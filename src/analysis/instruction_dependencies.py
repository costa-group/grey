"""
Module to compute the different dependencies among instructions
"""
from typing import List, Tuple
import networkx as nx
from parser.cfg_instruction import CFGInstruction
from global_params.types import var_id_T, expression_T, memory_instr_interval_T


# Methods to manipulate expressions

def get_interval(opcode_name, input_args):
    """
    Returns the memory interval associated to "opcode_name" with the arguments "input_args"
    """
    if opcode_name in ["keccak256", "log0", "log1", "log2", "log3", "log4"]:
        return [input_args[0], input_args[1]]
    elif opcode_name in ["codecopy", "calldatacopy", "returndatacopy", "mcopy"]:
        return [input_args[0], input_args[2]]
    elif opcode_name in ["extcodecopy"]:
        return [input_args[1], input_args[3]]
    elif opcode_name in ["create", "create2"]:
        return [input_args[1], input_args[2]]
    elif opcode_name in ["call", "callcode"]:
        return [[input_args[3], input_args[4]], [input_args[5], input_args[6]]]
    elif opcode_name in ["delegatecall", "staticcall"]:
        return [[input_args[2], input_args[3]], [input_args[4], input_args[5]]]


def get_expression(var: var_id_T, instructions) -> expression_T:
    """
    It returns the expression that an instruction takes as argument
    It returns an expression of the form:
    op -> opcode_name
    exp -> int_val | input_var | (op, [exp1, ..., expn])
    """
    # Case: constant
    if var.startswith("0x"):
        return int(var, 16)

    candidates = list(filter(lambda x: var in x.get_out_args(), instructions))

    # Case: variable not define in the set of instructions
    if len(candidates) == 0:
        return var
    assert all(candidates[i] == candidates[i + 1] for i in range(len(candidates) - 1)), \
        "[ERROR]: A variable cannot be generated by more than one instruction"
    # Case: build expression from subexpressions
    new_instruction = candidates[0]

    sub_expression = []
    for v in new_instruction.get_in_args():
        new_subexp = get_expression(v, instructions)
        sub_expression.append(new_subexp)

    return new_instruction.get_op_name(), sub_expression


def is_member_recursive(val: str, exp: expression_T) -> bool:
    # Checks whether the value val matches the expression
    if not isinstance(exp, tuple):
        return val == exp

    else:
        # We have to check the arguments
        for x in exp[1]:

            # Once we find it is a subterm, we stop the search
            if is_member_recursive(val, x):
                return True

        # TODO: ask Pablo this condition
        # result = result and x[0] in ["add", "mul", "sub", "div"]
        return False


def are_dependent_accesses(exp1: expression_T, exp2: expression_T) -> bool:
    """
    Checks whether the accesses of two expressions are dependent or not
    """
    val1 = exp1[0]
    val2 = exp2[0]

    # print(exp1)
    # print(exp2)

    if val1 == "inf" or val2 == "inf":
        return True
    elif isinstance(val1, int) and isinstance(val2, int):  # constants
        return val1 == val2
    elif isinstance(val1, str) and isinstance(val2, str):  # variables
        # print("Check with ssa")
        return True  # val1 == val2
    elif isinstance(val1, str) and isinstance(val2, tuple):  # One expression is contained in the other
        return not is_member_recursive(val1, val2)
    elif isinstance(val2, str) and isinstance(val1, tuple):
        return not is_member_recursive(val2, val1)
    else:
        return True


def are_dependent_interval(exp1: memory_instr_interval_T, exp2: memory_instr_interval_T) -> bool:
    """
    Checks whether two intervals can overlap (symbolically)
    """
    val1 = exp1[0]
    offset1 = exp1[1]

    val2 = exp2[0]
    offset2 = exp2[1]

    if all(isinstance(value, int) for value in [val1, offset1, val2, offset2]):  # all are constants
        return overlap(val1, offset1, val2, offset2)

    else:
        return True


def overlap(idx1: int, offset1: int, idx2: int, offset2: int) -> bool:
    """
    Checks whether two pairs of (index, offset) overlap or not
    """
    return idx1 <= idx2 < idx1 + offset1 or idx2 <= idx1 < idx2 + offset2


def generate_dep(t_ins1: str, t_ins2: str) -> bool:
    """
    Determines if there is a dependency among read and write accesses
    """
    return t_ins1 == "write" or t_ins2 == "write"


# Methods to compute dependencies

def compute_storage_dependences(instructions: List[CFGInstruction]) -> List[List[int]]:
    """
    Returns a list with the positions that have storage dependencies
    """
    sto_ins = []
    # print(instructions)
    for i, ins in enumerate(instructions):

        if ins.get_op_name() in ["sload", "sstore"]:
            v = ins.get_in_args()[0]
            input_val = get_expression(v, instructions[:i])

            # Store instructions have an empty offset
            interval = (input_val, 0)

            # We store the position of the store access, the position accessed and the type (whether write or read)
            sto_ins.append([i, interval, ins.get_type_mem_op()])

        elif ins.get_op_name() in ["call", "delegatecall", "staticcall", "callcode"]:
            sto_ins.append([i, ["inf"], "write"])

    deps = [[first_sto_access[0], second_sto_access[0]]
            for i, first_sto_access in enumerate(sto_ins) for second_sto_access in sto_ins[i + 1:]
            if are_dependent_accesses(first_sto_access[1], second_sto_access[1])
            and generate_dep(first_sto_access[2], second_sto_access[2])]

    # print("DEPS: "+str(deps))
    # print("******")
    return deps


def compute_transient_dependences(instructions: List[CFGInstruction]) -> List[List[int]]:
    """
    Returns a list with the positions that have storage dependencies
    """
    trans_ins = []
    # print(instructions)
    for i, ins in enumerate(instructions):

        if ins.get_op_name() in ["tload", "tstore"]:
            v = ins.get_in_args()[0]
            input_val = get_expression(v, instructions[:i])

            # Store instructions have an empty offset
            interval = (input_val, 0)

            # We store the position of the store access, the position accessed and the type (whether write or read)
            trans_ins.append([i, interval, ins.get_type_mem_op()])

        elif ins.get_op_name() in ["call", "delegatecall", "staticcall", "callcode"]:
            trans_ins.append([i, ["inf"], "write"])

    deps = [[first_sto_access[0], second_sto_access[0]]
            for i, first_sto_access in enumerate(trans_ins) for second_sto_access in trans_ins[i + 1:]
            if are_dependent_accesses(first_sto_access[1], second_sto_access[1])
            and generate_dep(first_sto_access[2], second_sto_access[2])]

    # print("DEPS: "+str(deps))
    # print("******")
    return deps




def compute_memory_dependences(instructions: List[CFGInstruction]):
    """
    Returns a list with the positions that have memory dependencies
    """
    mem_ins = []

    mem_instrs_access = ["mload", "mstore", "mstore8"]
    mem_instrs_offset = ["keccak256", "codecopy", "extcodecopy", "calldatacopy",
                         "returndatacopy", "mcopy", "log0", "log1", "log2", "log3", "log4",
                         "create", "create2", "call", "delegatecall", "staticcall", "callcode"]

    for i, ins in enumerate(instructions):

        if ins.get_op_name() in mem_instrs_access:
            v = ins.get_in_args()[0]
            input_val = get_expression(v, instructions[:i])
            interval = (input_val, 32)
            mem_ins.append([i, interval, ins.get_type_mem_op()])

        elif ins.get_op_name() == "assignimmutable":
            mem_ins.append([i, (0,"inf"), "write"])
            
        elif ins.get_op_name() in mem_instrs_offset:
            values = ins.get_in_args()
            interval_args = get_interval(ins.get_op_name(), values)

            if ins.get_op_name() not in ["call", "callcode", "delegatecall", "staticcall"]:
                input_vals = list(map(lambda x: get_expression(x, instructions[:i]), interval_args))
                interval = (input_vals[0], input_vals[1])
                mem_ins.append([i, interval, ins.get_type_mem_op()])

            else:
                input_vals = list(map(lambda x: get_expression(x, instructions[:i]), interval_args[0]))
                interval = [input_vals[0], input_vals[1]]
                mem_ins.append([i, interval, "read"])

                input_vals = list(map(lambda x: get_expression(x, instructions[:i]), interval_args[1]))
                interval = [input_vals[0], input_vals[1]]
                mem_ins.append([i, interval, "write"])

    deps = [[first_mem_ins[0], second_mem_ins[0]]
            for i, first_mem_ins in enumerate(mem_ins) for second_mem_ins in mem_ins[i + 1:]
            if first_mem_ins[0] != second_mem_ins[0] and generate_dep(first_mem_ins[2], second_mem_ins[2]) and
            are_dependent_interval(first_mem_ins[1], second_mem_ins[1])]

    # print("DEPS: "+str(deps))
    # print("******")
    return deps


def compute_gas_dependences(instructions: List[CFGInstruction]):

    gas_ins = []
    
    gas_instructions = ["gas"]
    for i, ins in enumerate(instructions):
        if ins.get_op_name() in gas_instructions:
            gas_ins.append(i)

    deps = [[first_gas_ins, second_gas_ins]
            for i, first_gas_ins in enumerate(gas_ins) for second_gas_ins in gas_ins[i + 1:]]

    return deps
                    

def simplify_dependences(deps: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
    dg = nx.DiGraph(deps)
    tr = nx.transitive_reduction(dg)
    return list(tr.edges)
