#!/usr/bin/env python3
import itertools
import json
import logging
import resource
import sys
import os
from typing import List, Dict, Tuple, Any, Set, Optional, Generator, Union
from collections import defaultdict, Counter
import traceback
from enum import Enum, unique

import networkx
import networkx as nx
# from analysis.greedy_validation import check_execution_from_ids
from global_params.types import var_id_T, instr_id_T, instr_JSON_T, SMS_T

# Specific type to identify which positions corresponds to the ones
# in the current and final stacks
cstack_pos_T = int
fstack_pos_T = int

# Annotation for the maximum stack depth that can be managed through operations
STACK_DEPTH = 16


def _simplify_graph_to_selected_nodes(graph: nx.DiGraph, selected_nodes: List) -> nx.DiGraph:
    """
    Auxiliary method that returns the transitive reduction of the graph that is generated by
    preserving the initial paths in the original path when restricted to the selected nodes
    """
    subgraph = nx.DiGraph()
    subgraph.add_nodes_from(selected_nodes)

    # Add edges based on reachability using BFS/DFS
    for u in selected_nodes:
        for v in selected_nodes:
            # Avoid self-loops and skips relations that have already been considered
            if u != v and not subgraph.has_edge(v, u):

                # Check if v is reachable from u in G using DFS
                reachable = nx.algorithms.dfs_predecessors(graph, source=u)
                if v in reachable:
                    subgraph.add_edge(u, v)

    # Step 4: Apply transitive reduction on the dynamically created subgraph
    subgraph_reduced = nx.transitive_reduction(subgraph)
    return subgraph_reduced


def idx_wrt_cstack(idx: fstack_pos_T, cstack: List, fstack: List) -> cstack_pos_T:
    """
    Given a position w.r.t fstack, returns the corresponding position w.r.t cstack
    """
    return idx - len(fstack) + len(cstack)


def idx_wrt_fstack(idx: cstack_pos_T, cstack: List, fstack: List) -> fstack_pos_T:
    """
    Given a position w.r.t cstack, returns the corresponding position w.r.t fstack
    """
    return idx - len(cstack) + len(fstack)


def top_relative_position_to_fstack(cstack: List[var_id_T], fstack: List[var_id_T]) -> int:
    return idx_wrt_fstack(0, cstack, fstack)


def extract_idx_from_id(instr_id: str) -> int:
    return int(instr_id.split('_')[-1])


def cheap(instr: instr_JSON_T) -> bool:
    """
    Cheap computations are those who take one instruction (i.e. inpt_sk is empty)
    """
    return len(instr['inpt_sk']) == 0 and instr["size"] <= 2


class SymbolicState:
    """
    A symbolic state includes a stack, a dict indicating the number of total uses of each instruction,
    the instructions that can be computed and the variables that must be duplicated
    """

    def __init__(self, initial_stack: List[var_id_T], dependency_graph: nx.DiGraph,
                 stack_var_copies_needed: Dict[var_id_T, int], user_instrs: List[instr_JSON_T],
                 final_stack: List[var_id_T]) -> None:
        self.debug_mode = True

        self.stack: List[var_id_T] = initial_stack.copy()
        self.final_stack: List[var_id_T] = final_stack # Not necessary to dup

        # The dependency graph with the instructions that can be computed due to
        # its arguments are already computed
        self.dep_graph: nx.DiGraph = dependency_graph.copy()

        # Terms that are cheap to compute
        self.cheap_terms_to_compute: Set[var_id_T] = {output_var for instr in user_instrs if cheap(instr)
                                                      for output_var in instr["outpt_sk"]}

        self.variables_to_dup: Set[var_id_T] = {stack_var for stack_var in initial_stack
                                                if stack_var_copies_needed[stack_var] > 0}

        self.stack_var_copies_needed: Dict[var_id_T, int] = stack_var_copies_needed.copy()

        # Solved: positions in the final stack that contain elements in the correct position
        self.solved: Set[fstack_pos_T] = {len(final_stack) - i - 1
                                          for i, (ini_var, fin_var) in enumerate(zip(reversed(initial_stack), reversed(final_stack)))
                                          if ini_var == fin_var}

        # Debug mode: store all the ops applied and the stacks before and after
        if self.debug_mode:
            self.trace: List[Tuple[List[var_id_T], instr_id_T]] = [(self.stack.copy(), "Initial")]

    @property
    def not_solved(self):
        return set(range(len(self.final_stack))).difference(self.solved)

    def _remove_solved(self, idx: fstack_pos_T):
        """
        Removes an element from the solved set, even if it is not there
        """
        try:
            self.solved.remove(idx)
        except KeyError:
            pass

    def _check_idx_solved_cstack(self, idx: cstack_pos_T):
        """
        Checks if the index in current stack is now solved or not
        """
        fstack_pos = self.idx_wrt_fstack(idx)
        self._remove_solved(fstack_pos)
        var_elem = self.stack[idx]
        if 0 <= fstack_pos < len(self.final_stack) and self.final_stack[fstack_pos] == var_elem:
            self.solved.add(fstack_pos)

    def idx_wrt_fstack(self, idx: cstack_pos_T) -> fstack_pos_T:
        """
        Conversion of the idx in the current stack to its corresponding position in the final stack
        """
        return idx_wrt_fstack(idx, self.stack, self.final_stack)

    def idx_wrt_cstack(self, idx: fstack_pos_T) -> cstack_pos_T:
        """
        Conversion of the idx in the final stack to its corresponding position in the current stack
        """

        return idx_wrt_cstack(idx, self.stack, self.final_stack)

    def swap(self, x: int) -> List[instr_id_T]:
        """
        Stores the top of the stack in the local with index x. in_position marks whether the element is
        solved in flocals
        """
        assert 0 <= x < len(self.stack), f"Swapping with index {x} a stack of {len(self.stack)} elements: {self.stack}"
        self.stack[0], self.stack[x] = self.stack[x], self.stack[0]

        # Var copies: no modification, as we are just moving two elements

        # Solved: Check if either positions 0 or x are solved
        self._check_idx_solved_cstack(0)
        self._check_idx_solved_cstack(x)

        if self.debug_mode:
            self.trace.append((self.stack.copy(), f"SWAP{x}"))

        return [f"SWAP{x}"]

    def dup(self, x: int) -> List[instr_id_T]:
        """
        Tee instruction in local with index x. in_position marks whether the element is solved in flocals
        """
        idx = x - 1
        assert 0 <= idx < len(self.stack), \
            f"Duplicating index {x} in a stack in {len(self.stack)} elements: {self.stack}"
        new_topmost = self.stack[idx]
        self.stack.insert(0, new_topmost)

        # Var copies: we increment the element that we have duplicated
        self.stack_var_copies_needed[new_topmost] -= 1

        # Variables to dup: remove the element from this list if we have computed all the copies
        if self.stack_var_copies_needed[new_topmost] == 0:
            self.variables_to_dup.remove(new_topmost)

        # Solved: only the duplicated element can modify the solved elements, being added if
        # in the new topmost element is correctly placed
        fstack_idx = self.idx_wrt_fstack(0)

        if fstack_idx >= 0 and self.final_stack[fstack_idx] == new_topmost:
            self.solved.add(fstack_idx)

        if self.debug_mode:
            self.trace.append((self.stack.copy(), f"DUP{x}"))

        return [f"DUP{x}"]

    def pop(self) -> List[instr_id_T]:
        """
        Drops the last element
        """
        stack_var = self.stack.pop(0)

        # Var copies: we add one because the stack var is totally removed from the encoding
        self.stack_var_copies_needed[stack_var] += 1

        # Solved: just check whether the old topmost position was in solved
        self._remove_solved(self.idx_wrt_fstack(-1))

        if self.debug_mode:
            self.trace.append((self.stack.copy(), "POP"))

        return ["POP"]

    def consume_element(self) -> var_id_T:
        """
        Consumes element in order to compute an instruction
        """
        stack_var = self.stack.pop(0)

        # Var copies: it is not affected, as we are just consuming the elements for an operation

        # Solved: just check whether the old topmost position was in solved
        self._remove_solved(self.idx_wrt_fstack(-1))

        return stack_var

    def insert_element(self, instr: instr_JSON_T, output_var: var_id_T) -> None:
        """
        Insert an element as a result of computing an instruction
        """
        self.stack.insert(0, output_var)

        # Var copies: remove one, as we have introduced a stack variable
        self.stack_var_copies_needed[output_var] -= 1

        # First case: cheap instructions just require to remove the element from the cheap instructions
        # if we have computed the necessary number of copies
        if cheap(instr):
            if self.stack_var_copies_needed[output_var] == 0:
                self.cheap_terms_to_compute.remove(output_var)
        else:
            # Second case: we add the produced terms that need to be
            # duplicated to the corresponding list
            if self.stack_var_copies_needed[output_var] > 0:
                self.variables_to_dup.add(output_var)

        # Solved: only the introduced element can modify the solved elements, being added if
        # in the new topmost element is correctly placed
        fstack_idx = self.idx_wrt_fstack(0)

        if fstack_idx >= 0 and self.final_stack[fstack_idx] == output_var:
            self.solved.add(fstack_idx)

    def uf(self, instr: instr_JSON_T) -> List[instr_id_T]:
        """
        Symbolic execution of instruction instr. Additionally, checks the arguments match if debug mode flag is enabled
        """
        consumed_elements = [self.consume_element() for _ in range(len(instr['inpt_sk']))]

        # Neither liveness nor var uses are affected by consuming elements, as these elements are just being embedded
        # into a new term
        # Debug mode to check the pop args from the stack match
        if self.debug_mode:
            if instr['commutative']:
                # Compare them as multisets
                assert Counter(consumed_elements) == Counter(instr['inpt_sk']), \
                    f"{instr['id']} is not consuming the correct elements from the stack"
            else:
                # Compare them as lists
                assert consumed_elements == instr['inpt_sk'], \
                    f"{instr['id']} is not consuming the correct elements from the stack.\n" \
                    f"Consumed elements: {consumed_elements}\nRequired elements: {instr['inpt_sk']}"

        # We introduce the new elements
        for output_var in instr['outpt_sk']:
            self.insert_element(instr, output_var)

        if not cheap(instr):
            self.dep_graph.remove_node(instr["id"])

        if self.debug_mode:
            self.trace.append((self.stack.copy(), instr["id"]))

        return [instr["id"]]

    def from_memory(self, var_elem: var_id_T) -> List[instr_id_T]:
        """
        Assumes the value is retrieved from memory
        """
        self.stack.insert(0, var_elem)

        # Var uses: we increment the element that we have retrieved from memory
        self.stack_var_copies_needed[var_elem] -= 1

        # Solved: same as duplication
        fstack_idx = self.idx_wrt_fstack(0)

        if fstack_idx >= 0 and self.final_stack[fstack_idx] == var_elem:
            self.solved.add(fstack_idx)

        if self.debug_mode:
            self.trace.append((self.stack.copy(), f"MEM({var_elem})"))

        return [f"MEM({var_elem})"]

    def top_stack(self) -> Optional[var_id_T]:
        return None if len(self.stack) == 0 else self.stack[0]

    def negative_idx2positive(self, idx: int) -> int:
        """
        Converts a negative index (-1 from the last element and so on) to the corresponding positive one
        """
        positive_idx = idx + len(self.stack)
        assert -1 <= positive_idx < len(self.stack), f"Attempting to convert an invalid negative index {idx}, " \
                                                     f"in a stack with {len(self.stack)} elements"
        return positive_idx

    def positive_idx2negative(self, idx: int) -> int:
        """
        Converts a positive index to the corresponding positive one (-1 to the last one and so on).
        It allows the index -1
        """
        negative_idx = idx - len(self.stack)
        assert 0 > negative_idx >= -len(self.stack) - 1, f"Attempting to convert an invalid positive index {idx}, " \
                                                         f"in a stack with {len(self.stack)} elements"
        return negative_idx

    def is_accessible_swap(self, var_elem: var_id_T) -> bool:
        """
        Checks whether the variable element can be accessed for a swap instruction
        """
        return self.stack.index(var_elem) <= STACK_DEPTH

    def is_accessible_dup(self, var_elem: var_id_T) -> bool:
        """
        Checks whether the variable element can be accessed for a dup instruction
        """
        return self.stack.index(var_elem) < STACK_DEPTH

    def first_occurrence(self, var_elem: var_id_T) -> int:
        """
        Returns the first position in which the element appears
        """
        try:
            return self.stack.index(var_elem)
        except:
            return -1

    def last_occurrence(self, var_elem: var_id_T) -> int:
        """
        Returns the last position in which the element appears
        """
        for idx, stack_elem in enumerate(self.stack[::-1]):
            if stack_elem == var_elem:
                return len(self.stack) - 1 - idx
        return -1

    def last_swap_occurrence(self, var_elem: var_id_T) -> int:
        """
        Returns the last accessible position in which the element appears and can be swapped
        """
        current_idx = min(STACK_DEPTH, len(self.stack) - 1)

        while current_idx > 0:
            stack_elem = self.stack[current_idx]

            # Find the last occurrence in which the element is not placed in its position
            if stack_elem == var_elem and self.idx_wrt_fstack(current_idx) != var_elem:
                return current_idx
            current_idx -= 1

        return -1

    def has_computations(self):
        """
        Checks if the current state has still computations left to do
        """
        # TODO: remove elements once they have 0 copies left and just check length
        return any(value > 0 for value in self.stack_var_copies_needed.values()) or len(self.dep_graph) > 0

    def candidates(self) -> Tuple[List[instr_id_T], Set[var_id_T], Set[var_id_T]]:
        """
        Returns the possible candidates from the pool of available instructions, cheap instructions
        and stack variables that are needed to be duplicated
        """
        return [id_ for id_ in self.dep_graph.nodes if self.dep_graph.out_degree(id_) == 0], \
            self.cheap_terms_to_compute, self.variables_to_dup

    def __repr__(self):
        return str(self.stack)


class SMSgreedy:

    def __init__(self, json_format: SMS_T):
        self.debug_mode: bool = True
        # How many elements are placed in the correct position and cannot be moved further in a computation
        self.fixed_elements: int = 0
        self._user_instr: List[instr_JSON_T] = json_format['user_instrs']
        self._initial_stack: List[var_id_T] = json_format['src_ws']
        self._final_stack: List[var_id_T] = json_format['tgt_ws']
        self._deps: List[Tuple[var_id_T, var_id_T]] = json_format['dependencies']
        self.debug_logger = DebugLogger()

        # Note: we assume function invocations might have several variables in 'outpt_sk'
        self._var2instr = {var: ins for ins in self._user_instr for var in ins['outpt_sk']}
        self._id2instr = {ins['id']: ins for ins in self._user_instr}
        self._var2id = {var: ins['id'] for ins in self._user_instr for var in ins['outpt_sk']}
        self._var2pos_stack = self._compute_var2pos(self._final_stack)
        self._instrs_with_deps = {instr_id for dep in self._deps for instr_id in dep}

        self._stack_var_copies_needed = self._compute_var_total_uses()
        self._dep_graph = self._compute_dependency_graph()

        # Determine which topmost elements can be reused in the graph
        self._top_can_be_used = {}

        for instr in self._user_instr:
            self._compute_top_can_used(instr, self._top_can_be_used)

    def _compute_var_total_uses(self) -> Dict[var_id_T, int]:
        """
        Computes how many times each var must be computed due to appearing either in the final stack or as a subterm
        for other terms. It can be negative for stack variables that must be popped
        """
        var_uses = defaultdict(lambda: 0)

        for var_stack in self._initial_stack:
            var_uses[var_stack] -= 1

        # Count vars in the final stack
        for var_stack in self._final_stack:
            var_uses[var_stack] += 1

        # Count vars as input of other instrs
        for instr_id, instr in self._id2instr.items():
            for subterm_var in instr['inpt_sk']:
                var_uses[subterm_var] += 1

        return var_uses

    def _compute_var2pos(self, var_list: List[var_id_T]) -> Dict[var_id_T, List[int]]:
        """
        Dict that links each stack variable that appears in a var list to the
        list of positions it occupies
        """
        var2pos = defaultdict(lambda: [])

        for i, stack_var in enumerate(var_list):
            var2pos[stack_var].append(i)

        return var2pos

    def _compute_dependency_graph(self) -> nx.DiGraph:
        """
        We generate two dependency graphs: one for direct relations (i.e. one term embedded into another)
        and other with the dependencies due to memory/storage accesses
        """
        graph = nx.DiGraph()

        for instr in self._user_instr:
            instr_id = instr['id']
            graph.add_node(instr_id)

            for stack_elem in instr['inpt_sk']:
                # This means the stack element corresponds to another uninterpreted instruction
                associated_instr = self._var2instr.get(stack_elem, None)
                if associated_instr and not cheap(associated_instr):
                    graph.add_edge(instr_id, self._var2id[stack_elem])

        # We need to consider also the order given by the tuples
        for id1, id2 in self._deps:
            graph.add_edge(id2, id1)

        return graph

    def _compute_top_can_used(self, instr: instr_JSON_T, top_can_be_used: Dict[var_id_T, Set[var_id_T]]) -> Set[
        var_id_T]:
        """
        Computes for each instruction if the topmost element of the stack can be reused directly
        at some point. It considers commutative operations
        """
        reused_elements = top_can_be_used.get(instr["id"], None)
        if reused_elements is not None:
            return reused_elements

        current_uses = set()
        comm = instr["commutative"]
        first_element = True
        for stack_var in reversed(instr["inpt_sk"]):
            # We only consider the first element if the operation is not commutative, or both elements otherwise
            if comm or first_element:
                instr_bef = self._var2instr.get(stack_var, None)
                if instr_bef is not None:
                    instr_bef_id = instr_bef["id"]
                    if instr_bef_id not in top_can_be_used:
                        current_uses.update(self._compute_top_can_used(instr_bef, top_can_be_used))
                    else:
                        current_uses.update(top_can_be_used[instr_bef_id])
                    # Add only instructions that are relevant to our context
                    current_uses.add(stack_var)
            else:
                break
            first_element = False

        top_can_be_used[instr["id"]] = current_uses
        return current_uses

    def greedy(self) -> List[instr_id_T]:
        """
        Main implementation of the greedy algorithm (i.e. the instruction scheduling algorithm)
        """
        cstate: SymbolicState = SymbolicState(self._initial_stack, self._dep_graph, self._stack_var_copies_needed,
                                              self._user_instr, self._final_stack)
        optg = []

        self.debug_logger.debug_initial(cstate.dep_graph.nodes)

        # For easier code, we end the while when we need to choose an
        # operation and there are no operations left
        while True:
            var_top = cstate.top_stack()
            self.fixed_elements = 0

            self.debug_logger.debug_loop(cstate.dep_graph, optg, cstate)

            # Case 1: Top of the stack must be removed, as it appears more time it is being used
            if var_top is not None and cstate.stack_var_copies_needed[var_top] < 0:
                self.debug_logger.debug_pop(var_top, cstate)
                optg.extend(cstate.pop())

            # Case 2: Top of the stack must be placed in some other position
            elif var_top is not None and (move_information := self.var_must_be_moved(var_top, cstate)) \
                    and move_information[0]:
                self.debug_logger.debug_move_var(var_top, move_information[1], cstate)
                optg.extend(cstate.swap(move_information[1]))

            # Case 3: Top of the stack cannot be moved to the corresponding position.
            # Hence, we just generate the following computation
            else:
                # There are no operations left to choose, so we stop the search
                if not cstate.has_computations():
                    break

                next_id, how_to_compute = self.choose_next_computation(cstate)
                self.debug_logger.debug_choose_computation(next_id, how_to_compute, cstate)

                if how_to_compute == "instr":
                    next_instr = self._id2instr[next_id]
                    ops = self.compute_instr(next_instr, cstate)
                else:
                    ops = self.compute_var(next_id, cstate)

                optg.extend(ops)

        optg.extend(self.solve_permutation(cstate))
        self.debug_logger.debug_after_permutation(cstate, optg)

        self.print_traces(cstate)
        return optg

    def _available_positions(self, var_elem: var_id_T, cstate: SymbolicState) -> Generator[cstack_pos_T, None, None]:
        """
        Generator for the set of available positions in cstack where the var element can be placed
        """
        # We just need to check that the positions in which the element appears in the
        # final stack are in range and not contain the element
        for position in reversed(self._var2pos_stack[var_elem]):
            fidx = idx_wrt_cstack(position, cstate.stack, self._final_stack)

            # When the index is negative, it means there are not enough elements in cstack
            # to place the corresponding element
            if fidx < 0:
                break

            # A variable must be moved when a positive index is found (less than STACK_DEPTH)
            # which does not contain yet the corresponding element
            elif STACK_DEPTH >= fidx >= 0 and fidx < len(cstate.stack) and cstate.stack[fidx] != var_elem:
                yield fidx

    def _deepest_position(self, var_elem: var_id_T) -> Optional[int]:
        """
        Deepest position in the final stack of var_elem (if any). Used to determine which computation is chosen first
        """
        return self._var2pos_stack[var_elem][-1] if len(self._var2pos_stack[var_elem]) > 0 else None

    def var_must_be_moved(self, var_elem: var_id_T, cstate: SymbolicState) -> Tuple[bool, int]:
        """
        By construction, a var element must be moved if there is an available position in which it
        appears in the final stack (and it is not yet in its position). Return whether it is possible to
        perform the movement and the position the var element must be placed
        """
        topmost_idx_fstack = idx_wrt_fstack(0, cstate.stack, self._final_stack)
        # Condition: the topmost element is not placed in its corresponding position yet
        if topmost_idx_fstack < 0 or self._final_stack[topmost_idx_fstack] != var_elem:
            # Find the first position to which it can be moved
            next_available_pos = next(self._available_positions(var_elem, cstate), None)
            return next_available_pos is not None, next_available_pos
        return False, -1

    def choose_next_computation(self, cstate: SymbolicState) -> Tuple[Union[instr_id_T, var_id_T], str]:
        """
        Returns either a stack element or an instruction that must be computed
        """
        candidate = self._select_candidate(cstate)
        return candidate

    def _select_candidate(self, cstate: SymbolicState) -> Tuple[Union[instr_id_T, var_id_T], str]:
        """
        Decides which stack variable or instruction must be computed using a scoring system
        """
        new_instr, cheap_stack_elems, dup_stack_elems = cstate.candidates()
        current_top = cstate.top_stack()
        best_candidate_score = [-1]
        candidate = None

        # TODO: pass candidates as arguments
        option = self._handle_too_deep(cstate)

        # First case: too deep scenario
        if option is not None:
            return option

        # The topmost element can be used if it does not need to be duplicated further
        top_can_be_reused = current_top is not None and cstate.stack_var_copies_needed[current_top] == 0

        # First, we evaluate the remaining instructions
        for id_ in new_instr:
            score_id = self._score_instr(self._id2instr[id_], cstate, top_can_be_reused)

            # To decide whether the current candidate is the best so far, we use the information from deepest_pos
            # and reuses_pos
            better_candidate = score_id > best_candidate_score
            if better_candidate:
                candidate = id_
                best_candidate_score = score_id

            self.debug_logger.debug_rank_candidates(id_, score_id, better_candidate)

        # If the best candidate does not reuse the topmost element, we also try duplicating already existing elements
        # or cheap computations
        if best_candidate_score[0] <= 0:
            # Search among the positions not solved that are deepest than the one in the best candidate
            deepest_position = best_candidate_score[3] if len(best_candidate_score) == 4 else -1
            for position_not_solved in sorted(cstate.not_solved, reverse=True):

                if position_not_solved < deepest_position:
                    break

                associated_stack_var = self._final_stack[position_not_solved]
                if associated_stack_var in cheap_stack_elems or associated_stack_var in dup_stack_elems:
                    return associated_stack_var, "var"

        assert candidate is not None, "Loop of _score_candidate must assign one candidate"
        return candidate, "instr"

    def _handle_too_deep(self, cstate: SymbolicState) -> Optional[Tuple[Union[instr_id_T, var_id_T], str]]:
        new_instr, cheap_stack_elems, dup_stack_elems = cstate.candidates()

        if len(cstate.not_solved) == 0:
            return None

        # First, we detect if there is an element that is about to become unreachable (and prioritize computing
        # this element)
        max_not_solved_pos = cstate.idx_wrt_cstack(max(cstate.not_solved))
        if max_not_solved_pos > STACK_DEPTH:
            # TODO: handle this case
            raise AssertionError("There is a position that cannot be accessed and whose stack element is not "
                                 f"correctly placed\nPosition: {max_not_solved_pos}\nStack: {cstate.stack}\n"
                                 f"Final stack: {self._final_stack}")
        elif STACK_DEPTH - 2 <= max_not_solved_pos <= STACK_DEPTH:
            # Returns either the instruction (if not computed yet) or the stack variable
            # of the stack element associated to the instruction
            final_stack_var = self._final_stack[max_not_solved_pos]

            if final_stack_var in dup_stack_elems:
                return final_stack_var, "var"

            elif final_stack_var in cheap_stack_elems or cstate.dep_graph.out_degree(self._var2instr[final_stack_var]) == 0:
                return self._var2instr[final_stack_var], "instr"

            else:
                raise ValueError("Case not handled: Swap the element to the position")

        return None

    def _score_instr(self, instr: instr_JSON_T, cstate: SymbolicState, top_can_reused: bool) -> Tuple[int, int, int, int]:
        """
        We score the instructions according to the following lexicographic order:
        1) Can reuse the topmost element
        2) Number of stack elements that can consume by swapping
        3) Deepest position that needs to access. If > STACK_DEPTH, then, we assign to -1
        4) Deepest position in which one of the produced stack vars can be consumed
        """
        can_reuse_topmost = int(top_can_reused and self._top_can_be_used.get(cstate.top_stack(), False))
        n_swappable = 0
        max_pos = -1

        # From the input stack, retrieves how many stack elements can be consumed by swapping
        # and the deepest position needed to access
        for input_var in instr['inpt_sk']:

            # Does not need to be duplicated
            if cstate.stack_var_copies_needed[input_var] == 0:
                swap_position = cstate.last_swap_occurrence(input_var)
                if swap_position != -1:
                    n_swappable += 1
                max_pos = max(max_pos, swap_position)
            else:
                max_pos = max(max_pos, cstate.first_occurrence(input_var))

        deepest_to_place = -1
        # Function invocations might generate multiple values that we should take into account
        for out_var in instr['outpt_sk']:
            # We detect which is the deepest position in which the element can be placed
            deepest_position = self._deepest_position(out_var)
            if deepest_position is not None:
                deepest_to_place = max(deepest_position, deepest_to_place)

        return [can_reuse_topmost, n_swappable, max_pos, deepest_to_place]

    def compute_instr(self, instr: instr_JSON_T, cstate: SymbolicState) -> List[instr_id_T]:
        """
        Given an instr, the current state and the terms that need to be duplicated, computes the corresponding term.
        This function is separated from compute_op because there
        are terms, such as var accesses or memory accesses that produce no var element as a result.
        """
        self.debug_logger.debug_compute_instr(instr, cstate)

        seq = []

        # Decide in which order computations must be done (after computing the subterms)
        input_vars = self._computation_order(instr, cstate)
        initial_idx = self.decide_fixed_elements(cstate, list(reversed(input_vars)))
        self.debug_logger.debug_message(f"Assuming elements are placed from index: {initial_idx}")
        first_element = True

        for i, stack_var in enumerate(input_vars):
            # The initial index is negative
            top_elem = cstate.top_stack()
            # If we can reuse the first element and this element must be not consumed elsewhere
            if first_element and top_elem is not None and top_elem == stack_var and \
                    cstate.stack_var_copies_needed[top_elem] == 0:
                self.fixed_elements += 1
            else:
                # Otherwise, we must return generate it with a recursive call
                seq.extend(self.compute_var(stack_var, cstate))

            first_element = False

        # Finally, we compute the element
        seq.extend(cstate.uf(instr))

        # Update the number of fixed elements afterwards
        self.fixed_elements -= len(instr['inpt_sk'])
        self.fixed_elements += len(instr['outpt_sk'])
        return seq

    def _computation_order(self, instr: instr_JSON_T, cstate: SymbolicState) -> List[var_id_T]:
        """
        Decides in which order the arguments of the instruction must be computed
        """
        if instr['commutative']:
            # If it's commutative, study its dependencies.
            if self.debug_mode:
                assert len(instr['inpt_sk']) == 2, \
                    f'Commutative instruction {instr["id"]} has arity != 2'

            # Condition: the top of the stack can be reused
            topmost_element = cstate.top_stack()
            first_arg_instr = self._var2instr.get(instr['inpt_sk'][0], None)

            # Condition1: the topmost element can be reused by the first argument instruction or is the first argument
            condition1 = (topmost_element is not None and topmost_element in self._top_can_be_used[instr["id"]] and
                          first_arg_instr is not None and (first_arg_instr["outpt_sk"][0] == topmost_element or
                                                           topmost_element in self._top_can_be_used[first_arg_instr["id"]]))

            # Condition2: the first argument just needs to be swapped
            condition2 = cstate.stack_var_copies_needed[instr['inpt_sk'][0]] == 0
            if condition1 or condition2:
                input_vars = instr['inpt_sk']
            else:
                input_vars = list(reversed(instr['inpt_sk']))
        else:
            input_vars = list(reversed(instr['inpt_sk']))
        return input_vars

    def decide_fixed_elements(self, cstate: SymbolicState, input_vars: List[var_id_T]):
        """
        Decides from which position in the current stack we are computing the arguments of the corresponding element,
        expressed in a negative index (from the bottom). Assumes the input vars are given from top to bottom
        """
        # TODO: (possibly) combine with computation order and make it more efficient based on KMP
        # We start from
        best_possibility = 0
        best_idx = cstate.positive_idx2negative(-1)
        idx = min(len(input_vars), len(cstate.stack)) - 1

        self.debug_logger.debug_message(f"FFF: {input_vars} {cstate.stack}")

        while idx >= 0:
            stack_idx, input_idx, count = idx, len(input_vars) - 1, 0
            while stack_idx >= 0 and input_idx >= 0:
                # We can reuse the element
                # TODO: decide if we consider whether some of the positions are solved or not
                if cstate.stack[stack_idx] == input_vars[input_idx] and \
                        cstate.stack_var_copies_needed[input_vars[input_idx]] == 0:
                    count += 1
                input_idx -= 1
                stack_idx -= 1

            if count > best_possibility:
                best_idx = cstate.positive_idx2negative(idx)
                best_possibility = count

            idx -= 1

        # Last case: if there is no better alternative, we just consider whether to consider the first element to
        # be swapped with the first element to consume
        if best_idx == -1:
            if cstate.stack_var_copies_needed[input_vars[-1]] == 0 and cstate.is_accessible_swap(input_vars[-1]):
                return cstate.positive_idx2negative(0)

        return best_idx

    def compute_var(self, var_elem: var_id_T, cstate: SymbolicState) -> List[instr_id_T]:
        """
        Given a stack_var and current state, computes the element and updates cstate accordingly. Returns the sequence of ids.
        Compute var considers it the var elem is already stored in the stack
        """
        self.debug_logger.debug_compute_var(var_elem, cstate)
        # First case: the element has not been computed previously. We have to compute it, as it
        # corresponds to a stack variable
        instr = self._var2instr.get(var_elem, None)
        if instr is not None and instr["id"] in cstate.dep_graph and cstate.stack_var_copies_needed[var_elem] == 0:
            seq = self.compute_instr(instr, cstate)

        # Second case: the variable has already been computed (i.e. var_uses > 0).
        # In this case, we duplicate it or retrieve it from memory
        else:

            # If the instruction is cheap, we compute it again
            instr = self._var2instr.get(var_elem, None)
            if instr is not None and cheap(instr):
                seq = self.compute_instr(instr, cstate)
            else:
                assert var_elem in cstate.stack, f"Variable {var_elem} must appear in the stack, " \
                                                 f"as it was previously computed and it is not a cheap computation"
                # TODO: case for recomputing the element?
                # Case I: We swap the element the number of copies required is met, the position is accessible
                # and there is no fixed stack elements
                if cstate.is_accessible_swap(var_elem) and cstate.stack_var_copies_needed[var_elem] == 0 \
                        and self.fixed_elements == 0:
                    # We swap to the deepest accesible copy
                    idx = cstate.last_swap_occurrence(var_elem)
                    seq = cstate.swap(idx)
                    self.debug_logger.debug_message(f"SWAP{idx} {cstate.stack}")

                # Case II: we duplicate the element that is within reach
                elif cstate.is_accessible_dup(var_elem):
                    idx = cstate.first_occurrence(var_elem) + 1
                    seq = cstate.dup(idx)
                    self.debug_logger.debug_message(f"DUP{idx} {cstate.stack}")

                # Case III: we retrieve the element from memory
                else:
                    seq = cstate.from_memory(var_elem)

                # We have computed the corresponding element
                self.fixed_elements += 1

        return seq

    def solve_permutation(self, cstate: SymbolicState) -> List[instr_id_T]:
        """
        Places all the elements in their corresponding positions
        """
        # TODO: complete code
        return []

    def print_traces(self, cstate: SymbolicState) -> None:
        """
        Prints the traces so far from the current state. Debug mode must be activated
        """
        if cstate.debug_mode:
            list_strings = [str(t[0]) for t in cstate.trace]
            max_list_len = max(len(ls) for ls in list_strings)

            # Calculate the maximum length of the string part
            max_str_len = max(len(t[1]) for t in cstate.trace)

            # Print each tuple with aligned formatting
            for (lst, string), list_str in zip(cstate.trace, list_strings):
                print(f"{string:<{max_str_len}} {list_str:>{max_list_len}}")


class DebugLogger:
    """
    Class that contains the multiple debugging messages for the greedy algorithm
    """

    def __init__(self):
        self._logger = logging.getLogger("greedy")

    def debug_initial(self, ops: List[instr_id_T]):
        self._logger.debug("---- Initial Ops ----")
        self._logger.debug(f'Ops:{ops}')
        self._logger.debug("")

    def debug_loop(self, dep_graph, optg: List[instr_id_T],
                   cstate: SymbolicState):
        self._logger.debug("---- While loop ----")
        self._logger.debug(f"Ops not computed {list(dep_graph.nodes)}")
        self._logger.debug(f"Ops computed: {optg}")
        self._logger.debug(cstate)
        self._logger.debug("")

    def debug_pop(self, var_top: var_id_T, cstate: SymbolicState):
        self._logger.debug("---- Drop term ----")
        self._logger.debug(f"Var Term: {var_top}")
        self._logger.debug(f'State {cstate}')
        self._logger.debug("")

    def debug_move_var(self, var_top: var_id_T, position: int, cstate: SymbolicState):
        self._logger.debug("---- Move var to position ----")
        self._logger.debug(f"Var Term: {var_top}")
        self._logger.debug(f"Position: {position}")
        self._logger.debug(f'State {cstate}')
        self._logger.debug("")

    def debug_rank_candidates(self, candidate: instr_id_T, candidate_score: Tuple[bool, Dict[var_id_T, int]],
                              chosen: bool):
        self._logger.debug("---- Score candidate ----")
        self._logger.debug(f"Candidate {candidate}")
        self._logger.debug(f'Candidate score {candidate_score}')
        self._logger.debug("Candidate has been chosen" if chosen else "Candidate does not improve")
        self._logger.debug("")

    def debug_choose_computation(self, next_id: instr_id_T, how_to_compute: str, cstate: SymbolicState):
        self._logger.debug("---- Computation chosen ----")
        self._logger.debug(f"Computation method {how_to_compute}")
        self._logger.debug(next_id)
        self._logger.debug(cstate)
        self._logger.debug("")

    def debug_compute_instr(self, instr: instr_JSON_T, cstate: SymbolicState):
        self._logger.debug("---- Computing instr ----")
        self._logger.debug(instr)
        self._logger.debug(f"Stack: {cstate.stack}")
        self._logger.debug("")

    def debug_compute_var(self, var: var_id_T, cstate: SymbolicState):
        self._logger.debug("---- Computing variable ----")
        self._logger.debug(var)
        self._logger.debug(f"Stack: {cstate.stack}")
        self._logger.debug("")

    def debug_after_permutation(self, cstate: SymbolicState, optg: List[instr_id_T]):
        self._logger.debug("---- State after solving permutation ----")
        self._logger.debug(cstate)
        self._logger.debug(optg)
        self._logger.debug("")

    def debug_message(self, message: str):
        self._logger.debug(message)


def greedy_standalone(sms: Dict) -> Tuple[str, float, List[str]]:
    """
    Executes the greedy algorithm as a standalone configuration. Returns whether the execution has been
    sucessful or not ("non_optimal" or "error"), the total time and the sequence of ids returned.
    """
    error = 0
    usage_start = resource.getrusage(resource.RUSAGE_SELF)
    try:
        seq_ids = SMSgreedy(sms).greedy()
        usage_stop = resource.getrusage(resource.RUSAGE_SELF)
    except Exception as e:
        usage_stop = resource.getrusage(resource.RUSAGE_SELF)
        _, _, tb = sys.exc_info()
        traceback.print_tb(tb)
        print(e, file=sys.stderr)
        error = 1
        seq_ids = []
    optimization_outcome = "error" if error == 1 else "non_optimal"
    return optimization_outcome, usage_stop.ru_utime + usage_stop.ru_stime - usage_start.ru_utime - usage_start.ru_stime, seq_ids


def greedy_from_file(filename: str) -> Tuple[SMS_T, List[instr_id_T]]:
    logging.basicConfig(level=logging.DEBUG)
    with open(filename, "r") as f:
        sfs = json.load(f)
    outcome, time, ids = greedy_standalone(sfs)
    return sfs, ids


if __name__ == "__main__":
    greedy_from_file(sys.argv[1])
