{
    "language": "Solidity",
    "sources": {
        "offset_overflow_in_array_decoding_2.sol": {
            "content": "pragma abicoder v2;\ncontract Test {\n\tstruct MemoryTuple {\n\t\tuint field1;\n\t\tuint field2;\n\t}\n\tfunction withinArray() public pure returns (uint) {\n\t\tuint[] memory before = new uint[](1);\n\t\tbytes memory corrupt = abi.encode(uint(32),\n\t\t\t\t\t\t\t\t\t\t  uint(2));\n\t\tMemoryTuple memory afterCorrupt;\n\t\tbefore[0] = 123456;\n\t\t/*\n\t\t  As above, but in this case we are adding to:\n\t\t  0x80 + 64 (before) + 32 (length of corrupt) + 32 (offset) + 32 (field pointer)\n\t\t  giving MAX_UINT - 96\n\t\t*/\n\t\tafterCorrupt.field1 = uint(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60);\n\t\tafterCorrupt.field2 = uint(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60);\n\t\tuint[][] memory decoded = abi.decode(corrupt, (uint[][]));\n\t\t/*\n\t\t  Will return 123456 * 2, AKA before has been copied twice\n\t\t */\n\t\treturn decoded[0][0] + decoded[1][0];\n\t}\n}\n// ----\n// withinArray() -> FAILURE\n"
        },
        "abi_encode_with_signaturev2.sol": {
            "content": "pragma abicoder v2;\ncontract C {\n    function f0() public pure returns (bytes memory) {\n        return abi.encodeWithSignature(\"f(uint256)\");\n    }\n    function f1() public pure returns (bytes memory) {\n        string memory x = \"f(uint256)\";\n        return abi.encodeWithSignature(x, \"abc\");\n    }\n    string xstor;\n    function f1s() public returns (bytes memory) {\n        xstor = \"f(uint256)\";\n        return abi.encodeWithSignature(xstor, \"abc\");\n    }\n    function f2() public pure returns (bytes memory r, uint[] memory ar) {\n        string memory x = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\";\n        uint[] memory y = new uint[](4);\n        y[0] = type(uint).max;\n        y[1] = type(uint).max - 1;\n        y[2] = type(uint).max - 2;\n        y[3] = type(uint).max - 3;\n        r = abi.encodeWithSignature(x, y);\n        // The hash uses temporary memory. This allocation re-uses the memory\n        // and should initialize it properly.\n        ar = new uint[](2);\n    }\n    struct S { uint a; string b; uint16 c; }\n    function f4() public pure returns (bytes memory) {\n        S memory s;\n        s.a = 0x1234567;\n        s.b = \"Lorem ipsum dolor sit ethereum........\";\n        s.c = 0x1234;\n        return abi.encodeWithSignature(s.b, type(uint).max, s, uint(3));\n    }\n}\n// ----\n// f0() -> 0x20, 4, -34435155370463444793260793355178157075203752403645521721995013737368954863616\n// f1() -> 0x20, 0x64, -34435155370463444793260793355178157075203752403645521721995013737368954863616, 862718293348820473429344482784628181556388621521298319395315527974912, 91135606241822717681769169345594720818313984248279388438121731325952, 0\n// f1s() -> 0x20, 0x64, -34435155370463444793260793355178157075203752403645521721995013737368954863616, 862718293348820473429344482784628181556388621521298319395315527974912, 91135606241822717681769169345594720818313984248279388438121731325952, 0\n// f2() -> 0x40, 0x0140, 0xc4, -10047825972976160827854069633043429618646681939320956771263895477211642200064, 862718293348820473429344482784628181556388621521298319395315527974912, 0x04ffffffffffffffffffffffffffffffffffffffffffffffffffffffff, -1, -26959946667150639794667015087019630673637144422540572481103610249217, -53919893334301279589334030174039261347274288845081144962207220498433, -107839786668602559178668060348078522694548577690162289924414440996864, 2, 0, 0\n// f4() -> 0x20, 292, 0x7c793002ffffffffffffffffffffffffffffffffffffffffffffffffffffffff, -26959946667150639794667015087019630673637144422540572481103610249216, 2588154880046461420288033448353884544669165864563894958185946583924736, 80879840001451919384001045261058892020911433267621717443310830747648, 514631493222945105325971421573240365883976325135760395164659172419450175488, 2588154880046461420288033448353884544669165864563894958185946583924736, 125633351468921981443148290305511478939149093009039067761942823761346560, 0x264c6f72656d20697073756d20646f6c6f722073697420657468657265, 53113508339655873314659021564971517366334151400493876485713881232784043802624, 0\n"
        },
        "offset_overflow_in_array_decoding_3.sol": {
            "content": "pragma abicoder v2;\ncontract Test {\n\tstruct MemoryUint {\n\t\tuint field;\n\t}\n\tfunction test() public pure returns (uint) {\n\t\tuint[] memory before = new uint[](1); // at offset 0x80\n\t\tbytes memory corrupt = abi.encode(\n            uint(32),\n            uint(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80),\n            uint(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80)\n        );\n\t\tMemoryUint memory afterCorrupt;\n\t\tafterCorrupt.field = uint(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80);\n\t\tbefore[0] = 123456;\n\t\tuint[][2] memory decoded = abi.decode(corrupt, (uint[][2]));\n\t\treturn decoded[1][0];\n\t}\n}\n// ----\n// test() -> FAILURE\n"
        },
        "contract_array_v2.sol": {
            "content": "pragma abicoder               v2;\ncontract C {\n  function f(bytes calldata x) public returns (C[] memory) {\n    return abi.decode(x, (C[]));\n  }\n  function g() public returns (bytes memory) {\n    C[] memory c = new C[](3);\n    c[0] = C(address(0x42));\n    c[1] = C(address(0x21));\n    c[2] = C(address(0x23));\n    return abi.encode(c);\n  }\n}\n// ----\n// f(bytes): 0x20, 0xA0, 0x20, 3, 0x01, 0x02, 0x03 -> 0x20, 3, 0x01, 0x02, 0x03\n// f(bytes): 0x20, 0x60, 0x20, 1, 0x0102030405060708090a0b0c0d0e0f1011121314 -> 0x20, 1, 0x0102030405060708090a0b0c0d0e0f1011121314\n// f(bytes): 0x20, 0x60, 0x20, 1, 0x0102030405060708090a0b0c0d0e0f101112131415 -> FAILURE\n// g() -> 0x20, 0xa0, 0x20, 3, 0x42, 0x21, 0x23\n"
        },
        "abi_encode_call_uint_bytes.sol": {
            "content": "contract C {\n\tfunction removeSignature(bytes calldata x) external pure returns (bytes memory) {\n\t\treturn x[4:];\n\t}\n\tfunction g(bytes2, bytes2, bytes2) public {}\n\tfunction h(uint16, uint16) public {}\n\tfunction f() public returns (bytes memory) {\n\t\tuint16 x = 0x1234;\n\t\treturn this.removeSignature(abi.encodeCall(this.g, (0x1234, \"ab\", bytes2(x))));\n\t}\n\tfunction f2() public returns (bytes memory) {\n\t\tbytes2 x = 0x1234;\n\t\treturn this.removeSignature(abi.encodeCall(this.h, (0x1234, uint16(x))));\n\t}\n}\n// ====\n// EVMVersion: >homestead\n// ----\n// f() -> 0x20, 0x60, 0x1234000000000000000000000000000000000000000000000000000000000000, 0x6162000000000000000000000000000000000000000000000000000000000000, 0x1234000000000000000000000000000000000000000000000000000000000000\n// f2() -> 0x20, 0x40, 0x1234, 0x1234\n"
        },
        "offset_overflow_in_array_decoding.sol": {
            "content": "pragma abicoder v2;\ncontract Test {\n\tstruct MemoryUint {\n\t\tuint field;\n\t}\n\tfunction test() public pure returns (uint) {\n\t\tuint[] memory before = new uint[](1); // at offset 0x80\n\t\t// Two problems here: The first offset is zero, the second offset is missing.\n\t\tbytes memory corrupt = abi.encode(uint(32), // offset to \"tuple\"\n\t\t\t\t\t\t\t\t\t\t  uint(0)); // bogus first element\n\t\t/*\n\t\t  At this point the free pointer is 0x80 + 64 (size of before) + 32 (length field of corrupt) + 64 (two encoded words)\n\n\t\t  Now let's put random junk into memory immediately after the bogus first element. Our goal is to overflow the read pointer to point to before.\n\t\t  The value read out at this point will be added to beginning of the encoded tuple, AKA corrupt + 64. We need then to write x where:\n\t\t  x + 0x80 + 64 (before) + 32 (length of corrupt) + 32 (first word of corrupt) = 0x80 (mod 2^256)\n\t\t  that is MAX_UINT - 128\n\t\t*/\n\t\tMemoryUint memory afterCorrupt;\n\t\tafterCorrupt.field = uint(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80);\n\t\tbefore[0] = 123456;\n\t\tuint[][2] memory decoded = abi.decode(corrupt, (uint[][2]));\n\t\treturn decoded[1][0];\n\t}\n}\n// ----\n// test() -> FAILURE\n"
        },
        "abi_encode_call_special_args.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n\tbool sideEffectRan = false;\n\n\tfunction fNoArgs() external {}\n\tfunction fArray(uint[] memory x) external {}\n\tfunction fUint(uint x, uint y) external returns (uint a, uint b) {}\n\n\tfunction fSignatureFromLiteralNoArgs() public pure returns (bytes memory) {\n\t\treturn abi.encodeWithSignature(\"fNoArgs()\");\n\t}\n\tfunction fPointerNoArgs() public view returns (bytes memory) {\n\t\treturn abi.encodeCall(this.fNoArgs, ());\n\t}\n\n\tfunction fSignatureFromLiteralArray() public pure returns (bytes memory) {\n\t\tuint[] memory x;\n\t\treturn abi.encodeWithSignature(\"fArray(uint256[])\", x);\n\t}\n\tfunction fPointerArray() public view returns (bytes memory) {\n\t\tuint[] memory x;\n\t\treturn abi.encodeCall(this.fArray, x);\n\t}\n\n\tfunction fSignatureFromLiteralUint() public pure returns (bytes memory) {\n\t\treturn abi.encodeWithSignature(\"fUint(uint256,uint256)\", 12, 13);\n\t}\n\tfunction fPointerUint() public view returns (bytes memory) {\n\t\treturn abi.encodeCall(this.fUint, (12,13));\n\t}\n\n\tfunction assertConsistentSelectors() public view {\n\t\tassert(keccak256(fSignatureFromLiteralNoArgs()) == keccak256(fPointerNoArgs()));\n\t\tassert(keccak256(fSignatureFromLiteralArray()) == keccak256(fPointerArray()));\n\t\tassert(keccak256(fSignatureFromLiteralUint()) == keccak256(fPointerUint()));\n\t}\n}\n// ----\n// assertConsistentSelectors() ->\n// fSignatureFromLiteralNoArgs() -> 0x20, 0x04, 12200448252684243758085936796735499259670113115893304444050964496075123064832\n// fPointerNoArgs() -> 0x20, 4, 12200448252684243758085936796735499259670113115893304444050964496075123064832\n// fSignatureFromLiteralArray() -> 0x20, 0x44, 4612216551196396486909126966576324289294165774260092952932219511233230929920, 862718293348820473429344482784628181556388621521298319395315527974912, 0\n// fPointerArray() -> 0x20, 0x44, 4612216551196396486909126966576324289294165774260092952932219511233230929920, 862718293348820473429344482784628181556388621521298319395315527974912, 0\n// fPointerUint() -> 0x20, 0x44, 30372892641494467502622535050667754357470287521126424526399600764424271429632, 323519360005807677536004181044235568083645733070486869773243322990592, 350479306672958317330671196131255198757282877493027442254346933239808\n// fSignatureFromLiteralUint() -> 0x20, 0x44, 30372892641494467502622535050667754357470287521126424526399600764424271429632, 323519360005807677536004181044235568083645733070486869773243322990592, 350479306672958317330671196131255198757282877493027442254346933239808\n"
        },
        "abi_decode_calldata.sol": {
            "content": "contract C {\n    function f(bytes calldata data)\n        external\n        pure\n        returns (uint256, bytes memory r)\n    {\n        return abi.decode(data, (uint256, bytes));\n    }\n}\n// ----\n// f(bytes): 0x20, 0x80, 0x21, 0x40, 0x7, \"abcdefg\" -> 0x21, 0x40, 0x7, \"abcdefg\"\n"
        },
        "abi_encode_with_selector.sol": {
            "content": "pragma abicoder v1;\ncontract C {\n\tfunction f0() public pure returns (bytes memory) {\n\t\treturn abi.encodeWithSelector(0x12345678);\n\t}\n\tfunction f1() public pure returns (bytes memory) {\n\t\treturn abi.encodeWithSelector(0x12345678, \"abc\");\n\t}\n\tfunction f2() public pure returns (bytes memory) {\n\t\tbytes4 x = 0x12345678;\n\t\treturn abi.encodeWithSelector(x, \"abc\");\n\t}\n\tfunction f3() public pure returns (bytes memory) {\n\t\tbytes4 x = 0x12345678;\n\t\treturn abi.encodeWithSelector(x, type(uint).max);\n\t}\n}\n// ----\n// f0() -> 0x20, 4, 8234104107246695022420661102507966550300666591269321702959126607540084801536\n// f1() -> 0x20, 0x64, 8234104107246695022420661102507966550300666591269321702959126607540084801536, 862718293348820473429344482784628181556388621521298319395315527974912, 91135606241822717681769169345594720818313984248279388438121731325952, 0\n// f2() -> 0x20, 0x64, 8234104107246695022420661102507966550300666591269321702959126607540084801536, 862718293348820473429344482784628181556388621521298319395315527974912, 91135606241822717681769169345594720818313984248279388438121731325952, 0\n// f3() -> 0x20, 0x24, 0x12345678ffffffffffffffffffffffffffffffffffffffffffffffffffffffff, -26959946667150639794667015087019630673637144422540572481103610249216\n"
        },
        "abi_encode_with_signature.sol": {
            "content": "pragma abicoder v1;\ncontract C {\n\tfunction f0() public pure returns (bytes memory) {\n\t\treturn abi.encodeWithSignature(\"f(uint256)\");\n\t}\n\tfunction f1() public pure returns (bytes memory) {\n\t\tstring memory x = \"f(uint256)\";\n\t\treturn abi.encodeWithSignature(x, \"abc\");\n\t}\n\tstring xstor;\n\tfunction f1s() public returns (bytes memory) {\n\t\txstor = \"f(uint256)\";\n\t\treturn abi.encodeWithSignature(xstor, \"abc\");\n\t}\n\tfunction f2() public pure returns (bytes memory r, uint[] memory ar) {\n\t\tstring memory x = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\";\n\t\tuint[] memory y = new uint[](4);\n\t\ty[0] = type(uint).max;\n\t\ty[1] = type(uint).max - 1;\n\t\ty[2] = type(uint).max - 2;\n\t\ty[3] = type(uint).max - 3;\n\t\tr = abi.encodeWithSignature(x, y);\n\t\t// The hash uses temporary memory. This allocation re-uses the memory\n\t\t// and should initialize it properly.\n\t\tar = new uint[](2);\n\t}\n}\n// ----\n// f0() -> 0x20, 4, -34435155370463444793260793355178157075203752403645521721995013737368954863616\n// f1() -> 0x20, 0x64, -34435155370463444793260793355178157075203752403645521721995013737368954863616, 862718293348820473429344482784628181556388621521298319395315527974912, 91135606241822717681769169345594720818313984248279388438121731325952, 0\n// f1s() -> 0x20, 0x64, -34435155370463444793260793355178157075203752403645521721995013737368954863616, 862718293348820473429344482784628181556388621521298319395315527974912, 91135606241822717681769169345594720818313984248279388438121731325952, 0\n// f2() -> 0x40, 0x0140, 0xc4, -10047825972976160827854069633043429618646681939320956771263895477211642200064, 862718293348820473429344482784628181556388621521298319395315527974912, 0x04ffffffffffffffffffffffffffffffffffffffffffffffffffffffff, -1, -26959946667150639794667015087019630673637144422540572481103610249217, -53919893334301279589334030174039261347274288845081144962207220498433, -107839786668602559178668060348078522694548577690162289924414440996864, 2, 0, 0\n"
        },
        "abi_encode_with_selectorv2.sol": {
            "content": "pragma abicoder v2;\ncontract C {\n\tfunction f0() public pure returns (bytes memory) {\n\t\treturn abi.encodeWithSelector(0x12345678);\n\t}\n\tfunction f1() public pure returns (bytes memory) {\n\t\treturn abi.encodeWithSelector(0x12345678, \"abc\");\n\t}\n\tfunction f2() public pure returns (bytes memory) {\n\t\tbytes4 x = 0x12345678;\n\t\treturn abi.encodeWithSelector(x, \"abc\");\n\t}\n\tfunction f3() public pure returns (bytes memory) {\n\t\tbytes4 x = 0x12345678;\n\t\treturn abi.encodeWithSelector(x, type(uint).max);\n\t}\n\tstruct S { uint a; string b; uint16 c; }\n\tfunction f4() public pure returns (bytes memory) {\n\t\tbytes4 x = 0x12345678;\n\t\tS memory s;\n\t\ts.a = 0x1234567;\n\t\ts.b = \"Lorem ipsum dolor sit ethereum........\";\n\t\ts.c = 0x1234;\n\t\treturn abi.encodeWithSelector(x, type(uint).max, s, uint(3));\n\t}\n}\n// ----\n// f0() -> 0x20, 4, 8234104107246695022420661102507966550300666591269321702959126607540084801536\n// f1() -> 0x20, 0x64, 8234104107246695022420661102507966550300666591269321702959126607540084801536, 862718293348820473429344482784628181556388621521298319395315527974912, 91135606241822717681769169345594720818313984248279388438121731325952, 0\n// f2() -> 0x20, 0x64, 8234104107246695022420661102507966550300666591269321702959126607540084801536, 862718293348820473429344482784628181556388621521298319395315527974912, 91135606241822717681769169345594720818313984248279388438121731325952, 0\n// f3() -> 0x20, 0x24, 0x12345678ffffffffffffffffffffffffffffffffffffffffffffffffffffffff, -26959946667150639794667015087019630673637144422540572481103610249216\n// f4() -> 0x20, 292, 0x12345678ffffffffffffffffffffffffffffffffffffffffffffffffffffffff, -26959946667150639794667015087019630673637144422540572481103610249216, 2588154880046461420288033448353884544669165864563894958185946583924736, 80879840001451919384001045261058892020911433267621717443310830747648, 514631493222945105325971421573240365883976325135760395164659172419450175488, 2588154880046461420288033448353884544669165864563894958185946583924736, 125633351468921981443148290305511478939149093009039067761942823761346560, 0x264c6f72656d20697073756d20646f6c6f722073697420657468657265, 53113508339655873314659021564971517366334151400493876485713881232784043802624, 0\n"
        },
        "abi_encode_call.sol": {
            "content": "pragma abicoder v2;\ncontract C {\n\ttype UnsignedNumber is uint256;\n\tenum Enum { First, Second, Third }\n\n\tstruct Struct {\n\t\tUnsignedNumber[] dynamicArray;\n\t\tuint256 justAnInt;\n\t\tstring name;\n\t\tbytes someBytes;\n\t\tEnum theEnum;\n\t}\n\n\tfunction callMeMaybe(Struct calldata _data, int256 _intVal, string memory _nameVal) external pure {\n\t\tassert(_data.dynamicArray.length == 3);\n\t\tassert(UnsignedNumber.unwrap(_data.dynamicArray[0]) == 0);\n\t\tassert(UnsignedNumber.unwrap(_data.dynamicArray[1]) == 1);\n\t\tassert(UnsignedNumber.unwrap(_data.dynamicArray[2]) == 2);\n\t\tassert(_data.justAnInt == 6);\n\t\tassert(keccak256(bytes(_data.name)) == keccak256(\"StructName\"));\n\t\tassert(keccak256(_data.someBytes) == keccak256(bytes(\"1234\")));\n\t\tassert(_data.theEnum == Enum.Second);\n\t\tassert(_intVal == 5);\n\t\tassert(keccak256(bytes(_nameVal)) == keccak256(\"TestName\"));\n\t}\n\n\tfunction callExternal() public returns (bool) {\n\t\tStruct memory structToSend;\n\t\tstructToSend.dynamicArray = new UnsignedNumber[](3);\n\t\tstructToSend.dynamicArray[0] = UnsignedNumber.wrap(0);\n\t\tstructToSend.dynamicArray[1] = UnsignedNumber.wrap(1);\n\t\tstructToSend.dynamicArray[2] = UnsignedNumber.wrap(2);\n\t\tstructToSend.justAnInt = 6;\n\t\tstructToSend.name = \"StructName\";\n\t\tstructToSend.someBytes = bytes(\"1234\");\n\t\tstructToSend.theEnum = Enum.Second;\n\n\t\t(bool success,) = address(this).call(abi.encodeCall(this.callMeMaybe, (\n\t\t\tstructToSend,\n\t\t\t5,\n\t\t\t\"TestName\"\n\t\t)));\n\n\t\treturn success;\n\t}\n}\n// ----\n// callExternal() -> true\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200,
            "details": {
                "peephole": false,
                "inliner": false,
                "jumpdestRemover": false,
                "orderLiterals": false,
                "deduplicate": false,
                "cse": false,
                "constantOptimizer": false
            }
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "metadata",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ]
            }
        }
    }
}