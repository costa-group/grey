{"language": "Solidity", "sources": {"invalid_error_encoding.sol": {"content": "contract C {\n    function g(bytes memory revertMsg) public pure returns (uint, uint) {\n        assembly { revert(add(revertMsg, 0x20), mload(revertMsg)) }\n    }\n    function f1() public returns (uint x) {\n        // Invalid signature\n        try this.g(abi.encodeWithSelector(0x12345678, uint(0), uint(0), uint(0))) returns (uint a, uint b) {\n            return 0;\n        } catch Error(string memory) {\n            return 1;\n        } catch (bytes memory) {\n            return 2;\n        }\n    }\n    function f1a() public returns (uint x) {\n        // Invalid signature\n        try this.g(abi.encodeWithSelector(0x12345678, uint(0), uint(0), uint(0))) returns (uint a, uint b) {\n            return 0;\n        } catch Error(string memory) {\n            return 1;\n        } catch {\n            return 2;\n        }\n    }\n    function f1b() public returns (uint x) {\n        // Invalid signature\n        try this.g(abi.encodeWithSelector(0x12345678, uint(0), uint(0), uint(0))) returns (uint a, uint b) {\n            return 0;\n        } catch Error(string memory) {\n            return 1;\n        }\n    }\n    function f1c() public returns (uint x) {\n        // Invalid signature\n        try this.g(abi.encodeWithSelector(0x12345678, uint(0), uint(0), uint(0))) returns (uint a, uint b) {\n            return 0;\n        } catch {\n            return 2;\n        }\n    }\n    function f2() public returns (uint x) {\n        // Valid signature but illegal offset\n        try this.g(abi.encodeWithSignature(\"Error(string)\", uint(0x100), uint(0), uint(0))) returns (uint a, uint b) {\n            return 0;\n        } catch Error(string memory) {\n            return 1;\n        } catch (bytes memory) {\n            return 2;\n        }\n    }\n    function f2a() public returns (uint x) {\n        // Valid signature but illegal offset\n        try this.g(abi.encodeWithSignature(\"Error(string)\", uint(0x100), uint(0), uint(0))) returns (uint a, uint b) {\n            return 0;\n        } catch Error(string memory) {\n            return 1;\n        } catch {\n            return 2;\n        }\n    }\n    function f2b() public returns (uint x) {\n        // Valid signature but illegal offset\n        try this.g(abi.encodeWithSignature(\"Error(string)\", uint(0x100), uint(0), uint(0))) returns (uint a, uint b) {\n            return 0;\n        } catch Error(string memory) {\n            return 1;\n        }\n    }\n    function f2c() public returns (uint x) {\n        // Valid signature but illegal offset\n        try this.g(abi.encodeWithSignature(\"Error(string)\", uint(0x100), uint(0), uint(0))) returns (uint a, uint b) {\n            return 0;\n        } catch {\n            return 1;\n        }\n    }\n    function f3() public returns (uint x) {\n        // Valid up to length\n        try this.g(abi.encodeWithSignature(\"Error(string)\", uint(0x20), uint(0x30), uint(0))) returns (uint a, uint b) {\n            return 0;\n        } catch Error(string memory) {\n            return 1;\n        } catch (bytes memory) {\n            return 2;\n        }\n    }\n    function f3a() public returns (uint x) {\n        // Valid up to length\n        try this.g(abi.encodeWithSignature(\"Error(string)\", uint(0x20), uint(0x30), uint(0))) returns (uint a, uint b) {\n            return 0;\n        } catch Error(string memory) {\n            return 1;\n        } catch (bytes memory) {\n            return 2;\n        }\n    }\n    function f3b() public returns (uint x) {\n        // Valid up to length\n        try this.g(abi.encodeWithSignature(\"Error(string)\", uint(0x20), uint(0x30), uint(0))) returns (uint a, uint b) {\n            return 0;\n        } catch Error(string memory) {\n            return 1;\n        }\n    }\n    function f3c() public returns (uint x) {\n        // Valid up to length\n        try this.g(abi.encodeWithSignature(\"Error(string)\", uint(0x20), uint(0x30), uint(0))) returns (uint a, uint b) {\n            return 0;\n        } catch {\n            return 1;\n        }\n    }\n    function f4() public returns (uint x) {\n        // Fully valid\n        try this.g(abi.encodeWithSignature(\"Error(string)\", uint(0x20), uint(0x7), bytes7(\"abcdefg\"))) returns (uint a, uint b) {\n            return 0;\n        } catch Error(string memory) {\n            return 1;\n        } catch (bytes memory) {\n            return 2;\n        }\n    }\n    function f4a() public returns (uint x) {\n        // Fully valid\n        try this.g(abi.encodeWithSignature(\"Error(string)\", uint(0x20), uint(0x7), bytes7(\"abcdefg\"))) returns (uint a, uint b) {\n            return 0;\n        } catch Error(string memory) {\n            return 1;\n        } catch {\n            return 2;\n        }\n    }\n    function f4b() public returns (uint x) {\n        // Fully valid\n        try this.g(abi.encodeWithSignature(\"Error(string)\", uint(0x20), uint(0x7), bytes7(\"abcdefg\"))) returns (uint a, uint b) {\n            return 0;\n        } catch Error(string memory) {\n            return 1;\n        }\n    }\n    function f4c() public returns (uint x) {\n        // Fully valid\n        try this.g(abi.encodeWithSignature(\"Error(string)\", uint(0x20), uint(0x7), bytes7(\"abcdefg\"))) returns (uint a, uint b) {\n            return 0;\n        } catch {\n            return 1;\n        }\n    }\n}\n// ====\n// EVMVersion: >=byzantium\n// ----\n// f1() -> 2\n// f1a() -> 2\n// f1b() -> FAILURE, hex\"12345678\", 0x0, 0, \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n// f1c() -> 2\n// f2() -> 2\n// f2a() -> 2\n// f2b() -> FAILURE, hex\"08c379a0\", 0x100, 0, \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n// f2c() -> 1\n// f3() -> 2\n// f3a() -> 2\n// f3b() -> FAILURE, hex\"08c379a0\", 0x20, 48, \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n// f3c() -> 1\n// f4() -> 1\n// f4a() -> 1\n// f4b() -> 1\n// f4c() -> 1\n"}}, "settings": {"optimizer": {"enabled": true, "runs": 200}, "outputSelection": {"*": {"*": ["abi", "metadata", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers"]}}, "metadata": {"appendCBOR": false}, "viaIR": true}}