{
    "language": "Solidity",
    "sources": {
        "operator_precendence.sol": {
            "content": "type Int is int64;\nusing {\n    bitor as |, bitand as &, bitxor as ^, bitnot as ~,\n    add as +, sub as -, unsub as -, mul as *, div as /, mod as %\n} for Int global;\n\nfunction bitor(Int x, Int y) pure returns (Int) { return Int.wrap(Int.unwrap(x) | Int.unwrap(y)); }\nfunction bitand(Int x, Int y) pure returns (Int) { return Int.wrap(Int.unwrap(x) & Int.unwrap(y)); }\nfunction bitxor(Int x, Int y) pure returns (Int) { return Int.wrap(Int.unwrap(x) ^ Int.unwrap(y)); }\nfunction bitnot(Int x) pure returns (Int) { return Int.wrap(~Int.unwrap(x)); }\n\nfunction add(Int x, Int y) pure returns (Int) { return Int.wrap(Int.unwrap(x) + Int.unwrap(y)); }\nfunction sub(Int x, Int y) pure returns (Int) { return Int.wrap(Int.unwrap(x) - Int.unwrap(y)); }\nfunction unsub(Int x) pure returns (Int) { return Int.wrap(-Int.unwrap(x)); }\nfunction mul(Int x, Int y) pure returns (Int) { return Int.wrap(Int.unwrap(x) * Int.unwrap(y)); }\nfunction div(Int x, Int y) pure returns (Int) { return Int.wrap(Int.unwrap(x) / Int.unwrap(y)); }\nfunction mod(Int x, Int y) pure returns (Int) { return Int.wrap(Int.unwrap(x) % Int.unwrap(y)); }\n\ncontract C {\n    Int constant I0 = Int.wrap(0);\n    Int constant I1 = Int.wrap(1);\n    Int constant I2 = Int.wrap(2);\n    Int constant I3 = Int.wrap(3);\n    Int constant I4 = Int.wrap(4);\n    Int constant I5 = Int.wrap(5);\n    Int constant I6 = Int.wrap(6);\n    Int constant I7 = Int.wrap(7);\n    Int constant I8 = Int.wrap(8);\n    Int constant I10 = Int.wrap(10);\n    Int constant I13 = Int.wrap(13);\n    Int constant I15 = Int.wrap(15);\n    Int constant I20 = Int.wrap(20);\n    Int constant I128 = Int.wrap(128);\n\n    function testBitwise() public pure {\n        assert(Int.unwrap(I0 & I0 | I1) == (0 & 0 | 1));\n        assert(Int.unwrap(I0 & I0 | I1) == ((0 & 0) | 1));\n    }\n\n    function testBitwise_arithmetic() public pure {\n        assert(Int.unwrap(I2 + I2 & ~I1 | I6 * I6 - I4 & ~I3) == (2 + 2 & ~1 | 6 * 6 - 4 & ~3));\n        assert(Int.unwrap(I2 + I2 & ~I1 | I6 * I6 - I4 & ~I3) == (((2 + 2) & (~1)) | (((6 * 6) - 4) & (~3))));\n    }\n\n    function testArithmetic() public pure {\n        assert(Int.unwrap(I1 + I8 / I4 - I5 % I6 * I7) == (1 + 8 / 4 - 5 % 6 * 7));\n        assert(Int.unwrap(I1 + I8 / I4 - I5 % I6 * I7) == ((1 + (8 / 4)) - ((5 % 6) * 7)));\n    }\n\n    function testAll() public pure {\n        assert(\n            Int.unwrap(I128 + I1 - I10 + I4 & ~I1 ^ ~I1 * I2 | -I15 % -I10 * I20 / I2 + I13 & ~I3) ==\n            (128 + 1 - 10 + 4 & ~1 ^ ~1 * 2 | -15 % -10 * 20 / 2 + 13 & ~3)\n        );\n        assert(\n            Int.unwrap(I128 + I1 - I10 + I4 & ~I1 ^ ~I1 * I2 | -I15 % -I10 * I20 / I2 + I13 & ~I3) ==\n            (\n                (\n                    ((((128 + 1) - 10) + 4) & (~1)) ^\n                    ((~1) * 2)\n                ) |\n                ((((((-15) % (-10)) * 20) / 2) + 13) & (~3))\n            )\n        );\n    }\n}\n// ----\n// testBitwise() ->\n// testBitwise_arithmetic() ->\n// testArithmetic() ->\n// testAll() ->\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200,
            "details": {
                "peephole": false,
                "inliner": false,
                "jumpdestRemover": false,
                "orderLiterals": false,
                "deduplicate": false,
                "cse": false,
                "constantOptimizer": false
            }
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "metadata",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ]
            }
        }
    }
}