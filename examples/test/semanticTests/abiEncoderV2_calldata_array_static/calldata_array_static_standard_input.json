{
    "language": "Solidity",
    "sources": {
        "calldata_struct_array_reencode.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n    struct D { uint[] x; }\n    struct S { uint x; }\n\n    function f(D calldata a) public returns (bytes memory){\n        return abi.encode(a);\n    }\n\n    function g(D[2] calldata a) public returns (bytes memory) {\n        return abi.encode(a);\n    }\n\n    function h(D[][] calldata a) public returns (bytes memory) {\n        return abi.encode(a);\n    }\n\n    function i(D[2][] calldata a) public returns (bytes memory) {\n        return abi.encode(a);\n    }\n\n    function j(S[] memory a) public returns (bytes memory) {\n        return abi.encode(a);\n    }\n\n    function k(S[2] memory a) public returns (bytes memory) {\n        return abi.encode(a);\n    }\n\n    function l(S[][] memory a) public returns (bytes memory) {\n        return abi.encode(a);\n    }\n\n}\n// ----\n// f((uint256[])): 0x20, 0x20, 0 -> 0x20, 0x60, 0x20, 0x20, 0\n// f((uint256[])): 0x20, 0x20, 1 -> FAILURE\n// f((uint256[])): 0x20, 0x20, 2 -> FAILURE\n// f((uint256[])): 0x20, 0x20, 3 -> FAILURE\n// g((uint256[])[2]): 0x20, 0x40, 0xc0, 0x20, 2, 1, 2, 0x20, 1, 3 -> 0x20, 0x0140, 0x20, 0x40, 0xc0, 0x20, 2, 1, 2, 0x20, 1, 3\n// g((uint256[])[2]): 0x20, 0x40, 0xc0, 0x20, 2, 1, 2, 0x20, 1 -> FAILURE\n// h((uint256[])[][]): 0x20, 0x02, 0x40, 0x0180, 2, 0x40, 0xc0, 0x20, 2, 1, 2, 0x20, 1, 3, 1, 0x20, 0x20, 1, 1 -> 0x20, 0x0260, 0x20, 2, 0x40, 0x0180, 2, 0x40, 0xc0, 0x20, 2, 1, 2, 0x20, 1, 3, 1, 0x20, 0x20, 1, 1\n// h((uint256[])[][]): 0x20, 0x02, 0x40, 0x0180, 2, 0x40, 0xc0, 0x20, 2, 1, 2, 0x20, 1, 3, 1, 0x20, 0x20, 1 -> FAILURE\n// i((uint256[])[2][]): 0x20, 1, 0x20, 0x40, 0xc0, 0x20, 2, 1, 2, 0x20, 1, 3 -> 0x20, 0x0180, 0x20, 1, 0x20, 0x40, 0xc0, 0x20, 2, 1, 2, 0x20, 1, 3\n// i((uint256[])[2][]): 0x20, 1, 0x20, 0x40, 0xc0, 0x20, 2, 1, 2, 0x20, 1 -> FAILURE\n// j((uint256)[]): 0x20, 2, 1, 2 -> 0x20, 0x80, 0x20, 2, 1, 2\n// j((uint256)[]): 0x20, 2, 1 -> FAILURE\n// k((uint256)[2]): 1, 2 -> 0x20, 0x40, 1, 2\n// k((uint256)[2]): 1 -> FAILURE\n// l((uint256)[][]): 0x20, 2, 0x40, 0xa0, 2, 5, 6, 3, 7, 8, 9 -> 0x20, 0x0160, 0x20, 2, 0x40, 0xa0, 2, 5, 6, 3, 7, 8, 9\n// l((uint256)[][]): 0x20, 2, 0x40, 0xa0, 2, 5, 6, 3, 7, 8, 9, 10 -> 0x20, 0x0160, 0x20, 2, 0x40, 0xa0, 2, 5, 6, 3, 7, 8, 9\n// l((uint256)[][]): 0x20, 2, 0x40, 0xa0, 2, 5, 6, 3, 7, 8 -> FAILURE\n"
        },
        "abi_encode_rational_v2.sol": {
            "content": "// Tests that rational numbers (even negative ones) are encoded properly.\npragma abicoder               v2;\n\n\ncontract C {\n    function f() public pure returns (bytes memory) {\n        return abi.encode(1, -2);\n    }\n}\n// ----\n// f() -> 0x20, 0x40, 0x1, -2\n"
        },
        "dynamic_arrays.sol": {
            "content": "pragma abicoder               v2;\n\ncontract C {\n    function f(uint a, uint16[] memory b, uint c)\n            public pure returns (uint, uint, uint) {\n        return (b.length, b[a], c);\n    }\n}\n// ----\n// f(uint256,uint16[],uint256): 6, 0x60, 9, 7, 11, 12, 13, 14, 15, 16, 17 -> 7, 17, 9\n"
        },
        "calldata_nested_array_static_reencode.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n\tfunction f(uint[3][] calldata a) public {\n\t\tabi.encode(a);\n\t}\n\tfunction f(uint[][3] calldata a) public {\n\t\tabi.encode(a);\n\t}\n\tfunction f(uint[2][2] calldata a) public {\n\t\tabi.encode(a);\n\t}\n}\n// ----\n// f(uint256[3][]): 0x20, 1, 0x01 -> FAILURE\n// f(uint256[3][]): 0x20, 1, 0x01, 0x02 -> FAILURE\n// f(uint256[3][]): 0x20, 1, 0x01, 0x02, 0x03 ->\n// f(uint256[][3]): 0x20, 0x60, 0x60, 0x60, 3, 0x01 -> FAILURE\n// f(uint256[][3]): 0x20, 0x60, 0x60, 0x60, 3, 0x01, 0x02 -> FAILURE\n// f(uint256[][3]): 0x20, 0x60, 0x60, 0x60, 3, 0x01, 0x02, 0x03 ->\n// f(uint256[2][2]): 0x01 -> FAILURE\n// f(uint256[2][2]): 0x01, 0x02 -> FAILURE\n// f(uint256[2][2]): 0x01, 0x02, 0x03 -> FAILURE\n// f(uint256[2][2]): 0x01, 0x02, 0x03, 0x04 ->\n// f(uint256[2][2]): 0x01, 0x02, 0x03, 0x04, 0x05 ->\n"
        },
        "byte_arrays.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n    function f(uint a, bytes memory b, uint c)\n            public pure returns (uint, uint, bytes1, uint) {\n        return (a, b.length, b[3], c);\n    }\n\n    function f_external(uint a, bytes calldata b, uint c)\n            external pure returns (uint, uint, bytes1, uint) {\n        return (a, b.length, b[3], c);\n    }\n}\n// ----\n// f(uint256,bytes,uint256): 6, 0x60, 9, 7, \"abcdefg\" -> 6, 7, \"d\", 9\n// f_external(uint256,bytes,uint256): 6, 0x60, 9, 7, \"abcdefg\" -> 6, 7, \"d\", 9\n"
        },
        "calldata_struct_member_offset.sol": {
            "content": "pragma abicoder               v2;\n\ncontract C {\n    struct A {\n        uint256 a;\n        uint256[] b;\n    }\n    struct B {\n        A a;\n        uint256 b;\n    }\n    function g(B calldata b) external pure returns(uint256) {\n        return b.b;\n    }\n    function f() public view returns(uint256, uint256) {\n        uint256[] memory arr = new uint256[](20);\n        arr[0] = 31; arr[2] = 84;\n        B memory b = B(A(420, arr), 11);\n        return (b.b, this.g(b));\n    }\n}\n// ----\n// f() -> 11, 11\n"
        },
        "calldata_with_garbage.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n    uint[] aTmp;\n    uint[2] bTmp;\n\n    function f_memory(uint[] calldata a) public returns (uint[] memory) {\n        return a;\n    }\n\n    function f_encode(uint[] calldata a) public returns (bytes memory) {\n        return abi.encode(a);\n    }\n\n    function f_storage(uint[] calldata a) public returns (bytes memory) {\n        aTmp = a;\n        return abi.encode(aTmp);\n    }\n\n    function f_index(uint[] calldata a, uint which) public returns (uint) {\n        return a[which];\n    }\n\n    function g_memory(uint[] calldata a, uint[2] calldata b) public returns (uint[] memory, uint[2] memory) {\n        return (a, b);\n    }\n\n    function g_encode(uint[] calldata a, uint[2] calldata b) public returns (bytes memory) {\n        return abi.encode(a, b);\n    }\n\n    function g_storage(uint[] calldata a, uint[2] calldata b) public returns (bytes memory) {\n        aTmp = a;\n        bTmp = b;\n        return abi.encode(aTmp, bTmp);\n    }\n\n    function g_index(uint[] calldata a, uint[2] calldata b, uint which) public returns (uint, uint) {\n        return (a[which], b[0]);\n    }\n}\n// ----\n// f_memory(uint256[]): 0x80, 9, 9, 9, 0 -> 0x20, 0\n// f_memory(uint256[]): 0x80, 9, 9, 9, 1, 7 -> 0x20, 1, 7\n// f_memory(uint256[]): 0x80, 9, 9, 9, 2, 7 -> FAILURE\n// f_encode(uint256[]): 0x80, 9, 9, 9, 0 -> 0x20, 0x40, 0x20, 0\n// f_encode(uint256[]): 0x80, 9, 9, 9, 1, 7 -> 0x20, 0x60, 0x20, 1, 7\n// f_encode(uint256[]): 0x80, 9, 9, 9, 2, 7 -> FAILURE\n// f_storage(uint256[]): 0x80, 9, 9, 9, 0 -> 0x20, 0x40, 0x20, 0\n// f_storage(uint256[]): 0x80, 9, 9, 9, 1, 7 -> 0x20, 0x60, 0x20, 1, 7\n// f_storage(uint256[]): 0x80, 9, 9, 9, 2, 7 -> FAILURE\n// f_index(uint256[],uint256): 0xa0, 0, 9, 9, 9, 2, 7, 8 -> 7\n// f_index(uint256[],uint256): 0xa0, 1, 9, 9, 9, 2, 7, 8 -> 8\n// f_index(uint256[],uint256): 0xa0, 2, 9, 9, 9, 2, 7, 8 -> FAILURE, hex\"4e487b71\", 0x32\n// g_memory(uint256[],uint256[2]): 0xc0, 1, 2, 9, 9, 9, 0 -> 0x60, 1, 2, 0\n// g_memory(uint256[],uint256[2]): 0xc0, 1, 2, 9, 9, 9, 1, 7 -> 0x60, 1, 2, 1, 7\n// g_memory(uint256[],uint256[2]): 0xc0, 1, 2, 9, 9, 9, 2, 7 -> FAILURE\n// g_encode(uint256[],uint256[2]): 0xc0, 1, 2, 9, 9, 9, 0 -> 0x20, 0x80, 0x60, 1, 2, 0\n// g_encode(uint256[],uint256[2]): 0xc0, 1, 2, 9, 9, 9, 1, 7 -> 0x20, 0xa0, 0x60, 1, 2, 1, 7\n// g_encode(uint256[],uint256[2]): 0xc0, 1, 2, 9, 9, 9, 2, 7 -> FAILURE\n// g_storage(uint256[],uint256[2]): 0xc0, 1, 2, 9, 9, 9, 0 -> 0x20, 0x80, 0x60, 1, 2, 0\n// g_storage(uint256[],uint256[2]): 0xc0, 1, 2, 9, 9, 9, 1, 7 -> 0x20, 0xa0, 0x60, 1, 2, 1, 7\n// g_storage(uint256[],uint256[2]): 0xc0, 1, 2, 9, 9, 9, 2, 7 -> FAILURE\n// g_index(uint256[],uint256[2],uint256): 0xe0, 1, 2, 0, 9, 9, 9, 2, 7, 8 -> 7, 1\n// g_index(uint256[],uint256[2],uint256): 0xe0, 1, 2, 1, 9, 9, 9, 2, 7, 8 -> 8, 1\n// g_index(uint256[],uint256[2],uint256): 0xe0, 1, 2, 1, 9, 9, 9, 2, 7 -> FAILURE\n"
        },
        "calldata_array_struct_dynamic.sol": {
            "content": "pragma abicoder               v2;\n\ncontract C {\n    struct S { uint256[] a; }\n    function f(S[] calldata s) external pure returns (bytes memory) {\n        return abi.encode(s);\n    }\n    function g(S[] calldata s) external view returns (bytes memory) {\n        return this.f(s);\n    }\n}\n// ====\n// EVMVersion: >homestead\n// ----\n// f((uint256[])[]): 32, 1, 32, 32, 3, 17, 42, 23 -> 32, 256, 32, 1, 32, 32, 3, 17, 42, 23\n// g((uint256[])[]): 32, 1, 32, 32, 3, 17, 42, 23 -> 32, 256, 32, 1, 32, 32, 3, 17, 42, 23\n"
        },
        "calldata_array_short_no_revert_string.sol": {
            "content": "contract C {\n\tfunction f(uint[] calldata) public {}\n}\n// ----\n// f(uint256[]): 0x20, 0 ->\n// f(uint256[]): 0x20, 1 -> FAILURE\n// f(uint256[]): 0x20, 2 -> FAILURE\n\n"
        },
        "calldata_array_dynamic_index_access.sol": {
            "content": "pragma abicoder               v2;\n\ncontract C {\n    function f(uint256[] calldata s) external pure returns (bytes memory) {\n        return abi.encode(s);\n    }\n    function g(uint256[][2] calldata s, uint256 which) external view returns (bytes memory) {\n        return this.f(s[which]);\n    }\n    function h(uint8[] calldata s) external pure returns (bytes memory) {\n        return abi.encode(s);\n    }\n    function i(uint8[][2] calldata s, uint256 which) external view returns (bytes memory) {\n        return this.h(s[which]);\n    }\n    function j(bytes calldata s) external pure returns (bytes memory) {\n        return abi.encode(s);\n    }\n    function k(bytes[2] calldata s, uint256 which) external view returns (bytes memory) {\n        return this.j(s[which]);\n    }\n}\n// ====\n// EVMVersion: >homestead\n// ----\n// f(uint256[]): 32, 3, 42, 23, 87 -> 32, 160, 32, 3, 42, 23, 87\n// g(uint256[][2],uint256): 0x40, 0, 0x40, 0xC0, 3, 42, 23, 87, 4, 11, 13, 17 -> 32, 160, 32, 3, 42, 23, 87\n// g(uint256[][2],uint256): 0x40, 1, 0x40, 0xC0, 3, 42, 23, 87, 4, 11, 13, 17, 27 -> 32, 192, 32, 4, 11, 13, 17, 27\n// h(uint8[]): 32, 3, 42, 23, 87 -> 32, 160, 32, 3, 42, 23, 87\n// i(uint8[][2],uint256): 0x40, 0, 0x40, 0xC0, 3, 42, 23, 87, 4, 11, 13, 17 -> 32, 160, 32, 3, 42, 23, 87\n// i(uint8[][2],uint256): 0x40, 1, 0x40, 0xC0, 3, 42, 23, 87, 4, 11, 13, 17, 27 -> 32, 192, 32, 4, 11, 13, 17, 27\n// j(bytes): 32, 3, hex\"AB11FF\" -> 32, 96, 32, 3, left(0xAB11FF)\n// k(bytes[2],uint256): 0x40, 0, 0x40, 0x63, 3, hex\"AB11FF\", 4, hex\"FF791432\" -> 32, 96, 32, 3, left(0xAB11FF)\n// k(bytes[2],uint256): 0x40, 1, 0x40, 0x63, 3, hex\"AB11FF\", 4, hex\"FF791432\" -> 32, 96, 32, 4, left(0xFF791432)\n"
        },
        "calldata_overlapped_nested_dynamic_arrays.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n    uint[] s;\n    uint[2] n;\n\n    function f_memory(uint[][] calldata a) public returns (uint[][] memory) {\n        return a;\n    }\n\n    function f_encode(uint[][] calldata a) public returns (bytes memory) {\n        return abi.encode(a);\n    }\n\n    function f_which(uint[][] calldata a, uint which) public returns (uint[] memory) {\n        return a[which];\n    }\n}\n// ----\n// f_memory(uint256[][]): 0x20, 2, 0x40, 0x40, 2, 1, 2 -> 0x20, 2, 0x40, 0xa0, 2, 1, 2, 2, 1, 2\n// f_memory(uint256[][]): 0x20, 2, 0x40, 0x60, 2, 1, 2 -> 0x20, 2, 0x40, 0xa0, 2, 1, 2, 1, 2\n// f_memory(uint256[][]): 0x20, 2, 0, 0x60, 2, 1, 2 -> 0x20, 2, 0x40, 0x60, 0, 1, 2\n// f_memory(uint256[][]): 0x20, 2, 0, 0x60, 2, 2, 2 -> FAILURE\n// f_encode(uint256[][]): 0x20, 2, 0x40, 0x40, 2, 1, 2 -> 0x20, 0x0140, 0x20, 2, 0x40, 0xa0, 2, 1, 2, 2, 1, 2\n// f_encode(uint256[][]): 0x20, 2, 0x40, 0x60, 2, 1, 2 -> 0x20, 0x0120, 0x20, 2, 0x40, 0xa0, 2, 1, 2, 1, 2\n// f_encode(uint256[][]): 0x20, 2, 0, 0x60, 2, 1, 2 -> 0x20, 0xe0, 0x20, 2, 0x40, 0x60, 0, 1, 2\n// f_encode(uint256[][]): 0x20, 2, 0, 0x60, 2, 2, 2 -> FAILURE\n// f_which(uint256[][],uint256): 0x40, 0, 2, 0x40, 0x40, 2, 1, 2 -> 0x20, 2, 1, 2\n// f_which(uint256[][],uint256): 0x40, 1, 2, 0x40, 0x40, 2, 1, 2 -> 0x20, 2, 1, 2\n// f_which(uint256[][],uint256): 0x40, 0, 2, 0x40, 0x60, 2, 1, 2 -> 0x20, 2, 1, 2\n// f_which(uint256[][],uint256): 0x40, 1, 2, 0x40, 0x60, 2, 1, 2 -> 0x20, 1, 2\n// f_which(uint256[][],uint256): 0x40, 0, 2, 0, 0x60, 2, 1, 2 -> 0x20, 0\n// f_which(uint256[][],uint256): 0x40, 1, 2, 0, 0x60, 2, 1, 2 -> 0x20, 1, 2\n// f_which(uint256[][],uint256): 0x40, 1, 2, 0, 0x60, 2, 2, 2 -> FAILURE\n"
        },
        "memory_params_in_external_function.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n    function f(bytes memory a, bytes calldata b, uint[] memory c)\n        external\n        pure\n        returns (uint, bytes1, uint, bytes1, uint, uint)\n    {\n        return (a.length, a[1], b.length, b[2], c.length, c[3]);\n    }\n    function g() public returns (uint, bytes1, uint, bytes1, uint, uint) {\n        uint[] memory x = new uint[](4);\n        x[3] = 7;\n        return this.f(\"abc\", \"def\", x);\n    }\n}\n// ----\n// g() -> 3, 0x6200000000000000000000000000000000000000000000000000000000000000, 3, 0x6600000000000000000000000000000000000000000000000000000000000000, 4, 7\n"
        },
        "calldata_array_dynamic_static_in_library.sol": {
            "content": "library L {\n    // This case used to be affected by the buggy cleanup due to ABIEncoderV2HeadOverflowWithStaticArrayCleanup bug.\n    function g(uint[] memory a, uint[1] calldata b) public returns (uint[] memory, uint[1] calldata) {\n        return (a, b);\n    }\n}\n\ncontract C {\n    function f(uint[] memory a, uint[1] calldata b) public returns (uint[] memory, uint[1] memory) {\n        return L.g(a, b);\n    }\n}\n// ====\n// EVMVersion: >homestead\n// ----\n// library: L\n// f(uint256[],uint256[1]): 0x40, 0xff, 1, 0xffff -> 0x40, 0xff, 0x01, 0xffff\n"
        },
        "bool_out_of_bounds.sol": {
            "content": "pragma abicoder               v2;\n\ncontract C {\n\tfunction f(bool b) public pure returns (bool) { return b; }\n}\n// ----\n// f(bool): true -> true\n// f(bool): false -> false\n// f(bool): 0x000000 -> false\n// f(bool): 0xffffff -> FAILURE\n"
        },
        "calldata_dynamic_array_to_memory.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n    function f(uint[][] calldata a) public returns (uint[][] memory) {\n        return a;\n    }\n\n    function g(uint[][][] calldata a) public returns (uint[][][] memory) {\n        return a;\n    }\n\n    function h(uint[2][][] calldata a) public returns (uint[2][][] memory) {\n        return a;\n    }\n}\n// ----\n// f(uint256[][]): 0x20, 2, 0x40, 0xa0, 2, 5, 6, 2, 7, 8 -> 0x20, 2, 0x40, 0xa0, 2, 5, 6, 2, 7, 8\n// f(uint256[][]): 0x20, 2, 0x40, 0xa0, 2, 5, 6, 2, 7, 8, 9 -> 0x20, 2, 0x40, 0xa0, 2, 5, 6, 2, 7, 8\n// f(uint256[][]): 0x20, 2, 0x40, 0xa0, 2, 5, 6, 3, 7, 8 -> FAILURE\n// g(uint256[][][]): 0x20, 2, 0x40, 0x60, 0, 2, 0x40, 0xa0, 2, 5, 6, 2, 7, 8 -> 0x20, 2, 0x40, 0x60, 0, 2, 0x40, 0xa0, 2, 5, 6, 2, 7, 8\n// g(uint256[][][]): 0x20, 2, 0x40, 0x60, 0, 2, 0x40, 0xa0, 2, 5, 6, 2, 7 -> FAILURE\n// h(uint256[2][][]): 0x20, 2, 0x40, 0x60, 0, 2, 5, 6, 7, 8 -> 0x20, 2, 0x40, 0x60, 0, 2, 5, 6, 7, 8\n// h(uint256[2][][]): 0x20, 2, 0x40, 0x60, 0, 2, 5, 6, 7, 8, 9 -> 0x20, 2, 0x40, 0x60, 0, 2, 5, 6, 7, 8\n// h(uint256[2][][]): 0x20, 2, 0x40, 0x60, 0, 2, 5, 6, 7 -> FAILURE\n"
        },
        "calldata_array_two_static.sol": {
            "content": "pragma abicoder               v2;\n\ncontract C {\n    function f(uint256[3] calldata s1, uint256[2] calldata s2, bool which) external pure returns (bytes memory) {\n        if (which)\n            return abi.encode(s1);\n        else\n            return abi.encode(s2);\n    }\n    function g(uint256[3] calldata s1, uint256[2] calldata s2, bool which) external view returns (bytes memory) {\n        return this.f(s1, s2, which);\n    }\n}\n// ====\n// EVMVersion: >homestead\n// ----\n// f(uint256[3],uint256[2],bool): 23, 42, 87, 51, 72, true -> 32, 96, 23, 42, 87\n// f(uint256[3],uint256[2],bool): 23, 42, 87, 51, 72, false -> 32, 64, 51, 72\n// g(uint256[3],uint256[2],bool): 23, 42, 87, 51, 72, true -> 32, 96, 23, 42, 87\n// g(uint256[3],uint256[2],bool): 23, 42, 87, 51, 72, false -> 32, 64, 51, 72\n"
        },
        "calldata_struct_simple.sol": {
            "content": "pragma abicoder               v2;\n\ncontract C {\n    struct S { uint256 a; }\n\n    function f(S calldata s) external returns (bytes memory) {\n        return abi.encode(s);\n    }\n\n    function g(S calldata s) external returns (bytes memory) {\n        return this.f(s);\n    }\n}\n// ====\n// EVMVersion: >homestead\n// ----\n// f((uint256)): 3 -> 32, 32, 3\n// g((uint256)): 3 -> 32, 32, 3\n"
        },
        "calldata_array_dynamic_static_short_decode.sol": {
            "content": "pragma abicoder               v2;\ncontract C {\n    function f(uint256[][2][] calldata x) external returns (uint256) {\n        x[0]; // trigger bounds checks\n        return 23;\n    }\n}\n// ----\n// f(uint256[][2][]): 0x20, 0x01, 0x20, 0x40, 0x60, 0x00, 0x00 -> 23 # this is the common encoding for x.length == 1 && x[0][0].length == 0 && x[0][1].length == 0 #\n// f(uint256[][2][]): 0x20, 0x01, 0x20, 0x00, 0x00 -> 23 # exotic, but still valid encoding #\n// f(uint256[][2][]): 0x20, 0x01, 0x20, 0x00 -> FAILURE # invalid (too short) encoding, but no failure due to this PR #\n"
        },
        "calldata_array_dynamic_static_dynamic.sol": {
            "content": "pragma abicoder               v2;\n\ncontract C {\n    function f(uint8[][1][] calldata s) external pure returns (bytes memory) {\n        return msg.data;\n    }\n    function f2(uint256[][2][] calldata s) external pure returns (bytes memory) {\n        return msg.data;\n    }\n    function reenc_f(uint8[][1][] calldata s) external view returns (bytes memory) {\n        return this.f(s);\n    }\n    function reenc_f2(uint256[][2][] calldata s) external view returns (bytes memory) {\n        return this.f2(s);\n    }\n    function g() external returns (bytes memory) {\n        uint8[][1][] memory m = new uint8[][1][](1);\n        m[0][0] = new uint8[](1);\n        m[0][0][0] = 42;\n        return this.f(m);\n    }\n    function h() external returns (bytes memory) {\n        uint8[][1][] memory m = new uint8[][1][](1);\n        m[0][0] = new uint8[](1);\n        m[0][0][0] = 42;\n        return this.reenc_f(m);\n    }\n    function i() external returns (bytes memory) {\n        uint256[][2][] memory m = new uint256[][2][](1);\n        m[0][0] = new uint256[](1);\n        m[0][1] = new uint256[](1);\n        m[0][0][0] = 42;\n        m[0][1][0] = 42;\n        return this.f2(m);\n    }\n    function j() external returns (bytes memory) {\n        uint256[][2][] memory m = new uint256[][2][](1);\n        m[0][0] = new uint256[](1);\n        m[0][1] = new uint256[](1);\n        m[0][0][0] = 42;\n        m[0][1][0] = 42;\n        return this.reenc_f2(m);\n    }\n}\n// ====\n// EVMVersion: >homestead\n// ----\n// g() -> 32, 196, hex\"eccb829a\", 32, 1, 32, 32, 1, 42, hex\"00000000000000000000000000000000000000000000000000000000\"\n// h() -> 32, 196, hex\"eccb829a\", 32, 1, 32, 32, 1, 42, hex\"00000000000000000000000000000000000000000000000000000000\"\n"
        },
        "enums.sol": {
            "content": "pragma abicoder               v2;\n\ncontract C {\n    enum E { A, B }\n    function f(E e) public pure returns (uint x) {\n        assembly { x := e }\n    }\n}\n// ----\n// f(uint8): 0 -> 0\n// f(uint8): 1 -> 1\n// f(uint8): 2 -> FAILURE\n// f(uint8): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff -> FAILURE\n"
        },
        "calldata_array_short.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n\tfunction f(uint[] calldata) public {}\n}\n// ====\n// revertStrings: debug\n// ----\n// f(uint256[]): 0x20, 0 ->\n// f(uint256[]): 0x20, 1 -> FAILURE, hex\"08c379a0\", 0x20, 0x2b, \"ABI decoding: invalid calldata a\", \"rray stride\"\n// f(uint256[]): 0x20, 2 -> FAILURE, hex\"08c379a0\", 0x20, 0x2b, \"ABI decoding: invalid calldata a\", \"rray stride\"\n"
        },
        "calldata_overlapped_dynamic_arrays.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n    uint[] s;\n    uint[2] n;\n\n    function f_memory(uint[] calldata a, uint[2] calldata b) public returns (uint[] memory, uint[2] memory) {\n        return (a, b);\n    }\n\n    function f_encode(uint[] calldata a, uint[2] calldata b) public returns (bytes memory) {\n        return abi.encode(a, b);\n    }\n\n    function f_which(uint[] calldata a, uint[2] calldata b, uint which) public returns (bytes memory) {\n        return abi.encode(a[which], b[1]);\n    }\n\n    function f_storage(uint[] calldata a, uint[2] calldata b ) public returns (bytes memory) {\n        s = a;\n        n = b;\n        return abi.encode(s);\n    }\n}\n// ----\n// f_memory(uint256[],uint256[2]): 0x20, 1, 2 -> 0x60, 0x01, 0x02, 1, 2\n// f_memory(uint256[],uint256[2]): 0x40, 1, 2, 5, 6 -> 0x60, 1, 2, 2, 5, 6\n// f_memory(uint256[],uint256[2]): 0x40, 1, 2, 5 -> FAILURE\n// f_encode(uint256[],uint256[2]): 0x20, 1, 2 -> 0x20, 0xa0, 0x60, 1, 2, 1, 2\n// f_encode(uint256[],uint256[2]): 0x40, 1, 2, 5, 6 -> 0x20, 0xc0, 0x60, 1, 2, 2, 5, 6\n// f_encode(uint256[],uint256[2]): 0x40, 1, 2, 5 -> FAILURE\n// f_which(uint256[],uint256[2],uint256): 0x40, 1, 2, 1, 5 -> 0x20, 0x40, 5, 2\n// f_which(uint256[],uint256[2],uint256): 0x40, 1, 2, 1, 5, 6 -> 0x20, 0x40, 5, 2\n// f_which(uint256[],uint256[2],uint256): 0x40, 1, 2, 1 -> FAILURE\n// f_storage(uint256[],uint256[2]): 0x20, 1, 2 -> 0x20, 0x60, 0x20, 1, 2\n// gas irOptimized: 111409\n// gas legacy: 112707\n// gas legacyOptimized: 111845\n// f_storage(uint256[],uint256[2]): 0x40, 1, 2, 5, 6 -> 0x20, 0x80, 0x20, 2, 5, 6\n// f_storage(uint256[],uint256[2]): 0x40, 1, 2, 5 -> FAILURE\n"
        },
        "calldata_array_static_dynamic_static.sol": {
            "content": "pragma abicoder               v2;\n\ncontract C {\n    function f(uint8[1][][1] calldata s) external pure returns (bytes memory) {\n        return msg.data;\n    }\n    function f2(uint256[2][][2] calldata s) external pure returns (bytes memory) {\n        return msg.data;\n    }\n    function reenc_f(uint8[1][][1] calldata s) external view returns (bytes memory) {\n        return this.f(s);\n    }\n    function reenc_f2(uint256[2][][2] calldata s) external view returns (bytes memory) {\n        return this.f2(s);\n    }\n    function g() external returns (bytes memory) {\n        uint8[1][][1] memory m = [new uint8[1][](1)];\n        m[0][0][0] = 42;\n        return this.f(m);\n    }\n    function h() external returns (bytes memory) {\n        uint8[1][][1] memory m = [new uint8[1][](1)];\n        m[0][0][0] = 42;\n        return this.reenc_f(m);\n    }\n    function i() external returns (bytes memory) {\n        uint256[2][][2] memory m = [new uint256[2][](1),new uint256[2][](1)];\n        m[0][0][0] = 0x00042;\n        m[0][0][1] = 0x00142;\n        m[1][0][0] = 0x10042;\n        m[1][0][1] = 0x10142;\n        return this.f2(m);\n    }\n    function j() external returns (bytes memory) {\n        uint256[2][][2] memory m = [new uint256[2][](1),new uint256[2][](1)];\n        m[0][0][0] = 0x00042;\n        m[0][0][1] = 0x00142;\n        m[1][0][0] = 0x10042;\n        m[1][0][1] = 0x10142;\n        return this.reenc_f2(m);\n    }\n}\n// ====\n// EVMVersion: >homestead\n// ----\n// g() -> 32, 132, hex\"15cfcc01\", 32, 32, 1, 42, hex\"00000000000000000000000000000000000000000000000000000000\"\n// h() -> 32, 132, hex\"15cfcc01\", 32, 32, 1, 42, hex\"00000000000000000000000000000000000000000000000000000000\"\n// i() -> 32, 292, hex\"dc0ee233\", 32, 64, 160, 1, 0x42, 0x000142, 1, 0x010042, 0x010142, hex\"00000000000000000000000000000000000000000000000000000000\"\n// j() -> 32, 292, hex\"dc0ee233\", 32, 64, 160, 1, 0x42, 0x000142, 1, 0x010042, 0x010142, hex\"00000000000000000000000000000000000000000000000000000000\"\n"
        },
        "calldata_array.sol": {
            "content": "pragma abicoder               v2;\n\ncontract C {\n    function g(uint256[] calldata) external pure returns (bytes memory) {\n        return msg.data;\n    }\n    function f(uint256[][1] calldata s) external view returns (bool) {\n        bytes memory a = this.g(s[0]);\n        uint256[] memory m = s[0];\n        bytes memory b = this.g(m);\n        assert(a.length == b.length);\n        for (uint i = 0; i < a.length; i++)\n            assert(a[i] == b[i]);\n        return true;\n    }\n}\n// ====\n// EVMVersion: >homestead\n// ----\n// f(uint256[][1]): 32, 32, 0 -> true\n// f(uint256[][1]): 32, 32, 1, 42 -> true\n// f(uint256[][1]): 32, 32, 8, 421, 422, 423, 424, 425, 426, 427, 428 -> true\n// gas irOptimized: 120978\n// gas legacy: 101568\n// gas legacyOptimized: 119092\n"
        },
        "calldata_three_dimensional_dynamic_array_index_access.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n    struct S { uint[] a; }\n\n    function f(uint[][] calldata s, uint i, uint j) public pure returns (bytes memory) {\n        return abi.encode(s[i][j]);\n    }\n\n    function g(uint[][][] calldata s, uint i, uint j, uint k) public pure returns (bytes memory) {\n        return abi.encode(s[i][j][k]);\n    }\n\n    function h(uint[][][1] calldata s, uint i) public pure returns (bytes memory) {\n        return abi.encode(s[0][i]);\n    }\n\n    function k(S[][] calldata s, uint i, uint j) public pure returns (bytes memory) {\n        return abi.encode(s[i][j].a);\n    }\n\n    function l(S[2][2] calldata s, uint i, uint j) public pure returns (bytes memory) {\n        return abi.encode(s[i][j].a);\n    }\n}\n// ====\n// revertStrings: debug\n// ----\n// f(uint256[][],uint256,uint256): 0x60, 0, 0, 2, 0x40, 0x80, 1, 7, 1, 8 -> 0x20, 0x20, 7\n// f(uint256[][],uint256,uint256): 0x60, 1, 0, 2, 0x40, 0x80, 1, 7, 1, 8 -> 0x20, 0x20, 8\n// g(uint256[][][],uint256,uint256,uint256): 0x80, 0, 0, 0, 2, 0x40, 0xc0, 1, 0x20, 1, 4, 2, 0x40, 0xa0, 2, 5, 6, 1, 7 -> 0x20, 0x20, 4\n// g(uint256[][][],uint256,uint256,uint256): 0x80, 1, 0, 1, 2, 0x40, 0xc0, 1, 0x20, 1, 4, 2, 0x40, 0xa0, 2, 5, 6, 1, 7 -> 0x20, 0x20, 6\n// g(uint256[][][],uint256,uint256,uint256): 0x80, 1, 0, 2, 2, 0x40, 0xc0, 1, 0x20, 1, 4, 2, 0x40, 0xa0, 2, 5, 6, 1, 7 -> FAILURE, hex\"4e487b71\", 0x32\n// g(uint256[][][],uint256,uint256,uint256): 0x80, 2, 0, 1, 2, 0x40, 0xc0, 1, 0x20, 1, 4, 2, 0x40, 0xa0, 2, 5, 6, 1, 7 -> FAILURE, hex\"4e487b71\", 0x32\n// h(uint256[][][1],uint256): 0x40, 1, 0x20, 2, 0x40, 0xA0, 2, 5, 6, 3, 7, 8, 9 -> 0x20, 0xa0, 0x20, 3, 7, 8, 9\n// h(uint256[][][1],uint256): 0x40, 2, 0x20, 2, 0x40, 0xA0, 2, 5, 6, 3, 7, 8, 9 -> FAILURE, hex\"4e487b71\", 0x32\n// k((uint256[])[][],uint256,uint256): 0x60, 0, 0, 2, 0x40, 0xe0, 1, 0x20, 0x20, 1, 6, 2, 0x40, 0xa0, 0x20, 1, 7, 0x20, 2, 8, 9 -> 0x20, 0x60, 0x20, 1, 6\n// k((uint256[])[][],uint256,uint256): 0x60, 0, 1, 2, 0x40, 0xe0, 1, 0x20, 0x20, 1, 6, 2, 0x40, 0xa0, 0x20, 1, 7, 0x20, 2, 8, 9 -> FAILURE, hex\"4e487b71\", 0x32\n// l((uint256[])[2][2],uint256,uint256): 0x60, 1, 1, 0x40, 0x0140, 0x40, 0xa0, 0x20, 1, 5, 0x20, 1, 6, 0x40, 0xa0, 0x20, 1, 7, 0x20, 2, 8, 9 -> 0x20, 0x80, 0x20, 2, 8, 9\n// l((uint256[])[2][2],uint256,uint256): 0x60, 1, 2, 0x40, 0x0140, 0x40, 0xa0, 0x20, 1, 5, 0x20, 1, 6, 0x40, 0xa0, 0x20, 1, 7, 0x20, 2, 8, 9 -> FAILURE, hex\"4e487b71\", 0x32\n"
        },
        "abi_encode_v2_in_function_inherited_in_v1_contract.sol": {
            "content": "==== Source: A ====\npragma abicoder v2;\n\nstruct Data {\n    uint a;\n    uint[2] b;\n    uint c;\n}\n\ncontract A {\n    function get() public view returns (Data memory) {\n        return Data(5, [uint(66), 77], 8);\n    }\n}\n\ncontract B {\n    function foo(A _a) public returns (uint) {\n        return _a.get().b[1];\n    }\n}\n==== Source: B ====\npragma abicoder v1;\n\nimport \"A\";\n\ncontract C is B {\n    function test() public returns (uint) {\n        return foo(new A());\n    }\n}\n// ----\n// test() -> 77\n// gas irOptimized: 55117\n// gas irOptimized code: 56800\n// gas legacy: 57266\n// gas legacy code: 94600\n// gas legacyOptimized: 55195\n// gas legacyOptimized code: 55000\n"
        },
        "calldata_struct_dynamic.sol": {
            "content": "pragma abicoder               v2;\n\ncontract C {\n    struct S { uint256[] a; }\n\n    function f(S calldata s) external returns (bytes memory) {\n        return abi.encode(s);\n    }\n\n    function g(S calldata s) external returns (bytes memory) {\n        return this.f(s);\n    }\n}\n// ====\n// EVMVersion: >homestead\n// ----\n// f((uint256[])): 0x20, 0x20, 3, 42, 23, 17 -> 32, 192, 0x20, 0x20, 3, 42, 23, 17\n// g((uint256[])): 0x20, 0x20, 3, 42, 23, 17 -> 32, 192, 0x20, 0x20, 3, 42, 23, 17\n"
        },
        "calldata_array_dynamic.sol": {
            "content": "pragma abicoder               v2;\n\ncontract C {\n    function f(uint256[] calldata s) external pure returns (bytes memory) {\n        return abi.encode(s);\n    }\n    function g(uint256[] calldata s) external view returns (bytes memory) {\n        return this.f(s);\n    }\n    function h(uint8[] calldata s) external pure returns (bytes memory) {\n        return abi.encode(s);\n    }\n    function i(uint8[] calldata s) external view returns (bytes memory) {\n        return this.h(s);\n    }\n    function j(bytes calldata s) external pure returns (bytes memory) {\n        return abi.encode(s);\n    }\n    function k(bytes calldata s) external view returns (bytes memory) {\n        return this.j(s);\n    }\n}\n// ====\n// EVMVersion: >homestead\n// ----\n// f(uint256[]): 32, 3, 23, 42, 87 -> 32, 160, 32, 3, 23, 42, 87\n// g(uint256[]): 32, 3, 23, 42, 87 -> 32, 160, 32, 3, 23, 42, 87\n// h(uint8[]): 32, 3, 23, 42, 87 -> 32, 160, 32, 3, 23, 42, 87\n// i(uint8[]): 32, 3, 23, 42, 87 -> 32, 160, 32, 3, 23, 42, 87\n// h(uint8[]): 32, 3, 0xFF23, 0x1242, 0xAB87 -> FAILURE\n// i(uint8[]): 32, 3, 0xAB23, 0x1242, 0xFF87 -> FAILURE\n// j(bytes): 32, 3, hex\"123456\" -> 32, 96, 32, 3, left(0x123456)\n// k(bytes): 32, 3, hex\"AB33FF\" -> 32, 96, 32, 3, left(0xAB33FF)\n"
        },
        "memory_dynamic_array_and_calldata_static_array.sol": {
            "content": "contract C {\n    function f(uint256[] memory a, uint256[1] calldata b) public returns (bytes memory) {\n        return abi.encode(a, b);\n    }\n\n    function g(uint256[] memory a, uint256[1] calldata b) external returns (bytes memory) {\n        return f(a, b);\n    }\n\n    function h(uint256[] memory a, uint256[1] calldata b) external returns (uint256[] memory, uint256[1] calldata) {\n        return (a, b);\n    }\n}\n// ----\n// f(uint256[],uint256[1]): 0x40, 0xff, 1, 0xffff -> 0x20, 0x80, 0x40, 0xff, 1, 0xffff\n// g(uint256[],uint256[1]): 0x40, 0xff, 1, 0xffff -> 0x20, 0x80, 0x40, 0xff, 1, 0xffff\n// h(uint256[],uint256[1]): 0x40, 0xff, 1, 0xffff -> 0x40, 0xff, 1, 0xffff\n"
        },
        "abi_encode_v2.sol": {
            "content": "pragma abicoder               v2;\n\n\ncontract C {\n    struct S {\n        uint256 a;\n        uint256[] b;\n    }\n\n    function f0() public pure returns (bytes memory) {\n        return abi.encode();\n    }\n\n    function f1() public pure returns (bytes memory) {\n        return abi.encode(1, 2);\n    }\n\n    function f2() public pure returns (bytes memory) {\n        string memory x = \"abc\";\n        return abi.encode(1, x, 2);\n    }\n\n    function f3() public pure returns (bytes memory r) {\n        // test that memory is properly allocated\n        string memory x = \"abc\";\n        r = abi.encode(1, x, 2);\n        bytes memory y = \"def\";\n        require(y[0] == \"d\");\n        y[0] = \"e\";\n        require(y[0] == \"e\");\n    }\n\n    S s;\n\n    function f4() public returns (bytes memory r) {\n        string memory x = \"abc\";\n        s.a = 7;\n        s.b.push(2);\n        s.b.push(3);\n        r = abi.encode(1, x, s, 2);\n        bytes memory y = \"def\";\n        require(y[0] == \"d\");\n        y[0] = \"e\";\n        require(y[0] == \"e\");\n    }\n}\n// ----\n// f0() -> 0x20, 0x0\n// f1() -> 0x20, 0x40, 0x1, 0x2\n// f2() -> 0x20, 0xa0, 0x1, 0x60, 0x2, 0x3, \"abc\"\n// f3() -> 0x20, 0xa0, 0x1, 0x60, 0x2, 0x3, \"abc\"\n// f4() -> 0x20, 0x160, 0x1, 0x80, 0xc0, 0x2, 0x3, \"abc\", 0x7, 0x40, 0x2, 0x2, 0x3\n// gas irOptimized: 111816\n// gas legacy: 113890\n// gas legacyOptimized: 111658\n"
        },
        "calldata_array_two_dynamic.sol": {
            "content": "pragma abicoder               v2;\n\ncontract C {\n    function f(uint256[] calldata s1, uint256[] calldata s2, bool which) external pure returns (bytes memory) {\n        if (which)\n            return abi.encode(s1);\n        else\n            return abi.encode(s2);\n    }\n    function g(uint256[] calldata s1, uint256[] calldata s2, bool which) external view returns (bytes memory) {\n        return this.f(s1, s2, which);\n    }\n}\n// ====\n// EVMVersion: >homestead\n// ----\n// f(uint256[],uint256[],bool): 0x60, 0xE0, true, 3, 23, 42, 87, 2, 51, 72 -> 32, 160, 0x20, 3, 23, 42, 87\n// f(uint256[],uint256[],bool): 0x60, 0xE0, false, 3, 23, 42, 87, 2, 51, 72 -> 32, 128, 0x20, 2, 51, 72\n// g(uint256[],uint256[],bool): 0x60, 0xE0, true, 3, 23, 42, 87, 2, 51, 72 -> 32, 160, 0x20, 3, 23, 42, 87\n// g(uint256[],uint256[],bool): 0x60, 0xE0, false, 3, 23, 42, 87, 2, 51, 72 -> 32, 128, 0x20, 2, 51, 72\n"
        },
        "calldata_array_static_index_access.sol": {
            "content": "pragma abicoder               v2;\n\ncontract C {\n    function f(uint256[3] calldata s) external pure returns (bytes memory) {\n        return abi.encode(s);\n    }\n    function g(uint256[3][2] calldata s, uint256 which) external view returns (bytes memory) {\n        return this.f(s[which]);\n    }\n    function h(uint8[3] calldata s) external pure returns (bytes memory) {\n        return abi.encode(s);\n    }\n    function i(uint8[3][2] calldata s, uint256 which) external view returns (bytes memory) {\n        return this.h(s[which]);\n    }\n}\n// ====\n// EVMVersion: >homestead\n// ----\n// f(uint256[3]): 23, 42, 87 -> 32, 96, 23, 42, 87\n// g(uint256[3][2],uint256): 23, 42, 87, 123, 142, 187, 0 -> 32, 96, 23, 42, 87\n// g(uint256[3][2],uint256): 23, 42, 87, 123, 142, 187, 1 -> 32, 96, 123, 142, 187\n// h(uint8[3]): 23, 42, 87 -> 32, 96, 23, 42, 87\n// i(uint8[3][2],uint256): 23, 42, 87, 123, 142, 187, 0 -> 32, 96, 23, 42, 87\n// i(uint8[3][2],uint256): 23, 42, 87, 123, 142, 187, 1 -> 32, 96, 123, 142, 187\n"
        },
        "calldata_array_function_types.sol": {
            "content": "pragma abicoder               v2;\n\ncontract C {\n    function f(function() external returns (uint)[] calldata s) external returns (uint, uint, uint) {\n        assert(s.length == 3);\n        return (s[0](), s[1](), s[2]());\n    }\n    function f_reenc(function() external returns (uint)[] calldata s) external returns (uint, uint, uint) {\n        return this.f(s);\n    }\n    function getter1() external returns (uint) {\n        return 23;\n    }\n    function getter2() external returns (uint) {\n        return 37;\n    }\n    function getter3() external returns (uint) {\n        return 71;\n    }\n    function g(bool reenc) external returns (uint, uint, uint) {\n        function() external returns (uint)[] memory a = new function() external returns (uint)[](3);\n        a[0] = this.getter1;\n        a[1] = this.getter2;\n        a[2] = this.getter3;\n        return reenc ? this.f_reenc(a) : this.f(a);\n    }\n}\n// ----\n// g(bool): false -> 23, 37, 71\n// g(bool): true -> 23, 37, 71\n"
        },
        "storage_array_encoding.sol": {
            "content": "pragma abicoder               v2;\n\n// tests encoding from storage arrays\n\ncontract C {\n    uint256[2][] tmp_h;\n    function h(uint256[2][] calldata s) external returns (bytes memory) {\n        tmp_h = s;\n        return abi.encode(tmp_h);\n    }\n    uint256[2][2] tmp_i;\n    function i(uint256[2][2] calldata s) external returns (bytes memory) {\n        tmp_i = s;\n        return abi.encode(tmp_i);\n    }\n}\n// ====\n// EVMVersion: >homestead\n// ----\n// h(uint256[2][]): 0x20, 3, 123, 124, 223, 224, 323, 324 -> 32, 256, 0x20, 3, 123, 124, 223, 224, 323, 324\n// gas irOptimized: 180080\n// gas legacy: 184233\n// gas legacyOptimized: 180856\n// i(uint256[2][2]): 123, 124, 223, 224 -> 32, 128, 123, 124, 223, 224\n// gas irOptimized: 112031\n// gas legacy: 115091\n// gas legacyOptimized: 112657\n"
        },
        "memory_dynamic_array_and_calldata_bytes.sol": {
            "content": "contract C {\n    function f(uint256[] memory a, bytes calldata b) public returns (bytes memory) {\n        return abi.encode(a, b);\n    }\n\n    function g(uint256[] memory a, bytes calldata b) external returns (bytes memory) {\n        return f(a, b);\n    }\n}\n// ----\n// f(uint256[],bytes): 0x40, 0x80, 1, 0xFF, 6, \"123456\" -> 0x20, 0xc0, 0x40, 0x80, 1, 0xff, 6, \"123456\"\n// g(uint256[],bytes): 0x40, 0x80, 1, 0xffff, 8, \"12345678\" -> 0x20, 0xc0, 0x40, 0x80, 1, 0xffff, 8, \"12345678\"\n"
        },
        "dynamic_nested_arrays.sol": {
            "content": "pragma abicoder               v2;\n\ncontract C {\n\tfunction f(uint a, uint16[][] memory b, uint[2][][3] memory c, uint d)\n\t\t\tpublic pure returns (uint, uint, uint, uint, uint, uint, uint) {\n\t\treturn (a, b.length, b[1].length, b[1][1], c[1].length, c[1][1][1], d);\n\t}\n\tfunction test() public view returns (uint, uint, uint, uint, uint, uint, uint) {\n\t\tuint16[][] memory b = new uint16[][](3);\n\t\tb[0] = new uint16[](2);\n\t\tb[0][0] = 0x55;\n\t\tb[0][1] = 0x56;\n\t\tb[1] = new uint16[](4);\n\t\tb[1][0] = 0x65;\n\t\tb[1][1] = 0x66;\n\t\tb[1][2] = 0x67;\n\t\tb[1][3] = 0x68;\n\n\t\tuint[2][][3] memory c;\n\t\tc[0] = new uint[2][](1);\n\t\tc[0][0][1] = 0x75;\n\t\tc[1] = new uint[2][](5);\n\t\tc[1][1][1] = 0x85;\n\n\t\treturn this.f(12, b, c, 13);\n\t}\n}\n// ----\n// test() -> 12, 3, 4, 0x66, 5, 0x85, 13\n// f(uint256,uint16[][],uint256[2][][3],uint256): 12, 0x80, 0x220, 13, 3, 0x60, 0xC0, 0x160, 2, 85, 86, 4, 101, 102, 103, 104, 0, 0x60, 0xC0, 0x220, 1, 0, 117, 5, 0, 0, 0, 133, 0, 0, 0, 0, 0, 0, 0 -> 12, 3, 4, 0x66, 5, 0x85, 13\n"
        },
        "calldata_array_multi_dynamic.sol": {
            "content": "pragma abicoder               v2;\n\ncontract C {\n    function f(uint256[][] calldata s) external pure returns (bytes memory) {\n        return abi.encode(s);\n    }\n    function g(uint256[][] calldata s) external view returns (bytes memory) {\n        return this.f(s);\n    }\n    function h(uint8[][] calldata s) external pure returns (bytes memory) {\n        return abi.encode(s);\n    }\n    function i(uint8[][] calldata s) external view returns (bytes memory) {\n        return this.h(s);\n    }\n    function j(bytes[] calldata s) external pure returns (bytes memory) {\n        return abi.encode(s);\n    }\n    function k(bytes[] calldata s) external view returns (bytes memory) {\n        return this.j(s);\n    }\n}\n// ====\n// EVMVersion: >homestead\n// ----\n// f(uint256[][]): 0x20, 2, 0x40, 0xC0, 3, 13, 17, 23, 4, 27, 31, 37, 41 -> 32, 416, 32, 2, 64, 192, 3, 13, 17, 23, 4, 27, 31, 37, 41\n// g(uint256[][]): 0x20, 2, 0x40, 0xC0, 3, 13, 17, 23, 4, 27, 31, 37, 41 -> 32, 416, 32, 2, 64, 192, 3, 13, 17, 23, 4, 27, 31, 37, 41\n// h(uint8[][]): 0x20, 2, 0x40, 0xC0, 3, 13, 17, 23, 4, 27, 31, 37, 41 -> 32, 416, 32, 2, 64, 192, 3, 13, 17, 23, 4, 27, 31, 37, 41\n// i(uint8[][]): 0x20, 2, 0x40, 0xC0, 3, 13, 17, 23, 4, 27, 31, 37, 41 -> 32, 416, 32, 2, 64, 192, 3, 13, 17, 23, 4, 27, 31, 37, 41\n// j(bytes[]): 0x20, 2, 0x40, 0x63, 3, hex\"131723\", 4, hex\"27313741\" -> 32, 256, 32, 2, 64, 128, 3, left(0x131723), 4, left(0x27313741)\n// k(bytes[]): 0x20, 2, 0x40, 0x63, 3, hex\"131723\", 4, hex\"27313741\" -> 32, 256, 32, 2, 64, 128, 3, left(0x131723), 4, left(0x27313741)\n"
        },
        "calldata_array_static.sol": {
            "content": "pragma abicoder               v2;\n\ncontract C {\n    function f(uint256[3] calldata s) external pure returns (bytes memory) {\n        return abi.encode(s);\n    }\n    function g(uint256[3] calldata s) external view returns (bytes memory) {\n        return this.f(s);\n    }\n    function h(uint8[3] calldata s) external pure returns (bytes memory) {\n        return abi.encode(s);\n    }\n    function i(uint8[3] calldata s) external view returns (bytes memory) {\n        return this.h(s);\n    }\n}\n// ====\n// EVMVersion: >homestead\n// ----\n// f(uint256[3]): 23, 42, 87 -> 32, 96, 23, 42, 87\n// g(uint256[3]): 23, 42, 87 -> 32, 96, 23, 42, 87\n// h(uint8[3]): 23, 42, 87 -> 32, 96, 23, 42, 87\n// i(uint8[3]): 23, 42, 87 -> 32, 96, 23, 42, 87\n// h(uint8[3]): 0xFF23, 0x1242, 0xAB87 -> FAILURE\n// i(uint8[3]): 0xAB23, 0x1242, 0xFF87 -> FAILURE\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200,
            "details": {
                "peephole": false,
                "inliner": false,
                "jumpdestRemover": false,
                "orderLiterals": false,
                "deduplicate": false,
                "cse": false,
                "constantOptimizer": false
            }
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "metadata",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ]
            }
        }
    }
}