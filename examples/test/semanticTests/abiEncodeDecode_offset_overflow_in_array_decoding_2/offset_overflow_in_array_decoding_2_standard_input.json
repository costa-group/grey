{
    "language": "Solidity",
    "sources": {
        "offset_overflow_in_array_decoding_2.sol": {
            "content": "pragma abicoder v2;\ncontract Test {\n\tstruct MemoryTuple {\n\t\tuint field1;\n\t\tuint field2;\n\t}\n\tfunction withinArray() public pure returns (uint) {\n\t\tuint[] memory before = new uint[](1);\n\t\tbytes memory corrupt = abi.encode(uint(32),\n\t\t\t\t\t\t\t\t\t\t  uint(2));\n\t\tMemoryTuple memory afterCorrupt;\n\t\tbefore[0] = 123456;\n\t\t/*\n\t\t  As above, but in this case we are adding to:\n\t\t  0x80 + 64 (before) + 32 (length of corrupt) + 32 (offset) + 32 (field pointer)\n\t\t  giving MAX_UINT - 96\n\t\t*/\n\t\tafterCorrupt.field1 = uint(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60);\n\t\tafterCorrupt.field2 = uint(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60);\n\t\tuint[][] memory decoded = abi.decode(corrupt, (uint[][]));\n\t\t/*\n\t\t  Will return 123456 * 2, AKA before has been copied twice\n\t\t */\n\t\treturn decoded[0][0] + decoded[1][0];\n\t}\n}\n// ----\n// withinArray() -> FAILURE\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200,
            "details": {
                "peephole": false,
                "inliner": false,
                "jumpdestRemover": false,
                "orderLiterals": false,
                "deduplicate": false,
                "cse": false,
                "constantOptimizer": false
            }
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "metadata",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ]
            }
        }
    }
}