{"language": "Solidity", "sources": {"nested_array_of_structs_storage_to_storage.sol": {"content": "pragma abicoder v2;\n\ncontract C {\n    struct S {\n        uint8 x;\n        uint8 y;\n    }\n\n    S[][] src1;\n    S[][1] src2;\n    S[1][] src3;\n\n    S[][] dst1;\n    S[][1] dst2;\n    S[1][] dst3;\n\n    constructor() {\n        src1 = new S[][](1);\n        src1[0].push(S({x: 3, y: 7}));\n        src1[0].push(S({x: 11, y: 13}));\n\n        src2[0].push(S({x: 3, y: 7}));\n        src2[0].push(S({x: 11, y: 13}));\n        src2[0].push(S({x: 17, y: 19}));\n\n        src3.push([S({x: 3, y: 7})]);\n        src3.push([S({x: 11, y: 13})]);\n    }\n\n    function test1() public {\n        dst1 = src1;\n\n        require(dst1.length == 1);\n        require(dst1[0][0].x == src1[0][0].x);\n        require(dst1[0][0].y == src1[0][0].y);\n        require(dst1[0][1].x == src1[0][1].x);\n        require(dst1[0][1].y == src1[0][1].y);\n    }\n\n    function test2() public {\n        dst2 = src2;\n\n        require(dst2[0].length == 3);\n        require(dst2[0][0].x == src2[0][0].x);\n        require(dst2[0][0].y == src2[0][0].y);\n        require(dst2[0][1].x == src2[0][1].x);\n        require(dst2[0][1].y == src2[0][1].y);\n        require(dst2[0][2].x == src2[0][2].x);\n        require(dst2[0][2].y == src2[0][2].y);\n    }\n\n    function test3() public {\n        dst3 = src3;\n\n        require(dst3.length == 2);\n        require(dst3[0][0].x == src3[0][0].x);\n        require(dst3[0][0].y == src3[0][0].y);\n        require(dst3[1][0].x == src3[1][0].x);\n        require(dst3[1][0].y == src3[1][0].y);\n    }\n}\n// ====\n// compileViaYul: true\n// ----\n// test1()\n// gas irOptimized: 123195\n// test2()\n// gas irOptimized: 123018\n// test3()\n"}}, "settings": {"optimizer": {"enabled": true, "runs": 200}, "outputSelection": {"*": {"*": ["abi", "metadata", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers"]}}, "metadata": {"appendCBOR": false}, "viaIR": true}}