{"language": "Solidity", "sources": {"erc20.sol": {"content": "pragma abicoder v2;\n// A rewrite of the test/libsolidity/semanticTests/various/erc20.sol, but using user defined value\n// types.\n\n// User defined type name. Indicating a type with 18 decimals.\ntype UFixed18 is uint256;\n\nlibrary FixedMath\n{\n    function add(UFixed18 a, UFixed18 b) internal pure returns (UFixed18 c) {\n        return UFixed18.wrap(UFixed18.unwrap(a) + UFixed18.unwrap(b));\n    }\n    function sub(UFixed18 a, UFixed18 b) internal pure returns (UFixed18 c) {\n        return UFixed18.wrap(UFixed18.unwrap(a) - UFixed18.unwrap(b));\n    }\n}\n\ncontract ERC20 {\n    using FixedMath for UFixed18;\n\n    event Transfer(address indexed from, address indexed to, UFixed18 value);\n    event Approval(address indexed owner, address indexed spender, UFixed18 value);\n\n    mapping (address => UFixed18) private _balances;\n    mapping (address => mapping (address => UFixed18)) private _allowances;\n    UFixed18 private _totalSupply;\n\n    constructor() {\n        _mint(msg.sender, UFixed18.wrap(20));\n    }\n\n    function totalSupply() public view returns (UFixed18) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address owner) public view returns (UFixed18) {\n        return _balances[owner];\n    }\n\n    function allowance(address owner, address spender) public view returns (UFixed18) {\n        return _allowances[owner][spender];\n    }\n\n    function transfer(address to, UFixed18 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function approve(address spender, UFixed18 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, UFixed18 value) public returns (bool) {\n        _transfer(from, to, value);\n        // The subtraction here will revert on overflow.\n        _approve(from, msg.sender, _allowances[from][msg.sender].sub(value));\n        return true;\n    }\n\n    function increaseAllowance(address spender, UFixed18 addedValue) public returns (bool) {\n        // The addition here will revert on overflow.\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, UFixed18 subtractedValue) public returns (bool) {\n        // The subtraction here will revert on overflow.\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    function _transfer(address from, address to, UFixed18 value) internal {\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        // The subtraction and addition here will revert on overflow.\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function _mint(address account, UFixed18 value) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        // The additions here will revert on overflow.\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\n\n    function _burn(address account, UFixed18 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        // The subtractions here will revert on overflow.\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    function _approve(address owner, address spender, UFixed18 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _burnFrom(address account, UFixed18 value) internal {\n        _burn(account, value);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(value));\n    }\n}\n// ----\n// constructor()\n// ~ emit Transfer(address,address,uint256): #0x00, #0x1212121212121212121212121212120000000012, 0x14\n// gas irOptimized: 121322\n// gas irOptimized code: 234600\n// gas legacy: 163350\n// gas legacy code: 671400\n// gas legacyOptimized: 127464\n// gas legacyOptimized code: 285400\n// totalSupply() -> 20\n// gas irOptimized: 23415\n// gas legacy: 23653\n// gas legacyOptimized: 23368\n// transfer(address,uint256): 2, 5 -> true\n// ~ emit Transfer(address,address,uint256): #0x1212121212121212121212121212120000000012, #0x02, 0x05\n// gas irOptimized: 48471\n// gas legacy: 49572\n// gas legacyOptimized: 48575\n// decreaseAllowance(address,uint256): 2, 0 -> true\n// ~ emit Approval(address,address,uint256): #0x1212121212121212121212121212120000000012, #0x02, 0x00\n// gas irOptimized: 26275\n// gas legacy: 27204\n// gas legacyOptimized: 26317\n// decreaseAllowance(address,uint256): 2, 1 -> FAILURE, hex\"4e487b71\", 0x11\n// gas irOptimized: 24042\n// gas legacy: 24506\n// gas legacyOptimized: 24077\n// transfer(address,uint256): 2, 14 -> true\n// ~ emit Transfer(address,address,uint256): #0x1212121212121212121212121212120000000012, #0x02, 0x0e\n// gas irOptimized: 28571\n// gas legacy: 29672\n// gas legacyOptimized: 28675\n// transfer(address,uint256): 2, 2 -> FAILURE, hex\"4e487b71\", 0x11\n// gas irOptimized: 24071\n// gas legacy: 24492\n// gas legacyOptimized: 24074\n"}}, "settings": {"optimizer": {"enabled": true, "runs": 200, "details": {"peephole": false, "inliner": false, "jumpdestRemover": false, "orderLiterals": false, "deduplicate": false, "cse": false, "constantOptimizer": false}}, "outputSelection": {"*": {"*": ["abi", "metadata", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers"]}}, "metadata": {"appendCBOR": false}}}