{
    "language": "Solidity",
    "sources": {
        "bytes_to_fixed_bytes_too_long.sol": {
            "content": "contract C {\n    bytes s = \"abcdefghabcdefghabcdefghabcdefgha\";\n\n    function fromMemory(bytes memory m) public returns (bytes32) {\n        return bytes32(m);\n    }\n    function fromCalldata(bytes calldata c) external returns (bytes32) {\n        return bytes32(c);\n    }\n    function fromStorage() external returns (bytes32) {\n        return bytes32(s);\n    }\n    function fromSlice(bytes calldata c) external returns (bytes32) {\n        return bytes32(c[0:33]);\n    }\n}\n// ----\n// fromMemory(bytes): 0x20, 33, \"abcdefghabcdefghabcdefghabcdefgh\", \"a\" -> \"abcdefghabcdefghabcdefghabcdefgh\"\n// fromCalldata(bytes): 0x20, 33, \"abcdefghabcdefghabcdefghabcdefgh\", \"a\" -> \"abcdefghabcdefghabcdefghabcdefgh\"\n// fromStorage() -> \"abcdefghabcdefghabcdefghabcdefgh\"\n// fromSlice(bytes): 0x20, 33, \"abcdefghabcdefghabcdefghabcdefgh\", \"a\" -> \"abcdefghabcdefghabcdefghabcdefgh\"\n"
        },
        "array_2d_new.sol": {
            "content": "contract C {\n\tfunction f(uint n) public pure returns (uint) {\n\t\tuint[][] memory a = new uint[][](2);\n\t\tfor (uint i = 0; i < 2; ++i)\n\t\t\ta[i] = new uint[](3);\n\t\treturn a[0][0] = n;\n\t}\n}\n// ----\n// f(uint256): 42 -> 42\n"
        },
        "array_3d_new.sol": {
            "content": "contract C {\n\tfunction f(uint n) public pure returns (uint) {\n\t\tuint[][][] memory a = new uint[][][](2);\n\t\tfor (uint i = 0; i < 2; ++i)\n\t\t{\n\t\t\ta[i] = new uint[][](3);\n\t\t\tfor (uint j = 0; j < 3; ++j)\n\t\t\t\ta[i][j] = new uint[](4);\n\t\t}\n\t\treturn a[1][1][1] = n;\n\t}\n}\n// ----\n// f(uint256): 42 -> 42\n"
        },
        "dynamic_multi_array_cleanup.sol": {
            "content": "contract c {\n    struct s { uint[][] d; }\n    s[] data;\n    function fill() public returns (uint) {\n        while (data.length < 3)\n            data.push();\n        while (data[2].d.length < 4)\n            data[2].d.push();\n        while (data[2].d[3].length < 5)\n            data[2].d[3].push();\n        data[2].d[3][4] = 8;\n        return data[2].d[3][4];\n    }\n    function clear() public { delete data; }\n}\n// ----\n// storageEmpty -> 1\n// fill() -> 8\n// gas irOptimized: 122985\n// gas legacy: 121602\n// gas legacyOptimized: 120589\n// storageEmpty -> 0\n// clear() ->\n// storageEmpty -> 1\n"
        },
        "create_multiple_dynamic_arrays.sol": {
            "content": "contract C {\n    function f() public returns (uint256) {\n        uint256[][] memory x = new uint256[][](42);\n        assert(x[0].length == 0);\n        x[0] = new uint256[](1);\n        x[0][0] = 1;\n        assert(x[4].length == 0);\n        x[4] = new uint256[](1);\n        x[4][0] = 2;\n        assert(x[10].length == 0);\n        x[10] = new uint256[](1);\n        x[10][0] = 44;\n        uint256[][] memory y = new uint256[][](24);\n        assert(y[0].length == 0);\n        y[0] = new uint256[](1);\n        y[0][0] = 1;\n        assert(y[4].length == 0);\n        y[4] = new uint256[](1);\n        y[4][0] = 2;\n        assert(y[10].length == 0);\n        y[10] = new uint256[](1);\n        y[10][0] = 88;\n        if (\n            (x[0][0] == y[0][0]) &&\n            (x[4][0] == y[4][0]) &&\n            (x[10][0] == 44) &&\n            (y[10][0] == 88)\n        ) return 7;\n        return 0;\n    }\n}\n// ----\n// f() -> 7\n"
        },
        "reusing_memory.sol": {
            "content": "// Invoke some features that use memory and test that they do not interfere with each other.\ncontract Helper {\n    uint256 public flag;\n\n    constructor(uint256 x) {\n        flag = x;\n    }\n}\n\n\ncontract Main {\n    mapping(uint256 => uint256) map;\n\n    function f(uint256 x) public returns (uint256) {\n        map[x] = x;\n        return\n            (new Helper(uint256(keccak256(abi.encodePacked(this.g(map[x]))))))\n                .flag();\n    }\n\n    function g(uint256 a) public returns (uint256) {\n        return map[a];\n    }\n}\n// ----\n// f(uint256): 0x34 -> 0x46bddb1178e94d7f2892ff5f366840eb658911794f2c3a44c450aa2c505186c1\n// gas irOptimized: 99552\n// gas irOptimized code: 12400\n// gas legacy: 101551\n// gas legacy code: 23600\n// gas legacyOptimized: 99612\n// gas legacyOptimized code: 13400\n"
        },
        "fixed_array_cleanup.sol": {
            "content": "contract c {\n    uint spacer1;\n    uint spacer2;\n    uint[20] data;\n    function fill() public {\n        for (uint i = 0; i < data.length; ++i) data[i] = i+1;\n    }\n    function clear() public { delete data; }\n}\n// ----\n// storageEmpty -> 1\n// fill() ->\n// gas irOptimized: 465013\n// gas legacy: 468825\n// gas legacyOptimized: 466238\n// storageEmpty -> 0\n// clear() ->\n// gas irOptimized: 122148\n// gas legacy: 122440\n// gas legacyOptimized: 122259\n// storageEmpty -> 1\n"
        },
        "create_memory_byte_array.sol": {
            "content": "contract C {\n    function f() public returns (bytes1) {\n        bytes memory x = new bytes(35);\n        assert(x.length == 35);\n        x[34] = \"A\";\n        return (x[34]);\n    }\n}\n// ----\n// f() -> \"A\"\n"
        },
        "calldata_array_as_argument_internal_function.sol": {
            "content": "pragma abicoder v2;\ncontract Test {\n    function f(uint256[] calldata c) internal returns (uint a, uint b) {\n        return (c.length, c[0]);\n    }\n\n    function g(uint256[] calldata c) external returns (uint a, uint b) {\n        return f(c);\n    }\n\n    function h(uint256[] calldata c, uint start, uint end) external returns (uint a, uint b) {\n        return f(c[start: end]);\n    }\n}\n// ----\n// g(uint256[]): 0x20, 4, 1, 2, 3, 4 -> 4, 1\n// h(uint256[],uint256,uint256): 0x60, 1, 3, 4, 1, 2, 3, 4 -> 2, 2\n"
        },
        "calldata_array_dynamic_invalid_static_middle.sol": {
            "content": "pragma abicoder               v2;\n\n\ncontract C {\n    function f(uint256[][1][] calldata a) external returns (uint256) {\n        return 42;\n    }\n\n    function g(uint256[][1][] calldata a) external returns (uint256) {\n        a[0];\n        return 42;\n    }\n\n    function h(uint256[][1][] calldata a) external returns (uint256) {\n        a[0][0];\n        return 42;\n    }\n}\n// ----\n// f(uint256[][1][]): 0x20, 0x0 -> 42 # valid access stub #\n// f(uint256[][1][]): 0x20, 0x1 -> FAILURE # invalid on argument decoding #\n// f(uint256[][1][]): 0x20, 0x1, 0x20 -> 42 # invalid on outer access #\n// g(uint256[][1][]): 0x20, 0x1, 0x20 -> FAILURE\n// f(uint256[][1][]): 0x20, 0x1, 0x20, 0x20 -> 42 # invalid on inner access #\n// g(uint256[][1][]): 0x20, 0x1, 0x20, 0x20 -> 42\n// h(uint256[][1][]): 0x20, 0x1, 0x20, 0x20 -> FAILURE\n// f(uint256[][1][]): 0x20, 0x1, 0x20, 0x20, 0x1 -> 42\n// g(uint256[][1][]): 0x20, 0x1, 0x20, 0x20, 0x1 -> 42\n// h(uint256[][1][]): 0x20, 0x1, 0x20, 0x20, 0x1 -> FAILURE\n"
        },
        "calldata_array_two_dimensional_1.sol": {
            "content": "pragma abicoder               v2;\ncontract C {\n    function test(uint256[][] calldata a) external returns (uint256) {\n        return a.length;\n    }\n    function test(uint256[][] calldata a, uint256 i) external returns (uint256) {\n        return a[i].length;\n    }\n    function test(uint256[][] calldata a, uint256 i, uint256 j) external returns (uint256) {\n        return a[i][j];\n    }\n    function reenc(uint256[][] calldata a, uint256 i, uint256 j) external returns (uint256) {\n        return this.test(a, i, j);\n    }\n}\n// ----\n// test(uint256[][]): 0x20, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 2\n// test(uint256[][],uint256): 0x40, 0, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 3\n// test(uint256[][],uint256): 0x40, 1, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 4\n// test(uint256[][],uint256,uint256): 0x60, 0, 0, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 0x0A01\n// reenc(uint256[][],uint256,uint256): 0x60, 0, 0, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 0x0A01\n// test(uint256[][],uint256,uint256): 0x60, 0, 1, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 0x0A02\n// reenc(uint256[][],uint256,uint256): 0x60, 0, 1, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 0x0A02\n// test(uint256[][],uint256,uint256): 0x60, 0, 2, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 0x0A03\n// reenc(uint256[][],uint256,uint256): 0x60, 0, 2, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 0x0A03\n// test(uint256[][],uint256,uint256): 0x60, 1, 0, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 0x0B01\n// reenc(uint256[][],uint256,uint256): 0x60, 1, 0, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 0x0B01\n// test(uint256[][],uint256,uint256): 0x60, 1, 1, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 0x0B02\n// reenc(uint256[][],uint256,uint256): 0x60, 1, 1, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 0x0B02\n// test(uint256[][],uint256,uint256): 0x60, 1, 2, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 0x0B03\n// reenc(uint256[][],uint256,uint256): 0x60, 1, 2, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 0x0B03\n// test(uint256[][],uint256,uint256): 0x60, 1, 3, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 0x0B04\n// reenc(uint256[][],uint256,uint256): 0x60, 1, 3, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 0x0B04\n// test(uint256[][],uint256,uint256): 0x60, 0, 3, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> FAILURE, hex\"4e487b71\", 0x32\n// test(uint256[][],uint256,uint256): 0x60, 1, 4, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> FAILURE, hex\"4e487b71\", 0x32\n// test(uint256[][],uint256): 0x40, 2, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> FAILURE, hex\"4e487b71\", 0x32\n"
        },
        "array_push_return_reference.sol": {
            "content": "contract C {\n    uint[] storageArray;\n    function test(uint256 v) public {\n        storageArray.push() = v;\n    }\n    function getLength() public view returns (uint256) {\n        return storageArray.length;\n    }\n    function fetch(uint256 a) public view returns (uint256) {\n        return storageArray[a];\n    }\n}\n// ----\n// getLength() -> 0\n// test(uint256): 42 ->\n// getLength() -> 1\n// fetch(uint256): 0 -> 42\n// fetch(uint256): 1 -> FAILURE, hex\"4e487b71\", 0x32\n// test(uint256): 23 ->\n// getLength() -> 2\n// fetch(uint256): 0 -> 42\n// fetch(uint256): 1 -> 23\n// fetch(uint256): 2 -> FAILURE, hex\"4e487b71\", 0x32\n"
        },
        "calldata_bytes_array_bounds.sol": {
            "content": "pragma abicoder               v2;\ncontract C {\n    function f(bytes[] calldata a, uint256 i) external returns (uint) {\n        return uint8(a[0][i]);\n    }\n}\n// ----\n// f(bytes[],uint256): 0x40, 0, 1, 0x20, 2, 0x6162000000000000000000000000000000000000000000000000000000000000 -> 0x61\n// f(bytes[],uint256): 0x40, 1, 1, 0x20, 2, 0x6162000000000000000000000000000000000000000000000000000000000000 -> 0x62\n// f(bytes[],uint256): 0x40, 2, 1, 0x20, 2, 0x6162000000000000000000000000000000000000000000000000000000000000 -> FAILURE, hex\"4e487b71\", 0x32\n"
        },
        "array_push_with_arg.sol": {
            "content": "contract C {\n    uint[] storageArray;\n    function test(uint256 v) public {\n        storageArray.push(v);\n    }\n    function getLength() public view returns (uint256) {\n        return storageArray.length;\n    }\n    function fetch(uint256 a) public view returns (uint256) {\n        return storageArray[a];\n    }\n}\n// ----\n// getLength() -> 0\n// test(uint256): 42 ->\n// getLength() -> 1\n// fetch(uint256): 0 -> 42\n// fetch(uint256): 1 -> FAILURE, hex\"4e487b71\", 0x32\n// test(uint256): 23 ->\n// getLength() -> 2\n// fetch(uint256): 0 -> 42\n// fetch(uint256): 1 -> 23\n// fetch(uint256): 2 -> FAILURE, hex\"4e487b71\", 0x32\n"
        },
        "calldata_array_of_struct.sol": {
            "content": "pragma abicoder               v2;\n\n\ncontract C {\n    struct S {\n        uint256 a;\n        uint256 b;\n    }\n\n    function f(S[] calldata s)\n        external\n        pure\n        returns (uint256 l, uint256 a, uint256 b, uint256 c, uint256 d)\n    {\n        l = s.length;\n        a = s[0].a;\n        b = s[0].b;\n        c = s[1].a;\n        d = s[1].b;\n    }\n}\n// ----\n// f((uint256,uint256)[]): 0x20, 0x2, 0x1, 0x2, 0x3, 0x4 -> 2, 1, 2, 3, 4\n"
        },
        "string_allocation_bug.sol": {
            "content": "contract Sample {\n    struct s {\n        uint16 x;\n        uint16 y;\n        string a;\n        string b;\n    }\n    s[2] public p;\n\n    constructor() {\n        s memory m;\n        m.x = 0xbbbb;\n        m.y = 0xcccc;\n        m.a = \"hello\";\n        m.b = \"world\";\n        p[0] = m;\n    }\n}\n// ----\n// p(uint256): 0x0 -> 0xbbbb, 0xcccc, 0x80, 0xc0, 0x05, \"hello\", 0x05, \"world\"\n"
        },
        "array_memory_index_access.sol": {
            "content": "contract C {\n\tfunction index(uint256 len) public returns (bool)\n\t{\n\t\tuint[] memory array = new uint[](len);\n\n\t\tfor (uint256 i = 0; i < len; i++)\n\t\t\tarray[i] = i + 1;\n\n\t\tfor (uint256 i = 0; i < len; i++)\n\t\t\trequire(array[i] == i + 1, \"Unexpected value in array!\");\n\n\t\treturn array.length == len;\n\t}\n\tfunction accessIndex(uint256 len, int256 idx) public returns (uint256)\n\t{\n\t\tuint[] memory array = new uint[](len);\n\n\t\tfor (uint256 i = 0; i < len; i++)\n\t\t\tarray[i] = i + 1;\n\n\t\treturn array[uint256(idx)];\n\t}\n}\n// ----\n// index(uint256): 0 -> true\n// index(uint256): 10 -> true\n// index(uint256): 20 -> true\n// index(uint256): 0xFF -> true\n// gas irOptimized: 108272\n// gas legacy: 181536\n// gas legacyOptimized: 117442\n// accessIndex(uint256,int256): 10, 1 -> 2\n// accessIndex(uint256,int256): 10, 0 -> 1\n// accessIndex(uint256,int256): 10, 11 -> FAILURE, hex\"4e487b71\", 0x32\n// accessIndex(uint256,int256): 10, 10 -> FAILURE, hex\"4e487b71\", 0x32\n// accessIndex(uint256,int256): 10, -1 -> FAILURE, hex\"4e487b71\", 0x32\n"
        },
        "calldata_array_dynamic_invalid.sol": {
            "content": "pragma abicoder               v2;\n\n\ncontract C {\n    function f(uint256[][] calldata a) external returns (uint256) {\n        return 42;\n    }\n\n    function g(uint256[][] calldata a) external returns (uint256) {\n        a[0];\n        return 42;\n    }\n}\n// ----\n// f(uint256[][]): 0x20, 0x0 -> 42 # valid access stub #\n// f(uint256[][]): 0x20, 0x1 -> FAILURE # invalid on argument decoding #\n// f(uint256[][]): 0x20, 0x1, 0x20 -> 42 # invalid on outer access #\n// g(uint256[][]): 0x20, 0x1, 0x20 -> FAILURE\n// f(uint256[][]): 0x20, 0x1, 0x20, 0x2, 0x42 -> 42 # invalid on inner access #\n// g(uint256[][]): 0x20, 0x1, 0x20, 0x2, 0x42 -> FAILURE\n"
        },
        "evm_exceptions_out_of_band_access.sol": {
            "content": "contract A {\n    uint256[3] arr;\n    bool public test = false;\n\n    function getElement(uint256 i) public returns (uint256) {\n        return arr[i];\n    }\n\n    function testIt() public returns (bool) {\n        uint256 i = this.getElement(5);\n        test = true;\n        return true;\n    }\n}\n// ----\n// test() -> false\n// testIt() -> FAILURE, hex\"4e487b71\", 0x32\n// test() -> false\n"
        },
        "string_literal_assign_to_storage_bytes.sol": {
            "content": "contract C {\n    bytes public s = \"abc\";\n    bytes public s1 = \"abcd\";\n    function f() public {\n        s = \"abcd\";\n        s1 = \"abc\";\n    }\n    function g() public {\n        (s, s1) = (\"abc\", \"abcd\");\n    }\n}\n// ----\n// s() -> 0x20, 3, \"abc\"\n// s1() -> 0x20, 4, \"abcd\"\n// f() ->\n// s() -> 0x20, 4, \"abcd\"\n// s1() -> 0x20, 3, \"abc\"\n// g() ->\n// s() -> 0x20, 3, \"abc\"\n// s1() -> 0x20, 4, \"abcd\"\n"
        },
        "create_dynamic_array_with_zero_length.sol": {
            "content": "contract C {\n    function f() public returns (uint256) {\n        uint256[][] memory a = new uint256[][](0);\n        return 7;\n    }\n}\n// ----\n// f() -> 7\n"
        },
        "strings_in_struct.sol": {
            "content": "contract buggystruct {\n    Buggy public bug;\n\n    struct Buggy {\n        uint256 first;\n        uint256 second;\n        uint256 third;\n        string last;\n    }\n\n    constructor() {\n        bug = Buggy(10, 20, 30, \"asdfghjkl\");\n    }\n\n    function getFirst() public returns (uint256) {\n        return bug.first;\n    }\n\n    function getSecond() public returns (uint256) {\n        return bug.second;\n    }\n\n    function getThird() public returns (uint256) {\n        return bug.third;\n    }\n\n    function getLast() public returns (string memory) {\n        return bug.last;\n    }\n}\n// ----\n// getFirst() -> 0x0a\n// getSecond() -> 0x14\n// getThird() -> 0x1e\n// getLast() -> 0x20, 0x09, \"asdfghjkl\"\n"
        },
        "array_storage_length_access.sol": {
            "content": "contract C {\n    uint[] storageArray;\n    function set_get_length(uint256 len) public returns (uint256) {\n        while(storageArray.length < len)\n            storageArray.push();\n        return storageArray.length;\n    }\n}\n// ----\n// set_get_length(uint256): 0 -> 0\n// set_get_length(uint256): 1 -> 1\n// set_get_length(uint256): 10 -> 10\n// set_get_length(uint256): 20 -> 20\n// set_get_length(uint256): 0xFF -> 0xFF\n// gas irOptimized: 96690\n// gas legacy: 128571\n// gas legacyOptimized: 110143\n// set_get_length(uint256): 0xFFF -> 0xFFF\n// gas irOptimized: 1209116\n// gas legacy: 1689548\n// gas legacyOptimized: 1393535\n// set_get_length(uint256): 0xFFFFF -> FAILURE # Out-of-gas #\n"
        },
        "inline_array_singleton.sol": {
            "content": "// This caused a failure since the type was not converted to its mobile type.\ncontract C {\n    function f() public returns (uint256) {\n        return [4][0];\n    }\n}\n// ----\n// f() -> 4\n"
        },
        "storage_array_ref.sol": {
            "content": "contract BinarySearch {\n    /// Finds the position of _value in the sorted list _data.\n    /// Note that \"internal\" is important here, because storage references only work for internal or private functions\n    function find(uint256[] storage _data, uint256 _value)\n        internal\n        returns (uint256 o_position)\n    {\n        return find(_data, 0, _data.length, _value);\n    }\n\n    function find(\n        uint256[] storage _data,\n        uint256 _begin,\n        uint256 _len,\n        uint256 _value\n    ) private returns (uint256 o_position) {\n        if (_len == 0 || (_len == 1 && _data[_begin] != _value))\n            return type(uint256).max; // failure\n        uint256 halfLen = _len / 2;\n        uint256 v = _data[_begin + halfLen];\n        if (_value < v) return find(_data, _begin, halfLen, _value);\n        else if (_value > v)\n            return find(_data, _begin + halfLen + 1, halfLen - 1, _value);\n        else return _begin + halfLen;\n    }\n}\n\n\ncontract Store is BinarySearch {\n    uint256[] data;\n\n    function add(uint256 v) public {\n        data.push(0);\n        data[data.length - 1] = v;\n    }\n\n    function find(uint256 v) public returns (uint256) {\n        return find(data, v);\n    }\n}\n// ----\n// find(uint256): 7 -> -1\n// add(uint256): 7 ->\n// find(uint256): 7 -> 0\n// add(uint256): 11 ->\n// add(uint256): 17 ->\n// add(uint256): 27 ->\n// add(uint256): 31 ->\n// add(uint256): 32 ->\n// add(uint256): 66 ->\n// add(uint256): 177 ->\n// find(uint256): 7 -> 0\n// find(uint256): 27 -> 3\n// find(uint256): 32 -> 5\n// find(uint256): 176 -> -1\n// find(uint256): 0 -> -1\n// find(uint256): 400 -> -1\n"
        },
        "array_storage_push_empty_length_address.sol": {
            "content": "contract C {\n    address[] addressArray;\n    function set_get_length(uint256 len) public returns (uint256)\n    {\n        while(addressArray.length < len)\n            addressArray.push();\n        while(addressArray.length > len)\n            addressArray.pop();\n        return addressArray.length;\n    }\n}\n// ====\n// EVMVersion: >=petersburg\n// ----\n// set_get_length(uint256): 0 -> 0\n// set_get_length(uint256): 1 -> 1\n// set_get_length(uint256): 10 -> 10\n// set_get_length(uint256): 20 -> 20\n// set_get_length(uint256): 0 -> 0\n// gas irOptimized: 77628\n// gas legacy: 77730\n// gas legacyOptimized: 77162\n// set_get_length(uint256): 0xFF -> 0xFF\n// gas irOptimized: 168565\n// gas legacy: 696850\n// gas legacyOptimized: 134488\n// set_get_length(uint256): 0xFFF -> 0xFFF\n// gas irOptimized: 1908127\n// gas legacy: 9857362\n// gas legacyOptimized: 1393660\n// set_get_length(uint256): 0xFFFFF -> FAILURE # Out-of-gas #\n// gas irOptimized: 100000000\n// gas legacyOptimized: 100000000\n"
        },
        "arrays_complex_from_and_to_storage.sol": {
            "content": "contract Test {\n    uint24[3][] public data;\n\n    function set(uint24[3][] memory _data) public returns (uint256) {\n        data = _data;\n        return data.length;\n    }\n\n    function get() public returns (uint24[3][] memory) {\n        return data;\n    }\n}\n// ----\n// set(uint24[3][]): 0x20, 0x06, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12 -> 0x06\n// gas irOptimized: 185216\n// gas legacy: 211054\n// gas legacyOptimized: 206077\n// data(uint256,uint256): 0x02, 0x02 -> 0x09\n// data(uint256,uint256): 0x05, 0x01 -> 0x11\n// data(uint256,uint256): 0x06, 0x00 -> FAILURE\n// get() -> 0x20, 0x06, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12\n"
        },
        "byte_array_storage_layout.sol": {
            "content": "contract c {\n    bytes data;\n    function test_short() public returns (uint256 r) {\n        assembly {\n            sstore(data.slot, 0)\n        }\n        for (uint8 i = 0; i < 15; i++) {\n            data.push(bytes1(i));\n        }\n        assembly {\n            r := sload(data.slot)\n        }\n    }\n\n    function test_long() public returns (uint256 r) {\n        assembly {\n            sstore(data.slot, 0)\n        }\n        for (uint8 i = 0; i < 33; i++) {\n            data.push(bytes1(i));\n        }\n        assembly {\n            r := sload(data.slot)\n        }\n    }\n\n    function test_pop() public returns (uint256 r) {\n        assembly {\n            sstore(data.slot, 0)\n        }\n        for (uint8 i = 0; i < 32; i++) {\n            data.push(bytes1(i));\n        }\n        data.pop();\n        data.pop();\n        assembly {\n            r := sload(data.slot)\n        }\n    }\n}\n// ----\n// storageEmpty -> 1\n// test_short() -> 1780731860627700044960722568376587075150542249149356309979516913770823710\n// gas legacy: 59838\n// gas legacyOptimized: 58606\n// storageEmpty -> 0\n// test_long() -> 67\n// gas irOptimized: 89148\n// gas legacy: 101607\n// gas legacyOptimized: 100479\n// storageEmpty -> 0\n// test_pop() -> 1780731860627700044960722568376592200742329637303199754547598369979433020\n// gas legacy: 61930\n// gas legacyOptimized: 59404\n// storageEmpty -> 0\n"
        },
        "array_storage_index_access.sol": {
            "content": "contract C {\n    uint[] storageArray;\n    function test_indices(uint256 len) public\n    {\n        while (storageArray.length < len)\n            storageArray.push();\n        while (storageArray.length > len)\n            storageArray.pop();\n        for (uint i = 0; i < len; i++)\n            storageArray[i] = i + 1;\n\n        for (uint i = 0; i < len; i++)\n            require(storageArray[i] == i + 1);\n    }\n}\n// ----\n// test_indices(uint256): 1 ->\n// test_indices(uint256): 129 ->\n// gas irOptimized: 3017687\n// gas legacy: 3038668\n// gas legacyOptimized: 2995964\n// test_indices(uint256): 5 ->\n// gas irOptimized: 579670\n// gas legacy: 573821\n// gas legacyOptimized: 571847\n// test_indices(uint256): 10 ->\n// gas irOptimized: 157953\n// gas legacy: 160122\n// gas legacyOptimized: 156996\n// test_indices(uint256): 15 ->\n// gas irOptimized: 172733\n// gas legacy: 175987\n// gas legacyOptimized: 171596\n// test_indices(uint256): 0xFF ->\n// gas irOptimized: 5673823\n// gas legacy: 5715762\n// gas legacyOptimized: 5632556\n// test_indices(uint256): 1000 ->\n// gas irOptimized: 18173005\n// gas legacy: 18347824\n// gas legacyOptimized: 18037248\n// test_indices(uint256): 129 ->\n// gas irOptimized: 4166279\n// gas legacy: 4140124\n// gas legacyOptimized: 4108272\n// test_indices(uint256): 128 ->\n// gas irOptimized: 405522\n// gas legacy: 433512\n// gas legacyOptimized: 400909\n// test_indices(uint256): 1 ->\n// gas irOptimized: 583437\n// gas legacy: 576726\n// gas legacyOptimized: 575542\n"
        },
        "invalid_encoding_for_storage_byte_array.sol": {
            "content": "contract C {\n    bytes public x = \"abc\";\n    bytes public y;\n    function invalidateXShort() public {\n        assembly { sstore(x.slot, 64) }\n        delete y;\n    }\n    function invalidateXLong() public {\n        assembly { sstore(x.slot, 5) }\n        delete y;\n    }\n    function abiEncode() public view returns (bytes memory) { return x; }\n    function abiEncodePacked() public view returns (bytes memory) { return abi.encodePacked(x); }\n    function copyToMemory() public view returns (bytes memory m) { m = x; }\n    function indexAccess() public view returns (bytes1) { return x[0]; }\n    function assignTo() public { x = \"def\"; }\n    function assignToLong() public { x = \"1234567890123456789012345678901234567\"; }\n    function copyToStorage() public { y = x; }\n    function copyFromStorageShort() public { y = \"abc\"; x = y; }\n    function copyFromStorageLong() public { y = \"1234567890123456789012345678901234567\"; x = y; }\n    function arrayPop() public { x.pop(); }\n    function arrayPush() public { x.push(\"t\"); }\n    function arrayPushEmpty() public { x.push(); }\n    function del() public { delete x; }\n}\n// ----\n// x() -> 0x20, 3, 0x6162630000000000000000000000000000000000000000000000000000000000\n// abiEncode() -> 0x20, 3, 0x6162630000000000000000000000000000000000000000000000000000000000\n// abiEncodePacked() -> 0x20, 3, 0x6162630000000000000000000000000000000000000000000000000000000000\n// copyToMemory() -> 0x20, 3, 0x6162630000000000000000000000000000000000000000000000000000000000\n// indexAccess() -> 0x6100000000000000000000000000000000000000000000000000000000000000\n// arrayPushEmpty()\n// arrayPush()\n// x() -> 0x20, 5, 0x6162630074000000000000000000000000000000000000000000000000000000\n// arrayPop()\n// assignToLong()\n// x() -> 0x20, 0x25, 0x3132333435363738393031323334353637383930313233343536373839303132, 0x3334353637000000000000000000000000000000000000000000000000000000\n// assignTo()\n// x() -> 0x20, 3, 0x6465660000000000000000000000000000000000000000000000000000000000\n// copyFromStorageShort()\n// x() -> 0x20, 3, 0x6162630000000000000000000000000000000000000000000000000000000000\n// copyFromStorageLong()\n// gas irOptimized: 121095\n// gas legacy: 121904\n// gas legacyOptimized: 121388\n// x() -> 0x20, 0x25, 0x3132333435363738393031323334353637383930313233343536373839303132, 0x3334353637000000000000000000000000000000000000000000000000000000\n// copyToStorage()\n// x() -> 0x20, 0x25, 0x3132333435363738393031323334353637383930313233343536373839303132, 0x3334353637000000000000000000000000000000000000000000000000000000\n// y() -> 0x20, 0x25, 0x3132333435363738393031323334353637383930313233343536373839303132, 0x3334353637000000000000000000000000000000000000000000000000000000\n// del()\n// x() -> 0x20, 0x00\n// invalidateXLong()\n// x() -> FAILURE, hex\"4e487b71\", 0x22\n// abiEncode() -> FAILURE, hex\"4e487b71\", 0x22\n// abiEncodePacked() -> FAILURE, hex\"4e487b71\", 0x22\n// copyToMemory() -> FAILURE, hex\"4e487b71\", 0x22\n// indexAccess() -> FAILURE, hex\"4e487b71\", 0x22\n// arrayPushEmpty() -> FAILURE, hex\"4e487b71\", 0x22\n// arrayPush() -> FAILURE, hex\"4e487b71\", 0x22\n// x() -> FAILURE, hex\"4e487b71\", 0x22\n// arrayPop() -> FAILURE, hex\"4e487b71\", 0x22\n// assignToLong() -> FAILURE, hex\"4e487b71\", 0x22\n// x() -> FAILURE, hex\"4e487b71\", 0x22\n// assignTo() -> FAILURE, hex\"4e487b71\", 0x22\n// x() -> FAILURE, hex\"4e487b71\", 0x22\n// copyFromStorageShort() -> FAILURE, hex\"4e487b71\", 0x22\n// x() -> FAILURE, hex\"4e487b71\", 0x22\n// copyFromStorageLong() -> FAILURE, hex\"4e487b71\", 0x22\n// x() -> FAILURE, hex\"4e487b71\", 0x22\n// copyToStorage() -> FAILURE, hex\"4e487b71\", 0x22\n// x() -> FAILURE, hex\"4e487b71\", 0x22\n// y() -> 0x20, 0x00\n// del() -> FAILURE, hex\"4e487b71\", 0x22\n// x() -> FAILURE, hex\"4e487b71\", 0x22\n// invalidateXShort()\n// x() -> FAILURE, hex\"4e487b71\", 0x22\n// abiEncode() -> FAILURE, hex\"4e487b71\", 0x22\n// abiEncodePacked() -> FAILURE, hex\"4e487b71\", 0x22\n// copyToMemory() -> FAILURE, hex\"4e487b71\", 0x22\n// indexAccess() -> FAILURE, hex\"4e487b71\", 0x22\n// arrayPushEmpty() -> FAILURE, hex\"4e487b71\", 0x22\n// arrayPush() -> FAILURE, hex\"4e487b71\", 0x22\n// x() -> FAILURE, hex\"4e487b71\", 0x22\n// arrayPop() -> FAILURE, hex\"4e487b71\", 0x22\n// assignToLong() -> FAILURE, hex\"4e487b71\", 0x22\n// x() -> FAILURE, hex\"4e487b71\", 0x22\n// assignTo() -> FAILURE, hex\"4e487b71\", 0x22\n// x() -> FAILURE, hex\"4e487b71\", 0x22\n// copyFromStorageShort() -> FAILURE, hex\"4e487b71\", 0x22\n// x() -> FAILURE, hex\"4e487b71\", 0x22\n// copyFromStorageLong() -> FAILURE, hex\"4e487b71\", 0x22\n// x() -> FAILURE, hex\"4e487b71\", 0x22\n// copyToStorage() -> FAILURE, hex\"4e487b71\", 0x22\n// x() -> FAILURE, hex\"4e487b71\", 0x22\n// y() -> 0x20, 0x00\n"
        },
        "array_storage_index_zeroed_test.sol": {
            "content": "contract C {\n    uint[] storageArray;\n    function test_zeroed_indices(uint256 len) public\n    {\n        while(storageArray.length < len)\n            storageArray.push();\n        while(storageArray.length > len)\n            storageArray.pop();\n\n        for (uint i = 0; i < len; i++)\n            storageArray[i] = i + 1;\n\n        if (len > 3)\n        {\n            while(storageArray.length > 0)\n                storageArray.pop();\n            while(storageArray.length < 3)\n                storageArray.push();\n\n            for (uint i = 3; i < len; i++)\n            {\n                assembly {\n                    mstore(0, storageArray.slot)\n                    let pos := add(keccak256(0, 0x20), i)\n\n                    if iszero(eq(sload(pos), 0)) {\n                        revert(0, 0)\n                    }\n                }\n            }\n\n        }\n\n        while(storageArray.length > 0)\n            storageArray.pop();\n        while(storageArray.length < len)\n            storageArray.push();\n\n        for (uint i = 0; i < len; i++)\n        {\n            require(storageArray[i] == 0);\n\n            uint256 val = storageArray[i];\n            uint256 check;\n\n            assembly { check := iszero(val) }\n\n            require(check == 1);\n        }\n    }\n}\n// ----\n// test_zeroed_indices(uint256): 1 ->\n// test_zeroed_indices(uint256): 5 ->\n// gas irOptimized: 133763\n// gas legacy: 131664\n// gas legacyOptimized: 129990\n// test_zeroed_indices(uint256): 10 ->\n// gas irOptimized: 228556\n// gas legacy: 225215\n// gas legacyOptimized: 222351\n// test_zeroed_indices(uint256): 15 ->\n// gas irOptimized: 327360\n// gas legacy: 322899\n// gas legacyOptimized: 318907\n// test_zeroed_indices(uint256): 0xFF ->\n// gas irOptimized: 5180120\n// gas legacy: 5093135\n// gas legacyOptimized: 5020523\n"
        },
        "short_fixed_array_cleanup.sol": {
            "content": "contract c {\n    uint spacer1;\n    uint spacer2;\n    uint[3] data;\n    function fill() public {\n        for (uint i = 0; i < data.length; ++i) data[i] = i+1;\n    }\n    function clear() public { delete data; }\n}\n// ----\n// storageEmpty -> 1\n// fill() ->\n// storageEmpty -> 0\n// clear() ->\n// storageEmpty -> 1\n"
        },
        "function_memory_array.sol": {
            "content": "contract C {\n    function a(uint256 x) public returns (uint256) {\n        return x + 1;\n    }\n\n    function b(uint256 x) public returns (uint256) {\n        return x + 2;\n    }\n\n    function c(uint256 x) public returns (uint256) {\n        return x + 3;\n    }\n\n    function d(uint256 x) public returns (uint256) {\n        return x + 5;\n    }\n\n    function e(uint256 x) public returns (uint256) {\n        return x + 8;\n    }\n\n    function test(uint256 x, uint256 i) public returns (uint256) {\n        function(uint) internal returns (uint)[] memory arr =\n            new function(uint) internal returns (uint)[](10);\n        arr[0] = a;\n        arr[1] = b;\n        arr[2] = c;\n        arr[3] = d;\n        arr[4] = e;\n        return arr[i](x);\n    }\n}\n// ----\n// test(uint256,uint256): 10, 0 -> 11\n// test(uint256,uint256): 10, 1 -> 12\n// test(uint256,uint256): 10, 2 -> 13\n// test(uint256,uint256): 10, 3 -> 15\n// test(uint256,uint256): 10, 4 -> 18\n// test(uint256,uint256): 10, 5 -> FAILURE, hex\"4e487b71\", 0x51\n"
        },
        "fixed_arrays_in_storage.sol": {
            "content": "contract c {\n    struct Data {\n        uint256 x;\n        uint256 y;\n    }\n    Data[2**10] data;\n    uint256[2**10 + 3] ids;\n\n    function setIDStatic(uint256 id) public {\n        ids[2] = id;\n    }\n\n    function setID(uint256 index, uint256 id) public {\n        ids[index] = id;\n    }\n\n    function setData(uint256 index, uint256 x, uint256 y) public {\n        data[index].x = x;\n        data[index].y = y;\n    }\n\n    function getID(uint256 index) public returns (uint256) {\n        return ids[index];\n    }\n\n    function getData(uint256 index) public returns (uint256 x, uint256 y) {\n        x = data[index].x;\n        y = data[index].y;\n    }\n\n    function getLengths() public returns (uint256 l1, uint256 l2) {\n        l1 = data.length;\n        l2 = ids.length;\n    }\n}\n// ----\n// setIDStatic(uint256): 0xb ->\n// getID(uint256): 0x2 -> 0xb\n// setID(uint256,uint256): 0x7, 0x8 ->\n// getID(uint256): 0x7 -> 0x8\n// setData(uint256,uint256,uint256): 0x7, 0x8, 0x9 ->\n// setData(uint256,uint256,uint256): 0x8, 0xa, 0xb ->\n// getData(uint256): 0x7 -> 0x8, 0x9\n// getData(uint256): 0x8 -> 0xa, 0xb\n// getLengths() -> 0x400, 0x403\n"
        },
        "bytes_to_fixed_bytes_cleanup.sol": {
            "content": "contract C {\n    bytes s = \"abcdefghabcdefghabcdefghabcdefg\";\n\n    function fromMemory(bytes memory m) public returns (bytes16) {\n        assembly { mstore(m, 14) }\n        return bytes16(m);\n    }\n    function fromCalldata(bytes calldata c) external returns (bytes16) {\n        return bytes16(c);\n    }\n    function fromStorage() external returns (bytes32) {\n        return bytes32(s);\n    }\n    function fromSlice(bytes calldata c) external returns (bytes8) {\n        return bytes8(c[0:6]);\n    }\n}\n// ====\n// compileViaYul: true\n// ----\n// fromMemory(bytes): 0x20, 16, \"abcdefghabcdefgh\" -> \"abcdefghabcdef\\0\\0\"\n// fromCalldata(bytes): 0x20, 15, \"abcdefghabcdefgh\" -> \"abcdefghabcdefg\\0\"\n// fromStorage() -> \"abcdefghabcdefghabcdefghabcdefg\\0\"\n// fromSlice(bytes): 0x20, 15, \"abcdefghabcdefgh\" -> \"abcdef\\0\\0\"\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200,
            "details": {
                "peephole": false,
                "inliner": false,
                "jumpdestRemover": false,
                "orderLiterals": false,
                "deduplicate": false,
                "cse": false,
                "constantOptimizer": false
            }
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "metadata",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ]
            }
        }
    }
}