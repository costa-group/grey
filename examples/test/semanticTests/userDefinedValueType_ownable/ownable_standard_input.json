{
    "language": "Solidity",
    "sources": {
        "zero_cost_abstraction_comparison_userdefined.sol": {
            "content": "// a test to compare the cost between using user defined value types and elementary type. See the\n// test zero_cost_abstraction_elementary.sol for comparison.\n\npragma abicoder v2;\n\ntype MyInt is int;\ncontract C {\n    int x;\n    function setX(MyInt _x) external {\n        x = MyInt.unwrap(_x);\n    }\n    function getX() view external returns (MyInt) {\n        return MyInt.wrap(x);\n    }\n    function add(MyInt a, MyInt b) pure external returns(MyInt) {\n        return MyInt.wrap(MyInt.unwrap(a) + MyInt.unwrap(b));\n    }\n}\n// ----\n// getX() -> 0\n// gas irOptimized: 23379\n// gas legacy: 23608\n// gas legacyOptimized: 23311\n// setX(int256): 5 ->\n// gas irOptimized: 43510\n// gas legacy: 43724\n// gas legacyOptimized: 43516\n// getX() -> 5\n// gas irOptimized: 23379\n// gas legacy: 23608\n// gas legacyOptimized: 23311\n// add(int256,int256): 200, 99 -> 299\n// gas irOptimized: 21764\n// gas legacy: 22523\n// gas legacyOptimized: 21813\n"
        },
        "zero_cost_abstraction_comparison_elementary.sol": {
            "content": "// a test to compare the cost between using user defined value types and elementary type. See the\n// test zero_cost_abstraction_userdefined.sol for a comparison.\n\npragma abicoder v2;\n\ncontract C {\n    int x;\n    function setX(int _x) external {\n        x = _x;\n    }\n    function getX() view external returns (int) {\n        return x;\n    }\n    function add(int a, int b) view external returns (int) {\n        return a + b;\n    }\n}\n// ----\n// getX() -> 0\n// gas irOptimized: 23379\n// gas legacy: 23479\n// gas legacyOptimized: 23311\n// setX(int256): 5 ->\n// gas irOptimized: 43510\n// gas legacy: 43724\n// gas legacyOptimized: 43516\n// getX() -> 5\n// gas irOptimized: 23379\n// gas legacy: 23479\n// gas legacyOptimized: 23311\n// add(int256,int256): 200, 99 -> 299\n// gas irOptimized: 21764\n// gas legacy: 22394\n// gas legacyOptimized: 21813\n"
        },
        "constant.sol": {
            "content": "type T is int224;\npragma solidity >= 0.0.0;\ncontract C {\n  T constant public s = T.wrap(int224(165521356710917456517261742455526507355687727119203895813322792776));\n  T constant public t = s;\n  int224 constant public u = T.unwrap(t);\n}\n// ----\n// s() -> 165521356710917456517261742455526507355687727119203895813322792776\n// t() -> 165521356710917456517261742455526507355687727119203895813322792776\n// u() -> 165521356710917456517261742455526507355687727119203895813322792776\n"
        },
        "storage_layout_struct.sol": {
            "content": "type MyInt64 is int64;\nstruct HalfSlot {\n    MyInt64 a;\n    MyInt64 b;\n}\n\nstruct RegularHalfSlot {\n    int64 a;\n    int64 b;\n}\n\ntype MyAddress is address;\ntype MyInt96 is int96;\nstruct FullSlot {\n    MyInt96 a;\n    MyAddress b;\n}\nstruct RegularFullSlot {\n    int96 a;\n    address b;\n}\n\ncontract C {\n    HalfSlot public a;\n    RegularHalfSlot public ra;\n\n    HalfSlot public b;\n    RegularHalfSlot public rb;\n\n    HalfSlot public c;\n    RegularHalfSlot public rc;\n\n    FullSlot public d;\n    RegularFullSlot public rd;\n\n    function storage_a() pure external returns(uint slot, uint offset) {\n        assembly {\n            slot := a.slot\n            offset := a.offset\n        }\n    }\n\n    function storage_ra() pure external returns(uint slot, uint offset) {\n        assembly {\n            slot := ra.slot\n            offset := ra.offset\n        }\n    }\n\n    function storage_b() pure external returns(uint slot, uint offset) {\n        assembly {\n            slot := b.slot\n            offset := b.offset\n        }\n    }\n\n    function storage_rb() pure external returns(uint slot, uint offset) {\n        assembly {\n            slot := rb.slot\n            offset := rb.offset\n        }\n    }\n\n   function storage_c() pure external returns(uint slot, uint offset) {\n        assembly {\n            slot := c.slot\n            offset := c.offset\n        }\n    }\n\n   function storage_rc() pure external returns(uint slot, uint offset) {\n        assembly {\n            slot := rc.slot\n            offset := rc.offset\n        }\n    }\n\n   function storage_d() pure external returns(uint slot, uint offset) {\n        assembly {\n            slot := d.slot\n            offset := d.offset\n        }\n    }\n\n   function storage_rd() pure external returns(uint slot, uint offset) {\n        assembly {\n            slot := rd.slot\n            offset := rd.offset\n        }\n    }\n\n\n   function set_a(MyInt64 _a, MyInt64 _b) external {\n       a.a = _a;\n       a.b = _b;\n   }\n\n   function set_ra(int64 _a, int64 _b) external {\n       ra.a = _a;\n       ra.b = _b;\n   }\n\n   function set_b(MyInt64 _a, MyInt64 _b) external {\n       b.a = _a;\n       b.b = _b;\n   }\n\n   function set_rb(int64 _a, int64 _b) external {\n       rb.a = _a;\n       rb.b = _b;\n   }\n\n   function set_c(MyInt64 _a, MyInt64 _b) external {\n       c.a = _a;\n       c.b = _b;\n   }\n\n   function set_rc(int64 _a, int64 _b) external {\n       rc.a = _a;\n       rc.b = _b;\n   }\n\n   function set_d(MyInt96 _a, MyAddress _b) external {\n       d.a = _a;\n       d.b = _b;\n   }\n\n   function set_rd(int96 _a, address _b) external {\n       rd.a = _a;\n       rd.b = _b;\n   }\n\n   function read_slot(uint slot) view external returns (uint value) {\n       assembly {\n           value := sload(slot)\n       }\n   }\n\n   function read_contents_asm() external returns (bytes32 rxa, bytes32 rya, bytes32 rxb, bytes32 ryb) {\n       b.a = MyInt64.wrap(-2);\n       b.b = MyInt64.wrap(-3);\n       HalfSlot memory x = b;\n       MyInt64 y = b.a;\n       MyInt64 z = b.b;\n       assembly {\n           rxa := mload(x)\n           rya := y\n           rxb := mload(add(x, 0x20))\n           ryb := z\n       }\n   }\n}\n// ----\n// storage_a() -> 0, 0\n// set_a(int64,int64): 100, 200 ->\n// read_slot(uint256): 0 -> 0xc80000000000000064\n// storage_ra() -> 1, 0\n// set_ra(int64,int64): 100, 200 ->\n// read_slot(uint256): 1 -> 0xc80000000000000064\n// storage_b() -> 2, 0\n// set_b(int64,int64): 0, 200 ->\n// read_slot(uint256): 2 -> 3689348814741910323200\n// storage_rb() -> 3, 0\n// set_rb(int64,int64): 0, 200 ->\n// read_slot(uint256): 3 -> 3689348814741910323200\n// storage_c() -> 4, 0\n// set_c(int64,int64): 100, 0 ->\n// read_slot(uint256): 4 -> 0x64\n// storage_rc() -> 5, 0\n// set_rc(int64,int64): 100, 0 ->\n// read_slot(uint256): 5 -> 0x64\n// storage_d() -> 6, 0\n// set_d(int96,address): 39614081257132168796771975167, 1461501637330902918203684832716283019655932542975 ->\n// read_slot(uint256): 6 -> -39614081257132168796771975169\n// storage_rd() -> 7, 0\n// set_rd(int96,address): 39614081257132168796771975167, 1461501637330902918203684832716283019655932542975 ->\n// read_slot(uint256): 7 -> -39614081257132168796771975169\n// read_contents_asm() -> 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe, 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe, 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd, 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd\n"
        },
        "erc20.sol": {
            "content": "pragma abicoder v2;\n// A rewrite of the test/libsolidity/semanticTests/various/erc20.sol, but using user defined value\n// types.\n\n// User defined type name. Indicating a type with 18 decimals.\ntype UFixed18 is uint256;\n\nlibrary FixedMath\n{\n    function add(UFixed18 a, UFixed18 b) internal pure returns (UFixed18 c) {\n        return UFixed18.wrap(UFixed18.unwrap(a) + UFixed18.unwrap(b));\n    }\n    function sub(UFixed18 a, UFixed18 b) internal pure returns (UFixed18 c) {\n        return UFixed18.wrap(UFixed18.unwrap(a) - UFixed18.unwrap(b));\n    }\n}\n\ncontract ERC20 {\n    using FixedMath for UFixed18;\n\n    event Transfer(address indexed from, address indexed to, UFixed18 value);\n    event Approval(address indexed owner, address indexed spender, UFixed18 value);\n\n    mapping (address => UFixed18) private _balances;\n    mapping (address => mapping (address => UFixed18)) private _allowances;\n    UFixed18 private _totalSupply;\n\n    constructor() {\n        _mint(msg.sender, UFixed18.wrap(20));\n    }\n\n    function totalSupply() public view returns (UFixed18) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address owner) public view returns (UFixed18) {\n        return _balances[owner];\n    }\n\n    function allowance(address owner, address spender) public view returns (UFixed18) {\n        return _allowances[owner][spender];\n    }\n\n    function transfer(address to, UFixed18 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function approve(address spender, UFixed18 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, UFixed18 value) public returns (bool) {\n        _transfer(from, to, value);\n        // The subtraction here will revert on overflow.\n        _approve(from, msg.sender, _allowances[from][msg.sender].sub(value));\n        return true;\n    }\n\n    function increaseAllowance(address spender, UFixed18 addedValue) public returns (bool) {\n        // The addition here will revert on overflow.\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, UFixed18 subtractedValue) public returns (bool) {\n        // The subtraction here will revert on overflow.\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    function _transfer(address from, address to, UFixed18 value) internal {\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        // The subtraction and addition here will revert on overflow.\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function _mint(address account, UFixed18 value) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        // The additions here will revert on overflow.\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\n\n    function _burn(address account, UFixed18 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        // The subtractions here will revert on overflow.\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    function _approve(address owner, address spender, UFixed18 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _burnFrom(address account, UFixed18 value) internal {\n        _burn(account, value);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(value));\n    }\n}\n// ----\n// constructor()\n// ~ emit Transfer(address,address,uint256): #0x00, #0x1212121212121212121212121212120000000012, 0x14\n// gas irOptimized: 121322\n// gas irOptimized code: 234600\n// gas legacy: 163350\n// gas legacy code: 671400\n// gas legacyOptimized: 127464\n// gas legacyOptimized code: 285400\n// totalSupply() -> 20\n// gas irOptimized: 23415\n// gas legacy: 23653\n// gas legacyOptimized: 23368\n// transfer(address,uint256): 2, 5 -> true\n// ~ emit Transfer(address,address,uint256): #0x1212121212121212121212121212120000000012, #0x02, 0x05\n// gas irOptimized: 48471\n// gas legacy: 49572\n// gas legacyOptimized: 48575\n// decreaseAllowance(address,uint256): 2, 0 -> true\n// ~ emit Approval(address,address,uint256): #0x1212121212121212121212121212120000000012, #0x02, 0x00\n// gas irOptimized: 26275\n// gas legacy: 27204\n// gas legacyOptimized: 26317\n// decreaseAllowance(address,uint256): 2, 1 -> FAILURE, hex\"4e487b71\", 0x11\n// gas irOptimized: 24042\n// gas legacy: 24506\n// gas legacyOptimized: 24077\n// transfer(address,uint256): 2, 14 -> true\n// ~ emit Transfer(address,address,uint256): #0x1212121212121212121212121212120000000012, #0x02, 0x0e\n// gas irOptimized: 28571\n// gas legacy: 29672\n// gas legacyOptimized: 28675\n// transfer(address,uint256): 2, 2 -> FAILURE, hex\"4e487b71\", 0x11\n// gas irOptimized: 24071\n// gas legacy: 24492\n// gas legacyOptimized: 24074\n"
        },
        "conversion.sol": {
            "content": "pragma abicoder v2;\n\ntype MyUInt8 is uint8;\ntype MyInt8 is int8;\ntype MyUInt16 is uint16;\n\ncontract C {\n    function f(uint a) external returns(MyUInt8) {\n        return MyUInt8.wrap(uint8(a));\n    }\n    function g(uint a) external returns(MyInt8) {\n        return MyInt8.wrap(int8(int(a)));\n    }\n    function h(MyUInt8 a) external returns (MyInt8) {\n        return MyInt8.wrap(int8(MyUInt8.unwrap(a)));\n    }\n    function i(MyUInt8 a) external returns(MyUInt16) {\n        return MyUInt16.wrap(MyUInt8.unwrap(a));\n    }\n    function j(MyUInt8 a) external returns (uint) {\n        return MyUInt8.unwrap(a);\n    }\n    function k(MyUInt8 a) external returns (MyUInt16) {\n        return MyUInt16.wrap(MyUInt8.unwrap(a));\n    }\n    function m(MyUInt16 a) external returns (MyUInt8) {\n        return MyUInt8.wrap(uint8(MyUInt16.unwrap(a)));\n    }\n}\n// ----\n// f(uint256): 1 -> 1\n// f(uint256): 2 -> 2\n// f(uint256): 257 -> 1\n// g(uint256): 1 -> 1\n// g(uint256): 2 -> 2\n// g(uint256): 255 -> -1\n// g(uint256): 257 -> 1\n// h(uint8): 1 -> 1\n// h(uint8): 2 -> 2\n// h(uint8): 255 -> -1\n// h(uint8): 257 -> FAILURE\n// i(uint8): 250 -> 250\n// j(uint8): 1 -> 1\n// j(uint8): 2 -> 2\n// j(uint8): 255 -> 0xff\n// j(uint8): 257 -> FAILURE\n// k(uint8): 1 -> 1\n// k(uint8): 2 -> 2\n// k(uint8): 255 -> 0xff\n// k(uint8): 257 -> FAILURE\n// m(uint16): 1 -> 1\n// m(uint16): 2 -> 2\n// m(uint16): 255 -> 0xff\n// m(uint16): 257 -> 1\n"
        },
        "dirty_uint8_read.sol": {
            "content": "type MyInt8 is int8;\ncontract C {\n    MyInt8 public x = MyInt8.wrap(-5);\n\n    /// The most significant bit is flipped to 0\n    function create_dirty_slot() external {\n        uint mask  = 2**255 -1;\n        assembly {\n            let value := sload(x.slot)\n            sstore(x.slot, and(mask, value))\n        }\n    }\n\n    function read_unclean_value() external returns (bytes32 ret) {\n        MyInt8 value = x;\n        assembly {\n            ret := value\n        }\n    }\n}\n// ----\n// x() -> -5\n// create_dirty_slot() ->\n// read_unclean_value() -> 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\n"
        },
        "ownable.sol": {
            "content": "// Implementation of OpenZepplin's\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\n// using user defined value types.\n\ncontract Ownable {\n    type Owner is address;\n    Owner public owner = Owner.wrap(msg.sender);\n    error OnlyOwner();\n    modifier onlyOwner() {\n        if (Owner.unwrap(owner) != msg.sender)\n            revert OnlyOwner();\n\n        _;\n    }\n    event OwnershipTransferred(Owner indexed previousOwner, Owner indexed newOwner);\n    function setOwner(Owner newOwner) onlyOwner external {\n        emit OwnershipTransferred({previousOwner: owner, newOwner: newOwner});\n        owner = newOwner;\n    }\n    function renounceOwnership() onlyOwner external {\n        owner = Owner.wrap(address(0));\n    }\n}\n// ----\n// owner() -> 0x1212121212121212121212121212120000000012\n// setOwner(address): 0x1212121212121212121212121212120000000012 ->\n// ~ emit OwnershipTransferred(address,address): #0x1212121212121212121212121212120000000012, #0x1212121212121212121212121212120000000012\n// renounceOwnership() ->\n// owner() -> 0\n// setOwner(address): 0x1212121212121212121212121212120000000012 -> FAILURE, hex\"5fc483c5\"\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200,
            "details": {
                "peephole": false,
                "inliner": false,
                "jumpdestRemover": false,
                "orderLiterals": false,
                "deduplicate": false,
                "cse": false,
                "constantOptimizer": false
            }
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "metadata",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ]
            }
        }
    }
}