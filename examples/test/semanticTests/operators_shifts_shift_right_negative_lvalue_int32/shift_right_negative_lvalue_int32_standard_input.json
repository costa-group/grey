{
    "language": "Solidity",
    "sources": {
        "shift_right_garbled_v2.sol": {
            "content": "pragma abicoder               v2;\n\n\ncontract C {\n    function f(uint8 a, uint8 b) public returns (uint256) {\n        assembly {\n            a := 0xffffffff\n        }\n        // Higher bits should be cleared before the shift\n        return a >> b;\n    }\n}\n// ----\n// f(uint8,uint8): 0x00, 0x04 -> 0x0f\n// f(uint8,uint8): 0x00, 0x1004 -> FAILURE\n"
        },
        "shift_left_uint8.sol": {
            "content": "contract C {\n    function f(uint8 a, uint8 b) public returns (uint256) {\n        return a << b;\n    }\n}\n// ----\n// f(uint8,uint8): 0x66, 0x0 -> 0x66\n// f(uint8,uint8): 0x66, 0x8 -> 0\n"
        },
        "shift_right_garbled_v1.sol": {
            "content": "pragma abicoder v1;\ncontract C {\n    function f(uint8 a, uint8 b) public returns (uint256) {\n        assembly {\n            a := 0xffffffff\n        }\n        // Higher bits should be cleared before the shift\n        return a >> b;\n    }\n}\n// ====\n// ABIEncoderV1Only: true\n// compileViaYul: false\n// ----\n// f(uint8,uint8): 0x00, 0x04 -> 0x0f\n// f(uint8,uint8): 0x00, 0x1004 -> 0x0f\n"
        },
        "shift_negative_constant_right.sol": {
            "content": "contract C {\n    int256 public a = -0x4200 >> 8;\n}\n// ----\n// a() -> -66\n"
        },
        "bitwise_shifting_constantinople_combined.sol": {
            "content": "contract C {\n    function shl_zero(uint256 a) public returns (uint256 c) {\n        assembly {\n            c := shl(0, a)\n        }\n    }\n\n    function shr_zero(uint256 a) public returns (uint256 c) {\n        assembly {\n            c := shr(0, a)\n        }\n    }\n\n    function sar_zero(uint256 a) public returns (uint256 c) {\n        assembly {\n            c := sar(0, a)\n        }\n    }\n\n    function shl_large(uint256 a) public returns (uint256 c) {\n        assembly {\n            c := shl(0x110, a)\n        }\n    }\n\n    function shr_large(uint256 a) public returns (uint256 c) {\n        assembly {\n            c := shr(0x110, a)\n        }\n    }\n\n    function sar_large(uint256 a) public returns (uint256 c) {\n        assembly {\n            c := sar(0x110, a)\n        }\n    }\n\n    function shl_combined(uint256 a) public returns (uint256 c) {\n        assembly {\n            c := shl(4, shl(12, a))\n        }\n    }\n\n    function shr_combined(uint256 a) public returns (uint256 c) {\n        assembly {\n            c := shr(4, shr(12, a))\n        }\n    }\n\n    function sar_combined(uint256 a) public returns (uint256 c) {\n        assembly {\n            c := sar(4, sar(12, a))\n        }\n    }\n\n    function shl_combined_large(uint256 a) public returns (uint256 c) {\n        assembly {\n            c := shl(0xd0, shl(0x40, a))\n        }\n    }\n\n    function shl_combined_overflow(uint256 a) public returns (uint256 c) {\n        assembly {\n            c := shl(0x01, shl(not(0x00), a))\n        }\n    }\n\n    function shr_combined_large(uint256 a) public returns (uint256 c) {\n        assembly {\n            c := shr(0xd0, shr(0x40, a))\n        }\n    }\n\n    function shr_combined_overflow(uint256 a) public returns (uint256 c) {\n        assembly {\n            c := shr(0x01, shr(not(0x00), a))\n        }\n    }\n\n    function sar_combined_large(uint256 a) public returns (uint256 c) {\n        assembly {\n            c := sar(0xd0, sar(0x40, a))\n        }\n    }\n}\n// ====\n// EVMVersion: >=constantinople\n// ----\n// shl_zero(uint256): 0x00 -> 0x00\n// shl_zero(uint256): 0xffff -> 0xffff\n// shl_zero(uint256): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff -> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n// shr_zero(uint256): 0x00 -> 0x00\n// shr_zero(uint256): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff -> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n// sar_zero(uint256): 0x00 -> 0x00\n// sar_zero(uint256): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff -> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n// shl_large(uint256): 0x00 -> 0x00\n// shl_large(uint256): 0xffff -> 0x00\n// shl_large(uint256): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff -> 0x00\n// shr_large(uint256): 0x00 -> 0x00\n// shr_large(uint256): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff -> 0x00\n// sar_large(uint256): 0x00 -> 0x00\n// sar_large(uint256): 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff -> 0x00\n// sar_large(uint256): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff -> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n// shl_combined(uint256): 0x00 -> 0x00\n// shl_combined(uint256): 0xffff -> 0xffff0000\n// shl_combined(uint256): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff -> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000\n// shr_combined(uint256): 0x00 -> 0x00\n// shr_combined(uint256): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff -> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n// sar_combined(uint256): 0x00 -> 0x00\n// sar_combined(uint256): 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff -> 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n// sar_combined(uint256): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff -> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n// shl_combined_large(uint256): 0x00 -> 0x00\n// shl_combined_large(uint256): 0xffff -> 0x00\n// shl_combined_large(uint256): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff -> 0x00\n// shl_combined_overflow(uint256): 0x02 -> 0x00\n// shr_combined_large(uint256): 0x00 -> 0x00\n// shr_combined_large(uint256): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff -> 0x00\n// shr_combined_overflow(uint256): 0x02 -> 0x00\n// sar_combined_large(uint256): 0x00 -> 0x00\n// sar_combined_large(uint256): 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff -> 0x00\n// sar_combined_large(uint256): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff -> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n"
        },
        "shift_bytes_cleanup_viaYul.sol": {
            "content": "contract C {\n\tfunction l(uint8 y) public returns (bytes20) {\n\t\tbytes20 x;\n\t\tassembly { x := \"12345678901234567890abcde\" }\n\t\t// When compiling via IR, `x` is truncated before applying\n\t\t// the operation.\n\t\treturn x << y;\n\t}\n\tfunction r(uint8 y) public returns (bytes20) {\n\t\tbytes20 x;\n\t\tassembly { x := \"12345678901234567890abcde\" }\n\t\treturn x >> y;\n\t}\n}\n// ====\n// compileViaYul: true\n// ----\n// l(uint8): 64 -> 0x3930313233343536373839300000000000000000000000000000000000000000\n// r(uint8): 64 -> 0x313233343536373839303132000000000000000000000000\n"
        },
        "shift_left_uint32.sol": {
            "content": "contract C {\n    function f(uint32 a, uint32 b) public returns (uint256) {\n        return a << b;\n    }\n}\n// ----\n// f(uint32,uint32): 0x4266, 0x0 -> 0x4266\n// f(uint32,uint32): 0x4266, 0x8 -> 0x426600\n// f(uint32,uint32): 0x4266, 0x10 -> 0x42660000\n// f(uint32,uint32): 0x4266, 0x11 -> 0x84cc0000\n// f(uint32,uint32): 0x4266, 0x20 -> 0\n"
        },
        "bitwise_shifting_constantinople.sol": {
            "content": "contract C {\n    function shl(uint256 a, uint256 b) public returns (uint256 c) {\n        assembly {\n            c := shl(b, a)\n        }\n    }\n\n    function shr(uint256 a, uint256 b) public returns (uint256 c) {\n        assembly {\n            c := shr(b, a)\n        }\n    }\n\n    function sar(uint256 a, uint256 b) public returns (uint256 c) {\n        assembly {\n            c := sar(b, a)\n        }\n    }\n}\n// ====\n// EVMVersion: >=constantinople\n// ----\n// shl(uint256,uint256): 0x01, 0x02 -> 0x04\n// shl(uint256,uint256): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0x01 -> 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\n// shl(uint256,uint256): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0x100 -> 0x00\n// shr(uint256,uint256): 0x03, 0x01 -> 0x01\n// shr(uint256,uint256): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0x01 -> 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n// shr(uint256,uint256): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0xff -> 0x01\n// shr(uint256,uint256): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0x100 -> 0x00\n// sar(uint256,uint256): 0x03, 0x01 -> 0x01\n// sar(uint256,uint256): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0x01 -> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n// sar(uint256,uint256): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0xff -> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n// sar(uint256,uint256): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0x100 -> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n"
        },
        "shift_right.sol": {
            "content": "contract C {\n    function f(uint256 a, uint256 b) public returns (uint256) {\n        return a >> b;\n    }\n}\n// ----\n// f(uint256,uint256): 0x4266, 0x0 -> 0x4266\n// f(uint256,uint256): 0x4266, 0x8 -> 0x42\n// f(uint256,uint256): 0x4266, 0x10 -> 0\n// f(uint256,uint256): 0x4266, 0x11 -> 0\n// f(uint256,uint256): 57896044618658097711785492504343953926634992332820282019728792003956564819968, 5 -> 1809251394333065553493296640760748560207343510400633813116524750123642650624\n"
        },
        "shift_bytes_cleanup.sol": {
            "content": "contract C {\n\tfunction l(uint8 y) public returns (bytes20) {\n\t\tbytes20 x;\n\t\tassembly { x := \"12345678901234567890abcde\" }\n\t\t// When compiling via IR, `x` is truncated before applying\n\t\t// the operation.\n\t\treturn x << y;\n\t}\n\tfunction r(uint8 y) public returns (bytes20) {\n\t\tbytes20 x;\n\t\tassembly { x := \"12345678901234567890abcde\" }\n\t\treturn x >> y;\n\t}\n}\n// ====\n// compileViaYul: false\n// ----\n// l(uint8): 64 -> 0x3930313233343536373839300000000000000000000000000000000000000000\n// r(uint8): 64 -> 0x313233343536373839303132000000000000000000000000\n"
        },
        "shift_constant_left.sol": {
            "content": "contract C {\n    uint256 public a = 0x42 << 8;\n}\n// ----\n// a() -> 0x4200\n"
        },
        "shift_cleanup.sol": {
            "content": "contract C {\n    function f() public returns (uint16 x) {\n        unchecked {\n            x = 0xffff;\n            x += 32;\n            x <<= 8;\n            x >>= 16;\n        }\n    }\n}\n// ----\n// f() -> 0x0\n"
        },
        "shift_right_negative_lvalue_signextend_int32_v2.sol": {
            "content": "pragma abicoder               v2;\n\n\ncontract C {\n    function f(int32 a, uint32 b) public returns (int32) {\n        return a >> b;\n    }\n}\n// ----\n// f(int32,uint32): 0xffffff99, 0x00 -> FAILURE\n// f(int32,uint32): 0xffffff99, 0x01 -> FAILURE\n// f(int32,uint32): 0xffffff99, 0x02 -> FAILURE\n// f(int32,uint32): 0xffffff99, 0x04 -> FAILURE\n// f(int32,uint32): 0xffffff99, 0x08 -> FAILURE\n"
        },
        "shift_right_negative_lvalue_signextend_int16_v2.sol": {
            "content": "pragma abicoder               v2;\n\n\ncontract C {\n    function f(int16 a, uint16 b) public returns (int16) {\n        return a >> b;\n    }\n}\n// ----\n// f(int16,uint16): 0xff99, 0x00 -> FAILURE\n// f(int16,uint16): 0xff99, 0x01 -> FAILURE\n// f(int16,uint16): 0xff99, 0x02 -> FAILURE\n// f(int16,uint16): 0xff99, 0x04 -> FAILURE\n// f(int16,uint16): 0xff99, 0x08 -> FAILURE\n"
        },
        "shift_right_negative_lvalue_signextend_int32_v1.sol": {
            "content": "pragma abicoder v1;\ncontract C {\n    function f(int32 a, uint32 b) public returns (int32) {\n        return a >> b;\n    }\n}\n// ====\n// ABIEncoderV1Only: true\n// compileViaYul: false\n// ----\n// f(int32,uint32): 0xffffff99, 0x00 -> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff99\n// f(int32,uint32): 0xffffff99, 0x01 -> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffcc\n// f(int32,uint32): 0xffffff99, 0x02 -> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe6\n// f(int32,uint32): 0xffffff99, 0x04 -> 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9\n// f(int32,uint32): 0xffffff99, 0x08 -> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n"
        },
        "shift_right_uint32.sol": {
            "content": "contract C {\n    function f(uint32 a, uint32 b) public returns (uint256) {\n        return a >> b;\n    }\n}\n// ----\n// f(uint32,uint32): 0x4266, 0x0 -> 0x4266\n// f(uint32,uint32): 0x4266, 0x8 -> 0x42\n// f(uint32,uint32): 0x4266, 0x10 -> 0\n// f(uint32,uint32): 0x4266, 0x11 -> 0\n"
        },
        "shift_cleanup_garbled.sol": {
            "content": "contract C {\n    function f() public returns (uint8 x) {\n        assembly {\n            x := 0xffff\n        }\n        x >>= 8;\n    }\n}\n// ----\n// f() -> 0x0\n"
        },
        "shift_negative_constant_left.sol": {
            "content": "contract C {\n    int256 public a = -0x42 << 8;\n}\n// ----\n// a() -> -16896\n"
        },
        "shift_right_negative_lvalue_signextend_int16_v1.sol": {
            "content": "pragma abicoder v1;\ncontract C {\n    function f(int16 a, uint16 b) public returns (int16) {\n        return a >> b;\n    }\n}\n// ====\n// ABIEncoderV1Only: true\n// compileViaYul: false\n// ----\n// f(int16,uint16): 0xff99, 0x00 -> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff99\n// f(int16,uint16): 0xff99, 0x01 -> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffcc\n// f(int16,uint16): 0xff99, 0x02 -> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe6\n// f(int16,uint16): 0xff99, 0x04 -> 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9\n// f(int16,uint16): 0xff99, 0x08 -> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n"
        },
        "shift_right_negative_lvalue.sol": {
            "content": "contract C {\n    function f(int256 a, uint256 b) public returns (int256) {\n        return a >> b;\n    }\n}\n// ----\n// f(int256,uint256): -4266, 0 -> -4266\n// f(int256,uint256): -4266, 1 -> -2133\n// f(int256,uint256): -4266, 4 -> -267\n// f(int256,uint256): -4266, 8 -> -17\n// f(int256,uint256): -4266, 16 -> -1\n// f(int256,uint256): -4266, 17 -> -1\n// f(int256,uint256): -4267, 0 -> -4267\n// f(int256,uint256): -4267, 1 -> -2134\n// f(int256,uint256): -4267, 4 -> -267\n// f(int256,uint256): -4267, 8 -> -17\n// f(int256,uint256): -4267, 16 -> -1\n// f(int256,uint256): -4267, 17 -> -1\n"
        },
        "shift_right_uint8.sol": {
            "content": "contract C {\n    function f(uint8 a, uint8 b) public returns (uint256) {\n        return a >> b;\n    }\n}\n// ----\n// f(uint8,uint8): 0x66, 0x0 -> 0x66\n// f(uint8,uint8): 0x66, 0x8 -> 0x0\n"
        },
        "shift_right_negative_lvalue_assignment.sol": {
            "content": "contract C {\n    function f(int256 a, uint256 b) public returns (int256) {\n        a >>= b;\n        return a;\n    }\n}\n// ----\n// f(int256,uint256): -4266, 0 -> -4266\n// f(int256,uint256): -4266, 1 -> -2133\n// f(int256,uint256): -4266, 4 -> -267\n// f(int256,uint256): -4266, 8 -> -17\n// f(int256,uint256): -4266, 16 -> -1\n// f(int256,uint256): -4266, 17 -> -1\n// f(int256,uint256): -4267, 0 -> -4267\n// f(int256,uint256): -4267, 1 -> -2134\n// f(int256,uint256): -4267, 4 -> -267\n// f(int256,uint256): -4267, 8 -> -17\n// f(int256,uint256): -4267, 16 -> -1\n// f(int256,uint256): -4267, 17 -> -1\n"
        },
        "shifts.sol": {
            "content": "contract C {\n    function f(uint x) public returns (uint y) {\n        assembly { y := shl(2, x) }\n    }\n}\n// ====\n// EVMVersion: >=constantinople\n// ----\n// f(uint256): 7 -> 28\n"
        },
        "shift_right_negative_lvalue_int16.sol": {
            "content": "contract C {\n    function f(int16 a, uint16 b) public returns (int256) {\n        return a >> b;\n    }\n}\n// ----\n// f(int16,uint16): -4266, 0 -> -4266\n// f(int16,uint16): -4266, 1 -> -2133\n// f(int16,uint16): -4266, 4 -> -267\n// f(int16,uint16): -4266, 8 -> -17\n// f(int16,uint16): -4266, 16 -> -1\n// f(int16,uint16): -4266, 17 -> -1\n// f(int16,uint16): -4267, 0 -> -4267\n// f(int16,uint16): -4267, 1 -> -2134\n// f(int16,uint16): -4267, 4 -> -267\n// f(int16,uint16): -4267, 8 -> -17\n// f(int16,uint16): -4267, 16 -> -1\n// f(int16,uint16): -4267, 17 -> -1\n"
        },
        "shift_left.sol": {
            "content": "contract C {\n    function f(uint256 a, uint256 b) public returns (uint256) {\n        return a << b;\n    }\n}\n// ----\n// f(uint256,uint256): 0x4266, 0x0 -> 0x4266\n// f(uint256,uint256): 0x4266, 0x8 -> 0x426600\n// f(uint256,uint256): 0x4266, 0x10 -> 0x42660000\n// f(uint256,uint256): 0x4266, 0x11 -> 0x84cc0000\n// f(uint256,uint256): 0x4266, 0xf0 -> 0x4266000000000000000000000000000000000000000000000000000000000000\n// f(uint256,uint256): 0x4266, 0x100 -> 0\n"
        },
        "shift_overflow.sol": {
            "content": "contract C {\n    function leftU(uint8 x, uint8 y) public returns (uint8) {\n        return x << y;\n    }\n\n    function leftS(int8 x, uint8 y) public returns (int8) {\n        return x << y;\n    }\n}\n// ----\n// leftU(uint8,uint8): 255, 8 -> 0\n// leftU(uint8,uint8): 255, 1 -> 254\n// leftU(uint8,uint8): 255, 0 -> 255\n// leftS(int8,uint8): 1, 7 -> -128 # Result is -128 and output is sign-extended, not zero-padded. #\n// leftS(int8,uint8): 1, 6 -> 64\n"
        },
        "shift_right_negative_lvalue_int32.sol": {
            "content": "contract C {\n    function f(int32 a, uint32 b) public returns (int256) {\n        return a >> b;\n    }\n}\n// ----\n// f(int32,uint32): -4266, 0 -> -4266\n// f(int32,uint32): -4266, 1 -> -2133\n// f(int32,uint32): -4266, 4 -> -267\n// f(int32,uint32): -4266, 8 -> -17\n// f(int32,uint32): -4266, 16 -> -1\n// f(int32,uint32): -4266, 17 -> -1\n// f(int32,uint32): -4267, 0 -> -4267\n// f(int32,uint32): -4267, 1 -> -2134\n// f(int32,uint32): -4267, 4 -> -267\n// f(int32,uint32): -4267, 8 -> -17\n// f(int32,uint32): -4267, 16 -> -1\n// f(int32,uint32): -4267, 17 -> -1\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200,
            "details": {
                "peephole": false,
                "inliner": false,
                "jumpdestRemover": false,
                "orderLiterals": false,
                "deduplicate": false,
                "cse": false,
                "constantOptimizer": false
            }
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "metadata",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ]
            }
        }
    }
}