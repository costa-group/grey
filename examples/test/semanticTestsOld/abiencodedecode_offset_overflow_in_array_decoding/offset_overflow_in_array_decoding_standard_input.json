{"language": "Solidity", "sources": {"offset_overflow_in_array_decoding.sol": {"content": "pragma abicoder v2;\ncontract Test {\n\tstruct MemoryUint {\n\t\tuint field;\n\t}\n\tfunction test() public pure returns (uint) {\n\t\tuint[] memory before = new uint[](1); // at offset 0x80\n\t\t// Two problems here: The first offset is zero, the second offset is missing.\n\t\tbytes memory corrupt = abi.encode(uint(32), // offset to \"tuple\"\n\t\t\t\t\t\t\t\t\t\t  uint(0)); // bogus first element\n\t\t/*\n\t\t  At this point the free pointer is 0x80 + 64 (size of before) + 32 (length field of corrupt) + 64 (two encoded words)\n\n\t\t  Now let's put random junk into memory immediately after the bogus first element. Our goal is to overflow the read pointer to point to before.\n\t\t  The value read out at this point will be added to beginning of the encoded tuple, AKA corrupt + 64. We need then to write x where:\n\t\t  x + 0x80 + 64 (before) + 32 (length of corrupt) + 32 (first word of corrupt) = 0x80 (mod 2^256)\n\t\t  that is MAX_UINT - 128\n\t\t*/\n\t\tMemoryUint memory afterCorrupt;\n\t\tafterCorrupt.field = uint(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80);\n\t\tbefore[0] = 123456;\n\t\tuint[][2] memory decoded = abi.decode(corrupt, (uint[][2]));\n\t\treturn decoded[1][0];\n\t}\n}\n// ----\n// test() -> FAILURE\n"}}, "settings": {"optimizer": {"enabled": true, "runs": 200, "details": {"peephole": false, "inliner": false, "jumpdestRemover": false, "orderLiterals": false, "deduplicate": false, "cse": false, "constantOptimizer": false}}, "outputSelection": {"*": {"*": ["abi", "metadata", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers"]}}, "metadata": {"appendCBOR": false}}}