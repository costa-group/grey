{
    "language": "Solidity",
    "sources": {
        "unchecked_called_by_checked.sol": {
            "content": "contract C {\n    function add(uint16 a, uint16 b) public returns (uint16) {\n        unchecked {\n            return a + b;\n        }\n    }\n\n    function f(uint16 a) public returns (uint16) {\n        return add(a, 0x100) + 0x100;\n    }\n}\n// ----\n// f(uint16): 7 -> 0x0207\n// f(uint16): 0xffff -> 511\n// f(uint16): 0xfeff -> FAILURE, hex\"4e487b71\", 0x11\n"
        },
        "addmod_mulmod.sol": {
            "content": "contract C {\n    function test() public returns (uint256) {\n        // Note that this only works because computation on literals is done using\n        // unbounded integers.\n        if ((2**255 + 2**255) % 7 != addmod(2**255, 2**255, 7)) return 1;\n        if ((2**255 + 2**255) % 7 != addmod(2**255, 2**255, 7)) return 2;\n        return 0;\n    }\n}\n// ----\n// test() -> 0\n"
        },
        "block_inside_unchecked.sol": {
            "content": "contract C {\n  function f() public returns (uint y) {\n    unchecked{{\n        uint max = type(uint).max;\n        uint x = max + 1;\n        y = x;\n    }}\n  }\n}\n// ----\n// f() -> 0x00\n"
        },
        "unchecked_div_by_zero.sol": {
            "content": "contract C {\n    function div(uint256 a, uint256 b) public returns (uint256) {\n        // Does not disable div by zero check\n        unchecked {\n            return a / b;\n        }\n    }\n\n    function mod(uint256 a, uint256 b) public returns (uint256) {\n        // Does not disable div by zero check\n        unchecked {\n            return a % b;\n        }\n    }\n}\n// ----\n// div(uint256,uint256): 7, 2 -> 3\n// div(uint256,uint256): 7, 0 -> FAILURE, hex\"4e487b71\", 0x12 # throws #\n// mod(uint256,uint256): 7, 2 -> 1\n// mod(uint256,uint256): 7, 0 -> FAILURE, hex\"4e487b71\", 0x12 # throws #\n"
        },
        "checked_add_v2.sol": {
            "content": "pragma abicoder v2;\ncontract C {\n    function f(uint16 a, uint16 b) public returns (uint16) {\n        return a + b;\n    }\n}\n// ----\n// f(uint16,uint16): 65534, 0 -> 0xfffe\n// f(uint16,uint16): 65536, 0 -> FAILURE\n// f(uint16,uint16): 65535, 0 -> 0xffff\n// f(uint16,uint16): 65535, 1 -> FAILURE, hex\"4e487b71\", 0x11\n"
        },
        "checked_add_v1.sol": {
            "content": "pragma abicoder v1;\ncontract C {\n    // Input is still not checked - this needs ABIEncoderV2!\n    function f(uint16 a, uint16 b) public returns (uint16) {\n        return a + b;\n    }\n}\n// ====\n// ABIEncoderV1Only: true\n// compileViaYul: false\n// ----\n// f(uint16,uint16): 65534, 0 -> 0xfffe\n// f(uint16,uint16): 65536, 0 -> 0x00\n// f(uint16,uint16): 65535, 0 -> 0xffff\n// f(uint16,uint16): 65535, 1 -> FAILURE, hex\"4e487b71\", 0x11\n"
        },
        "checked_modifier_called_by_unchecked.sol": {
            "content": "contract C {\n    modifier add(uint16 a, uint16 b) {\n        unchecked { a + b; }\n        _;\n    }\n\n    function f(uint16 a, uint16 b, uint16 c) public add(a, b) returns (uint16) {\n        return b + c;\n    }\n}\n// ----\n// f(uint16,uint16,uint16): 0xe000, 0xe500, 2 -> 58626\n// f(uint16,uint16,uint16): 0x1000, 0xe500, 0xe000 -> FAILURE, hex\"4e487b71\", 0x11\n"
        },
        "addmod_mulmod_zero.sol": {
            "content": "contract C {\n    function f(uint256 d) public pure returns (uint256) {\n        addmod(1, 2, d);\n        return 2;\n    }\n\n    function g(uint256 d) public pure returns (uint256) {\n        mulmod(1, 2, d);\n        return 2;\n    }\n\n    function h() public pure returns (uint256) {\n        mulmod(0, 1, 2);\n        mulmod(1, 0, 2);\n        addmod(0, 1, 2);\n        addmod(1, 0, 2);\n        return 2;\n    }\n}\n// ----\n// f(uint256): 0 -> FAILURE, hex\"4e487b71\", 0x12\n// g(uint256): 0 -> FAILURE, hex\"4e487b71\", 0x12\n// h() -> 2\n"
        },
        "check_var_init.sol": {
            "content": "contract C {\n    uint public x = msg.value - 10;\n    constructor() payable {}\n}\n\ncontract D {\n    function f() public {\n        unchecked {\n            new C();\n        }\n    }\n    function g() public payable returns (uint) {\n        return (new C{value: 11}()).x();\n    }\n}\n// ----\n// f() -> FAILURE, hex\"4e487b71\", 0x11\n// g(), 100 wei -> 1\n// gas legacy: 76780\n// gas legacy code: 23600\n"
        },
        "signed_mod.sol": {
            "content": "contract C {\n    function f(int a, int b) public pure returns (int) {\n        return a % b;\n    }\n    function g(bool _check) public pure returns (int) {\n        int x = type(int).min;\n        if (_check) {\n            return x / -1;\n        } else {\n            unchecked { return x / -1; }\n        }\n    }\n}\n// ----\n// f(int256,int256): 7, 5 -> 2\n// f(int256,int256): 7, -5 -> 2\n// f(int256,int256): -7, 5 -> -2\n// f(int256,int256): -7, 5 -> -2\n// f(int256,int256): -5, -5 -> 0\n// g(bool): true -> FAILURE, hex\"4e487b71\", 0x11\n// g(bool): false -> -57896044618658097711785492504343953926634992332820282019728792003956564819968\n"
        },
        "exp_associativity.sol": {
            "content": "contract C {\n    // (2**3)**4 = 4096\n    // 2**(3**4) = 2417851639229258349412352\n    function test_hardcode1(uint a, uint b, uint c) public returns (uint256) {\n        return a**b**c;\n    }\n\n    // (3**2)**2)**2 = 6561\n    // 3**(2**(2**2) = 43046721\n    function test_hardcode2(uint a, uint b, uint c, uint d) public returns (uint256) {\n        return a**b**c**d;\n    }\n\n    function test_invariant(uint a, uint b, uint c) public returns (bool) {\n        return a**b**c == a**(b**c);\n    }\n\n    function test_literal_mix(uint a, uint b) public returns (bool) {\n        return\n            (a**2**b == a**(2**b)) &&\n            (2**a**b == 2**(a**b)) &&\n            (a**b**2 == a**(b**2));\n    }\n\n    function test_other_operators(uint a, uint b) public returns (bool) {\n        return\n            (a**b/25 == (a**b)/25) &&\n            (a**b*3**b == (a**b)*(3**b)) &&\n            (b**a**a/b**a**b == (b**(a**a))/(b**(a**b)));\n     }\n}\n// ----\n// test_hardcode1(uint256,uint256,uint256): 2, 3, 4 -> 2417851639229258349412352\n// test_hardcode2(uint256,uint256,uint256,uint256): 3, 2, 2, 2 -> 43046721\n// test_invariant(uint256,uint256,uint256): 2, 3, 4 -> true\n// test_invariant(uint256,uint256,uint256): 3, 4, 2 -> true\n// test_literal_mix(uint256,uint256): 2, 3 -> true\n// test_other_operators(uint256,uint256): 2, 4 -> true\n"
        },
        "checked_called_by_unchecked.sol": {
            "content": "contract C {\n    function add(uint16 a, uint16 b) public returns (uint16) {\n        return a + b;\n    }\n\n    function f(uint16 a, uint16 b, uint16 c) public returns (uint16) {\n        unchecked { return add(a, b) + c; }\n    }\n}\n// ----\n// f(uint16,uint16,uint16): 0xe000, 0xe500, 2 -> FAILURE, hex\"4e487b71\", 0x11\n// f(uint16,uint16,uint16): 0xe000, 0x1000, 0x1000 -> 0x00\n"
        },
        "divisiod_by_zero.sol": {
            "content": "contract C {\n    function div(uint256 a, uint256 b) public returns (uint256) {\n        return a / b;\n    }\n\n    function mod(uint256 a, uint256 b) public returns (uint256) {\n        return a % b;\n    }\n}\n// ----\n// div(uint256,uint256): 7, 2 -> 3\n// div(uint256,uint256): 7, 0 -> FAILURE, hex\"4e487b71\", 0x12 # throws #\n// mod(uint256,uint256): 7, 2 -> 1\n// mod(uint256,uint256): 7, 0 -> FAILURE, hex\"4e487b71\", 0x12 # throws #\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "metadata",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ]
            }
        }
    }
}