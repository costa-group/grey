{
    "language": "Solidity",
    "sources": {
        "packed_storage.sol": {
            "content": "contract C {\n    uint16 x;\n    bytes1 y;\n    uint16 z;\n    function f(uint8 a) public returns (uint _x) {\n        x = a;\n        y = bytes1(uint8(x) + 1);\n        z = uint8(y) + 1;\n        x = z + 1;\n        _x = x;\n    }\n}\n// ----\n// f(uint8): 6 -> 9\n"
        },
        "dirty_storage_dynamic_array.sol": {
            "content": "contract C {\n    uint8[] s;\n    function f() public returns (bool correct) {\n        s.push();\n        assembly {\n            mstore(0, s.slot)\n            sstore(keccak256(0, 0x20), 257)\n        }\n        uint8 x = s[0];\n        uint r;\n        assembly {\n            r := x\n        }\n        correct = (s[0] == 0x01) && (r == 0x01);\n    }\n}\n// ----\n// f() -> true\n"
        },
        "dirty_storage_bytes.sol": {
            "content": "contract C {\n    bytes b;\n    function f() public returns (bool correct) {\n        assembly {\n            sstore(b.slot, or(\"deadbeef\", 0x08))\n        }\n        bytes1 s = b[3];\n        uint r;\n        assembly {\n            r := s\n        }\n        correct = r == (0x64 << 248);\n    }\n}\n// ----\n// f() -> true\n"
        },
        "simple_storage.sol": {
            "content": "contract C {\n    uint x;\n    uint y;\n    function setX(uint a) public returns (uint _x) {\n        x = a;\n        _x = x;\n    }\n    function setY(uint a) public returns (uint _y) {\n        y = a;\n        _y = y;\n    }\n}\n// ----\n// setX(uint256): 6 -> 6\n// setY(uint256): 2 -> 2\n"
        },
        "dirty_storage_bytes_long.sol": {
            "content": "contract C {\n    bytes b;\n    function f() public returns (bool correct) {\n        assembly {\n            sstore(b.slot, 0x41)\n            mstore(0, b.slot)\n            sstore(keccak256(0, 0x20), \"deadbeefdeadbeefdeadbeefdeadbeef\")\n        }\n        bytes1 s = b[31];\n        uint r;\n        assembly {\n            r := s\n        }\n        correct = r == (0x66 << 248);\n    }\n}\n// ----\n// f() -> true\n"
        },
        "dirty_storage_struct.sol": {
            "content": "contract C {\n    struct S {\n        uint8[] m;\n    }\n    S s;\n    function f() public returns (bool correct) {\n        s.m.push();\n        assembly {\n            mstore(0, s.slot)\n            sstore(keccak256(0, 0x20), 257)\n        }\n        uint8 x = s.m[0];\n        uint r;\n        assembly {\n            r := x\n        }\n        correct = r == 0x01;\n    }\n}\n// ----\n// f() -> true\n"
        },
        "mappings.sol": {
            "content": "contract C {\n    mapping(uint => uint) simple;\n    mapping(uint16 => uint) cleanup;\n    mapping(string => uint) str;\n    mapping(uint => mapping(uint => uint)) twodim;\n    function test_simple(uint _off) public returns (uint _a, uint _b, uint _c) {\n        simple[_off + 2] = 3;\n        simple[_off + 3] = 4;\n        simple[type(uint256).max] = 5;\n        _c = simple[type(uint256).max];\n        _b = simple[3 + _off];\n        _a = simple[2 + _off];\n    }\n    function test_cleanup() public returns (bool) {\n        uint16 x;\n        assembly { x := 0xffff0001 }\n        cleanup[x] = 3;\n        return cleanup[1] == 3;\n    }\n    function test_str() public returns (bool) {\n        str[\"abc\"] = 3;\n        string memory s = \"abc\";\n        return str[s] == 3;\n    }\n    function test_twodim() public returns (uint a, uint b) {\n        twodim[2][3] = 3;\n        a = twodim[3][2];\n        b = twodim[2][3];\n    }\n}\n// ----\n// test_simple(uint256): 0 -> 3, 4, 5\n// test_simple(uint256): 1 -> 3, 4, 5\n// test_simple(uint256): 2 -> 3, 4, 5\n// test_cleanup() -> true\n// test_str() -> true\n// test_twodim() -> 0, 3\n"
        },
        "dirty_storage_static_array.sol": {
            "content": "contract C {\n    uint8[1] s;\n    function f() public returns (bool correct) {\n        assembly {\n            sstore(s.slot, 257)\n        }\n        uint8 x = s[0];\n        uint r;\n        assembly {\n            r := x\n        }\n        correct = (s[0] == 0x01) && (r == 0x01);\n    }\n}\n// ----\n// f() -> true\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "metadata",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ]
            }
        }
    }
}