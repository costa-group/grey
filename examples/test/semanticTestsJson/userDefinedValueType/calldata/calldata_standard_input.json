{
    "language": "Solidity",
    "sources": {
        "zero_cost_abstraction_comparison_userdefined.sol": {
            "content": "// a test to compare the cost between using user defined value types and elementary type. See the\n// test zero_cost_abstraction_elementary.sol for comparison.\n\npragma abicoder v2;\n\ntype MyInt is int;\ncontract C {\n    int x;\n    function setX(MyInt _x) external {\n        x = MyInt.unwrap(_x);\n    }\n    function getX() view external returns (MyInt) {\n        return MyInt.wrap(x);\n    }\n    function add(MyInt a, MyInt b) pure external returns(MyInt) {\n        return MyInt.wrap(MyInt.unwrap(a) + MyInt.unwrap(b));\n    }\n}\n// ----\n// getX() -> 0\n// gas irOptimized: 23379\n// gas legacy: 23608\n// gas legacyOptimized: 23311\n// setX(int256): 5 ->\n// gas irOptimized: 43510\n// gas legacy: 43724\n// gas legacyOptimized: 43516\n// getX() -> 5\n// gas irOptimized: 23379\n// gas legacy: 23608\n// gas legacyOptimized: 23311\n// add(int256,int256): 200, 99 -> 299\n// gas irOptimized: 21764\n// gas legacy: 22523\n// gas legacyOptimized: 21813\n"
        },
        "zero_cost_abstraction_comparison_elementary.sol": {
            "content": "// a test to compare the cost between using user defined value types and elementary type. See the\n// test zero_cost_abstraction_userdefined.sol for a comparison.\n\npragma abicoder v2;\n\ncontract C {\n    int x;\n    function setX(int _x) external {\n        x = _x;\n    }\n    function getX() view external returns (int) {\n        return x;\n    }\n    function add(int a, int b) view external returns (int) {\n        return a + b;\n    }\n}\n// ----\n// getX() -> 0\n// gas irOptimized: 23379\n// gas legacy: 23479\n// gas legacyOptimized: 23311\n// setX(int256): 5 ->\n// gas irOptimized: 43510\n// gas legacy: 43724\n// gas legacyOptimized: 43516\n// getX() -> 5\n// gas irOptimized: 23379\n// gas legacy: 23479\n// gas legacyOptimized: 23311\n// add(int256,int256): 200, 99 -> 299\n// gas irOptimized: 21764\n// gas legacy: 22394\n// gas legacyOptimized: 21813\n"
        },
        "constant.sol": {
            "content": "type T is int224;\npragma solidity >= 0.0.0;\ncontract C {\n  T constant public s = T.wrap(int224(165521356710917456517261742455526507355687727119203895813322792776));\n  T constant public t = s;\n  int224 constant public u = T.unwrap(t);\n}\n// ----\n// s() -> 165521356710917456517261742455526507355687727119203895813322792776\n// t() -> 165521356710917456517261742455526507355687727119203895813322792776\n// u() -> 165521356710917456517261742455526507355687727119203895813322792776\n"
        },
        "storage_layout_struct.sol": {
            "content": "type MyInt64 is int64;\nstruct HalfSlot {\n    MyInt64 a;\n    MyInt64 b;\n}\n\nstruct RegularHalfSlot {\n    int64 a;\n    int64 b;\n}\n\ntype MyAddress is address;\ntype MyInt96 is int96;\nstruct FullSlot {\n    MyInt96 a;\n    MyAddress b;\n}\nstruct RegularFullSlot {\n    int96 a;\n    address b;\n}\n\ncontract C {\n    HalfSlot public a;\n    RegularHalfSlot public ra;\n\n    HalfSlot public b;\n    RegularHalfSlot public rb;\n\n    HalfSlot public c;\n    RegularHalfSlot public rc;\n\n    FullSlot public d;\n    RegularFullSlot public rd;\n\n    function storage_a() pure external returns(uint slot, uint offset) {\n        assembly {\n            slot := a.slot\n            offset := a.offset\n        }\n    }\n\n    function storage_ra() pure external returns(uint slot, uint offset) {\n        assembly {\n            slot := ra.slot\n            offset := ra.offset\n        }\n    }\n\n    function storage_b() pure external returns(uint slot, uint offset) {\n        assembly {\n            slot := b.slot\n            offset := b.offset\n        }\n    }\n\n    function storage_rb() pure external returns(uint slot, uint offset) {\n        assembly {\n            slot := rb.slot\n            offset := rb.offset\n        }\n    }\n\n   function storage_c() pure external returns(uint slot, uint offset) {\n        assembly {\n            slot := c.slot\n            offset := c.offset\n        }\n    }\n\n   function storage_rc() pure external returns(uint slot, uint offset) {\n        assembly {\n            slot := rc.slot\n            offset := rc.offset\n        }\n    }\n\n   function storage_d() pure external returns(uint slot, uint offset) {\n        assembly {\n            slot := d.slot\n            offset := d.offset\n        }\n    }\n\n   function storage_rd() pure external returns(uint slot, uint offset) {\n        assembly {\n            slot := rd.slot\n            offset := rd.offset\n        }\n    }\n\n\n   function set_a(MyInt64 _a, MyInt64 _b) external {\n       a.a = _a;\n       a.b = _b;\n   }\n\n   function set_ra(int64 _a, int64 _b) external {\n       ra.a = _a;\n       ra.b = _b;\n   }\n\n   function set_b(MyInt64 _a, MyInt64 _b) external {\n       b.a = _a;\n       b.b = _b;\n   }\n\n   function set_rb(int64 _a, int64 _b) external {\n       rb.a = _a;\n       rb.b = _b;\n   }\n\n   function set_c(MyInt64 _a, MyInt64 _b) external {\n       c.a = _a;\n       c.b = _b;\n   }\n\n   function set_rc(int64 _a, int64 _b) external {\n       rc.a = _a;\n       rc.b = _b;\n   }\n\n   function set_d(MyInt96 _a, MyAddress _b) external {\n       d.a = _a;\n       d.b = _b;\n   }\n\n   function set_rd(int96 _a, address _b) external {\n       rd.a = _a;\n       rd.b = _b;\n   }\n\n   function read_slot(uint slot) view external returns (uint value) {\n       assembly {\n           value := sload(slot)\n       }\n   }\n\n   function read_contents_asm() external returns (bytes32 rxa, bytes32 rya, bytes32 rxb, bytes32 ryb) {\n       b.a = MyInt64.wrap(-2);\n       b.b = MyInt64.wrap(-3);\n       HalfSlot memory x = b;\n       MyInt64 y = b.a;\n       MyInt64 z = b.b;\n       assembly {\n           rxa := mload(x)\n           rya := y\n           rxb := mload(add(x, 0x20))\n           ryb := z\n       }\n   }\n}\n// ----\n// storage_a() -> 0, 0\n// set_a(int64,int64): 100, 200 ->\n// read_slot(uint256): 0 -> 0xc80000000000000064\n// storage_ra() -> 1, 0\n// set_ra(int64,int64): 100, 200 ->\n// read_slot(uint256): 1 -> 0xc80000000000000064\n// storage_b() -> 2, 0\n// set_b(int64,int64): 0, 200 ->\n// read_slot(uint256): 2 -> 3689348814741910323200\n// storage_rb() -> 3, 0\n// set_rb(int64,int64): 0, 200 ->\n// read_slot(uint256): 3 -> 3689348814741910323200\n// storage_c() -> 4, 0\n// set_c(int64,int64): 100, 0 ->\n// read_slot(uint256): 4 -> 0x64\n// storage_rc() -> 5, 0\n// set_rc(int64,int64): 100, 0 ->\n// read_slot(uint256): 5 -> 0x64\n// storage_d() -> 6, 0\n// set_d(int96,address): 39614081257132168796771975167, 1461501637330902918203684832716283019655932542975 ->\n// read_slot(uint256): 6 -> -39614081257132168796771975169\n// storage_rd() -> 7, 0\n// set_rd(int96,address): 39614081257132168796771975167, 1461501637330902918203684832716283019655932542975 ->\n// read_slot(uint256): 7 -> -39614081257132168796771975169\n// read_contents_asm() -> 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe, 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe, 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd, 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd\n"
        },
        "erc20.sol": {
            "content": "pragma abicoder v2;\n// A rewrite of the test/libsolidity/semanticTests/various/erc20.sol, but using user defined value\n// types.\n\n// User defined type name. Indicating a type with 18 decimals.\ntype UFixed18 is uint256;\n\nlibrary FixedMath\n{\n    function add(UFixed18 a, UFixed18 b) internal pure returns (UFixed18 c) {\n        return UFixed18.wrap(UFixed18.unwrap(a) + UFixed18.unwrap(b));\n    }\n    function sub(UFixed18 a, UFixed18 b) internal pure returns (UFixed18 c) {\n        return UFixed18.wrap(UFixed18.unwrap(a) - UFixed18.unwrap(b));\n    }\n}\n\ncontract ERC20 {\n    using FixedMath for UFixed18;\n\n    event Transfer(address indexed from, address indexed to, UFixed18 value);\n    event Approval(address indexed owner, address indexed spender, UFixed18 value);\n\n    mapping (address => UFixed18) private _balances;\n    mapping (address => mapping (address => UFixed18)) private _allowances;\n    UFixed18 private _totalSupply;\n\n    constructor() {\n        _mint(msg.sender, UFixed18.wrap(20));\n    }\n\n    function totalSupply() public view returns (UFixed18) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address owner) public view returns (UFixed18) {\n        return _balances[owner];\n    }\n\n    function allowance(address owner, address spender) public view returns (UFixed18) {\n        return _allowances[owner][spender];\n    }\n\n    function transfer(address to, UFixed18 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function approve(address spender, UFixed18 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, UFixed18 value) public returns (bool) {\n        _transfer(from, to, value);\n        // The subtraction here will revert on overflow.\n        _approve(from, msg.sender, _allowances[from][msg.sender].sub(value));\n        return true;\n    }\n\n    function increaseAllowance(address spender, UFixed18 addedValue) public returns (bool) {\n        // The addition here will revert on overflow.\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, UFixed18 subtractedValue) public returns (bool) {\n        // The subtraction here will revert on overflow.\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    function _transfer(address from, address to, UFixed18 value) internal {\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        // The subtraction and addition here will revert on overflow.\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function _mint(address account, UFixed18 value) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        // The additions here will revert on overflow.\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\n\n    function _burn(address account, UFixed18 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        // The subtractions here will revert on overflow.\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    function _approve(address owner, address spender, UFixed18 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _burnFrom(address account, UFixed18 value) internal {\n        _burn(account, value);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(value));\n    }\n}\n// ----\n// constructor()\n// ~ emit Transfer(address,address,uint256): #0x00, #0x1212121212121212121212121212120000000012, 0x14\n// gas irOptimized: 121322\n// gas irOptimized code: 234600\n// gas legacy: 163350\n// gas legacy code: 671400\n// gas legacyOptimized: 127464\n// gas legacyOptimized code: 285400\n// totalSupply() -> 20\n// gas irOptimized: 23415\n// gas legacy: 23653\n// gas legacyOptimized: 23368\n// transfer(address,uint256): 2, 5 -> true\n// ~ emit Transfer(address,address,uint256): #0x1212121212121212121212121212120000000012, #0x02, 0x05\n// gas irOptimized: 48471\n// gas legacy: 49572\n// gas legacyOptimized: 48575\n// decreaseAllowance(address,uint256): 2, 0 -> true\n// ~ emit Approval(address,address,uint256): #0x1212121212121212121212121212120000000012, #0x02, 0x00\n// gas irOptimized: 26275\n// gas legacy: 27204\n// gas legacyOptimized: 26317\n// decreaseAllowance(address,uint256): 2, 1 -> FAILURE, hex\"4e487b71\", 0x11\n// gas irOptimized: 24042\n// gas legacy: 24506\n// gas legacyOptimized: 24077\n// transfer(address,uint256): 2, 14 -> true\n// ~ emit Transfer(address,address,uint256): #0x1212121212121212121212121212120000000012, #0x02, 0x0e\n// gas irOptimized: 28571\n// gas legacy: 29672\n// gas legacyOptimized: 28675\n// transfer(address,uint256): 2, 2 -> FAILURE, hex\"4e487b71\", 0x11\n// gas irOptimized: 24071\n// gas legacy: 24492\n// gas legacyOptimized: 24074\n"
        },
        "conversion.sol": {
            "content": "pragma abicoder v2;\n\ntype MyUInt8 is uint8;\ntype MyInt8 is int8;\ntype MyUInt16 is uint16;\n\ncontract C {\n    function f(uint a) external returns(MyUInt8) {\n        return MyUInt8.wrap(uint8(a));\n    }\n    function g(uint a) external returns(MyInt8) {\n        return MyInt8.wrap(int8(int(a)));\n    }\n    function h(MyUInt8 a) external returns (MyInt8) {\n        return MyInt8.wrap(int8(MyUInt8.unwrap(a)));\n    }\n    function i(MyUInt8 a) external returns(MyUInt16) {\n        return MyUInt16.wrap(MyUInt8.unwrap(a));\n    }\n    function j(MyUInt8 a) external returns (uint) {\n        return MyUInt8.unwrap(a);\n    }\n    function k(MyUInt8 a) external returns (MyUInt16) {\n        return MyUInt16.wrap(MyUInt8.unwrap(a));\n    }\n    function m(MyUInt16 a) external returns (MyUInt8) {\n        return MyUInt8.wrap(uint8(MyUInt16.unwrap(a)));\n    }\n}\n// ----\n// f(uint256): 1 -> 1\n// f(uint256): 2 -> 2\n// f(uint256): 257 -> 1\n// g(uint256): 1 -> 1\n// g(uint256): 2 -> 2\n// g(uint256): 255 -> -1\n// g(uint256): 257 -> 1\n// h(uint8): 1 -> 1\n// h(uint8): 2 -> 2\n// h(uint8): 255 -> -1\n// h(uint8): 257 -> FAILURE\n// i(uint8): 250 -> 250\n// j(uint8): 1 -> 1\n// j(uint8): 2 -> 2\n// j(uint8): 255 -> 0xff\n// j(uint8): 257 -> FAILURE\n// k(uint8): 1 -> 1\n// k(uint8): 2 -> 2\n// k(uint8): 255 -> 0xff\n// k(uint8): 257 -> FAILURE\n// m(uint16): 1 -> 1\n// m(uint16): 2 -> 2\n// m(uint16): 255 -> 0xff\n// m(uint16): 257 -> 1\n"
        },
        "dirty_uint8_read.sol": {
            "content": "type MyInt8 is int8;\ncontract C {\n    MyInt8 public x = MyInt8.wrap(-5);\n\n    /// The most significant bit is flipped to 0\n    function create_dirty_slot() external {\n        uint mask  = 2**255 -1;\n        assembly {\n            let value := sload(x.slot)\n            sstore(x.slot, and(mask, value))\n        }\n    }\n\n    function read_unclean_value() external returns (bytes32 ret) {\n        MyInt8 value = x;\n        assembly {\n            ret := value\n        }\n    }\n}\n// ----\n// x() -> -5\n// create_dirty_slot() ->\n// read_unclean_value() -> 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\n"
        },
        "ownable.sol": {
            "content": "// Implementation of OpenZepplin's\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\n// using user defined value types.\n\ncontract Ownable {\n    type Owner is address;\n    Owner public owner = Owner.wrap(msg.sender);\n    error OnlyOwner();\n    modifier onlyOwner() {\n        if (Owner.unwrap(owner) != msg.sender)\n            revert OnlyOwner();\n\n        _;\n    }\n    event OwnershipTransferred(Owner indexed previousOwner, Owner indexed newOwner);\n    function setOwner(Owner newOwner) onlyOwner external {\n        emit OwnershipTransferred({previousOwner: owner, newOwner: newOwner});\n        owner = newOwner;\n    }\n    function renounceOwnership() onlyOwner external {\n        owner = Owner.wrap(address(0));\n    }\n}\n// ----\n// owner() -> 0x1212121212121212121212121212120000000012\n// setOwner(address): 0x1212121212121212121212121212120000000012 ->\n// ~ emit OwnershipTransferred(address,address): #0x1212121212121212121212121212120000000012, #0x1212121212121212121212121212120000000012\n// renounceOwnership() ->\n// owner() -> 0\n// setOwner(address): 0x1212121212121212121212121212120000000012 -> FAILURE, hex\"5fc483c5\"\n"
        },
        "conversion_abicoderv1.sol": {
            "content": "pragma abicoder v1;\n\ntype MyUInt8 is uint8;\ntype MyInt8 is int8;\ntype MyUInt16 is uint16;\n\ncontract C {\n    function f(uint a) external returns(MyUInt8) {\n        return MyUInt8.wrap(uint8(a));\n    }\n    function g(uint a) external returns(MyInt8) {\n        return MyInt8.wrap(int8(int(a)));\n    }\n    function h(MyUInt8 a) external returns (MyInt8) {\n        return MyInt8.wrap(int8(MyUInt8.unwrap(a)));\n    }\n    function i(MyUInt8 a) external returns(MyUInt16) {\n        return MyUInt16.wrap(MyUInt8.unwrap(a));\n    }\n    function j(MyUInt8 a) external returns (uint) {\n        return MyUInt8.unwrap(a);\n    }\n    function k(MyUInt8 a) external returns (MyUInt16) {\n        return MyUInt16.wrap(MyUInt8.unwrap(a));\n    }\n    function m(MyUInt16 a) external returns (MyUInt8) {\n        return MyUInt8.wrap(uint8(MyUInt16.unwrap(a)));\n    }\n}\n// ====\n// compileViaYul: false\n// ----\n// f(uint256): 1 -> 1\n// f(uint256): 2 -> 2\n// f(uint256): 257 -> 1\n// g(uint256): 1 -> 1\n// g(uint256): 2 -> 2\n// g(uint256): 255 -> -1\n// g(uint256): 257 -> 1\n// h(uint8): 1 -> 1\n// h(uint8): 2 -> 2\n// h(uint8): 255 -> -1\n// h(uint8): 257 -> 1\n// i(uint8): 250 -> 250\n// j(uint8): 1 -> 1\n// j(uint8): 2 -> 2\n// j(uint8): 255 -> 0xff\n// j(uint8): 257 -> 1\n// k(uint8): 1 -> 1\n// k(uint8): 2 -> 2\n// k(uint8): 255 -> 0xff\n// k(uint8): 257 -> 1\n// m(uint16): 1 -> 1\n// m(uint16): 2 -> 2\n// m(uint16): 255 -> 0xff\n// m(uint16): 257 -> 1\n"
        },
        "abicodec.sol": {
            "content": "// A test to see if `abi.encodeWithSelector(..., (CustomType))` works as intended.\ncontract C {\n    type MyInt is int;\n    function f(MyInt x) external returns(MyInt a, MyInt b, MyInt c, MyInt d) {\n        a = MyInt.wrap(-1);\n        b = MyInt.wrap(0);\n        c = MyInt.wrap(1);\n        d = x;\n    }\n    function g() external returns(bool) {\n        (bool success1, bytes memory ret1) =  address(this).call(abi.encodeWithSelector(this.f.selector, MyInt.wrap(5)));\n        assert(success1);\n\n        (MyInt a1, MyInt b1, MyInt c1, MyInt d1) = abi.decode(ret1, (MyInt, MyInt, MyInt, MyInt));\n        assert(MyInt.unwrap(a1) == -1);\n        assert(MyInt.unwrap(b1) == 0);\n        assert(MyInt.unwrap(c1) == 1);\n        assert(MyInt.unwrap(d1) == 5);\n\n        (bool success2, bytes memory ret2) = address(this).call(abi.encodeWithSelector(this.f.selector, int(-5)));\n        assert(success2);\n\n        (int a2, int b2, int c2, int d2) = abi.decode(ret2, (int, int, int, int));\n        assert(a2 == -1);\n        assert(b2 == 0);\n        assert(c2 == 1);\n        assert(d2 == -5);\n\n        return true;\n    }\n}\n// ====\n// EVMVersion: >=byzantium\n// ----\n// g() -> true\n"
        },
        "fixedpoint.sol": {
            "content": "// Represent a 18 decimal, 256 bit wide fixed point type using a user defined value type.\ntype UFixed256x18 is uint256;\n\n/// A minimal library to do fixed point operations on UFixed256x18.\nlibrary FixedMath {\n    uint constant multiplier = 10**18;\n    /// Adds two UFixed256x18 numbers. Reverts on overflow, relying on checked arithmetic on\n    /// uint256.\n    function add(UFixed256x18 a, UFixed256x18 b) internal returns (UFixed256x18) {\n        return UFixed256x18.wrap(UFixed256x18.unwrap(a) + UFixed256x18.unwrap(b));\n    }\n    /// Multiplies UFixed256x18 and uint256. Reverts on overflow, relying on checked arithmetic on\n    /// uint256.\n    function mul(UFixed256x18 a, uint256 b) internal returns (UFixed256x18) {\n        return UFixed256x18.wrap(UFixed256x18.unwrap(a) * b);\n    }\n    /// Take the floor of a UFixed256x18 number.\n    /// @return the largest integer that does not exceed `a`.\n    function floor(UFixed256x18 a) internal returns (uint256) {\n        return UFixed256x18.unwrap(a) / multiplier;\n    }\n    /// Turns a uint256 into a UFixed256x18 of the same value.\n    /// Reverts if the integer is too large.\n    function toUFixed256x18(uint256 a) internal pure returns (UFixed256x18) {\n        return UFixed256x18.wrap(a * multiplier);\n    }\n}\n\ncontract TestFixedMath {\n    function add(UFixed256x18 a, UFixed256x18 b) external returns (UFixed256x18) {\n        return FixedMath.add(a, b);\n    }\n    function mul(UFixed256x18 a, uint256 b) external returns (UFixed256x18) {\n        return FixedMath.mul(a, b);\n    }\n    function floor(UFixed256x18 a) external returns (uint256) {\n        return FixedMath.floor(a);\n    }\n    function toUFixed256x18(uint256 a) external returns (UFixed256x18) {\n        return FixedMath.toUFixed256x18(a);\n    }\n}\n// ----\n// add(uint256,uint256): 0, 0 -> 0\n// add(uint256,uint256): 25, 45 -> 0x46\n// add(uint256,uint256): 115792089237316195423570985008687907853269984665640564039457584007913129639935, 10 -> FAILURE, hex\"4e487b71\", 0x11\n// mul(uint256,uint256): 340282366920938463463374607431768211456, 45671926166590716193865151022383844364247891968 -> FAILURE, hex\"4e487b71\", 0x11\n// mul(uint256,uint256): 340282366920938463463374607431768211456, 20 -> 6805647338418769269267492148635364229120\n// floor(uint256): 11579208923731619542357098500868790785326998665640564039457584007913129639930 -> 11579208923731619542357098500868790785326998665640564039457\n// floor(uint256): 115792089237316195423570985008687907853269984665640564039457584007913129639935 -> 115792089237316195423570985008687907853269984665640564039457\n// toUFixed256x18(uint256): 0 -> 0\n// toUFixed256x18(uint256): 5 -> 5000000000000000000\n// toUFixed256x18(uint256): 115792089237316195423570985008687907853269984665640564039457 -> 115792089237316195423570985008687907853269984665640564039457000000000000000000\n// toUFixed256x18(uint256): 115792089237316195423570985008687907853269984665640564039458 -> FAILURE, hex\"4e487b71\", 0x11\n"
        },
        "storage_layout.sol": {
            "content": "type MyInt8 is int8;\ntype MyAddress is address;\ntype MyInt96 is int96;\n\ncontract C {\n    MyInt8 a;\n    MyInt8 b;\n    MyInt8 c;\n    MyAddress d;\n\n    MyAddress e;\n\n    MyAddress f;\n    MyInt96 g;\n\n    function storage_a() pure external returns(uint slot, uint offset) {\n        assembly {\n            slot := a.slot\n            offset := a.offset\n        }\n    }\n\n    function storage_b() pure external returns(uint slot, uint offset) {\n        assembly {\n            slot := b.slot\n            offset := b.offset\n        }\n    }\n\n    function storage_c() pure external returns(uint slot, uint offset) {\n        assembly {\n            slot := d.slot\n            offset := c.offset\n        }\n    }\n    function storage_d() pure external returns(uint slot, uint offset) {\n        assembly {\n            slot := d.slot\n            offset := d.offset\n        }\n    }\n\n    function storage_e() pure external returns(uint slot, uint offset) {\n        assembly {\n            slot := e.slot\n            offset := e.offset\n        }\n    }\n\n    function storage_f() pure external returns(uint slot, uint offset) {\n        assembly {\n            slot := f.slot\n            offset := f.offset\n        }\n    }\n\n    function storage_g() pure external returns(uint slot, uint offset) {\n        assembly {\n            slot := g.slot\n            offset := g.offset\n        }\n    }\n\n}\n// ----\n// storage_a() -> 0, 0\n// storage_b() -> 0, 1\n// storage_c() -> 0, 2\n// storage_d() -> 0, 3\n// storage_e() -> 1, 0\n// storage_f() -> 2, 0\n// storage_g() -> 2, 0x14\n"
        },
        "mapping_key.sol": {
            "content": "type MyInt is int;\ncontract C {\n    mapping(MyInt => int) public m;\n    function set(MyInt key, int value) external {\n        m[key] = value;\n    }\n    function set_unwrapped(int key, int value) external {\n        m[MyInt.wrap(key)] = value;\n    }\n}\n// ----\n// set(int256,int256): 1, 1 ->\n// m(int256): 1 -> 1\n// set_unwrapped(int256,int256): 1, 2 ->\n// m(int256): 1 -> 2\n// m(int256): 2 -> 0\n"
        },
        "cleanup.sol": {
            "content": "pragma abicoder v2;\ntype MyUInt8 is uint8;\n\n// Note that this wraps from a uint256\nfunction wrap(uint x) pure returns (MyUInt8 y) { assembly { y := x } }\nfunction unwrap(MyUInt8 x) pure returns (uint8 y) { assembly { y := x } }\n\ncontract C {\n    uint8 a;\n    MyUInt8 b;\n    uint8 c;\n    function ret() external returns(MyUInt8) {\n        return wrap(0x1ff);\n    }\n    function f(MyUInt8 x) external returns(MyUInt8) {\n        return x;\n    }\n    function mem() external returns (MyUInt8[] memory) {\n        MyUInt8[] memory x = new MyUInt8[](2);\n        x[0] = wrap(0x1ff);\n        x[1] = wrap(0xff);\n        require(unwrap(x[0]) == unwrap(x[1]));\n        assembly {\n            mstore(add(x, 0x20), 0x1ff)\n        }\n        require(unwrap(x[0]) == unwrap(x[1]));\n        return x;\n    }\n    function stor() external returns (uint8, MyUInt8, uint8) {\n        a = 1;\n        c = 2;\n        b = wrap(0x1ff);\n        return (a, b, c);\n    }\n}\n// ----\n// ret() -> 0xff\n// f(uint8): 0x1ff -> FAILURE\n// f(uint8): 0xff -> 0xff\n// mem() -> 0x20, 2, 0xff, 0xff\n// stor() -> 1, 0xff, 2\n"
        },
        "memory_to_storage.sol": {
            "content": "pragma abicoder v2;\n\ntype Small is uint16;\ntype Left is bytes2;\nstruct S { uint8 a; Small b; Left c; uint8 d; }\n\ncontract C {\n    S public s;\n    Small[] public small;\n    Left[] public l;\n    function f(S memory _s) public {\n        s = _s;\n    }\n    function g(Small[] memory _small) public returns (Small[] memory) {\n        small = _small;\n        return small;\n    }\n    function h(Left[] memory _left) public returns (Left[] memory) {\n        l = _left;\n        return l;\n    }\n}\n// ----\n// s() -> 0, 0, 0x00, 0\n// f((uint8,uint16,bytes2,uint8)): 1, 0xff, \"ab\", 15 ->\n// gas irOptimized: 44473\n// gas legacy: 46213\n// gas legacyOptimized: 44671\n// s() -> 1, 0xff, 0x6162000000000000000000000000000000000000000000000000000000000000, 15\n// g(uint16[]): 0x20, 3, 1, 2, 3 -> 0x20, 3, 1, 2, 3\n// gas irOptimized: 69555\n// gas legacy: 76557\n// gas legacyOptimized: 74834\n// small(uint256): 0 -> 1\n// small(uint256): 1 -> 2\n// h(bytes2[]): 0x20, 3, \"ab\", \"cd\", \"ef\" -> 0x20, 3, \"ab\", \"cd\", \"ef\"\n// gas irOptimized: 69617\n// gas legacy: 76238\n// gas legacyOptimized: 74921\n// l(uint256): 0 -> 0x6162000000000000000000000000000000000000000000000000000000000000\n// l(uint256): 1 -> 0x6364000000000000000000000000000000000000000000000000000000000000\n"
        },
        "dirty_slot.sol": {
            "content": "type MyUInt16 is uint16;\ntype MyBytes2 is bytes2;\ncontract C {\n    MyUInt16 public a = MyUInt16.wrap(13);\n    MyBytes2 public b = MyBytes2.wrap(bytes2(uint16(1025)));\n    bytes2 public x;\n    function write_a() external {\n        uint max = 0xf00e0bbc0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0e0c0ba098076054032001;\n        assembly {\n            sstore(a.slot, max)\n        }\n    }\n    function write_b() external {\n        uint max = 0xf00e0bbc0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0e0c0ba098076054032001;\n        assembly {\n            sstore(b.slot, max)\n        }\n    }\n    function get_b(uint index) public returns (bytes1) {\n        return MyBytes2.unwrap(b)[index];\n    }\n}\n// ----\n// a() -> 13\n// b() -> 0x0401000000000000000000000000000000000000000000000000000000000000\n// get_b(uint256): 0 -> 0x0400000000000000000000000000000000000000000000000000000000000000\n// get_b(uint256): 1 -> 0x0100000000000000000000000000000000000000000000000000000000000000\n// get_b(uint256): 2 -> FAILURE, hex\"4e487b71\", 0x32\n// write_a() ->\n// a() -> 0x2001\n// write_b() ->\n// b() -> 0x5403000000000000000000000000000000000000000000000000000000000000\n// get_b(uint256): 0 -> 0x5400000000000000000000000000000000000000000000000000000000000000\n// get_b(uint256): 1 -> 0x0300000000000000000000000000000000000000000000000000000000000000\n// get_b(uint256): 2 -> FAILURE, hex\"4e487b71\", 0x32\n"
        },
        "calldata_to_storage.sol": {
            "content": "pragma abicoder v2;\n\ntype Small is uint16;\ntype Left is bytes2;\nstruct S { uint8 a; Small b; Left c; uint8 d; }\n\ncontract C {\n    S public s;\n    Small[] public small;\n    Left[] public l;\n    function f(S calldata _s) external {\n        s = _s;\n    }\n    function g(Small[] calldata _small) external returns (Small[] memory) {\n        small = _small;\n        return small;\n    }\n    function h(Left[] calldata _left) external returns (Left[] memory) {\n        l = _left;\n        return l;\n    }\n}\n// ----\n// s() -> 0, 0, 0x00, 0\n// f((uint8,uint16,bytes2,uint8)): 1, 0xff, \"ab\", 15 ->\n// gas irOptimized: 44405\n// gas legacy: 47200\n// gas legacyOptimized: 44923\n// s() -> 1, 0xff, 0x6162000000000000000000000000000000000000000000000000000000000000, 15\n// g(uint16[]): 0x20, 3, 1, 2, 3 -> 0x20, 3, 1, 2, 3\n// gas irOptimized: 69097\n// gas legacy: 75466\n// gas legacyOptimized: 74255\n// small(uint256): 0 -> 1\n// small(uint256): 1 -> 2\n// h(bytes2[]): 0x20, 3, \"ab\", \"cd\", \"ef\" -> 0x20, 3, \"ab\", \"cd\", \"ef\"\n// gas irOptimized: 69174\n// gas legacy: 75156\n// gas legacyOptimized: 74342\n// l(uint256): 0 -> 0x6162000000000000000000000000000000000000000000000000000000000000\n// l(uint256): 1 -> 0x6364000000000000000000000000000000000000000000000000000000000000\n"
        },
        "calldata.sol": {
            "content": "pragma abicoder v2;\ntype MyAddress is address;\n\ncontract C {\n    MyAddress[] public addresses;\n    function f(MyAddress[] calldata _addresses) external {\n        for (uint i = 0; i < _addresses.length; i++) {\n            MyAddress.unwrap(_addresses[i]).call(\"\");\n        }\n        addresses = _addresses;\n    }\n    function g(MyAddress[] memory _addresses) external {\n        for (uint i = 0; i < _addresses.length; i++) {\n            MyAddress.unwrap(_addresses[i]).call(\"\");\n        }\n        addresses = _addresses;\n    }\n    function test_f() external returns (bool) {\n        clean();\n        MyAddress[] memory test = new MyAddress[](3);\n        test[0] = MyAddress.wrap(address(21));\n        test[1] = MyAddress.wrap(address(22));\n        test[2] = MyAddress.wrap(address(23));\n        this.f(test);\n        test_equality(test);\n        return true;\n    }\n    function test_g() external returns (bool) {\n        clean();\n        MyAddress[] memory test = new MyAddress[](5);\n        test[0] = MyAddress.wrap(address(24));\n        test[1] = MyAddress.wrap(address(25));\n        test[2] = MyAddress.wrap(address(26));\n        test[3] = MyAddress.wrap(address(27));\n        test[4] = MyAddress.wrap(address(28));\n        this.g(test);\n        test_equality(test);\n        return true;\n    }\n    function clean() internal {\n        delete addresses;\n    }\n    function test_equality(MyAddress[] memory _addresses) internal view {\n        require (_addresses.length == addresses.length);\n        for (uint i = 0; i < _addresses.length; i++) {\n            require(MyAddress.unwrap(_addresses[i]) == MyAddress.unwrap(addresses[i]));\n        }\n    }\n}\n// ----\n// test_f() -> true\n// gas irOptimized: 122201\n// gas legacy: 125333\n// gas legacyOptimized: 122693\n// test_g() -> true\n// gas irOptimized: 106408\n// gas legacy: 111133\n// gas legacyOptimized: 106925\n// addresses(uint256): 0 -> 0x18\n// addresses(uint256): 1 -> 0x19\n// addresses(uint256): 3 -> 0x1b\n// addresses(uint256): 4 -> 0x1c\n// addresses(uint256): 5 -> FAILURE\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "metadata",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ]
            }
        }
    }
}