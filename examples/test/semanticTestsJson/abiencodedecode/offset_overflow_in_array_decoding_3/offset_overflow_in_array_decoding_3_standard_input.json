{
    "language": "Solidity",
    "sources": {
        "offset_overflow_in_array_decoding_2.sol": {
            "content": "pragma abicoder v2;\ncontract Test {\n\tstruct MemoryTuple {\n\t\tuint field1;\n\t\tuint field2;\n\t}\n\tfunction withinArray() public pure returns (uint) {\n\t\tuint[] memory before = new uint[](1);\n\t\tbytes memory corrupt = abi.encode(uint(32),\n\t\t\t\t\t\t\t\t\t\t  uint(2));\n\t\tMemoryTuple memory afterCorrupt;\n\t\tbefore[0] = 123456;\n\t\t/*\n\t\t  As above, but in this case we are adding to:\n\t\t  0x80 + 64 (before) + 32 (length of corrupt) + 32 (offset) + 32 (field pointer)\n\t\t  giving MAX_UINT - 96\n\t\t*/\n\t\tafterCorrupt.field1 = uint(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60);\n\t\tafterCorrupt.field2 = uint(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60);\n\t\tuint[][] memory decoded = abi.decode(corrupt, (uint[][]));\n\t\t/*\n\t\t  Will return 123456 * 2, AKA before has been copied twice\n\t\t */\n\t\treturn decoded[0][0] + decoded[1][0];\n\t}\n}\n// ----\n// withinArray() -> FAILURE\n"
        },
        "abi_encode_with_signaturev2.sol": {
            "content": "pragma abicoder v2;\ncontract C {\n    function f0() public pure returns (bytes memory) {\n        return abi.encodeWithSignature(\"f(uint256)\");\n    }\n    function f1() public pure returns (bytes memory) {\n        string memory x = \"f(uint256)\";\n        return abi.encodeWithSignature(x, \"abc\");\n    }\n    string xstor;\n    function f1s() public returns (bytes memory) {\n        xstor = \"f(uint256)\";\n        return abi.encodeWithSignature(xstor, \"abc\");\n    }\n    function f2() public pure returns (bytes memory r, uint[] memory ar) {\n        string memory x = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\";\n        uint[] memory y = new uint[](4);\n        y[0] = type(uint).max;\n        y[1] = type(uint).max - 1;\n        y[2] = type(uint).max - 2;\n        y[3] = type(uint).max - 3;\n        r = abi.encodeWithSignature(x, y);\n        // The hash uses temporary memory. This allocation re-uses the memory\n        // and should initialize it properly.\n        ar = new uint[](2);\n    }\n    struct S { uint a; string b; uint16 c; }\n    function f4() public pure returns (bytes memory) {\n        S memory s;\n        s.a = 0x1234567;\n        s.b = \"Lorem ipsum dolor sit ethereum........\";\n        s.c = 0x1234;\n        return abi.encodeWithSignature(s.b, type(uint).max, s, uint(3));\n    }\n}\n// ----\n// f0() -> 0x20, 4, -34435155370463444793260793355178157075203752403645521721995013737368954863616\n// f1() -> 0x20, 0x64, -34435155370463444793260793355178157075203752403645521721995013737368954863616, 862718293348820473429344482784628181556388621521298319395315527974912, 91135606241822717681769169345594720818313984248279388438121731325952, 0\n// f1s() -> 0x20, 0x64, -34435155370463444793260793355178157075203752403645521721995013737368954863616, 862718293348820473429344482784628181556388621521298319395315527974912, 91135606241822717681769169345594720818313984248279388438121731325952, 0\n// f2() -> 0x40, 0x0140, 0xc4, -10047825972976160827854069633043429618646681939320956771263895477211642200064, 862718293348820473429344482784628181556388621521298319395315527974912, 0x04ffffffffffffffffffffffffffffffffffffffffffffffffffffffff, -1, -26959946667150639794667015087019630673637144422540572481103610249217, -53919893334301279589334030174039261347274288845081144962207220498433, -107839786668602559178668060348078522694548577690162289924414440996864, 2, 0, 0\n// f4() -> 0x20, 292, 0x7c793002ffffffffffffffffffffffffffffffffffffffffffffffffffffffff, -26959946667150639794667015087019630673637144422540572481103610249216, 2588154880046461420288033448353884544669165864563894958185946583924736, 80879840001451919384001045261058892020911433267621717443310830747648, 514631493222945105325971421573240365883976325135760395164659172419450175488, 2588154880046461420288033448353884544669165864563894958185946583924736, 125633351468921981443148290305511478939149093009039067761942823761346560, 0x264c6f72656d20697073756d20646f6c6f722073697420657468657265, 53113508339655873314659021564971517366334151400493876485713881232784043802624, 0\n"
        },
        "offset_overflow_in_array_decoding_3.sol": {
            "content": "pragma abicoder v2;\ncontract Test {\n\tstruct MemoryUint {\n\t\tuint field;\n\t}\n\tfunction test() public pure returns (uint) {\n\t\tuint[] memory before = new uint[](1); // at offset 0x80\n\t\tbytes memory corrupt = abi.encode(\n            uint(32),\n            uint(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80),\n            uint(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80)\n        );\n\t\tMemoryUint memory afterCorrupt;\n\t\tafterCorrupt.field = uint(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80);\n\t\tbefore[0] = 123456;\n\t\tuint[][2] memory decoded = abi.decode(corrupt, (uint[][2]));\n\t\treturn decoded[1][0];\n\t}\n}\n// ----\n// test() -> FAILURE\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "metadata",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ]
            }
        }
    }
}