{
    "language": "Solidity",
    "sources": {
        "memory_struct_named_constructor.sol": {
            "content": "pragma abicoder               v2;\n\ncontract C {\n    struct S {\n        uint256 a;\n        bool x;\n    }\n\n    function s() public returns(S memory)\n    {\n        return S({x: true, a: 8});\n    }\n}\n// ----\n// s() -> 8, true\n"
        },
        "copy_from_mapping.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n    struct S {\n        bytes b;\n        uint16[] a;\n        uint16 u;\n    }\n\n    constructor() {\n        uint16[] memory a = new uint16[](2);\n        a[0] = 13;\n        a[1] = 14;\n\n        m[7] = S({b: \"foo\", a: a, u: 7});\n    }\n\n    mapping (uint => S) m;\n    S s;\n\n    function to_state() public returns (S memory) {\n\ts = m[7];\n        return s;\n    }\n\n    function to_storage() public returns (S memory) {\n        S storage sLocal = s;\n\tsLocal = m[7];\n        return sLocal;\n    }\n\n    function to_memory() public returns (S memory) {\n\treturn m[7];\n    }\n\n}\n// ----\n// to_state() -> 0x20, 0x60, 0xa0, 7, 3, 0x666F6F0000000000000000000000000000000000000000000000000000000000, 2, 13, 14\n// gas irOptimized: 121282\n// gas legacy: 122977\n// gas legacyOptimized: 121652\n// to_storage() -> 0x20, 0x60, 0xa0, 7, 3, 0x666F6F0000000000000000000000000000000000000000000000000000000000, 2, 13, 14\n// to_memory() -> 0x20, 0x60, 0xa0, 7, 3, 0x666F6F0000000000000000000000000000000000000000000000000000000000, 2, 13, 14\n"
        },
        "struct_delete_storage_nested_small.sol": {
            "content": "contract C {\n    struct S {\n        uint32 a;\n        S[] x;\n    }\n    S s;\n    function f() public returns (uint256 r1, uint256 r2, uint256 r3) {\n        assembly {\n            // 2 ** 150 - 1\n            sstore(s.slot, 1427247692705959881058285969449495136382746623)\n        }\n        s.a = 1;\n        s.x.push(); s.x.push();\n        S storage ptr1 = s.x[0];\n        S storage ptr2 = s.x[1];\n        assembly {\n            // 2 ** 150 - 1\n            sstore(ptr1.slot, 1427247692705959881058285969449495136382746623)\n            sstore(ptr2.slot, 1427247692705959881058285969449495136382746623)\n        }\n        s.x[0].a = 2; s.x[1].a = 3;\n        delete s;\n        assert(s.a == 0);\n        assert(s.x.length == 0);\n        assembly {\n            r1 := sload(s.slot)\n            r2 := sload(ptr1.slot)\n            r3 := sload(ptr2.slot)\n        }\n    }\n}\n// ====\n// compileViaYul: true\n// ----\n// f() -> 0, 0, 0\n// gas irOptimized: 117101\n"
        },
        "copy_from_storage.sol": {
            "content": "pragma abicoder v2;\n// Example from https://github.com/ethereum/solidity/issues/12558\nstruct S {\n    uint x;\n}\n\ncontract C {\n    S sStorage;\n    constructor() {\n        sStorage.x = 13;\n    }\n\n    function f() external returns (S[] memory) {\n        S[] memory sMemory = new S[](1);\n\n        sMemory[0] = sStorage;\n\n        return sMemory;\n    }\n}\n// ----\n// f() -> 0x20, 1, 13\n"
        },
        "copy_substructures_from_mapping.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n    struct S {\n        bytes b;\n        uint16[] a;\n        uint16 u;\n    }\n\n    constructor() {\n        uint16[] memory a = new uint16[](2);\n        a[0] = 13;\n        a[1] = 14;\n\n        m[7] = S({b: \"foo\", a: a, u: 7});\n    }\n\n    mapping (uint => S) m;\n    S s;\n\n    function to_state() public returns (S memory) {\n\ts.b = m[7].b;\n\ts.a = m[7].a;\n\ts.u = m[7].u;\n        return s;\n    }\n\n    function to_storage() public returns (S memory) {\n        S storage sLocal = s;\n\tsLocal.b = m[7].b;\n\tsLocal.a = m[7].a;\n\tsLocal.u = m[7].u;\n        return sLocal;\n    }\n\n    function to_memory() public returns (S memory) {\n        S memory sLocal;\n        sLocal.b = m[7].b;\n        sLocal.a = m[7].a;\n        sLocal.u = m[7].u;\n\treturn sLocal;\n    }\n\n}\n// ----\n// to_state() -> 0x20, 0x60, 0xa0, 7, 3, 0x666F6F0000000000000000000000000000000000000000000000000000000000, 2, 13, 14\n// gas irOptimized: 121454\n// gas legacy: 123114\n// gas legacyOptimized: 121659\n// to_storage() -> 0x20, 0x60, 0xa0, 7, 3, 0x666F6F0000000000000000000000000000000000000000000000000000000000, 2, 13, 14\n// to_memory() -> 0x20, 0x60, 0xa0, 7, 3, 0x666F6F0000000000000000000000000000000000000000000000000000000000, 2, 13, 14\n"
        },
        "struct_reference.sol": {
            "content": "contract test {\n    struct s2 {\n        uint32 z;\n        mapping(uint8 => s2) recursive;\n    }\n    s2 data;\n    function check() public returns (bool ok) {\n        return data.z == 2 &&\n            data.recursive[0].z == 3 &&\n            data.recursive[0].recursive[1].z == 0 &&\n            data.recursive[0].recursive[0].z == 1;\n    }\n    function set() public {\n        data.z = 2;\n        mapping(uint8 => s2) storage map = data.recursive;\n        s2 storage inner = map[0];\n        inner.z = 3;\n        inner.recursive[0].z = inner.recursive[1].z + 1;\n    }\n}\n// ----\n// check() -> false\n// set() ->\n// check() -> true\n"
        },
        "struct_named_constructor.sol": {
            "content": "contract C {\n    struct S {\n        uint256 a;\n        bool x;\n    }\n    S public s;\n\n    constructor() {\n        s = S({x: true, a: 1});\n    }\n}\n// ----\n// s() -> 1, true\n"
        },
        "using_for_function_on_struct.sol": {
            "content": "library D { struct s { uint a; } function mul(s storage self, uint x) public returns (uint) { return self.a *= x; } }\ncontract C {\n    using D for D.s;\n    D.s public x;\n    function f(uint a) public returns (uint) {\n        x.a = 3;\n        return x.mul(a);\n    }\n}\n// ----\n// library: D\n// f(uint256): 7 -> 0x15\n// x() -> 0x15\n"
        },
        "structs.sol": {
            "content": "contract test {\n    struct s1 {\n        uint8 x;\n        bool y;\n    }\n    struct s2 {\n        uint32 z;\n        s1 s1data;\n        mapping(uint8 => s2) recursive;\n    }\n    s2 data;\n    function check() public returns (bool ok) {\n        return data.z == 1 && data.s1data.x == 2 &&\n            data.s1data.y == true &&\n            data.recursive[3].recursive[4].z == 5 &&\n            data.recursive[4].recursive[3].z == 6 &&\n            data.recursive[0].s1data.y == false &&\n            data.recursive[4].z == 9;\n    }\n    function set() public {\n        data.z = 1;\n        data.s1data.x = 2;\n        data.s1data.y = true;\n        data.recursive[3].recursive[4].z = 5;\n        data.recursive[4].recursive[3].z = 6;\n        data.recursive[0].s1data.y = false;\n        data.recursive[4].z = 9;\n    }\n}\n// ----\n// check() -> false\n// set() ->\n// gas irOptimized: 134073\n// gas legacy: 135243\n// gas legacyOptimized: 134062\n// check() -> true\n"
        },
        "global.sol": {
            "content": "pragma abicoder               v2;\n\nstruct S { uint256 a; uint256 b; }\ncontract C {\n    function f(S calldata s) external pure returns (uint256, uint256) {\n        return (s.a, s.b);\n    }\n}\n// ----\n// f((uint256,uint256)): 42, 23 -> 42, 23\n"
        },
        "struct_memory_to_storage.sol": {
            "content": "pragma abicoder               v2;\n\ncontract C {\n    struct S {\n        uint32 a;\n        uint128 b;\n        uint256 c;\n    }\n\n    struct X {\n        uint256 a;\n        S s;\n    }\n\n    uint[79] r;\n    X x;\n\n    function f() external returns (uint32, uint128, uint256) {\n        X memory m = X(12, S(42, 23, 34));\n        x = m;\n        return (x.s.a, x.s.b, x.s.c);\n    }\n}\n// ----\n// f() -> 42, 23, 34\n"
        },
        "simple_struct_allocation.sol": {
            "content": "contract C {\n  struct S {\n    uint a;\n  }\n\n  function f() external returns (uint) {\n    S memory s = S(1);\n    return s.a;\n  }\n}\n// ----\n// f() -> 1\n"
        },
        "event.sol": {
            "content": "pragma abicoder v2;\n\nstruct Item {uint x;}\nlibrary L {\n    event Ev(Item);\n    function o() public { emit L.Ev(Item(1)); }\n}\ncontract C {\n    function f() public {\n        L.o();\n    }\n}\n// ----\n// library: L\n// f() ->\n// ~ emit Ev((uint256)): 0x01\n"
        },
        "struct_containing_bytes_copy_and_delete.sol": {
            "content": "contract c {\n    struct Struct { uint a; bytes data; uint b; }\n    Struct data1;\n    Struct data2;\n    function set(uint _a, bytes calldata _data, uint _b) external returns (bool) {\n        data1.a = _a;\n        data1.b = _b;\n        data1.data = _data;\n        return true;\n    }\n    function copy() public returns (bool) {\n        data1 = data2;\n        return true;\n    }\n    function del() public returns (bool) {\n        delete data1;\n        return true;\n    }\n    function test(uint256 i) public returns (bytes1) {\n        return data1.data[i];\n    }\n}\n// ----\n// storageEmpty -> 1\n// set(uint256,bytes,uint256): 12, 0x60, 13, 33, \"12345678901234567890123456789012\", \"3\" -> true\n// gas irOptimized: 133557\n// gas legacy: 134624\n// gas legacyOptimized: 133856\n// test(uint256): 32 -> \"3\"\n// storageEmpty -> 0\n// copy() -> true\n// storageEmpty -> 1\n// set(uint256,bytes,uint256): 12, 0x60, 13, 33, \"12345678901234567890123456789012\", \"3\" -> true\n// gas irOptimized: 133557\n// gas legacy: 134624\n// gas legacyOptimized: 133856\n// storageEmpty -> 0\n// del() -> true\n// storageEmpty -> 1\n"
        },
        "memory_structs_as_function_args.sol": {
            "content": "contract Test {\n    struct S {\n        uint8 x;\n        uint16 y;\n        uint256 z;\n    }\n\n    function test() public returns (uint256 x, uint256 y, uint256 z) {\n        S memory data = combine(1, 2, 3);\n        x = extract(data, 0);\n        y = extract(data, 1);\n        z = extract(data, 2);\n    }\n\n    function extract(S memory s, uint256 which) internal returns (uint256 x) {\n        if (which == 0) return s.x;\n        else if (which == 1) return s.y;\n        else return s.z;\n    }\n\n    function combine(uint8 x, uint16 y, uint256 z)\n        internal\n        returns (S memory s)\n    {\n        s.x = x;\n        s.y = y;\n        s.z = z;\n    }\n}\n// ----\n// test() -> 1, 2, 3\n"
        },
        "struct_referencing.sol": {
            "content": "pragma abicoder v2;\ninterface I {\n    struct S { uint a; }\n}\n\nlibrary L {\n    struct S { uint b; uint a; }\n    function f() public pure returns (S memory) {\n        S memory s;\n        s.a = 3;\n        return s;\n    }\n    function g() public pure returns (I.S memory) {\n        I.S memory s;\n        s.a = 4;\n        return s;\n    }\n    // argument-dependent lookup tests\n    function a(I.S memory) public pure returns (uint) { return 1; }\n    function a(S memory) public pure returns (uint) { return 2; }\n}\n\ncontract C is I {\n    function f() public pure returns (S memory) {\n        S memory s;\n        s.a = 1;\n        return s;\n    }\n    function g() public pure returns (I.S memory) {\n        I.S memory s;\n        s.a = 2;\n        return s;\n    }\n    function h() public pure returns (L.S memory) {\n        L.S memory s;\n        s.a = 5;\n        return s;\n    }\n    function x() public pure returns (L.S memory) {\n        return L.f();\n    }\n    function y() public pure returns (I.S memory) {\n        return L.g();\n    }\n    function a1() public pure returns (uint) { S memory s; return L.a(s); }\n    function a2() public pure returns (uint) { L.S memory s; return L.a(s); }\n}\n// ----\n// library: L\n// f() -> 1\n// g() -> 2\n// f() -> 1\n// g() -> 2\n// h() -> 0, 5\n// x() -> 0, 3\n// y() -> 4\n// a1() -> 1\n// a2() -> 2\n"
        },
        "struct_delete_member.sol": {
            "content": "contract test {\n    struct testStruct {\n        uint256 m_value;\n    }\n    testStruct data1;\n\n    constructor() {\n        data1.m_value = 2;\n    }\n\n    function deleteMember() public returns (uint256 ret_value) {\n        testStruct storage x = data1; //should not copy the data. data1.m_value == 2 but x.m_value = 0\n        x.m_value = 4;\n        delete x.m_value;\n        ret_value = data1.m_value;\n    }\n}\n// ----\n// deleteMember() -> 0\n"
        },
        "recursive_struct_2.sol": {
            "content": "contract C {\n    struct S {\n        uint16 v;\n        S[] x;\n    }\n    uint8[77] padding;\n    S s;\n    constructor() {\n         s.v = 21;\n         s.x.push(); s.x.push(); s.x.push();\n         s.x[0].v = 101; s.x[1].v = 102; s.x[2].v = 103;\n    }\n    function f() public returns (uint256 a, uint256 b, uint256 c, uint256 d) {\n       S storage sptr1 = s.x[0];\n       S storage sptr2 = s.x[1];\n       S storage sptr3 = s.x[2];\n       uint256 slot1; uint256 slot2; uint256 slot3;\n       assembly { slot1 := sptr1.slot slot2 := sptr2.slot slot3 := sptr3.slot }\n       delete s;\n       assembly { a := sload(s.slot) b := sload(slot1) c := sload(slot2) d := sload(slot3) }\n    }\n}\n// ----\n// f() -> 0, 0, 0, 0\n"
        },
        "struct_delete_storage.sol": {
            "content": "contract C {\n    struct S {\n        uint256 x;\n        uint128 y;\n        uint32 z;\n    }\n    uint8 b = 23;\n    S s;\n    uint8 a = 17;\n    function f() public {\n        s.x = 42; s.y = 42; s.y = 42;\n        delete s;\n        assert(s.x == 0);\n        assert(s.y == 0);\n        assert(s.z == 0);\n        assert(b == 23);\n        assert(a == 17);\n    }\n}\n// ----\n// f() ->\n"
        },
        "memory_structs_read_write.sol": {
            "content": "contract Test {\n    struct S {\n        uint8 x;\n        uint16 y;\n        uint256 z;\n        uint8[2] a;\n    }\n    S[5] data;\n\n    function testInit()\n        public\n        returns (uint8 x, uint16 y, uint256 z, uint8 a, bool flag)\n    {\n        S[2] memory d;\n        x = d[0].x;\n        y = d[0].y;\n        z = d[0].z;\n        a = d[0].a[1];\n        flag = true;\n    }\n\n    function testCopyRead()\n        public\n        returns (uint8 x, uint16 y, uint256 z, uint8 a)\n    {\n        data[2].x = 1;\n        data[2].y = 2;\n        data[2].z = 3;\n        data[2].a[1] = 4;\n        S memory s = data[2];\n        x = s.x;\n        y = s.y;\n        z = s.z;\n        a = s.a[1];\n    }\n\n    function testAssign()\n        public\n        returns (uint8 x, uint16 y, uint256 z, uint8 a)\n    {\n        S memory s;\n        s.x = 1;\n        s.y = 2;\n        s.z = 3;\n        s.a[1] = 4;\n        x = s.x;\n        y = s.y;\n        z = s.z;\n        a = s.a[1];\n    }\n}\n// ----\n// testInit() -> 0, 0, 0, 0, true\n// testCopyRead() -> 1, 2, 3, 4\n// testAssign() -> 1, 2, 3, 4\n"
        },
        "struct_copy_via_local.sol": {
            "content": "contract c {\n    struct Struct {\n        uint256 a;\n        uint256 b;\n    }\n    uint[75] r;\n    Struct data1;\n    Struct data2;\n\n    function test() public returns (bool) {\n        data1.a = 1;\n        data1.b = 2;\n        Struct memory x = data1;\n        data2 = x;\n        return data2.a == data1.a && data2.b == data1.b;\n    }\n}\n// ----\n// test() -> true\n// gas irOptimized: 109921\n// gas legacy: 110615\n// gas legacyOptimized: 109705\n"
        },
        "msg_data_to_struct_member_copy.sol": {
            "content": "pragma abicoder v2;\n\nstruct St0 {\n    bytes el0;\n}\ncontract C {\n    function f() external returns (St0 memory) {\n        St0 memory x;\n        x.el0 = msg.data;\n        return x;\n    }\n\n    function g() external returns (St0 memory) {\n        bytes memory temp = msg.data;\n        St0 memory x;\n        x.el0 = temp;\n        return x;\n    }\n\n    function hashes() external returns (bytes4, bytes4) {\n        return (this.f.selector, this.g.selector);\n    }\n\n    function large(uint256, uint256, uint256, uint256) external returns (St0 memory) {\n        St0 memory x;\n        x.el0 = msg.data;\n        return x;\n    }\n\n    function another_large(uint256, uint256, uint256, uint256) external returns (St0 memory) {\n        bytes memory temp = msg.data;\n        St0 memory x;\n        x.el0 = temp;\n        return x;\n    }\n\n}\n// ----\n// f() -> 0x20, 0x20, 4, 0x26121ff000000000000000000000000000000000000000000000000000000000\n// g() -> 0x20, 0x20, 4, 0xe2179b8e00000000000000000000000000000000000000000000000000000000\n// hashes() -> 0x26121ff000000000000000000000000000000000000000000000000000000000, 0xe2179b8e00000000000000000000000000000000000000000000000000000000\n// large(uint256,uint256,uint256,uint256): 1, 2, 3, 4 -> 0x20, 0x20, 0x84, 0xe02492f800000000000000000000000000000000000000000000000000000000, 0x100000000000000000000000000000000000000000000000000000000, 0x200000000000000000000000000000000000000000000000000000000, 0x300000000000000000000000000000000000000000000000000000000, 0x400000000000000000000000000000000000000000000000000000000\n// another_large(uint256,uint256,uint256,uint256): 1, 2, 3, 4 -> 0x20, 0x20, 0x84, 0x2a46f85a00000000000000000000000000000000000000000000000000000000, 0x100000000000000000000000000000000000000000000000000000000, 0x200000000000000000000000000000000000000000000000000000000, 0x300000000000000000000000000000000000000000000000000000000, 0x400000000000000000000000000000000000000000000000000000000\n"
        },
        "struct_storage_push_zero_value.sol": {
            "content": "contract C {\n    struct S {\n        uint256 x;\n        uint128 y;\n        uint32 z;\n        uint128[3] a1;\n        uint128[] a2;\n    }\n    uint8 b = 23;\n    S[] s;\n    uint8 a = 17;\n    function f() public {\n        s.push();\n        assert(s[0].x == 0);\n        assert(s[0].y == 0);\n        assert(s[0].z == 0);\n        assert(s[0].a1[0] == 0);\n        assert(s[0].a1[1] == 0);\n        assert(s[0].a1[2] == 0);\n        assert(s[0].a2.length == 0);\n        assert(b == 23);\n        assert(a == 17);\n    }\n}\n// ----\n// f() ->\n"
        },
        "function_type_copy.sol": {
            "content": "pragma abicoder v2;\nstruct S {\n    function () external[] functions;\n}\n\ncontract C {\n    function f(function () external[] calldata functions) external returns (S memory) {\n        S memory s;\n        s.functions = functions;\n        return s;\n    }\n}\n\ncontract Test {\n    C immutable c = new C();\n\n    function test() external returns (bool) {\n        function() external[] memory functions = new function() external[](3);\n\n        functions[0] = this.random1;\n        functions[1] = this.random2;\n        functions[2] = this.random3;\n\n        S memory ret = c.f(functions);\n\n        assert(ret.functions.length == 3);\n        assert(ret.functions[0] == this.random1);\n        assert(ret.functions[1] == this.random2);\n        assert(ret.functions[2] == this.random3);\n\n        return true;\n    }\n    function random1() external {\n    }\n    function random2() external {\n    }\n    function random3() external {\n    }\n}\n// ====\n// EVMVersion: >homestead\n// ----\n// test() -> true\n"
        },
        "memory_structs_nested_load.sol": {
            "content": "contract Test {\n    struct S {\n        uint8 x;\n        uint16 y;\n        uint256 z;\n    }\n    struct X {\n        uint8 x;\n        S s;\n        uint8[2] a;\n    }\n    X m_x;\n\n    function load()\n        public\n        returns (\n            uint256 a,\n            uint256 x,\n            uint256 y,\n            uint256 z,\n            uint256 a1,\n            uint256 a2\n        )\n    {\n        m_x.x = 1;\n        m_x.s.x = 2;\n        m_x.s.y = 3;\n        m_x.s.z = 4;\n        m_x.a[0] = 5;\n        m_x.a[1] = 6;\n        X memory d = m_x;\n        a = d.x;\n        x = d.s.x;\n        y = d.s.y;\n        z = d.s.z;\n        a1 = d.a[0];\n        a2 = d.a[1];\n    }\n\n    function store()\n        public\n        returns (\n            uint256 a,\n            uint256 x,\n            uint256 y,\n            uint256 z,\n            uint256 a1,\n            uint256 a2\n        )\n    {\n        X memory d;\n        d.x = 1;\n        d.s.x = 2;\n        d.s.y = 3;\n        d.s.z = 4;\n        d.a[0] = 5;\n        d.a[1] = 6;\n        m_x = d;\n        a = m_x.x;\n        x = m_x.s.x;\n        y = m_x.s.y;\n        z = m_x.s.z;\n        a1 = m_x.a[0];\n        a2 = m_x.a[1];\n    }\n}\n// ----\n// load() -> 0x01, 0x02, 0x03, 0x04, 0x05, 0x06\n// gas irOptimized: 110772\n// gas legacy: 112959\n// gas legacyOptimized: 110876\n// store() -> 0x01, 0x02, 0x03, 0x04, 0x05, 0x06\n"
        },
        "struct_delete_storage_with_array.sol": {
            "content": "pragma abicoder               v2;\n\ncontract C {\n    struct S {\n        uint128 a;\n        uint256[] x;\n        uint240 b;\n    }\n    uint8 b = 23;\n    S s;\n    uint8 a = 17;\n    function f() public {\n        delete s;\n        s.x.push(42); s.x.push(42); s.x.push(42);\n        delete s;\n        assert(s.x.length == 0);\n        uint256[] storage x = s.x;\n        assembly { sstore(x.slot, 3) }\n        assert(s.x[0] == 0);\n        assert(s.x[1] == 0);\n        assert(s.x[2] == 0);\n        assert(b == 23);\n        assert(a == 17);\n    }\n\n    function g() public {\n        delete s;\n        s.x.push(42); s.x.push(42); s.x.push(42);\n        s.a = 1; s.b = 2;\n        delete s.x;\n        assert(s.x.length == 0);\n        uint256[] storage x = s.x;\n        assembly { sstore(x.slot, 3) }\n        assert(s.x[0] == 0);\n        assert(s.x[1] == 0);\n        assert(s.x[2] == 0);\n        assert(b == 23);\n        assert(a == 17);\n        assert(s.a == 1);\n        assert(s.b == 2);\n    }\n}\n// ----\n// f() ->\n// gas irOptimized: 113465\n// gas legacy: 113591\n// gas legacyOptimized: 113098\n// g() ->\n// gas irOptimized: 118828\n// gas legacy: 118764\n// gas legacyOptimized: 118168\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "metadata",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ]
            }
        }
    }
}