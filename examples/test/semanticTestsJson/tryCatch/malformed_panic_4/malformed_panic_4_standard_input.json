{
    "language": "Solidity",
    "sources": {
        "nested.sol": {
            "content": "contract C {\n    function g(bool b) public pure returns (uint, uint) {\n        require(b, \"failure\");\n        return (1, 2);\n    }\n    function f(bool cond1, bool cond2) public returns (uint x, uint y, bytes memory txt) {\n        try this.g(cond1) returns (uint a, uint b) {\n            try this.g(cond2) returns (uint a2, uint b2) {\n                (x, y) = (a, b);\n                txt = \"success\";\n            } catch Error(string memory s) {\n                x = 12;\n                txt = bytes(s);\n            } catch (bytes memory s) {\n                x = 13;\n                txt = s;\n            }\n        } catch Error(string memory s) {\n            x = 99;\n            txt = bytes(s);\n        } catch (bytes memory s) {\n            x = 98;\n            txt = s;\n        }\n    }\n}\n// ====\n// EVMVersion: >=byzantium\n// ----\n// f(bool,bool): true, true -> 1, 2, 96, 7, \"success\"\n// f(bool,bool): true, false -> 12, 0, 96, 7, \"failure\"\n// f(bool,bool): false, true -> 99, 0, 96, 7, \"failure\"\n// f(bool,bool): false, false -> 99, 0, 96, 7, \"failure\"\n"
        },
        "trivial.sol": {
            "content": "contract C {\n    function g(bool x) public pure {\n        require(x);\n    }\n    function f(bool x) public returns (uint) {\n        // Set the gas to make this work on pre-byzantium VMs\n        try this.g{gas: 8000}(x) {\n            return 1;\n        } catch {\n            return 2;\n        }\n    }\n}\n// ----\n// f(bool): true -> 1\n// f(bool): false -> 2\n"
        },
        "create.sol": {
            "content": "contract Reverts {\n    constructor(uint) { revert(\"test message.\"); }\n}\ncontract Succeeds {\n    constructor(uint) { }\n}\n\ncontract C {\n    function f() public returns (Reverts x, uint, string memory txt) {\n        uint i = 3;\n        try new Reverts(i) returns (Reverts r) {\n            x = r;\n            txt = \"success\";\n        } catch Error(string memory s) {\n            txt = s;\n        }\n    }\n    function g() public returns (Succeeds x, uint, string memory txt) {\n        uint i = 8;\n        try new Succeeds(i) returns (Succeeds r) {\n            x = r;\n            txt = \"success\";\n        } catch Error(string memory s) {\n            txt = s;\n        }\n    }\n}\n// ====\n// EVMVersion: >=byzantium\n// ----\n// f() -> 0, 0, 96, 13, \"test message.\"\n// g() -> 0x137aa4dfc0911524504fcd4d98501f179bc13b4a, 0, 96, 7, \"success\"\n"
        },
        "simple_notuple.sol": {
            "content": "contract C {\n    function g(bool b) public pure returns (uint x) {\n        require(b);\n        return 13;\n    }\n    function f(bool flag) public view returns (uint x) {\n        try this.g(flag) returns (uint a) {\n            x = a;\n        } catch {\n            x = 9;\n        }\n    }\n}\n// ====\n// EVMVersion: >=byzantium\n// ----\n// f(bool): true -> 13\n// f(bool): false -> 9\n"
        },
        "malformed_error.sol": {
            "content": "contract C {\n    function f(uint size) public pure {\n        assembly {\n            mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n            mstore(4, 0x20)\n            mstore(0x24, 7)\n            mstore(0x44, \"abcdefg\")\n            revert(0, size)\n        }\n    }\n    function a() public returns (uint) {\n        try this.f(3) {\n            assert(false);\n        } catch Panic(uint) {\n            assert(false);\n        } catch Error(string memory) {\n            assert(false);\n        } catch {\n            assert(true);\n        }\n    }\n    function b() public returns (uint) {\n        try this.f(6) {\n            assert(false);\n        } catch Panic(uint) {\n            assert(false);\n        } catch Error(string memory) {\n            assert(false);\n        } catch {\n            assert(true);\n        }\n    }\n    function b2() public returns (uint) {\n        try this.f(0x43) {\n            assert(false);\n        } catch Panic(uint) {\n            assert(false);\n        } catch Error(string memory) {\n            assert(false);\n        } catch {\n            assert(true);\n        }\n    }\n    function b3() public returns (string memory) {\n        try this.f(0x4a) {\n            assert(false);\n        } catch Panic(uint) {\n            assert(false);\n        } catch Error(string memory) {\n            assert(false);\n        } catch {\n            assert(true);\n        }\n    }\n    function c() public returns (string memory) {\n        try this.f(0x4b) {\n            assert(false);\n        } catch Panic(uint) {\n            assert(false);\n        } catch Error(string memory er) {\n            assert(true);\n            return er;\n        } catch {\n            assert(false);\n        }\n    }\n    function d() public returns (string memory) {\n        try this.f(0x100) {\n            assert(false);\n        } catch Panic(uint) {\n            assert(false);\n        } catch Error(string memory er) {\n            assert(true);\n            return er;\n        } catch {\n            assert(false);\n        }\n    }\n}\n// ====\n// EVMVersion: >=byzantium\n// ----\n// a() -> 0x00\n// b() -> 0x00\n// b2() -> 0x00\n// b3() -> 0x20, 0x00\n// c() -> 0x20, 7, \"abcdefg\"\n// d() -> 0x20, 7, \"abcdefg\"\n"
        },
        "panic.sol": {
            "content": "contract C {\n    function uf(bool b, uint x, uint y) public pure returns (uint) {\n        require(b, \"failure\");\n        return x - y;\n    }\n    function onlyPanic(bool b, uint x, uint y) public returns (uint r, uint code) {\n        try this.uf(b, x, y) returns (uint b) {\n            r = b;\n        } catch Panic(uint c) {\n            code = c;\n        }\n    }\n    function panicAndError(bool b, uint x, uint y) public returns (uint r, uint code, string memory msg_) {\n        try this.uf(b, x, y) returns (uint b) {\n            r = b;\n        } catch Panic(uint c) {\n            code = c;\n        } catch Error(string memory _errmsg) {\n            msg_ = _errmsg;\n        }\n    }\n}\n// ====\n// EVMVersion: >=byzantium\n// ----\n// onlyPanic(bool,uint256,uint256): true, 7, 6 -> 1, 0x00\n// onlyPanic(bool,uint256,uint256): true, 6, 7 -> 0x00, 0x11\n// onlyPanic(bool,uint256,uint256): false, 7, 6 -> FAILURE, hex\"08c379a0\", 0x20, 7, \"failure\"\n// onlyPanic(bool,uint256,uint256): false, 6, 7 -> FAILURE, hex\"08c379a0\", 0x20, 7, \"failure\"\n// panicAndError(bool,uint256,uint256): true, 7, 6 -> 1, 0x00, 0x60, 0x00\n// panicAndError(bool,uint256,uint256): true, 6, 7 -> 0x00, 0x11, 0x60, 0x00\n// panicAndError(bool,uint256,uint256): false, 7, 6 -> 0x00, 0x00, 0x60, 7, \"failure\"\n// panicAndError(bool,uint256,uint256): false, 6, 7 -> 0x00, 0x00, 0x60, 7, \"failure\"\n"
        },
        "super_trivial.sol": {
            "content": "contract C {\n    function g(bool x) external pure {\n        require(x);\n    }\n    function f(bool x) public returns (uint) {\n        try this.g(x) {\n            return 1;\n        } catch {\n            return 2;\n        }\n    }\n}\n// ====\n// EVMVersion: >=byzantium\n// ----\n// f(bool): true -> 1\n// f(bool): false -> 2\n"
        },
        "assert.sol": {
            "content": "contract C {\n    function g(bool x) public pure {\n        assert(x);\n    }\n    function f(bool x) public returns (uint) {\n        // Set the gas to make this work on pre-byzantium VMs\n        try this.g{gas: 8000}(x) {\n            return 1;\n        } catch {\n            return 2;\n        }\n    }\n}\n// ----\n// f(bool): true -> 1\n// f(bool): false -> 2\n"
        },
        "structuredAndLowLevel.sol": {
            "content": "contract C {\n    function g(bool b) public pure returns (uint, uint) {\n        require(b, \"message longer than 32 bytes 32 bytes 32 bytes 32 bytes 32 bytes 32 bytes 32 bytes\");\n        return (1, 2);\n    }\n    function f(bool cond) public returns (uint x, uint y, bytes memory txt) {\n        try this.g(cond) returns (uint a, uint b) {\n            (x, y) = (a, b);\n            txt = \"success\";\n        } catch Error(string memory s) {\n            x = 99;\n            txt = bytes(s);\n        } catch (bytes memory s) {\n            x = 98;\n            txt = s;\n        }\n    }\n}\n// ====\n// EVMVersion: >=byzantium\n// ----\n// f(bool): true -> 1, 2, 96, 7, \"success\"\n// f(bool): false -> 99, 0, 96, 82, \"message longer than 32 bytes 32 \", \"bytes 32 bytes 32 bytes 32 bytes\", \" 32 bytes 32 bytes\"\n"
        },
        "malformed_panic.sol": {
            "content": "contract C {\n    function f(uint size) public pure {\n        assembly {\n            mstore(0, 0x4e487b7100000000000000000000000000000000000000000000000000000000)\n            mstore(4, 0x43)\n            revert(0, size)\n        }\n    }\n    function a() public returns (uint) {\n        try this.f(3) {\n            assert(false);\n        } catch Panic(uint) {\n            assert(false);\n        } catch {\n            assert(true);\n        }\n    }\n    function b() public returns (uint) {\n        try this.f(6) {\n            assert(false);\n        } catch Panic(uint) {\n            assert(false);\n        } catch {\n            assert(true);\n        }\n    }\n    function c() public returns (uint) {\n        try this.f(0x24) {\n            assert(false);\n        } catch Panic(uint c) {\n            assert(true);\n            return c;\n        } catch {\n            assert(false);\n        }\n    }\n    function d() public returns (uint) {\n        try this.f(0x100) {\n            assert(false);\n        } catch Panic(uint c) {\n            assert(true);\n            return c;\n        } catch {\n            assert(false);\n        }\n    }\n}\n// ====\n// EVMVersion: >=byzantium\n// ----\n// a() -> 0x00\n// b() -> 0x00\n// c() -> 0x43\n// d() -> 0x43\n"
        },
        "structured.sol": {
            "content": "contract C {\n    function g(bool b) public pure returns (uint, uint) {\n        require(b, \"message\");\n        return (1, 2);\n    }\n    function f(bool b) public returns (uint x, uint y, string memory txt) {\n        try this.g(b) returns (uint a, uint b) {\n            (x, y) = (a, b);\n            txt = \"success\";\n        } catch Error(string memory s) {\n            txt = s;\n        }\n    }\n}\n// ====\n// EVMVersion: >=byzantium\n// ----\n// f(bool): true -> 1, 2, 0x60, 7, \"success\"\n// f(bool): false -> 0, 0, 0x60, 7, \"message\"\n"
        },
        "simple.sol": {
            "content": "contract C {\n    function g(bool b) public pure returns (uint x, uint y) {\n        require(b);\n        return (1, 2);\n    }\n    function f(bool flag) public view returns (uint x, uint y) {\n        try this.g(flag) returns (uint a, uint b) {\n            (x, y) = (a, b);\n        } catch {\n            (x, y) = (9, 10);\n        }\n    }\n}\n// ====\n// EVMVersion: >=byzantium\n// ----\n// f(bool): true -> 1, 2\n// f(bool): false -> 9, 10\n"
        },
        "invalid_error_encoding.sol": {
            "content": "contract C {\n    function g(bytes memory revertMsg) public pure returns (uint, uint) {\n        assembly { revert(add(revertMsg, 0x20), mload(revertMsg)) }\n    }\n    function f1() public returns (uint x) {\n        // Invalid signature\n        try this.g(abi.encodeWithSelector(0x12345678, uint(0), uint(0), uint(0))) returns (uint a, uint b) {\n            return 0;\n        } catch Error(string memory) {\n            return 1;\n        } catch (bytes memory) {\n            return 2;\n        }\n    }\n    function f1a() public returns (uint x) {\n        // Invalid signature\n        try this.g(abi.encodeWithSelector(0x12345678, uint(0), uint(0), uint(0))) returns (uint a, uint b) {\n            return 0;\n        } catch Error(string memory) {\n            return 1;\n        } catch {\n            return 2;\n        }\n    }\n    function f1b() public returns (uint x) {\n        // Invalid signature\n        try this.g(abi.encodeWithSelector(0x12345678, uint(0), uint(0), uint(0))) returns (uint a, uint b) {\n            return 0;\n        } catch Error(string memory) {\n            return 1;\n        }\n    }\n    function f1c() public returns (uint x) {\n        // Invalid signature\n        try this.g(abi.encodeWithSelector(0x12345678, uint(0), uint(0), uint(0))) returns (uint a, uint b) {\n            return 0;\n        } catch {\n            return 2;\n        }\n    }\n    function f2() public returns (uint x) {\n        // Valid signature but illegal offset\n        try this.g(abi.encodeWithSignature(\"Error(string)\", uint(0x100), uint(0), uint(0))) returns (uint a, uint b) {\n            return 0;\n        } catch Error(string memory) {\n            return 1;\n        } catch (bytes memory) {\n            return 2;\n        }\n    }\n    function f2a() public returns (uint x) {\n        // Valid signature but illegal offset\n        try this.g(abi.encodeWithSignature(\"Error(string)\", uint(0x100), uint(0), uint(0))) returns (uint a, uint b) {\n            return 0;\n        } catch Error(string memory) {\n            return 1;\n        } catch {\n            return 2;\n        }\n    }\n    function f2b() public returns (uint x) {\n        // Valid signature but illegal offset\n        try this.g(abi.encodeWithSignature(\"Error(string)\", uint(0x100), uint(0), uint(0))) returns (uint a, uint b) {\n            return 0;\n        } catch Error(string memory) {\n            return 1;\n        }\n    }\n    function f2c() public returns (uint x) {\n        // Valid signature but illegal offset\n        try this.g(abi.encodeWithSignature(\"Error(string)\", uint(0x100), uint(0), uint(0))) returns (uint a, uint b) {\n            return 0;\n        } catch {\n            return 1;\n        }\n    }\n    function f3() public returns (uint x) {\n        // Valid up to length\n        try this.g(abi.encodeWithSignature(\"Error(string)\", uint(0x20), uint(0x30), uint(0))) returns (uint a, uint b) {\n            return 0;\n        } catch Error(string memory) {\n            return 1;\n        } catch (bytes memory) {\n            return 2;\n        }\n    }\n    function f3a() public returns (uint x) {\n        // Valid up to length\n        try this.g(abi.encodeWithSignature(\"Error(string)\", uint(0x20), uint(0x30), uint(0))) returns (uint a, uint b) {\n            return 0;\n        } catch Error(string memory) {\n            return 1;\n        } catch (bytes memory) {\n            return 2;\n        }\n    }\n    function f3b() public returns (uint x) {\n        // Valid up to length\n        try this.g(abi.encodeWithSignature(\"Error(string)\", uint(0x20), uint(0x30), uint(0))) returns (uint a, uint b) {\n            return 0;\n        } catch Error(string memory) {\n            return 1;\n        }\n    }\n    function f3c() public returns (uint x) {\n        // Valid up to length\n        try this.g(abi.encodeWithSignature(\"Error(string)\", uint(0x20), uint(0x30), uint(0))) returns (uint a, uint b) {\n            return 0;\n        } catch {\n            return 1;\n        }\n    }\n    function f4() public returns (uint x) {\n        // Fully valid\n        try this.g(abi.encodeWithSignature(\"Error(string)\", uint(0x20), uint(0x7), bytes7(\"abcdefg\"))) returns (uint a, uint b) {\n            return 0;\n        } catch Error(string memory) {\n            return 1;\n        } catch (bytes memory) {\n            return 2;\n        }\n    }\n    function f4a() public returns (uint x) {\n        // Fully valid\n        try this.g(abi.encodeWithSignature(\"Error(string)\", uint(0x20), uint(0x7), bytes7(\"abcdefg\"))) returns (uint a, uint b) {\n            return 0;\n        } catch Error(string memory) {\n            return 1;\n        } catch {\n            return 2;\n        }\n    }\n    function f4b() public returns (uint x) {\n        // Fully valid\n        try this.g(abi.encodeWithSignature(\"Error(string)\", uint(0x20), uint(0x7), bytes7(\"abcdefg\"))) returns (uint a, uint b) {\n            return 0;\n        } catch Error(string memory) {\n            return 1;\n        }\n    }\n    function f4c() public returns (uint x) {\n        // Fully valid\n        try this.g(abi.encodeWithSignature(\"Error(string)\", uint(0x20), uint(0x7), bytes7(\"abcdefg\"))) returns (uint a, uint b) {\n            return 0;\n        } catch {\n            return 1;\n        }\n    }\n}\n// ====\n// EVMVersion: >=byzantium\n// ----\n// f1() -> 2\n// f1a() -> 2\n// f1b() -> FAILURE, hex\"12345678\", 0x0, 0, \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n// f1c() -> 2\n// f2() -> 2\n// f2a() -> 2\n// f2b() -> FAILURE, hex\"08c379a0\", 0x100, 0, \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n// f2c() -> 1\n// f3() -> 2\n// f3a() -> 2\n// f3b() -> FAILURE, hex\"08c379a0\", 0x20, 48, \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n// f3c() -> 1\n// f4() -> 1\n// f4a() -> 1\n// f4b() -> 1\n// f4c() -> 1\n"
        },
        "malformed_panic_4.sol": {
            "content": "contract C {\n    function f(uint size) public pure {\n        assembly {\n            mstore(0, 0x4e487b7100000000000000000000000000000000000000000000000000000000)\n            mstore(4, 0x43)\n            revert(0, size)\n        }\n    }\n    function a() public returns (uint) {\n        try this.f(3) {\n            assert(false);\n        } catch Panic(uint) {\n            assert(false);\n        } catch Error(string memory) {\n            assert(false);\n        } catch {\n            assert(true);\n        }\n    }\n    function b() public returns (uint) {\n        try this.f(6) {\n            assert(false);\n        } catch Panic(uint) {\n            assert(false);\n        } catch Error(string memory) {\n            assert(false);\n        } catch {\n            assert(true);\n        }\n    }\n    function c() public returns (uint) {\n        try this.f(0x24) {\n            assert(false);\n        } catch Panic(uint c) {\n            assert(true);\n            return c;\n        } catch Error(string memory) {\n            assert(false);\n        } catch {\n            assert(false);\n        }\n    }\n    function d() public returns (uint) {\n        try this.f(0x100) {\n            assert(false);\n        } catch Panic(uint c) {\n            assert(true);\n            return c;\n        } catch Error(string memory) {\n            assert(false);\n        } catch {\n            assert(false);\n        }\n    }\n}\n// ====\n// EVMVersion: >=byzantium\n// ----\n// a() -> 0x00\n// b() -> 0x00\n// c() -> 0x43\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "metadata",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ]
            }
        }
    }
}