{
    "language": "Solidity",
    "sources": {
        "calldata_struct_array_reencode.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n    struct D { uint[] x; }\n    struct S { uint x; }\n\n    function f(D calldata a) public returns (bytes memory){\n        return abi.encode(a);\n    }\n\n    function g(D[2] calldata a) public returns (bytes memory) {\n        return abi.encode(a);\n    }\n\n    function h(D[][] calldata a) public returns (bytes memory) {\n        return abi.encode(a);\n    }\n\n    function i(D[2][] calldata a) public returns (bytes memory) {\n        return abi.encode(a);\n    }\n\n    function j(S[] memory a) public returns (bytes memory) {\n        return abi.encode(a);\n    }\n\n    function k(S[2] memory a) public returns (bytes memory) {\n        return abi.encode(a);\n    }\n\n    function l(S[][] memory a) public returns (bytes memory) {\n        return abi.encode(a);\n    }\n\n}\n// ----\n// f((uint256[])): 0x20, 0x20, 0 -> 0x20, 0x60, 0x20, 0x20, 0\n// f((uint256[])): 0x20, 0x20, 1 -> FAILURE\n// f((uint256[])): 0x20, 0x20, 2 -> FAILURE\n// f((uint256[])): 0x20, 0x20, 3 -> FAILURE\n// g((uint256[])[2]): 0x20, 0x40, 0xc0, 0x20, 2, 1, 2, 0x20, 1, 3 -> 0x20, 0x0140, 0x20, 0x40, 0xc0, 0x20, 2, 1, 2, 0x20, 1, 3\n// g((uint256[])[2]): 0x20, 0x40, 0xc0, 0x20, 2, 1, 2, 0x20, 1 -> FAILURE\n// h((uint256[])[][]): 0x20, 0x02, 0x40, 0x0180, 2, 0x40, 0xc0, 0x20, 2, 1, 2, 0x20, 1, 3, 1, 0x20, 0x20, 1, 1 -> 0x20, 0x0260, 0x20, 2, 0x40, 0x0180, 2, 0x40, 0xc0, 0x20, 2, 1, 2, 0x20, 1, 3, 1, 0x20, 0x20, 1, 1\n// h((uint256[])[][]): 0x20, 0x02, 0x40, 0x0180, 2, 0x40, 0xc0, 0x20, 2, 1, 2, 0x20, 1, 3, 1, 0x20, 0x20, 1 -> FAILURE\n// i((uint256[])[2][]): 0x20, 1, 0x20, 0x40, 0xc0, 0x20, 2, 1, 2, 0x20, 1, 3 -> 0x20, 0x0180, 0x20, 1, 0x20, 0x40, 0xc0, 0x20, 2, 1, 2, 0x20, 1, 3\n// i((uint256[])[2][]): 0x20, 1, 0x20, 0x40, 0xc0, 0x20, 2, 1, 2, 0x20, 1 -> FAILURE\n// j((uint256)[]): 0x20, 2, 1, 2 -> 0x20, 0x80, 0x20, 2, 1, 2\n// j((uint256)[]): 0x20, 2, 1 -> FAILURE\n// k((uint256)[2]): 1, 2 -> 0x20, 0x40, 1, 2\n// k((uint256)[2]): 1 -> FAILURE\n// l((uint256)[][]): 0x20, 2, 0x40, 0xa0, 2, 5, 6, 3, 7, 8, 9 -> 0x20, 0x0160, 0x20, 2, 0x40, 0xa0, 2, 5, 6, 3, 7, 8, 9\n// l((uint256)[][]): 0x20, 2, 0x40, 0xa0, 2, 5, 6, 3, 7, 8, 9, 10 -> 0x20, 0x0160, 0x20, 2, 0x40, 0xa0, 2, 5, 6, 3, 7, 8, 9\n// l((uint256)[][]): 0x20, 2, 0x40, 0xa0, 2, 5, 6, 3, 7, 8 -> FAILURE\n"
        },
        "abi_encode_rational_v2.sol": {
            "content": "// Tests that rational numbers (even negative ones) are encoded properly.\npragma abicoder               v2;\n\n\ncontract C {\n    function f() public pure returns (bytes memory) {\n        return abi.encode(1, -2);\n    }\n}\n// ----\n// f() -> 0x20, 0x40, 0x1, -2\n"
        },
        "dynamic_arrays.sol": {
            "content": "pragma abicoder               v2;\n\ncontract C {\n    function f(uint a, uint16[] memory b, uint c)\n            public pure returns (uint, uint, uint) {\n        return (b.length, b[a], c);\n    }\n}\n// ----\n// f(uint256,uint16[],uint256): 6, 0x60, 9, 7, 11, 12, 13, 14, 15, 16, 17 -> 7, 17, 9\n"
        },
        "calldata_nested_array_static_reencode.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n\tfunction f(uint[3][] calldata a) public {\n\t\tabi.encode(a);\n\t}\n\tfunction f(uint[][3] calldata a) public {\n\t\tabi.encode(a);\n\t}\n\tfunction f(uint[2][2] calldata a) public {\n\t\tabi.encode(a);\n\t}\n}\n// ----\n// f(uint256[3][]): 0x20, 1, 0x01 -> FAILURE\n// f(uint256[3][]): 0x20, 1, 0x01, 0x02 -> FAILURE\n// f(uint256[3][]): 0x20, 1, 0x01, 0x02, 0x03 ->\n// f(uint256[][3]): 0x20, 0x60, 0x60, 0x60, 3, 0x01 -> FAILURE\n// f(uint256[][3]): 0x20, 0x60, 0x60, 0x60, 3, 0x01, 0x02 -> FAILURE\n// f(uint256[][3]): 0x20, 0x60, 0x60, 0x60, 3, 0x01, 0x02, 0x03 ->\n// f(uint256[2][2]): 0x01 -> FAILURE\n// f(uint256[2][2]): 0x01, 0x02 -> FAILURE\n// f(uint256[2][2]): 0x01, 0x02, 0x03 -> FAILURE\n// f(uint256[2][2]): 0x01, 0x02, 0x03, 0x04 ->\n// f(uint256[2][2]): 0x01, 0x02, 0x03, 0x04, 0x05 ->\n"
        },
        "byte_arrays.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n    function f(uint a, bytes memory b, uint c)\n            public pure returns (uint, uint, bytes1, uint) {\n        return (a, b.length, b[3], c);\n    }\n\n    function f_external(uint a, bytes calldata b, uint c)\n            external pure returns (uint, uint, bytes1, uint) {\n        return (a, b.length, b[3], c);\n    }\n}\n// ----\n// f(uint256,bytes,uint256): 6, 0x60, 9, 7, \"abcdefg\" -> 6, 7, \"d\", 9\n// f_external(uint256,bytes,uint256): 6, 0x60, 9, 7, \"abcdefg\" -> 6, 7, \"d\", 9\n"
        },
        "calldata_struct_member_offset.sol": {
            "content": "pragma abicoder               v2;\n\ncontract C {\n    struct A {\n        uint256 a;\n        uint256[] b;\n    }\n    struct B {\n        A a;\n        uint256 b;\n    }\n    function g(B calldata b) external pure returns(uint256) {\n        return b.b;\n    }\n    function f() public view returns(uint256, uint256) {\n        uint256[] memory arr = new uint256[](20);\n        arr[0] = 31; arr[2] = 84;\n        B memory b = B(A(420, arr), 11);\n        return (b.b, this.g(b));\n    }\n}\n// ----\n// f() -> 11, 11\n"
        },
        "calldata_with_garbage.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n    uint[] aTmp;\n    uint[2] bTmp;\n\n    function f_memory(uint[] calldata a) public returns (uint[] memory) {\n        return a;\n    }\n\n    function f_encode(uint[] calldata a) public returns (bytes memory) {\n        return abi.encode(a);\n    }\n\n    function f_storage(uint[] calldata a) public returns (bytes memory) {\n        aTmp = a;\n        return abi.encode(aTmp);\n    }\n\n    function f_index(uint[] calldata a, uint which) public returns (uint) {\n        return a[which];\n    }\n\n    function g_memory(uint[] calldata a, uint[2] calldata b) public returns (uint[] memory, uint[2] memory) {\n        return (a, b);\n    }\n\n    function g_encode(uint[] calldata a, uint[2] calldata b) public returns (bytes memory) {\n        return abi.encode(a, b);\n    }\n\n    function g_storage(uint[] calldata a, uint[2] calldata b) public returns (bytes memory) {\n        aTmp = a;\n        bTmp = b;\n        return abi.encode(aTmp, bTmp);\n    }\n\n    function g_index(uint[] calldata a, uint[2] calldata b, uint which) public returns (uint, uint) {\n        return (a[which], b[0]);\n    }\n}\n// ----\n// f_memory(uint256[]): 0x80, 9, 9, 9, 0 -> 0x20, 0\n// f_memory(uint256[]): 0x80, 9, 9, 9, 1, 7 -> 0x20, 1, 7\n// f_memory(uint256[]): 0x80, 9, 9, 9, 2, 7 -> FAILURE\n// f_encode(uint256[]): 0x80, 9, 9, 9, 0 -> 0x20, 0x40, 0x20, 0\n// f_encode(uint256[]): 0x80, 9, 9, 9, 1, 7 -> 0x20, 0x60, 0x20, 1, 7\n// f_encode(uint256[]): 0x80, 9, 9, 9, 2, 7 -> FAILURE\n// f_storage(uint256[]): 0x80, 9, 9, 9, 0 -> 0x20, 0x40, 0x20, 0\n// f_storage(uint256[]): 0x80, 9, 9, 9, 1, 7 -> 0x20, 0x60, 0x20, 1, 7\n// f_storage(uint256[]): 0x80, 9, 9, 9, 2, 7 -> FAILURE\n// f_index(uint256[],uint256): 0xa0, 0, 9, 9, 9, 2, 7, 8 -> 7\n// f_index(uint256[],uint256): 0xa0, 1, 9, 9, 9, 2, 7, 8 -> 8\n// f_index(uint256[],uint256): 0xa0, 2, 9, 9, 9, 2, 7, 8 -> FAILURE, hex\"4e487b71\", 0x32\n// g_memory(uint256[],uint256[2]): 0xc0, 1, 2, 9, 9, 9, 0 -> 0x60, 1, 2, 0\n// g_memory(uint256[],uint256[2]): 0xc0, 1, 2, 9, 9, 9, 1, 7 -> 0x60, 1, 2, 1, 7\n// g_memory(uint256[],uint256[2]): 0xc0, 1, 2, 9, 9, 9, 2, 7 -> FAILURE\n// g_encode(uint256[],uint256[2]): 0xc0, 1, 2, 9, 9, 9, 0 -> 0x20, 0x80, 0x60, 1, 2, 0\n// g_encode(uint256[],uint256[2]): 0xc0, 1, 2, 9, 9, 9, 1, 7 -> 0x20, 0xa0, 0x60, 1, 2, 1, 7\n// g_encode(uint256[],uint256[2]): 0xc0, 1, 2, 9, 9, 9, 2, 7 -> FAILURE\n// g_storage(uint256[],uint256[2]): 0xc0, 1, 2, 9, 9, 9, 0 -> 0x20, 0x80, 0x60, 1, 2, 0\n// g_storage(uint256[],uint256[2]): 0xc0, 1, 2, 9, 9, 9, 1, 7 -> 0x20, 0xa0, 0x60, 1, 2, 1, 7\n// g_storage(uint256[],uint256[2]): 0xc0, 1, 2, 9, 9, 9, 2, 7 -> FAILURE\n// g_index(uint256[],uint256[2],uint256): 0xe0, 1, 2, 0, 9, 9, 9, 2, 7, 8 -> 7, 1\n// g_index(uint256[],uint256[2],uint256): 0xe0, 1, 2, 1, 9, 9, 9, 2, 7, 8 -> 8, 1\n// g_index(uint256[],uint256[2],uint256): 0xe0, 1, 2, 1, 9, 9, 9, 2, 7 -> FAILURE\n"
        },
        "calldata_array_struct_dynamic.sol": {
            "content": "pragma abicoder               v2;\n\ncontract C {\n    struct S { uint256[] a; }\n    function f(S[] calldata s) external pure returns (bytes memory) {\n        return abi.encode(s);\n    }\n    function g(S[] calldata s) external view returns (bytes memory) {\n        return this.f(s);\n    }\n}\n// ====\n// EVMVersion: >homestead\n// ----\n// f((uint256[])[]): 32, 1, 32, 32, 3, 17, 42, 23 -> 32, 256, 32, 1, 32, 32, 3, 17, 42, 23\n// g((uint256[])[]): 32, 1, 32, 32, 3, 17, 42, 23 -> 32, 256, 32, 1, 32, 32, 3, 17, 42, 23\n"
        },
        "calldata_array_short_no_revert_string.sol": {
            "content": "contract C {\n\tfunction f(uint[] calldata) public {}\n}\n// ----\n// f(uint256[]): 0x20, 0 ->\n// f(uint256[]): 0x20, 1 -> FAILURE\n// f(uint256[]): 0x20, 2 -> FAILURE\n\n"
        },
        "calldata_array_dynamic_index_access.sol": {
            "content": "pragma abicoder               v2;\n\ncontract C {\n    function f(uint256[] calldata s) external pure returns (bytes memory) {\n        return abi.encode(s);\n    }\n    function g(uint256[][2] calldata s, uint256 which) external view returns (bytes memory) {\n        return this.f(s[which]);\n    }\n    function h(uint8[] calldata s) external pure returns (bytes memory) {\n        return abi.encode(s);\n    }\n    function i(uint8[][2] calldata s, uint256 which) external view returns (bytes memory) {\n        return this.h(s[which]);\n    }\n    function j(bytes calldata s) external pure returns (bytes memory) {\n        return abi.encode(s);\n    }\n    function k(bytes[2] calldata s, uint256 which) external view returns (bytes memory) {\n        return this.j(s[which]);\n    }\n}\n// ====\n// EVMVersion: >homestead\n// ----\n// f(uint256[]): 32, 3, 42, 23, 87 -> 32, 160, 32, 3, 42, 23, 87\n// g(uint256[][2],uint256): 0x40, 0, 0x40, 0xC0, 3, 42, 23, 87, 4, 11, 13, 17 -> 32, 160, 32, 3, 42, 23, 87\n// g(uint256[][2],uint256): 0x40, 1, 0x40, 0xC0, 3, 42, 23, 87, 4, 11, 13, 17, 27 -> 32, 192, 32, 4, 11, 13, 17, 27\n// h(uint8[]): 32, 3, 42, 23, 87 -> 32, 160, 32, 3, 42, 23, 87\n// i(uint8[][2],uint256): 0x40, 0, 0x40, 0xC0, 3, 42, 23, 87, 4, 11, 13, 17 -> 32, 160, 32, 3, 42, 23, 87\n// i(uint8[][2],uint256): 0x40, 1, 0x40, 0xC0, 3, 42, 23, 87, 4, 11, 13, 17, 27 -> 32, 192, 32, 4, 11, 13, 17, 27\n// j(bytes): 32, 3, hex\"AB11FF\" -> 32, 96, 32, 3, left(0xAB11FF)\n// k(bytes[2],uint256): 0x40, 0, 0x40, 0x63, 3, hex\"AB11FF\", 4, hex\"FF791432\" -> 32, 96, 32, 3, left(0xAB11FF)\n// k(bytes[2],uint256): 0x40, 1, 0x40, 0x63, 3, hex\"AB11FF\", 4, hex\"FF791432\" -> 32, 96, 32, 4, left(0xFF791432)\n"
        },
        "calldata_overlapped_nested_dynamic_arrays.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n    uint[] s;\n    uint[2] n;\n\n    function f_memory(uint[][] calldata a) public returns (uint[][] memory) {\n        return a;\n    }\n\n    function f_encode(uint[][] calldata a) public returns (bytes memory) {\n        return abi.encode(a);\n    }\n\n    function f_which(uint[][] calldata a, uint which) public returns (uint[] memory) {\n        return a[which];\n    }\n}\n// ----\n// f_memory(uint256[][]): 0x20, 2, 0x40, 0x40, 2, 1, 2 -> 0x20, 2, 0x40, 0xa0, 2, 1, 2, 2, 1, 2\n// f_memory(uint256[][]): 0x20, 2, 0x40, 0x60, 2, 1, 2 -> 0x20, 2, 0x40, 0xa0, 2, 1, 2, 1, 2\n// f_memory(uint256[][]): 0x20, 2, 0, 0x60, 2, 1, 2 -> 0x20, 2, 0x40, 0x60, 0, 1, 2\n// f_memory(uint256[][]): 0x20, 2, 0, 0x60, 2, 2, 2 -> FAILURE\n// f_encode(uint256[][]): 0x20, 2, 0x40, 0x40, 2, 1, 2 -> 0x20, 0x0140, 0x20, 2, 0x40, 0xa0, 2, 1, 2, 2, 1, 2\n// f_encode(uint256[][]): 0x20, 2, 0x40, 0x60, 2, 1, 2 -> 0x20, 0x0120, 0x20, 2, 0x40, 0xa0, 2, 1, 2, 1, 2\n// f_encode(uint256[][]): 0x20, 2, 0, 0x60, 2, 1, 2 -> 0x20, 0xe0, 0x20, 2, 0x40, 0x60, 0, 1, 2\n// f_encode(uint256[][]): 0x20, 2, 0, 0x60, 2, 2, 2 -> FAILURE\n// f_which(uint256[][],uint256): 0x40, 0, 2, 0x40, 0x40, 2, 1, 2 -> 0x20, 2, 1, 2\n// f_which(uint256[][],uint256): 0x40, 1, 2, 0x40, 0x40, 2, 1, 2 -> 0x20, 2, 1, 2\n// f_which(uint256[][],uint256): 0x40, 0, 2, 0x40, 0x60, 2, 1, 2 -> 0x20, 2, 1, 2\n// f_which(uint256[][],uint256): 0x40, 1, 2, 0x40, 0x60, 2, 1, 2 -> 0x20, 1, 2\n// f_which(uint256[][],uint256): 0x40, 0, 2, 0, 0x60, 2, 1, 2 -> 0x20, 0\n// f_which(uint256[][],uint256): 0x40, 1, 2, 0, 0x60, 2, 1, 2 -> 0x20, 1, 2\n// f_which(uint256[][],uint256): 0x40, 1, 2, 0, 0x60, 2, 2, 2 -> FAILURE\n"
        },
        "memory_params_in_external_function.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n    function f(bytes memory a, bytes calldata b, uint[] memory c)\n        external\n        pure\n        returns (uint, bytes1, uint, bytes1, uint, uint)\n    {\n        return (a.length, a[1], b.length, b[2], c.length, c[3]);\n    }\n    function g() public returns (uint, bytes1, uint, bytes1, uint, uint) {\n        uint[] memory x = new uint[](4);\n        x[3] = 7;\n        return this.f(\"abc\", \"def\", x);\n    }\n}\n// ----\n// g() -> 3, 0x6200000000000000000000000000000000000000000000000000000000000000, 3, 0x6600000000000000000000000000000000000000000000000000000000000000, 4, 7\n"
        },
        "calldata_array_dynamic_static_in_library.sol": {
            "content": "library L {\n    // This case used to be affected by the buggy cleanup due to ABIEncoderV2HeadOverflowWithStaticArrayCleanup bug.\n    function g(uint[] memory a, uint[1] calldata b) public returns (uint[] memory, uint[1] calldata) {\n        return (a, b);\n    }\n}\n\ncontract C {\n    function f(uint[] memory a, uint[1] calldata b) public returns (uint[] memory, uint[1] memory) {\n        return L.g(a, b);\n    }\n}\n// ====\n// EVMVersion: >homestead\n// ----\n// library: L\n// f(uint256[],uint256[1]): 0x40, 0xff, 1, 0xffff -> 0x40, 0xff, 0x01, 0xffff\n"
        },
        "bool_out_of_bounds.sol": {
            "content": "pragma abicoder               v2;\n\ncontract C {\n\tfunction f(bool b) public pure returns (bool) { return b; }\n}\n// ----\n// f(bool): true -> true\n// f(bool): false -> false\n// f(bool): 0x000000 -> false\n// f(bool): 0xffffff -> FAILURE\n"
        },
        "calldata_dynamic_array_to_memory.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n    function f(uint[][] calldata a) public returns (uint[][] memory) {\n        return a;\n    }\n\n    function g(uint[][][] calldata a) public returns (uint[][][] memory) {\n        return a;\n    }\n\n    function h(uint[2][][] calldata a) public returns (uint[2][][] memory) {\n        return a;\n    }\n}\n// ----\n// f(uint256[][]): 0x20, 2, 0x40, 0xa0, 2, 5, 6, 2, 7, 8 -> 0x20, 2, 0x40, 0xa0, 2, 5, 6, 2, 7, 8\n// f(uint256[][]): 0x20, 2, 0x40, 0xa0, 2, 5, 6, 2, 7, 8, 9 -> 0x20, 2, 0x40, 0xa0, 2, 5, 6, 2, 7, 8\n// f(uint256[][]): 0x20, 2, 0x40, 0xa0, 2, 5, 6, 3, 7, 8 -> FAILURE\n// g(uint256[][][]): 0x20, 2, 0x40, 0x60, 0, 2, 0x40, 0xa0, 2, 5, 6, 2, 7, 8 -> 0x20, 2, 0x40, 0x60, 0, 2, 0x40, 0xa0, 2, 5, 6, 2, 7, 8\n// g(uint256[][][]): 0x20, 2, 0x40, 0x60, 0, 2, 0x40, 0xa0, 2, 5, 6, 2, 7 -> FAILURE\n// h(uint256[2][][]): 0x20, 2, 0x40, 0x60, 0, 2, 5, 6, 7, 8 -> 0x20, 2, 0x40, 0x60, 0, 2, 5, 6, 7, 8\n// h(uint256[2][][]): 0x20, 2, 0x40, 0x60, 0, 2, 5, 6, 7, 8, 9 -> 0x20, 2, 0x40, 0x60, 0, 2, 5, 6, 7, 8\n// h(uint256[2][][]): 0x20, 2, 0x40, 0x60, 0, 2, 5, 6, 7 -> FAILURE\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "metadata",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ]
            }
        }
    }
}