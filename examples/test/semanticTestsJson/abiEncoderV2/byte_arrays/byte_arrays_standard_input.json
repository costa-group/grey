{
    "language": "Solidity",
    "sources": {
        "calldata_struct_array_reencode.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n    struct D { uint[] x; }\n    struct S { uint x; }\n\n    function f(D calldata a) public returns (bytes memory){\n        return abi.encode(a);\n    }\n\n    function g(D[2] calldata a) public returns (bytes memory) {\n        return abi.encode(a);\n    }\n\n    function h(D[][] calldata a) public returns (bytes memory) {\n        return abi.encode(a);\n    }\n\n    function i(D[2][] calldata a) public returns (bytes memory) {\n        return abi.encode(a);\n    }\n\n    function j(S[] memory a) public returns (bytes memory) {\n        return abi.encode(a);\n    }\n\n    function k(S[2] memory a) public returns (bytes memory) {\n        return abi.encode(a);\n    }\n\n    function l(S[][] memory a) public returns (bytes memory) {\n        return abi.encode(a);\n    }\n\n}\n// ----\n// f((uint256[])): 0x20, 0x20, 0 -> 0x20, 0x60, 0x20, 0x20, 0\n// f((uint256[])): 0x20, 0x20, 1 -> FAILURE\n// f((uint256[])): 0x20, 0x20, 2 -> FAILURE\n// f((uint256[])): 0x20, 0x20, 3 -> FAILURE\n// g((uint256[])[2]): 0x20, 0x40, 0xc0, 0x20, 2, 1, 2, 0x20, 1, 3 -> 0x20, 0x0140, 0x20, 0x40, 0xc0, 0x20, 2, 1, 2, 0x20, 1, 3\n// g((uint256[])[2]): 0x20, 0x40, 0xc0, 0x20, 2, 1, 2, 0x20, 1 -> FAILURE\n// h((uint256[])[][]): 0x20, 0x02, 0x40, 0x0180, 2, 0x40, 0xc0, 0x20, 2, 1, 2, 0x20, 1, 3, 1, 0x20, 0x20, 1, 1 -> 0x20, 0x0260, 0x20, 2, 0x40, 0x0180, 2, 0x40, 0xc0, 0x20, 2, 1, 2, 0x20, 1, 3, 1, 0x20, 0x20, 1, 1\n// h((uint256[])[][]): 0x20, 0x02, 0x40, 0x0180, 2, 0x40, 0xc0, 0x20, 2, 1, 2, 0x20, 1, 3, 1, 0x20, 0x20, 1 -> FAILURE\n// i((uint256[])[2][]): 0x20, 1, 0x20, 0x40, 0xc0, 0x20, 2, 1, 2, 0x20, 1, 3 -> 0x20, 0x0180, 0x20, 1, 0x20, 0x40, 0xc0, 0x20, 2, 1, 2, 0x20, 1, 3\n// i((uint256[])[2][]): 0x20, 1, 0x20, 0x40, 0xc0, 0x20, 2, 1, 2, 0x20, 1 -> FAILURE\n// j((uint256)[]): 0x20, 2, 1, 2 -> 0x20, 0x80, 0x20, 2, 1, 2\n// j((uint256)[]): 0x20, 2, 1 -> FAILURE\n// k((uint256)[2]): 1, 2 -> 0x20, 0x40, 1, 2\n// k((uint256)[2]): 1 -> FAILURE\n// l((uint256)[][]): 0x20, 2, 0x40, 0xa0, 2, 5, 6, 3, 7, 8, 9 -> 0x20, 0x0160, 0x20, 2, 0x40, 0xa0, 2, 5, 6, 3, 7, 8, 9\n// l((uint256)[][]): 0x20, 2, 0x40, 0xa0, 2, 5, 6, 3, 7, 8, 9, 10 -> 0x20, 0x0160, 0x20, 2, 0x40, 0xa0, 2, 5, 6, 3, 7, 8, 9\n// l((uint256)[][]): 0x20, 2, 0x40, 0xa0, 2, 5, 6, 3, 7, 8 -> FAILURE\n"
        },
        "abi_encode_rational_v2.sol": {
            "content": "// Tests that rational numbers (even negative ones) are encoded properly.\npragma abicoder               v2;\n\n\ncontract C {\n    function f() public pure returns (bytes memory) {\n        return abi.encode(1, -2);\n    }\n}\n// ----\n// f() -> 0x20, 0x40, 0x1, -2\n"
        },
        "dynamic_arrays.sol": {
            "content": "pragma abicoder               v2;\n\ncontract C {\n    function f(uint a, uint16[] memory b, uint c)\n            public pure returns (uint, uint, uint) {\n        return (b.length, b[a], c);\n    }\n}\n// ----\n// f(uint256,uint16[],uint256): 6, 0x60, 9, 7, 11, 12, 13, 14, 15, 16, 17 -> 7, 17, 9\n"
        },
        "calldata_nested_array_static_reencode.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n\tfunction f(uint[3][] calldata a) public {\n\t\tabi.encode(a);\n\t}\n\tfunction f(uint[][3] calldata a) public {\n\t\tabi.encode(a);\n\t}\n\tfunction f(uint[2][2] calldata a) public {\n\t\tabi.encode(a);\n\t}\n}\n// ----\n// f(uint256[3][]): 0x20, 1, 0x01 -> FAILURE\n// f(uint256[3][]): 0x20, 1, 0x01, 0x02 -> FAILURE\n// f(uint256[3][]): 0x20, 1, 0x01, 0x02, 0x03 ->\n// f(uint256[][3]): 0x20, 0x60, 0x60, 0x60, 3, 0x01 -> FAILURE\n// f(uint256[][3]): 0x20, 0x60, 0x60, 0x60, 3, 0x01, 0x02 -> FAILURE\n// f(uint256[][3]): 0x20, 0x60, 0x60, 0x60, 3, 0x01, 0x02, 0x03 ->\n// f(uint256[2][2]): 0x01 -> FAILURE\n// f(uint256[2][2]): 0x01, 0x02 -> FAILURE\n// f(uint256[2][2]): 0x01, 0x02, 0x03 -> FAILURE\n// f(uint256[2][2]): 0x01, 0x02, 0x03, 0x04 ->\n// f(uint256[2][2]): 0x01, 0x02, 0x03, 0x04, 0x05 ->\n"
        },
        "byte_arrays.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n    function f(uint a, bytes memory b, uint c)\n            public pure returns (uint, uint, bytes1, uint) {\n        return (a, b.length, b[3], c);\n    }\n\n    function f_external(uint a, bytes calldata b, uint c)\n            external pure returns (uint, uint, bytes1, uint) {\n        return (a, b.length, b[3], c);\n    }\n}\n// ----\n// f(uint256,bytes,uint256): 6, 0x60, 9, 7, \"abcdefg\" -> 6, 7, \"d\", 9\n// f_external(uint256,bytes,uint256): 6, 0x60, 9, 7, \"abcdefg\" -> 6, 7, \"d\", 9\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "metadata",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ]
            }
        }
    }
}