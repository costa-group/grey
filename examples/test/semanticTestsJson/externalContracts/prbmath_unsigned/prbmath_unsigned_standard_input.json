{
    "language": "Solidity",
    "sources": {
        "ramanujan_pi.sol": {
            "content": "==== ExternalSource: _prbmath/PRBMathCommon.sol ====\n==== ExternalSource: _prbmath/PRBMathSD59x18.sol ====\n==== Source: ramanujan_pi.sol ====\nimport \"_prbmath/PRBMathSD59x18.sol\";\n\n// The goal of this test file is to implement Ramanujan's pi approximation using various libraries.\n\nfunction factorial(uint n) pure returns (uint ret) {\n    ret = 1;\n    for (; n > 1; --n)\n        ret *= n;\n}\n\ncontract test {\n    using PRBMathSD59x18 for int256;\n\n    function prb_scale(uint n) internal pure returns (int256 ret) {\n        // Scale to SD59x18\n        ret = int256(n * 10e17);\n    }\n\n    // This dumb implementation of Ramanujan series calculates 1/pi\n    function prb_pi() external pure returns (int256 ret) {\n        uint n = 6; // More than 6 iterations results in failure\n        for (uint k = 0; k < n; k++) {\n            int256 a = prb_scale(factorial(4 * k)).div(prb_scale(factorial(k)).pow(4));\n            int256 b = (prb_scale(25390).mul(prb_scale(k)) + prb_scale(1103)).div(prb_scale(396).pow(4 * k));\n            ret += a.mul(b);\n        }\n        ret = ret.mul(prb_scale(2).sqrt().mul(prb_scale(2)).div(prb_scale(99).pow(2)));\n        ret = prb_scale(1).div(ret);\n    }\n}\n// ----\n// constructor()\n// gas irOptimized: 77816\n// gas irOptimized code: 307600\n// gas legacy: 92110\n// gas legacy code: 523600\n// gas legacyOptimized: 82667\n// gas legacyOptimized code: 369200\n// prb_pi() -> 3141592656369545286\n// gas irOptimized: 57478\n// gas legacy: 100657\n// gas legacyOptimized: 75735\n"
        },
        "FixedFeeRegistrar.sol": {
            "content": "//sol FixedFeeRegistrar\n// Simple global registrar with fixed-fee reservations.\n// @authors:\n//   Gav Wood <g@ethdev.com>\n\npragma solidity >=0.4.0 <0.9.0;\n\nabstract contract Registrar {\n\tevent Changed(string indexed name);\n\n\tfunction owner(string memory _name) public virtual view returns (address o_owner);\n\tfunction addr(string memory _name) public virtual view returns (address o_address);\n\tfunction subRegistrar(string memory _name) virtual public view returns (address o_subRegistrar);\n\tfunction content(string memory _name) public virtual view returns (bytes32 o_content);\n}\n\ncontract FixedFeeRegistrar is Registrar {\n\tstruct Record {\n\t\taddress addr;\n\t\taddress subRegistrar;\n\t\tbytes32 content;\n\t\taddress owner;\n\t}\n\n\tmodifier onlyrecordowner(string memory _name) { if (m_record(_name).owner == msg.sender) _; }\n\n\tfunction reserve(string memory _name) public payable {\n\t\tRecord storage rec = m_record(_name);\n\t\tif (rec.owner == 0x0000000000000000000000000000000000000000 && msg.value >= c_fee) {\n\t\t\trec.owner = msg.sender;\n\t\t\temit Changed(_name);\n\t\t}\n\t}\n\tfunction disown(string memory _name, address payable _refund) onlyrecordowner(_name) public {\n\t\tdelete m_recordData[uint(keccak256(bytes(_name))) / 8];\n\t\tif (!_refund.send(c_fee))\n\t\t\trevert();\n\t\temit Changed(_name);\n\t}\n\tfunction transfer(string memory _name, address _newOwner) onlyrecordowner(_name) public {\n\t\tm_record(_name).owner = _newOwner;\n\t\temit Changed(_name);\n\t}\n\tfunction setAddr(string memory _name, address _a) onlyrecordowner(_name) public {\n\t\tm_record(_name).addr = _a;\n\t\temit Changed(_name);\n\t}\n\tfunction setSubRegistrar(string memory _name, address _registrar) onlyrecordowner(_name) public {\n\t\tm_record(_name).subRegistrar = _registrar;\n\t\temit Changed(_name);\n\t}\n\tfunction setContent(string memory _name, bytes32 _content) onlyrecordowner(_name) public {\n\t\tm_record(_name).content = _content;\n\t\temit Changed(_name);\n\t}\n\n\tfunction record(string memory _name) public view returns (address o_addr, address o_subRegistrar, bytes32 o_content, address o_owner) {\n\t\tRecord storage rec = m_record(_name);\n\t\to_addr = rec.addr;\n\t\to_subRegistrar = rec.subRegistrar;\n\t\to_content = rec.content;\n\t\to_owner = rec.owner;\n\t}\n\tfunction addr(string memory _name) public override view returns (address) { return m_record(_name).addr; }\n\tfunction subRegistrar(string memory _name) public override view returns (address) { return m_record(_name).subRegistrar; }\n\tfunction content(string memory _name) public override view returns (bytes32) { return m_record(_name).content; }\n\tfunction owner(string memory _name) public override view returns (address) { return m_record(_name).owner; }\n\n\tRecord[2**253] m_recordData;\n\tfunction m_record(string memory _name) view internal returns (Record storage o_record) {\n\t\treturn m_recordData[uint(keccak256(bytes(_name))) / 8];\n\t}\n\tuint constant c_fee = 69 ether;\n}\n// ----\n// constructor()\n// gas irOptimized: 78076\n// gas irOptimized code: 307400\n// gas legacy: 115395\n// gas legacy code: 792400\n// gas legacyOptimized: 84598\n// gas legacyOptimized code: 388000\n// reserve(string), 69 ether: 0x20, 3, \"abc\" ->\n// ~ emit Changed(string): #0x4e03657aea45a94fc7d47ba826c8d667c0d1e6e33a64a036ec44f58fa12d6c45\n// gas irOptimized: 45967\n// gas legacy: 46842\n// gas legacyOptimized: 46091\n// owner(string): 0x20, 3, \"abc\" -> 0x1212121212121212121212121212120000000012\n// reserve(string), 70 ether: 0x20, 3, \"def\" ->\n// ~ emit Changed(string): #0x34607c9bbfeb9c23509680f04363f298fdb0b5f9abe327304ecd1daca08cda9c\n// owner(string): 0x20, 3, \"def\" -> 0x1212121212121212121212121212120000000012\n// reserve(string), 68 ether: 0x20, 3, \"ghi\" ->\n// owner(string): 0x20, 3, \"ghi\" -> 0\n// account: 1 -> 0x1212121212121212121212121212120000001012\n// reserve(string), 69 ether: 0x20, 3, \"abc\" ->\n// owner(string): 0x20, 3, \"abc\" -> 0x1212121212121212121212121212120000000012\n// account: 0 -> 0x1212121212121212121212121212120000000012\n// setContent(string,bytes32): 0x40, 0, 3, \"abc\" ->\n// ~ emit Changed(string): #0x4e03657aea45a94fc7d47ba826c8d667c0d1e6e33a64a036ec44f58fa12d6c45\n// transfer(string,address): 0x40, 555, 3, \"abc\" ->\n// ~ emit Changed(string): #0x4e03657aea45a94fc7d47ba826c8d667c0d1e6e33a64a036ec44f58fa12d6c45\n// owner(string): 0x20, 3, \"abc\" -> 555\n// content(string): 0x20, 3, \"abc\" -> 0x00\n// setContent(string,bytes32): 0x40, 333, 3, \"def\" ->\n// ~ emit Changed(string): #0x34607c9bbfeb9c23509680f04363f298fdb0b5f9abe327304ecd1daca08cda9c\n// setAddr(string,address): 0x40, 124, 3, \"def\" ->\n// ~ emit Changed(string): #0x34607c9bbfeb9c23509680f04363f298fdb0b5f9abe327304ecd1daca08cda9c\n// setSubRegistrar(string,address): 0x40, 125, 3, \"def\" ->\n// ~ emit Changed(string): #0x34607c9bbfeb9c23509680f04363f298fdb0b5f9abe327304ecd1daca08cda9c\n// content(string): 0x20, 3, \"def\" -> 333\n// addr(string): 0x20, 3, \"def\" -> 124\n// subRegistrar(string): 0x20, 3, \"def\" -> 125\n// balance: 0x124 -> 0\n// disown(string,address): 0x40, 0x124, 3, \"def\" ->\n// ~ emit Changed(string): #0x34607c9bbfeb9c23509680f04363f298fdb0b5f9abe327304ecd1daca08cda9c\n// balance: 0x124 -> 0\n// ~ emit Changed(string): #0x34607c9bbfeb9c23509680f04363f298fdb0b5f9abe327304ecd1daca08cda9c\n// owner(string): 0x20, 3, \"def\" -> 0\n// content(string): 0x20, 3, \"def\" -> 0\n// addr(string): 0x20, 3, \"def\" -> 0\n// subRegistrar(string): 0x20, 3, \"def\" -> 0\n"
        },
        "deposit_contract.sol": {
            "content": "// \u250f\u2501\u2501\u2501\u2513\u2501\u250f\u2513\u2501\u250f\u2513\u2501\u2501\u250f\u2501\u2501\u2501\u2513\u2501\u2501\u250f\u2501\u2501\u2501\u2513\u2501\u2501\u2501\u2501\u250f\u2501\u2501\u2501\u2513\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u250f\u2513\u2501\u2501\u2501\u2501\u2501\u250f\u2501\u2501\u2501\u2513\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u250f\u2513\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u250f\u2513\u2501\n// \u2503\u250f\u2501\u2501\u251b\u250f\u251b\u2517\u2513\u2503\u2503\u2501\u2501\u2503\u250f\u2501\u2513\u2503\u2501\u2501\u2503\u250f\u2501\u2513\u2503\u2501\u2501\u2501\u2501\u2517\u2513\u250f\u2513\u2503\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u250f\u251b\u2517\u2513\u2501\u2501\u2501\u2501\u2503\u250f\u2501\u2513\u2503\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u250f\u251b\u2517\u2513\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u250f\u251b\u2517\u2513\n// \u2503\u2517\u2501\u2501\u2513\u2517\u2513\u250f\u251b\u2503\u2517\u2501\u2513\u2517\u251b\u250f\u251b\u2503\u2501\u2501\u2503\u2503\u2501\u2503\u2503\u2501\u2501\u2501\u2501\u2501\u2503\u2503\u2503\u2503\u250f\u2501\u2501\u2513\u250f\u2501\u2501\u2513\u250f\u2501\u2501\u2513\u250f\u2501\u2501\u2513\u250f\u2513\u2517\u2513\u250f\u251b\u2501\u2501\u2501\u2501\u2503\u2503\u2501\u2517\u251b\u250f\u2501\u2501\u2513\u250f\u2501\u2513\u2501\u2517\u2513\u250f\u251b\u250f\u2501\u2513\u250f\u2501\u2501\u2513\u2501\u250f\u2501\u2501\u2513\u2517\u2513\u250f\u251b\n// \u2503\u250f\u2501\u2501\u251b\u2501\u2503\u2503\u2501\u2503\u250f\u2513\u2503\u250f\u2501\u251b\u250f\u251b\u2501\u2501\u2503\u2503\u2501\u2503\u2503\u2501\u2501\u2501\u2501\u2501\u2503\u2503\u2503\u2503\u2503\u250f\u2513\u2503\u2503\u250f\u2513\u2503\u2503\u250f\u2513\u2503\u2503\u2501\u2501\u252b\u2523\u252b\u2501\u2503\u2503\u2501\u2501\u2501\u2501\u2501\u2503\u2503\u2501\u250f\u2513\u2503\u250f\u2513\u2503\u2503\u250f\u2513\u2513\u2501\u2503\u2503\u2501\u2503\u250f\u251b\u2517\u2501\u2513\u2503\u2501\u2503\u250f\u2501\u251b\u2501\u2503\u2503\u2501\n// \u2503\u2517\u2501\u2501\u2513\u2501\u2503\u2517\u2513\u2503\u2503\u2503\u2503\u2503\u2503\u2517\u2501\u2513\u250f\u2513\u2503\u2517\u2501\u251b\u2503\u2501\u2501\u2501\u2501\u250f\u251b\u2517\u251b\u2503\u2503\u2503\u2501\u252b\u2503\u2517\u251b\u2503\u2503\u2517\u251b\u2503\u2523\u2501\u2501\u2503\u2503\u2503\u2501\u2503\u2517\u2513\u2501\u2501\u2501\u2501\u2503\u2517\u2501\u251b\u2503\u2503\u2517\u251b\u2503\u2503\u2503\u2503\u2503\u2501\u2503\u2517\u2513\u2503\u2503\u2501\u2503\u2517\u251b\u2517\u2513\u2503\u2517\u2501\u2513\u2501\u2503\u2517\u2513\n// \u2517\u2501\u2501\u2501\u251b\u2501\u2517\u2501\u251b\u2517\u251b\u2517\u251b\u2517\u2501\u2501\u2501\u251b\u2517\u251b\u2517\u2501\u2501\u2501\u251b\u2501\u2501\u2501\u2501\u2517\u2501\u2501\u2501\u251b\u2517\u2501\u2501\u251b\u2503\u250f\u2501\u251b\u2517\u2501\u2501\u251b\u2517\u2501\u2501\u251b\u2517\u251b\u2501\u2517\u2501\u251b\u2501\u2501\u2501\u2501\u2517\u2501\u2501\u2501\u251b\u2517\u2501\u2501\u251b\u2517\u251b\u2517\u251b\u2501\u2517\u2501\u251b\u2517\u251b\u2501\u2517\u2501\u2501\u2501\u251b\u2517\u2501\u2501\u251b\u2501\u2517\u2501\u251b\n// \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2503\u2503\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n// \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2517\u251b\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n\n// SPDX-License-Identifier: CC0-1.0\n\n// This interface is designed to be compatible with the Vyper version.\n/// @notice This is the Ethereum 2.0 deposit contract interface.\n/// For more information see the Phase 0 specification under https://github.com/ethereum/eth2.0-specs\ninterface IDepositContract {\n    /// @notice A processed deposit event.\n    event DepositEvent(\n        bytes pubkey,\n        bytes withdrawal_credentials,\n        bytes amount,\n        bytes signature,\n        bytes index\n    );\n\n    /// @notice Submit a Phase 0 DepositData object.\n    /// @param pubkey A BLS12-381 public key.\n    /// @param withdrawal_credentials Commitment to a public key for withdrawals.\n    /// @param signature A BLS12-381 signature.\n    /// @param deposit_data_root The SHA-256 hash of the SSZ-encoded DepositData object.\n    /// Used as a protection against malformed input.\n    function deposit(\n        bytes calldata pubkey,\n        bytes calldata withdrawal_credentials,\n        bytes calldata signature,\n        bytes32 deposit_data_root\n    ) external payable;\n\n    /// @notice Query the current deposit root hash.\n    /// @return The deposit root hash.\n    function get_deposit_root() external view returns (bytes32);\n\n    /// @notice Query the current deposit count.\n    /// @return The deposit count encoded as a little endian 64-bit number.\n    function get_deposit_count() external view returns (bytes memory);\n}\n\n// Based on official specification in https://eips.ethereum.org/EIPS/eip-165\ninterface ERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceId` and\n    ///  `interfaceId` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool);\n}\n\n// This is a rewrite of the Vyper Eth2.0 deposit contract in Solidity.\n// It tries to stay as close as possible to the original source code.\n/// @notice This is the Ethereum 2.0 deposit contract interface.\n/// For more information see the Phase 0 specification under https://github.com/ethereum/eth2.0-specs\ncontract DepositContract is IDepositContract, ERC165 {\n    uint constant DEPOSIT_CONTRACT_TREE_DEPTH = 32;\n    // NOTE: this also ensures `deposit_count` will fit into 64-bits\n    uint constant MAX_DEPOSIT_COUNT = 2**DEPOSIT_CONTRACT_TREE_DEPTH - 1;\n\n    bytes32[DEPOSIT_CONTRACT_TREE_DEPTH] branch;\n    uint256 deposit_count;\n\n    bytes32[DEPOSIT_CONTRACT_TREE_DEPTH] zero_hashes;\n\n    constructor() public {\n        // Compute hashes in empty sparse Merkle tree\n        for (uint height = 0; height < DEPOSIT_CONTRACT_TREE_DEPTH - 1; height++)\n            zero_hashes[height + 1] = sha256(abi.encodePacked(zero_hashes[height], zero_hashes[height]));\n    }\n\n    function get_deposit_root() override external view returns (bytes32) {\n        bytes32 node;\n        uint size = deposit_count;\n        for (uint height = 0; height < DEPOSIT_CONTRACT_TREE_DEPTH; height++) {\n            if ((size & 1) == 1)\n                node = sha256(abi.encodePacked(branch[height], node));\n            else\n                node = sha256(abi.encodePacked(node, zero_hashes[height]));\n            size /= 2;\n        }\n        return sha256(abi.encodePacked(\n            node,\n            to_little_endian_64(uint64(deposit_count)),\n            bytes24(0)\n        ));\n    }\n\n    function get_deposit_count() override external view returns (bytes memory) {\n        return to_little_endian_64(uint64(deposit_count));\n    }\n\n    function deposit(\n        bytes calldata pubkey,\n        bytes calldata withdrawal_credentials,\n        bytes calldata signature,\n        bytes32 deposit_data_root\n    ) override external payable {\n        // Extended ABI length checks since dynamic types are used.\n        require(pubkey.length == 48, \"DepositContract: invalid pubkey length\");\n        require(withdrawal_credentials.length == 32, \"DepositContract: invalid withdrawal_credentials length\");\n        require(signature.length == 96, \"DepositContract: invalid signature length\");\n\n        // Check deposit amount\n        require(msg.value >= 1 ether, \"DepositContract: deposit value too low\");\n        require(msg.value % 1 gwei == 0, \"DepositContract: deposit value not multiple of gwei\");\n        uint deposit_amount = msg.value / 1 gwei;\n        require(deposit_amount <= type(uint64).max, \"DepositContract: deposit value too high\");\n\n        // Emit `DepositEvent` log\n        bytes memory amount = to_little_endian_64(uint64(deposit_amount));\n        emit DepositEvent(\n            pubkey,\n            withdrawal_credentials,\n            amount,\n            signature,\n            to_little_endian_64(uint64(deposit_count))\n        );\n\n        // Compute deposit data root (`DepositData` hash tree root)\n        bytes32 pubkey_root = sha256(abi.encodePacked(pubkey, bytes16(0)));\n        bytes32 signature_root = sha256(abi.encodePacked(\n            sha256(abi.encodePacked(signature[:64])),\n            sha256(abi.encodePacked(signature[64:], bytes32(0)))\n        ));\n        bytes32 node = sha256(abi.encodePacked(\n            sha256(abi.encodePacked(pubkey_root, withdrawal_credentials)),\n            sha256(abi.encodePacked(amount, bytes24(0), signature_root))\n        ));\n\n        // Verify computed and expected deposit data roots match\n        require(node == deposit_data_root, \"DepositContract: reconstructed DepositData does not match supplied deposit_data_root\");\n\n        // Avoid overflowing the Merkle tree (and prevent edge case in computing `branch`)\n        require(deposit_count < MAX_DEPOSIT_COUNT, \"DepositContract: merkle tree full\");\n\n        // Add deposit data root to Merkle tree (update a single `branch` node)\n        deposit_count += 1;\n        uint size = deposit_count;\n        for (uint height = 0; height < DEPOSIT_CONTRACT_TREE_DEPTH; height++) {\n            if ((size & 1) == 1) {\n                branch[height] = node;\n                return;\n            }\n            node = sha256(abi.encodePacked(branch[height], node));\n            size /= 2;\n        }\n        // As the loop should always end prematurely with the `return` statement,\n        // this code should be unreachable. We assert `false` just to be safe.\n        assert(false);\n    }\n\n    function supportsInterface(bytes4 interfaceId) override external pure returns (bool) {\n        return interfaceId == type(ERC165).interfaceId || interfaceId == type(IDepositContract).interfaceId;\n    }\n\n    function to_little_endian_64(uint64 value) internal pure returns (bytes memory ret) {\n        ret = new bytes(8);\n        bytes8 bytesValue = bytes8(value);\n        // Byteswapping during copying to bytes.\n        ret[0] = bytesValue[7];\n        ret[1] = bytesValue[6];\n        ret[2] = bytesValue[5];\n        ret[3] = bytesValue[4];\n        ret[4] = bytesValue[3];\n        ret[5] = bytesValue[2];\n        ret[6] = bytesValue[1];\n        ret[7] = bytesValue[0];\n    }\n}\n// ----\n// constructor()\n// gas irOptimized: 809570\n// gas irOptimized code: 558000\n// gas legacy: 920228\n// gas legacy code: 1438800\n// gas legacyOptimized: 848699\n// gas legacyOptimized code: 878200\n// supportsInterface(bytes4): 0x0 -> 0\n// supportsInterface(bytes4): 0xffffffff00000000000000000000000000000000000000000000000000000000 -> false # defined to be false by ERC-165 #\n// supportsInterface(bytes4): 0x01ffc9a700000000000000000000000000000000000000000000000000000000 -> true # ERC-165 id #\n// supportsInterface(bytes4): 0x8564090700000000000000000000000000000000000000000000000000000000 -> true # the deposit interface id #\n// get_deposit_root() -> 0xd70a234731285c6804c2a4f56711ddb8c82c99740f207854891028af34e27e5e\n// gas irOptimized: 109178\n// gas legacy: 142741\n// gas legacyOptimized: 117558\n// get_deposit_count() -> 0x20, 8, 0 # TODO: check balance and logs after each deposit #\n// deposit(bytes,bytes,bytes,bytes32), 32 ether: 0 -> FAILURE # Empty input #\n// get_deposit_root() -> 0xd70a234731285c6804c2a4f56711ddb8c82c99740f207854891028af34e27e5e\n// gas irOptimized: 109178\n// gas legacy: 142741\n// gas legacyOptimized: 117558\n// get_deposit_count() -> 0x20, 8, 0\n// deposit(bytes,bytes,bytes,bytes32), 1 ether: 0x80, 0xe0, 0x120, 0xaa4a8d0b7d9077248630f1a4701ae9764e42271d7f22b7838778411857fd349e, 0x30, 0x933ad9491b62059dd065b560d256d8957a8c402cc6e8d8ee7290ae11e8f73292, 0x67a8811c397529dac52ae1342ba58c9500000000000000000000000000000000, 0x20, 0x00f50428677c60f997aadeab24aabf7fceaef491c96a52b463ae91f95611cf71, 0x60, 0xa29d01cc8c6296a8150e515b5995390ef841dc18948aa3e79be6d7c1851b4cbb, 0x5d6ff49fa70b9c782399506a22a85193151b9b691245cebafd2063012443c132, 0x4b6c36debaedefb7b2d71b0503ffdc00150aaffd42e63358238ec888901738b8 -> # txhash: 0x7085c586686d666e8bb6e9477a0f0b09565b2060a11f1c4209d3a52295033832 #\n// ~ emit DepositEvent(bytes,bytes,bytes,bytes,bytes): 0xa0, 0x0100, 0x0140, 0x0180, 0x0200, 0x30, 0x933ad9491b62059dd065b560d256d8957a8c402cc6e8d8ee7290ae11e8f73292, 0x67a8811c397529dac52ae1342ba58c9500000000000000000000000000000000, 0x20, 0xf50428677c60f997aadeab24aabf7fceaef491c96a52b463ae91f95611cf71, 0x08, 0xca9a3b00000000000000000000000000000000000000000000000000000000, 0x60, 0xa29d01cc8c6296a8150e515b5995390ef841dc18948aa3e79be6d7c1851b4cbb, 0x5d6ff49fa70b9c782399506a22a85193151b9b691245cebafd2063012443c132, 0x4b6c36debaedefb7b2d71b0503ffdc00150aaffd42e63358238ec888901738b8, 0x08, 0x00\n// get_deposit_root() -> 0x2089653123d9c721215120b6db6738ba273bbc5228ac093b1f983badcdc8a438\n// gas irOptimized: 109174\n// gas legacy: 142750\n// gas legacyOptimized: 117570\n// get_deposit_count() -> 0x20, 8, 0x0100000000000000000000000000000000000000000000000000000000000000\n// deposit(bytes,bytes,bytes,bytes32), 32 ether: 0x80, 0xe0, 0x120, 0xdbd986dc85ceb382708cf90a3500f500f0a393c5ece76963ac3ed72eccd2c301, 0x30, 0xb2ce0f79f90e7b3a113ca5783c65756f96c4b4673c2b5c1eb4efc22280259441, 0x06d601211e8866dc5b50dc48a244dd7c00000000000000000000000000000000, 0x20, 0x00344b6c73f71b11c56aba0d01b7d8ad83559f209d0a4101a515f6ad54c89771, 0x60, 0x945caaf82d18e78c033927d51f452ebcd76524497b91d7a11219cb3db6a1d369, 0x7595fc095ce489e46b2ef129591f2f6d079be4faaf345a02c5eb133c072e7c56, 0x0c6c3617eee66b4b878165c502357d49485326bc6b31bc96873f308c8f19c09d -> # txhash: 0x404d8e109822ce448e68f45216c12cb051b784d068fbe98317ab8e50c58304ac #\n// ~ emit DepositEvent(bytes,bytes,bytes,bytes,bytes): 0xa0, 0x0100, 0x0140, 0x0180, 0x0200, 0x30, 0xb2ce0f79f90e7b3a113ca5783c65756f96c4b4673c2b5c1eb4efc22280259441, 0x06d601211e8866dc5b50dc48a244dd7c00000000000000000000000000000000, 0x20, 0x344b6c73f71b11c56aba0d01b7d8ad83559f209d0a4101a515f6ad54c89771, 0x08, 0x40597307000000000000000000000000000000000000000000000000000000, 0x60, 0x945caaf82d18e78c033927d51f452ebcd76524497b91d7a11219cb3db6a1d369, 0x7595fc095ce489e46b2ef129591f2f6d079be4faaf345a02c5eb133c072e7c56, 0x0c6c3617eee66b4b878165c502357d49485326bc6b31bc96873f308c8f19c09d, 0x08, 0x0100000000000000000000000000000000000000000000000000000000000000\n// get_deposit_root() -> 0x40255975859377d912c53aa853245ebd939bdd2b33a28e084babdcc1ed8238ee\n// gas irOptimized: 109174\n// gas legacy: 142750\n// gas legacyOptimized: 117570\n// get_deposit_count() -> 0x20, 8, 0x0200000000000000000000000000000000000000000000000000000000000000\n"
        },
        "snark.sol": {
            "content": "library Pairing {\n\tstruct G1Point {\n\t\tuint X;\n\t\tuint Y;\n\t}\n\t// Encoding of field elements is: X[0] * z + X[1]\n\tstruct G2Point {\n\t\tuint[2] X;\n\t\tuint[2] Y;\n\t}\n\n\t/// @return the generator of G1\n\tfunction P1() internal returns (G1Point memory) {\n\t\treturn G1Point(1, 2);\n\t}\n\n\t/// @return the generator of G2\n\tfunction P2() internal returns (G2Point memory) {\n\t\treturn G2Point(\n\t\t\t[11559732032986387107991004021392285783925812861821192530917403151452391805634,\n\t\t\t 10857046999023057135944570762232829481370756359578518086990519993285655852781],\n\t\t\t[4082367875863433681332203403145435568316851327593401208105741076214120093531,\n\t\t\t 8495653923123431417604973247489272438418190587263600148770280649306958101930]\n\t\t);\n\t}\n\n\t/// @return the negation of p, i.e. p.add(p.negate()) should be zero.\n\tfunction negate(G1Point memory p) internal returns (G1Point memory) {\n\t\t// The prime q in the base field F_q for G1\n\t\tuint q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\t\tif (p.X == 0 && p.Y == 0)\n\t\t\treturn G1Point(0, 0);\n\t\treturn G1Point(p.X, q - (p.Y % q));\n\t}\n\n\t/// @return r the sum of two points of G1\n\tfunction add(G1Point memory p1, G1Point memory p2) internal returns (G1Point memory r) {\n\t\tuint[4] memory input;\n\t\tinput[0] = p1.X;\n\t\tinput[1] = p1.Y;\n\t\tinput[2] = p2.X;\n\t\tinput[3] = p2.Y;\n\t\tbool success;\n\t\tassembly {\n\t\t\tsuccess := call(sub(gas(), 2000), 6, 0, input, 0xc0, r, 0x60)\n\t\t\t// Use \"invalid\" to make gas estimation work\n\t\t\tswitch success case 0 { invalid() }\n\t\t}\n\t\trequire(success);\n\t}\n\n\t/// @return r the product of a point on G1 and a scalar, i.e.\n\t/// p == p.mul(1) and p.add(p) == p.mul(2) for all points p.\n\tfunction mul(G1Point memory p, uint s) internal returns (G1Point memory r) {\n\t\tuint[3] memory input;\n\t\tinput[0] = p.X;\n\t\tinput[1] = p.Y;\n\t\tinput[2] = s;\n\t\tbool success;\n\t\tassembly {\n\t\t\tsuccess := call(sub(gas(), 2000), 7, 0, input, 0x80, r, 0x60)\n\t\t\t// Use \"invalid\" to make gas estimation work\n\t\t\tswitch success case 0 { invalid() }\n\t\t}\n\t\trequire(success);\n\t}\n\n\t/// @return the result of computing the pairing check\n\t/// e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\n\t/// For example pairing([P1(), P1().negate()], [P2(), P2()]) should\n\t/// return true.\n\tfunction pairing(G1Point[] memory p1, G2Point[] memory p2) internal returns (bool) {\n\t\trequire(p1.length == p2.length);\n\t\tuint elements = p1.length;\n\t\tuint inputSize = p1.length * 6;\n\t\tuint[] memory input = new uint[](inputSize);\n\t\tfor (uint i = 0; i < elements; i++)\n\t\t{\n\t\t\tinput[i * 6 + 0] = p1[i].X;\n\t\t\tinput[i * 6 + 1] = p1[i].Y;\n\t\t\tinput[i * 6 + 2] = p2[i].X[0];\n\t\t\tinput[i * 6 + 3] = p2[i].X[1];\n\t\t\tinput[i * 6 + 4] = p2[i].Y[0];\n\t\t\tinput[i * 6 + 5] = p2[i].Y[1];\n\t\t}\n\t\tuint[1] memory out;\n\t\tbool success;\n\t\tassembly {\n\t\t\tsuccess := call(sub(gas(), 2000), 8, 0, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\n\t\t\t// Use \"invalid\" to make gas estimation work\n\t\t\tswitch success case 0 { invalid() }\n\t\t}\n\t\trequire(success);\n\t\treturn out[0] != 0;\n\t}\n\tfunction pairingProd2(G1Point memory a1, G2Point memory a2, G1Point memory b1, G2Point memory b2) internal returns (bool) {\n\t\tG1Point[] memory p1 = new G1Point[](2);\n\t\tG2Point[] memory p2 = new G2Point[](2);\n\t\tp1[0] = a1;\n\t\tp1[1] = b1;\n\t\tp2[0] = a2;\n\t\tp2[1] = b2;\n\t\treturn pairing(p1, p2);\n\t}\n\tfunction pairingProd3(\n\t\tG1Point memory a1, G2Point memory a2,\n\t\tG1Point memory b1, G2Point memory b2,\n\t\tG1Point memory c1, G2Point memory c2\n\t) internal returns (bool) {\n\t\tG1Point[] memory p1 = new G1Point[](3);\n\t\tG2Point[] memory p2 = new G2Point[](3);\n\t\tp1[0] = a1;\n\t\tp1[1] = b1;\n\t\tp1[2] = c1;\n\t\tp2[0] = a2;\n\t\tp2[1] = b2;\n\t\tp2[2] = c2;\n\t\treturn pairing(p1, p2);\n\t}\n\tfunction pairingProd4(\n\t\tG1Point memory a1, G2Point memory a2,\n\t\tG1Point memory b1, G2Point memory b2,\n\t\tG1Point memory c1, G2Point memory c2,\n\t\t\tG1Point memory d1, G2Point memory d2\n\t) internal returns (bool) {\n\t\tG1Point[] memory p1 = new G1Point[](4);\n\t\tG2Point[] memory p2 = new G2Point[](4);\n\t\tp1[0] = a1;\n\t\tp1[1] = b1;\n\t\tp1[2] = c1;\n\t\tp1[3] = d1;\n\t\tp2[0] = a2;\n\t\tp2[1] = b2;\n\t\tp2[2] = c2;\n\t\tp2[3] = d2;\n\t\treturn pairing(p1, p2);\n\t}\n}\n\ncontract Test {\n\tusing Pairing for *;\n\tstruct VerifyingKey {\n\t\tPairing.G2Point A;\n\t\tPairing.G1Point B;\n\t\tPairing.G2Point C;\n\t\tPairing.G2Point gamma;\n\t\tPairing.G1Point gammaBeta1;\n\t\tPairing.G2Point gammaBeta2;\n\t\tPairing.G2Point Z;\n\t\tPairing.G1Point[] IC;\n\t}\n\tstruct Proof {\n\t\tPairing.G1Point A;\n\t\tPairing.G1Point A_p;\n\t\tPairing.G2Point B;\n\t\tPairing.G1Point B_p;\n\t\tPairing.G1Point C;\n\t\tPairing.G1Point C_p;\n\t\tPairing.G1Point K;\n\t\tPairing.G1Point H;\n\t}\n\tfunction f() public returns (bool) {\n\t\tPairing.G1Point memory p1;\n\t\tPairing.G1Point memory p2;\n\t\tp1.X = 1; p1.Y = 2;\n\t\tp2.X = 1; p2.Y = 2;\n\t\tPairing.G1Point memory explicit_sum = Pairing.add(p1, p2);\n\t\tPairing.G1Point memory scalar_prod = Pairing.mul(p1, 2);\n\t\treturn (explicit_sum.X == scalar_prod.X &&\n\t\t\texplicit_sum.Y == scalar_prod.Y);\n\t}\n\tfunction g() public returns (bool) {\n\t\tPairing.G1Point memory x = Pairing.add(Pairing.P1(), Pairing.negate(Pairing.P1()));\n\t\t// should be zero\n\t\treturn (x.X == 0 && x.Y == 0);\n\t}\n\tfunction testMul() public returns (bool) {\n\t\tPairing.G1Point memory p;\n\t\t// @TODO The points here are reported to be not well-formed\n\t\tp.X = 14125296762497065001182820090155008161146766663259912659363835465243039841726;\n\t\tp.Y = 16229134936871442251132173501211935676986397196799085184804749187146857848057;\n\t\tp = Pairing.mul(p, 13986731495506593864492662381614386532349950841221768152838255933892789078521);\n\t\treturn\n\t\t\tp.X == 18256332256630856740336504687838346961237861778318632856900758565550522381207 &&\n\t\t\tp.Y == 6976682127058094634733239494758371323697222088503263230319702770853579280803;\n\t}\n\tfunction pair() public returns (bool) {\n\t\tPairing.G2Point memory fiveTimesP2 = Pairing.G2Point(\n\t\t\t[4540444681147253467785307942530223364530218361853237193970751657229138047649, 20954117799226682825035885491234530437475518021362091509513177301640194298072],\n\t\t\t[11631839690097995216017572651900167465857396346217730511548857041925508482915, 21508930868448350162258892668132814424284302804699005394342512102884055673846]\n\t\t);\n\t\t// The prime p in the base field F_p for G1\n\t\tuint p = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\t\tPairing.G1Point[] memory g1points = new Pairing.G1Point[](2);\n\t\tPairing.G2Point[] memory g2points = new Pairing.G2Point[](2);\n\t\t// check e(5 P1, P2)e(-P1, 5 P2) == 1\n\t\tg1points[0] = Pairing.P1().mul(5);\n\t\tg1points[1] = Pairing.P1().negate();\n\t\tg2points[0] = Pairing.P2();\n\t\tg2points[1] = fiveTimesP2;\n\t\tif (!Pairing.pairing(g1points, g2points))\n\t\t\treturn false;\n\t\t// check e(P1, P2)e(-P1, P2) == 1\n\t\tg1points[0] = Pairing.P1();\n\t\tg1points[1] = Pairing.P1();\n\t\tg1points[1].Y = p - g1points[1].Y;\n\t\tg2points[0] = Pairing.P2();\n\t\tg2points[1] = Pairing.P2();\n\t\tif (!Pairing.pairing(g1points, g2points))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\tfunction verifyingKey() internal returns (VerifyingKey memory vk) {\n\t\tvk.A = Pairing.G2Point([0x209dd15ebff5d46c4bd888e51a93cf99a7329636c63514396b4a452003a35bf7, 0x04bf11ca01483bfa8b34b43561848d28905960114c8ac04049af4b6315a41678], [0x2bb8324af6cfc93537a2ad1a445cfd0ca2a71acd7ac41fadbf933c2a51be344d, 0x120a2a4cf30c1bf9845f20c6fe39e07ea2cce61f0c9bb048165fe5e4de877550]);\n\t\tvk.B = Pairing.G1Point(0x2eca0c7238bf16e83e7a1e6c5d49540685ff51380f309842a98561558019fc02, 0x03d3260361bb8451de5ff5ecd17f010ff22f5c31cdf184e9020b06fa5997db84);\n\t\tvk.C = Pairing.G2Point([0x2e89718ad33c8bed92e210e81d1853435399a271913a6520736a4729cf0d51eb, 0x01a9e2ffa2e92599b68e44de5bcf354fa2642bd4f26b259daa6f7ce3ed57aeb3], [0x14a9a87b789a58af499b314e13c3d65bede56c07ea2d418d6874857b70763713, 0x178fb49a2d6cd347dc58973ff49613a20757d0fcc22079f9abd10c3baee24590]);\n\t\tvk.gamma = Pairing.G2Point([0x25f83c8b6ab9de74e7da488ef02645c5a16a6652c3c71a15dc37fe3a5dcb7cb1, 0x22acdedd6308e3bb230d226d16a105295f523a8a02bfc5e8bd2da135ac4c245d], [0x065bbad92e7c4e31bf3757f1fe7362a63fbfee50e7dc68da116e67d600d9bf68, 0x06d302580dc0661002994e7cd3a7f224e7ddc27802777486bf80f40e4ca3cfdb]);\n\t\tvk.gammaBeta1 = Pairing.G1Point(0x15794ab061441e51d01e94640b7e3084a07e02c78cf3103c542bc5b298669f21, 0x14db745c6780e9df549864cec19c2daf4531f6ec0c89cc1c7436cc4d8d300c6d);\n\t\tvk.gammaBeta2 = Pairing.G2Point([0x1f39e4e4afc4bc74790a4a028aff2c3d2538731fb755edefd8cb48d6ea589b5e, 0x283f150794b6736f670d6a1033f9b46c6f5204f50813eb85c8dc4b59db1c5d39], [0x140d97ee4d2b36d99bc49974d18ecca3e7ad51011956051b464d9e27d46cc25e, 0x0764bb98575bd466d32db7b15f582b2d5c452b36aa394b789366e5e3ca5aabd4]);\n\t\tvk.Z = Pairing.G2Point([0x217cee0a9ad79a4493b5253e2e4e3a39fc2df38419f230d341f60cb064a0ac29, 0x0a3d76f140db8418ba512272381446eb73958670f00cf46f1d9e64cba057b53c], [0x26f64a8ec70387a13e41430ed3ee4a7db2059cc5fc13c067194bcc0cb49a9855, 0x2fd72bd9edb657346127da132e5b82ab908f5816c826acb499e22f2412d1a2d7]);\n\t\tvk.IC = new Pairing.G1Point[](10);\n\t\tvk.IC[0] = Pairing.G1Point(0x0aee46a7ea6e80a3675026dfa84019deee2a2dedb1bbe11d7fe124cb3efb4b5a, 0x044747b6e9176e13ede3a4dfd0d33ccca6321b9acd23bf3683a60adc0366ebaf);\n\t\tvk.IC[1] = Pairing.G1Point(0x1e39e9f0f91fa7ff8047ffd90de08785777fe61c0e3434e728fce4cf35047ddc, 0x2e0b64d75ebfa86d7f8f8e08abbe2e7ae6e0a1c0b34d028f19fa56e9450527cb);\n\t\tvk.IC[2] = Pairing.G1Point(0x1c36e713d4d54e3a9644dffca1fc524be4868f66572516025a61ca542539d43f, 0x042dcc4525b82dfb242b09cb21909d5c22643dcdbe98c4d082cc2877e96b24db);\n\t\tvk.IC[3] = Pairing.G1Point(0x17d5d09b4146424bff7e6fb01487c477bbfcd0cdbbc92d5d6457aae0b6717cc5, 0x02b5636903efbf46db9235bbe74045d21c138897fda32e079040db1a16c1a7a1);\n\t\tvk.IC[4] = Pairing.G1Point(0x0f103f14a584d4203c27c26155b2c955f8dfa816980b24ba824e1972d6486a5d, 0x0c4165133b9f5be17c804203af781bcf168da7386620479f9b885ecbcd27b17b);\n\t\tvk.IC[5] = Pairing.G1Point(0x232063b584fb76c8d07995bee3a38fa7565405f3549c6a918ddaa90ab971e7f8, 0x2ac9b135a81d96425c92d02296322ad56ffb16299633233e4880f95aafa7fda7);\n\t\tvk.IC[6] = Pairing.G1Point(0x09b54f111d3b2d1b2fe1ae9669b3db3d7bf93b70f00647e65c849275de6dc7fe, 0x18b2e77c63a3e400d6d1f1fbc6e1a1167bbca603d34d03edea231eb0ab7b14b4);\n\t\tvk.IC[7] = Pairing.G1Point(0x0c54b42137b67cc268cbb53ac62b00ecead23984092b494a88befe58445a244a, 0x18e3723d37fae9262d58b548a0575f59d9c3266db7afb4d5739555837f6b8b3e);\n\t\tvk.IC[8] = Pairing.G1Point(0x0a6de0e2240aa253f46ce0da883b61976e3588146e01c9d8976548c145fe6e4a, 0x04fbaa3a4aed4bb77f30ebb07a3ec1c7d77a7f2edd75636babfeff97b1ea686e);\n\t\tvk.IC[9] = Pairing.G1Point(0x111e2e2a5f8828f80ddad08f9f74db56dac1cc16c1cb278036f79a84cf7a116f, 0x1d7d62e192b219b9808faa906c5ced871788f6339e8d91b83ac1343e20a16b30);\n\t}\n\tfunction verify(uint[] memory input, Proof memory proof) internal returns (uint) {\n\t\tVerifyingKey memory vk = verifyingKey();\n\t\trequire(input.length + 1 == vk.IC.length);\n\t\t// Compute the linear combination vk_x\n\t\tPairing.G1Point memory vk_x = Pairing.G1Point(0, 0);\n\t\tfor (uint i = 0; i < input.length; i++)\n\t\t\tvk_x = Pairing.add(vk_x, Pairing.mul(vk.IC[i + 1], input[i]));\n\t\tvk_x = Pairing.add(vk_x, vk.IC[0]);\n\t\tif (!Pairing.pairingProd2(proof.A, vk.A, Pairing.negate(proof.A_p), Pairing.P2())) return 1;\n\t\tif (!Pairing.pairingProd2(vk.B, proof.B, Pairing.negate(proof.B_p), Pairing.P2())) return 2;\n\t\tif (!Pairing.pairingProd2(proof.C, vk.C, Pairing.negate(proof.C_p), Pairing.P2())) return 3;\n\t\tif (!Pairing.pairingProd3(\n\t\t\tproof.K, vk.gamma,\n\t\t\tPairing.negate(Pairing.add(vk_x, Pairing.add(proof.A, proof.C))), vk.gammaBeta2,\n\t\t\tPairing.negate(vk.gammaBeta1), proof.B\n\t\t)) return 4;\n\t\tif (!Pairing.pairingProd3(\n\t\t\tPairing.add(vk_x, proof.A), proof.B,\n\t\t\tPairing.negate(proof.H), vk.Z,\n\t\t\tPairing.negate(proof.C), Pairing.P2()\n\t\t)) return 5;\n\t\treturn 0;\n\t}\n\tevent Verified(string);\n\tfunction verifyTx() public returns (bool) {\n\t\tuint[] memory input = new uint[](9);\n\t\tProof memory proof;\n\t\tproof.A = Pairing.G1Point(12873740738727497448187997291915224677121726020054032516825496230827252793177, 21804419174137094775122804775419507726154084057848719988004616848382402162497);\n\t\tproof.A_p = Pairing.G1Point(7742452358972543465462254569134860944739929848367563713587808717088650354556, 7324522103398787664095385319014038380128814213034709026832529060148225837366);\n\t\tproof.B = Pairing.G2Point(\n\t\t\t[8176651290984905087450403379100573157708110416512446269839297438960217797614, 15588556568726919713003060429893850972163943674590384915350025440408631945055],\n\t\t\t[15347511022514187557142999444367533883366476794364262773195059233657571533367, 4265071979090628150845437155927259896060451682253086069461962693761322642015]);\n\t\tproof.B_p = Pairing.G1Point(2979746655438963305714517285593753729335852012083057917022078236006592638393, 6470627481646078059765266161088786576504622012540639992486470834383274712950);\n\t\tproof.C = Pairing.G1Point(6851077925310461602867742977619883934042581405263014789956638244065803308498, 10336382210592135525880811046708757754106524561907815205241508542912494488506);\n\t\tproof.C_p = Pairing.G1Point(12491625890066296859584468664467427202390981822868257437245835716136010795448, 13818492518017455361318553880921248537817650587494176379915981090396574171686);\n\t\tproof.H = Pairing.G1Point(12091046215835229523641173286701717671667447745509192321596954139357866668225, 14446807589950902476683545679847436767890904443411534435294953056557941441758);\n\t\tproof.K = Pairing.G1Point(21341087976609916409401737322664290631992568431163400450267978471171152600502, 2942165230690572858696920423896381470344658299915828986338281196715687693170);\n\t\tinput[0] = 13986731495506593864492662381614386532349950841221768152838255933892789078521;\n\t\tinput[1] = 622860516154313070522697309645122400675542217310916019527100517240519630053;\n\t\tinput[2] = 11094488463398718754251685950409355128550342438297986977413505294941943071569;\n\t\tinput[3] = 6627643779954497813586310325594578844876646808666478625705401786271515864467;\n\t\tinput[4] = 2957286918163151606545409668133310005545945782087581890025685458369200827463;\n\t\tinput[5] = 1384290496819542862903939282897996566903332587607290986044945365745128311081;\n\t\tinput[6] = 5613571677741714971687805233468747950848449704454346829971683826953541367271;\n\t\tinput[7] = 9643208548031422463313148630985736896287522941726746581856185889848792022807;\n\t\tinput[8] = 18066496933330839731877828156604;\n\t\tif (verify(input, proof) == 0) {\n\t\t\temit Verified(\"Successfully verified.\");\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n}\n/// Disabled because the point seems to be not well-formed, we need to find another example.\n/// testMul() -> true\n//\n// ====\n// EVMVersion: >=constantinople\n// ----\n// library: Pairing\n// f() -> true\n// g() -> true\n// pair() -> true\n// gas irOptimized: 270409\n// gas legacy: 275219\n// gas legacyOptimized: 266862\n// verifyTx() -> true\n// ~ emit Verified(string): 0x20, 0x16, \"Successfully verified.\"\n// gas irOptimized: 785720\n// gas legacy: 801903\n// gas legacyOptimized: 770941\n"
        },
        "prbmath_signed.sol": {
            "content": "==== ExternalSource: _prbmath/PRBMathCommon.sol ====\n==== ExternalSource: _prbmath/PRBMathSD59x18.sol ====\n==== Source: prbmath.sol ====\nimport \"_prbmath/PRBMathSD59x18.sol\";\n\ncontract test {\n    using PRBMathSD59x18 for int256;\n\n    function div(int256 x, int256 y) external pure returns (int256 ret) {\n        ret = x.div(y);\n    }\n    function exp(int256 x) external pure returns (int256 ret) {\n        ret = x.exp();\n    }\n    function exp2(int256 x) external pure returns (int256 ret) {\n        ret = x.exp2();\n    }\n    function gm(int256 x, int256 y) external pure returns (int256 ret) {\n        ret = x.gm(y);\n    }\n    function log10(int256 x) external pure returns (int256 ret) {\n        ret = x.log10();\n    }\n    function log2(int256 x) external pure returns (int256 ret) {\n        ret = x.log2();\n    }\n    function mul(int256 x, int256 y) external pure returns (int256 ret) {\n        ret = x.mul(y);\n    }\n    function pow(int256 x, uint256 y) external pure returns (int256 ret) {\n        ret = x.pow(y);\n    }\n    function sqrt(int256 x) external pure returns (int256 ret) {\n        ret = x.sqrt();\n    }\n    function benchmark(int256 x) external pure returns (int256 ret, int256 z1, int256 z2) {\n        int256 y = x.mul(3).ceil();\n        int256 z = y.div(x);\n        for (uint i = 0; i < 10; i++)\n            z = z.sqrt();\n        ret = z;\n\n        // Check precision\n        z1 = z.ceil();\n        z2 = z.sqrt().pow(2).ceil();\n        assert(z1 == z2);\n    }\n}\n// ----\n// constructor()\n// gas irOptimized: 177903\n// gas irOptimized code: 1674400\n// gas legacy: 209723\n// gas legacy code: 2205000\n// gas legacyOptimized: 178012\n// gas legacyOptimized code: 1669600\n// div(int256,int256): 3141592653589793238, 88714123 -> 35412542528203691288251815328\n// gas irOptimized: 22137\n// gas legacy: 22767\n// gas legacyOptimized: 22282\n// exp(int256): 3141592653589793238 -> 23140692632779268978\n// gas irOptimized: 24545\n// gas legacy: 25203\n// gas legacyOptimized: 24357\n// exp2(int256): 3141592653589793238 -> 8824977827076287620\n// gas irOptimized: 24257\n// gas legacy: 24864\n// gas legacyOptimized: 24110\n// gm(int256,int256): 3141592653589793238, 88714123 -> 16694419339601\n// gas irOptimized: 22970\n// gas legacy: 23228\n// gas legacyOptimized: 22683\n// log10(int256): 3141592653589793238 -> 4971498726941338506\n// gas irOptimized: 30609\n// gas legacy: 32934\n// gas legacyOptimized: 30323\n// log2(int256): 3141592653589793238 -> 1651496129472318782\n// gas irOptimized: 28819\n// gas legacy: 31067\n// gas legacyOptimized: 28426\n// mul(int256,int256): 3141592653589793238, 88714123 -> 278703637\n// gas irOptimized: 22225\n// gas legacy: 22807\n// gas legacyOptimized: 22295\n// pow(int256,uint256): 3141592653589793238, 5 -> 306019684785281453040\n// gas irOptimized: 22635\n// gas legacy: 23508\n// gas legacyOptimized: 22921\n// sqrt(int256): 3141592653589793238 -> 1772453850905516027\n// gas irOptimized: 22650\n// gas legacy: 22802\n// gas legacyOptimized: 22422\n// benchmark(int256): 3141592653589793238 -> 998882724338592125, 1000000000000000000, 1000000000000000000\n// gas irOptimized: 36630\n// gas legacy: 36673\n// gas legacyOptimized: 34729\n"
        },
        "prbmath_unsigned.sol": {
            "content": "==== ExternalSource: _prbmath/PRBMathCommon.sol ====\n==== ExternalSource: _prbmath/PRBMathUD60x18.sol ====\n==== Source: prbmath.sol ====\nimport \"_prbmath/PRBMathUD60x18.sol\";\n\ncontract test {\n    using PRBMathUD60x18 for uint256;\n\n    function div(uint256 x, uint256 y) external pure returns (uint256 ret) {\n        ret = x.div(y);\n    }\n    function exp(uint256 x) external pure returns (uint256 ret) {\n        ret = x.exp();\n    }\n    function exp2(uint256 x) external pure returns (uint256 ret) {\n        ret = x.exp2();\n    }\n    function gm(uint256 x, uint256 y) external pure returns (uint256 ret) {\n        ret = x.gm(y);\n    }\n    function log10(uint256 x) external pure returns (uint256 ret) {\n        ret = x.log10();\n    }\n    function log2(uint256 x) external pure returns (uint256 ret) {\n        ret = x.log2();\n    }\n    function mul(uint256 x, uint256 y) external pure returns (uint256 ret) {\n        ret = x.mul(y);\n    }\n    function pow(uint256 x, uint256 y) external pure returns (uint256 ret) {\n        ret = x.pow(y);\n    }\n    function sqrt(uint256 x) external pure returns (uint256 ret) {\n        ret = x.sqrt();\n    }\n    function benchmark(uint256 x) external pure returns (uint256 ret, uint256 z1, uint256 z2) {\n        uint256 y = x.mul(3).ceil();\n        uint256 z = y.div(x);\n        for (uint i = 0; i < 10; i++)\n            z = z.sqrt();\n        ret = z;\n\n        // Check precision\n        z1 = z.ceil();\n        z2 = z.sqrt().pow(2).ceil();\n        assert(z1 == z2);\n    }\n}\n// ----\n// constructor()\n// gas irOptimized: 170626\n// gas irOptimized code: 1577400\n// gas legacy: 195206\n// gas legacy code: 1999000\n// gas legacyOptimized: 168857\n// gas legacyOptimized code: 1556200\n// div(uint256,uint256): 3141592653589793238, 88714123 -> 35412542528203691288251815328\n// gas irOptimized: 22004\n// gas legacy: 22497\n// gas legacyOptimized: 22010\n// exp(uint256): 3141592653589793238 -> 23140692632779268978\n// gas irOptimized: 24444\n// gas legacy: 25104\n// gas legacyOptimized: 24258\n// exp2(uint256): 3141592653589793238 -> 8824977827076287620\n// gas irOptimized: 24198\n// gas legacy: 24814\n// gas legacyOptimized: 24062\n// gm(uint256,uint256): 3141592653589793238, 88714123 -> 16694419339601\n// gas irOptimized: 22950\n// gas legacy: 23269\n// gas legacyOptimized: 22724\n// log10(uint256): 3141592653589793238 -> 0x44fe4fc084a52b8a\n// gas irOptimized: 30269\n// gas legacy: 32898\n// gas legacyOptimized: 29925\n// log2(uint256): 3141592653589793238 -> 1651496129472318782\n// gas irOptimized: 28235\n// gas legacy: 30986\n// gas legacyOptimized: 28001\n// mul(uint256,uint256): 3141592653589793238, 88714123 -> 278703637\n// gas irOptimized: 22048\n// gas legacy: 22604\n// gas legacyOptimized: 22090\n// pow(uint256,uint256): 3141592653589793238, 5 -> 306019684785281453040\n// gas irOptimized: 22406\n// gas legacy: 23245\n// gas legacyOptimized: 22646\n// sqrt(uint256): 3141592653589793238 -> 1772453850905516027\n// gas irOptimized: 22672\n// gas legacy: 22820\n// gas legacyOptimized: 22440\n// benchmark(uint256): 3141592653589793238 -> 998882724338592125, 1000000000000000000, 1000000000000000000\n// gas irOptimized: 35603\n// gas legacy: 35385\n// gas legacyOptimized: 33449\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "metadata",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ]
            }
        }
    }
}