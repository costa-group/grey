{
    "language": "Solidity",
    "sources": {
        "require_error_string_literal.sol": {
            "content": "error CustomError(string);\n\ncontract C\n{\n    function f() external pure\n    {\n        require(false, CustomError(\"errorReason\"));\n    }\n\n    function g() external pure\n    {\n        require(false, CustomError(\"anotherReason\"));\n    }\n}\n\n// ----\n// f() -> FAILURE, hex\"8d6ea8be\", hex\"0000000000000000000000000000000000000000000000000000000000000020\", hex\"000000000000000000000000000000000000000000000000000000000000000b\", hex\"6572726f72526561736f6e000000000000000000000000000000000000000000\"\n// g() -> FAILURE, hex\"8d6ea8be\", hex\"0000000000000000000000000000000000000000000000000000000000000020\", hex\"000000000000000000000000000000000000000000000000000000000000000d\", hex\"616e6f74686572526561736f6e00000000000000000000000000000000000000\"\n"
        },
        "require_error_multiple_arguments.sol": {
            "content": "error CustomError(uint256, string, uint256);\n\ncontract C\n{\n    function f() external pure\n    {\n        require(false, CustomError(1, \"two\", 3));\n    }\n\n    function g() external pure\n    {\n        require(false, CustomError(4, \"five\", 6));\n    }\n}\n\n// ----\n// f() -> FAILURE, hex\"11a1077e\", hex\"0000000000000000000000000000000000000000000000000000000000000001\", hex\"0000000000000000000000000000000000000000000000000000000000000060\", hex\"0000000000000000000000000000000000000000000000000000000000000003\", hex\"0000000000000000000000000000000000000000000000000000000000000003\", hex\"74776f0000000000000000000000000000000000000000000000000000000000\"\n// g() -> FAILURE, hex\"11a1077e\", hex\"0000000000000000000000000000000000000000000000000000000000000004\", hex\"0000000000000000000000000000000000000000000000000000000000000060\", hex\"0000000000000000000000000000000000000000000000000000000000000006\", hex\"0000000000000000000000000000000000000000000000000000000000000004\", hex\"6669766500000000000000000000000000000000000000000000000000000000\"\n"
        },
        "require_error_function_pointer_parameter.sol": {
            "content": "error CustomError(function(uint256) external pure returns (uint256));\n\ncontract C\n{\n    function e(uint256 x) external pure returns (uint256)\n    {\n        return x;\n    }\n\n    function f() external view\n    {\n        // more than one stack slot\n        require(false, CustomError(this.e));\n    }\n}\n\n// ----\n// f() -> FAILURE, hex\"271b1dfa\", hex\"c06afe3a8444fc0004668591e8306bfb9968e79ef37cdc8e0000000000000000\"\n"
        },
        "require_error_uint256.sol": {
            "content": "error CustomError(uint256);\n\ncontract C\n{\n    function f() external pure\n    {\n        require(false, CustomError(1));\n    }\n\n    function g() external pure\n    {\n        require(false, CustomError(2));\n    }\n}\n\n// ----\n// f() -> FAILURE, hex\"110b3655\", 1\n// g() -> FAILURE, hex\"110b3655\", 2\n"
        },
        "require_error_condition_evaluated_only_once.sol": {
            "content": "contract C {\n    uint256 counter = 0;\n\n    error CustomError(uint256);\n\n    function getCounter() public view returns (uint256) {\n        return counter;\n    }\n\n    function g(bool condition) internal returns (bool) {\n        counter++;\n        return condition;\n    }\n\n    function f(bool condition) external {\n        require(g(condition), CustomError(counter));\n    }\n}\n\n// ----\n// f(bool): false -> FAILURE, hex\"110b3655\", 1\n// getCounter() -> 0\n// f(bool): true ->\n// getCounter() -> 1\n"
        },
        "error_in_library_and_interface.sol": {
            "content": "error E(uint a);\nlibrary L {\n    error E(uint a, uint b);\n}\ninterface I {\n    error E(uint a, uint b, uint c);\n}\ncontract C {\n    function f() public pure {\n        revert E(1);\n    }\n    function g() public pure {\n        revert L.E(1, 2);\n    }\n    function h() public pure {\n        revert I.E(1, 2, 3);\n    }\n}\n// ----\n// f() -> FAILURE, hex\"002ff067\", hex\"0000000000000000000000000000000000000000000000000000000000000001\"\n// g() -> FAILURE, hex\"85208890\", hex\"0000000000000000000000000000000000000000000000000000000000000001\", hex\"0000000000000000000000000000000000000000000000000000000000000002\"\n// h() -> FAILURE, hex\"7924ea7c\", hex\"0000000000000000000000000000000000000000000000000000000000000001\", hex\"0000000000000000000000000000000000000000000000000000000000000002\", hex\"0000000000000000000000000000000000000000000000000000000000000003\"\n"
        },
        "error_static_calldata_uint_array_and_dynamic_array.sol": {
            "content": "contract C {\n    error E(uint[], uint[1]);\n\n    // This case used to be affected by the buggy cleanup due to ABIEncoderV2HeadOverflowWithStaticArrayCleanup bug.\n    function f(uint[] memory a, uint[1] calldata b) public {\n        revert E(a, b);\n    }\n}\n// ----\n// f(uint256[],uint256[1]): 0x40, 0xff, 1, 0xffff -> FAILURE, hex\"f42f106d\", 0x40, 0xff, 1, 0xffff\n"
        },
        "named_parameters_shadowing_types.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n    enum EnumType {A, B, C}\n\n    struct StructType {\n        uint x;\n    }\n\n    error E1(StructType StructType);\n    error E2(EnumType StructType, StructType EnumType);\n\n    function f() public {\n        revert E1({StructType: StructType(42)});\n    }\n\n    function g() public {\n        revert E2({EnumType: StructType(42), StructType: EnumType.B});\n    }\n}\n// ----\n// f() -> FAILURE, hex\"33a54193\", hex\"000000000000000000000000000000000000000000000000000000000000002a\"\n// g() -> FAILURE, hex\"374b9387\", hex\"0000000000000000000000000000000000000000000000000000000000000001\", hex\"000000000000000000000000000000000000000000000000000000000000002a\"\n"
        },
        "require_error_string_memory.sol": {
            "content": "error CustomError(string);\n\ncontract C\n{\n    function f() external pure\n    {\n        string memory reason = \"errorReason\";\n        require(false, CustomError(reason));\n    }\n\n    function g() external pure\n    {\n        string memory reason = \"anotherReason\";\n        require(false, CustomError(reason));\n    }\n}\n\n// ----\n// f() -> FAILURE, hex\"8d6ea8be\", hex\"0000000000000000000000000000000000000000000000000000000000000020\", hex\"000000000000000000000000000000000000000000000000000000000000000b\", hex\"6572726f72526561736f6e000000000000000000000000000000000000000000\"\n// g() -> FAILURE, hex\"8d6ea8be\", hex\"0000000000000000000000000000000000000000000000000000000000000020\", hex\"000000000000000000000000000000000000000000000000000000000000000d\", hex\"616e6f74686572526561736f6e00000000000000000000000000000000000000\"\n"
        },
        "require_inherited_error.sol": {
            "content": "contract Base\n{\n    error CustomError(uint256, string, uint256);\n}\n\ncontract C is Base\n{\n    function f() external pure\n    {\n        require(false, CustomError(1, \"two\", 3));\n    }\n}\n\n// ----\n// f() -> FAILURE, hex\"11a1077e\", hex\"0000000000000000000000000000000000000000000000000000000000000001\", hex\"0000000000000000000000000000000000000000000000000000000000000060\", hex\"0000000000000000000000000000000000000000000000000000000000000003\", hex\"0000000000000000000000000000000000000000000000000000000000000003\", hex\"74776f0000000000000000000000000000000000000000000000000000000000\"\n"
        },
        "require_different_errors_same_parameters.sol": {
            "content": "error AnError(uint256, string, uint256);\nerror AnotherError(uint256, string, uint256);\n\ncontract C\n{\n    function f() external pure\n    {\n        require(false, AnError(1, \"two\", 3));\n    }\n\n    function g() external pure\n    {\n        require(false, AnotherError(4, \"five\", 6));\n    }\n}\n\n// ----\n// f() -> FAILURE, hex\"f55fefe3\", hex\"0000000000000000000000000000000000000000000000000000000000000001\", hex\"0000000000000000000000000000000000000000000000000000000000000060\", hex\"0000000000000000000000000000000000000000000000000000000000000003\", hex\"0000000000000000000000000000000000000000000000000000000000000003\", hex\"74776f0000000000000000000000000000000000000000000000000000000000\"\n// g() -> FAILURE, hex\"44a06798\", hex\"0000000000000000000000000000000000000000000000000000000000000004\", hex\"0000000000000000000000000000000000000000000000000000000000000060\", hex\"0000000000000000000000000000000000000000000000000000000000000006\", hex\"0000000000000000000000000000000000000000000000000000000000000004\", hex\"6669766500000000000000000000000000000000000000000000000000000000\"\n"
        },
        "using_structs.sol": {
            "content": "pragma abicoder v2;\nstruct S { uint a; string b; }\nerror E(uint a, S s, uint b);\ncontract C {\n    S s;\n    function f(bool c) public {\n        if (c) {\n            s.a = 9;\n            s.b = \"abc\";\n            revert E(2, s, 7);\n        } else {\n            revert E({b: 7, a: 2, s: S({b: \"abc\", a: 9})});\n        }\n    }\n}\n// ----\n// f(bool): true -> FAILURE, hex\"e96e07f0\", hex\"0000000000000000000000000000000000000000000000000000000000000002\", hex\"0000000000000000000000000000000000000000000000000000000000000060\", hex\"0000000000000000000000000000000000000000000000000000000000000007\", hex\"0000000000000000000000000000000000000000000000000000000000000009\", hex\"0000000000000000000000000000000000000000000000000000000000000040\", hex\"0000000000000000000000000000000000000000000000000000000000000003\", hex\"6162630000000000000000000000000000000000000000000000000000000000\"\n// f(bool): false -> FAILURE, hex\"e96e07f0\", hex\"0000000000000000000000000000000000000000000000000000000000000002\", hex\"0000000000000000000000000000000000000000000000000000000000000060\", hex\"0000000000000000000000000000000000000000000000000000000000000007\", hex\"0000000000000000000000000000000000000000000000000000000000000009\", hex\"0000000000000000000000000000000000000000000000000000000000000040\", hex\"0000000000000000000000000000000000000000000000000000000000000003\", hex\"6162630000000000000000000000000000000000000000000000000000000000\"\n"
        },
        "via_contract_type.sol": {
            "content": "contract A {\n  error E(uint);\n}\ncontract X {\n  error E(string);\n}\ncontract B is A {\n  function f() public pure { revert E(1); }\n  function g() public pure  { revert A.E(1); }\n  function h() public pure { revert X.E(\"abc\"); }\n\n}\n// ----\n// f() -> FAILURE, hex\"002ff067\", hex\"0000000000000000000000000000000000000000000000000000000000000001\"\n// g() -> FAILURE, hex\"002ff067\", hex\"0000000000000000000000000000000000000000000000000000000000000001\"\n// h() -> FAILURE, hex\"3e9992c9\", hex\"0000000000000000000000000000000000000000000000000000000000000020\", hex\"0000000000000000000000000000000000000000000000000000000000000003\", hex\"6162630000000000000000000000000000000000000000000000000000000000\"\n"
        },
        "revert_conversion.sol": {
            "content": "error E(string a, uint[] b);\ncontract C {\n    uint[] x;\n    function f() public {\n        x.push(7);\n        revert E(\"abc\", x);\n    }\n}\n// ----\n// f() -> FAILURE, hex\"59e4d4df\", 0x40, 0x80, 3, \"abc\", 1, 7\n"
        },
        "errors_by_parameter_type.sol": {
            "content": "pragma abicoder v2;\n\nstruct S {\n    uint256 a;\n    bool b;\n    string s;\n}\n\nerror E();\nerror E1(uint256);\nerror E2(string);\nerror E3(S);\nerror E4(address);\nerror E5(function() external pure);\n\ncontract C {\n    function a() external pure {\n        require(false, E());\n    }\n    function b() external pure {\n        require(false, E1(1));\n    }\n    function c() external pure {\n        require(false, E2(\"string literal\"));\n    }\n    function d() external pure {\n        require(false, E3(S(1, true, \"string literal\")));\n    }\n    function e() external view {\n        require(false, E4(address(this)));\n    }\n    function f() external view {\n        require(false, E5(this.a));\n    }\n}\n\n// ====\n// compileViaYul: true\n// ----\n// a() -> FAILURE, hex\"92bbf6e8\"\n// b() -> FAILURE, hex\"47e26897\", hex\"0000000000000000000000000000000000000000000000000000000000000001\"\n// c() -> FAILURE, hex\"8f372c34\", hex\"0000000000000000000000000000000000000000000000000000000000000020\", hex\"000000000000000000000000000000000000000000000000000000000000000e\", hex\"737472696e67206c69746572616c000000000000000000000000000000000000\"\n// d() -> FAILURE, hex\"5717173e\", hex\"0000000000000000000000000000000000000000000000000000000000000020\", hex\"0000000000000000000000000000000000000000000000000000000000000001\", hex\"0000000000000000000000000000000000000000000000000000000000000001\", hex\"0000000000000000000000000000000000000000000000000000000000000060\", hex\"000000000000000000000000000000000000000000000000000000000000000e\", hex\"737472696e67206c69746572616c000000000000000000000000000000000000\"\n// e() -> FAILURE, hex\"7efef9ea\", hex\"000000000000000000000000c06afe3a8444fc0004668591e8306bfb9968e79e\"\n// f() -> FAILURE, hex\"0c3f12eb\", hex\"c06afe3a8444fc0004668591e8306bfb9968e79e0dbe671f0000000000000000\"\n"
        },
        "require_error_stack_check.sol": {
            "content": "// The purpose of this test is to make sure that error constructor call\n// stack items are popped from the stack in the success branch, i.e. when\n// require condition is true.\ncontract C {\n    error E(uint, uint, uint, function(uint256) external pure returns (uint256));\n    uint public x;\n\n    function e(uint256 y) external pure returns (uint256) {\n        return y;\n    }\n\n    function f(bool condition, uint a, uint b, uint c) public {\n        require(condition, E(a, b, c, this.e));\n        x = b;\n    }\n}\n// ----\n// f(bool,uint256,uint256,uint256): true, 42, 4242, 424242 ->\n// x() -> 4242\n"
        },
        "small_error_optimization.sol": {
            "content": "error E();\ncontract A {\n\tuint8[] x;\n\tfunction f() public {\n\t\tfor (uint i = 0; i < 100; ++i)\n\t\t\tx.push(uint8(i));\n\t\trevert E();\n\t}\n}\ncontract B {\n\tfunction f() public {\n\t\t(new A()).f();\n\t}\n}\n// ----\n// f() -> FAILURE, hex\"92bbf6e8\"\n// gas irOptimized: 221918\n// gas irOptimized code: 42800\n// gas legacy: 233752\n// gas legacy code: 38000\n// gas legacyOptimized: 224863\n// gas legacyOptimized code: 34200\n"
        },
        "error_selector.sol": {
            "content": "library L {\n    error E();\n}\nlibrary S {\n    error E(uint);\n}\nlibrary T {\n    error E();\n}\n\nerror E();\n\ninterface I {\n    error E();\n    function f() external pure;\n}\n\ncontract D {\n    error F();\n}\n\ncontract C is D {\n    function test1() public pure returns (bytes4, bytes4, bytes4, bytes4) {\n        assert(L.E.selector == T.E.selector);\n        assert(L.E.selector != S.E.selector);\n        assert(E.selector == L.E.selector);\n        assert(I.E.selector == L.E.selector);\n        return (L.E.selector, S.E.selector, E.selector, I.E.selector);\n    }\n\n    bytes4 s1 = L.E.selector;\n    bytes4 s2 = S.E.selector;\n    bytes4 s3 = T.E.selector;\n    bytes4 s4 = I.E.selector;\n    function test2() external returns (bytes4, bytes4, bytes4, bytes4) {\n        return (s1, s2, s3, s4);\n    }\n\n    function test3() external returns (bytes4) {\n        return (F.selector);\n    }\n}\n// ====\n// compileViaYul: also\n// ----\n// test1() -> 0x92bbf6e800000000000000000000000000000000000000000000000000000000, 0x2ff06700000000000000000000000000000000000000000000000000000000, 0x92bbf6e800000000000000000000000000000000000000000000000000000000, 0x92bbf6e800000000000000000000000000000000000000000000000000000000\n// test2() -> 0x92bbf6e800000000000000000000000000000000000000000000000000000000, 0x2ff06700000000000000000000000000000000000000000000000000000000, 0x92bbf6e800000000000000000000000000000000000000000000000000000000, 0x92bbf6e800000000000000000000000000000000000000000000000000000000\n// test3() -> 0x28811f5900000000000000000000000000000000000000000000000000000000\n"
        },
        "simple.sol": {
            "content": "error E(uint a, uint b);\ncontract C {\n    function f() public pure {\n        revert E(2, 7);\n    }\n}\n// ----\n// f() -> FAILURE, hex\"85208890\", 2, 7\n"
        },
        "panic_via_import.sol": {
            "content": "==== Source: s1.sol ====\nerror E(uint);\n==== Source: s2.sol ====\nimport { E as Panic } from \"s1.sol\";\ncontract C {\n    error E(uint);\n    function a() public pure {\n        revert Panic(1);\n    }\n    function b() public pure {\n        revert E(1);\n    }\n}\n// ----\n// a() -> FAILURE, hex\"002ff067\", hex\"0000000000000000000000000000000000000000000000000000000000000001\"\n// b() -> FAILURE, hex\"002ff067\", hex\"0000000000000000000000000000000000000000000000000000000000000001\"\n"
        },
        "require_error_evaluation_order_3.sol": {
            "content": "contract C {\n    string failureMessage = \"Failure Message\";\n    function g(bool x) internal returns (bool) {\n        failureMessage = \"Intercepted failure message\";\n        return x;\n    }\n    function h() internal returns (string memory) { return failureMessage; }\n    function f(bool c) public {\n        require(g(c), h());\n    }\n}\n\n// ----\n// f(bool): false -> FAILURE, hex\"08c379a0\", 0x20, 0x1b, \"Intercepted failure message\"\n// f(bool): true ->\n"
        },
        "require_error_evaluation_order_2.sol": {
            "content": "contract C {\n    uint y;\n    function g(bool x) internal returns (bool) {\n        y = 42;\n        return x;\n    }\n    error E(uint256);\n    function h() internal returns (uint256) { return y; }\n    function f(bool c) public {\n        require(g(c), E(h()));\n    }\n}\n\n// ----\n// f(bool): false -> FAILURE, hex\"002ff067\", 42\n// f(bool): true ->\n"
        },
        "weird_name.sol": {
            "content": "error error(uint a);\ncontract C {\n    function f() public pure {\n        revert error(2);\n    }\n}\n// ----\n// f() -> FAILURE, hex\"b48fb6cf\", hex\"0000000000000000000000000000000000000000000000000000000000000002\"\n"
        },
        "require_error_evaluation_order_1.sol": {
            "content": "contract C\n{\n    error E(uint);\n\n    function r() internal returns (uint)\n    {\n        assembly { mstore(0, 7) return (0, 32) }\n        return 42;\n    }\n\n    function f() public returns (uint)\n    {\n        require(false, E(r()));\n        return 42;\n    }\n\n    function g() public returns (uint)\n    {\n        require(true, E(r()));\n        return 42;\n    }\n}\n\n// ----\n// f() -> 7\n// g() -> 7\n"
        },
        "require_error_function_join_control_flow.sol": {
            "content": "contract C {\n    uint x = 0;\n    uint y = 42;\n    error E(uint);\n    function f(bool c) public returns (uint256, uint256, uint256) {\n        uint z = x;\n        if (y == 42) {\n            x = 21;\n        } else {\n            require(c, E(y));\n        }\n        y /= 2;\n        return (x,y,z);\n    }\n}\n// ----\n// f(bool): true -> 0x15, 0x15, 0\n// f(bool): false -> FAILURE, hex\"002ff067\", 21\n"
        },
        "via_import.sol": {
            "content": "==== Source: s1.sol ====\nerror E(uint);\n==== Source: s2.sol ====\nimport \"s1.sol\" as S;\n==== Source: s3.sol ====\nimport \"s1.sol\" as S;\nimport \"s2.sol\" as T;\nimport \"s1.sol\";\ncontract C {\n  function x() public pure {\n    revert E(1);\n  }\n  function y() public pure {\n    revert S.E(2);\n  }\n  function z() public pure {\n    revert T.S.E(3);\n  }\n}\n// ----\n// x() -> FAILURE, hex\"002ff067\", hex\"0000000000000000000000000000000000000000000000000000000000000001\"\n// y() -> FAILURE, hex\"002ff067\", hex\"0000000000000000000000000000000000000000000000000000000000000002\"\n// z() -> FAILURE, hex\"002ff067\", hex\"0000000000000000000000000000000000000000000000000000000000000003\"\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "metadata",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ]
            }
        }
    }
}