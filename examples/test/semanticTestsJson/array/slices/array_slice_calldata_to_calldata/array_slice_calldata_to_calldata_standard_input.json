{
    "language": "Solidity",
    "sources": {
        "array_slice_calldata_to_memory.sol": {
            "content": "contract C {\n    function f(int[] calldata b, uint256 start, uint256 end) public returns (int) {\n        int[] memory m = b[start:end];\n        uint len = end - start;\n        assert(len == m.length);\n        for (uint i = 0; i < len; i++) {\n            assert(b[start:end][i] == m[i]);\n        }\n        return [b[start:end]][0][0];\n    }\n\n    function g(int[] calldata b, uint256 start, uint256 end) public returns (int[] memory) {\n        return b[start:end];\n    }\n\n    function h1(int[] memory b) internal returns (int[] memory) {\n        return b;\n    }\n\n    function h(int[] calldata b, uint256 start, uint256 end) public returns (int[] memory) {\n        return h1(b[start:end]);\n    }\n}\n// ----\n// f(int256[],uint256,uint256): 0x60, 1, 3, 4, 1, 2, 3, 4 -> 2\n// g(int256[],uint256,uint256): 0x60, 1, 3, 4, 1, 2, 3, 4 -> 0x20, 2, 2, 3\n// h(int256[],uint256,uint256): 0x60, 1, 3, 4, 1, 2, 3, 4 -> 0x20, 2, 2, 3\n"
        },
        "array_slice_calldata_to_storage.sol": {
            "content": "contract C {\n    int[] s;\n    function f(int[] calldata b, uint256 start, uint256 end) public returns (int) {\n        s = b[start:end];\n        uint len = end - start;\n        assert(len == s.length);\n        for (uint i = 0; i < len; i++) {\n            assert(b[start:end][i] == s[i]);\n        }\n        return s[0];\n    }\n}\n// ----\n// f(int256[],uint256,uint256): 0x60, 1, 3, 4, 1, 2, 3, 4 -> 2\n"
        },
        "array_calldata_assignment.sol": {
            "content": "contract C {\n    function f(uint256[] calldata x, uint256[] calldata y, uint256 i) external returns (uint256) {\n        x = y;\n        return x[i];\n    }\n}\n// ----\n// f(uint256[],uint256[],uint256): 0x60, 0xA0, 1, 1, 0, 2, 1, 2 -> 2\n"
        },
        "array_slice_calldata_as_argument_of_external_calls.sol": {
            "content": "contract C {\n    function f1(bytes calldata c1, uint256 s, uint256 e, bytes calldata c2) public returns (bool) {\n        return keccak256(c1[s:e]) == keccak256(c2);\n    }\n\n    function f2(bytes calldata c, uint256 s) public returns (uint256, bytes memory) {\n        return abi.decode(c[s:], (uint256, bytes));\n    }\n\n    function f3(bytes calldata c1, uint256 s, uint256 e, bytes calldata c2) public returns (bool) {\n        bytes memory a = abi.encode(c1[s:e]);\n        bytes memory b = abi.encode(c2);\n        if (a.length != b.length) { return false; }\n        for (uint256 i = 0; i < a.length; i++) {\n            if (a[i] != b[i]) { return false; }\n        }\n        return true;\n    }\n\n    function f4(bytes calldata c1, uint256 s, uint256 e, bytes calldata c2) public returns (bool) {\n        bytes memory a = abi.encodePacked(c1[s:e]);\n        bytes memory b = abi.encodePacked(c2);\n        if (a.length != b.length) { return false; }\n        for (uint256 i = 0; i < a.length; i++) {\n            if (a[i] != b[i]) { return false; }\n        }\n        return true;\n    }\n}\n// ----\n// f1(bytes,uint256,uint256,bytes): 0x80, 1, 5, 0xC0, 8, \"abcdefgh\", 4, \"bcde\" -> true\n// f1(bytes,uint256,uint256,bytes): 0x80, 1, 5, 0xC0, 8, \"abcdefgh\", 4, \"bcdf\" -> false\n// f2(bytes,uint256): 0x40, 0, 0x80, 0x21, 0x40, 0x7, \"abcdefg\" -> 0x21, 0x40, 0x7, \"abcdefg\"\n// f3(bytes,uint256,uint256,bytes): 0x80, 1, 5, 0xC0, 8, \"abcdefgh\", 4, \"bcde\" -> true\n// f3(bytes,uint256,uint256,bytes): 0x80, 1, 5, 0xC0, 8, \"abcdefgh\", 4, \"bcdf\" -> false\n// f4(bytes,uint256,uint256,bytes): 0x80, 1, 5, 0xC0, 8, \"abcdefgh\", 4, \"bcde\" -> true\n// f4(bytes,uint256,uint256,bytes): 0x80, 1, 5, 0xC0, 8, \"abcdefgh\", 4, \"bcdf\" -> false\n"
        },
        "array_slice_calldata_to_calldata.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n    struct S {\n        uint128 p1;\n        uint256[3] a;\n        uint32 p2;\n    }\n    function f(S[] calldata c) internal returns (S[] memory) {\n        return c;\n    }\n    function g(S[] calldata c, uint256 s, uint256 e) public returns (S[] memory) {\n        return f(c[s:e]);\n    }\n\n    function f1(uint256[3][] calldata c) internal returns (uint256[3][] memory) {\n        return c;\n    }\n    function g1(uint256[3][] calldata c, uint256 s, uint256 e) public returns (uint256[3][] memory) {\n        return f1(c[s:e]);\n    }\n}\n// ----\n// g((uint128,uint256[3],uint32)[],uint256,uint256): 0x60, 1, 3, 4, 55, 1, 2, 3, 66, 66, 2, 3, 4, 77, 77, 3, 4, 5, 88, 88, 4, 5, 6, 99 -> 0x20, 2, 66, 2, 3, 4, 77, 77, 3, 4, 5, 88\n// g1(uint256[3][],uint256,uint256): 0x60, 1, 3, 4, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 -> 0x20, 2, 4, 5, 6, 7, 8, 9\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "metadata",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ]
            }
        }
    }
}