{
    "language": "Solidity",
    "sources": {
        "array_copy_cleanup_uint128.sol": {
            "content": "// Test to see if cleanup is performed properly during array copying\ncontract C {\n    uint128[] x;\n    function f() public returns(bool) {\n        x.push(42); x.push(42); x.push(42); x.push(42);\n        uint128[] memory y = new uint128[](1);\n        y[0] = 23;\n        x = y;\n        assembly { sstore(x.slot, 4) }\n\n        assert(x[0] == 23);\n        assert(x[1] == 0);\n\n        assert(x[2] == 0);\n        // Issue 9832: the cleanup was only performed for the first packed type leaving the rest of\n        // the slot dirty.\n        assert(x[3] == 0);\n\n        return true;\n    }\n}\n// ----\n// f() -> true\n// gas irOptimized: 92740\n// gas legacy: 93035\n// gas legacyOptimized: 92257\n"
        },
        "array_of_function_external_storage_to_storage_dynamic.sol": {
            "content": "contract C {\n    function testFunction1() public {}\n    function testFunction2() public {}\n    function testFunction3() public {}\n\n\n    function() external [] externalArray0;\n    function() external [] externalArray1;\n\n    function() internal [] internalArray0;\n    function() internal [] internalArray1;\n\n    constructor() {\n        externalArray0 = new function() external[] (3);\n        externalArray1 = [\n            this.testFunction1,\n            this.testFunction2,\n            this.testFunction3\n        ];\n\n        internalArray0 = new function() internal[] (3);\n        internalArray1 = [\n            testFunction1,\n            testFunction2,\n            testFunction3\n        ];\n    }\n\n    function copyExternalStorageArrayOfFunctionType() external returns (bool) {\n        assert(keccak256(abi.encode(externalArray0)) != keccak256(abi.encode(externalArray1)));\n        externalArray0 = externalArray1;\n        return keccak256(abi.encode(externalArray0)) == keccak256(abi.encode(externalArray1));\n    }\n\n    function copyInternalArrayOfFunctionType() external returns (bool) {\n        internalArray0 = internalArray1;\n        assert(internalArray0.length == 3);\n\n        return\n            internalArray0.length == internalArray1.length &&\n            internalArray0[0] == internalArray1[0] &&\n            internalArray0[1] == internalArray1[1] &&\n            internalArray0[2] == internalArray1[2];\n    }\n}\n// ----\n// copyExternalStorageArrayOfFunctionType() -> true\n// gas irOptimized: 104566\n// gas legacy: 108554\n// gas legacyOptimized: 102405\n// copyInternalArrayOfFunctionType() -> true\n"
        },
        "nested_array_element_calldata_to_memory.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n    function test1(uint8[][][] calldata _a) public returns (uint8[][] memory) {\n        return _a[1];\n    }\n\n    function test2(uint8[][1][] calldata _a) public returns (uint8[][1] memory) {\n        return _a[0];\n    }\n\n    function test3(uint8[2][][2] calldata _a) public returns (uint8[2][] memory) {\n        return _a[0];\n    }\n\n    function test4(uint16[][] calldata _a) public returns (uint16[][] memory) {\n        uint16[][][] memory tmp = new uint16[][][](2);\n        tmp[1] = _a;\n        return tmp[1];\n    }\n\n    function test5(uint32[][2] calldata _a) public returns (uint32[][2] memory) {\n        uint32[][2][] memory tmp = new uint32[][2][](1);\n        tmp[0] = _a;\n        return tmp[0];\n    }\n\n    function test6(uint32[2][] calldata _a) public returns (uint32[2][] memory) {\n        uint32[2][][] memory tmp = new uint32[2][][](1);\n        tmp[0] = _a;\n        return tmp[0];\n    }\n}\n// ----\n// test1(uint8[][][]): 0x20, 2, 0x40, 0x60, 0, 2, 0x40, 0x80, 1, 7, 2, 8, 9 -> 0x20, 2, 0x40, 0x80, 1, 7, 2, 8, 9\n// test2(uint8[][1][]): 0x20, 2, 0x40, 0xe0, 0x20, 3, 12, 13, 14, 0x20, 3, 15, 16, 17 -> 0x20, 0x20, 3, 12, 13, 14\n// test3(uint8[2][][2]): 0x20, 0x40, 0xa0, 1, 7, 7, 2, 8, 8, 0x09, 9 -> 0x20, 1, 7, 7\n// test4(uint16[][]): 0x20, 2, 0x40, 0x80, 1, 7, 2, 8, 9 -> 0x20, 2, 0x40, 0x80, 1, 7, 2, 8, 9\n// test5(uint32[][2]): 0x20, 0x40, 0x80, 1, 7, 2, 8, 9 -> 0x20, 0x40, 0x80, 1, 7, 2, 8, 9\n// test6(uint32[2][]): 0x20, 2, 5, 6, 7, 8 -> 0x20, 2, 5, 6, 7, 8\n"
        },
        "calldata_array_of_struct_to_memory.sol": {
            "content": "pragma abicoder               v2;\n\n\ncontract C {\n    struct S {\n        uint256 a;\n        uint256 b;\n    }\n\n    function f(S[] calldata s)\n        external\n        pure\n        returns (uint256 l, uint256 a, uint256 b, uint256 c, uint256 d)\n    {\n        S[] memory m = s;\n        l = m.length;\n        a = m[0].a;\n        b = m[0].b;\n        c = m[1].a;\n        d = m[1].b;\n    }\n}\n// ----\n// f((uint256,uint256)[]): 0x20, 0x2, 0x1, 0x2, 0x3, 0x4 -> 2, 1, 2, 3, 4\n"
        },
        "calldata_2d_bytes_to_memory_2.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n    function g(bytes[2] memory m) internal {\n        assert(m[0].length > 1);\n        assert(m[1].length > 1);\n        assert(m[0][0] == m[1][0]);\n        assert(m[0][1] == m[1][1]);\n    }\n    function f(bytes[2] calldata c) external {\n        g(c);\n    }\n}\n// ----\n// f(bytes[2]): 0x20, 0x40, 0x40, 2, \"ab\" ->\n// f(bytes[2]): 0x20, 0x40, 0x40, 1, \"a\" -> FAILURE, hex\"4e487b71\", 0x01\n"
        },
        "memory_dyn_2d_bytes_to_storage.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n    bytes[] s;\n    function f() external returns (uint256) {\n        bytes[] memory m = new bytes[](3);\n        m[0] = \"ab\"; m[1] = \"cde\"; m[2] = \"fghij\";\n        s = m;\n        assert(s.length == m.length);\n        for (uint i = 0; i < s.length; ++i) {\n            assert(s[i].length == m[i].length);\n            for (uint j = 0; j < s[i].length; ++j) {\n                 assert(s[i][j] == m[i][j]);\n            }\n        }\n        return s.length;\n    }\n}\n// ----\n// f() -> 3\n// gas irOptimized: 128296\n// gas legacy: 129077\n// gas legacyOptimized: 128210\n"
        },
        "array_copy_storage_abi_signed.sol": {
            "content": "// NOTE: This does not really test copying from storage to ABI directly,\n// because it will always copy to memory first.\ncontract c {\n    int16[] x;\n\n    function test() public returns (int16[] memory) {\n        x.push(int16(-1));\n        x.push(int16(-1));\n        x.push(int16(8));\n        x.push(int16(-16));\n        x.push(int16(-2));\n        x.push(int16(6));\n        x.push(int16(8));\n        x.push(int16(-1));\n        return x;\n    }\n}\n// ----\n// test() -> 0x20, 0x8, -1, -1, 8, -16, -2, 6, 8, -1\n"
        },
        "storage_memory_nested_from_pointer.sol": {
            "content": "contract C {\n    uint72[5][] a;\n\n    function f() public returns (uint72, uint72, uint72, uint72, uint72, uint72, uint72) {\n        for (uint i = 0; i < 4; i++)\n            a.push();\n        a[0][0] = 1;\n        a[0][3] = 2;\n        a[1][1] = 3;\n        a[1][4] = 4;\n        a[2][0] = 5;\n        a[3][2] = 6;\n        a[3][3] = 7;\n        uint72[5][] storage a_ = a;\n        uint72[5][] memory m = a_;\n        return (m[0][0], m[0][3], m[1][1], m[1][4], m[2][0], m[3][2], m[3][3]);\n    }\n}\n// ----\n// f() -> 1, 2, 3, 4, 5, 6, 7\n// gas irOptimized: 206440\n// gas legacy: 211770\n// gas legacyOptimized: 211191\n"
        },
        "array_copy_target_leftover.sol": {
            "content": "contract c {\n    bytes1[10] data1;\n    bytes2[32] data2;\n    function test() public returns (uint check, uint res1, uint res2) {\n        uint i;\n        for (i = 0; i < data2.length; ++i)\n            data2[i] = 0xffff;\n        check = uint(uint16(data2[31])) * 0x10000 | uint(uint16(data2[14]));\n        for (i = 0; i < data1.length; ++i)\n            data1[i] = bytes1(uint8(1 + i));\n        data2 = data1;\n        for (i = 0; i < 16; ++i)\n            res1 |= uint(uint16(data2[i])) * 0x10000**i;\n        for (i = 0; i < 16; ++i)\n            res2 |= uint(uint16(data2[16 + i])) * 0x10000**i;\n    }\n}\n// ----\n// test() -> 0xffffffff, 0x0000000000000000000000000a00090008000700060005000400030002000100, 0x0000000000000000000000000000000000000000000000000000000000000000\n// gas irOptimized: 100496\n// gas legacy: 158109\n// gas legacyOptimized: 141019\n"
        },
        "array_copy_including_array.sol": {
            "content": "contract c {\n    uint[3][90][] large;\n    uint[3][3][] small;\n    function test() public returns (uint r) {\n        for (uint i = 0; i < 7; i++) {\n            large.push();\n            small.push();\n        }\n        large[3][2][0] = 2;\n        large[1] = large[3];\n        small[3][2][0] = 2;\n        small[1] = small[2];\n        r = ((\n            small[3][2][0] * 0x100 |\n            small[1][2][0]) * 0x100 |\n            large[3][2][0]) * 0x100 |\n            large[1][2][0];\n        delete small;\n        delete large;\n\n    }\n    function clear() public returns (uint, uint) {\n        for (uint i = 0; i < 7; i++) {\n            large.push();\n            small.push();\n        }\n        small[3][2][0] = 0;\n        large[3][2][0] = 0;\n        while (small.length > 0)\n            small.pop();\n        while (large.length > 0)\n            large.pop();\n        return (small.length, large.length);\n    }\n}\n// ----\n// test() -> 0x02000202\n// gas irOptimized: 4549676\n// gas legacy: 4475394\n// gas legacyOptimized: 4447665\n// storageEmpty -> 1\n// clear() -> 0, 0\n// gas irOptimized: 4478184\n// gas legacy: 4407185\n// gas legacyOptimized: 4381337\n// storageEmpty -> 1\n"
        },
        "array_nested_storage_to_memory.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n    uint256[][] a1;\n    uint256[][2] a2;\n    uint256[2][] a3;\n    uint256[2][2] a4;\n\n    constructor() {\n        a1 = new uint256[][](2);\n        a1[0] = [1, 2];\n        a1[1] = [3, 4, 5];\n\n        a2[0] = [6, 7, 8];\n        a2[1] = [9];\n\n        a3.push([1, 2]);\n        a3.push([3, 4]);\n        a3.push([5, 6]);\n\n        a4 = [[10, 11], [12, 13]];\n    }\n\n    function test1() external returns (uint256[][] memory) {\n        return a1;\n    }\n\n    function test2() external returns (uint256[][2] memory) {\n        return a2;\n    }\n\n    function test3() external returns (uint256[2][] memory) {\n        return a3;\n    }\n\n    function test4() external returns (uint256[2][2] memory) {\n        return a4;\n    }\n}\n// ----\n// test1() -> 0x20, 2, 0x40, 0xa0, 2, 1, 2, 3, 3, 4, 5\n// test2() -> 0x20, 0x40, 0xc0, 3, 6, 7, 8, 1, 9\n// test3() -> 0x20, 3, 1, 2, 3, 4, 5, 6\n// test4() -> 10, 11, 12, 13\n"
        },
        "nested_array_element_storage_to_storage.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n    uint8[][][] src1 = new uint8[][][](2);\n    uint8[][][2] src2;\n    uint8[][2][] src3 = new uint8[][2][](1);\n    uint8[2][][] src4 = new uint8[2][][](2);\n\n    uint8[][] dst1;\n    uint8[][] dst2;\n    uint8[][2] dst3;\n    uint8[][] dst4;\n\n    constructor() {\n        src1[1] = new uint8[][](2);\n        src1[1][0] = [3, 4];\n        src1[1][1] = [5, 6];\n\n        src2[0] = new uint8[][](2);\n        src2[0][0] = [6, 7];\n        src2[0][1] = [8, 9];\n        src2[1] = new uint8[][](2);\n        src2[1][0] = [10, 11];\n\n        src3[0][0] = [3, 4];\n        src3[0][1] = [5, 6];\n\n        src4[0] = new uint8[2][](1);\n        src4[0][0] = [17, 23];\n        src4[1] = new uint8[2][](1);\n        src4[1][0] = [19, 31];\n    }\n\n    function test1() public {\n        dst1 = src1[1];\n\n        require(dst1.length == 2);\n        require(dst1[0][0] == src1[1][0][0]);\n        require(dst1[0][1] == src1[1][0][1]);\n        require(dst1[1][0] == src1[1][1][0]);\n        require(dst1[1][1] == src1[1][1][1]);\n    }\n\n    function test2() public {\n        dst2 = src2[0];\n\n        require(dst2.length == 2);\n        require(dst2[0][0] == src2[1][0][0]);\n        require(dst2[0][1] == src2[1][0][1]);\n        require(dst2[1][0] == src2[1][1][0]);\n        require(dst2[1][1] == src2[1][1][1]);\n    }\n\n    function test3() public {\n        dst3 = src3[0];\n        require(dst3[0][0] == src3[0][0][0]);\n        require(dst3[0][1] == src3[0][0][1]);\n        require(dst3[1][0] == src3[0][1][0]);\n        require(dst3[1][1] == src3[0][1][1]);\n    }\n\n    function test4() public {\n        dst4 = src4[1];\n        require(dst4.length == 2);\n        require(dst4[0][0] == src4[0][0][0]);\n        require(dst4[0][1] == src4[0][0][1]);\n        require(dst4[1][0] == src4[0][1][0]);\n        require(dst4[1][1] == src4[0][1][1]);\n    }\n}\n// ----\n// test1() ->\n// gas irOptimized: 150488\n// gas legacy: 150949\n// gas legacyOptimized: 150906\n// test2() -> FAILURE\n// gas irOptimized: 150389\n// gas legacy: 150672\n// gas legacyOptimized: 150575\n// test3() ->\n// gas irOptimized: 124300\n// gas legacy: 125333\n// gas legacyOptimized: 125127\n// test4() -> FAILURE\n"
        },
        "bytes_storage_to_storage.sol": {
            "content": "contract c {\n    bytes a;\n    bytes b;\n    function f(uint len) public returns (bytes memory) {\n        bytes memory x = new bytes(len);\n        for (uint i = 0; i < len; i++)\n            x[i] = bytes1(uint8(i));\n        a = x;\n        for (uint i = 0; i < len; i++)\n            assert(a[i] == x[i]);\n        b = a;\n        for (uint i = 0; i < len; i++)\n            assert(b[i] == x[i]);\n        return b;\n    }\n}\n// ----\n// f(uint256): 0 -> 0x20, 0x00\n// f(uint256): 31 -> 0x20, 0x1f, 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e00\n// gas irOptimized: 103268\n// gas legacy: 112904\n// gas legacyOptimized: 112647\n// f(uint256): 32 -> 0x20, 0x20, 1780731860627700044960722568376592200742329637303199754547598369979440671\n// gas irOptimized: 117825\n// gas legacy: 128964\n// gas legacyOptimized: 128854\n// f(uint256): 33 -> 0x20, 33, 1780731860627700044960722568376592200742329637303199754547598369979440671, 0x2000000000000000000000000000000000000000000000000000000000000000\n// gas irOptimized: 124091\n// gas legacy: 136092\n// gas legacyOptimized: 135469\n// f(uint256): 63 -> 0x20, 0x3f, 1780731860627700044960722568376592200742329637303199754547598369979440671, 14532552714582660066924456880521368950258152170031413196862950297402215316992\n// gas irOptimized: 127151\n// gas legacy: 148692\n// gas legacyOptimized: 148699\n// f(uint256): 12 -> 0x20, 0x0c, 0x0102030405060708090a0b0000000000000000000000000000000000000000\n// gas legacy: 59345\n// gas legacyOptimized: 57279\n// f(uint256): 129 -> 0x20, 0x81, 1780731860627700044960722568376592200742329637303199754547598369979440671, 0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f, 29063324697304692433803953038474361308315562010425523193971352996434451193439, 0x606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f, -57896044618658097711785492504343953926634992332820282019728792003956564819968\n// gas irOptimized: 416918\n// gas legacy: 458997\n// gas legacyOptimized: 460664\n"
        },
        "copy_internal_function_array_to_storage.sol": {
            "content": "contract C {\n    function() internal returns (uint)[20] x;\n    int256 mutex;\n\n    function one() public returns (uint256) {\n        function() internal returns (uint)[20] memory xmem;\n        x = xmem;\n        return 3;\n    }\n\n    function two() public returns (uint256) {\n        if (mutex > 0) return 7;\n        mutex = 1;\n        // If this test fails, it might re-execute this function.\n        x[0]();\n        return 2;\n    }\n}\n// ----\n// one() -> 3\n// gas legacy: 140253\n// gas legacyOptimized: 140093\n// two() -> FAILURE, hex\"4e487b71\", 0x51\n"
        },
        "array_of_function_external_storage_to_storage_dynamic_different_mutability.sol": {
            "content": "contract C {\n    function testFunction1() public {}\n    function testFunction2() public view {}\n    function testFunction3() public pure {}\n\n\n    function() external [] externalArray0;\n    function() external [] externalArray1;\n\n    function() internal [] internalArray0;\n    function() internal [] internalArray1;\n\n    constructor() {\n        externalArray0 = new function() external[] (3);\n        externalArray1 = [\n            this.testFunction1,\n            this.testFunction2,\n            this.testFunction3\n        ];\n\n        internalArray0 = new function() internal[] (3);\n        internalArray1 = [\n            testFunction1,\n            testFunction2,\n            testFunction3\n        ];\n    }\n\n\n    function copyExternalStorageArraysOfFunctionType() external returns (bool)\n    {\n        assert(keccak256(abi.encodePacked(externalArray0)) != keccak256(abi.encodePacked(externalArray1)));\n        externalArray0 = externalArray1;\n        return keccak256(abi.encodePacked(externalArray0)) == keccak256(abi.encodePacked(externalArray1));\n    }\n\n    function copyInternalArrayOfFunctionType() external returns (bool)\n    {\n        internalArray0 = internalArray1;\n        assert(internalArray0.length == 3);\n\n        return\n            internalArray0.length == internalArray1.length &&\n            internalArray0[0] == internalArray1[0] &&\n            internalArray0[1] == internalArray1[1] &&\n            internalArray0[2] == internalArray1[2];\n    }\n}\n// ----\n// copyExternalStorageArraysOfFunctionType() -> true\n// gas irOptimized: 104238\n// gas legacy: 108295\n// gas legacyOptimized: 102162\n// copyInternalArrayOfFunctionType() -> true\n// gas legacy: 104178\n"
        },
        "nested_array_of_structs_storage_to_storage.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n    struct S {\n        uint8 x;\n        uint8 y;\n    }\n\n    S[][] src1;\n    S[][1] src2;\n    S[1][] src3;\n\n    S[][] dst1;\n    S[][1] dst2;\n    S[1][] dst3;\n\n    constructor() {\n        src1 = new S[][](1);\n        src1[0].push(S({x: 3, y: 7}));\n        src1[0].push(S({x: 11, y: 13}));\n\n        src2[0].push(S({x: 3, y: 7}));\n        src2[0].push(S({x: 11, y: 13}));\n        src2[0].push(S({x: 17, y: 19}));\n\n        src3.push([S({x: 3, y: 7})]);\n        src3.push([S({x: 11, y: 13})]);\n    }\n\n    function test1() public {\n        dst1 = src1;\n\n        require(dst1.length == 1);\n        require(dst1[0][0].x == src1[0][0].x);\n        require(dst1[0][0].y == src1[0][0].y);\n        require(dst1[0][1].x == src1[0][1].x);\n        require(dst1[0][1].y == src1[0][1].y);\n    }\n\n    function test2() public {\n        dst2 = src2;\n\n        require(dst2[0].length == 3);\n        require(dst2[0][0].x == src2[0][0].x);\n        require(dst2[0][0].y == src2[0][0].y);\n        require(dst2[0][1].x == src2[0][1].x);\n        require(dst2[0][1].y == src2[0][1].y);\n        require(dst2[0][2].x == src2[0][2].x);\n        require(dst2[0][2].y == src2[0][2].y);\n    }\n\n    function test3() public {\n        dst3 = src3;\n\n        require(dst3.length == 2);\n        require(dst3[0][0].x == src3[0][0].x);\n        require(dst3[0][0].y == src3[0][0].y);\n        require(dst3[1][0].x == src3[1][0].x);\n        require(dst3[1][0].y == src3[1][0].y);\n    }\n}\n// ====\n// compileViaYul: true\n// ----\n// test1()\n// gas irOptimized: 123195\n// test2()\n// gas irOptimized: 123018\n// test3()\n"
        },
        "string_calldata_to_bytes_calldata.sol": {
            "content": "contract C {\n    function f(string calldata s) public returns (bytes calldata m) {\n        return bytes(s);\n    }\n}\n// ----\n// f(string): 0x20, 3, \"abc\" -> 0x20, 3, \"abc\"\n"
        },
        "nested_dynamic_array_element_calldata_to_storage.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n    uint8[][] a;\n    uint8[][][] a2;\n\n    function test(uint8[][][] calldata _a) public {\n        a = _a[1];\n        require(a.length == 2);\n        require(a[0].length == 1);\n        require(a[0][0] == 7);\n        require(a[1].length == 2);\n        require(a[1][0] == 8);\n        require(a[1][1] == 9);\n    }\n\n    function test2(uint8[][] calldata _a) public {\n        a2 = new uint8[][][](2);\n        a2[0] = _a;\n        require(a2[0].length == 2);\n\trequire(a2[0][0].length == 1);\n\trequire(a2[0][0][0] == 7);\n\trequire(a2[0][1].length == 2);\n\trequire(a2[0][1][0] == 8);\n\trequire(a2[0][1][1] == 9);\n\trequire(a2[1].length == 0);\n    }\n}\n// ====\n// compileViaYul: true\n// ----\n// test(uint8[][][]): 0x20, 2, 0x40, 0x60, 0, 2, 0x40, 0x80, 1, 7, 2, 8, 9\n// gas irOptimized: 137897\n// test2(uint8[][]): 0x20, 2, 0x40, 0x80, 1, 7, 2, 8, 9\n// gas irOptimized: 164482\n// gas legacyOptimized: 120228\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "metadata",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ]
            }
        }
    }
}