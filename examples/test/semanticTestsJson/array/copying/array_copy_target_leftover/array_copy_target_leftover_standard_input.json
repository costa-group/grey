{
    "language": "Solidity",
    "sources": {
        "array_copy_cleanup_uint128.sol": {
            "content": "// Test to see if cleanup is performed properly during array copying\ncontract C {\n    uint128[] x;\n    function f() public returns(bool) {\n        x.push(42); x.push(42); x.push(42); x.push(42);\n        uint128[] memory y = new uint128[](1);\n        y[0] = 23;\n        x = y;\n        assembly { sstore(x.slot, 4) }\n\n        assert(x[0] == 23);\n        assert(x[1] == 0);\n\n        assert(x[2] == 0);\n        // Issue 9832: the cleanup was only performed for the first packed type leaving the rest of\n        // the slot dirty.\n        assert(x[3] == 0);\n\n        return true;\n    }\n}\n// ----\n// f() -> true\n// gas irOptimized: 92740\n// gas legacy: 93035\n// gas legacyOptimized: 92257\n"
        },
        "array_of_function_external_storage_to_storage_dynamic.sol": {
            "content": "contract C {\n    function testFunction1() public {}\n    function testFunction2() public {}\n    function testFunction3() public {}\n\n\n    function() external [] externalArray0;\n    function() external [] externalArray1;\n\n    function() internal [] internalArray0;\n    function() internal [] internalArray1;\n\n    constructor() {\n        externalArray0 = new function() external[] (3);\n        externalArray1 = [\n            this.testFunction1,\n            this.testFunction2,\n            this.testFunction3\n        ];\n\n        internalArray0 = new function() internal[] (3);\n        internalArray1 = [\n            testFunction1,\n            testFunction2,\n            testFunction3\n        ];\n    }\n\n    function copyExternalStorageArrayOfFunctionType() external returns (bool) {\n        assert(keccak256(abi.encode(externalArray0)) != keccak256(abi.encode(externalArray1)));\n        externalArray0 = externalArray1;\n        return keccak256(abi.encode(externalArray0)) == keccak256(abi.encode(externalArray1));\n    }\n\n    function copyInternalArrayOfFunctionType() external returns (bool) {\n        internalArray0 = internalArray1;\n        assert(internalArray0.length == 3);\n\n        return\n            internalArray0.length == internalArray1.length &&\n            internalArray0[0] == internalArray1[0] &&\n            internalArray0[1] == internalArray1[1] &&\n            internalArray0[2] == internalArray1[2];\n    }\n}\n// ----\n// copyExternalStorageArrayOfFunctionType() -> true\n// gas irOptimized: 104566\n// gas legacy: 108554\n// gas legacyOptimized: 102405\n// copyInternalArrayOfFunctionType() -> true\n"
        },
        "nested_array_element_calldata_to_memory.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n    function test1(uint8[][][] calldata _a) public returns (uint8[][] memory) {\n        return _a[1];\n    }\n\n    function test2(uint8[][1][] calldata _a) public returns (uint8[][1] memory) {\n        return _a[0];\n    }\n\n    function test3(uint8[2][][2] calldata _a) public returns (uint8[2][] memory) {\n        return _a[0];\n    }\n\n    function test4(uint16[][] calldata _a) public returns (uint16[][] memory) {\n        uint16[][][] memory tmp = new uint16[][][](2);\n        tmp[1] = _a;\n        return tmp[1];\n    }\n\n    function test5(uint32[][2] calldata _a) public returns (uint32[][2] memory) {\n        uint32[][2][] memory tmp = new uint32[][2][](1);\n        tmp[0] = _a;\n        return tmp[0];\n    }\n\n    function test6(uint32[2][] calldata _a) public returns (uint32[2][] memory) {\n        uint32[2][][] memory tmp = new uint32[2][][](1);\n        tmp[0] = _a;\n        return tmp[0];\n    }\n}\n// ----\n// test1(uint8[][][]): 0x20, 2, 0x40, 0x60, 0, 2, 0x40, 0x80, 1, 7, 2, 8, 9 -> 0x20, 2, 0x40, 0x80, 1, 7, 2, 8, 9\n// test2(uint8[][1][]): 0x20, 2, 0x40, 0xe0, 0x20, 3, 12, 13, 14, 0x20, 3, 15, 16, 17 -> 0x20, 0x20, 3, 12, 13, 14\n// test3(uint8[2][][2]): 0x20, 0x40, 0xa0, 1, 7, 7, 2, 8, 8, 0x09, 9 -> 0x20, 1, 7, 7\n// test4(uint16[][]): 0x20, 2, 0x40, 0x80, 1, 7, 2, 8, 9 -> 0x20, 2, 0x40, 0x80, 1, 7, 2, 8, 9\n// test5(uint32[][2]): 0x20, 0x40, 0x80, 1, 7, 2, 8, 9 -> 0x20, 0x40, 0x80, 1, 7, 2, 8, 9\n// test6(uint32[2][]): 0x20, 2, 5, 6, 7, 8 -> 0x20, 2, 5, 6, 7, 8\n"
        },
        "calldata_array_of_struct_to_memory.sol": {
            "content": "pragma abicoder               v2;\n\n\ncontract C {\n    struct S {\n        uint256 a;\n        uint256 b;\n    }\n\n    function f(S[] calldata s)\n        external\n        pure\n        returns (uint256 l, uint256 a, uint256 b, uint256 c, uint256 d)\n    {\n        S[] memory m = s;\n        l = m.length;\n        a = m[0].a;\n        b = m[0].b;\n        c = m[1].a;\n        d = m[1].b;\n    }\n}\n// ----\n// f((uint256,uint256)[]): 0x20, 0x2, 0x1, 0x2, 0x3, 0x4 -> 2, 1, 2, 3, 4\n"
        },
        "calldata_2d_bytes_to_memory_2.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n    function g(bytes[2] memory m) internal {\n        assert(m[0].length > 1);\n        assert(m[1].length > 1);\n        assert(m[0][0] == m[1][0]);\n        assert(m[0][1] == m[1][1]);\n    }\n    function f(bytes[2] calldata c) external {\n        g(c);\n    }\n}\n// ----\n// f(bytes[2]): 0x20, 0x40, 0x40, 2, \"ab\" ->\n// f(bytes[2]): 0x20, 0x40, 0x40, 1, \"a\" -> FAILURE, hex\"4e487b71\", 0x01\n"
        },
        "memory_dyn_2d_bytes_to_storage.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n    bytes[] s;\n    function f() external returns (uint256) {\n        bytes[] memory m = new bytes[](3);\n        m[0] = \"ab\"; m[1] = \"cde\"; m[2] = \"fghij\";\n        s = m;\n        assert(s.length == m.length);\n        for (uint i = 0; i < s.length; ++i) {\n            assert(s[i].length == m[i].length);\n            for (uint j = 0; j < s[i].length; ++j) {\n                 assert(s[i][j] == m[i][j]);\n            }\n        }\n        return s.length;\n    }\n}\n// ----\n// f() -> 3\n// gas irOptimized: 128296\n// gas legacy: 129077\n// gas legacyOptimized: 128210\n"
        },
        "array_copy_storage_abi_signed.sol": {
            "content": "// NOTE: This does not really test copying from storage to ABI directly,\n// because it will always copy to memory first.\ncontract c {\n    int16[] x;\n\n    function test() public returns (int16[] memory) {\n        x.push(int16(-1));\n        x.push(int16(-1));\n        x.push(int16(8));\n        x.push(int16(-16));\n        x.push(int16(-2));\n        x.push(int16(6));\n        x.push(int16(8));\n        x.push(int16(-1));\n        return x;\n    }\n}\n// ----\n// test() -> 0x20, 0x8, -1, -1, 8, -16, -2, 6, 8, -1\n"
        },
        "storage_memory_nested_from_pointer.sol": {
            "content": "contract C {\n    uint72[5][] a;\n\n    function f() public returns (uint72, uint72, uint72, uint72, uint72, uint72, uint72) {\n        for (uint i = 0; i < 4; i++)\n            a.push();\n        a[0][0] = 1;\n        a[0][3] = 2;\n        a[1][1] = 3;\n        a[1][4] = 4;\n        a[2][0] = 5;\n        a[3][2] = 6;\n        a[3][3] = 7;\n        uint72[5][] storage a_ = a;\n        uint72[5][] memory m = a_;\n        return (m[0][0], m[0][3], m[1][1], m[1][4], m[2][0], m[3][2], m[3][3]);\n    }\n}\n// ----\n// f() -> 1, 2, 3, 4, 5, 6, 7\n// gas irOptimized: 206440\n// gas legacy: 211770\n// gas legacyOptimized: 211191\n"
        },
        "array_copy_target_leftover.sol": {
            "content": "contract c {\n    bytes1[10] data1;\n    bytes2[32] data2;\n    function test() public returns (uint check, uint res1, uint res2) {\n        uint i;\n        for (i = 0; i < data2.length; ++i)\n            data2[i] = 0xffff;\n        check = uint(uint16(data2[31])) * 0x10000 | uint(uint16(data2[14]));\n        for (i = 0; i < data1.length; ++i)\n            data1[i] = bytes1(uint8(1 + i));\n        data2 = data1;\n        for (i = 0; i < 16; ++i)\n            res1 |= uint(uint16(data2[i])) * 0x10000**i;\n        for (i = 0; i < 16; ++i)\n            res2 |= uint(uint16(data2[16 + i])) * 0x10000**i;\n    }\n}\n// ----\n// test() -> 0xffffffff, 0x0000000000000000000000000a00090008000700060005000400030002000100, 0x0000000000000000000000000000000000000000000000000000000000000000\n// gas irOptimized: 100496\n// gas legacy: 158109\n// gas legacyOptimized: 141019\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "metadata",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ]
            }
        }
    }
}