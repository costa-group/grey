{
    "language": "Solidity",
    "sources": {
        "bytes_to_fixed_bytes_too_long.sol": {
            "content": "contract C {\n    bytes s = \"abcdefghabcdefghabcdefghabcdefgha\";\n\n    function fromMemory(bytes memory m) public returns (bytes32) {\n        return bytes32(m);\n    }\n    function fromCalldata(bytes calldata c) external returns (bytes32) {\n        return bytes32(c);\n    }\n    function fromStorage() external returns (bytes32) {\n        return bytes32(s);\n    }\n    function fromSlice(bytes calldata c) external returns (bytes32) {\n        return bytes32(c[0:33]);\n    }\n}\n// ----\n// fromMemory(bytes): 0x20, 33, \"abcdefghabcdefghabcdefghabcdefgh\", \"a\" -> \"abcdefghabcdefghabcdefghabcdefgh\"\n// fromCalldata(bytes): 0x20, 33, \"abcdefghabcdefghabcdefghabcdefgh\", \"a\" -> \"abcdefghabcdefghabcdefghabcdefgh\"\n// fromStorage() -> \"abcdefghabcdefghabcdefghabcdefgh\"\n// fromSlice(bytes): 0x20, 33, \"abcdefghabcdefghabcdefghabcdefgh\", \"a\" -> \"abcdefghabcdefghabcdefghabcdefgh\"\n"
        },
        "array_2d_new.sol": {
            "content": "contract C {\n\tfunction f(uint n) public pure returns (uint) {\n\t\tuint[][] memory a = new uint[][](2);\n\t\tfor (uint i = 0; i < 2; ++i)\n\t\t\ta[i] = new uint[](3);\n\t\treturn a[0][0] = n;\n\t}\n}\n// ----\n// f(uint256): 42 -> 42\n"
        },
        "array_3d_new.sol": {
            "content": "contract C {\n\tfunction f(uint n) public pure returns (uint) {\n\t\tuint[][][] memory a = new uint[][][](2);\n\t\tfor (uint i = 0; i < 2; ++i)\n\t\t{\n\t\t\ta[i] = new uint[][](3);\n\t\t\tfor (uint j = 0; j < 3; ++j)\n\t\t\t\ta[i][j] = new uint[](4);\n\t\t}\n\t\treturn a[1][1][1] = n;\n\t}\n}\n// ----\n// f(uint256): 42 -> 42\n"
        },
        "dynamic_multi_array_cleanup.sol": {
            "content": "contract c {\n    struct s { uint[][] d; }\n    s[] data;\n    function fill() public returns (uint) {\n        while (data.length < 3)\n            data.push();\n        while (data[2].d.length < 4)\n            data[2].d.push();\n        while (data[2].d[3].length < 5)\n            data[2].d[3].push();\n        data[2].d[3][4] = 8;\n        return data[2].d[3][4];\n    }\n    function clear() public { delete data; }\n}\n// ----\n// storageEmpty -> 1\n// fill() -> 8\n// gas irOptimized: 122985\n// gas legacy: 121602\n// gas legacyOptimized: 120589\n// storageEmpty -> 0\n// clear() ->\n// storageEmpty -> 1\n"
        },
        "create_multiple_dynamic_arrays.sol": {
            "content": "contract C {\n    function f() public returns (uint256) {\n        uint256[][] memory x = new uint256[][](42);\n        assert(x[0].length == 0);\n        x[0] = new uint256[](1);\n        x[0][0] = 1;\n        assert(x[4].length == 0);\n        x[4] = new uint256[](1);\n        x[4][0] = 2;\n        assert(x[10].length == 0);\n        x[10] = new uint256[](1);\n        x[10][0] = 44;\n        uint256[][] memory y = new uint256[][](24);\n        assert(y[0].length == 0);\n        y[0] = new uint256[](1);\n        y[0][0] = 1;\n        assert(y[4].length == 0);\n        y[4] = new uint256[](1);\n        y[4][0] = 2;\n        assert(y[10].length == 0);\n        y[10] = new uint256[](1);\n        y[10][0] = 88;\n        if (\n            (x[0][0] == y[0][0]) &&\n            (x[4][0] == y[4][0]) &&\n            (x[10][0] == 44) &&\n            (y[10][0] == 88)\n        ) return 7;\n        return 0;\n    }\n}\n// ----\n// f() -> 7\n"
        },
        "reusing_memory.sol": {
            "content": "// Invoke some features that use memory and test that they do not interfere with each other.\ncontract Helper {\n    uint256 public flag;\n\n    constructor(uint256 x) {\n        flag = x;\n    }\n}\n\n\ncontract Main {\n    mapping(uint256 => uint256) map;\n\n    function f(uint256 x) public returns (uint256) {\n        map[x] = x;\n        return\n            (new Helper(uint256(keccak256(abi.encodePacked(this.g(map[x]))))))\n                .flag();\n    }\n\n    function g(uint256 a) public returns (uint256) {\n        return map[a];\n    }\n}\n// ----\n// f(uint256): 0x34 -> 0x46bddb1178e94d7f2892ff5f366840eb658911794f2c3a44c450aa2c505186c1\n// gas irOptimized: 99552\n// gas irOptimized code: 12400\n// gas legacy: 101551\n// gas legacy code: 23600\n// gas legacyOptimized: 99612\n// gas legacyOptimized code: 13400\n"
        },
        "fixed_array_cleanup.sol": {
            "content": "contract c {\n    uint spacer1;\n    uint spacer2;\n    uint[20] data;\n    function fill() public {\n        for (uint i = 0; i < data.length; ++i) data[i] = i+1;\n    }\n    function clear() public { delete data; }\n}\n// ----\n// storageEmpty -> 1\n// fill() ->\n// gas irOptimized: 465013\n// gas legacy: 468825\n// gas legacyOptimized: 466238\n// storageEmpty -> 0\n// clear() ->\n// gas irOptimized: 122148\n// gas legacy: 122440\n// gas legacyOptimized: 122259\n// storageEmpty -> 1\n"
        },
        "create_memory_byte_array.sol": {
            "content": "contract C {\n    function f() public returns (bytes1) {\n        bytes memory x = new bytes(35);\n        assert(x.length == 35);\n        x[34] = \"A\";\n        return (x[34]);\n    }\n}\n// ----\n// f() -> \"A\"\n"
        },
        "calldata_array_as_argument_internal_function.sol": {
            "content": "pragma abicoder v2;\ncontract Test {\n    function f(uint256[] calldata c) internal returns (uint a, uint b) {\n        return (c.length, c[0]);\n    }\n\n    function g(uint256[] calldata c) external returns (uint a, uint b) {\n        return f(c);\n    }\n\n    function h(uint256[] calldata c, uint start, uint end) external returns (uint a, uint b) {\n        return f(c[start: end]);\n    }\n}\n// ----\n// g(uint256[]): 0x20, 4, 1, 2, 3, 4 -> 4, 1\n// h(uint256[],uint256,uint256): 0x60, 1, 3, 4, 1, 2, 3, 4 -> 2, 2\n"
        },
        "calldata_array_dynamic_invalid_static_middle.sol": {
            "content": "pragma abicoder               v2;\n\n\ncontract C {\n    function f(uint256[][1][] calldata a) external returns (uint256) {\n        return 42;\n    }\n\n    function g(uint256[][1][] calldata a) external returns (uint256) {\n        a[0];\n        return 42;\n    }\n\n    function h(uint256[][1][] calldata a) external returns (uint256) {\n        a[0][0];\n        return 42;\n    }\n}\n// ----\n// f(uint256[][1][]): 0x20, 0x0 -> 42 # valid access stub #\n// f(uint256[][1][]): 0x20, 0x1 -> FAILURE # invalid on argument decoding #\n// f(uint256[][1][]): 0x20, 0x1, 0x20 -> 42 # invalid on outer access #\n// g(uint256[][1][]): 0x20, 0x1, 0x20 -> FAILURE\n// f(uint256[][1][]): 0x20, 0x1, 0x20, 0x20 -> 42 # invalid on inner access #\n// g(uint256[][1][]): 0x20, 0x1, 0x20, 0x20 -> 42\n// h(uint256[][1][]): 0x20, 0x1, 0x20, 0x20 -> FAILURE\n// f(uint256[][1][]): 0x20, 0x1, 0x20, 0x20, 0x1 -> 42\n// g(uint256[][1][]): 0x20, 0x1, 0x20, 0x20, 0x1 -> 42\n// h(uint256[][1][]): 0x20, 0x1, 0x20, 0x20, 0x1 -> FAILURE\n"
        },
        "calldata_array_two_dimensional_1.sol": {
            "content": "pragma abicoder               v2;\ncontract C {\n    function test(uint256[][] calldata a) external returns (uint256) {\n        return a.length;\n    }\n    function test(uint256[][] calldata a, uint256 i) external returns (uint256) {\n        return a[i].length;\n    }\n    function test(uint256[][] calldata a, uint256 i, uint256 j) external returns (uint256) {\n        return a[i][j];\n    }\n    function reenc(uint256[][] calldata a, uint256 i, uint256 j) external returns (uint256) {\n        return this.test(a, i, j);\n    }\n}\n// ----\n// test(uint256[][]): 0x20, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 2\n// test(uint256[][],uint256): 0x40, 0, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 3\n// test(uint256[][],uint256): 0x40, 1, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 4\n// test(uint256[][],uint256,uint256): 0x60, 0, 0, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 0x0A01\n// reenc(uint256[][],uint256,uint256): 0x60, 0, 0, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 0x0A01\n// test(uint256[][],uint256,uint256): 0x60, 0, 1, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 0x0A02\n// reenc(uint256[][],uint256,uint256): 0x60, 0, 1, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 0x0A02\n// test(uint256[][],uint256,uint256): 0x60, 0, 2, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 0x0A03\n// reenc(uint256[][],uint256,uint256): 0x60, 0, 2, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 0x0A03\n// test(uint256[][],uint256,uint256): 0x60, 1, 0, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 0x0B01\n// reenc(uint256[][],uint256,uint256): 0x60, 1, 0, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 0x0B01\n// test(uint256[][],uint256,uint256): 0x60, 1, 1, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 0x0B02\n// reenc(uint256[][],uint256,uint256): 0x60, 1, 1, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 0x0B02\n// test(uint256[][],uint256,uint256): 0x60, 1, 2, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 0x0B03\n// reenc(uint256[][],uint256,uint256): 0x60, 1, 2, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 0x0B03\n// test(uint256[][],uint256,uint256): 0x60, 1, 3, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 0x0B04\n// reenc(uint256[][],uint256,uint256): 0x60, 1, 3, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> 0x0B04\n// test(uint256[][],uint256,uint256): 0x60, 0, 3, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> FAILURE, hex\"4e487b71\", 0x32\n// test(uint256[][],uint256,uint256): 0x60, 1, 4, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> FAILURE, hex\"4e487b71\", 0x32\n// test(uint256[][],uint256): 0x40, 2, 2, 0x40, 0xC0, 3, 0x0A01, 0x0A02, 0x0A03, 4, 0x0B01, 0x0B02, 0x0B03, 0x0B04 -> FAILURE, hex\"4e487b71\", 0x32\n"
        },
        "array_push_return_reference.sol": {
            "content": "contract C {\n    uint[] storageArray;\n    function test(uint256 v) public {\n        storageArray.push() = v;\n    }\n    function getLength() public view returns (uint256) {\n        return storageArray.length;\n    }\n    function fetch(uint256 a) public view returns (uint256) {\n        return storageArray[a];\n    }\n}\n// ----\n// getLength() -> 0\n// test(uint256): 42 ->\n// getLength() -> 1\n// fetch(uint256): 0 -> 42\n// fetch(uint256): 1 -> FAILURE, hex\"4e487b71\", 0x32\n// test(uint256): 23 ->\n// getLength() -> 2\n// fetch(uint256): 0 -> 42\n// fetch(uint256): 1 -> 23\n// fetch(uint256): 2 -> FAILURE, hex\"4e487b71\", 0x32\n"
        },
        "calldata_bytes_array_bounds.sol": {
            "content": "pragma abicoder               v2;\ncontract C {\n    function f(bytes[] calldata a, uint256 i) external returns (uint) {\n        return uint8(a[0][i]);\n    }\n}\n// ----\n// f(bytes[],uint256): 0x40, 0, 1, 0x20, 2, 0x6162000000000000000000000000000000000000000000000000000000000000 -> 0x61\n// f(bytes[],uint256): 0x40, 1, 1, 0x20, 2, 0x6162000000000000000000000000000000000000000000000000000000000000 -> 0x62\n// f(bytes[],uint256): 0x40, 2, 1, 0x20, 2, 0x6162000000000000000000000000000000000000000000000000000000000000 -> FAILURE, hex\"4e487b71\", 0x32\n"
        },
        "array_push_with_arg.sol": {
            "content": "contract C {\n    uint[] storageArray;\n    function test(uint256 v) public {\n        storageArray.push(v);\n    }\n    function getLength() public view returns (uint256) {\n        return storageArray.length;\n    }\n    function fetch(uint256 a) public view returns (uint256) {\n        return storageArray[a];\n    }\n}\n// ----\n// getLength() -> 0\n// test(uint256): 42 ->\n// getLength() -> 1\n// fetch(uint256): 0 -> 42\n// fetch(uint256): 1 -> FAILURE, hex\"4e487b71\", 0x32\n// test(uint256): 23 ->\n// getLength() -> 2\n// fetch(uint256): 0 -> 42\n// fetch(uint256): 1 -> 23\n// fetch(uint256): 2 -> FAILURE, hex\"4e487b71\", 0x32\n"
        },
        "calldata_array_of_struct.sol": {
            "content": "pragma abicoder               v2;\n\n\ncontract C {\n    struct S {\n        uint256 a;\n        uint256 b;\n    }\n\n    function f(S[] calldata s)\n        external\n        pure\n        returns (uint256 l, uint256 a, uint256 b, uint256 c, uint256 d)\n    {\n        l = s.length;\n        a = s[0].a;\n        b = s[0].b;\n        c = s[1].a;\n        d = s[1].b;\n    }\n}\n// ----\n// f((uint256,uint256)[]): 0x20, 0x2, 0x1, 0x2, 0x3, 0x4 -> 2, 1, 2, 3, 4\n"
        },
        "string_allocation_bug.sol": {
            "content": "contract Sample {\n    struct s {\n        uint16 x;\n        uint16 y;\n        string a;\n        string b;\n    }\n    s[2] public p;\n\n    constructor() {\n        s memory m;\n        m.x = 0xbbbb;\n        m.y = 0xcccc;\n        m.a = \"hello\";\n        m.b = \"world\";\n        p[0] = m;\n    }\n}\n// ----\n// p(uint256): 0x0 -> 0xbbbb, 0xcccc, 0x80, 0xc0, 0x05, \"hello\", 0x05, \"world\"\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "metadata",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ]
            }
        }
    }
}