{
    "language": "Solidity",
    "sources": {
        "selfbalance.sol": {
            "content": "contract C {\n    function f() public payable returns (uint ret) {\n        assembly {\n            ret := selfbalance()\n        }\n    }\n}\n// ====\n// EVMVersion: >=istanbul\n// ----\n// f(), 254 wei -> 254\n"
        },
        "calldata_array_read.sol": {
            "content": "contract C {\n    function f(uint[2][] calldata x) public returns (uint o, uint l, uint s) {\n        assembly { l := x.length o := x.offset }\n        uint[2] calldata t = x[1];\n        // statically-sized arrays only use one slot, so we read directly.\n        assembly { s := t }\n    }\n}\n// ----\n// f(uint256[2][]): 0x20, 2, 1, 2, 3, 4 -> 0x44, 2, 0x84\n"
        },
        "inline_assembly_storage_access_via_pointer.sol": {
            "content": "contract C {\n    struct Data {\n        uint256 contents;\n    }\n    uint256 public separator;\n    Data public a;\n    uint256 public separator2;\n\n    function f() public returns (bool) {\n        Data storage x = a;\n        uint256 off;\n        assembly {\n            sstore(x.slot, 7)\n            off := x.offset\n        }\n        assert(off == 0);\n        return true;\n    }\n}\n// ----\n// f() -> true\n// a() -> 7\n// separator() -> 0\n// separator2() -> 0\n"
        },
        "calldata_struct_assign_and_return.sol": {
            "content": "pragma abicoder v2;\ncontract C {\n  struct S { int8 x; int8 y; }\n  function f() internal pure returns(S calldata s) {\n    assembly {\n      s := 0x24\n    }\n  }\n  function g() public pure returns(int8, int8) {\n    S calldata s = f();\n    return (s.x, s.y);\n  }\n  function h() public pure returns(uint256) { f(); return 0x42; }\n  function i() public pure returns(uint256) { abi.decode(msg.data[4:], (S)); return 0x42; }\n}\n// ----\n// g(): 0xCAFFEE, 0x42, 0x21 -> 0x42, 0x21\n// g(): 0xCAFFEE, 0x4242, 0x2121 -> FAILURE\n// g(): 0xCAFFEE, 0x42 -> 0x42, 0\n// h() -> 0x42\n// i() -> FAILURE\n"
        },
        "inline_assembly_function_call_assignment.sol": {
            "content": "contract C {\n    function f() public {\n        assembly {\n            let a1, b1, c1\n\n            function asmfun(a, b, c) -> x, y, z {\n                x := a\n                y := b\n                z := 7\n            }\n            a1, b1, c1 := asmfun(1, 2, 3)\n            mstore(0x00, a1)\n            mstore(0x20, b1)\n            mstore(0x40, c1)\n            return (0, 0x60)\n        }\n    }\n}\n// ----\n// f() -> 1, 2, 7\n"
        },
        "external_function_pointer_address_assignment.sol": {
            "content": "contract C {\n\tfunction testFunction() external {}\n\n\tfunction testYul(address newAddress) view public returns (address adr) {\n\t\tfunction() external fp = this.testFunction;\n\n\t\tassembly {\n\t\t\tfp.address := newAddress\n\t\t}\n\n\t\treturn fp.address;\n\t}\n}\n// ----\n// testYul(address): 0x1234567890 -> 0x1234567890\n// testYul(address): 0xC0FFEE3EA7 -> 0xC0FFEE3EA7\n"
        },
        "keccak_optimization_bug_string.sol": {
            "content": "contract C {\n    function f(string memory s) public returns (bool ret) {\n        assembly {\n            let a := keccak256(s, 32)\n            let b := keccak256(s, 8)\n            ret := eq(a, b)\n        }\n    }\n}\n// ----\n// f(string): \"\" -> false\n// f(string): 0x20, 5, \"hello\" -> false\n// f(string): 0x20, 0x2e, 29457663690442756349866640336617293820574110049925353194191585327958485180523, 45859201465615193776739262511799714667061496775486067316261261194408342061056 -> false\n"
        },
        "inlineasm_empty_let.sol": {
            "content": "contract C {\n\tfunction f() public pure returns (uint a, uint b) {\n\t\tassembly {\n\t\t\tlet x\n\t\t\tlet y, z\n\t\t\ta := x\n\t\t\tb := z\n\t\t}\n\t}\n}\n// ----\n// f() -> 0, 0\n"
        },
        "calldata_array_assign_dynamic.sol": {
            "content": "contract C {\n    function f(uint[2][] calldata x) public returns (uint[2][] memory r) {\n        assembly { x.offset := 0x44 x.length := 2 }\n        r = x;\n    }\n}\n// ----\n// f(uint256[2][]): 0x0, 1, 8, 7, 6, 5 -> 0x20, 2, 8, 7, 6, 5\n"
        },
        "external_function_pointer_address.sol": {
            "content": "contract C {\n\tfunction testFunction() external {}\n\n\tfunction testYul() public returns (address adr) {\n\t\tfunction() external fp = this.testFunction;\n\n\t\tassembly {\n\t\t\tadr := fp.address\n\t\t}\n\t}\n\tfunction testSol() public returns (address) {\n\t\treturn this.testFunction.address;\n\t}\n}\n// ----\n// testYul() -> 0xc06afe3a8444fc0004668591e8306bfb9968e79e\n// testSol() -> 0xc06afe3a8444fc0004668591e8306bfb9968e79e\n"
        },
        "inline_assembly_memory_access.sol": {
            "content": "contract C {\n    function test() public returns (bytes memory) {\n        bytes memory x = new bytes(5);\n        for (uint256 i = 0; i < x.length; ++i) x[i] = bytes1(uint8(i + 1));\n        assembly {\n            mstore(add(x, 32), \"12345678901234567890123456789012\")\n        }\n        return x;\n    }\n}\n// ----\n// test() -> 0x20, 0x5, \"12345\"\n"
        },
        "keccak256_optimizer_cache_bug.sol": {
            "content": "contract C {\n  uint[] data;\n\n  function val() public returns (bool) {\n    assembly {\n        sstore(0, 2)\n        mstore(0, 0)\n        sstore(keccak256(0, 32), 234)\n        // A bug in the caching mechanism previously caused keccak256(0, 23) to be the same as\n        // keccak256(0, 32), leading to `data[1] == 123` being true.\n        sstore(add(keccak256(0, 23), 1), 123)\n    }\n    assert(data[1] != 123);\n    assert(data[1] == 0);\n    return true;\n  }\n}\n// ----\n// val() -> true\n"
        },
        "mcopy_empty.sol": {
            "content": "contract C {\n    function mcopy_zero(bytes memory pattern) public pure returns (bytes memory out) {\n        out = pattern;\n\n        // This should have no effect on output\n        assembly {\n            mcopy(add(out, 0x20), add(out, 0x30), 0)\n            mcopy(add(out, 0x30), add(out, 0x30), 0)\n            mcopy(add(out, 0x40), add(out, 0x30), 0)\n\n            mcopy(add(out, 0x21), 0, 0)\n        }\n    }\n}\n// ====\n// EVMVersion: >=cancun\n// ----\n// mcopy_zero(bytes): 0x20, 0x20, 0xffeeddccbbaa9988776655443322110000112233445566778899aabbccddeeff -> 0x20, 0x20, 0xffeeddccbbaa9988776655443322110000112233445566778899aabbccddeeff\n"
        },
        "keccak256_optimization.sol": {
            "content": "contract C {\n    function f() public view returns (bool ret) {\n        assembly {\n            let x := calldataload(0)\n            mstore(0, x)\n            mstore(0x20, x)\n            let a := keccak256(0, 4)\n            let b := keccak256(0x20, 4)\n            ret := eq(a, b)\n        }\n    }\n}\n// ----\n// f() -> true\n"
        },
        "keccak_yul_optimization.sol": {
            "content": "contract C {\n    function g() public returns (uint ret) {\n        uint x = type(uint).max;\n        assembly {\n            mstore(0x20, x)\n            // both old and new optimizer should be able to evaluate this\n            ret := keccak256(0x20, 16)\n        }\n    }\n\n    function f() public returns (uint ret) {\n        uint x = type(uint).max;\n        assembly {\n            mstore(0x20, x)\n            // For Yul optimizer, load resolver and loop invariant code motion\n            // would take the Keccak-256 outside the loop. For the old-optimizer,\n            // this is not possible.\n            // Net savings approximately: 20 * cost of Keccak-256 = 572\n            for {let i := 0} lt(i, 20) { i := add(i, 1) } {\n                ret := keccak256(0x20, 16)\n            }\n        }\n    }\n}\n// ----\n// f() -> 0xcdb56c384a9682c600315e3470157a4cf7638d0d33e9dae5c40ffd2644fc5a80\n// gas irOptimized: 22239\n// gas legacy: 23385\n// gas legacyOptimized: 23092\n// g() -> 0xcdb56c384a9682c600315e3470157a4cf7638d0d33e9dae5c40ffd2644fc5a80\n// gas irOptimized: 21277\n// gas legacy: 21462\n// gas legacyOptimized: 21256\n"
        },
        "inline_assembly_if.sol": {
            "content": "contract C {\n    function f(uint256 a) public returns (uint256 b) {\n        assembly {\n            if gt(a, 1) {\n                b := 2\n            }\n        }\n    }\n}\n// ----\n// f(uint256): 0 -> 0\n// f(uint256): 1 -> 0\n// f(uint256): 2 -> 2\n// f(uint256): 3 -> 2\n"
        },
        "tload_tstore_not_reserved_before_cancun.sol": {
            "content": "contract C {\n    function f() public view returns (uint ret) {\n        assembly {\n            let tload := sload(0)\n            let tstore := add(tload, 1)\n            ret := tstore\n        }\n    }\n    function g() public view returns (uint ret) {\n        assembly {\n            function tstore() -> a {\n                a := 2\n            }\n            function tload() -> b {\n                b := 3\n            }\n            ret := add(tstore(), tload())\n        }\n    }\n}\n// ====\n// EVMVersion: <cancun\n// ----\n// f() -> 1\n// g() -> 5\n"
        },
        "transient_storage_sanity_checks.sol": {
            "content": "contract C {\n    function f() external {\n        assembly {\n            tstore(0, 21)\n            mstore(0, 42)\n            sstore(0, 42)\n            if iszero(eq(tload(0), 21)) {\n                revert(0, 0)\n            }\n        }\n    }\n    function g() external view returns (uint s, uint m, uint t) {\n        assembly {\n            s := sload(0)\n            m := mload(0)\n            t := tload(0)\n        }\n    }\n}\n// ====\n// EVMVersion: >=cancun\n// ----\n// f() ->\n// g() -> 0x2a, 0, 0\n"
        },
        "blobhash_index_exceeding_blob_count.sol": {
            "content": "contract C {\n    function f() public view returns (bytes32 ret) {\n        assembly {\n            // EIP-4844 specifies that if `index < len(tx.blob_versioned_hashes)`, `blobhash(index)` should return 0.\n            // Thus, as we injected only two blob hashes in the transaction context in EVMHost,\n            // the return value of the function below MUST be zero.\n            ret := blobhash(2)\n        }\n    }\n}\n// ====\n// EVMVersion: >=cancun\n// ----\n// f() -> 0x00\n"
        },
        "shadowing_local_function_opcode.sol": {
            "content": "contract C {\n    function add(uint, uint) public pure returns (uint) { return 7; }\n    function g() public pure returns (uint x, uint y) {\n        x = add(1, 2);\n        assembly {\n            y := add(1, 2)\n        }\n    }\n}\n// ----\n// g() -> 7, 3\n"
        },
        "calldata_length_read.sol": {
            "content": "contract C {\n    function lenBytesRead(bytes calldata x) public returns (uint l) {\n        assembly { l := x.length }\n    }\n\n    function lenStringRead(string calldata x) public returns (uint l) {\n        assembly { l := x.length }\n    }\n}\n// ----\n// lenBytesRead(bytes): 0x20, 4, \"abcd\" -> 4\n// lenBytesRead(bytes): 0x20, 0, \"abcd\" -> 0x00\n// lenBytesRead(bytes): 0x20, 0x21, \"abcd\", \"ef\" -> 33\n// lenStringRead(string): 0x20, 4, \"abcd\" -> 4\n// lenStringRead(string): 0x20, 0, \"abcd\" -> 0x00\n// lenStringRead(string): 0x20, 0x21, \"abcd\", \"ef\" -> 33\n"
        },
        "mcopy_overlap.sol": {
            "content": "function copy(uint dstOffset, uint srcOffset, uint length) pure returns (bytes memory out) {\n    out =\n        hex\"2222222222222222333333333333333344444444444444445555555555555555\"\n        hex\"6666666666666666777777777777777788888888888888889999999999999999\"\n        hex\"aaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbccccccccccccccccdddddddddddddddd\";\n    assembly {\n        mcopy(add(add(out, 0x20), dstOffset), add(add(out, 0x20), srcOffset), length)\n    }\n}\n\ncontract C {\n    function mcopy_to_right_overlap() public pure returns (bytes memory) {\n        return copy(0x20, 0x10, 0x30);\n    }\n\n    function mcopy_to_left_overlap() public pure returns (bytes memory) {\n        return copy(0x10, 0x20, 0x30);\n    }\n\n    function mcopy_in_place() public pure returns (bytes memory) {\n        return copy(0x10, 0x10, 0x40);\n    }\n\n    function mcopy_to_right_no_overlap() public pure returns (bytes memory) {\n        return copy(0x30, 0x10, 0x20);\n    }\n\n    function mcopy_to_left_no_overlap() public pure returns (bytes memory) {\n        return copy(0x10, 0x30, 0x20);\n    }\n}\n// ====\n// EVMVersion: >=cancun\n// ----\n// mcopy_to_right_overlap()    -> 0x20, 0x60, 0x2222222222222222333333333333333344444444444444445555555555555555, 0x4444444444444444555555555555555566666666666666667777777777777777, 0x88888888888888889999999999999999ccccccccccccccccdddddddddddddddd\n// mcopy_to_left_overlap()     -> 0x20, 0x60, 0x2222222222222222333333333333333366666666666666667777777777777777, 0x88888888888888889999999999999999aaaaaaaaaaaaaaaabbbbbbbbbbbbbbbb, 0xaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbccccccccccccccccdddddddddddddddd\n// mcopy_in_place()            -> 0x20, 0x60, 0x2222222222222222333333333333333344444444444444445555555555555555, 0x6666666666666666777777777777777788888888888888889999999999999999, 0xaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbccccccccccccccccdddddddddddddddd\n// mcopy_to_right_no_overlap() -> 0x20, 0x60, 0x2222222222222222333333333333333344444444444444445555555555555555, 0x6666666666666666777777777777777744444444444444445555555555555555, 0x66666666666666667777777777777777ccccccccccccccccdddddddddddddddd\n// mcopy_to_left_no_overlap()  -> 0x20, 0x60, 0x2222222222222222333333333333333388888888888888889999999999999999, 0xaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbb88888888888888889999999999999999, 0xaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbccccccccccccccccdddddddddddddddd\n"
        },
        "truefalse.sol": {
            "content": "contract C {\n    function f() public returns (uint x, uint y) {\n        assembly {\n            x := true\n            y := false\n        }\n    }\n}\n// ----\n// f() -> 1, 0\n"
        },
        "transient_storage_creation.sol": {
            "content": "contract C {\n    constructor() {\n        uint x;\n        assembly {\n            tstore(0, 42)\n            x := tload(0)\n        }\n        assert(x == 42);\n    }\n}\n// ====\n// EVMVersion: >=cancun\n// ----\n// constructor() ->\n"
        },
        "external_identifier_access_shadowing.sol": {
            "content": "contract C {\n    function f() public returns (uint x) {\n        assembly {\n            function g() -> f { f := 2 }\n            x := g()\n        }\n    }\n}\n// ----\n// f() -> 2\n"
        },
        "calldata_offset_read.sol": {
            "content": "contract C {\n    function f(bytes calldata x) public returns (uint r) {\n        assembly { r := x.offset }\n    }\n\n    function f(uint, bytes calldata x, uint) public returns (uint r, uint v) {\n        assembly {\n            r := x.offset\n            v := x.length\n        }\n    }\n}\n// ----\n// f(bytes): 0x20, 0, 0 -> 0x44\n// f(bytes): 0x22, 0, 0, 0 -> 0x46\n// f(uint256,bytes,uint256): 7, 0x60, 8, 2, 0 -> 0x84, 2\n// f(uint256,bytes,uint256): 0, 0, 0 -> 0x24, 0x00\n"
        },
        "calldata_assign.sol": {
            "content": "contract C {\n    function f(bytes calldata x) public returns (bytes memory) {\n        assembly { x.offset := 1 x.length := 3 }\n        return x;\n    }\n}\n// ----\n// f(bytes): 0x20, 0, 0 -> 0x20, 3, 0x5754f80000000000000000000000000000000000000000000000000000000000\n"
        },
        "inline_assembly_embedded_function_call.sol": {
            "content": "contract C {\n    function f() public {\n        assembly {\n            let d:= 0x10\n\n            function asmfun(a, b, c) -> x, y, z {\n                x := g(a)\n                function g(r) -> s {\n                    s := mul(r, r)\n                }\n                y := g(b)\n                z := 7\n            }\n            let a1, b1, c1 := asmfun(1, 2, 3)\n            mstore(0x00, a1)\n            mstore(0x20, b1)\n            mstore(0x40, c1)\n            mstore(0x60, d)\n            return (0, 0x80)\n        }\n    }\n}\n// ----\n// f() -> 0x1, 0x4, 0x7, 0x10\n"
        },
        "constant_access_referencing.sol": {
            "content": "contract C {\n    uint constant a = 2;\n    uint constant aa = a;\n    uint constant aaa = aa;\n    bytes2 constant b = 0xabcd;\n    bytes2 constant bb = b;\n    bytes3 constant c = \"abc\";\n    bytes3 constant cc = c;\n    bytes3 constant ccc = cc;\n    bytes3 constant cccc = ccc;\n    bool constant d = true;\n    bool constant dd = d;\n    address constant e = 0x1212121212121212121212121212121212121212;\n    address constant ee = e;\n    function f() public pure returns (uint w, bytes2 x, bytes3 y, bool z, address t) {\n        assembly {\n            w := aaa\n            x := bb\n            y := cccc\n            z := dd\n            t := ee\n        }\n    }\n}\n// ----\n// f() -> 2, left(0xabcd), left(0x616263), true, 0x1212121212121212121212121212121212121212\n"
        },
        "keccak256_optimizer_bug_different_memory_location.sol": {
            "content": "contract C {\n    function f() public view returns (bool ret) {\n        assembly {\n            let x := calldataload(0)\n            mstore(0, x)\n            mstore(0x20, x)\n            let a := keccak256(0, 4)\n            let b := keccak256(0x20, 8)\n            ret := eq(a, b)\n        }\n    }\n}\n// ----\n// f() -> false\n"
        },
        "external_function_pointer_selector.sol": {
            "content": "contract C {\n\tfunction testFunction() external {}\n\n\tfunction testYul() public returns (uint32) {\n\t\tfunction() external fp = this.testFunction;\n\t\tuint selectorValue = 0;\n\n\t\tassembly {\n\t\t\tselectorValue := fp.selector\n\t\t}\n\n\t\t// Value is right-aligned, we shift it so it can be compared\n\t\treturn uint32(bytes4(bytes32(selectorValue << (256 - 32))));\n\t}\n\tfunction testSol() public returns (uint32) {\n\t\treturn uint32(this.testFunction.selector);\n\t}\n}\n// ----\n// testYul() -> 0xe16b4a9b\n// testSol() -> 0xe16b4a9b\n"
        },
        "inline_assembly_in_modifiers.sol": {
            "content": "contract C {\n    modifier m {\n        uint256 a = 1;\n        assembly {\n            a := 2\n        }\n        if (a != 2) revert();\n        _;\n    }\n\n    function f() public m returns (bool) {\n        return true;\n    }\n\n    modifier n {\n        uint256 a = 1;\n        assembly {\n            a := 2\n        }\n        if (a != 2)\n            _;\n        revert();\n    }\n\n    function g() public n returns (bool) {\n        // This statement should never execute.\n        return true;\n    }\n}\n// ----\n// f() -> true\n// g() -> FAILURE\n"
        },
        "inline_assembly_recursion.sol": {
            "content": "contract C {\n    function f(uint256 a) public returns (uint256 b) {\n        assembly {\n            function fac(n) -> nf {\n                switch n\n                    case 0 {\n                        nf := 1\n                    }\n                    case 1 {\n                        nf := 1\n                    }\n                    default {\n                        nf := mul(n, fac(sub(n, 1)))\n                    }\n            }\n            b := fac(a)\n        }\n    }\n}\n// ----\n// f(uint256): 0 -> 1\n// f(uint256): 1 -> 1\n// f(uint256): 2 -> 2\n// f(uint256): 3 -> 6\n// f(uint256): 4 -> 24\n"
        },
        "calldata_struct_assign.sol": {
            "content": "pragma abicoder v2;\n\ncontract C {\n\tstruct S { uint256 x; }\n\tstruct S2 { uint256 x; uint256 y; }\n\tfunction f(S calldata s, S2 calldata s2) public pure returns (uint256 r, uint256 r2) {\n\t\tassembly {\n\t\t\ts := s2\n\t\t\ts2 := 4\n\t\t}\n\t\tr = s.x;\n\t\tr2 = s2.x;\n\t}\n}\n// ----\n// f((uint256),(uint256,uint256)): 0x42, 0x07, 0x77 -> 0x07, 0x42\n"
        },
        "inline_assembly_function_call.sol": {
            "content": "contract C {\n    function f() public {\n        assembly {\n            function asmfun(a, b, c) -> x, y, z {\n                x := a\n                y := b\n                z := 7\n            }\n            let a1, b1, c1 := asmfun(1, 2, 3)\n            mstore(0x00, a1)\n            mstore(0x20, b1)\n            mstore(0x40, c1)\n            return (0, 0x60)\n        }\n    }\n}\n// ----\n// f() -> 1, 2, 7\n"
        },
        "blobbasefee_shanghai_function.sol": {
            "content": "contract C {\n    function f() public view returns (uint ret) {\n        assembly {\n            let blobbasefee := 999\n            ret := blobbasefee\n        }\n    }\n    function g() public pure returns (uint ret) {\n        assembly {\n            function blobbasefee() -> r {\n                r := 1000\n            }\n            ret := blobbasefee()\n        }\n    }\n}\n// ====\n// EVMVersion: <=shanghai\n// ----\n// f() -> 999\n// g() -> 1000\n"
        },
        "transient_storage_multiple_transactions.sol": {
            "content": "contract C {\n    function set(uint value) private {\n        assembly {\n            tstore(0, value)\n        }\n    }\n\n    function get() private view returns (uint value) {\n        assembly {\n            value := tload(0)\n        }\n    }\n\n    function f() external {\n        assembly {\n            tstore(0, 42)\n        }\n    }\n\n    function g() external view returns(uint r) {\n        assembly {\n            r := tload(0)\n        }\n    }\n\n    function h() external returns (uint x) {\n        set(99);\n        x = get();\n    }\n}\n// ====\n// EVMVersion: >=cancun\n// ----\n// g() -> 0\n// f() ->\n// g() -> 0\n// h() -> 0x63\n// g() -> 0\n"
        },
        "transient_storage_simple_reentrancy_lock.sol": {
            "content": "contract C {\n    modifier nonreentrant {\n        assembly {\n            if tload(0) { revert(0, 0) }\n            tstore(0, 1)\n        }\n        _;\n        assembly {\n            tstore(0, 0)\n        }\n    }\n    function f(bool simulateReentrancy) nonreentrant public {\n        if (simulateReentrancy) {\n            f(false);\n        }\n    }\n}\n// ====\n// EVMVersion: >=cancun\n// ----\n// f(bool): false ->\n// f(bool): true -> FAILURE\n"
        },
        "inline_assembly_switch.sol": {
            "content": "contract C {\n    function f(uint256 a) public returns (uint256 b) {\n        assembly {\n            switch a\n                case 1 {\n                    b := 8\n                }\n                case 2 {\n                    b := 9\n                }\n                default {\n                    b := 2\n                }\n        }\n    }\n}\n// ----\n// f(uint256): 0 -> 2\n// f(uint256): 1 -> 8\n// f(uint256): 2 -> 9\n// f(uint256): 3 -> 2\n"
        },
        "function_name_clash.sol": {
            "content": "contract C {\n  function f() public pure returns (uint r) {\n    assembly { function f() -> x { x := 1 } r := f() }\n  }\n  function g() public pure returns (uint r) {\n    assembly { function f() -> x { x := 2 } r := f() }\n  }\n}\n// ----\n// f() -> 1\n// g() -> 2\n"
        },
        "chainid.sol": {
            "content": "contract C {\n    function f() public returns (uint id) {\n        assembly {\n            id := chainid()\n        }\n    }\n}\n// ====\n// EVMVersion: >=istanbul\n// ----\n// f() -> 1\n"
        },
        "inline_assembly_for2.sol": {
            "content": "contract C {\n    uint256 st;\n\n    function f(uint256 a) public returns (uint256 b, uint256 c, uint256 d) {\n        st = 0;\n        assembly {\n            function sideeffect(r) -> x {\n                sstore(0, add(sload(0), r))\n                x := 1\n            }\n            for {\n                let i := a\n            } eq(i, sideeffect(2)) {\n                d := add(d, 3)\n            } {\n                b := i\n                i := 0\n            }\n        }\n        c = st;\n    }\n}\n// ----\n// f(uint256): 0 -> 0, 2, 0\n// f(uint256): 1 -> 1, 4, 3\n// f(uint256): 2 -> 0, 2, 0\n"
        },
        "transient_storage_selfdestruct.sol": {
            "content": "contract C {\n    function set(uint value) external {\n        assembly {\n            tstore(0, value)\n        }\n    }\n\n    function get() external view returns (uint value) {\n        assembly {\n            value := tload(0)\n        }\n    }\n\n    function terminate(address payable a) external {\n        selfdestruct(a);\n    }\n}\n\ncontract D {\n    C public c;\n\n    constructor() {\n        c = new C();\n    }\n\n    function destroy() external {\n        c.set(42);\n        c.terminate(payable(address(this)));\n        assert(c.get() == 42);\n    }\n\n    function createAndDestroy() external {\n        c = new C();\n        c.set(42);\n        c.terminate(payable(address(this)));\n        assert(c.get() == 42);\n    }\n}\n// ====\n// EVMVersion: >=cancun\n// ----\n// constructor() ->\n// gas irOptimized: 127596\n// gas irOptimized code: 221000\n// gas legacy: 149480\n// gas legacy code: 501200\n// gas legacyOptimized: 125846\n// gas legacyOptimized code: 203400\n// destroy() ->\n// createAndDestroy() ->\n// gas legacy: 67048\n// gas legacy code: 92600\n// gas legacyOptimized: 65677\n// gas legacyOptimized code: 39400\n"
        },
        "external_function_pointer_selector_assignment.sol": {
            "content": "contract C {\n\tfunction testFunction() external {}\n\n\tfunction testYul(uint32 newSelector) view public returns (uint32) {\n\t\tfunction() external fp = this.testFunction;\n\n\t\tassembly {\n\t\t\tfp.selector := newSelector\n\t\t}\n\n\t\treturn uint32(fp.selector);\n\t}\n}\n// ----\n// testYul(uint32): 0x12345678 -> 0x12345678\n// testYul(uint32): 0xABCDEF00 -> 0xABCDEF00\n"
        },
        "transient_storage_multiple_calls_different_transactions.sol": {
            "content": "contract C {\n    function get(uint256 addr) external view returns (uint256 x) {\n        assembly {\n            x := tload(addr)\n        }\n    }\n    function set(uint256 addr, uint256 x) external {\n        assembly {\n            tstore(addr, x)\n        }\n    }\n    function test() public {\n        assert(this.get(0) == 0 && this.get(42) == 0);\n        this.set(0, 21);\n        assert(this.get(0) == 21 && this.get(42) == 0);\n        this.set(42, 131);\n        assert(this.get(0) == 21 && this.get(42) == 131);\n    }\n}\n// ====\n// EVMVersion: >=cancun\n// ----\n// test() ->\n// test() ->\n"
        },
        "calldata_array_assign_static.sol": {
            "content": "contract C {\n    function f(uint[2][2] calldata x) public returns (uint[2][2] memory r) {\n        assembly { x := 0x24 }\n        r = x;\n    }\n}\n// ----\n// f(uint256[2][2]): 0x0, 8, 7, 6, 5 -> 8, 7, 6, 5\n"
        },
        "blobhash.sol": {
            "content": "contract C {\n    function f() public view returns (bytes32 ret) {\n        assembly {\n            ret := blobhash(0)\n        }\n    }\n}\n// ====\n// EVMVersion: >=cancun\n// ----\n// f() -> 0x0100000000000000000000000000000000000000000000000000000000000001\n"
        },
        "inline_assembly_storage_access.sol": {
            "content": "contract C {\n    uint16 x;\n    uint16 public y;\n    uint256 public z;\n\n    function f() public returns (bool) {\n        uint256 off1;\n        uint256 off2;\n        assembly {\n            sstore(z.slot, 7)\n            off1 := z.offset\n            off2 := y.offset\n        }\n        assert(off1 == 0);\n        assert(off2 == 2);\n        return true;\n    }\n}\n// ----\n// f() -> true\n// z() -> 7\n"
        },
        "prevrandao.sol": {
            "content": "contract C {\n    function f() public view returns (uint ret) {\n        assembly {\n            ret := prevrandao()\n        }\n    }\n}\n// ====\n// EVMVersion: >=paris\n// ----\n// f() -> 0xa86c2e601b6c44eb4848f7d23d9df3113fbcac42041c49cbed5000cb4f118777\n"
        },
        "mcopy_as_identifier_pre_cancun.sol": {
            "content": "contract C {\n    function f() public pure returns (uint result) {\n        assembly {\n            let mcopy := 1\n            result := mcopy\n        }\n    }\n\n    function g() public pure returns (uint result) {\n        assembly {\n            function mcopy() -> r {\n                r := 1000\n            }\n            result := mcopy()\n        }\n    }\n}\n// ====\n// EVMVersion: <cancun\n// ----\n// f() -> 1\n// g() -> 1000\n"
        },
        "constant_access.sol": {
            "content": "contract C {\n    uint constant a = 2;\n    bytes2 constant b = 0xabcd;\n    bytes3 constant c = \"abc\";\n    bool constant d = true;\n    address constant e = 0x1212121212121212121212121212121212121212;\n    function f() public pure returns (uint w, bytes2 x, bytes3 y, bool z, address t) {\n        assembly {\n            w := a\n            x := b\n            y := c\n            z := d\n            t := e\n        }\n    }\n}\n// ----\n// f() -> 2, left(0xabcd), left(0x616263), true, 0x1212121212121212121212121212121212121212\n"
        },
        "calldata_assign_from_nowhere.sol": {
            "content": "contract C {\n    function f() public pure returns (bytes calldata x) {\n        assembly { x.offset := 0 x.length := 4 }\n    }\n}\n// ----\n// f() -> 0x20, 4, 0x26121ff000000000000000000000000000000000000000000000000000000000\n"
        },
        "transient_storage_low_level_calls.sol": {
            "content": "contract D {\n    function addOne() external {\n        assembly {\n            let x := tload(0)\n            tstore(0, add(x, 1))\n        }\n    }\n    function get() external returns (uint x) {\n        assembly {\n            x := tload(0)\n        }\n    }\n}\n\ncontract C {\n    function set(uint x) external {\n        assembly {\n            tstore(0, x)\n        }\n    }\n\n    function get() external view returns (uint x) {\n        assembly {\n            x := tload(0)\n        }\n    }\n\n    function testDelegateCall() external returns (bool) {\n        this.set(5);\n        D d = new D();\n        // Caller contract is the owner of the transient storage\n        (bool success, ) = address(d).delegatecall(abi.encodeCall(d.addOne, ()));\n        require(success);\n        require(this.get() == 6);\n        return true;\n    }\n\n    function testCall() external returns (bool) {\n        this.set(5);\n        D d = new D();\n        // Callee/Target contract is the owner of the transient storage\n        (bool success, ) = address(d).call(abi.encodeCall(d.addOne, ()));\n        require(success);\n        require(d.get() == 1);\n        return true;\n    }\n\n    function tloadAllowedStaticCall() external returns (bool) {\n        this.set(5);\n        D d = new D();\n        (bool success, bytes memory result) = address(d).staticcall(abi.encodeCall(d.get, ()));\n        require(success);\n        require(abi.decode(result, (uint)) == 0);\n        return true;\n    }\n\n    function tstoreNotAllowedStaticCall() external returns (bool) {\n        D d = new D();\n        (bool success, ) = address(d).staticcall(abi.encodeCall(d.addOne, ()));\n        require(!success);\n        return true;\n    }\n}\n// ====\n// EVMVersion: >=cancun\n// ----\n// testDelegateCall() -> true\n// testCall() -> true\n// tloadAllowedStaticCall() -> true\n// tstoreNotAllowedStaticCall() -> true\n// gas irOptimized: 98419720\n// gas irOptimized code: 19000\n// gas legacy: 98409086\n// gas legacy code: 30000\n// gas legacyOptimized: 98420962\n// gas legacyOptimized code: 17800\n"
        },
        "keccak256_assembly.sol": {
            "content": "contract C {\n    function f() public pure returns (bytes32 ret) {\n        assembly {\n            ret := keccak256(0, 0)\n        }\n    }\n}\n// ----\n// f() -> 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\n"
        },
        "inline_assembly_function_call2.sol": {
            "content": "contract C {\n    function f() public {\n        assembly {\n            let d := 0x10\n\n            function asmfun(a, b, c) -> x, y, z {\n                x := a\n                y := b\n                z := 7\n            }\n            let a1, b1, c1 := asmfun(1, 2, 3)\n            mstore(0x00, a1)\n            mstore(0x20, b1)\n            mstore(0x40, c1)\n            mstore(0x60, d)\n            return (0, 0x80)\n        }\n    }\n}\n// ----\n// f() -> 0x1, 0x2, 0x7, 0x10\n"
        },
        "basefee_berlin_function.sol": {
            "content": "contract C {\n    function f() public view returns (uint ret) {\n        assembly {\n            let basefee := sload(0)\n            ret := basefee\n        }\n    }\n    function g() public pure returns (uint ret) {\n        assembly {\n            function basefee() -> r {\n                r := 1000\n            }\n            ret := basefee()\n        }\n    }\n}\n// ====\n// EVMVersion: <=berlin\n// ----\n// f() -> 0\n// g() -> 1000\n"
        },
        "optimize_memory_store_multi_block_bugreport.sol": {
            "content": "contract Test {\n\tuint256 x;\n\n\tfunction test() public returns (uint256) {\n\t\tuint256 a = myGetX();\n\t\tx = 5;\n\t\tuint256 b = myGetX();\n\t\tassembly {\n\t\t\tlog0(0, 64)\n\t\t}\n\t\treturn a + b + myGetX();\n\t}\n\n\tfunction myGetX() internal view returns (uint256) {\n\t\tassembly {\n\t\t\tmstore(1, 0x123456789abcdef)\n\t\t}\n\t\treturn x;\n\t}\n}\n// ----\n// test() -> 10\n// ~ emit <anonymous>: 0x0123456789abcd, 0xef00000000000000000000000000000000000000000000000000000000000000\n"
        },
        "inline_assembly_transient_storage_access_inside_function.sol": {
            "content": "contract C {\n    uint16 transient x;\n    uint16 public transient y;\n    uint256 public transient z;\n\n    function f() public returns (uint256) {\n        uint256 offset;\n        assembly {\n            function f() -> o1 {\n                tstore(z.slot, 7)\n                o1 := y.offset\n            }\n            offset := f()\n        }\n        assert(offset == 2);\n        return z;\n    }\n}\n// ====\n// EVMVersion: >=cancun\n// ----\n// f() -> 7\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "metadata",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ]
            }
        }
    }
}