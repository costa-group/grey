{"language": "Solidity", "sources": {"@openzeppelin/contracts/access/Ownable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"}, "@openzeppelin/contracts/security/ReentrancyGuard.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"}, "@openzeppelin/contracts/utils/Context.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"}, "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proofLen - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            require(proofPos == proofLen, \"MerkleProof: invalid multiproof\");\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proofLen - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            require(proofPos == proofLen, \"MerkleProof: invalid multiproof\");\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"}, "contracts/DelegateCashEnabled.sol": {"content": "//SPDX-License-Identifier: MIT\n/**\n * @title DelegateCashEnabled\n * @author @brougkr\n * @notice For Easily Integrating `delegate.cash`\n */\npragma solidity ^0.8.30;\nabstract contract DelegateCashEnabled\n{\n    address private constant _DN = 0x00000000000076A84feF008CDAbe6409d2FE638B;\n    IDelegation public constant DelegateCash = IDelegation(_DN);\n}\n\ninterface IDelegation\n{\n    /**\n     * @dev Returns If A Vault Has Delegated To The Delegate\n     */\n    function checkDelegateForAll(address delegate, address vault) external view returns (bool);\n}"}, "contracts/IMinter.sol": {"content": "// SPDX-License-Identifier: MIT\n/**\n * @title IMinter Minter Interface\n * @author @brougkr\n */\npragma solidity ^0.8.30;\ninterface IMinter \n{ \n    function purchase(uint256 _projectId) payable external returns (uint tokenID); // Custom\n    function purchaseTo(address _to, uint _projectId) payable external returns (uint tokenID); // ArtBlocks Standard Minter\n    // function purchaseTo(address _to) external returns (uint tokenID); // Custom\n    // function purchaseTo(address _to, uint _projectId, address _ownedNFTAddress, uint _ownedNFTTokenID) payable external returns (uint tokenID); // ArtBlocks PolyMinter\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\n    function _MintToFactory(uint ProjectID, address To, uint Amount) external; // MintPassFactory\n    function _MintToFactory(address To, uint Amount) external; // MintPassBespoke\n}\n"}, "contracts/Marketplace.sol": {"content": "//SPDX-License-Identifier: MIT\n/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\n/**\n * @dev: @brougkr\n */\npragma solidity ^0.8.30;\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { MerkleProof } from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IMinter } from \"./IMinter.sol\";\nimport { DelegateCashEnabled } from \"./DelegateCashEnabled.sol\";\ncontract Marketplace is Ownable, ReentrancyGuard, DelegateCashEnabled\n{\n    struct SaleTypeFixedPrice\n    {\n        string _Name;                 // [0] -> _Name\n        uint _Price;                  // [1] -> _Price\n        uint _MintPassProjectID;      // [2] -> _MintPassProjectID\n        uint _Type;                   // [3] -> _Type (The Type Of Sale) (Must Be Configured To One Of The Following Options)\n                                      // { ----------------------------------------------- }\n                                      // |  0 = _MintToFactory() Single Mint               |\n                                      // |  1 = _MintToFactory() Mint Pack                 |\n                                      // |  2 = _LiveMintMarketplace() Single Mint         |\n                                      // |  3 = _LiveMintMarketplace() Mint Pack           |\n                                      // |  4 = purchaseTo() ArtBlocks Direct Sale         |\n                                      // |  5 = transferFrom() Already-Minted ERC721 Sale  |\n                                      // |  6 = purchaseTo() ArtBlocks Direct Sale /w ETH  |\n                                      // { ----------------------------------------------- }\n        uint _MinterProjectID;        // [4] -> _MinterProjectID (ArtBlocks or LiveMint)\n        uint _AmountForSale;          // [5] -> _AmountForSale\n        uint _TimestampStart;         // [6] -> _TimestampStart\n        uint _CurrentIndex;           // [7] -> _CurrentIndex\n        uint _BatchPurchaseAmount;    // [8] -> _BatchPurchaseAmount (Transfer Amount Per Purchase) (MintPack or Direct Mint)\n        address _NFT;                 // [9] -> _NFT\n        address _Operator;            // [10] -> _Operator\n        bytes32[] _RootEligibilities; // [11] -> _RootEligibilities\n        bytes32[] _RootAmounts;       // [12] -> _RootAmounts\n        uint[] _LiveMintProjectIDs;   // [13] -> _LiveMintProjectIDs\n    }\n\n    struct FixedPriceSaleInfo\n    {\n        string _Name;                        // [0] -> _Price\n        uint _Price;                         // [1] -> _Price\n        uint _MintPassProjectID;             // [2] -> _MintPassProjectID\n        uint _Type;                          // [3] -> _Type (The Type Of Sale) (Must Be Configured To One Of These Options)\n                                             // { ----------------------------------------------- }\n                                             // |  0 = _MintToFactory() Single Mint               |\n                                             // |  1 = _MintToFactory() Mint Pack                 |\n                                             // |  2 = _LiveMintMarketplace() Single Mint         |\n                                             // |  3 = _LiveMintMarketplace() Mint Pack           |\n                                             // |  4 = purchaseTo() ArtBlocks Direct Sale         |\n                                             // |  5 = transferFrom() Already-Minted ERC721 Sale  |\n                                             // |  6 = purchaseTo() ArtBlocks Direct Sale /w ETH  |\n                                             // { ----------------------------------------------- }\n        uint _MinterProjectID;               // [4] -> _MinterProjectID (ArtBlocks or LiveMint)\n        uint _AmountForSale;                 // [5] -> _AmountForSale\n        uint _TimestampStart;                // [6] -> _TimestampStart\n        uint _CurrentIndex;                  // [7] -> _CurrentIndex\n        uint _BatchPurchaseAmount;           // [8] -> _BatchPurchaseAmount (Transfer Amount Per Purchase)\n        address _NFT;                        // [9] -> _NFT\n        address _Operator;                   // [10] -> _Operator\n        bytes32[] _RootEligibilities;        // [11] -> _RootEligibilities\n        bytes32[] _RootAmounts;              // [12] -> _RootAmounts\n        uint[] _LiveMintProjectIDs;          // [13] -> _LiveMintProjectIDs\n        uint[] _DiscountAmountWEIValues;     // [14] -> _DiscountAmountWEIValues\n        uint _ETHRevenue;                    // [15] -> _ETHRevenue\n        uint _AmountRemaining;               // [16] -> _AmountRemaining\n        uint _Priority;                      // [17] -> _Priority\n        uint _AmountRemainingMerklePriority; // [18] -> _AmountRemainingMerklePriority\n        uint _AmountPurchasedUser;           // [19] -> _AmountPurchasedUser\n        bool _BrightListEligible;            // [20] -> _BrightListEligible\n        bool _BrightListAmounts;             // [21] -> _BrightListAmounts\n    }\n    \n    struct SaleTypePresale \n    {\n        string _Name;              // [0] -> _Name\n        address _Operator;         // [1] -> _Operator\n        address _NFT;              // [2] -> _NFT\n        uint _MaxForSale;          // [3] -> _MaxForSale\n        uint _MaxPerPurchase;      // [4] -> _MaxPerPurchase\n        uint _PricePresale;        // [5] -> _PricePresale\n        uint _PricePublic;         // [6] -> _PricePublic\n        uint _TimestampEndFullSet; // [7] -> _TimestampEndFullSet\n        uint _TimestampEndCitizen; // [8] -> _TimestampEndCitizen\n        uint _TimestampSaleStart;  // [9] -> _TimestampSaleStart\n        uint _Type;                // [10] -> _Type\n        uint _ProjectID;           // [11] -> _ProjectID\n    }\n\n    struct InternalPresaleSale\n    {\n        bool _Active;                 // [0] -> _Active\n        uint _AmountSold;             // [1] -> _AmountSold\n        uint _ETHRevenue;             // [2] -> _ETHRevenue\n        uint _GlobalPurchasesFullSet; // [3] -> _GlobalPurchasesFullSet\n        uint _GlobalPurchasesCitizen; // [4] -> _GlobalPurchasesCitizen\n        uint _GlobalPurchasesPublic;  // [5] -> _GlobalPurchasesPublic\n        uint _CurrentTokenIndex;      // [6] -> _CurrentTokenIndex\n        uint _AmountSoldFullSet;      // [7] -> _AmountSoldFullSet\n        uint _AmountSoldCitizen;      // [8] -> _AmountSoldCitizen\n        uint _AmountSoldPublic;       // [9] -> _AmountSoldPublic\n    }\n\n    struct InternalPresaleSaleRoots\n    {\n        bytes32 _RootEligibilityFullSet; // [0] -> _RootEligibilityFullSet\n        bytes32 _RootEligibilityCitizen; // [1] -> _RootEligibilityCitizen\n        bytes32 _RootAmountFullSet;      // [2] -> _RootAmountFullSet\n        bytes32 _RootAmountCitizen;      // [3] -> _RootAmountCitizen\n    }\n\n    struct InternalPresaleWalletInfo    \n    {\n        uint _AmountPurchasedFullSetWindow; // [0] -> _AmountPurchasedFullSetWindow\n        uint _AmountPurchasedCitizenWindow; // [1] -> _AmountPurchasedCitizenWindow\n        uint _AmountPurchasedWallet;        // [2] -> _AmountPurchasedWallet\n    }\n\n    struct SaleInfoPresale\n    {\n        uint _ETHRevenue;                   // [0] -> _ETHRevenue\n        uint _PricePresale;                 // [1] -> _PricePresale\n        uint _PricePublic;                  // [2] -> _PricePublic\n        uint _MaxForSale;                   // [3] -> _MaxForSale\n        uint _AmountRemaining;              // [4] -> _AmountRemaining\n        uint _TimestampEndFullSet;          // [5] -> _TimestampEndFullSet\n        uint _TimestampEndCitizen;          // [6] -> _TimestampEndCitizen\n        uint _TimestampSaleStart;           // [7] -> _TimestampSaleStart\n        uint _AmountPurchasableFullSet;     // [8] -> _AmountPurchasableFullSet\n        uint _AmountPurchasableCitizen;     // [9] -> _AmountPurchasableCitizen\n        uint _AmountPurchasedFullSetWindow; // [10] -> _AmountPurchasedFullSetWindow\n        uint _AmountPurchasedCitizenWindow; // [11] -> _AmountPurchasedCitizenWindow\n        uint _GlobalPurchasesFullSet;       // [12] -> _GlobalPurchasesFullSet\n        uint _GlobalPurchasesCitizen;       // [13] -> _GlobalPurchasesCitizen\n        uint _GlobalPurchasesPublic;        // [14] -> _GlobalPurchasesPublic\n        uint _AmountPurchasedWallet;        // [15] -> _AmountPurchasedWallet\n        bool _EligibleFullSet;              // [16] -> _EligibleFullSet\n        bool _EligibleCitizen;              // [17] -> _EligibleCitizen\n        bool _ValidMaxAmountFullSet;        // [18] -> _ValidMaxAmountFullSet\n        bool _ValidMaxAmountCitizen;        // [19] -> _ValidMaxAmountCitizen\n    }\n\n    /*------------------\n     * STATE VARIABLES *\n    -------------------*/\n\n    uint public _TOTAL_UNIQUE_PRESALE_SALES; // Total Unique Presale Sales                \n    uint public _TOTAL_UNIQUE_FIXED_SALES; // Total Unique Fixed Price Sales\n    address private constant _BRT_MULTISIG = 0x0BC56e3c1397e4570069e89C07936A5c6020e3BE; // `sales.brightmoments.eth`a\n    \n    /*-----------\n     * MAPPINGS *\n    ------------*/\n\n    mapping(uint=>SaleTypeFixedPrice) public FixedPriceSales;                                 // [SaleIndex] -> SaleTypeFixedPrice\n    mapping(uint=>SaleTypePresale) public PresaleSales;                                       // [SaleIndex] -> SaleTypePresale\n    mapping(uint=>InternalPresaleSale) public PresaleSalesInternal;                           // [SaleIndex] -> InternalPresaleSale\n    mapping(uint=>uint) public AmountSoldFixedPrice;                                          // [SaleIndex] -> Amount Sold\n    mapping(uint=>uint[]) public DiscountAmounts;                                             // [SaleIndex] -> Discount Amounts\n    mapping(uint=>InternalPresaleSaleRoots) public InternalRoots;                             // [SaleIndex] -> InternalPresaleSaleRoots\n    mapping(uint=>mapping(address=>InternalPresaleWalletInfo)) public InternalSaleWalletInfo; // [SaleIndex][Wallet] -> InternalPresaleWalletInfo\n    mapping(uint=>uint) public ETHRevenueFixedPriceSale;                                      // [SaleIndex] -> ETH Amount\n    mapping(uint=>uint) public ETHRevenueWithdrawn;                                           // [SaleIndex] -> ETH Amount Withdrawn\n    mapping(uint=>mapping(address=>mapping(uint=>uint))) public PriorityPurchaseAmount;       // [SaleIndex][Wallet][Priority] => Purchased Amount For Priority Level\n    mapping(address=>bool) public Admin;                                                      // [Address] -> Admin Status\n    mapping(uint=>mapping(address=>uint)) public UserPurchasedAmount;                         // [SaleIndex][Wallet] -> Purchased Amount\n\n    /*---------\n     * EVENTS *\n    ----------*/\n\n    event PurchasedPresale(uint SaleIndex, address Purchaser, uint DesiredAmount, uint MessageValue, bool PresaleEnded);    \n    event SaleStarted(uint SaleIndex);\n    event Refunded(address Refundee, uint Amount);\n    event Purchased(uint SaleIndex, address Purchaser, uint Amount, uint Priority);\n    event Fullset();\n    event Citizen();\n    event Public();\n\n    constructor() \n    { \n        Admin[msg.sender] = true; \n        Admin[0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700] = true;\n        Admin[0x90D98d5A1fD21B7cEa4D5c18341607ed1a8345c0] = true;\n        Admin[0x18B7511938FBe2EE08ADf3d4A24edB00A5C9B783] = true;\n        _transferOwnership(0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700);\n    }\n\n    /*---------------------\n     * EXTERNAL FUNCTIONS *\n    ----------------------*/\n\n    /**\n     * @dev Purchases One Fixed Price Sale\n     * @param SaleIndex The Sale Index To Purchase\n     * @param DesiredAmount The Desired Amount To Purchase\n     * @param MaxAmount The Maximum Merkle Priority To Purchase\n     * @param Vault Delegate Vault Address\n     * @param ProofEligibility Merkle Proof For Eligibility\n     * @param ProofAmount Merkle Proof For MaxAmount\n     */\n    function PurchaseFixedPrice (\n        uint SaleIndex,\n        uint DesiredAmount,\n        uint MaxAmount,\n        address Vault,\n        bytes32[] calldata ProofEligibility,\n        bytes32[] calldata ProofAmount\n    ) external payable nonReentrant {\n        __FinalizeFixedPriceSale(\n            SaleIndex, \n            DesiredAmount, \n            MaxAmount, \n            Vault, \n            ProofEligibility, \n            ProofAmount, \n            msg.value,\n            msg.sender\n        );\n    }\n\n    /**\n     * @dev Purchases Multiple Fixed Price Sales\n     * @param SaleIndexes The Sale Indexes To Purchase\n     * @param DesiredAmounts The Desired Amounts To Purchase\n     * @param MaxAmounts The Maximum Merkle Priority To Purchase\n     * @param Vaults Delegate Vault Addresses\n     * @param ProofEligibilities Merkle Proofs For Eligibility\n     * @param ProofAmounts Merkle Proofs For MaxAmount\n     * @param MessageValues The Amounts To Purchase Per Sale\n     */\n    function PurchaseFixedPriceMulti (\n        uint[] calldata SaleIndexes,\n        uint[] calldata DesiredAmounts,\n        uint[] calldata MaxAmounts,\n        address[] calldata Vaults,\n        bytes32[][] calldata ProofEligibilities,\n        bytes32[][] calldata ProofAmounts,\n        uint[] calldata MessageValues\n    ) external payable nonReentrant {\n        uint MessageValueSum;\n        require(\n            SaleIndexes.length == DesiredAmounts.length \n            &&\n            DesiredAmounts.length == MaxAmounts.length\n            &&\n            MaxAmounts.length == Vaults.length\n            &&\n            Vaults.length == ProofEligibilities.length\n            &&\n            ProofEligibilities.length == ProofAmounts.length\n            && \n            ProofAmounts.length == MessageValues.length,\n            \"Marketplace: Incorrect Array Lengths\"\n        );\n        for(uint x; x < SaleIndexes.length; x++)\n        {\n            __FinalizeFixedPriceSale(\n                SaleIndexes[x], \n                DesiredAmounts[x], \n                MaxAmounts[x], \n                Vaults[x], \n                ProofEligibilities[x], \n                ProofAmounts[x],\n                MessageValues[x],\n                msg.sender\n            );\n            MessageValueSum += MessageValues[x];\n        }\n        require(MessageValueSum == msg.value, \"Marketplace: `msg.value` & `MessageValues` Input Incorrect\");\n    }\n\n    /**\n     * @dev Presale Purchase\n     * @param SaleIndex The Sale Index To Purchase\n     * @param DesiredAmount The Desired Amount To Purchase\n     * @param MaxAmount The Maximum Amount For Merkle Priority Purchase\n     * @param Vault Delegate Vault Address\n     * @param ProofEligibility Merkle Proof For Eligibility\n     * @param ProofAmount Merkle Proof For MaxAmount\n     */\n    function PurchasePresale (\n        uint SaleIndex,                      \n        uint DesiredAmount,                  \n        uint MaxAmount,                      \n        address Vault,                       \n        bytes32[] calldata ProofEligibility, \n        bytes32[] calldata ProofAmount \n    ) external payable nonReentrant {\n        __FinalizePresale(\n            SaleIndex, \n            DesiredAmount, \n            MaxAmount, \n            Vault, \n            ProofEligibility, \n            ProofAmount,\n            msg.value,\n            msg.sender\n        );\n    }\n\n    /*------------------\n     * ADMIN FUNCTIONS *\n    -------------------*/\n\n    /**\n     * @dev Instantiates A New Presale Sale\n     * @param _Sale The Presale Sale Struct\n     * @param _Roots The Presale Sale Roots Struct\n     */\n    function __StartPresaleSale(SaleTypePresale memory _Sale, InternalPresaleSaleRoots memory _Roots) external onlyAdmin \n    {\n        PresaleSales[_TOTAL_UNIQUE_PRESALE_SALES] = _Sale; \n        PresaleSalesInternal[_TOTAL_UNIQUE_PRESALE_SALES]._Active = true;\n        InternalRoots[_TOTAL_UNIQUE_PRESALE_SALES] = _Roots;\n        emit SaleStarted(_TOTAL_UNIQUE_PRESALE_SALES);\n        _TOTAL_UNIQUE_PRESALE_SALES++;\n    }\n\n    /**\n     * @dev Overwrites A Presale Sale\n     * @param SaleIndex The Sale Index To Edit\n     * @param _Sale The Fixed Price Sale Struct\n     */\n    function __OverwritePresaleSale(uint SaleIndex, SaleTypePresale memory _Sale) external onlyAdmin { PresaleSales[SaleIndex] = _Sale; }\n    \n    /**\n     * @dev Changes The Presale Sale Type\n     * @param SaleIndex The Sale Index To Edit\n     * @param Type The Sale Type (0 = _MintToFactory() | 1 = purchaseTo() | 2 = transferFrom())\n     */\n    function __ChangePresaleType(uint SaleIndex, uint Type) external onlyAdmin\n    {\n        PresaleSales[SaleIndex]._Type = Type;\n    }\n\n    /**\n     * @dev Changes Presale ArtBlocks ProjectID\n     * @param SaleIndex The Sale Index To Edit\n     * @param ProjectID ArtBlocks ProjectID\n     */\n    function __ChangePresaleProjectID(uint SaleIndex, uint ProjectID) external onlyAdmin\n    {\n        PresaleSales[SaleIndex]._ProjectID = ProjectID;\n    }\n\n    /**\n     * @dev Changes Presale Times\n     * @param SaleIndex The Sale Index To Edit\n     * @param TimestampSaleStart The Unix Timestamp For Sale Start\n     * @param TimestampFullSetEnd The Unix Timestamp When Full Set Window Ends\n     * @param TimestampCitizenEnd The Unix Timestamp When Citizen Window Ends (Public Begins)\n     */\n    function __ChangePresaleTimes (\n        uint SaleIndex,\n        uint TimestampSaleStart,\n        uint TimestampFullSetEnd,\n        uint TimestampCitizenEnd\n    ) external onlyAdmin {\n        PresaleSales[SaleIndex]._TimestampSaleStart = TimestampSaleStart;\n        PresaleSales[SaleIndex]._TimestampEndFullSet = TimestampFullSetEnd;\n        PresaleSales[SaleIndex]._TimestampEndCitizen = TimestampCitizenEnd;\n    }\n\n    /**\n     * @dev Changes All Presale Roots\n     * @param SaleIndex The Sale Index To Edit\n     * @param RootEligibilityFullSet The Merkle Eligibility Root For Full Set\n     * @param RootAmountsFullSet The Merkle Amounts Root For Full Set\n     * @param RootEligibilityCitizen The Merkle Eligibility Root For Citizens\n     * @param RootAmountsCitizen The Merkle Amounts Root For Citizens\n     */\n    function __ChangePresaleRootsAll (\n        uint SaleIndex,\n        bytes32 RootEligibilityFullSet,\n        bytes32 RootAmountsFullSet,\n        bytes32 RootEligibilityCitizen,\n        bytes32 RootAmountsCitizen\n    ) external onlyAdmin { \n        InternalRoots[SaleIndex]._RootEligibilityFullSet = RootEligibilityFullSet;\n        InternalRoots[SaleIndex]._RootEligibilityCitizen = RootEligibilityCitizen;\n        InternalRoots[SaleIndex]._RootAmountFullSet = RootAmountsFullSet;\n        InternalRoots[SaleIndex]._RootAmountCitizen = RootAmountsCitizen;\n    }\n\n    /**\n     * @dev Changes The Presale Roots For Merkle Eligibility\n     * @param SaleIndex The Sale Index To Edit\n     * @param RootCitizen The Merkle Eligibility Root For Citizens\n     * @param RootFullSet The Merkle Eligibility Root For Full Set Holders\n     */\n    function __ChangePresaleRootsEligibility (\n        uint SaleIndex, \n        bytes32 RootCitizen,\n        bytes32 RootFullSet\n    ) external onlyAdmin {\n        InternalRoots[SaleIndex]._RootEligibilityCitizen = RootCitizen;\n        InternalRoots[SaleIndex]._RootEligibilityFullSet = RootFullSet;\n    }\n\n    /**\n     * @dev Changes The Presale Roots For Merkle Amounts\n     * @param SaleIndex The Sale Index To Edit\n     * @param RootCitizen The Merkle Amount Root For Citizens\n     * @param RootFullSet The Merkle Amount Root For Full Set Holders\n     */\n    function __ChangePresaleRootsAmounts (\n        uint SaleIndex,\n        bytes32 RootCitizen,\n        bytes32 RootFullSet\n    ) external onlyAdmin {\n        InternalRoots[SaleIndex]._RootAmountCitizen = RootCitizen;\n        InternalRoots[SaleIndex]._RootAmountFullSet = RootFullSet;\n    }\n\n    /**\n     * @dev Changes Presale Sale Max For Sale\n     * @param SaleIndex The Sale Index To Edit\n     * @param MaxForSale The Total Amount For Sale\n     */\n    function __ChangePresaleSaleMaxForSale(uint SaleIndex, uint MaxForSale) external onlyAdmin \n    {   \n        require(PresaleSalesInternal[SaleIndex]._Active, \"Marketplace: Sale Not Active\");\n        PresaleSales[SaleIndex]._MaxForSale = MaxForSale; \n    }\n\n    /**\n     * @dev Change Presale Sale Max Per Purchase\n     * @param SaleIndex The Sale Index To Edit\n     * @param MaxPerPurchase The Maximum Purchase Amount Per Transaction\n     */\n    function __ChangePresaleSaleMaxPerPurchase(uint SaleIndex, uint MaxPerPurchase) external onlyAdmin \n    {   \n        require(PresaleSalesInternal[SaleIndex]._Active, \"Marketplace: Sale Not Active\");\n        PresaleSales[SaleIndex]._MaxPerPurchase = MaxPerPurchase; \n    }\n\n    /**\n     * @dev Changes Presale Sale Mint Pass Price\n     * @param SaleIndex The Sale Index To Edit\n     * @param Price The Sale Presale Price Input In WEI\n     */\n    function __ChangePresaleSalePresalePrice(uint SaleIndex, uint Price) external onlyAdmin \n    {   \n        require(PresaleSalesInternal[SaleIndex]._Active, \"Marketplace: Sale Not Active\");\n        PresaleSales[SaleIndex]._PricePresale = Price; \n    }\n\n    /**\n     * @dev Changes Presale Sale Public Price\n     * @param SaleIndex The Sale Index To Edit\n     * @param Price The Sale Public Price Input In WEI\n     */\n    function __ChangePresaleSalePublicPrice(uint SaleIndex, uint Price) external onlyAdmin \n    {   \n        require(PresaleSalesInternal[SaleIndex]._Active, \"Marketplace: Sale Not Active\");\n        PresaleSales[SaleIndex]._PricePublic = Price; \n    }\n\n    /**\n     * @dev Changes Timestamp End Full Set\n     * @param SaleIndex The Sale Index To Edit\n     * @param Timestamp The Unix Timestamp Of The End Of Full Set Window (1st Priority)\n     */\n    function __ChangePresaleSaleEndFullSet(uint SaleIndex, uint Timestamp) external onlyAdmin \n    {   \n        require(PresaleSalesInternal[SaleIndex]._Active, \"Marketplace: Sale Not Active\");\n        PresaleSales[SaleIndex]._TimestampEndFullSet = Timestamp; \n    }\n\n    /**\n     * @dev Changes Timestamp End Citizen\n     * @param SaleIndex The Sale Index To Edit\n     * @param Timestamp The Unix Timestamp Of The End Of Citizen Window (2nd Priority)\n     */\n    function __ChangePresaleSaleEndCitizen(uint SaleIndex, uint Timestamp) external onlyAdmin\n    {\n        require(PresaleSalesInternal[SaleIndex]._Active, \"Marketplace: Sale Not Active\");\n        PresaleSales[SaleIndex]._TimestampEndCitizen = Timestamp; \n    }\n\n    /**\n     * @dev Changes Timestamp Sale Start\n     * @param SaleIndex The Sale Index To Edit\n     * @param Timestamp The Unix Timestamp For Sale Start\n     */\n    function __ChangePresaleSaleStart(uint SaleIndex, uint Timestamp) external onlyAdmin\n    {\n        require(PresaleSalesInternal[SaleIndex]._Active, \"Marketplace: Sale Not Active\");\n        PresaleSales[SaleIndex]._TimestampSaleStart = Timestamp; \n    }\n\n    /**\n     * @dev Changes Presale Sale Full Set Root\n     * @param SaleIndex The Sale Index To Edit\n     * @param RootFullSet The Full Set Priority Root\n     */\n    function __ChangePresaleSaleRootFullSet(uint SaleIndex, bytes32 RootFullSet) external onlyAdmin \n    { \n        InternalRoots[SaleIndex]._RootEligibilityFullSet = RootFullSet; \n    }\n\n    /**\n     * @dev Changes Presale Sale Citizen Root\n     * @param SaleIndex The Sale Index To Edit\n     * @param RootCitizen The Citizen Priority Root\n     */\n    function __ChangePresaleSaleRootCitizen(uint SaleIndex, bytes32 RootCitizen) external onlyAdmin\n    {\n        InternalRoots[SaleIndex]._RootAmountCitizen = RootCitizen; \n    }\n\n    /**\n     * @dev Initializes A Sale Via A Struct\n     * @param _Sale The Sale Struct\n     * @param Discounts The Array Of Discount Amounts ([80,90] = [20%,10%]) Discounts\n     */\n    function __StartFixedPriceSale (\n        SaleTypeFixedPrice memory _Sale, \n        uint[] calldata Discounts\n    ) external onlyAdmin returns (uint SaleIndex) { return __FixedPriceSaleInit(_Sale, Discounts); }\n\n    /**\n     * @dev Starts Multiple Fixed Price Sales\n     * @param _Sales The Sale Struct\n     * @param Discounts The Array Of Discount Amounts ([80,90] = [20%,10%]) Discounts\n     */\n    function __StartFixedPriceSales (\n        SaleTypeFixedPrice[] memory _Sales,\n        uint[][] calldata Discounts\n    ) external onlyAdmin returns (uint[] memory SaleIndexes) {\n        SaleIndexes = new uint[](_Sales.length);\n        for(uint x; x < _Sales.length; x++) { SaleIndexes[x] = __FixedPriceSaleInit(_Sales[x], Discounts[x]); }\n        return SaleIndexes;\n    }\n\n    /**\n     * @dev Changes The Price Of A Fixed Price Sale\n     * @param SaleIndex The Sale Index To Edit\n     * @param Price The Sale Price (IN WEI)\n     */\n    function __ChangeFixedPrice(uint SaleIndex, uint Price) external onlyAdmin { FixedPriceSales[SaleIndex]._Price = Price; }\n\n    /**\n     * @dev Changes The MintPass ProjectID\n     * @param SaleIndex The Sale Index To Edit\n     * @param MintPassProjectID The Mint Pass ProjectID\n     */\n    function __ChangeFixedPriceMintPassProjectID(uint SaleIndex, uint MintPassProjectID) external onlyAdmin \n    { \n        FixedPriceSales[SaleIndex]._MintPassProjectID = MintPassProjectID; \n    }\n\n    /**\n     * @dev Changes The Type Of A Sale\n     * @param SaleIndex The Sale Index To Edit\n     * @param Type The Sale Type (0 = _MintToFactory() | 1 = purchaseTo() | 2 = transferFrom())\n     */\n    function __ChangeFixedPriceType(uint SaleIndex, uint Type) external onlyAdmin { FixedPriceSales[SaleIndex]._Type = Type; }\n\n    /**\n     * @dev Changes The ArtBlocks ProjectID\n     * @param SaleIndex The Sale Index To Edit\n     * @param ABProjectID ArtBlocks ProjectID\n     */\n    function __ChangeFixedPriceABProjectID(uint SaleIndex, uint ABProjectID) external onlyAdmin { FixedPriceSales[SaleIndex]._MinterProjectID = ABProjectID; }\n\n    /**\n     * @dev Changes The Amount Of NFTs For Sale\n     * @param SaleIndex The Sale Index To Edit\n     * @param AmountForSale The Total Amount For Sale\n     */\n    function __ChangeFixedPriceAmountForSale(uint SaleIndex, uint AmountForSale) external onlyAdmin { FixedPriceSales[SaleIndex]._AmountForSale = AmountForSale; }\n\n    /**\n     * @dev Changes A Fixed Price Sale's Unix Start Time\n     * @param SaleIndex The Sale Index To Edit\n     * @param UnixTimestamp The Unix Timestamp To Store\n     */\n    function __ChangeFixedPriceStartTimestamp(uint SaleIndex, uint UnixTimestamp) external onlyAdmin { FixedPriceSales[SaleIndex]._TimestampStart = UnixTimestamp; }\n   \n   /**\n     * @dev Changes A Fixed Price Sale's Unix Start Time\n     * @param SaleIndex The Sale Index To Edit\n     * @param CurrentIndex The Current TokenID To Disperse\n     */\n    function __ChangeFixedPriceCurrentIndex(uint SaleIndex, uint CurrentIndex) external onlyAdmin { FixedPriceSales[SaleIndex]._CurrentIndex = CurrentIndex; }\n\n    /**\n     * @dev Changes The NFT Address Of A Fixed Price Sale\n     * @param SaleIndex The Sale Index To Edit\n     * @param NewAddress The NFT Contract Address To Store\n     */\n    function __ChangeFixedPriceNFTAddress(uint SaleIndex, address NewAddress) external onlyAdmin { FixedPriceSales[SaleIndex]._NFT = NewAddress; }\n\n    /**\n     * @dev Changes The NFT Address Of A Fixed Price Sale\n     * @param SaleIndex The Sale Index To Edit\n     * @param Operator The Operator Holding The NFTs To Disperse\n     */\n    function __ChangeFixedPriceOperator(uint SaleIndex, address Operator) external onlyAdmin { FixedPriceSales[SaleIndex]._Operator = Operator; }\n\n    /**\n     * @dev Changes The Fixed Price Merkle Root For Merkle Eligibility\n     * @param SaleIndex The Sale Index To Edit\n     * @param NewRoots The Merkle Roots To Store\n     */\n    function __ChangeFixedPriceRootEligibility(uint SaleIndex, bytes32[] calldata NewRoots) external onlyAdmin { FixedPriceSales[SaleIndex]._RootEligibilities = NewRoots; }\n\n    /**\n     * @dev Changes The Fixed Price Merkle Root For Merkle Eligibility\n     * @param SaleIndex The Sale Index To Edit\n     * @param NewRoots The Merkle Root To Store\n     */\n    function __ChangeFixedPriceRootAmounts(uint SaleIndex, bytes32[] calldata NewRoots) external onlyAdmin { FixedPriceSales[SaleIndex]._RootAmounts = NewRoots; }\n\n    /**\n     * @dev Changes The Fixed Price Sale Roots\n     * @param SaleIndex The Sale Index To Edit\n     * @param RootEligibilities The Merkle Root For Merkle Eligibility\n     * @param RootAmounts The Merkle Root For Amounts\n     */\n    function __ChangeFixedPriceSaleRoots(uint SaleIndex, bytes32[] calldata RootEligibilities, bytes32[] calldata RootAmounts) external onlyAdmin\n    {\n        FixedPriceSales[SaleIndex]._RootEligibilities = RootEligibilities;\n        FixedPriceSales[SaleIndex]._RootAmounts = RootAmounts;\n    }\n\n    /**\n     * @dev Changes Fixed Price Sale Discount Amounts (IN BIPS)\n     * @param SaleIndex The Sale Index To Edit\n     * @param Discounts The Array Of Discount Amounts ([80,90] = 20%, 10% Discount) To Seed\n     */\n    function __ChangeFixedPriceDiscountAmounts(uint SaleIndex, uint[] calldata Discounts) external onlyAdmin\n    {\n        for(uint x; x < Discounts.length; x++) { require(Discounts[x] <= 100, \"Marketplace: Invalid Discount Amounts\");}\n        DiscountAmounts[SaleIndex] = Discounts;\n    }\n\n    /**\n     * @dev Changes The Fixed Price LiveMint ProjectIDs\n     * @param SaleIndex The Sale Index To Edit\n     * @param LiveMintProjectIDs The LiveMint ProjectIDs To Seed\n     */\n    function __ChangeFixedPriceLiveMintProjecIDs(uint SaleIndex, uint[] calldata LiveMintProjectIDs) external onlyAdmin\n    {\n        FixedPriceSales[SaleIndex]._LiveMintProjectIDs = LiveMintProjectIDs;\n    }\n\n    /**\n     * @dev Changes The Fixed Price Sale Mint Pack Amount\n     * @param SaleIndex The Sale Index To Edit\n     * @param MintPackAmount The Mint Pack Amount To Seed\n     */\n    function __ChangeFixedPriceMintPackAmount(uint SaleIndex, uint MintPackAmount) external onlyAdmin\n    {\n        FixedPriceSales[SaleIndex]._BatchPurchaseAmount = MintPackAmount;\n    }\n\n    /**\n     * @dev Sweeps Proceeds From A Sale Index To Multisig\n     * @param SaleIndex The Sale Index To Withdraw From\n     */\n    function __WithdrawETHFromSaleIndex(uint SaleIndex) external onlyAdmin\n    {\n        require(ETHRevenueFixedPriceSale[SaleIndex] - ETHRevenueWithdrawn[SaleIndex] > 0, \"Marketplace: No ETH To Withdraw\");\n        uint WithdrawAmount = ETHRevenueFixedPriceSale[SaleIndex] - ETHRevenueWithdrawn[SaleIndex];\n        ETHRevenueWithdrawn[SaleIndex] += WithdrawAmount;\n        (bool success,) = _BRT_MULTISIG.call { value: WithdrawAmount }(\"\"); \n        require(success, \"Marketplace: ETH Withdraw Failed\"); \n    }\n\n    /*--------------*/\n    /*  ONLY OWNER  */\n    /*--------------*/\n\n    /**\n     * @dev onlyOwner: Grants Admin Role\n     * @param Wallet The Admin To Add\n     */\n    function ____AddressAuthorize(address Wallet) external onlyOwner { Admin[Wallet] = true; }\n\n    /**\n     * @dev onlyOwner: Removes Admin Role\n     * @param Wallet The Admin To Remove\n     */\n    function ____DeuthorizeAddress(address Wallet) external onlyOwner { Admin[Wallet] = false; }\n\n    /**\n     * @dev onlyOwner: Withdraws Ether From Contract To Address With A Specified Amount\n     * @param Recipient The Recipient Of The Ether\n     * @param Amount The Amount Of Ether To Withdraw\n     */\n    function ____WithdrawEtherToAddress(address payable Recipient, uint Amount) external onlyOwner\n    {\n        require(Amount > 0 && Amount <= address(this).balance, \"Invalid Amount\");\n        (bool Success, ) = Recipient.call{value: Amount}(\"\");\n        require(Success, \"Unable to Withdraw, Recipient May Have Reverted\");\n    }\n\n    /**\n     * @dev Withdraws ETH In Contract To Multisig\n     */\n    function __WithdrawAllETHToMultisig() external onlyOwner \n    {\n        (bool success,) = _BRT_MULTISIG.call { value: address(this).balance }(\"\"); \n        require(success, \"Marketplace: ETH Withdraw Failed\"); \n    }\n\n    /*-----------------\n     * VIEW FUNCTIONS *\n    ------------------*/\n\n    /**\n     * @dev Returns The Fixed Price Merkle Roots\n     */\n    function ViewFixedPriceRoots(uint SaleIndex) external view returns (bytes32[] memory, bytes32[] memory)\n    {\n        return (FixedPriceSales[SaleIndex]._RootEligibilities, FixedPriceSales[SaleIndex]._RootAmounts);\n    }\n\n    /**\n     * @dev Verifies BrightList For Presale\n     */\n    function VerifyBrightList(address _Wallet, bytes32 _RootEligibilities, bytes32[] calldata _Proof) public pure returns(bool)\n    {\n        bytes32 _Leaf = keccak256(abi.encodePacked(_Wallet));\n        return MerkleProof.verify(_Proof, _RootEligibilities, _Leaf);\n    }\n\n    /**\n     * @dev Verifies BrightList For Presale Fixed Price Sale\n     */\n    function VerifyBrightListWithPriority (\n        uint SaleIndex, \n        address _Wallet, \n        bytes32[] calldata _ProofEligibility\n    ) public view returns (bool, uint) {\n        bytes32 _Leaf = keccak256(abi.encodePacked(_Wallet));\n        for(uint x; x < DiscountAmounts[SaleIndex].length; x++) \n        { \n            if(MerkleProof.verify(_ProofEligibility, FixedPriceSales[SaleIndex]._RootEligibilities[x], _Leaf)) { return (true, x); } \n        }\n        return (false, 69420);\n    }\n\n    /**\n     * @dev Verifies Merkle Amount Is Passed Correctly\n     */\n    function VerifyBrightListAmount (\n        address _Wallet,\n        uint _Amount,\n        bytes32 _RootAmounts,\n        bytes32[] calldata _ProofAmount\n    ) public pure returns (bool) {\n        bytes32 _Leaf = (keccak256(abi.encodePacked(_Wallet, _Amount)));\n        return MerkleProof.verify(_ProofAmount, _RootAmounts, _Leaf);\n    }\n\n    /**\n     * @dev Verifies Maximum Purchase Amount Being Passed Is Valid\n     */\n    function VerifyAmount(address _Wallet, uint _Amount, bytes32 _RootEligibilities, bytes32[] calldata _Proof) public pure returns(bool)\n    {\n        bytes32 _Leaf = (keccak256(abi.encodePacked(_Wallet, _Amount)));\n        return MerkleProof.verify(_Proof, _RootEligibilities, _Leaf);\n    }\n\n    /**\n     * @dev Returns Information Of A Fixed Price Sale\n     */\n    function ViewSaleInfoFixedPrice (\n        uint SaleIndex,\n        address Wallet,\n        uint MaxAmount,\n        bytes32[] calldata ProofEligibility,\n        bytes32[] calldata ProofAmount\n    ) public view returns (FixedPriceSaleInfo memory) {\n        return __ViewSaleInfoFixedPrice(\n            SaleIndex,\n            Wallet,\n            MaxAmount,\n            ProofEligibility,\n            ProofAmount\n        );\n    }\n\n    /**\n     * @dev Returns Information Of Multiple Fixed Price Sales\n     */\n    function ViewSaleInfosFixedPrice(\n        uint[] calldata SaleIndexes,\n        address[] calldata Wallets,\n        uint[] calldata MaxAmounts,\n        bytes32[][] calldata ProofEligibilities,\n        bytes32[][] calldata ProofAmounts\n    ) public view returns (FixedPriceSaleInfo[] memory _Sales)\n    {\n        _Sales = new FixedPriceSaleInfo[](SaleIndexes.length);\n        for(uint x; x < SaleIndexes.length; x++)\n        {\n            _Sales[x] = __ViewSaleInfoFixedPrice(\n                SaleIndexes[x],\n                Wallets[x],\n                MaxAmounts[x],\n                ProofEligibilities[x],\n                ProofAmounts[x]\n            );\n        }\n        return _Sales;\n    }\n    \n    /**\n     * @dev Returns A Wallet's Sale Information For A Presale Sale\n     */\n    function ViewSaleInfoPresale (\n        uint SaleIndex,\n        address Wallet,\n        uint MaxAmountFullSet,\n        uint MaxAmountCitizen,\n        bytes32[] calldata FullsetProof, \n        bytes32[] calldata CitizenProof,\n        bytes32[] calldata ProofAmountFullSet,\n        bytes32[] calldata ProofAmountCitizen\n    ) public view returns (SaleInfoPresale memory) {\n        uint AmountPurchaseableFullset;\n        uint AmountPurchaseableCitizen;\n        SaleTypePresale memory _Sale = PresaleSales[SaleIndex];\n        InternalPresaleSale memory _SaleInternal = PresaleSalesInternal[SaleIndex];\n        InternalPresaleWalletInfo memory _WalletInfo = InternalSaleWalletInfo[SaleIndex][Wallet];\n        uint AmountRemaining = _Sale._MaxForSale - _SaleInternal._AmountSold;\n        uint ETHRevenue = _SaleInternal._ETHRevenue;\n        if(_WalletInfo._AmountPurchasedFullSetWindow >= MaxAmountFullSet) { AmountPurchaseableFullset = 0; }\n        else { AmountPurchaseableFullset = MaxAmountFullSet - _WalletInfo._AmountPurchasedFullSetWindow; }\n        if(_WalletInfo._AmountPurchasedCitizenWindow >= MaxAmountCitizen) { AmountPurchaseableCitizen = 0; }\n        else { AmountPurchaseableCitizen = MaxAmountCitizen - _WalletInfo._AmountPurchasedCitizenWindow; }\n        return SaleInfoPresale (\n            ETHRevenue, // ETHRevenue\n            _Sale._PricePresale, // _PricePresale\n            _Sale._PricePublic, // _PricePublic\n            _Sale._MaxForSale, // _MintPassesAvailable\n            AmountRemaining, // _AmountRemaining\n            _Sale._TimestampEndFullSet, // _TimestampEndFullSet\n            _Sale._TimestampEndCitizen, // _TimestampEndCitizen\n            _Sale._TimestampSaleStart, // _TimestampSaleStart\n            AmountPurchaseableFullset, // _AmountPurchasableFullSet\n            AmountPurchaseableCitizen, // _AmountPurchasableCitizen\n            _WalletInfo._AmountPurchasedFullSetWindow, // _AmountPurchasedFullSetWindow\n            _WalletInfo._AmountPurchasedCitizenWindow, // _AmountPurchasedCitizenWindow\n            _SaleInternal._GlobalPurchasesFullSet, // _GlobalPurchasesFullSet\n            _SaleInternal._GlobalPurchasesCitizen, // _GlobalPurchasesCitizen\n            _SaleInternal._GlobalPurchasesPublic, // _GlobalPurchasesPublic\n            _WalletInfo._AmountPurchasedWallet, // _AmountPurchasedWallet\n            VerifyBrightList(Wallet, InternalRoots[SaleIndex]._RootEligibilityFullSet, FullsetProof), // _EligibleFullSet\n            VerifyBrightList(Wallet, InternalRoots[SaleIndex]._RootEligibilityCitizen, CitizenProof), // _EligibleCitizen\n            VerifyAmount(Wallet, MaxAmountFullSet, InternalRoots[SaleIndex]._RootAmountFullSet, ProofAmountFullSet), // _ValidMaxAmountFullSet\n            VerifyAmount(Wallet, MaxAmountCitizen, InternalRoots[SaleIndex]._RootAmountCitizen, ProofAmountCitizen) // _ValidMaxAmountCitizen\n        );\n    }\n  \n    /*-----------\n     * INTERNAL *\n    ------------*/  \n\n    /**\n     * @dev Refunds `Recipient` ETH Amount `Value`\n     */\n    function __Refund(address Recipient, uint Value) internal\n    {\n        (bool Confirmed,) = Recipient.call{value: Value}(\"\"); \n        require(Confirmed, \"Marketplace: Refund failed\");\n        emit Refunded(Recipient, Value);\n    }\n\n    /**\n     * @dev Initializes A Sale Via A Struct\n     */\n    function __FixedPriceSaleInit(SaleTypeFixedPrice memory _Sale, uint[] calldata Discounts) internal returns (uint SaleIndex) { \n        require(\n            _Sale._RootEligibilities.length == _Sale._RootAmounts.length\n            &&\n            _Sale._RootAmounts.length == Discounts.length,\n            \"Marketplace: All Array Lengths Must Match\"\n        );\n        for(uint x; x < Discounts.length; x++) { require(Discounts[x] <= 100 && Discounts[x] > 0, \"Marketplace: Discount Amounts Must Be <= 100 & > 0\"); }\n        SaleIndex = _TOTAL_UNIQUE_FIXED_SALES;\n        FixedPriceSales[SaleIndex] = _Sale; \n        DiscountAmounts[SaleIndex] = Discounts;\n        _TOTAL_UNIQUE_FIXED_SALES += 1;\n        return SaleIndex;\n    }\n\n    /**\n     * @dev Finalizes A Fixed Price Sale\n     */\n    function __FinalizeFixedPriceSale(\n        uint SaleIndex,\n        uint DesiredAmount,\n        uint MaxAmount,\n        address Vault,\n        bytes32[] calldata ProofEligibility,\n        bytes32[] calldata ProofAmount,\n        uint MessageValue,\n        address Purchaser\n    ) internal {\n        require(tx.origin == Purchaser, \"Marketplace: EOA Only\");\n        address MerkleRecipient = Purchaser;\n        if(Vault != address(0)) { if(DelegateCash.checkDelegateForAll(Purchaser, Vault)) { MerkleRecipient = Vault; } }\n        require(block.timestamp >= FixedPriceSales[SaleIndex]._TimestampStart, \"Marketplace: Sale Not Started\");\n        (bool BrightList, uint Priority) = VerifyBrightListWithPriority(SaleIndex, MerkleRecipient, ProofEligibility);\n        if(BrightList)  \n        {\n            require(\n                VerifyBrightListAmount( \n                    MerkleRecipient, \n                    MaxAmount, \n                    FixedPriceSales[SaleIndex]._RootAmounts[Priority], \n                    ProofAmount\n                ), \n                \"DutchMarketplace: Invalid Max Amount Merkle Proof For Provided Merkle Priority\"\n            );\n            require(\n                MessageValue\n                == \n                (((FixedPriceSales[SaleIndex]._Price * DesiredAmount) * DiscountAmounts[SaleIndex][Priority]) / 100), \n                \"Marketplace: Incorrect BrightList ETH Sent\"\n            );\n            require(\n                DesiredAmount + PriorityPurchaseAmount[SaleIndex][MerkleRecipient][Priority] \n                <= \n                MaxAmount, \n                \"Marketplace: Desired Purchase Amount Exceeds Purchase Allocation\"\n            );\n            PriorityPurchaseAmount[SaleIndex][MerkleRecipient][Priority] += DesiredAmount;\n        }\n        else { require(MessageValue == FixedPriceSales[SaleIndex]._Price * DesiredAmount, \"Marketplace: Incorrect ETH Amount Sent\"); }\n        require(AmountSoldFixedPrice[SaleIndex] + DesiredAmount <= FixedPriceSales[SaleIndex]._AmountForSale, \"Marketplace: Not Enough NFTs Left For Sale\");\n        AmountSoldFixedPrice[SaleIndex] = AmountSoldFixedPrice[SaleIndex] + DesiredAmount;\n        if(FixedPriceSales[SaleIndex]._Type == 0) // Factory MintPass Direct Mint\n        { \n            IMinter(FixedPriceSales[SaleIndex]._NFT)._MintToFactory(\n                Purchaser, \n                DesiredAmount\n            ); \n        }\n        else if (FixedPriceSales[SaleIndex]._Type == 1) // Factory MintPass MintPack Direct Mint\n        {\n            for(uint x; x < DesiredAmount; x++)\n            {\n                IMinter(FixedPriceSales[SaleIndex]._NFT)._MintToFactory(\n                    Purchaser, \n                    FixedPriceSales[SaleIndex]._BatchPurchaseAmount\n                ); \n            }\n        }\n        else if (FixedPriceSales[SaleIndex]._Type == 2) // LiveMint Direct Mint\n        {\n            ILiveMint(FixedPriceSales[SaleIndex]._NFT)._LiveMintMarketplace(\n                Purchaser, \n                FixedPriceSales[SaleIndex]._MinterProjectID, \n                DesiredAmount\n            );\n        }\n        else if (FixedPriceSales[SaleIndex]._Type == 3) // LiveMint Direct Mint Pack\n        {\n            for(uint x; x < FixedPriceSales[SaleIndex]._LiveMintProjectIDs.length; x++)\n            {\n                ILiveMint(FixedPriceSales[SaleIndex]._NFT)._LiveMintMarketplace(\n                    Purchaser, \n                    FixedPriceSales[SaleIndex]._LiveMintProjectIDs[x], \n                    DesiredAmount\n                );\n            }\n        }\n        else if(FixedPriceSales[SaleIndex]._Type == 4) // ArtBlocks purchaseTo() Mint\n        { \n            uint ProjectID = FixedPriceSales[SaleIndex]._MinterProjectID;\n            for(uint x; x < DesiredAmount; x++) { IMinter(FixedPriceSales[SaleIndex]._NFT).purchaseTo(Purchaser, ProjectID); }\n        } \n        else if (FixedPriceSales[SaleIndex]._Type == 5) // ERC721 transferFrom() Sale\n        {\n            IERC721 _NFT = IERC721(FixedPriceSales[SaleIndex]._NFT);\n            address _Operator = FixedPriceSales[SaleIndex]._Operator;\n            uint _StartingIndex = FixedPriceSales[SaleIndex]._CurrentIndex;\n            for(uint Index; Index < DesiredAmount; Index++) { _NFT.transferFrom(_Operator, Purchaser, _StartingIndex + Index); }\n            FixedPriceSales[SaleIndex]._CurrentIndex += DesiredAmount;\n        }\n        else if (FixedPriceSales[SaleIndex]._Type == 6)\n        {\n            IMinter _NFT = IMinter(FixedPriceSales[SaleIndex]._NFT);\n            uint _BatchPurchaseAmount = FixedPriceSales[SaleIndex]._BatchPurchaseAmount;\n            uint _ETHValue = FixedPriceSales[SaleIndex]._Price / _BatchPurchaseAmount;\n            uint _MinterProjectID = FixedPriceSales[SaleIndex]._MinterProjectID;\n            for(uint x; x < DesiredAmount; x++) // Iterates Over The Desired Units Of Purchase\n            {\n                for(uint y; y < _BatchPurchaseAmount; y++) // Mints Configured Amount Of NFTs Per Unit Purchased\n                { \n                    _NFT.purchaseTo{value: _ETHValue}(Purchaser, _MinterProjectID); \n                }\n            }\n        }\n        else { revert('Marketplace: Incorrect Sale Configuration'); }\n        UserPurchasedAmount[SaleIndex][Purchaser] += DesiredAmount;\n        ETHRevenueFixedPriceSale[SaleIndex] += MessageValue;\n        emit Purchased(SaleIndex, Purchaser, DesiredAmount, Priority);\n    }\n\n    /**\n     * @dev Finalizes A Presale Purchase\n     * @param SaleIndex The Sale Index To Purchase\n     * @param DesiredAmount The Desired Amount To Purchase\n     * @param MaxAmount The Maximum Amount For Merkle Priority Purchase\n     * @param Vault Delegate Vault Address\n     * @param Proof Merkle Proof For Eligibility\n     * @param ProofAmount Merkle Proof For MaxAmount\n     */\n    function __FinalizePresale(\n        uint SaleIndex,\n        uint DesiredAmount,\n        uint MaxAmount,\n        address Vault,\n        bytes32[] calldata Proof,\n        bytes32[] calldata ProofAmount,\n        uint MessageValue,\n        address Purchaser\n    ) internal {\n        require(tx.origin == Purchaser, \"Marketplace: EOA Only\");\n        require(block.timestamp >= PresaleSales[SaleIndex]._TimestampSaleStart, \"Marketplace: Sale Not Started\");\n        address MerkleRecipient = Purchaser;\n        if(Vault != address(0)) { if(DelegateCash.checkDelegateForAll(Purchaser, Vault)) { MerkleRecipient = Vault; } }\n        InternalPresaleSale memory _InternalPresaleSale = PresaleSalesInternal[SaleIndex];\n        SaleTypePresale memory _PresaleSale = PresaleSales[SaleIndex];\n        bool PresaleEnded;\n        uint _Price;\n        uint _MaxPerPurchase = _PresaleSale._MaxPerPurchase;\n        if(_InternalPresaleSale._AmountSold + DesiredAmount > _PresaleSale._MaxForSale) \n        { \n            DesiredAmount = _PresaleSale._MaxForSale - _InternalPresaleSale._AmountSold; // Partial Fill\n        } \n        if(block.timestamp <= _PresaleSale._TimestampEndCitizen) // Presale\n        {\n            if(block.timestamp <= _PresaleSale._TimestampEndFullSet) // Full Set Window\n            { \n                require ( // Eligible For Full Set Window\n                    VerifyBrightList(MerkleRecipient, InternalRoots[SaleIndex]._RootEligibilityFullSet, Proof), \n                    \"Full Set Window: Not Eligible For Presale Window Or Block Pending, Please Try Again In A Few Seconds...\"\n                ); \n                require(VerifyAmount(MerkleRecipient, MaxAmount, InternalRoots[SaleIndex]._RootAmountFullSet, ProofAmount), \"Invalid Full Set Amount Proof\");\n                require(InternalSaleWalletInfo[SaleIndex][MerkleRecipient]._AmountPurchasedWallet + DesiredAmount <= MaxAmount, \"All Full Set Allocation Used\");\n                InternalSaleWalletInfo[SaleIndex][MerkleRecipient]._AmountPurchasedFullSetWindow += DesiredAmount;\n                PresaleSalesInternal[SaleIndex]._GlobalPurchasesFullSet += DesiredAmount;\n                emit Fullset();\n            }\n            else // Citizen Window\n            { \n                require ( // Eligible For Citizen Window\n                    VerifyBrightList(MerkleRecipient, InternalRoots[SaleIndex]._RootEligibilityCitizen, Proof), \n                    \"Citizen Window: Not Eligible For Presale Window Or Block Pending, Please Try Again In A Few Seconds...\"\n                ); \n                require(VerifyAmount(MerkleRecipient, MaxAmount, InternalRoots[SaleIndex]._RootAmountCitizen, ProofAmount), \"Invalid Citizen Amount Proof\");\n                require(InternalSaleWalletInfo[SaleIndex][MerkleRecipient]._AmountPurchasedCitizenWindow + DesiredAmount <= MaxAmount, \"All Citizen Allocation Used\");\n                InternalSaleWalletInfo[SaleIndex][MerkleRecipient]._AmountPurchasedWallet += DesiredAmount;\n                PresaleSalesInternal[SaleIndex]._GlobalPurchasesCitizen += DesiredAmount;\n                emit Citizen();\n            }\n            _Price = _PresaleSale._PricePresale * DesiredAmount;\n        }\n        else // Public Sale\n        { \n            _Price = _PresaleSale._PricePublic * DesiredAmount;\n            PresaleSalesInternal[SaleIndex]._GlobalPurchasesPublic += DesiredAmount;\n            PresaleEnded = true; \n            emit Public();\n        }\n        require(DesiredAmount <= _MaxPerPurchase, \"Invalid Desired Purchase Amount. Must Be <= Max Purchase Limit\"); // Purchase Limiter\n        require(_InternalPresaleSale._AmountSold + DesiredAmount <= _PresaleSale._MaxForSale, \"Sale Ended\"); // Sale End State\n        require(DesiredAmount > 0 && _Price > 0, \"Sale Ended\"); // Sale End State\n        require(MessageValue >= _Price, \"Invalid ETH Amount\"); // Ensures ETH Amount Sent Is Correct\n        if(MessageValue > _Price) { __Refund(Purchaser, MessageValue - _Price); } // Refunds The Difference\n        if(_PresaleSale._Type == 0) { IMinter(_PresaleSale._NFT)._MintToFactory(0, Purchaser, DesiredAmount); }\n        else if (_PresaleSale._Type == 1) \n        { \n            for(uint x; x < DesiredAmount; x++) { IMinter(_PresaleSale._NFT).purchaseTo(Purchaser, _PresaleSale._ProjectID); }\n        }\n        PresaleSalesInternal[SaleIndex]._AmountSold += DesiredAmount;\n        PresaleSalesInternal[SaleIndex]._CurrentTokenIndex += DesiredAmount;\n        PresaleSalesInternal[SaleIndex]._ETHRevenue += _Price;\n        InternalSaleWalletInfo[SaleIndex][MerkleRecipient]._AmountPurchasedWallet += DesiredAmount;\n        emit PurchasedPresale(SaleIndex, Purchaser, DesiredAmount, MessageValue, PresaleEnded);\n    }\n\n    /**\n     * @dev Returns The Sale Info For A Fixed Price Sale\n     */\n    function __ViewSaleInfoFixedPrice (\n        uint SaleIndex,\n        address Wallet,\n        uint MaxAmount,\n        bytes32[] calldata ProofEligibility,\n        bytes32[] calldata ProofAmount\n    ) internal view returns (FixedPriceSaleInfo memory) {\n        uint Price = FixedPriceSales[SaleIndex]._Price;\n        uint AmountForSale = FixedPriceSales[SaleIndex]._AmountForSale;\n        uint AmountRemaining = AmountForSale - AmountSoldFixedPrice[SaleIndex];\n        uint ETHRevenue = ETHRevenueFixedPriceSale[SaleIndex];\n        uint AmountPurchasedUser = UserPurchasedAmount[SaleIndex][Wallet];\n        uint AmountRemainingMerklePriority;\n        uint PurchasedAmountMerklePriority;\n        bool BrightListMerkleAmount;\n        uint[] memory DiscountAmountWEIValues = new uint[](FixedPriceSales[SaleIndex]._RootEligibilities.length);\n        for(uint x; x < FixedPriceSales[SaleIndex]._RootEligibilities.length; x++)\n        {\n            DiscountAmountWEIValues[x] = (Price * DiscountAmounts[SaleIndex][x]) / 100;\n        }\n        (bool BrightListEligible, uint Priority) = VerifyBrightListWithPriority(\n            SaleIndex, \n            Wallet, \n            ProofEligibility\n        );\n        if(BrightListEligible)\n        {\n            BrightListMerkleAmount = VerifyBrightListAmount(Wallet, MaxAmount, FixedPriceSales[SaleIndex]._RootAmounts[Priority], ProofAmount);\n            PurchasedAmountMerklePriority = PriorityPurchaseAmount[SaleIndex][Wallet][Priority];\n            if(MaxAmount > PurchasedAmountMerklePriority)\n            {\n                AmountRemainingMerklePriority = MaxAmount - PurchasedAmountMerklePriority;\n            }\n        }\n        return FixedPriceSaleInfo(\n            FixedPriceSales[SaleIndex]._Name,\n            Price, \n            FixedPriceSales[SaleIndex]._MintPassProjectID,\n            FixedPriceSales[SaleIndex]._Type,\n            FixedPriceSales[SaleIndex]._MinterProjectID,\n            AmountForSale, \n            FixedPriceSales[SaleIndex]._TimestampStart,\n            FixedPriceSales[SaleIndex]._CurrentIndex,\n            FixedPriceSales[SaleIndex]._BatchPurchaseAmount,\n            FixedPriceSales[SaleIndex]._NFT,\n            FixedPriceSales[SaleIndex]._Operator,\n            FixedPriceSales[SaleIndex]._RootEligibilities,\n            FixedPriceSales[SaleIndex]._RootAmounts,\n            FixedPriceSales[SaleIndex]._LiveMintProjectIDs,\n            DiscountAmountWEIValues,\n            ETHRevenue, \n            AmountRemaining, \n            Priority, \n            AmountRemainingMerklePriority,\n            AmountPurchasedUser,\n            BrightListEligible, \n            BrightListMerkleAmount\n        );\n    }\n\n    /*-----------\n     * MODIFIER *\n    ------------*/\n\n    /**\n     * @dev onlyAdmin Modifier\n     */\n    modifier onlyAdmin\n    {\n        require(Admin[msg.sender], \"Marketplace | onlyAdmin | Caller Is Not Admin\");\n        _;\n    }\n}\n\ninterface IERC20 { function approve(address From, address To, uint Amount) external; }\ninterface IERC721 { function transferFrom(address From, address To, uint TokenID) external; }\ninterface ILiveMint { function _LiveMintMarketplace(address Recipient, uint ArtistID, uint Amount) external; }"}}, "settings": {"viaIR": false, "optimizer": {"enabled": true}, "outputSelection": {"*": {"*": ["evm.legacyAssembly"]}}, "libraries": {}}}