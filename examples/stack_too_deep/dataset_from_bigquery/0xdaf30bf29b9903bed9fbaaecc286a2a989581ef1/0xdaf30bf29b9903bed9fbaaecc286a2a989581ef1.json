{"language": "Solidity", "sources": {"@axelar-network/axelar-cgp-solidity/contracts/interfaces/IAxelarGasService.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\nimport './IUpgradable.sol';\n\n// This should be owned by the microservice that is paying for gas.\ninterface IAxelarGasService is IUpgradable {\n    error NothingReceived();\n    error TransferFailed();\n    error InvalidAddress();\n    error NotCollector();\n    error InvalidAmounts();\n\n    event GasPaidForContractCall(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event GasPaidForContractCallWithToken(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        string symbol,\n        uint256 amount,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeGasPaidForContractCall(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeGasPaidForContractCallWithToken(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        string symbol,\n        uint256 amount,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event GasAdded(bytes32 indexed txHash, uint256 indexed logIndex, address gasToken, uint256 gasFeeAmount, address refundAddress);\n\n    event NativeGasAdded(bytes32 indexed txHash, uint256 indexed logIndex, uint256 gasFeeAmount, address refundAddress);\n\n    // This is called on the source chain before calling the gateway to execute a remote contract.\n    function payGasForContractCall(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    // This is called on the source chain before calling the gateway to execute a remote contract.\n    function payGasForContractCallWithToken(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    // This is called on the source chain before calling the gateway to execute a remote contract.\n    function payNativeGasForContractCall(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address refundAddress\n    ) external payable;\n\n    // This is called on the source chain before calling the gateway to execute a remote contract.\n    function payNativeGasForContractCallWithToken(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount,\n        address refundAddress\n    ) external payable;\n\n    function addGas(\n        bytes32 txHash,\n        uint256 txIndex,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    function addNativeGas(\n        bytes32 txHash,\n        uint256 logIndex,\n        address refundAddress\n    ) external payable;\n\n    function collectFees(\n        address payable receiver,\n        address[] calldata tokens,\n        uint256[] calldata amounts\n    ) external;\n\n    function refund(\n        address payable receiver,\n        address token,\n        uint256 amount\n    ) external;\n\n    function gasCollector() external returns (address);\n}\n"}, "@axelar-network/axelar-cgp-solidity/contracts/interfaces/IUpgradable.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\n// General interface for upgradable contracts\ninterface IUpgradable {\n    error NotOwner();\n    error InvalidOwner();\n    error InvalidCodeHash();\n    error InvalidImplementation();\n    error SetupFailed();\n    error NotProxy();\n\n    event Upgraded(address indexed newImplementation);\n    event OwnershipTransferred(address indexed newOwner);\n\n    // Get current owner\n    function owner() external view returns (address);\n\n    function contractId() external pure returns (bytes32);\n\n    function implementation() external view returns (address);\n\n    function upgrade(\n        address newImplementation,\n        bytes32 newImplementationCodeHash,\n        bytes calldata params\n    ) external;\n\n    function setup(bytes calldata data) external;\n}\n"}, "@axelar-network/axelar-gmp-sdk-solidity/contracts/executables/AxelarForecallable.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\nimport { IAxelarGateway } from '../interfaces/IAxelarGateway.sol';\nimport { IERC20 } from '../interfaces/IERC20.sol';\nimport { IAxelarForecallable } from '../interfaces/IAxelarForecallable.sol';\n\ncontract AxelarForecallable is IAxelarForecallable {\n    IAxelarGateway public immutable gateway;\n\n    //keccak256('forecallers');\n    uint256 public constant FORECALLERS_SALT = 0xdb79ee324babd8834c3c1a1a2739c004fce73b812ac9f637241ff47b19e4b71f;\n\n    constructor(address gateway_) {\n        if (gateway_ == address(0)) revert InvalidAddress();\n\n        gateway = IAxelarGateway(gateway_);\n    }\n\n    function getForecaller(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) public view override returns (address forecaller) {\n        bytes32 pos = keccak256(abi.encode(sourceChain, sourceAddress, payload, FORECALLERS_SALT));\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            forecaller := sload(pos)\n        }\n    }\n\n    function _setForecaller(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload,\n        address forecaller\n    ) internal {\n        bytes32 pos = keccak256(abi.encode(sourceChain, sourceAddress, payload, FORECALLERS_SALT));\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(pos, forecaller)\n        }\n    }\n\n    function forecall(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) external {\n        _checkForecall(sourceChain, sourceAddress, payload, msg.sender);\n        if (getForecaller(sourceChain, sourceAddress, payload) != address(0)) revert AlreadyForecalled();\n        _setForecaller(sourceChain, sourceAddress, payload, msg.sender);\n        _execute(sourceChain, sourceAddress, payload);\n    }\n\n    function execute(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) external override {\n        bytes32 payloadHash = keccak256(payload);\n        if (!gateway.validateContractCall(commandId, sourceChain, sourceAddress, payloadHash))\n            revert NotApprovedByGateway();\n        address forecaller = getForecaller(sourceChain, sourceAddress, payload);\n        if (forecaller != address(0)) {\n            _setForecaller(sourceChain, sourceAddress, payload, address(0));\n        } else {\n            _execute(sourceChain, sourceAddress, payload);\n        }\n    }\n\n    function getForecallerWithToken(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount\n    ) public view override returns (address forecaller) {\n        bytes32 pos = keccak256(abi.encode(sourceChain, sourceAddress, payload, symbol, amount, FORECALLERS_SALT));\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            forecaller := sload(pos)\n        }\n    }\n\n    function _setForecallerWithToken(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount,\n        address forecaller\n    ) internal {\n        bytes32 pos = keccak256(abi.encode(sourceChain, sourceAddress, payload, symbol, amount, FORECALLERS_SALT));\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(pos, forecaller)\n        }\n    }\n\n    function forecallWithToken(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload,\n        string calldata tokenSymbol,\n        uint256 amount\n    ) external override {\n        address token = gateway.tokenAddresses(tokenSymbol);\n        uint256 amountPost = amountPostFee(amount, payload);\n        _safeTransferFrom(token, msg.sender, amountPost);\n        _checkForecallWithToken(sourceChain, sourceAddress, payload, tokenSymbol, amount, msg.sender);\n        if (getForecallerWithToken(sourceChain, sourceAddress, payload, tokenSymbol, amount) != address(0))\n            revert AlreadyForecalled();\n        _setForecallerWithToken(sourceChain, sourceAddress, payload, tokenSymbol, amount, msg.sender);\n        _executeWithToken(sourceChain, sourceAddress, payload, tokenSymbol, amountPost);\n    }\n\n    function executeWithToken(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload,\n        string calldata tokenSymbol,\n        uint256 amount\n    ) external override {\n        bytes32 payloadHash = keccak256(payload);\n        if (\n            !gateway.validateContractCallAndMint(\n                commandId,\n                sourceChain,\n                sourceAddress,\n                payloadHash,\n                tokenSymbol,\n                amount\n            )\n        ) revert NotApprovedByGateway();\n        address forecaller = getForecallerWithToken(sourceChain, sourceAddress, payload, tokenSymbol, amount);\n        if (forecaller != address(0)) {\n            _setForecallerWithToken(sourceChain, sourceAddress, payload, tokenSymbol, amount, address(0));\n            address token = gateway.tokenAddresses(tokenSymbol);\n            _safeTransfer(token, forecaller, amount);\n        } else {\n            _executeWithToken(sourceChain, sourceAddress, payload, tokenSymbol, amount);\n        }\n    }\n\n    function _execute(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) internal virtual {}\n\n    function _executeWithToken(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload,\n        string calldata tokenSymbol,\n        uint256 amount\n    ) internal virtual {}\n\n    // Override this to keep a fee.\n    function amountPostFee(\n        uint256 amount,\n        bytes calldata /*payload*/\n    ) public virtual override returns (uint256) {\n        return amount;\n    }\n\n    // Override this and revert if you want to only allow certain people/calls to be able to forecall.\n    function _checkForecall(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload,\n        address forecaller\n    ) internal virtual {}\n\n    // Override this and revert if you want to only allow certain people/calls to be able to forecall.\n    function _checkForecallWithToken(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload,\n        string calldata tokenSymbol,\n        uint256 amount,\n        address forecaller\n    ) internal virtual {}\n\n    function _safeTransfer(\n        address tokenAddress,\n        address receiver,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory returnData) = tokenAddress.call(\n            abi.encodeWithSelector(IERC20.transfer.selector, receiver, amount)\n        );\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n\n        if (!transferred || tokenAddress.code.length == 0) revert TransferFailed();\n    }\n\n    function _safeTransferFrom(\n        address tokenAddress,\n        address from,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory returnData) = tokenAddress.call(\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, address(this), amount)\n        );\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n\n        if (!transferred || tokenAddress.code.length == 0) revert TransferFailed();\n    }\n}\n"}, "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarExecutable.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\nimport { IAxelarGateway } from '../interfaces/IAxelarGateway.sol';\n\ninterface IAxelarExecutable {\n    error InvalidAddress();\n    error NotApprovedByGateway();\n\n    function gateway() external view returns (IAxelarGateway);\n\n    function execute(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) external;\n\n    function executeWithToken(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload,\n        string calldata tokenSymbol,\n        uint256 amount\n    ) external;\n}\n"}, "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarForecallable.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\nimport { IAxelarExecutable } from '../interfaces/IAxelarExecutable.sol';\n\ninterface IAxelarForecallable is IAxelarExecutable {\n    error AlreadyForecalled();\n    error TransferFailed();\n\n    function forecall(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) external;\n\n    function forecallWithToken(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload,\n        string calldata tokenSymbol,\n        uint256 amount\n    ) external;\n\n    function getForecaller(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) external returns (address forecaller);\n\n    function getForecallerWithToken(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount\n    ) external returns (address forecaller);\n\n    function amountPostFee(uint256 amount, bytes calldata payload) external returns (uint256);\n}\n"}, "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGateway.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\ninterface IAxelarGateway {\n    /**********\\\n    |* Errors *|\n    \\**********/\n\n    error NotSelf();\n    error NotProxy();\n    error InvalidCodeHash();\n    error SetupFailed();\n    error InvalidAuthModule();\n    error InvalidTokenDeployer();\n    error InvalidAmount();\n    error InvalidChainId();\n    error InvalidCommands();\n    error TokenDoesNotExist(string symbol);\n    error TokenAlreadyExists(string symbol);\n    error TokenDeployFailed(string symbol);\n    error TokenContractDoesNotExist(address token);\n    error BurnFailed(string symbol);\n    error MintFailed(string symbol);\n    error InvalidSetMintLimitsParams();\n    error ExceedMintLimit(string symbol);\n\n    /**********\\\n    |* Events *|\n    \\**********/\n\n    event TokenSent(\n        address indexed sender,\n        string destinationChain,\n        string destinationAddress,\n        string symbol,\n        uint256 amount\n    );\n\n    event ContractCall(\n        address indexed sender,\n        string destinationChain,\n        string destinationContractAddress,\n        bytes32 indexed payloadHash,\n        bytes payload\n    );\n\n    event ContractCallWithToken(\n        address indexed sender,\n        string destinationChain,\n        string destinationContractAddress,\n        bytes32 indexed payloadHash,\n        bytes payload,\n        string symbol,\n        uint256 amount\n    );\n\n    event Executed(bytes32 indexed commandId);\n\n    event TokenDeployed(string symbol, address tokenAddresses);\n\n    event ContractCallApproved(\n        bytes32 indexed commandId,\n        string sourceChain,\n        string sourceAddress,\n        address indexed contractAddress,\n        bytes32 indexed payloadHash,\n        bytes32 sourceTxHash,\n        uint256 sourceEventIndex\n    );\n\n    event ContractCallApprovedWithMint(\n        bytes32 indexed commandId,\n        string sourceChain,\n        string sourceAddress,\n        address indexed contractAddress,\n        bytes32 indexed payloadHash,\n        string symbol,\n        uint256 amount,\n        bytes32 sourceTxHash,\n        uint256 sourceEventIndex\n    );\n\n    event TokenMintLimitUpdated(string symbol, uint256 limit);\n\n    event OperatorshipTransferred(bytes newOperatorsData);\n\n    event Upgraded(address indexed implementation);\n\n    /********************\\\n    |* Public Functions *|\n    \\********************/\n\n    function sendToken(\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        string calldata symbol,\n        uint256 amount\n    ) external;\n\n    function callContract(\n        string calldata destinationChain,\n        string calldata contractAddress,\n        bytes calldata payload\n    ) external;\n\n    function callContractWithToken(\n        string calldata destinationChain,\n        string calldata contractAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount\n    ) external;\n\n    function isContractCallApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) external view returns (bool);\n\n    function isContractCallAndMintApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external view returns (bool);\n\n    function validateContractCall(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash\n    ) external returns (bool);\n\n    function validateContractCallAndMint(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external returns (bool);\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function authModule() external view returns (address);\n\n    function tokenDeployer() external view returns (address);\n\n    function tokenMintLimit(string memory symbol) external view returns (uint256);\n\n    function tokenMintAmount(string memory symbol) external view returns (uint256);\n\n    function allTokensFrozen() external view returns (bool);\n\n    function implementation() external view returns (address);\n\n    function tokenAddresses(string memory symbol) external view returns (address);\n\n    function tokenFrozen(string memory symbol) external view returns (bool);\n\n    function isCommandExecuted(bytes32 commandId) external view returns (bool);\n\n    function adminEpoch() external view returns (uint256);\n\n    function adminThreshold(uint256 epoch) external view returns (uint256);\n\n    function admins(uint256 epoch) external view returns (address[] memory);\n\n    /*******************\\\n    |* Admin Functions *|\n    \\*******************/\n\n    function setTokenMintLimits(string[] calldata symbols, uint256[] calldata limits) external;\n\n    function upgrade(\n        address newImplementation,\n        bytes32 newImplementationCodeHash,\n        bytes calldata setupParams\n    ) external;\n\n    /**********************\\\n    |* External Functions *|\n    \\**********************/\n\n    function setup(bytes calldata params) external;\n\n    function execute(bytes calldata input) external;\n}\n"}, "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    error InvalidAccount();\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"}, "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IUpgradable.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\n// General interface for upgradable contracts\ninterface IUpgradable {\n    error NotOwner();\n    error InvalidOwner();\n    error InvalidCodeHash();\n    error InvalidImplementation();\n    error SetupFailed();\n    error NotProxy();\n\n    event Upgraded(address indexed newImplementation);\n    event OwnershipTransferred(address indexed newOwner);\n\n    // Get current owner\n    function owner() external view returns (address);\n\n    function contractId() external pure returns (bytes32);\n\n    function upgrade(\n        address newImplementation,\n        bytes32 newImplementationCodeHash,\n        bytes calldata params\n    ) external;\n\n    function setup(bytes calldata data) external;\n}\n"}, "@axelar-network/axelar-gmp-sdk-solidity/contracts/upgradables/Upgradable.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\nimport '../interfaces/IUpgradable.sol';\n\nabstract contract Upgradable is IUpgradable {\n    // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    // keccak256('owner')\n    bytes32 internal constant _OWNER_SLOT = 0x02016836a56b71f0d02689e69e326f4f4c1b9057164ef592671cf0d37c8040c0;\n\n    modifier onlyOwner() {\n        if (owner() != msg.sender) revert NotOwner();\n        _;\n    }\n\n    function owner() public view returns (address owner_) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            owner_ := sload(_OWNER_SLOT)\n        }\n    }\n\n    function transferOwnership(address newOwner) external virtual onlyOwner {\n        if (newOwner == address(0)) revert InvalidOwner();\n\n        emit OwnershipTransferred(newOwner);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_OWNER_SLOT, newOwner)\n        }\n    }\n\n    function implementation() public view returns (address implementation_) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            implementation_ := sload(_IMPLEMENTATION_SLOT)\n        }\n    }\n\n    function upgrade(\n        address newImplementation,\n        bytes32 newImplementationCodeHash,\n        bytes calldata params\n    ) external override onlyOwner {\n        if (IUpgradable(newImplementation).contractId() != IUpgradable(this).contractId())\n            revert InvalidImplementation();\n        if (newImplementationCodeHash != newImplementation.codehash) revert InvalidCodeHash();\n\n        if (params.length > 0) {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = newImplementation.delegatecall(abi.encodeWithSelector(this.setup.selector, params));\n\n            if (!success) revert SetupFailed();\n        }\n\n        emit Upgraded(newImplementation);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_IMPLEMENTATION_SLOT, newImplementation)\n        }\n    }\n\n    function setup(bytes calldata data) external override {\n        // Prevent setup from being called on the implementation\n        if (implementation() == address(0)) revert NotProxy();\n\n        _setup(data);\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    function _setup(bytes calldata data) internal virtual {}\n}\n"}, "@openzeppelin/contracts/token/ERC20/IERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"}, "contracts/interfaces/IRoledPausable.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IRoledPausable {\n    event PauserProposed(address indexed currentPauser, address indexed pendingPauser);\n    event PauserUpdated(address indexed pendingPauser);\n    event Paused();\n    event Unpaused();\n\n    error ContractIsPaused();\n    error NotPauser();\n    error NotPendingPauser();\n\n    function updatePauser(address _newPauser) external;\n\n    function acceptPauser() external;\n\n    function pause() external;\n\n    function unpause() external;\n\n    function paused() external view returns (bool value);\n\n    function pauser() external view returns (address value);\n\n    function pendingPauser() external view returns (address value);\n}\n"}, "contracts/interfaces/ISquidMulticall.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface ISquidMulticall {\n    enum CallType {\n        Default,\n        FullTokenBalance,\n        FullNativeBalance,\n        CollectTokenBalance\n    }\n\n    struct Call {\n        CallType callType;\n        address target;\n        uint256 value;\n        bytes callData;\n        bytes payload;\n    }\n\n    error AlreadyRunning();\n    error CallFailed(uint256 callPosition, bytes reason);\n\n    function run(Call[] calldata calls) external payable;\n}\n"}, "contracts/interfaces/ISquidRouter.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {ISquidMulticall} from \"./ISquidMulticall.sol\";\n\ninterface ISquidRouter {\n    event CrossMulticallExecuted(bytes32 indexed payloadHash);\n    event CrossMulticallFailed(bytes32 indexed payloadHash, bytes reason, address indexed refundRecipient);\n\n    error ZeroAddressProvided();\n    error ApprovalFailed();\n\n    function bridgeCall(\n        string calldata bridgedTokenSymbol,\n        uint256 amount,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address gasRefundRecipient,\n        bool enableExpress\n    ) external payable;\n\n    function callBridge(\n        address token,\n        uint256 amount,\n        ISquidMulticall.Call[] calldata calls,\n        string calldata bridgedTokenSymbol,\n        string calldata destinationChain,\n        string calldata destinationAddress\n    ) external payable;\n\n    function callBridgeCall(\n        address token,\n        uint256 amount,\n        ISquidMulticall.Call[] calldata calls,\n        string calldata bridgedTokenSymbol,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address gasRefundRecipient,\n        bool enableExpress\n    ) external payable;\n\n    function fundAndRunMulticall(address token, uint256 amount, ISquidMulticall.Call[] memory calls) external payable;\n}\n"}, "contracts/libraries/RoledPausable.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IRoledPausable} from \"../interfaces/IRoledPausable.sol\";\nimport {StorageSlot} from \"./StorageSlot.sol\";\n\nabstract contract RoledPausable is IRoledPausable {\n    using StorageSlot for bytes32;\n\n    bytes32 internal constant PAUSED_SLOT = keccak256(\"RoledPausable.paused\");\n    bytes32 internal constant PAUSER_SLOT = keccak256(\"RoledPausable.pauser\");\n    bytes32 internal constant PENDING_PAUSER_SLOT = keccak256(\"RoledPausable.pendingPauser\");\n\n    modifier whenNotPaused() {\n        if (paused()) revert ContractIsPaused();\n        _;\n    }\n\n    modifier onlyPauser() {\n        if (msg.sender != pauser()) revert NotPauser();\n        _;\n    }\n\n    constructor() {\n        _setPauser(msg.sender);\n    }\n\n    function updatePauser(address newPauser) external onlyPauser {\n        PENDING_PAUSER_SLOT.setAddress(newPauser);\n        emit PauserProposed(msg.sender, newPauser);\n    }\n\n    function acceptPauser() external {\n        if (msg.sender != pendingPauser()) revert NotPendingPauser();\n        _setPauser(msg.sender);\n        PENDING_PAUSER_SLOT.setAddress(address(0));\n    }\n\n    function pause() external virtual onlyPauser {\n        PAUSED_SLOT.setBool(true);\n        emit Paused();\n    }\n\n    function unpause() external virtual onlyPauser {\n        PAUSED_SLOT.setBool(false);\n        emit Unpaused();\n    }\n\n    function pauser() public view returns (address value) {\n        value = PAUSER_SLOT.getAddress();\n    }\n\n    function paused() public view returns (bool value) {\n        value = PAUSED_SLOT.getBool();\n    }\n\n    function pendingPauser() public view returns (address value) {\n        value = PENDING_PAUSER_SLOT.getAddress();\n    }\n\n    function _setPauser(address _pauser) internal {\n        PAUSER_SLOT.setAddress(_pauser);\n        emit PauserUpdated(_pauser);\n    }\n}\n"}, "contracts/libraries/StorageSlot.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nlibrary StorageSlot {\n    function setUint256(bytes32 slot, uint256 value) internal {\n        assembly {\n            sstore(slot, value)\n        }\n    }\n\n    function getUint256(bytes32 slot) internal view returns (uint256 value) {\n        assembly {\n            value := sload(slot)\n        }\n    }\n\n    function setAddress(bytes32 slot, address value) internal {\n        assembly {\n            sstore(slot, value)\n        }\n    }\n\n    function getAddress(bytes32 slot) internal view returns (address value) {\n        assembly {\n            value := sload(slot)\n        }\n    }\n\n    function setBool(bytes32 slot, bool value) internal {\n        assembly {\n            sstore(slot, value)\n        }\n    }\n\n    function getBool(bytes32 slot) internal view returns (bool value) {\n        assembly {\n            value := sload(slot)\n        }\n    }\n}\n"}, "contracts/router/SquidRouter.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {ISquidRouter} from \"../interfaces/ISquidRouter.sol\";\nimport {ISquidMulticall} from \"../interfaces/ISquidMulticall.sol\";\nimport {AxelarForecallable} from \"@axelar-network/axelar-gmp-sdk-solidity/contracts/executables/AxelarForecallable.sol\";\nimport {IAxelarGasService} from \"@axelar-network/axelar-cgp-solidity/contracts/interfaces/IAxelarGasService.sol\";\nimport {IAxelarGateway} from \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGateway.sol\";\nimport {Upgradable} from \"@axelar-network/axelar-gmp-sdk-solidity/contracts/upgradables/Upgradable.sol\";\nimport {RoledPausable} from \"../libraries/RoledPausable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract SquidRouter is ISquidRouter, AxelarForecallable, Upgradable, RoledPausable {\n    IAxelarGasService private immutable gasService;\n    IAxelarGasService private immutable forecallGasService;\n    ISquidMulticall private immutable squidMulticall;\n\n    constructor(\n        address _gateway,\n        address _gasService,\n        address _forecallGasService,\n        address _multicall\n    ) AxelarForecallable(_gateway) {\n        if (\n            _gateway == address(0) ||\n            _gasService == address(0) ||\n            _forecallGasService == address(0) ||\n            _multicall == address(0)\n        ) revert ZeroAddressProvided();\n\n        gasService = IAxelarGasService(_gasService);\n        forecallGasService = IAxelarGasService(_forecallGasService);\n        squidMulticall = ISquidMulticall(_multicall);\n    }\n\n    function bridgeCall(\n        string calldata bridgedTokenSymbol,\n        uint256 amount,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address gasRefundRecipient,\n        bool enableExpress\n    ) external payable whenNotPaused {\n        address bridgedTokenAddress = gateway.tokenAddresses(bridgedTokenSymbol);\n\n        _safeTransferFrom(bridgedTokenAddress, msg.sender, amount);\n        _bridgeCall(\n            bridgedTokenSymbol,\n            bridgedTokenAddress,\n            destinationChain,\n            destinationAddress,\n            payload,\n            gasRefundRecipient,\n            enableExpress\n        );\n    }\n\n    function callBridge(\n        address token,\n        uint256 amount,\n        ISquidMulticall.Call[] calldata calls,\n        string calldata bridgedTokenSymbol,\n        string calldata destinationChain,\n        string calldata destinationAddress\n    ) external payable whenNotPaused {\n        fundAndRunMulticall(token, amount, calls);\n\n        address bridgedTokenAddress = gateway.tokenAddresses(bridgedTokenSymbol);\n        uint256 bridgedTokenAmount = IERC20(bridgedTokenAddress).balanceOf(address(this));\n\n        _approve(bridgedTokenAddress, address(gateway), bridgedTokenAmount);\n        gateway.sendToken(destinationChain, destinationAddress, bridgedTokenSymbol, bridgedTokenAmount);\n    }\n\n    function callBridgeCall(\n        address token,\n        uint256 amount,\n        ISquidMulticall.Call[] calldata calls,\n        string calldata bridgedTokenSymbol,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address gasRefundRecipient,\n        bool enableExpress\n    ) external payable whenNotPaused {\n        fundAndRunMulticall(token, amount, calls);\n\n        address bridgedTokenAddress = gateway.tokenAddresses(bridgedTokenSymbol);\n\n        _bridgeCall(\n            bridgedTokenSymbol,\n            bridgedTokenAddress,\n            destinationChain,\n            destinationAddress,\n            payload,\n            gasRefundRecipient,\n            enableExpress\n        );\n    }\n\n    function contractId() external pure override returns (bytes32 id) {\n        id = keccak256(\"squid-router\");\n    }\n\n    function fundAndRunMulticall(\n        address token,\n        uint256 amount,\n        ISquidMulticall.Call[] memory calls\n    ) public payable whenNotPaused {\n        uint256 valueToSend;\n\n        if (token == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n            valueToSend = amount;\n        } else {\n            _transferTokenToMulticall(token, amount);\n        }\n\n        squidMulticall.run{value: valueToSend}(calls);\n    }\n\n    function _executeWithToken(\n        string calldata,\n        string calldata,\n        bytes calldata payload,\n        string calldata bridgedTokenSymbol,\n        uint256\n    ) internal override {\n        (ISquidMulticall.Call[] memory calls, address refundRecipient) = abi.decode(\n            payload,\n            (ISquidMulticall.Call[], address)\n        );\n\n        address bridgedTokenAddress = gateway.tokenAddresses(bridgedTokenSymbol);\n        uint256 contractBalance = IERC20(bridgedTokenAddress).balanceOf(address(this));\n\n        _approve(bridgedTokenAddress, address(squidMulticall), contractBalance);\n\n        try squidMulticall.run(calls) {\n            emit CrossMulticallExecuted(keccak256(payload));\n        } catch (bytes memory reason) {\n            // Refund tokens to refund recipient if swap fails\n            _safeTransfer(bridgedTokenAddress, refundRecipient, contractBalance);\n            emit CrossMulticallFailed(keccak256(payload), reason, refundRecipient);\n        }\n    }\n\n    function _bridgeCall(\n        string calldata bridgedTokenSymbol,\n        address bridgedTokenAddress,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address gasRefundRecipient,\n        bool enableExpress\n    ) private {\n        uint256 bridgedTokenBalance = IERC20(bridgedTokenAddress).balanceOf(address(this));\n\n        if (address(this).balance > 0) {\n            IAxelarGasService executionService = enableExpress ? forecallGasService : gasService;\n            executionService.payNativeGasForContractCallWithToken{value: address(this).balance}(\n                address(this),\n                destinationChain,\n                destinationAddress,\n                payload,\n                bridgedTokenSymbol,\n                bridgedTokenBalance,\n                gasRefundRecipient\n            );\n        }\n\n        _approve(bridgedTokenAddress, address(gateway), bridgedTokenBalance);\n        gateway.callContractWithToken(\n            destinationChain,\n            destinationAddress,\n            payload,\n            bridgedTokenSymbol,\n            bridgedTokenBalance\n        );\n    }\n\n    function _approve(address token, address spender, uint256 amount) private {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance < amount) {\n            if (allowance > 0) {\n                _approveCall(token, spender, 0);\n            }\n            _approveCall(token, spender, type(uint256).max);\n        }\n    }\n\n    function _approveCall(address token, address spender, uint256 amount) private {\n        // Unlimited approval is not security issue since the contract doesn't store tokens\n        (bool success, ) = token.call(abi.encodeWithSelector(IERC20.approve.selector, spender, amount));\n        if (!success) revert ApprovalFailed();\n    }\n\n    function _transferTokenToMulticall(address token, uint256 amount) private {\n        (bool success, bytes memory returnData) = token.call(\n            abi.encodeWithSelector(IERC20.transferFrom.selector, msg.sender, address(squidMulticall), amount)\n        );\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n        if (!transferred || token.code.length == 0) revert TransferFailed();\n    }\n\n    function _setup(bytes calldata data) internal override {\n        address _pauser = abi.decode(data, (address));\n        if (_pauser == address(0)) revert ZeroAddressProvided();\n        _setPauser(_pauser);\n    }\n}\n"}}, "settings": {"optimizer": {"enabled": true}, "viaIR": false, "evmVersion": "paris", "outputSelection": {"*": {"*": ["evm.legacyAssembly"]}}, "metadata": {"useLiteralContent": true}, "libraries": {}}}