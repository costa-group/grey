{"language": "Solidity", "settings": {"optimizer": {"enabled": true}, "viaIR": false, "outputSelection": {"*": {"*": ["evm.legacyAssembly"]}}, "remappings": []}, "sources": {"projects/marketplacev6/ArtMarketplaceV6.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol\";\n\ncontract ArtMarketplaceV6 is Ownable {\n    uint256 private constant BPS = 10_000;\n    uint256 private constant BID_INCREASE_THRESHOLD_ETH = 0.2 ether;\n    uint256 private constant BID_INCREASE_THRESHOLD_USDC = 300 * USDC_CONSTANT;\n    uint8 private constant DEFAULT_PLATFORM_FEE = 30; // whole % points\n    uint256 private constant EXTENSION_TIME = 10 minutes;\n    uint256 private constant INIT_AUCTION_DURATION = 24 hours;\n    uint256 private constant MIN_BID_ETH = 0.1 ether;\n    uint256 private constant MIN_BID_USDC = 30 * USDC_CONSTANT;\n    uint256 private constant MIN_BID_INCREASE_PRE = 2_000;\n    uint256 private constant MIN_BID_INCREASE_POST = 1_000;\n    uint256 private constant SAFE_GAS_LIMIT = 30_000;\n    // Mainnet USDC: 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\n    // Sepolia USDC: 0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238\n    address private immutable USDC;\n    uint256 private constant USDC_CONSTANT = 10**6; // USDC uses 6 decimals instead of eth's 18\n\n    address public beneficiary;\n    bool public paused;\n\n    struct Auction {\n        uint24 offsetFromEnd;\n        uint72 amount;\n        address bidder;\n    }\n\n    struct AuctionConfig {\n        address artist;\n        uint8 platformFee; // in whole % points (30 = 30%)\n        uint8 royalty; // in whole % points, should be 0 for primary sales\n        uint80 buyNowStartTime;\n        uint80 auctionStartTime;\n        uint88 buyNowPrice;\n        uint88 reservePrice;\n        uint88 preBidPrice;\n        address seller; // when seller is schedueled as 0x0, seller defaults to the artist (i.e. primary sale)\n        bool usdcFlag; // true for usdc, false for eth\n    }\n\n    mapping(bytes32 => AuctionConfig) public auctionConfig;\n    mapping(uint256 => Auction) public auctionIdToAuction;\n    mapping(uint256 => bytes32) public auctionIdToConfigHash;\n\n    event BidMade(\n        uint256 indexed auctionId,\n        address indexed collectionAddress,\n        uint256 indexed tokenId,\n        address bidder,\n        uint256 amount,\n        uint256 timestamp\n    );\n    struct Receipt {\n        address orderMaker;\n        address orderTaker;\n        address collection;\n        uint256 tokenId;\n        address currency; // 0x0 when ETH sale\n        address artist;\n        address platform;\n        uint256 salePrice; // in wei (salePrice = funds to seller + platformFee + royalty = price buyer paid)\n        uint256 platformFee; // in wei\n        uint256 royalty; // in wei\n    }\n    event Sale(Receipt[] receipts);\n\n    constructor(address contractOwner, address _usdcAddress) Ownable(contractOwner) {\n        setBeneficiary(contractOwner);\n        USDC = _usdcAddress;\n    }\n\n    function bid(\n        uint256[] calldata auctionIds,\n        uint256[] calldata expectedPrices\n    ) external payable {\n        require(!paused, \"Bidding is paused\");\n        require(auctionIds.length == expectedPrices.length);\n\n        uint256 totalETH;\n        uint256 totalUSDC;\n        for (uint256 i; i < auctionIds.length; ++i) {\n            uint256 auctionId = auctionIds[i];\n            uint256 expectedPrice = expectedPrices[i];\n            AuctionConfig memory config = getConfig(auctionId);\n\n            // kickstart auction functionality\n            if (config.auctionStartTime == type(uint80).max) {\n                config.auctionStartTime = uint80(block.timestamp);\n                bytes32 configHash = keccak256(abi.encode(config));\n                if (auctionConfig[configHash].auctionStartTime == 0) {\n                    auctionConfig[configHash] = config;\n                }\n                auctionIdToConfigHash[auctionId] = configHash;\n            }\n\n            if (\n                !(isAuctionActive(auctionId) ||\n                    (config.preBidPrice > 0 &&\n                        expectedPrice >= config.preBidPrice)) ||\n                block.timestamp < config.buyNowStartTime\n            ) {\n                continue;\n            }\n\n            Auction memory highestBid = auctionIdToAuction[auctionId];\n            uint256 bidIncrease = highestBid.amount >=\n                getBidIncreaseThreshold(config.usdcFlag)\n                ? MIN_BID_INCREASE_POST\n                : MIN_BID_INCREASE_PRE;\n\n            if (\n                expectedPrice >=\n                ((highestBid.amount * (BPS + bidIncrease)) / BPS) &&\n                expectedPrice >= getReservePrice(auctionId)\n            ) {\n                uint256 refundAmount;\n                address refundBidder;\n                uint256 offset = highestBid.offsetFromEnd;\n                uint256 endTime = getAuctionEndTime(auctionId);\n\n                if (highestBid.amount > 0) {\n                    refundAmount = highestBid.amount;\n                    refundBidder = highestBid.bidder;\n                }\n\n                if (endTime - block.timestamp < EXTENSION_TIME) {\n                    offset += block.timestamp + EXTENSION_TIME - endTime;\n                }\n\n                auctionIdToAuction[auctionId] = Auction(\n                    uint24(offset),\n                    uint72(expectedPrice),\n                    msg.sender\n                );\n\n                if (config.usdcFlag) {\n                    totalUSDC += expectedPrice;\n                } else {\n                    totalETH += expectedPrice;\n                }\n\n                emit BidMade(\n                    auctionId,\n                    getCollectionFromId(auctionId),\n                    getArtTokenIdFromId(auctionId),\n                    msg.sender,\n                    expectedPrice,\n                    block.timestamp\n                );\n\n                if (refundAmount > 0) {\n                    if (config.usdcFlag) {\n                        IERC20(USDC).transfer(refundBidder, refundAmount);\n                    } else {\n                        SafeTransferLib.forceSafeTransferETH(\n                            refundBidder,\n                            refundAmount,\n                            SAFE_GAS_LIMIT\n                        );\n                    }\n                }\n            }\n        }\n        if (totalUSDC > 0) {\n            IERC20(USDC).transferFrom(msg.sender, address(this), totalUSDC);\n        }\n        require(msg.value >= totalETH, \"Incorrect amount of ETH sent\");\n        uint256 totalFailedETH = msg.value - totalETH;\n        if (totalFailedETH > 0) {\n            SafeTransferLib.forceSafeTransferETH(\n                msg.sender,\n                totalFailedETH,\n                SAFE_GAS_LIMIT\n            );\n        }\n    }\n\n    function buyNow(uint256[] calldata auctionIds) external payable {\n        require(!paused, \"Buying is paused\");\n\n        uint256 totalETH;\n        uint256 amountForBeneETH;\n        uint256 amountForBeneUSDC;\n\n        // Create a dynamic array to store tokenIds of successfully purchased tokens\n        Receipt[] memory successfulAuctions = new Receipt[](auctionIds.length);\n        uint256 successfulCount = 0;\n\n        for (uint256 i = 0; i < auctionIds.length; ++i) {\n            uint256 auctionId = auctionIds[i];\n            AuctionConfig memory config = getConfig(auctionId);\n            uint256 amountToPay = config.buyNowPrice;\n\n            if (\n                (block.timestamp < config.buyNowStartTime) ||\n                (config.auctionStartTime <= block.timestamp) ||\n                amountToPay == 0\n            ) {\n                continue;\n            }\n\n            // Mark the auction as settled and store the amount paid\n            config.auctionStartTime = uint80(block.timestamp - INIT_AUCTION_DURATION);\n            bytes32 configHash = keccak256(abi.encode(config));\n            if (auctionConfig[configHash].auctionStartTime == 0) {\n                auctionConfig[configHash] = config;\n            }\n            auctionIdToConfigHash[auctionId] = configHash;\n            auctionIdToAuction[auctionId] = Auction(\n                0,\n                uint72(amountToPay),\n                msg.sender\n            );\n\n            if (!config.usdcFlag) {\n                totalETH += amountToPay;\n            }\n\n            // Mint the token to the buyer\n            _mintOrTransfer(msg.sender, auctionId);\n            \n            uint256 amountForPlatform = (amountToPay * config.platformFee) / 100;\n            uint256 royalty = (amountToPay * config.royalty) / 100;\n            uint256 amountForSeller = amountToPay - amountForPlatform - royalty;\n\n            successfulAuctions[successfulCount] = Receipt(\n                config.seller,\n                msg.sender,\n                getCollectionFromId(auctionId),\n                getArtTokenIdFromId(auctionId),\n                config.usdcFlag ? USDC : address(0),\n                config.artist,\n                beneficiary,\n                amountToPay,\n                amountForPlatform,\n                royalty\n            );\n            successfulCount++;\n\n            if (config.usdcFlag) {\n                amountForBeneUSDC += amountForPlatform;\n                IERC20(USDC).transferFrom(msg.sender, config.seller, amountForSeller);\n                if (royalty > 0) {\n                    IERC20(USDC).transferFrom(msg.sender, config.artist, royalty);\n                }\n            } else {\n                amountForBeneETH += amountForPlatform;\n                SafeTransferLib.forceSafeTransferETH(\n                    config.seller,\n                    amountForSeller,\n                    SAFE_GAS_LIMIT\n                );\n                if (royalty > 0) {\n                    SafeTransferLib.forceSafeTransferETH(\n                        config.artist,\n                        royalty,\n                        SAFE_GAS_LIMIT\n                    );\n                }\n            }\n        }\n\n        if (amountForBeneUSDC > 0) {\n            IERC20(USDC).transferFrom(msg.sender, beneficiary, amountForBeneUSDC);\n        }\n        require(msg.value >= totalETH, \"Incorrect amount of ETH sent\");\n        uint256 totalFailedETH = msg.value - totalETH;\n        if (totalFailedETH > 0) {\n            SafeTransferLib.forceSafeTransferETH(\n                msg.sender,\n                totalFailedETH,\n                SAFE_GAS_LIMIT\n            );\n        }\n        if (amountForBeneETH > 0) {\n            SafeTransferLib.forceSafeTransferETH(\n                beneficiary,\n                amountForBeneETH,\n                SAFE_GAS_LIMIT\n            );\n        }\n\n        // Emit Sale event for all successful token purchases\n        if (successfulCount > 0) {\n            // Create a resized array with only the successfully bought tokenIds\n            Receipt[] memory sales = new Receipt[](successfulCount);\n            for (uint256 i = 0; i < successfulCount; ++i) {\n                sales[i] = successfulAuctions[i];\n            }\n\n            emit Sale(sales);\n        }\n    }\n\n    function settleAuctions(uint256[] calldata auctionIds) external {\n        uint256 amountForBeneETH;\n        uint256 amountForBeneUSDC;\n        Receipt[] memory successfulAuctions = new Receipt[](auctionIds.length);\n        uint256 successfulCount = 0;\n\n        for (uint256 i; i < auctionIds.length; ++i) {\n            uint256 auctionId = auctionIds[i];\n            Auction memory highestBid = auctionIdToAuction[auctionId];\n            require(isAuctionOver(auctionId), \"Auction is still active\");\n\n            uint256 amountToPay = highestBid.amount;\n            require(amountToPay > 0);\n            _mintOrTransfer(highestBid.bidder, auctionId);\n            AuctionConfig memory config = getConfig(auctionId);\n\n            uint256 amountForPlatform = (amountToPay * config.platformFee) / 100;\n            uint256 royalty = (amountToPay * config.royalty) / 100;\n            uint256 amountForSeller = amountToPay - amountForPlatform - royalty;\n\n            successfulAuctions[successfulCount] = Receipt(\n                config.seller,\n                highestBid.bidder,\n                getCollectionFromId(auctionId),\n                getArtTokenIdFromId(auctionId),\n                config.usdcFlag ? USDC : address(0),\n                config.artist,\n                beneficiary,\n                amountToPay,\n                amountForPlatform,\n                royalty\n            );\n\n            if (config.usdcFlag) {\n                amountForBeneUSDC += amountForPlatform;\n                IERC20(USDC).transfer(config.seller, amountForSeller);\n                if (royalty > 0) {\n                    IERC20(USDC).transfer(config.artist, royalty);\n                }\n            } else {\n                amountForBeneETH += amountForPlatform;\n                SafeTransferLib.forceSafeTransferETH(\n                    config.seller,\n                    amountForSeller,\n                    SAFE_GAS_LIMIT\n                );\n                if (royalty > 0) {\n                    SafeTransferLib.forceSafeTransferETH(\n                        config.artist,\n                        royalty,\n                        SAFE_GAS_LIMIT\n                    );\n                }\n            }\n        }\n\n        emit Sale(successfulAuctions);\n\n        if (amountForBeneUSDC > 0) {\n            IERC20(USDC).transfer(beneficiary, amountForBeneUSDC);\n        }\n        if (amountForBeneETH > 0) {\n            SafeTransferLib.forceSafeTransferETH(\n                beneficiary,\n                amountForBeneETH,\n                SAFE_GAS_LIMIT\n            );\n        }\n    }\n\n    function _mintOrTransfer(address to, uint256 auctionId) internal {\n        address collection = getCollectionFromId(auctionId);\n        uint256 tokenId = getArtTokenIdFromId(auctionId);\n        try INFT(collection).ownerOf(tokenId) returns (address _owner) {\n            if (_owner == address(0)) {\n                INFT(collection).mint(to, tokenId);\n            } else {\n                INFT(collection).transferFrom(_owner, to, tokenId);\n            }\n        } catch {\n            INFT(collection).mint(to, tokenId);\n        }\n    }\n\n    // INTERNAL\n    function _resetAuction(address collectionAddress, uint256 tokenId)\n        internal\n    {\n        uint256 auctionId = artTokentoAuctionId(collectionAddress, tokenId);\n        if (!isAuctionOver(auctionId)) {\n            Auction memory auctionData = auctionIdToAuction[auctionId];\n            if (auctionData.amount > 0) {\n                SafeTransferLib.forceSafeTransferETH(\n                    auctionData.bidder,\n                    auctionData.amount,\n                    SAFE_GAS_LIMIT\n                );\n            }\n        }\n        auctionIdToConfigHash[auctionId] = bytes32(0);\n        auctionIdToAuction[auctionId] = Auction(0, 0, address(0));\n    }\n\n    function _schedule(\n        address collectionAddress,\n        uint256 tokenId,\n        uint256 buyNowStartTime,\n        uint256 auctionStartTime,\n        address artist,\n        address seller,\n        uint256 platformFee,\n        uint256 royalty,\n        uint256 buyNowPrice,\n        uint256 reserve,\n        uint256 preBidPrice,\n        bool usdcFlag\n    ) internal {\n        uint256 auctionId = artTokentoAuctionId(collectionAddress, tokenId);\n        require(auctionIdToConfigHash[auctionId] == bytes32(0));\n\n        uint256 adjAucStartTime = auctionStartTime;\n        if (adjAucStartTime == 0) {\n            adjAucStartTime = type(uint80).max;\n        }\n\n        AuctionConfig memory config = AuctionConfig(\n            artist,\n            platformFee == 0 ? DEFAULT_PLATFORM_FEE : uint8(platformFee),\n            uint8(royalty),\n            uint80(buyNowStartTime),\n            uint80(adjAucStartTime),\n            uint88(buyNowPrice),\n            uint88(reserve),\n            uint88(preBidPrice),\n            seller == address(0) ? artist : seller,\n            usdcFlag\n        );\n        bytes32 configHash = keccak256(abi.encode(config));\n        if (auctionConfig[configHash].auctionStartTime == 0) {\n            auctionConfig[configHash] = config;\n        }\n        auctionIdToConfigHash[auctionId] = configHash;\n    }\n\n    // ONLY OWNER\n    function scheduleAuctionsLight(\n        address collection,\n        uint256[] calldata tokenIds,\n        uint256 buyNowStartTime,\n        uint256 auctionStartTime,\n        address artist,\n        address seller,\n        uint256 platformFee,\n        uint256 royalty,\n        uint256 buyNowPrice,\n        uint256 reservePrice,\n        uint256 preBidPrice,\n        bool usdcFlag\n    ) external onlyOwner {\n        for (uint256 i; i < tokenIds.length; ++i) {\n            _schedule(\n                collection,\n                tokenIds[i],\n                buyNowStartTime,\n                auctionStartTime,\n                artist,\n                seller,\n                platformFee,\n                royalty,\n                buyNowPrice,\n                reservePrice,\n                preBidPrice,\n                usdcFlag\n            );\n        }\n    }\n\n    function resetAuctions(\n        address[] calldata collections,\n        uint256[] calldata tokenIds\n    ) external onlyOwner {\n        for (uint256 i; i < collections.length; ++i) {\n            _resetAuction(collections[i], tokenIds[i]);\n        }\n    }\n\n    function scheduleAuctions(\n        address[] calldata collections,\n        uint256[] calldata tokenIds,\n        uint256[] calldata buyNowStartTimes,\n        uint256[] calldata auctionStartTimes,\n        address[] calldata artists,\n        address[] calldata sellers,\n        uint256[] calldata platformFees,\n        uint256[] calldata royalties,\n        uint256[] calldata buyNowPrices,\n        uint256[] calldata reservePrices,\n        uint256[] calldata preBidPrices,\n        bool[] calldata usdcFlags\n    ) external onlyOwner {\n        for (uint256 i; i < collections.length; ++i) {\n            _schedule(\n                collections[i],\n                tokenIds[i],\n                buyNowStartTimes[i],\n                auctionStartTimes[i],\n                artists[i],\n                sellers[i],\n                platformFees[i],\n                royalties[i],\n                buyNowPrices[i],\n                reservePrices[i],\n                preBidPrices[i],\n                usdcFlags[i]\n            );\n        }\n    }\n\n    function setBeneficiary(address _beneficiary) public onlyOwner {\n        beneficiary = _beneficiary;\n    }\n\n    function setPaused(bool _paused) external onlyOwner {\n        paused = _paused;\n    }\n\n    // GETTERS\n\n    function artTokentoAuctionId(address collection, uint256 tokenId)\n        public\n        pure\n        returns (uint256)\n    {\n        return (uint256(uint160(collection)) << 96) | uint96(tokenId);\n    }\n\n    function isAuctionActive(uint256 auctionId) public view returns (bool) {\n        uint256 startTime = getConfig(auctionId).auctionStartTime;\n        uint256 endTime = getAuctionEndTime(auctionId);\n        return (startTime > 0 &&\n            block.timestamp >= startTime &&\n            block.timestamp < endTime);\n    }\n\n    function isAuctionOver(uint256 auctionId) public view returns (bool) {\n        uint256 startTime = getConfig(auctionId).auctionStartTime;\n        uint256 endTime = getAuctionEndTime(auctionId);\n        return (startTime > 0 && block.timestamp >= endTime);\n    }\n\n    function getAuctionEndTime(uint256 auctionId)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            getConfig(auctionId).auctionStartTime +\n            INIT_AUCTION_DURATION +\n            auctionIdToAuction[auctionId].offsetFromEnd;\n    }\n\n    function getAuctionStartTime(uint256 auctionId)\n        public\n        view\n        returns (uint256)\n    {\n        return getConfig(auctionId).auctionStartTime;\n    }\n\n    function getCollectionFromId(uint256 id) public pure returns (address) {\n        return address(uint160(id >> 96));\n    }\n\n    function getConfig(uint256 id) public view returns (AuctionConfig memory) {\n        return auctionConfig[auctionIdToConfigHash[id]];\n    }\n\n    function getArtTokenIdFromId(uint256 id) public pure returns (uint256) {\n        return uint256(uint96(id));\n    }\n\n    function getReservePrice(uint256 auctionId) public view returns (uint256) {\n        AuctionConfig memory config = getConfig(auctionId);\n        uint256 reserve = config.reservePrice;\n        return reserve != 0 ? reserve : getMinBid(config.usdcFlag);\n    }\n\n    function getBidIncreaseThreshold(bool isUSDC)\n        internal\n        pure\n        returns (uint256)\n    {\n        return\n            isUSDC ? BID_INCREASE_THRESHOLD_USDC : BID_INCREASE_THRESHOLD_ETH;\n    }\n\n    function getMinBid(bool isUSDC) internal pure returns (uint256) {\n        return isUSDC ? MIN_BID_USDC : MIN_BID_ETH;\n    }\n}\n\ninterface INFT {\n    function mint(address to, uint256 tokenId) external;\n\n    function ownerOf(uint256 tokenId) external view returns (address);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n}\n"}, "https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\n///\n/// @dev Note:\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\nlibrary SafeTransferLib {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /// @dev The ERC20 `transferFrom` has failed.\n    error TransferFromFailed();\n\n    /// @dev The ERC20 `transfer` has failed.\n    error TransferFailed();\n\n    /// @dev The ERC20 `approve` has failed.\n    error ApproveFailed();\n\n    /// @dev The Permit2 operation has failed.\n    error Permit2Failed();\n\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\n    error Permit2AmountOverflow();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         CONSTANTS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\n\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\n    /// storage reads and writes, but low enough to prevent griefing.\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\n\n    /// @dev The unique EIP-712 domain domain separator for the DAI token contract.\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\n\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /// @dev The canonical Permit2 address.\n    /// [Github](https://github.com/Uniswap/permit2)\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       ETH OPERATIONS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\n    //\n    // The regular variants:\n    // - Forwards all remaining gas to the target.\n    // - Reverts if the target reverts.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The force variants:\n    // - Forwards with an optional gas stipend\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\n    // - If the target reverts, or if the gas stipend is exhausted,\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The try variants:\n    // - Forwards with a mandatory gas stipend.\n    // - Instead of reverting, returns whether the transfer succeeded.\n\n    /// @dev Sends `amount` (in wei) ETH to `to`.\n    function safeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`.\n    function safeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer all the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // forgefmt: disable-next-item\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      ERC20 OPERATIONS                      */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for\n    /// the current contract to manage.\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                success := lt(or(iszero(extcodesize(token)), returndatasize()), success)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have their entire balance approved for the current contract to manage.\n    function safeTransferAllFrom(address token, address from, address to)\n        internal\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransfer(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n            mstore(0x20, address()) // Store the address of the current contract.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x14, to) // Store the `to` argument.\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// Reverts upon failure.\n    function safeApprove(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\n    /// Reverts upon failure.\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, retrying upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x34, 0) // Store 0 for the `amount`.\n                    mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n                    pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\n                    mstore(0x34, amount) // Store back the original `amount`.\n                    // Retry the approval, reverting upon failure.\n                    success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                    if iszero(and(eq(mload(0x00), 1), success)) {\n                        // Check the `extcodesize` again just in case the token selfdestructs lol.\n                        if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                            mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                            revert(0x1c, 0x04)\n                        }\n                    }\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\n    /// Returns zero if the `token` does not exist.\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, account) // Store the `account` argument.\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            amount :=\n                mul( // The arguments of `mul` are evaluated from right to left.\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\n                    )\n                )\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\n        if (!trySafeTransferFrom(token, from, to, amount)) {\n            permit2TransferFrom(token, from, to, amount);\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\n    /// Reverts upon failure.\n    function permit2TransferFrom(address token, address from, address to, uint256 amount)\n        internal\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\n            mstore(add(m, 0x54), amount)\n            mstore(add(m, 0x34), to)\n            mstore(add(m, 0x20), shl(96, from))\n            // `transferFrom(address,address,uint160,address)`.\n            mstore(m, 0x36c78516000000000000000000000000)\n            let p := PERMIT2\n            let exists := eq(chainid(), 1)\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\n            if iszero(\n                and(\n                    call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00),\n                    lt(iszero(extcodesize(token)), exists) // Token has code and Permit2 exists.\n                )\n            ) {\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\n            }\n        }\n    }\n\n    /// @dev Permit a user to spend a given amount of\n    /// another user's tokens via native EIP-2612 permit if possible, falling\n    /// back to Permit2 if native permit fails or is not implemented on the token.\n    function permit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        bool success;\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} shl(96, xor(token, WETH9)) {} {\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\n                if iszero(\n                    and( // The arguments of `and` are evaluated from right to left.\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\n                    )\n                ) { break }\n                // After here, we can be sure that token is a contract.\n                let m := mload(0x40)\n                mstore(add(m, 0x34), spender)\n                mstore(add(m, 0x20), shl(96, owner))\n                mstore(add(m, 0x74), deadline)\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\n                    mstore(0x14, owner)\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\n                    mstore(add(m, 0x94), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\n                    // `nonces` is already at `add(m, 0x54)`.\n                    // `1` is already stored at `add(m, 0x94)`.\n                    mstore(add(m, 0xb4), and(0xff, v))\n                    mstore(add(m, 0xd4), r)\n                    mstore(add(m, 0xf4), s)\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\n                    break\n                }\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\n                mstore(add(m, 0x54), amount)\n                mstore(add(m, 0x94), and(0xff, v))\n                mstore(add(m, 0xb4), r)\n                mstore(add(m, 0xd4), s)\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\n                break\n            }\n        }\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\n    }\n\n    /// @dev Simple permit on the Permit2 contract.\n    function simplePermit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\n            {\n                let addressMask := shr(96, not(0))\n                mstore(add(m, 0x20), and(addressMask, owner))\n                mstore(add(m, 0x40), and(addressMask, token))\n                mstore(add(m, 0x60), and(addressMask, spender))\n                mstore(add(m, 0xc0), and(addressMask, spender))\n            }\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\n                )\n            ) {\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\n            }\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\n            // `owner` is already `add(m, 0x20)`.\n            // `token` is already at `add(m, 0x40)`.\n            mstore(add(m, 0x60), amount)\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\n            // `nonce` is already at `add(m, 0xa0)`.\n            // `spender` is already at `add(m, 0xc0)`.\n            mstore(add(m, 0xe0), deadline)\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\n            mstore(add(m, 0x120), 0x41) // `signature` length.\n            mstore(add(m, 0x140), r)\n            mstore(add(m, 0x160), s)\n            mstore(add(m, 0x180), shl(248, v))\n            if iszero( // Revert if token does not have code, or if the call fails.\n            mul(extcodesize(token), call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00))) {\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"}, "@openzeppelin/contracts/token/ERC20/IERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"}, "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.30;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"}, "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"}}}