{"language": "Solidity", "sources": {"src/PAMM.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nabstract contract ERC6909Minimal {\n    event OperatorSet(address indexed owner, address indexed operator, bool approved);\n    event Approval(\n        address indexed owner, address indexed spender, uint256 indexed id, uint256 amount\n    );\n    event Transfer(\n        address caller, address indexed from, address indexed to, uint256 indexed id, uint256 amount\n    );\n\n    mapping(address => mapping(address => bool)) public isOperator;\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public allowance;\n\n    function transfer(address receiver, uint256 id, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender][id] -= amount;\n        balanceOf[receiver][id] += amount;\n        emit Transfer(msg.sender, msg.sender, receiver, id, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 id, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender][id] = amount;\n        emit Approval(msg.sender, spender, id, amount);\n        return true;\n    }\n\n    function setOperator(address operator, bool approved) public virtual returns (bool) {\n        isOperator[msg.sender][operator] = approved;\n        emit OperatorSet(msg.sender, operator, approved);\n        return true;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == 0x01ffc9a7 || interfaceId == 0x0f632fb3;\n    }\n\n    function _mint(address receiver, uint256 id, uint256 amount) internal virtual {\n        balanceOf[receiver][id] += amount;\n        emit Transfer(msg.sender, address(0), receiver, id, amount);\n    }\n\n    function _burn(address sender, uint256 id, uint256 amount) internal virtual {\n        balanceOf[sender][id] -= amount;\n        emit Transfer(msg.sender, sender, address(0), id, amount);\n    }\n}\n\ninterface IZAMM {\n    struct PoolKey {\n        uint256 id0;\n        uint256 id1;\n        address token0;\n        address token1;\n        uint256 feeOrHook;\n    }\n\n    function pools(uint256 poolId)\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast,\n            uint256 price0CumulativeLast,\n            uint256 price1CumulativeLast,\n            uint256 kLast,\n            uint256 supply\n        );\n\n    function addLiquidity(\n        PoolKey calldata poolKey,\n        uint256 amount0Desired,\n        uint256 amount1Desired,\n        uint256 amount0Min,\n        uint256 amount1Min,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256 amount0, uint256 amount1, uint256 liquidity);\n\n    function swapExactOut(\n        PoolKey calldata poolKey,\n        uint256 amountOut,\n        uint256 amountInMax,\n        bool zeroForOne,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256 amountIn);\n\n    function deposit(address token, uint256 id, uint256 amount) external payable;\n    function recoverTransientBalance(address token, uint256 id, address to)\n        external\n        returns (uint256 amount);\n}\n\n/*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n| PredictionAMM (PAMM) \u2014 CPMM-backed YES/NO markets\n|  \u2022 Pool fee = 10 bps (paid to ZAMM with fee switch on)\n|  \u2022 Pot in wstETH; PM+ZAMM excluded from payout denominator\n|  \u2022 Path-fair EV charging via Simpson\u2019s rule (fee-aware)\n|\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500*/\ncontract PAMM is ERC6909Minimal {\n    /*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 errors \u2500\u2500\u2500\u2500\u2500\u2500\u2500*/\n    error MarketExists();\n    error MarketNotFound();\n    error MarketClosed();\n    error MarketNotClosed();\n    error MarketResolved();\n    error MarketNotResolved();\n    error OnlyResolver();\n    error InvalidResolver();\n    error AlreadyResolved();\n    error NoWinningShares();\n    error AmountZero();\n    error InvalidClose();\n    error FeeOverflow();\n    error PoolNotSeeded();\n    error InsufficientLiquidity();\n    error SlippageOppIn();\n    error InsufficientZap();\n    error InsufficientWst();\n    error NoEth();\n    error EthNotAllowed();\n    error NoCirculating();\n    error NotClosable();\n    error SeedBothSides();\n    error InvalidReceiver();\n\n    /*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 storage \u2500\u2500\u2500\u2500\u2500\u2500*/\n    struct Market {\n        address resolver;\n        bool resolved;\n        bool outcome; // true=YES wins, false=NO wins\n        bool canClose; // resolver can early-close\n        uint72 close; // trading close timestamp\n        uint256 pot; // wstETH collateral pool\n        uint256 payoutPerShare; // Q-scaled\n    }\n\n    uint256 constant Q = 1e18;\n    uint256 constant FEE_BPS = 10; // 0.1% pool fee\n\n    // ZAMM singleton\n    IZAMM constant ZAMM = IZAMM(0x000000000000040470635EB91b7CE4D132D616eD);\n\n    /*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 pm-AMM tuning (set once at create) \u2500\u2500\u2500\u2500\u2500\u2500\u2500*/\n    struct PMTuning {\n        uint32 lateRampStart; // seconds before close to start ramp (0 = off)\n        uint16 lateRampMaxBps; // +bps at T (applied to EV charge; inverse to refunds)\n        uint16 extremeMaxBps; // +bps at extremes p\u22480/1 (linear in |p-0.5|)\n    }\n\n    mapping(uint256 => PMTuning) public pmTuning;\n    mapping(uint256 => bool) public pmTuningFinal;\n\n    error TuningBadCaps();\n\n    event PMTuningSet(uint256 indexed marketId, PMTuning t, bool finalized);\n\n    uint256[] public allMarkets;\n    mapping(uint256 id => Market) public markets;\n    mapping(uint256 id => uint256) public totalSupply;\n    mapping(uint256 id => string) public descriptions;\n    mapping(address resolver => uint16) public resolverFeeBps;\n\n    /*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 events \u2500\u2500\u2500\u2500\u2500\u2500\u2500*/\n    event Created(\n        uint256 indexed marketId, uint256 indexed noId, string description, address resolver\n    );\n    event Seeded(uint256 indexed marketId, uint256 yesSeed, uint256 noSeed, uint256 liquidity);\n    event Bought(address indexed buyer, uint256 indexed id, uint256 sharesOut, uint256 wstIn);\n    event Sold(address indexed seller, uint256 indexed id, uint256 sharesIn, uint256 wstOut);\n\n    event Resolved(uint256 indexed marketId, bool outcome);\n    event Claimed(address indexed claimer, uint256 indexed id, uint256 shares, uint256 payout);\n    event Closed(uint256 indexed marketId, uint256 ts, address indexed by);\n    event ResolverFeeSet(address indexed resolver, uint16 bps);\n\n    constructor() payable {}\n\n    /*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 id helpers \u2500\u2500\u2500*/\n    function getMarketId(string calldata description, address resolver)\n        public\n        pure\n        returns (uint256)\n    {\n        return uint256(keccak256(abi.encodePacked(\"PMARKET:YES\", description, resolver)));\n    }\n\n    function getNoId(uint256 marketId) public pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(\"PMARKET:NO\", marketId)));\n    }\n\n    function _poolKey(uint256 yesId, uint256 noId) internal view returns (IZAMM.PoolKey memory k) {\n        (uint256 id0, uint256 id1) = (yesId < noId) ? (yesId, noId) : (noId, yesId);\n        k = IZAMM.PoolKey({\n            id0: id0,\n            id1: id1,\n            token0: address(this),\n            token1: address(this),\n            feeOrHook: FEE_BPS\n        });\n    }\n\n    function _poolId(IZAMM.PoolKey memory k) internal pure returns (uint256 id) {\n        id = uint256(keccak256(abi.encode(k.id0, k.id1, k.token0, k.token1, k.feeOrHook)));\n    }\n\n    function name(uint256 id) public pure returns (string memory) {\n        return string(abi.encodePacked(\"PAMM-\", _toString(id)));\n    }\n\n    function symbol(uint256) public pure returns (string memory) {\n        return \"PAMM\";\n    }\n\n    /*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 lifecycle \u2500\u2500\u2500*/\n    function createMarket(\n        string calldata description,\n        address resolver,\n        uint72 close,\n        bool canClose,\n        uint256 seedYes,\n        uint256 seedNo\n    ) public returns (uint256 marketId, uint256 noId) {\n        require(close > block.timestamp, InvalidClose());\n        require(resolver != address(0), InvalidResolver());\n\n        marketId = getMarketId(description, resolver);\n        noId = getNoId(marketId);\n        require(markets[marketId].resolver == address(0), MarketExists());\n\n        markets[marketId] = Market({\n            resolver: resolver,\n            resolved: false,\n            outcome: false,\n            canClose: canClose,\n            close: close,\n            pot: 0,\n            payoutPerShare: 0\n        });\n\n        allMarkets.push(marketId);\n        descriptions[marketId] = description;\n\n        emit Created(marketId, noId, description, resolver);\n\n        if (seedYes != 0 || seedNo != 0) {\n            require(seedYes != 0 && seedNo != 0, SeedBothSides());\n            _seedYesNoPool(marketId, seedYes, seedNo);\n        }\n    }\n\n    function createMarketWithPMTuning(\n        string calldata description,\n        address resolver,\n        uint72 close,\n        bool canClose,\n        uint256 seedYes,\n        uint256 seedNo,\n        PMTuning calldata t\n    ) public returns (uint256 marketId, uint256 noId) {\n        (marketId, noId) = createMarket(description, resolver, close, canClose, seedYes, seedNo);\n\n        // hard caps to avoid crazy tuning\n        if (t.lateRampMaxBps > 2_000 || t.extremeMaxBps > 2_000) revert TuningBadCaps();\n        require(t.lateRampStart == 0 || t.lateRampStart <= close, TuningBadCaps());\n\n        pmTuning[marketId] = t;\n        pmTuningFinal[marketId] = true; // immutable\u2014no updates allowed / placeholder for future tweaks\n        emit PMTuningSet(marketId, t, true);\n    }\n\n    function _seedYesNoPool(uint256 marketId, uint256 seedYes, uint256 seedNo) internal {\n        uint256 yesId = marketId;\n        uint256 noId = getNoId(marketId);\n        IZAMM.PoolKey memory key = _poolKey(yesId, noId);\n\n        // Mint seeds to PM (non-circulating; will be held by ZAMM as LP position):\n        _mint(address(this), yesId, seedYes);\n        totalSupply[yesId] += seedYes;\n        _mint(address(this), noId, seedNo);\n        totalSupply[noId] += seedNo;\n\n        (uint256 a0, uint256 a1) = (key.id0 == yesId) ? (seedYes, seedNo) : (seedNo, seedYes);\n        ZAMM.deposit(address(this), key.id0, a0);\n        ZAMM.deposit(address(this), key.id1, a1);\n\n        (uint256 used0, uint256 used1, uint256 liq) =\n            ZAMM.addLiquidity(key, a0, a1, 0, 0, address(this), block.timestamp);\n\n        if (used0 < a0) {\n            uint256 ret = ZAMM.recoverTransientBalance(address(this), key.id0, address(this));\n            _burn(address(this), key.id0, ret);\n            totalSupply[key.id0] -= ret;\n        }\n        if (used1 < a1) {\n            uint256 ret = ZAMM.recoverTransientBalance(address(this), key.id1, address(this));\n            _burn(address(this), key.id1, ret);\n            totalSupply[key.id1] -= ret;\n        }\n\n        (uint256 usedYes, uint256 usedNo) = (key.id0 == yesId) ? (used0, used1) : (used1, used0);\n        emit Seeded(marketId, usedYes, usedNo, liq);\n    }\n\n    function closeMarket(uint256 marketId) public nonReentrant {\n        Market storage m = markets[marketId];\n        require(m.resolver != address(0), MarketNotFound());\n        require(msg.sender == m.resolver, OnlyResolver());\n        require(m.canClose, NotClosable());\n        require(!m.resolved, MarketResolved());\n        require(block.timestamp < m.close, MarketClosed());\n\n        m.close = uint72(block.timestamp);\n        emit Closed(marketId, block.timestamp, msg.sender);\n    }\n\n    /*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 path-fair pricing helpers (fee-aware) \u2500\u2500\u2500\u2500\u2500*/\n    function _price1e18(uint256 num, uint256 den) internal pure returns (uint256) {\n        return mulDiv(num, Q, den); // floor(num/den * 1e18)\n    }\n\n    // YES buy (NO -> YES)\n    function _fairChargeYesWithFee(uint256 rYes, uint256 rNo, uint256 yesOut, uint256 feeBps)\n        internal\n        pure\n        returns (uint256 charge)\n    {\n        uint256 p0 = _price1e18(rNo, rYes + rNo);\n\n        // midpoint (simulate half the output):\n        uint256 outHalf = yesOut / 2;\n        uint256 inHalf = _getAmountIn(outHalf, rNo, rYes, feeBps);\n        uint256 rYesMid = rYes - outHalf;\n        uint256 rNoMid = rNo + inHalf;\n        uint256 pMid = _price1e18(rNoMid, rYesMid + rNoMid);\n\n        // end (simulate full output):\n        uint256 inAll = _getAmountIn(yesOut, rNo, rYes, feeBps);\n        uint256 rYesEnd = rYes - yesOut;\n        uint256 rNoEnd = rNo + inAll;\n        uint256 p1 = _price1e18(rNoEnd, rYesEnd + rNoEnd);\n\n        // Simpson: \u0394q * (p0 + 4*pMid + p1) / 6:\n        uint256 sum = p0 + (pMid << 2) + p1;\n        charge = mulDivUp(yesOut, sum, 6 * Q);\n    }\n\n    // NO buy (YES -> NO)\n    function _fairChargeNoWithFee(uint256 rYes, uint256 rNo, uint256 noOut, uint256 feeBps)\n        internal\n        pure\n        returns (uint256 charge)\n    {\n        // p0 (EV of NO share = 1 - pYES = rYes/(rYes+rNo))\n        uint256 p0 = _price1e18(rYes, rYes + rNo);\n\n        // midpoint:\n        uint256 outHalf = noOut / 2;\n        uint256 inHalf = _getAmountIn(outHalf, rYes, rNo, feeBps);\n        uint256 rNoMid = rNo - outHalf;\n        uint256 rYesMid = rYes + inHalf;\n        uint256 pMid = _price1e18(rYesMid, rYesMid + rNoMid);\n\n        // end:\n        uint256 inAll = _getAmountIn(noOut, rYes, rNo, feeBps);\n        uint256 rNoEnd = rNo - noOut;\n        uint256 rYesEnd = rYes + inAll;\n        uint256 p1 = _price1e18(rYesEnd, rYesEnd + rNoEnd);\n\n        uint256 sum = p0 + (pMid << 2) + p1;\n        charge = mulDivUp(noOut, sum, 6 * Q);\n    }\n\n    // YES sell (YES -> NO)\n    function _fairRefundYesWithFee(uint256 rYes, uint256 rNo, uint256 yesIn, uint256 feeBps)\n        internal\n        pure\n        returns (uint256 refund)\n    {\n        // p0 = EV of YES share at start = rNo/(rYes+rNo)\n        uint256 p0 = mulDiv(rNo, 1e18, rYes + rNo);\n\n        // midpoint (simulate half the input along the SELL path):\n        uint256 inHalf = yesIn / 2;\n        uint256 outHalf = _getAmountOut(inHalf, rYes, rNo, feeBps);\n        uint256 rYesMid = rYes + inHalf;\n        uint256 rNoMid = rNo - outHalf;\n        uint256 pMid = mulDiv(rNoMid, 1e18, rYesMid + rNoMid);\n\n        // end:\n        uint256 outAll = _getAmountOut(yesIn, rYes, rNo, feeBps);\n        uint256 rYesEnd = rYes + yesIn;\n        uint256 rNoEnd = rNo - outAll;\n        uint256 p1 = mulDiv(rNoEnd, 1e18, rYesEnd + rNoEnd);\n\n        // Simpson:\n        uint256 sum = p0 + (pMid << 2) + p1;\n        refund = mulDiv(yesIn, sum, 6 * 1e18);\n    }\n\n    // NO sell (NO -> YES)\n    function _fairRefundNoWithFee(uint256 rYes, uint256 rNo, uint256 noIn, uint256 feeBps)\n        internal\n        pure\n        returns (uint256 refund)\n    {\n        // p0(NO) = 1 - pYES = rYes/(rYes+rNo)\n        uint256 p0 = mulDiv(rYes, 1e18, rYes + rNo);\n\n        uint256 inHalf = noIn / 2;\n        uint256 outHalf = _getAmountOut(inHalf, rNo, rYes, feeBps);\n        uint256 rNoMid = rNo + inHalf;\n        uint256 rYesMid = rYes - outHalf;\n        uint256 pMid = mulDiv(rYesMid, 1e18, rYesMid + rNoMid);\n\n        uint256 outAll = _getAmountOut(noIn, rNo, rYes, feeBps);\n        uint256 rNoEnd = rNo + noIn;\n        uint256 rYesEnd = rYes - outAll;\n        uint256 p1 = mulDiv(rYesEnd, 1e18, rYesEnd + rNoEnd);\n\n        uint256 sum = p0 + (pMid << 2) + p1;\n        refund = mulDiv(noIn, sum, 6 * 1e18);\n    }\n\n    function _pmMultBps(uint256 marketId, uint256 rYes, uint256 rNo)\n        internal\n        view\n        returns (uint256 bps)\n    {\n        PMTuning memory t = pmTuning[marketId];\n        if ((t.lateRampStart | t.lateRampMaxBps | t.extremeMaxBps) == 0) return 0;\n\n        // Time ramp (saturating start):\n        if (t.lateRampStart != 0) {\n            Market storage m = markets[marketId];\n            uint256 start = (t.lateRampStart >= m.close) ? 0 : (m.close - t.lateRampStart);\n            if (block.timestamp >= m.close) {\n                bps += t.lateRampMaxBps;\n            } else if (block.timestamp > start) {\n                uint256 elapsed = block.timestamp - start;\n                bps += (uint256(t.lateRampMaxBps) * elapsed) / t.lateRampStart;\n            }\n        }\n\n        if (t.extremeMaxBps != 0) {\n            uint256 den = rYes + rNo;\n            if (den != 0) {\n                uint256 p1e18 = mulDiv(rNo, 1e18, den);\n                uint256 dist = p1e18 > 5e17 ? (p1e18 - 5e17) : (5e17 - p1e18);\n                bps += mulDiv(uint256(t.extremeMaxBps), dist, 5e17);\n            }\n        }\n    }\n\n    /*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 primary buys (path-fair EV; pot grows) \u2500\u2500\u2500\u2500*/\n    function buyYesViaPool(\n        uint256 marketId,\n        uint256 yesOut,\n        bool inIsETH,\n        uint256 wstInMax,\n        uint256 oppInMax,\n        address to\n    ) public payable nonReentrant returns (uint256 wstIn, uint256 oppIn) {\n        Market storage m = markets[marketId];\n        require(m.resolver != address(0), MarketNotFound());\n        require(!m.resolved && block.timestamp < m.close, MarketClosed());\n        require(yesOut != 0, AmountZero());\n\n        if (inIsETH) {\n            if (msg.value == 0) revert NoEth();\n        } else {\n            if (msg.value != 0) revert EthNotAllowed();\n        }\n\n        uint256 yesId = marketId;\n        uint256 noId = getNoId(marketId);\n        IZAMM.PoolKey memory key = _poolKey(yesId, noId);\n\n        (uint256 rYes, uint256 rNo) = _poolReserves(key, yesId);\n        require(rYes > 0 && rNo > 0, PoolNotSeeded());\n        require(yesOut < rYes, InsufficientLiquidity());\n\n        bool zeroForOne = (key.id0 == noId); // NO -> YES if id0 is NO\n\n        // ----- Pool quote (fee-aware, order-invariant): pay NO (rNo) to get YES (rYes)\n        uint256 quotedIn = _getAmountIn(yesOut, /*reserveIn=*/ rNo, /*reserveOut=*/ rYes, FEE_BPS);\n\n        // Caller\u2019s bound applies to the *raw* quote, not our internal padding:\n        require(quotedIn <= oppInMax, SlippageOppIn());\n\n        // Compute a safe internal mint (covers rounding), but never exceed caller\u2019s cap:\n        uint256 paddedNeeded = mulDivUp(quotedIn, 10_000 + (FEE_BPS * 2 + 3), 10_000) + 5;\n        if (paddedNeeded < quotedIn + 3) paddedNeeded = quotedIn + 3;\n        uint256 mintIn = paddedNeeded > oppInMax ? oppInMax : paddedNeeded;\n\n        // ----- Path-fair EV charge into pot (fee-aware Simpson):\n        wstIn = _fairChargeYesWithFee(rYes, rNo, yesOut, FEE_BPS);\n        {\n            uint256 b = _pmMultBps(marketId, rYes, rNo);\n            if (b != 0) wstIn = mulDivUp(wstIn, 10_000 + b, 10_000);\n        }\n        require(wstIn != 0, InsufficientWst());\n\n        // Collect wstETH:\n        if (inIsETH) {\n            uint256 z = ZSTETH.exactETHToWSTETH{value: msg.value}(address(this));\n            require(z >= wstIn, InsufficientZap());\n            m.pot += wstIn;\n            if (z > wstIn) IERC20(WSTETH).transfer(msg.sender, z - wstIn);\n        } else {\n            require(wstInMax >= wstIn, InsufficientWst());\n            IERC20(WSTETH).transferFrom(msg.sender, address(this), wstIn);\n            m.pot += wstIn;\n        }\n\n        // Swap via transient balance:\n        _mint(address(this), noId, mintIn);\n        totalSupply[noId] += mintIn;\n        ZAMM.deposit(address(this), noId, mintIn);\n\n        // Let AMM consume up to mintIn; capture the actual input used:\n        uint256 actualIn = ZAMM.swapExactOut(key, yesOut, mintIn, zeroForOne, to, block.timestamp);\n\n        // Sweep any unused NO and burn it immediately (keeps supply exact):\n        uint256 ret = ZAMM.recoverTransientBalance(address(this), noId, address(this));\n        if (ret != 0) {\n            _burn(address(this), noId, ret);\n            totalSupply[noId] -= ret;\n        }\n\n        // Report actual input used (matches quote under identical state):\n        oppIn = actualIn;\n\n        emit Bought(to, yesId, yesOut, wstIn);\n    }\n\n    function buyNoViaPool(\n        uint256 marketId,\n        uint256 noOut,\n        bool inIsETH,\n        uint256 wstInMax,\n        uint256 oppInMax,\n        address to\n    ) public payable nonReentrant returns (uint256 wstIn, uint256 oppIn) {\n        Market storage m = markets[marketId];\n        require(m.resolver != address(0), MarketNotFound());\n        require(!m.resolved && block.timestamp < m.close, MarketClosed());\n        require(noOut != 0, AmountZero());\n\n        if (inIsETH) {\n            if (msg.value == 0) revert NoEth();\n        } else {\n            if (msg.value != 0) revert EthNotAllowed();\n        }\n\n        uint256 yesId = marketId;\n        uint256 noId = getNoId(marketId);\n        IZAMM.PoolKey memory key = _poolKey(yesId, noId);\n\n        (uint256 rYes, uint256 rNo) = _poolReserves(key, yesId);\n        require(rYes > 0 && rNo > 0, PoolNotSeeded());\n        require(noOut < rNo, InsufficientLiquidity());\n\n        bool zeroForOne = (key.id0 == yesId); // YES -> NO if id0 is YES\n\n        // ----- Pool quote (fee-aware, order-invariant): pay YES (rYes) to get NO (rNo):\n        uint256 quotedIn = _getAmountIn(noOut, /*reserveIn=*/ rYes, /*reserveOut=*/ rNo, FEE_BPS);\n\n        // Caller\u2019s bound applies to the *raw* quote, not our internal padding:\n        require(quotedIn <= oppInMax, SlippageOppIn());\n\n        // Compute a safe internal mint (covers rounding), but never exceed caller\u2019s cap:\n        uint256 paddedNeeded = mulDivUp(quotedIn, 10_000 + (FEE_BPS * 2 + 3), 10_000) + 5;\n        if (paddedNeeded < quotedIn + 3) paddedNeeded = quotedIn + 3;\n        uint256 mintIn = paddedNeeded > oppInMax ? oppInMax : paddedNeeded;\n\n        // ----- Path-fair EV charge into pot (fee-aware Simpson):\n        wstIn = _fairChargeNoWithFee(rYes, rNo, noOut, FEE_BPS);\n        {\n            uint256 b = _pmMultBps(marketId, rYes, rNo);\n            if (b != 0) wstIn = mulDivUp(wstIn, 10_000 + b, 10_000);\n        }\n        require(wstIn != 0, InsufficientWst());\n\n        // Collect wstETH:\n        if (inIsETH) {\n            uint256 z = ZSTETH.exactETHToWSTETH{value: msg.value}(address(this));\n            require(z >= wstIn, InsufficientZap());\n            m.pot += wstIn;\n            if (z > wstIn) IERC20(WSTETH).transfer(msg.sender, z - wstIn);\n        } else {\n            require(wstInMax >= wstIn, InsufficientWst());\n            IERC20(WSTETH).transferFrom(msg.sender, address(this), wstIn);\n            m.pot += wstIn;\n        }\n\n        _mint(address(this), yesId, mintIn);\n        totalSupply[yesId] += mintIn;\n        ZAMM.deposit(address(this), yesId, mintIn);\n\n        // Let AMM consume up to mintIn; capture the actual input used:\n        uint256 actualIn = ZAMM.swapExactOut(key, noOut, mintIn, zeroForOne, to, block.timestamp);\n\n        // Sweep any unused YES and burn it immediately (keeps supply exact):\n        uint256 ret = ZAMM.recoverTransientBalance(address(this), yesId, address(this));\n        if (ret != 0) {\n            _burn(address(this), yesId, ret);\n            totalSupply[yesId] -= ret;\n        }\n\n        // Report actual input used (matches quote under identical state):\n        oppIn = actualIn;\n\n        emit Bought(to, noId, noOut, wstIn);\n    }\n\n    function sellYesViaPool(\n        uint256 marketId,\n        uint256 yesIn,\n        uint256 wstOutMin,\n        uint256 oppOutMin,\n        address to\n    ) public nonReentrant returns (uint256 wstOut, uint256 oppOut) {\n        Market storage m = markets[marketId];\n        require(m.resolver != address(0), MarketNotFound());\n        require(!m.resolved && block.timestamp < m.close, MarketClosed());\n        require(yesIn != 0, AmountZero());\n\n        uint256 yesId = marketId;\n        uint256 noId = getNoId(marketId);\n        IZAMM.PoolKey memory key = _poolKey(yesId, noId);\n\n        (uint256 rYes, uint256 rNo) = _poolReserves(key, yesId);\n        require(rYes > 0 && rNo > 0, PoolNotSeeded());\n\n        bool zeroForOne = (key.id0 == yesId); // YES -> NO if id0 is YES\n\n        // 1) Deterministic pool out (exact-in):\n        oppOut = _getAmountOut(yesIn, rYes, rNo, FEE_BPS);\n        require(oppOut >= oppOutMin, InsufficientLiquidity());\n\n        // 2) Path-fair EV refund, floored to pot:\n        uint256 fair = _fairRefundYesWithFee(rYes, rNo, yesIn, FEE_BPS);\n        {\n            uint256 b = _pmMultBps(marketId, rYes, rNo);\n            if (b != 0) fair = mulDiv(fair, 10_000, 10_000 + b);\n        }\n\n        uint256 potBal = m.pot;\n        wstOut = fair > potBal ? potBal : fair;\n        require(wstOut >= wstOutMin, InsufficientWst());\n\n        // 3) Pay refund:\n        m.pot = potBal - wstOut;\n        IERC20(WSTETH).transfer(to, wstOut);\n\n        // 4) Debit user's YES and fix totalSupply immediately:\n        _burn(msg.sender, yesId, yesIn);\n        totalSupply[yesId] -= yesIn;\n\n        // 5) Transient-mint YES to PM, swap to NO out for PM, then sweep:\n        _mint(address(this), yesId, yesIn);\n        totalSupply[yesId] += yesIn;\n        ZAMM.deposit(address(this), yesId, yesIn);\n        ZAMM.swapExactOut(\n            key,\n            oppOut, // exact NO to PM\n            yesIn, // cap YES spent\n            zeroForOne, // YES -> NO\n            address(this),\n            block.timestamp\n        );\n        // Sweep any leftover YES (rounding/slack):\n        uint256 retYes = ZAMM.recoverTransientBalance(address(this), yesId, address(this));\n        if (retYes != 0) {\n            _burn(address(this), yesId, retYes);\n            totalSupply[yesId] -= retYes;\n        }\n\n        // 6) Burn the NO received from pool (reduce NO supply deterministically):\n        _burn(address(this), noId, oppOut);\n        totalSupply[noId] -= oppOut;\n\n        emit Sold(msg.sender, yesId, yesIn, wstOut);\n        return (wstOut, oppOut);\n    }\n\n    function sellNoViaPool(\n        uint256 marketId,\n        uint256 noIn,\n        uint256 wstOutMin,\n        uint256 oppOutMin,\n        address to\n    ) public nonReentrant returns (uint256 wstOut, uint256 oppOut) {\n        Market storage m = markets[marketId];\n        require(m.resolver != address(0), MarketNotFound());\n        require(!m.resolved && block.timestamp < m.close, MarketClosed());\n        require(noIn != 0, AmountZero());\n\n        uint256 yesId = marketId;\n        uint256 noId = getNoId(marketId);\n        IZAMM.PoolKey memory key = _poolKey(yesId, noId);\n\n        (uint256 rYes, uint256 rNo) = _poolReserves(key, yesId);\n        require(rYes > 0 && rNo > 0, PoolNotSeeded());\n\n        bool zeroForOne = (key.id0 == noId); // NO -> YES if id0 is NO\n\n        // 1) Deterministic pool out (exact-in):\n        oppOut = _getAmountOut(noIn, rNo, rYes, FEE_BPS);\n        require(oppOut >= oppOutMin, InsufficientLiquidity());\n\n        // 2) Path-fair EV refund, floored to pot:\n        uint256 fair = _fairRefundNoWithFee(rYes, rNo, noIn, FEE_BPS);\n        {\n            uint256 b = _pmMultBps(marketId, rYes, rNo);\n            if (b != 0) fair = mulDiv(fair, 10_000, 10_000 + b);\n        }\n\n        uint256 potBal = m.pot;\n        wstOut = fair > potBal ? potBal : fair;\n        require(wstOut >= wstOutMin, InsufficientWst());\n\n        // 3) Pay refund:\n        m.pot = potBal - wstOut;\n        IERC20(WSTETH).transfer(to, wstOut);\n\n        // 4) Debit user's NO and fix totalSupply immediately:\n        _burn(msg.sender, noId, noIn);\n        totalSupply[noId] -= noIn;\n\n        // 5) Transient-mint NO to PM, swap to YES out for PM, then sweep:\n        _mint(address(this), noId, noIn);\n        totalSupply[noId] += noIn;\n        ZAMM.deposit(address(this), noId, noIn);\n        ZAMM.swapExactOut(\n            key,\n            oppOut, // exact YES to PM\n            noIn, // cap NO spent\n            zeroForOne, // NO -> YES\n            address(this),\n            block.timestamp\n        );\n        uint256 retNo = ZAMM.recoverTransientBalance(address(this), noId, address(this));\n        if (retNo != 0) {\n            _burn(address(this), noId, retNo);\n            totalSupply[noId] -= retNo;\n        }\n\n        // 6) Burn the YES received from pool (reduce YES supply deterministically):\n        _burn(address(this), yesId, oppOut);\n        totalSupply[yesId] -= oppOut;\n\n        emit Sold(msg.sender, noId, noIn, wstOut);\n        return (wstOut, oppOut);\n    }\n\n    /*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 resolution / claims \u2500\u2500\u2500\u2500\u2500\u2500\u2500*/\n    function setResolverFeeBps(uint16 bps) public {\n        require(bps <= 1_000, FeeOverflow());\n        resolverFeeBps[msg.sender] = bps;\n        emit ResolverFeeSet(msg.sender, bps);\n    }\n\n    function resolve(uint256 marketId, bool outcome) public nonReentrant {\n        Market storage m = markets[marketId];\n        require(m.resolver != address(0), MarketNotFound());\n        require(msg.sender == m.resolver, OnlyResolver());\n        require(!m.resolved, AlreadyResolved());\n        require(block.timestamp >= m.close, MarketNotClosed());\n\n        // optional resolver fee:\n        uint16 feeBps = resolverFeeBps[m.resolver];\n        if (feeBps != 0) {\n            uint256 fee = (m.pot * feeBps) / 10_000;\n            if (fee != 0) {\n                m.pot -= fee;\n                IERC20(WSTETH).transfer(m.resolver, fee);\n            }\n        }\n\n        uint256 yesId = marketId;\n        uint256 noId = getNoId(marketId);\n        uint256 yesCirc = _circulating(yesId);\n        uint256 noCirc = _circulating(noId);\n\n        // \u2500\u2500 auto-flip semantics \u2500\u2500\n        if (outcome) {\n            // resolver chose YES\n            if (yesCirc == 0 && noCirc > 0) outcome = false; // flip to NO\n        } else {\n            // resolver chose NO\n            if (noCirc == 0 && yesCirc > 0) outcome = true; // flip to YES\n        }\n\n        // If both are zero, we still can't resolve (no winners exist):\n        uint256 winningCirc = outcome ? yesCirc : noCirc;\n        require(winningCirc != 0, NoCirculating());\n\n        m.payoutPerShare = mulDiv(m.pot, Q, winningCirc);\n        m.resolved = true;\n        m.outcome = outcome;\n\n        emit Resolved(marketId, outcome);\n    }\n\n    function claim(uint256 marketId, address to) public nonReentrant {\n        Market storage m = markets[marketId];\n        require(m.resolved, MarketNotResolved());\n\n        uint256 winId = m.outcome ? marketId : getNoId(marketId);\n        uint256 userShares = balanceOf[msg.sender][winId];\n        require(userShares != 0, NoWinningShares());\n\n        uint256 payout = mulDiv(userShares, m.payoutPerShare, Q);\n\n        _burn(msg.sender, winId, userShares);\n        totalSupply[winId] -= userShares;\n\n        m.pot -= payout;\n        IERC20(WSTETH).transfer(to, payout);\n\n        emit Claimed(to, winId, userShares, payout);\n    }\n\n    /*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 transfer / transferFrom \u2500\u2500\u2500\u2500\u2500\u2500\u2500*/\n    function transfer(address receiver, uint256 id, uint256 amount)\n        public\n        override(ERC6909Minimal)\n        returns (bool)\n    {\n        // Disallow arbitrary parking at PM or ZAMM:\n        if (receiver == address(this)) {\n            // Only ZAMM may send back residuals to PM, or PM may move internally:\n            if (msg.sender != address(this) && msg.sender != address(ZAMM)) {\n                revert InvalidReceiver();\n            }\n        } else if (receiver == address(ZAMM)) {\n            // Never allow users to push their own tokens into ZAMM.\n            // PM itself also shouldn't \"transfer\" into ZAMM via this path (it uses deposit + transient mints).\n            revert InvalidReceiver();\n        }\n\n        return ERC6909Minimal.transfer(receiver, id, amount);\n    }\n\n    function transferFrom(address sender, address receiver, uint256 id, uint256 amount)\n        public\n        returns (bool)\n    {\n        // Block arbitrary parking at PM or ZAMM, even when ZAMM is the caller:\n        if (receiver == address(this)) {\n            // Allow only ZAMM to sweep residuals back to PM or PM-internal ops:\n            if (msg.sender != address(this) && msg.sender != address(ZAMM)) {\n                revert InvalidReceiver();\n            }\n        } else if (receiver == address(ZAMM)) {\n            // Only allow PM-owned tokens to go into ZAMM (transient LP/swaps):\n            if (sender != address(this)) {\n                revert InvalidReceiver();\n            }\n        }\n\n        if (msg.sender != sender) {\n            // Fast path: allow ZAMM to pull PM-owned balances without SLOADs:\n            if (!(sender == address(this) && msg.sender == address(ZAMM))) {\n                if (!isOperator[sender][msg.sender]) {\n                    uint256 allowed = allowance[sender][msg.sender][id];\n                    if (allowed != type(uint256).max) {\n                        allowance[sender][msg.sender][id] = allowed - amount;\n                    }\n                }\n            }\n        }\n\n        balanceOf[sender][id] -= amount;\n        balanceOf[receiver][id] += amount;\n        emit Transfer(msg.sender, sender, receiver, id, amount);\n        return true;\n    }\n\n    /*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 views & quotes (UX) \u2500\u2500\u2500\u2500\u2500\u2500\u2500*/\n    function marketCount() public view returns (uint256) {\n        return allMarkets.length;\n    }\n\n    function tradingOpen(uint256 marketId) public view returns (bool) {\n        Market storage m = markets[marketId];\n        return m.resolver != address(0) && !m.resolved && block.timestamp < m.close;\n    }\n\n    /// Implied YES probability p \u2248 rNO / (rYES + rNO)\n    function impliedYesProb(uint256 marketId) public view returns (uint256 num, uint256 den) {\n        IZAMM.PoolKey memory key = _poolKey(marketId, getNoId(marketId));\n        (uint256 rYes, uint256 rNo) = _poolReserves(key, marketId);\n        return (rNo, rYes + rNo);\n    }\n\n    /// Quote helpers for frontends (fee-aware, path-fair)\n    // ---------- BUY QUOTES ----------\n    function quoteBuyYes(uint256 marketId, uint256 yesOut)\n        public\n        view\n        returns (\n            uint256 oppIn,\n            uint256 wstInFair,\n            uint256 p0_num,\n            uint256 p0_den,\n            uint256 p1_num,\n            uint256 p1_den\n        )\n    {\n        IZAMM.PoolKey memory key = _poolKey(marketId, getNoId(marketId));\n        (uint256 rYes, uint256 rNo) = _poolReserves(key, marketId);\n        require(yesOut < rYes && rYes > 0 && rNo > 0, InsufficientLiquidity());\n\n        // Order-invariant: pay NO (rNo) to get YES (rYes):\n        oppIn = _getAmountIn(yesOut, /*reserveIn=*/ rNo, /*reserveOut=*/ rYes, FEE_BPS);\n\n        // p0 and p1 for display:\n        p0_num = rNo;\n        p0_den = rYes + rNo;\n        uint256 rYesEnd = rYes - yesOut;\n        uint256 rNoEnd = rNo + oppIn;\n        p1_num = rNoEnd;\n        p1_den = rYesEnd + rNoEnd;\n\n        wstInFair = _fairChargeYesWithFee(rYes, rNo, yesOut, FEE_BPS);\n        {\n            uint256 b = _pmMultBps(marketId, rYes, rNo);\n            if (b != 0) wstInFair = mulDivUp(wstInFair, 10_000 + b, 10_000);\n        }\n    }\n\n    function quoteBuyNo(uint256 marketId, uint256 noOut)\n        public\n        view\n        returns (\n            uint256 oppIn,\n            uint256 wstInFair,\n            uint256 p0_num,\n            uint256 p0_den,\n            uint256 p1_num,\n            uint256 p1_den\n        )\n    {\n        IZAMM.PoolKey memory key = _poolKey(marketId, getNoId(marketId));\n        (uint256 rYes, uint256 rNo) = _poolReserves(key, marketId);\n        require(noOut < rNo && rYes > 0 && rNo > 0, InsufficientLiquidity());\n\n        oppIn = _getAmountIn(noOut, rYes, rNo, FEE_BPS);\n\n        p0_num = rYes;\n        p0_den = rYes + rNo;\n        uint256 rNoEnd = rNo - noOut;\n        uint256 rYesEnd = rYes + oppIn;\n        p1_num = rYesEnd;\n        p1_den = rYesEnd + rNoEnd;\n\n        wstInFair = _fairChargeNoWithFee(rYes, rNo, noOut, FEE_BPS);\n        {\n            uint256 b = _pmMultBps(marketId, rYes, rNo);\n            if (b != 0) wstInFair = mulDivUp(wstInFair, 10_000 + b, 10_000);\n        }\n    }\n\n    // ---------- SELL QUOTES ----------\n    function quoteSellYes(uint256 marketId, uint256 yesIn)\n        public\n        view\n        returns (\n            uint256 oppOut,\n            uint256 wstOutFair,\n            uint256 p0_num,\n            uint256 p0_den,\n            uint256 p1_num,\n            uint256 p1_den\n        )\n    {\n        IZAMM.PoolKey memory key = _poolKey(marketId, getNoId(marketId));\n        (uint256 rYes, uint256 rNo) = _poolReserves(key, marketId);\n        require(yesIn != 0 && rYes > 0 && rNo > 0, InsufficientLiquidity());\n\n        oppOut = _getAmountOut(yesIn, rYes, rNo, FEE_BPS);\n\n        p0_num = rNo; // pYES = rNo / (rYes + rNo)\n        p0_den = rYes + rNo;\n        uint256 rYesEnd = rYes + yesIn;\n        uint256 rNoEnd = rNo - oppOut;\n        p1_num = rNoEnd;\n        p1_den = rYesEnd + rNoEnd;\n\n        uint256 fair = _fairRefundYesWithFee(rYes, rNo, yesIn, FEE_BPS);\n        {\n            uint256 b = _pmMultBps(marketId, rYes, rNo);\n            if (b != 0) fair = mulDiv(fair, 10_000, 10_000 + b);\n        }\n        uint256 potBal = markets[marketId].pot;\n        wstOutFair = fair > potBal ? potBal : fair;\n    }\n\n    function quoteSellNo(uint256 marketId, uint256 noIn)\n        public\n        view\n        returns (\n            uint256 oppOut,\n            uint256 wstOutFair,\n            uint256 p0_num,\n            uint256 p0_den,\n            uint256 p1_num,\n            uint256 p1_den\n        )\n    {\n        uint256 yesId = marketId;\n        uint256 noId = getNoId(marketId);\n        IZAMM.PoolKey memory key = _poolKey(yesId, noId);\n        (uint256 rYes, uint256 rNo) = _poolReserves(key, yesId);\n        require(noIn != 0 && rYes > 0 && rNo > 0, InsufficientLiquidity());\n\n        oppOut = _getAmountOut(noIn, rNo, rYes, FEE_BPS);\n\n        p0_num = rYes; // pNO = rYes / (rYes + rNo)\n        p0_den = rYes + rNo;\n        uint256 rNoEnd = rNo + noIn;\n        uint256 rYesEnd = rYes - oppOut;\n        p1_num = rYesEnd;\n        p1_den = rYesEnd + rNoEnd;\n\n        uint256 fair = _fairRefundNoWithFee(rYes, rNo, noIn, FEE_BPS);\n        {\n            uint256 b = _pmMultBps(marketId, rYes, rNo);\n            if (b != 0) fair = mulDiv(fair, 10_000, 10_000 + b);\n        }\n        uint256 potBal = markets[marketId].pot;\n        wstOutFair = fair > potBal ? potBal : fair;\n    }\n\n    /*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 view getters (UI & indexing) \u2500\u2500\u2500*/\n    function getMarket(uint256 marketId)\n        public\n        view\n        returns (\n            uint256 yesSupply,\n            uint256 noSupply,\n            address resolver,\n            bool resolved,\n            bool outcome,\n            uint256 pot,\n            uint256 payoutPerShare,\n            string memory desc,\n            uint72 closeTs,\n            bool canClose,\n            // AMM extras:\n            uint256 rYes,\n            uint256 rNo,\n            uint256 pYes_num,\n            uint256 pYes_den\n        )\n    {\n        Market storage m = markets[marketId];\n        resolver = m.resolver;\n        resolved = m.resolved;\n        outcome = m.outcome;\n        pot = m.pot;\n        payoutPerShare = m.payoutPerShare;\n        desc = descriptions[marketId];\n        closeTs = m.close;\n        canClose = m.canClose;\n\n        yesSupply = totalSupply[marketId];\n        noSupply = totalSupply[getNoId(marketId)];\n\n        if (resolver != address(0)) {\n            IZAMM.PoolKey memory key = _poolKey(marketId, getNoId(marketId));\n            (rYes, rNo) = _poolReserves(key, marketId);\n            pYes_num = rNo;\n            pYes_den = rYes + rNo;\n        }\n    }\n\n    function getMarkets(uint256 start, uint256 count)\n        public\n        view\n        returns (\n            uint256[] memory marketIds,\n            uint256[] memory yesSupplies,\n            uint256[] memory noSupplies,\n            address[] memory resolvers,\n            bool[] memory resolved,\n            bool[] memory outcome,\n            uint256[] memory pot,\n            uint256[] memory payoutPerShare,\n            string[] memory descs,\n            uint72[] memory closes,\n            bool[] memory canCloses,\n            // AMM extras:\n            uint256[] memory rYesArr,\n            uint256[] memory rNoArr,\n            uint256[] memory pYesNumArr,\n            uint256[] memory pYesDenArr,\n            uint256 next\n        )\n    {\n        uint256 len = allMarkets.length;\n        if (start >= len) {\n            return (\n                new uint256[](0),\n                new uint256[](0),\n                new uint256[](0),\n                new address[](0),\n                new bool[](0),\n                new bool[](0),\n                new uint256[](0),\n                new uint256[](0),\n                new string[](0),\n                new uint72[](0),\n                new bool[](0),\n                new uint256[](0),\n                new uint256[](0),\n                new uint256[](0),\n                new uint256[](0),\n                0\n            );\n        }\n\n        uint256 end = start + count;\n        if (end > len) end = len;\n        uint256 n = end - start;\n\n        marketIds = new uint256[](n);\n        yesSupplies = new uint256[](n);\n        noSupplies = new uint256[](n);\n        resolvers = new address[](n);\n        resolved = new bool[](n);\n        outcome = new bool[](n);\n        pot = new uint256[](n);\n        payoutPerShare = new uint256[](n);\n        descs = new string[](n);\n        closes = new uint72[](n);\n        canCloses = new bool[](n);\n        rYesArr = new uint256[](n);\n        rNoArr = new uint256[](n);\n        pYesNumArr = new uint256[](n);\n        pYesDenArr = new uint256[](n);\n\n        uint256 id;\n        uint256 noId;\n\n        for (uint256 j; j != n; ++j) {\n            id = allMarkets[start + j];\n            Market storage m = markets[id];\n            marketIds[j] = id;\n            yesSupplies[j] = totalSupply[id];\n            noId = getNoId(id);\n            noSupplies[j] = totalSupply[noId];\n            resolvers[j] = m.resolver;\n            resolved[j] = m.resolved;\n            outcome[j] = m.outcome;\n            pot[j] = m.pot;\n            payoutPerShare[j] = m.payoutPerShare;\n            descs[j] = descriptions[id];\n            closes[j] = m.close;\n            canCloses[j] = m.canClose;\n\n            if (m.resolver != address(0)) {\n                IZAMM.PoolKey memory key = _poolKey(id, noId);\n                (rYesArr[j], rNoArr[j]) = _poolReserves(key, id);\n                pYesNumArr[j] = rNoArr[j];\n                pYesDenArr[j] = rYesArr[j] + rNoArr[j];\n            }\n        }\n\n        next = (end < len) ? end : 0;\n    }\n\n    function getUserMarkets(address user, uint256 start, uint256 count)\n        public\n        view\n        returns (\n            uint256[] memory yesIds,\n            uint256[] memory noIds,\n            uint256[] memory yesBalances,\n            uint256[] memory noBalances,\n            uint256[] memory claimables,\n            bool[] memory isResolved,\n            bool[] memory tradingOpen_,\n            uint256 next\n        )\n    {\n        uint256 len = allMarkets.length;\n        if (start >= len) {\n            return (\n                new uint256[](0),\n                new uint256[](0),\n                new uint256[](0),\n                new uint256[](0),\n                new uint256[](0),\n                new bool[](0),\n                new bool[](0),\n                0\n            );\n        }\n\n        uint256 end = start + count;\n        if (end > len) end = len;\n        uint256 n = end - start;\n\n        yesIds = new uint256[](n);\n        noIds = new uint256[](n);\n        yesBalances = new uint256[](n);\n        noBalances = new uint256[](n);\n        claimables = new uint256[](n);\n        isResolved = new bool[](n);\n        tradingOpen_ = new bool[](n);\n\n        uint256 yId;\n        uint256 nId;\n        uint256 yBal;\n        uint256 nBal;\n        bool res;\n\n        for (uint256 j; j != n; ++j) {\n            yId = allMarkets[start + j];\n            nId = getNoId(yId);\n            Market storage m = markets[yId];\n\n            yesIds[j] = yId;\n            noIds[j] = nId;\n\n            yBal = balanceOf[user][yId];\n            nBal = balanceOf[user][nId];\n            yesBalances[j] = yBal;\n            noBalances[j] = nBal;\n\n            res = m.resolved;\n            isResolved[j] = res;\n            tradingOpen_[j] = (m.resolver != address(0) && !res && block.timestamp < m.close);\n\n            if (res) {\n                uint256 pps = m.payoutPerShare; // Q-scaled\n                uint256 winBal = m.outcome ? yBal : nBal;\n                claimables[j] = (pps == 0) ? 0 : mulDiv(winBal, pps, Q);\n            }\n        }\n\n        next = (end < len) ? end : 0;\n    }\n\n    function winningId(uint256 marketId) public view returns (uint256 id) {\n        Market storage m = markets[marketId];\n        if (m.resolver == address(0)) return 0;\n        if (!m.resolved) return 0;\n        if (m.payoutPerShare == 0) return 0;\n        return m.outcome ? marketId : getNoId(marketId);\n    }\n\n    function getPool(uint256 marketId)\n        public\n        view\n        returns (\n            uint256 poolId,\n            uint256 rYes,\n            uint256 rNo,\n            uint32 tsLast,\n            uint256 kLast,\n            uint256 lpSupply\n        )\n    {\n        IZAMM.PoolKey memory key = _poolKey(marketId, getNoId(marketId));\n        poolId = _poolId(key);\n        (uint112 r0, uint112 r1, uint32 t,,, uint256 k, uint256 s) = ZAMM.pools(poolId);\n        if (key.id0 == marketId) {\n            rYes = r0;\n            rNo = r1;\n        } else {\n            rYes = r1;\n            rNo = r0;\n        }\n        tsLast = t;\n        kLast = k;\n        lpSupply = s;\n    }\n\n    /*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 internals \u2500\u2500\u2500*/\n    function _circulating(uint256 id) internal view returns (uint256 c) {\n        c = totalSupply[id];\n        unchecked {\n            c -= balanceOf[address(this)][id]; // exclude PM\n            c -= balanceOf[address(ZAMM)][id]; // exclude ZAMM\n        }\n    }\n\n    function _poolReserves(IZAMM.PoolKey memory key, uint256 yesId)\n        internal\n        view\n        returns (uint256 rYes, uint256 rNo)\n    {\n        (uint112 r0, uint112 r1,,,,,) = ZAMM.pools(_poolId(key));\n        if (key.id0 == yesId) {\n            rYes = uint256(r0);\n            rNo = uint256(r1);\n        } else {\n            rYes = uint256(r1);\n            rNo = uint256(r0);\n        }\n    }\n\n    function _getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut, uint256 feeBps)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        if (amountOut == 0) return 0;\n        uint256 numerator = reserveIn * amountOut * 10000;\n        uint256 denominator = (reserveOut - amountOut) * (10000 - feeBps);\n        amountIn = (numerator / denominator) + 1;\n    }\n\n    function _getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut, uint256 feeBps)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        uint256 amountInWithFee = amountIn * (10000 - feeBps);\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 10000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n\n    /*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 utils \u2500\u2500\u2500\u2500\u2500\u2500\u2500*/\n    function _toString(uint256 value) internal pure returns (string memory result) {\n        assembly (\"memory-safe\") {\n            result := add(mload(0x40), 0x80)\n            mstore(0x40, add(result, 0x20))\n            mstore(result, 0)\n            let end := result\n            let w := not(0)\n            for { let temp := value } 1 {} {\n                result := add(result, w)\n                mstore8(result, add(48, mod(temp, 10)))\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n            let n := sub(end, result)\n            result := sub(result, 0x20)\n            mstore(result, n)\n        }\n    }\n\n    /*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 reentrancy \u2500*/\n    error Reentrancy();\n\n    uint256 constant REENTRANCY_GUARD_SLOT = 0x929eee149b4bd21268;\n\n    modifier nonReentrant() {\n        assembly (\"memory-safe\") {\n            if tload(REENTRANCY_GUARD_SLOT) {\n                mstore(0x00, 0xab143c06)\n                revert(0x1c, 0x04)\n            }\n            tstore(REENTRANCY_GUARD_SLOT, address())\n        }\n        _;\n        assembly (\"memory-safe\") {\n            tstore(REENTRANCY_GUARD_SLOT, 0)\n        }\n    }\n}\n\nIERC20 constant WSTETH = IERC20(0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0);\n\ninterface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n\nIZSTETH constant ZSTETH = IZSTETH(0x000000000077B216105413Dc45Dc6F6256577c7B);\n\ninterface IZSTETH {\n    function exactETHToWSTETH(address to) external payable returns (uint256 wstOut);\n}\n\n/*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n| mulDiv helper (Solady)\n|\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500*/\nerror MulDivFailed();\n\nfunction mulDiv(uint256 x, uint256 y, uint256 d) pure returns (uint256 z) {\n    assembly (\"memory-safe\") {\n        z := mul(x, y)\n        if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n            mstore(0x00, 0xad251c27)\n            revert(0x1c, 0x04)\n        }\n        z := div(z, d)\n    }\n}\n\nfunction mulDivUp(uint256 x, uint256 y, uint256 d) pure returns (uint256 z) {\n    assembly (\"memory-safe\") {\n        z := mul(x, y)\n        if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n            mstore(0x00, 0xad251c27)\n            revert(0x1c, 0x04)\n        }\n        z := add(iszero(iszero(mod(z, d))), div(z, d))\n    }\n}\n"}}, "settings": {"remappings": ["@solady/=lib/solady/", "@soledge/=lib/soledge/", "@forge/=lib/forge-std/src/", "forge-std/=lib/forge-std/src/", "solady/=lib/solady/src/"], "optimizer": {"enabled": true}, "metadata": {"useLiteralContent": false, "bytecodeHash": "ipfs", "appendCBOR": true}, "outputSelection": {"*": {"*": ["evm.legacyAssembly"]}}, "evmVersion": "prague", "viaIR": false}}