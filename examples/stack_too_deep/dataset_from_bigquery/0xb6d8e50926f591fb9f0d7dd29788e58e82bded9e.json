{"language": "Solidity", "sources": {"@openzeppelin/contracts/token/ERC20/IERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"}, "@openzeppelin/contracts/utils/math/SafeCast.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"}, "contracts/base/Dispatcher.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Payments} from \"../modules/Payments.sol\";\nimport {V2SwapRouter} from \"../modules/v2/V2SwapRouter.sol\";\nimport {V3SwapRouter} from \"../modules/v3/V3SwapRouter.sol\";\nimport {ReferrerProxy} from \"../modules/referrer/ReferrerProxy.sol\";\nimport {ActionConstants} from \"../libraries/ActionConstants.sol\";\nimport {BytesLib} from \"../modules/v3/BytesLib.sol\";\nimport {CalldataDecoder} from \"../libraries/CalldataDecoder.sol\";\nimport {Commands} from \"../libraries/Commands.sol\";\nimport {Lock} from \"./Lock.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nabstract contract Dispatcher is\n    Payments,\n    V2SwapRouter,\n    V3SwapRouter,\n    ReferrerProxy,\n    Lock\n{\n    using BytesLib for bytes;\n    using CalldataDecoder for bytes;\n\n    error InvalidCommandType(uint256 commandType);\n    error BalanceTooLow();\n\n    /**\n     * @notice Execute a batch of commands\n     * @param commands The commands to execute\n     * @param inputs The inputs for the commands\n     */\n    function execute(\n        bytes calldata commands,\n        bytes[] calldata inputs\n    ) external payable virtual;\n\n    /**\n     * @notice Get the message sender\n     * @return The message sender\n     */\n    function msgSender() public view virtual returns (address) {\n        return _getLocker();\n    }\n\n    /**\n     * @notice Dispatch a command\n     * @param commandType The command type\n     * @param inputs The inputs for the command\n     * @return success Whether the command was executed successfully\n     * @return output The output of the command\n     */\n    function dispatch(\n        bytes1 commandType,\n        bytes calldata inputs\n    ) internal returns (bool success, bytes memory output) {\n        uint256 command = uint8(commandType & Commands.COMMAND_TYPE_MASK);\n\n        success = true;\n\n        // First branch: 0x00 <= command < 0x08\n        if (command < 0x08) {\n            if (command == Commands.V3_SWAP) {\n                // equivalent: abi.decode(inputs, (address, address, uint256, uint256, bytes, bool))\n                address factory;\n                address recipient;\n                uint256 amountIn;\n                uint256 amountOutMin;\n                bool payerIsUser;\n                assembly {\n                    factory := calldataload(inputs.offset)\n                    recipient := calldataload(add(inputs.offset, 0x20))\n                    amountIn := calldataload(add(inputs.offset, 0x40))\n                    amountOutMin := calldataload(add(inputs.offset, 0x60))\n                    // 0x80 offset is the path, 0xa0 offset is the payerIsUser\n                    payerIsUser := calldataload(add(inputs.offset, 0xa0))\n                }\n                bytes calldata path = inputs.toBytes(4);\n                address payer = payerIsUser ? msgSender() : address(this);\n                _v3Swap(\n                    factory,\n                    map(recipient),\n                    amountIn,\n                    amountOutMin,\n                    path,\n                    payer\n                );\n            } else if (command == Commands.SWEEP) {\n                // equivalent:  abi.decode(inputs, (address, address, uint256))\n                address token;\n                address recipient;\n                uint160 amountMin;\n                assembly {\n                    token := calldataload(inputs.offset)\n                    recipient := calldataload(add(inputs.offset, 0x20))\n                    amountMin := calldataload(add(inputs.offset, 0x40))\n                }\n                Payments.sweep(token, map(recipient), amountMin);\n            } else if (command == Commands.TRANSFER_FROM) {\n                // equivalent: abi.decode(inputs, (address, address, uint160))\n                address token;\n                address recipient;\n                uint160 amount;\n                assembly {\n                    token := calldataload(inputs.offset)\n                    recipient := calldataload(add(inputs.offset, 0x20))\n                    amount := calldataload(add(inputs.offset, 0x40))\n                }\n                transferFrom(token, msgSender(), map(recipient), amount);\n            } else if (command == Commands.TRANSFER) {\n                // equivalent:  abi.decode(inputs, (address, address, uint256))\n                address token;\n                address recipient;\n                uint256 value;\n                assembly {\n                    token := calldataload(inputs.offset)\n                    recipient := calldataload(add(inputs.offset, 0x20))\n                    value := calldataload(add(inputs.offset, 0x40))\n                }\n                Payments.pay(token, map(recipient), value);\n            } else {\n                revert InvalidCommandType(command);\n            }\n        }\n        // Second branch: 0x08 <= command < 0x10\n        else if (command < 0x10) {\n            if (command == Commands.V2_SWAP) {\n                // equivalent: abi.decode(inputs, (address, uint16, address, uint256, uint256, bytes, bool))\n                address factory;\n                uint16 swapFee;\n                address recipient;\n                uint256 amountIn;\n                uint256 amountOutMin;\n                bool payerIsUser;\n                assembly {\n                    factory := calldataload(inputs.offset)\n                    swapFee := calldataload(add(inputs.offset, 0x20))\n                    recipient := calldataload(add(inputs.offset, 0x40))\n                    amountIn := calldataload(add(inputs.offset, 0x60))\n                    amountOutMin := calldataload(add(inputs.offset, 0x80))\n                    // 0xa0 offset is the path, payerIsUser is at 0xa0+0x20 = 0xc0\n                    payerIsUser := calldataload(add(inputs.offset, 0xc0))\n                }\n                address[] calldata path = inputs.toAddressArray(5);\n                address payer = payerIsUser ? msgSender() : address(this);\n                _v2Swap(\n                    factory,\n                    swapFee,\n                    map(recipient),\n                    amountIn,\n                    amountOutMin,\n                    path,\n                    payer\n                );\n            } else if (command == Commands.WRAP_ETH) {\n                // equivalent: abi.decode(inputs, (address, uint256))\n                address recipient;\n                uint256 amount;\n                assembly {\n                    recipient := calldataload(inputs.offset)\n                    amount := calldataload(add(inputs.offset, 0x20))\n                }\n                Payments.wrapETH(map(recipient), amount);\n            } else if (command == Commands.UNWRAP_WETH) {\n                // equivalent: abi.decode(inputs, (address, uint256))\n                address recipient;\n                uint256 amountMin;\n                assembly {\n                    recipient := calldataload(inputs.offset)\n                    amountMin := calldataload(add(inputs.offset, 0x20))\n                }\n                Payments.unwrapWETH9(map(recipient), amountMin);\n            } else if (command == Commands.PAY_PORTION) {\n                // equivalent:  abi.decode(inputs, (address, address, uint256))\n                address token;\n                address recipient;\n                uint256 bips;\n                assembly {\n                    token := calldataload(inputs.offset)\n                    recipient := calldataload(add(inputs.offset, 0x20))\n                    bips := calldataload(add(inputs.offset, 0x40))\n                }\n                Payments.payPortion(token, map(recipient), bips);\n            } else {\n                revert InvalidCommandType(command);\n            }\n        }\n        // Third branch: 0x10 <= command < 0x20\n        else if (command < 0x20) {\n            if (command == Commands.BALANCE_CHECK_ERC20) {\n                // equivalent: abi.decode(inputs, (address, address, uint256))\n                address owner;\n                address token;\n                uint256 minBalance;\n                assembly {\n                    owner := calldataload(inputs.offset)\n                    token := calldataload(add(inputs.offset, 0x20))\n                    minBalance := calldataload(add(inputs.offset, 0x40))\n                }\n                success = (IERC20(token).balanceOf(owner) >= minBalance);\n                if (!success) output = abi.encodePacked(BalanceTooLow.selector);\n            } else if (command == Commands.SET_REFERRER) {\n                // equivalent: abi.decode(inputs, (uint256))\n                uint256 referrerTokenId;\n                assembly {\n                    referrerTokenId := calldataload(inputs.offset)\n                }\n                setReferrer(referrerTokenId, msgSender());\n            } else {\n                revert InvalidCommandType(command);\n            }\n        }\n        // Fourth branch: 0x21 <= command <= 0x3f (Advanced commands)\n        else if (command >= 0x21) {\n            if (command == Commands.EXECUTE_SUB_PLAN) {\n                (bytes calldata _commands, bytes[] calldata _inputs) = inputs\n                    .decodeCommandsAndInputs();\n                (success, output) = (address(this)).call(\n                    abi.encodeCall(Dispatcher.execute, (_commands, _inputs))\n                );\n            } else {\n                revert InvalidCommandType(command);\n            }\n        }\n    }\n\n    /// @notice Calculates the recipient address for a command\n    /// @param recipient The recipient or recipient-flag for the command\n    /// @return output The resultant recipient for the command\n    function map(address recipient) internal view returns (address) {\n        if (recipient == ActionConstants.MSG_SENDER) {\n            return msgSender();\n        } else if (recipient == ActionConstants.ADDRESS_THIS) {\n            return address(this);\n        } else {\n            return recipient;\n        }\n    }\n}\n"}, "contracts/base/Lock.sol": {"content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.30;\n\nimport {Locker} from \"../libraries/Locker.sol\";\n\n/// @title Lock\n/// @notice A contract that provides a reentrancy lock for external calls\ncontract Lock {\n    /// @notice Thrown when attempting to reenter a locked function from an external caller\n    error ContractLocked();\n\n    /// @notice Modifier enforcing a reentrancy lock that allows self-reentrancy\n    /// @dev If the contract is not locked, use msg.sender as the locker\n    modifier isNotLocked() {\n        // Apply a reentrancy lock for all external callers\n        if (msg.sender != address(this)) {\n            if (Locker.isLocked()) revert ContractLocked();\n            Locker.set(msg.sender);\n            _;\n            Locker.set(address(0));\n        } else {\n            // The contract is allowed to reenter itself, so the lock is not checked\n            _;\n        }\n    }\n\n    /// @notice return the current locker of the contract\n    function _getLocker() internal view returns (address) {\n        return Locker.get();\n    }\n}\n"}, "contracts/interfaces/IReferrerCaller.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IReferrerCaller {\n    error NotCaller();\n\n    function setReferrer(uint256 referrerTokenId, address user) external;\n}\n"}, "contracts/interfaces/ISmartRouter.sol": {"content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.30;\n\ninterface ISmartRouter {\n    /// @notice Thrown when a required command has failed\n    error ExecutionFailed(uint256 commandIndex, bytes message);\n\n    /// @notice Thrown when executing commands with an expired deadline\n    error TransactionDeadlinePassed();\n\n    /// @notice Thrown when attempting to execute commands and an incorrect number of inputs are provided\n    error LengthMismatch();\n\n    // @notice Thrown when an address that isn't WETH tries to send ETH to the router without calldata\n    error InvalidEthSender();\n\n    /// @notice Executes encoded commands along with provided inputs. Reverts if deadline has expired.\n    /// @param commands A set of concatenated commands, each 1 byte in length\n    /// @param inputs An array of byte strings containing abi encoded inputs for each command\n    /// @param deadline The deadline by which the transaction must be executed\n    function execute(\n        bytes calldata commands,\n        bytes[] calldata inputs,\n        uint256 deadline\n    ) external payable;\n}\n"}, "contracts/interfaces/IUniV2.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IUniV2Factory {\n    function getPair(\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair);\n\n    function createPair(\n        address tokenA,\n        address tokenB\n    ) external returns (address pair);\n}\n\ninterface IUniV2Pool {\n    function getReserves()\n        external\n        view\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(\n        address to\n    ) external returns (uint256 amount0, uint256 amount1);\n}\n"}, "contracts/interfaces/IUniV3.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IUniV3Quoter {\n    function quoteExactInput(\n        address factory,\n        bytes memory path,\n        uint256 amountIn\n    ) external view returns (uint256 amountOut, uint256 priceImpact);\n}\n\ninterface IUniV3Factory {\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address pool);\n}\n\ninterface IUniV3Pool {\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    function liquidity() external view returns (uint128);\n}\n"}, "contracts/interfaces/IUniV3Callback.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IUniV3Callback {\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes memory data\n    ) external;\n\n    function pancakeV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes memory data\n    ) external;\n}\n"}, "contracts/interfaces/IWETH9.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IWETH9 is IERC20 {\n    function deposit() external payable;\n\n    function withdraw(uint256) external;\n}\n"}, "contracts/libraries/ActionConstants.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title Action constants\n/// @notice Constants used in actions\n/// @dev Constants are a more gas-efficient alternative to literal values\nlibrary ActionConstants {\n    /// @notice Used to indicate that an operation should use the entire balance of a contract-held currency\n    /// This value is equivalent to 1<<255, i.e. a number with the highest significant bit set to 1\n    uint256 internal constant CONTRACT_BALANCE =\n        0x8000000000000000000000000000000000000000000000000000000000000000;\n\n    /// @notice Used to indicate that the recipient of an operation should be msgSender\n    address internal constant MSG_SENDER = address(1);\n\n    /// @notice Used to indicate that the recipient of an operation should be address(this)\n    address internal constant ADDRESS_THIS = address(2);\n}\n"}, "contracts/libraries/BipsLibrary.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title For calculating a percentage of an amount, using bips\nlibrary BipsLibrary {\n    uint256 internal constant BPS_DENOMINATOR = 10_000;\n\n    /// @notice emitted when an invalid percentage is provided\n    error InvalidBips();\n\n    /// @param amount The total amount to calculate a percentage of\n    /// @param bips The percentage to calculate, in bips\n    function calculatePortion(\n        uint256 amount,\n        uint256 bips\n    ) internal pure returns (uint256) {\n        if (bips > BPS_DENOMINATOR) revert InvalidBips();\n        return (amount * bips) / BPS_DENOMINATOR;\n    }\n}\n"}, "contracts/libraries/CalldataDecoder.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title Library for abi decoding in calldata\nlibrary CalldataDecoder {\n    using CalldataDecoder for bytes;\n\n    uint256 constant OFFSET_OR_LENGTH_MASK = 0xffffffff;\n    uint256 constant OFFSET_OR_LENGTH_MASK_AND_WORD_ALIGN = 0xffffffe0;\n\n    /// @notice equivalent to SliceOutOfBounds.selector, stored in least-significant bits\n    uint256 constant SLICE_ERROR_SELECTOR = 0x3b99b53d;\n\n    /// @dev equivalent to: abi.decode(params, (bytes, bytes[])) in calldata (requires strict abi encoding)\n    function decodeActionsRouterParams(\n        bytes calldata _bytes\n    ) internal pure returns (bytes calldata actions, bytes[] calldata params) {\n        assembly (\"memory-safe\") {\n            // Strict encoding requires that the data begin with:\n            // 0x00: 0x40 (offset to `actions.length`)\n            // 0x20: 0x60 + actions.length (offset to `params.length`)\n            // 0x40: `actions.length`\n            // 0x60: beginning of actions\n\n            // Verify actions offset matches strict encoding\n            let invalidData := xor(calldataload(_bytes.offset), 0x40)\n            actions.offset := add(_bytes.offset, 0x60)\n            actions.length := and(\n                calldataload(add(_bytes.offset, 0x40)),\n                OFFSET_OR_LENGTH_MASK\n            )\n\n            // Round actions length up to be word-aligned, and add 0x60 (for the first 3 words of encoding)\n            let paramsLengthOffset := add(\n                and(\n                    add(actions.length, 0x1f),\n                    OFFSET_OR_LENGTH_MASK_AND_WORD_ALIGN\n                ),\n                0x60\n            )\n            // Verify params offset matches strict encoding\n            invalidData := or(\n                invalidData,\n                xor(calldataload(add(_bytes.offset, 0x20)), paramsLengthOffset)\n            )\n            let paramsLengthPointer := add(_bytes.offset, paramsLengthOffset)\n            params.length := and(\n                calldataload(paramsLengthPointer),\n                OFFSET_OR_LENGTH_MASK\n            )\n            params.offset := add(paramsLengthPointer, 0x20)\n\n            // Expected offset for `params[0]` is params.length * 32\n            // As the first `params.length` slots are pointers to each of the array element lengths\n            let tailOffset := shl(5, params.length)\n            let expectedOffset := tailOffset\n\n            for {\n                let offset := 0\n            } lt(offset, tailOffset) {\n                offset := add(offset, 32)\n            } {\n                let itemLengthOffset := calldataload(add(params.offset, offset))\n                // Verify that the offset matches the expected offset from strict encoding\n                invalidData := or(\n                    invalidData,\n                    xor(itemLengthOffset, expectedOffset)\n                )\n                let itemLengthPointer := add(params.offset, itemLengthOffset)\n                let length := add(\n                    and(\n                        add(calldataload(itemLengthPointer), 0x1f),\n                        OFFSET_OR_LENGTH_MASK_AND_WORD_ALIGN\n                    ),\n                    0x20\n                )\n                expectedOffset := add(expectedOffset, length)\n            }\n\n            // if the data encoding was invalid, or the provided bytes string isnt as long as the encoding says, revert\n            if or(\n                invalidData,\n                lt(\n                    add(_bytes.length, _bytes.offset),\n                    add(params.offset, expectedOffset)\n                )\n            ) {\n                mstore(0, SLICE_ERROR_SELECTOR)\n                revert(0x1c, 4)\n            }\n        }\n    }\n\n    /// @notice Decode the `_arg`-th element in `_bytes` as `bytes`\n    /// @param _bytes The input bytes string to extract a bytes string from\n    /// @param _arg The index of the argument to extract\n    function toBytes(\n        bytes calldata _bytes,\n        uint256 _arg\n    ) internal pure returns (bytes calldata res) {\n        uint256 length;\n        assembly (\"memory-safe\") {\n            // The offset of the `_arg`-th element is `32 * arg`, which stores the offset of the length pointer.\n            // shl(5, x) is equivalent to mul(32, x)\n            let lengthPtr := add(\n                _bytes.offset,\n                and(\n                    calldataload(add(_bytes.offset, shl(5, _arg))),\n                    OFFSET_OR_LENGTH_MASK\n                )\n            )\n            // the number of bytes in the bytes string\n            length := and(calldataload(lengthPtr), OFFSET_OR_LENGTH_MASK)\n            // the offset where the bytes string begins\n            let offset := add(lengthPtr, 0x20)\n            // assign the return parameters\n            res.length := length\n            res.offset := offset\n\n            // if the provided bytes string isnt as long as the encoding says, revert\n            if lt(add(_bytes.length, _bytes.offset), add(length, offset)) {\n                mstore(0, SLICE_ERROR_SELECTOR)\n                revert(0x1c, 4)\n            }\n        }\n    }\n}\n"}, "contracts/libraries/Commands.sol": {"content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.30;\n\n/// @title Commands\n/// @notice Command Flags used to decode commands\nlibrary Commands {\n    // Masks to extract certain bits of commands\n    bytes1 internal constant FLAG_ALLOW_REVERT = 0x80;\n    bytes1 internal constant COMMAND_TYPE_MASK = 0x3f;\n\n    // Command Types. Maximum supported command at this moment is 0x3f.\n    // The commands are executed in nested if blocks to minimise gas consumption\n    // Commands are ordered by usage frequency and gas consumption optimization\n\n    // First branch: 0x00 <= command < 0x08\n    uint256 constant V3_SWAP = 0x00; // V3 swap\n    uint256 constant SWEEP = 0x01; // Sweep\n    uint256 constant TRANSFER_FROM = 0x02; // Transfer from user balance to contract\n    uint256 constant TRANSFER = 0x03; // Transfer\n    // COMMAND_PLACEHOLDER = 0x04 -> 0x07;\n\n    // Second branch: 0x08 <= command < 0x10\n    uint256 constant V2_SWAP = 0x08; // V2 swap\n    uint256 constant WRAP_ETH = 0x09; // Wrap ETH\n    uint256 constant UNWRAP_WETH = 0x0a; // Unwrap WETH\n    uint256 constant PAY_PORTION = 0x0b; // Pay portion\n    // COMMAND_PLACEHOLDER = 0x0c -> 0x0f;\n\n    // Third branch: 0x10 <= command < 0x20\n    uint256 constant BALANCE_CHECK_ERC20 = 0x10; // Balance check ERC20\n    uint256 constant SET_REFERRER = 0x11; // Set referrer\n    // COMMAND_PLACEHOLDER = 0x12 -> 0x20\n\n    // Fourth branch: 0x21 <= command <= 0x3f (Advanced commands)\n    uint256 constant EXECUTE_SUB_PLAN = 0x21; // Execute sub plan\n    // COMMAND_PLACEHOLDER for 0x22 to 0x3f\n}\n"}, "contracts/libraries/Constants.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\nlibrary Constants {\n    uint256 internal constant ADDR_SIZE = 20;\n\n    uint256 internal constant V3_FEE_SIZE = 3;\n\n    uint256 internal constant NEXT_V3_POOL_OFFSET = ADDR_SIZE + V3_FEE_SIZE;\n\n    uint256 internal constant V3_POP_OFFSET = NEXT_V3_POOL_OFFSET + ADDR_SIZE;\n\n    uint256 internal constant MULTIPLE_V3_POOLS_MIN_LENGTH =\n        V3_POP_OFFSET + NEXT_V3_POOL_OFFSET;\n\n    /// @dev Used to identify the token address for ETH\n    address internal constant ETH = address(0);\n\n    /// @dev Used to identify that the v2 pool has already received the input token\n    uint256 internal constant ALREADY_PAID = 0;\n}\n"}, "contracts/libraries/Errors.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nerror SlippageIsTooLow(uint256 amountOut);\nerror InvalidPool();\nerror InvalidAmount();\n\nerror InsufficientAmount();\nerror InsufficientLiquidity();\n\nerror TransferFailed();\nerror TransferFromFailed();\nerror ETHTransferFailed();\n"}, "contracts/libraries/Locker.sol": {"content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.30;\n\n/// @notice A library to implement a reentrancy lock in transient storage.\n/// @dev Instead of storing a boolean, the locker's address is stored to allow the contract to know who locked the contract\n/// TODO: This library can be deleted when we have the transient keyword support in solidity.\nlibrary Locker {\n    // The slot holding the locker state, transiently. bytes32(uint256(keccak256(\"Locker\")) - 1)\n    bytes32 constant LOCKER_SLOT =\n        0x0e87e1788ebd9ed6a7e63c70a374cd3283e41cad601d21fbe27863899ed4a708;\n\n    function set(address locker) internal {\n        // The locker is always msg.sender or address(0) so does not need to be cleaned\n        assembly (\"memory-safe\") {\n            tstore(LOCKER_SLOT, locker)\n        }\n    }\n\n    function get() internal view returns (address locker) {\n        assembly (\"memory-safe\") {\n            locker := tload(LOCKER_SLOT)\n        }\n    }\n\n    function isLocked() internal view returns (bool) {\n        return Locker.get() != address(0);\n    }\n}\n"}, "contracts/libraries/SafeTransferLib.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {ETHTransferFailed, TransferFromFailed, TransferFailed} from \"./Errors.sol\";\n\nlibrary SafeTransferLib {\n    /*----------------------------------------------------------\n                        ETH FUNCTIONS\n    ------------------------------------------------------------*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n        if (!success) revert ETHTransferFailed();\n    }\n\n    /*----------------------------------------------------------\n                        ERC20 FUNCTIONS\n    ------------------------------------------------------------*/\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(\n                freeMemoryPointer,\n                0x23b872dd00000000000000000000000000000000000000000000000000000000\n            )\n            mstore(\n                add(freeMemoryPointer, 4),\n                and(from, 0xffffffffffffffffffffffffffffffffffffffff)\n            ) // Append and mask the \"from\" argument.\n            mstore(\n                add(freeMemoryPointer, 36),\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\n            ) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n            // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n            success := call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n\n            // Set success to whether the call reverted, if not we check it either\n            // returned exactly 1 (can't just be non-zero data), or had no return data and token has code.\n            if and(\n                iszero(and(eq(mload(0), 1), gt(returndatasize(), 31))),\n                success\n            ) {\n                success := iszero(\n                    or(iszero(extcodesize(token)), returndatasize())\n                )\n            }\n        }\n\n        if (!success) revert TransferFromFailed();\n    }\n\n    function safeTransfer(address token, address to, uint256 amount) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(\n                freeMemoryPointer,\n                0xa9059cbb00000000000000000000000000000000000000000000000000000000\n            )\n            mstore(\n                add(freeMemoryPointer, 4),\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\n            ) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n            // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n            success := call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n\n            // Set success to whether the call reverted, if not we check it either\n            // returned exactly 1 (can't just be non-zero data), or had no return data and token has code.\n            if and(\n                iszero(and(eq(mload(0), 1), gt(returndatasize(), 31))),\n                success\n            ) {\n                success := iszero(\n                    or(iszero(extcodesize(token)), returndatasize())\n                )\n            }\n        }\n\n        if (!success) revert TransferFailed();\n    }\n}\n"}, "contracts/modules/Payments.sol": {"content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.30;\n\nimport {Constants} from \"../libraries/Constants.sol\";\nimport {PaymentsImmutables} from \"./PaymentsImmutables.sol\";\nimport {SafeTransferLib} from \"../libraries/SafeTransferLib.sol\";\nimport {BipsLibrary} from \"../libraries/BipsLibrary.sol\";\nimport {ActionConstants} from \"../libraries/ActionConstants.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Payments contract\n/// @notice Performs various operations around the payment of ETH and tokens\nabstract contract Payments is PaymentsImmutables {\n    using SafeTransferLib for address;\n    using BipsLibrary for uint256;\n\n    error InsufficientToken();\n    error InsufficientETH();\n\n    /// @notice Performs a transferFrom on a token\n    /// @param token The token to transfer\n    /// @param from The address to transfer from\n    /// @param to The recipient of the transfer\n    /// @param amount The amount to transfer\n    function transferFrom(\n        address token,\n        address from,\n        address to,\n        uint160 amount\n    ) internal {\n        token.safeTransferFrom(from, to, amount);\n    }\n\n    /// @notice Pays an amount of ETH or ERC20 to a recipient\n    /// @param token The token to pay (can be ETH using Constants.ETH)\n    /// @param payer The address that will pay the amount\n    /// @param recipient The address that will receive the payment\n    /// @param amount The amount to pay\n    function payOrTransferFrom(\n        address token,\n        address payer,\n        address recipient,\n        uint256 amount\n    ) internal {\n        if (payer == address(this)) {\n            pay(token, recipient, amount);\n        } else {\n            token.safeTransferFrom(payer, recipient, amount);\n        }\n    }\n\n    /// @notice Pays an amount of ETH or ERC20 to a recipient\n    /// @param token The token to pay (can be ETH using Constants.ETH)\n    /// @param recipient The address that will receive the payment\n    /// @param value The amount to pay\n    function pay(address token, address recipient, uint256 value) internal {\n        if (token == Constants.ETH) {\n            recipient.safeTransferETH(value);\n        } else {\n            if (value == ActionConstants.CONTRACT_BALANCE) {\n                value = IERC20(token).balanceOf(address(this));\n            }\n            token.safeTransfer(recipient, value);\n        }\n    }\n\n    /// @notice Pays a proportion of the contract's ETH or ERC20 to a recipient\n    /// @param token The token to pay (can be ETH using Constants.ETH)\n    /// @param recipient The address that will receive payment\n    /// @param bips Portion in bips of whole balance of the contract\n    function payPortion(\n        address token,\n        address recipient,\n        uint256 bips\n    ) internal {\n        if (token == Constants.ETH) {\n            uint256 balance = address(this).balance;\n            uint256 amount = balance.calculatePortion(bips);\n            recipient.safeTransferETH(amount);\n        } else {\n            uint256 balance = IERC20(token).balanceOf(address(this));\n            uint256 amount = balance.calculatePortion(bips);\n            token.safeTransfer(recipient, amount);\n        }\n    }\n\n    /// @notice Sweeps all of the contract's ERC20 or ETH to an address\n    /// @param token The token to sweep (can be ETH using Constants.ETH)\n    /// @param recipient The address that will receive payment\n    /// @param amountMinimum The minimum desired amount\n    function sweep(\n        address token,\n        address recipient,\n        uint256 amountMinimum\n    ) internal {\n        uint256 balance;\n        if (token == Constants.ETH) {\n            balance = address(this).balance;\n            if (balance < amountMinimum) revert InsufficientETH();\n            if (balance > 0) recipient.safeTransferETH(balance);\n        } else {\n            balance = IERC20(token).balanceOf(address(this));\n            if (balance < amountMinimum) revert InsufficientToken();\n            if (balance > 0) token.safeTransfer(recipient, balance);\n        }\n    }\n\n    /// @notice Wraps an amount of ETH into WETH\n    /// @param recipient The recipient of the WETH\n    /// @param amount The amount to wrap (can be CONTRACT_BALANCE)\n    function wrapETH(address recipient, uint256 amount) internal {\n        if (amount == ActionConstants.CONTRACT_BALANCE) {\n            amount = address(this).balance;\n        } else if (amount > address(this).balance) {\n            revert InsufficientETH();\n        }\n        if (amount > 0) {\n            WETH9.deposit{value: amount}();\n            if (recipient != address(this)) {\n                WETH9.transfer(recipient, amount);\n            }\n        }\n    }\n\n    /// @notice Unwraps all of the contract's WETH into ETH\n    /// @param recipient The recipient of the ETH\n    /// @param amountMinimum The minimum amount of ETH desired\n    function unwrapWETH9(address recipient, uint256 amountMinimum) internal {\n        uint256 value = WETH9.balanceOf(address(this));\n        if (value < amountMinimum) {\n            revert InsufficientETH();\n        }\n        if (value > 0) {\n            WETH9.withdraw(value);\n            if (recipient != address(this)) {\n                recipient.safeTransferETH(value);\n            }\n        }\n    }\n}\n"}, "contracts/modules/PaymentsImmutables.sol": {"content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.30;\n\nimport {IWETH9} from \"../interfaces/IWETH9.sol\";\n\ncontract PaymentsImmutables {\n    IWETH9 internal immutable WETH9;\n\n    constructor(IWETH9 weth9) {\n        WETH9 = weth9;\n    }\n}\n"}, "contracts/modules/referrer/ReferrerProxy.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IReferrerCaller} from \"../../interfaces/IReferrerCaller.sol\";\n\nabstract contract ReferrerProxy {\n    address internal immutable REFERRER;\n\n    constructor(address _referrer) {\n        REFERRER = _referrer;\n    }\n\n    function setReferrer(uint256 referrerTokenId, address user) internal {\n        IReferrerCaller(REFERRER).setReferrer(referrerTokenId, user);\n    }\n}\n"}, "contracts/modules/v2/UniV2Library.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {SafeTransferLib} from \"../../libraries/SafeTransferLib.sol\";\nimport {IUniV2Factory, IUniV2Pool} from \"../../interfaces/IUniV2.sol\";\nimport {InsufficientLiquidity, InsufficientAmount} from \"../../libraries/Errors.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nlibrary UniV2Library {\n    using SafeTransferLib for address;\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        if (amountA == 0) revert InsufficientAmount();\n        if (reserveA == 0 || reserveB == 0) revert InsufficientLiquidity();\n        amountB = (amountA * reserveB) / reserveA;\n    }\n\n    function sortToken0(\n        address tokenA,\n        address tokenB\n    ) internal pure returns (address token0) {\n        token0 = tokenA < tokenB ? tokenA : tokenB;\n    }\n\n    function pairAndToken0For(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal view returns (address pair, address token0) {\n        token0 = sortToken0(tokenA, tokenB);\n        pair = IUniV2Factory(factory).getPair(tokenA, tokenB);\n    }\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut,\n        uint16 swapFee\n    ) internal pure returns (uint256 amountOut) {\n        unchecked {\n            uint256 amountInWithFee = amountIn * swapFee;\n            uint256 numerator = amountInWithFee * reserveOut;\n            uint256 denominator = reserveIn * 10_000 + amountInWithFee;\n            amountOut = numerator / denominator;\n        }\n    }\n\n    function getAmountOutWithPool(\n        address pool,\n        uint16 swapFee,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) internal view returns (uint256) {\n        address token0 = sortToken0(tokenIn, tokenOut);\n        (uint112 reserve0, uint112 reserve1, ) = IUniV2Pool(pool).getReserves();\n        (uint256 reserveIn, uint256 reserveOut) = tokenIn == token0\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n        return getAmountOut(amountIn, reserveIn, reserveOut, swapFee);\n    }\n\n    function addLiquidity(\n        address factory,\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin\n    ) internal returns (address pair, uint256 amountA, uint256 amountB) {\n        pair = IUniV2Factory(factory).getPair(tokenA, tokenB);\n        if (pair == address(0)) {\n            pair = IUniV2Factory(factory).createPair(tokenA, tokenB);\n        }\n\n        (uint256 reserve0, uint256 reserve1, ) = IUniV2Pool(pair).getReserves();\n        (uint256 reserveA, uint256 reserveB) = tokenA < tokenB\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint256 amountBOptimal = quote(amountADesired, reserveA, reserveB);\n            if (amountBOptimal <= amountBDesired) {\n                if (amountBOptimal < amountBMin) revert InsufficientAmount();\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint256 amountAOptimal = quote(\n                    amountBDesired,\n                    reserveB,\n                    reserveA\n                );\n                assert(amountAOptimal <= amountADesired);\n                if (amountAOptimal < amountAMin) revert InsufficientAmount();\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n\n    function removeLiquidity(\n        address factory,\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        address to\n    ) internal returns (uint256 amountA, uint256 amountB) {\n        address pair = IUniV2Factory(factory).getPair(tokenA, tokenB);\n        pair.safeTransferFrom(msg.sender, pair, liquidity);\n        (uint256 amount0, uint256 amount1) = IUniV2Pool(pair).burn(to);\n        (amountA, amountB) = tokenA < tokenB\n            ? (amount0, amount1)\n            : (amount1, amount0);\n    }\n\n    function swap(\n        address factory,\n        uint16 swapFee,\n        address[] calldata path,\n        address recipient,\n        address pair\n    ) internal {\n        unchecked {\n            address token0 = sortToken0(path[0], path[1]);\n            uint256 finalPairIndex = path.length - 1;\n            uint256 penultimatePairIndex = finalPairIndex - 1;\n            for (uint256 i; i < finalPairIndex; i++) {\n                (address input, address output) = (path[i], path[i + 1]);\n                (uint256 reserve0, uint256 reserve1, ) = IUniV2Pool(pair)\n                    .getReserves();\n                (uint256 reserveIn, uint256 reserveOut) = input == token0\n                    ? (reserve0, reserve1)\n                    : (reserve1, reserve0);\n                uint256 amountIn = IERC20(input).balanceOf(pair) - reserveIn;\n                uint256 amountOut = getAmountOut(\n                    amountIn,\n                    reserveIn,\n                    reserveOut,\n                    swapFee\n                );\n                (uint256 amount0Out, uint256 amount1Out) = input == token0\n                    ? (uint256(0), amountOut)\n                    : (amountOut, uint256(0));\n                address nextPair;\n                (nextPair, token0) = i < penultimatePairIndex\n                    ? pairAndToken0For(factory, output, path[i + 2])\n                    : (recipient, address(0));\n                IUniV2Pool(pair).swap(\n                    amount0Out,\n                    amount1Out,\n                    nextPair,\n                    new bytes(0)\n                );\n                pair = nextPair;\n            }\n        }\n    }\n}\n"}, "contracts/modules/v2/V2SwapRouter.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IUniV2Factory, IUniV2Pool} from \"../../interfaces/IUniV2.sol\";\nimport {SafeTransferLib} from \"../../libraries/SafeTransferLib.sol\";\nimport {UniV2Library} from \"./UniV2Library.sol\";\nimport {InsufficientAmount, SlippageIsTooLow} from \"../../libraries/Errors.sol\";\nimport {Constants} from \"../../libraries/Constants.sol\";\nimport {Payments} from \"../Payments.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nabstract contract V2SwapRouter is Payments {\n    using SafeTransferLib for address;\n\n    function _v2Swap(\n        address factory,\n        uint16 swapFee,\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        address[] calldata path,\n        address payer\n    ) internal {\n        address firstPair = IUniV2Factory(factory).getPair(path[0], path[1]);\n        if (\n            amountIn != Constants.ALREADY_PAID // amountIn of 0 to signal that the pair already has the tokens\n        ) {\n            payOrTransferFrom(path[0], payer, firstPair, amountIn);\n        }\n\n        IERC20 tokenOut = IERC20(path[path.length - 1]);\n        uint256 balanceBefore = tokenOut.balanceOf(recipient);\n\n        UniV2Library.swap(factory, swapFee, path, recipient, firstPair);\n\n        uint256 amountOut = tokenOut.balanceOf(recipient) - balanceBefore;\n        if (amountOut < amountOutMinimum) revert SlippageIsTooLow(amountOut);\n    }\n\n    function addV2Liquidity(\n        address factory,\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin\n    ) external {\n        (address pair, uint256 amountA, uint256 amountB) = UniV2Library\n            .addLiquidity(\n                factory,\n                tokenA,\n                tokenB,\n                amountADesired,\n                amountBDesired,\n                amountAMin,\n                amountBMin\n            );\n        tokenA.safeTransferFrom(msg.sender, pair, amountA);\n        tokenB.safeTransferFrom(msg.sender, pair, amountB);\n        IUniV2Pool(pair).mint(msg.sender);\n    }\n\n    function addV2LiquidityETH(\n        address factory,\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin\n    ) external payable {\n        (address pair, uint256 amountToken, uint256 amountETH) = UniV2Library\n            .addLiquidity(\n                factory,\n                token,\n                address(WETH9),\n                amountTokenDesired,\n                msg.value,\n                amountTokenMin,\n                amountETHMin\n            );\n        token.safeTransferFrom(msg.sender, pair, amountToken);\n        WETH9.deposit{value: amountETH}();\n        WETH9.transfer(pair, amountETH);\n        IUniV2Pool(pair).mint(msg.sender);\n        unchecked {\n            if (msg.value > amountETH)\n                msg.sender.safeTransferETH(msg.value - amountETH);\n        }\n    }\n\n    function removeV2Liquidity(\n        address factory,\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin\n    ) external {\n        (uint256 amountA, uint256 amountB) = UniV2Library.removeLiquidity(\n            factory,\n            tokenA,\n            tokenB,\n            liquidity,\n            msg.sender\n        );\n        if (amountA < amountAMin) revert InsufficientAmount();\n        if (amountB < amountBMin) revert InsufficientAmount();\n    }\n\n    function removeV2LiquidityETH(\n        address factory,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin\n    ) external {\n        UniV2Library.removeLiquidity(\n            factory,\n            token,\n            address(WETH9),\n            liquidity,\n            address(this)\n        );\n        uint256 amountToken = IERC20(token).balanceOf(address(this));\n        uint256 amountETH = WETH9.balanceOf(address(this));\n        if (amountToken < amountTokenMin) revert InsufficientAmount();\n        if (amountETH < amountETHMin) revert InsufficientAmount();\n        token.safeTransfer(msg.sender, amountToken);\n        WETH9.withdraw(amountETH);\n        msg.sender.safeTransferETH(amountETH);\n    }\n}\n"}, "contracts/modules/v3/BytesLib.sol": {"content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/// @title Library for Bytes Manipulation\npragma solidity ^0.8.30;\n\nimport {Constants} from \"../../libraries/Constants.sol\";\nimport {CalldataDecoder} from \"../../libraries/CalldataDecoder.sol\";\n\nlibrary BytesLib {\n    using CalldataDecoder for bytes;\n\n    error SliceOutOfBounds();\n\n    /// @notice Returns the address starting at byte 0\n    /// @dev length and overflow checks must be carried out before calling\n    /// @param _bytes The input bytes string to slice\n    /// @return _address The address starting at byte 0\n    function toAddress(\n        bytes calldata _bytes\n    ) internal pure returns (address _address) {\n        if (_bytes.length < Constants.ADDR_SIZE) revert SliceOutOfBounds();\n        assembly {\n            _address := shr(96, calldataload(_bytes.offset))\n        }\n    }\n\n    /// @notice Returns the pool details starting at byte 0\n    /// @dev length and overflow checks must be carried out before calling\n    /// @param _bytes The input bytes string to slice\n    /// @return token0 The address at byte 0\n    /// @return fee The uint24 starting at byte 20\n    /// @return token1 The address at byte 23\n    function toPool(\n        bytes calldata _bytes\n    ) internal pure returns (address token0, uint24 fee, address token1) {\n        if (_bytes.length < Constants.V3_POP_OFFSET) revert SliceOutOfBounds();\n        assembly {\n            let firstWord := calldataload(_bytes.offset)\n            token0 := shr(96, firstWord)\n            fee := and(shr(72, firstWord), 0xffffff)\n            token1 := shr(96, calldataload(add(_bytes.offset, 23)))\n        }\n    }\n\n    /// @notice Decode the `_arg`-th element in `_bytes` as a dynamic array\n    /// @dev The decoding of `length` and `offset` is universal,\n    /// whereas the type declaration of `res` instructs the compiler how to read it.\n    /// @param _bytes The input bytes string to slice\n    /// @param _arg The index of the argument to extract\n    /// @return length Length of the array\n    /// @return offset Pointer to the data part of the array\n    function toLengthOffset(\n        bytes calldata _bytes,\n        uint256 _arg\n    ) internal pure returns (uint256 length, uint256 offset) {\n        uint256 relativeOffset;\n        assembly {\n            // The offset of the `_arg`-th element is `32 * arg`, which stores the offset of the length pointer.\n            // shl(5, x) is equivalent to mul(32, x)\n            let lengthPtr := add(\n                _bytes.offset,\n                calldataload(add(_bytes.offset, shl(5, _arg)))\n            )\n            length := calldataload(lengthPtr)\n            offset := add(lengthPtr, 0x20)\n            relativeOffset := sub(offset, _bytes.offset)\n        }\n        if (_bytes.length < length + relativeOffset) revert SliceOutOfBounds();\n    }\n\n    /// @notice Decode the `_arg`-th element in `_bytes` as `address[]`\n    /// @param _bytes The input bytes string to extract an address array from\n    /// @param _arg The index of the argument to extract\n    function toAddressArray(\n        bytes calldata _bytes,\n        uint256 _arg\n    ) internal pure returns (address[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n\n    /// @notice Equivalent to abi.decode(bytes, bytes[])\n    /// @param _bytes The input bytes string to extract an parameters from\n    function decodeCommandsAndInputs(\n        bytes calldata _bytes\n    ) internal pure returns (bytes calldata, bytes[] calldata) {\n        return _bytes.decodeActionsRouterParams();\n    }\n}\n"}, "contracts/modules/v3/TickMath.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nlibrary TickMath {\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    uint160 internal constant MAX_SQRT_RATIO =\n        1461446703485210103287273052203988822378723970342;\n}\n"}, "contracts/modules/v3/V3Path.sol": {"content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.30;\n\nimport {BytesLib} from \"./BytesLib.sol\";\nimport {Constants} from \"../../libraries/Constants.sol\";\n\n/// @title Functions for manipulating path data for multihop swaps\nlibrary V3Path {\n    using BytesLib for bytes;\n\n    /// @notice Returns true iff the path contains two or more pools\n    /// @param path The encoded swap path\n    /// @return True if path contains two or more pools, otherwise false\n    function hasMultiplePools(\n        bytes calldata path\n    ) internal pure returns (bool) {\n        return path.length >= Constants.MULTIPLE_V3_POOLS_MIN_LENGTH;\n    }\n\n    /// @notice Decodes the first pool in path\n    /// @param path The bytes encoded swap path\n    /// @return tokenA The first token of the given pool\n    /// @return fee The fee level of the pool\n    /// @return tokenB The second token of the given pool\n    function decodeFirstPool(\n        bytes calldata path\n    ) internal pure returns (address, uint24, address) {\n        return path.toPool();\n    }\n\n    /// @notice Gets the segment corresponding to the first pool in the path\n    /// @param path The bytes encoded swap path\n    /// @return The segment containing all data necessary to target the first pool in the path\n    function getFirstPool(\n        bytes calldata path\n    ) internal pure returns (bytes calldata) {\n        return path[:Constants.V3_POP_OFFSET];\n    }\n\n    function decodeFirstToken(\n        bytes calldata path\n    ) internal pure returns (address tokenA) {\n        tokenA = path.toAddress();\n    }\n\n    /// @notice Skips a token + fee element\n    /// @param path The swap path\n    function skipToken(\n        bytes calldata path\n    ) internal pure returns (bytes calldata) {\n        return path[Constants.NEXT_V3_POOL_OFFSET:];\n    }\n}\n"}, "contracts/modules/v3/V3SwapRouter.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {IUniV3Quoter, IUniV3Factory, IUniV3Pool} from \"../../interfaces/IUniV3.sol\";\nimport {IUniV3Callback} from \"../../interfaces/IUniV3Callback.sol\";\nimport {SafeTransferLib} from \"../../libraries/SafeTransferLib.sol\";\nimport {InvalidAmount, InvalidPool, SlippageIsTooLow} from \"../../libraries/Errors.sol\";\nimport {Payments} from \"../Payments.sol\";\nimport {V3Path} from \"./V3Path.sol\";\nimport {BytesLib} from \"./BytesLib.sol\";\nimport {CalldataDecoder} from \"../../libraries/CalldataDecoder.sol\";\nimport {ActionConstants} from \"../../libraries/ActionConstants.sol\";\nimport {TickMath} from \"./TickMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nabstract contract V3SwapRouter is IUniV3Callback, Payments {\n    using V3Path for bytes;\n    using BytesLib for bytes;\n    using SafeCast for uint256;\n    using SafeTransferLib for address;\n    using CalldataDecoder for bytes;\n\n    /// @dev Mapping of factory addresses to their validity status\n    mapping(address => bool) private _factoryOf;\n\n    constructor(address[] memory factories) {\n        for (uint i = 0; i < factories.length; i++) {\n            _factoryOf[factories[i]] = true;\n        }\n    }\n\n    function _v3Swap(\n        address factory,\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        bytes calldata path,\n        address payer\n    ) internal {\n        // use amountIn == ActionConstants.CONTRACT_BALANCE as a flag to swap the entire balance of the contract\n        if (amountIn == ActionConstants.CONTRACT_BALANCE) {\n            address tokenIn = path.decodeFirstToken();\n            amountIn = IERC20(tokenIn).balanceOf(address(this));\n        }\n\n        uint256 amountOut;\n        while (true) {\n            bool hasMultiplePools = path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            (int256 amount0Delta, int256 amount1Delta, bool zeroForOne) = _swap(\n                amountIn.toInt256(),\n                hasMultiplePools ? address(this) : recipient, // for intermediate swaps, this contract custodies\n                path.getFirstPool(), // only the first pool is needed\n                payer, // for intermediate swaps, this contract custodies\n                factory\n            );\n\n            amountIn = uint256(-(zeroForOne ? amount1Delta : amount0Delta));\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this);\n                path = path.skipToken();\n            } else {\n                amountOut = amountIn;\n                break;\n            }\n        }\n\n        if (amountOut < amountOutMinimum) revert SlippageIsTooLow(amountOut);\n    }\n\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external {\n        _executeCallback(amount0Delta, amount1Delta, data);\n    }\n\n    function pancakeV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external {\n        _executeCallback(amount0Delta, amount1Delta, data);\n    }\n\n    function _executeCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) private {\n        if (amount0Delta <= 0 && amount1Delta <= 0) revert InvalidAmount();\n        (, address payer, address factory) = abi.decode(\n            data,\n            (bytes, address, address)\n        );\n        bytes calldata path = data.toBytes(0);\n        (address tokenIn, uint24 fee, address tokenOut) = path\n            .decodeFirstPool();\n        _verify(factory, tokenIn, tokenOut, fee);\n\n        /// @dev Only exact input is supported\n        uint256 amountToPay = amount0Delta > 0\n            ? uint256(amount0Delta)\n            : uint256(amount1Delta);\n        payOrTransferFrom(tokenIn, payer, msg.sender, amountToPay);\n    }\n\n    function _verify(\n        address factory,\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) private view {\n        address pool = IUniV3Factory(factory).getPool(tokenA, tokenB, fee);\n        if (msg.sender != pool || !_factoryOf[factory]) revert InvalidPool();\n    }\n\n    function _swap(\n        int256 amount,\n        address recipient,\n        bytes calldata path,\n        address payer,\n        address factory\n    )\n        private\n        returns (int256 amount0Delta, int256 amount1Delta, bool zeroForOne)\n    {\n        (address tokenIn, uint24 fee, address tokenOut) = path\n            .decodeFirstPool();\n\n        zeroForOne = tokenIn < tokenOut;\n\n        (amount0Delta, amount1Delta) = IUniV3Pool(\n            IUniV3Factory(factory).getPool(tokenIn, tokenOut, fee)\n        ).swap(\n                recipient,\n                zeroForOne,\n                amount,\n                (\n                    zeroForOne\n                        ? TickMath.MIN_SQRT_RATIO + 1\n                        : TickMath.MAX_SQRT_RATIO - 1\n                ),\n                abi.encode(path, payer, factory)\n            );\n    }\n}\n"}, "contracts/XSwapRouter.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {ISmartRouter} from \"./interfaces/ISmartRouter.sol\";\nimport {PaymentsImmutables} from \"./modules/PaymentsImmutables.sol\";\nimport {V3SwapRouter} from \"./modules/v3/V3SwapRouter.sol\";\nimport {ReferrerProxy} from \"./modules/referrer/ReferrerProxy.sol\";\nimport {Dispatcher} from \"./base/Dispatcher.sol\";\nimport {Commands} from \"./libraries/Commands.sol\";\nimport {IWETH9} from \"./interfaces/IWETH9.sol\";\n\n/**\n * @title XSwapRouter\n * @notice The Safest DEX Aggregator\n * @dev XSwapRouter contract for xSwap protocol\n * @author https://xswap.app\n */\ncontract XSwapRouter is ISmartRouter, Dispatcher {\n    constructor(\n        IWETH9 weth9,\n        address referrer,\n        address[] memory v3Factories\n    )\n        PaymentsImmutables(weth9)\n        V3SwapRouter(v3Factories)\n        ReferrerProxy(referrer)\n    {}\n\n    modifier checkDeadline(uint256 deadline) {\n        if (block.timestamp > deadline) revert TransactionDeadlinePassed();\n        _;\n    }\n\n    receive() external payable {\n        if (msg.sender != address(WETH9)) revert InvalidEthSender();\n    }\n\n    function execute(\n        bytes calldata commands,\n        bytes[] calldata inputs,\n        uint256 deadline\n    ) external payable checkDeadline(deadline) {\n        execute(commands, inputs);\n    }\n\n    /// @inheritdoc Dispatcher\n    function execute(\n        bytes calldata commands,\n        bytes[] calldata inputs\n    ) public payable override isNotLocked {\n        bool success;\n        bytes memory output;\n        uint256 numCommands = commands.length;\n        if (inputs.length != numCommands) revert LengthMismatch();\n\n        // loop through all given commands, execute them and pass along outputs as defined\n        for (\n            uint256 commandIndex = 0;\n            commandIndex < numCommands;\n            commandIndex++\n        ) {\n            bytes1 command = commands[commandIndex];\n\n            bytes calldata input = inputs[commandIndex];\n\n            (success, output) = dispatch(command, input);\n\n            if (!success && successRequired(command)) {\n                revert ExecutionFailed({\n                    commandIndex: commandIndex,\n                    message: output\n                });\n            }\n        }\n    }\n\n    function successRequired(bytes1 command) internal pure returns (bool) {\n        return command & Commands.FLAG_ALLOW_REVERT == 0;\n    }\n}\n"}}, "settings": {"viaIR": false, "optimizer": {"enabled": true}, "evmVersion": "cancun", "outputSelection": {"*": {"*": ["evm.legacyAssembly"]}}, "libraries": {}}}