{"language": "Solidity", "settings": {"optimizer": {"enabled": true}, "viaIR": false, "outputSelection": {"*": {"*": ["evm.legacyAssembly"]}}, "remappings": []}, "sources": {"contracts/swap/UniversalRouter.sol": {"content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.30;\r\n\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\n/**\r\n * @title  DSF UniversalRouter\r\n * @author Andrei Averin \u2014 CTO dsf.finance\r\n * @notice A universal router that combines DEX modules (Curve, UniswapV2, SushiSwap, UniswapV3, etc.)\r\n *         and performs single and split swaps with automatic commission withholding.\r\n * @dev    Router:\r\n * - Requests the best quotes (1-hop and 2-hop) from all modules;\r\n * - Selects the optimal route or split between the two best;\r\n * - Pulls tokens from the user, approves modules, and executes the swap;\r\n * - Charges a fee from the swap (feeBpsSwap) and from positive slippage (feeBpsPositive);\r\n * - Supports ETH\u2194WETH, secure calls, and module list management.\r\n *\r\n * Uses low-level staticcall to IDexModule.getBestRoute(address,address,uint256)\r\n * and a unified payload format: \r\n * abi.encode(module,index,quotedOut,tokenIn,tokenOut,amountIn,bytes[] route).\r\n */\r\n\r\n/* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Interfaces / Types \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n\r\nstruct DexRoute { bytes[] data; }\r\n\r\nstruct Quote {\r\n    address pool;\r\n    int128  i;\r\n    int128  j;\r\n    bool    useUnderlying;\r\n    uint256 amountOut;\r\n}\r\n\r\nstruct BestAgg {\r\n    bytes payload;\r\n    uint256 amount;\r\n    address module;\r\n    uint256 idx;\r\n}\r\n\r\nstruct RouteInfo {\r\n    address module;\r\n    uint256 index;\r\n    bytes   payload;  // the same format as in getBestRoute/decodeRoute\r\n    uint256 amount;   // quotedOut\r\n}\r\n\r\nstruct QuoteArgs {\r\n    address tokenIn;\r\n    address tokenOut;\r\n    uint256 amountIn;\r\n}\r\n\r\nstruct LegDecoded {\r\n    address module;\r\n    uint256 index;\r\n    uint256 quoted;   // quotedOut from payload\r\n    address tokenIn;\r\n    address tokenOut;\r\n    uint256 amountIn;\r\n    bytes[] route;\r\n}\r\n\r\nstruct SplitResult {\r\n    address moduleA;\r\n    address moduleB;\r\n    address tokenIn;\r\n    address tokenOut;\r\n    uint256 totalIn;\r\n    uint256 amountInA;\r\n    uint256 amountInB;\r\n    uint256 outA;\r\n    uint256 outB;\r\n    uint256 totalOut;\r\n}\r\n\r\nstruct TrackedRoute {\r\n    bytes payload;\r\n    uint256 amountOut;\r\n    address module;\r\n    uint256 moduleIndex;\r\n}\r\n\r\nstruct BestQuotes {\r\n    TrackedRoute top1Hop;\r\n    TrackedRoute second1Hop;\r\n    TrackedRoute top2Hop;\r\n    TrackedRoute second2Hop;\r\n}\r\n\r\nstruct ModuleQuotes {\r\n    address module;\r\n    uint256 moduleIndex;\r\n    bytes payload1Hop;\r\n    uint256 amountOut1Hop;\r\n    bytes payload2Hop;\r\n    uint256 amountOut2Hop;\r\n}\r\n\r\ninterface IFeedRegistry {\r\n    function latestRoundData(address base, address quote)\r\n        external\r\n        view\r\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\r\n\r\n    function decimals(address base, address quote) external view returns (uint8);\r\n}\r\n\r\ninterface IDexModule {\r\n    /**\r\n     * @notice  Compute the best 1-hop and 2-hop routes.\r\n     * @param   tokenIn       Input token\r\n     * @param   tokenOut      Output token\r\n     * @param   amountIn      Input amount\r\n     * @return  best1HopRoute Serialized 1-hop route\r\n     * @return  amountOut1Hop Quoted 1-hop output\r\n     * @return  best2HopRoute Serialized 2-hop route\r\n     * @return  amountOut2Hop Quoted 2-hop output\r\n     */\r\n    function getBestRoute(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountIn\r\n    ) external view returns (\r\n        DexRoute memory best1HopRoute,\r\n        uint256 amountOut1Hop,\r\n        DexRoute memory best2HopRoute,\r\n        uint256 amountOut2Hop\r\n    );\r\n\r\n    /**\r\n     * @notice  Execute a previously returned route with a slippage check based on a percentage.\r\n     * @param   route     Serialized route\r\n     * @param   to        Recipient of the final tokens\r\n     * @param   percent   Percentage (0-100) of amountIn from the route to be swapped. 100 = 100%.\r\n     * @return  amountOut Actual output received\r\n     */\r\n    function swapRoute(\r\n        DexRoute calldata route,\r\n        address to,\r\n        uint256 percent\r\n    ) external returns (uint256 amountOut);\r\n\r\n    /**\r\n     * @notice  Simulate a route (1\u20132 hops) encoded as {DexRoute}.\r\n     * @param   route Serialized route\r\n     * @param   percent   Percentage (0-100)\r\n     * @return  amountOut Quoted total output amount\r\n     */\r\n    function simulateRoute(\r\n        DexRoute calldata route,\r\n        uint256 percent\r\n    ) external view returns (uint256 amountOut);\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function withdraw(uint256 amount) external;\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function balanceOf(address) external view returns (uint256);\r\n}\r\n\r\ncontract UniversalRouter is Ownable, ReentrancyGuard {\r\n    using SafeERC20 for IERC20;\r\n\r\n    /* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Storage \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n\r\n    address constant DENOM_ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    address constant DENOM_USD = 0x0000000000000000000000000000000000000348;\r\n\r\n    // Store the registry address and maximum price \u201cfreshness\u201d\r\n    address public feedRegistry = 0x47Fb2585D2C56Fe188D0E6ec628a38b74fCeeeDf;\r\n\r\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address[] public modules;                                // list of modules (Curve, UniV2, Sushi, UniV3)\r\n    mapping(address => bool)     public isModule;\r\n    mapping(address => uint256)  private moduleIndexPlusOne; // 1-based for O(1) remove\r\n\r\n    /* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Fees config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n\r\n    address public feeRecipient;                             // commission recipient address\r\n    uint16  public feeBpsSwap;                               // commission in bps (max 10000 = 100%)\r\n    uint16  public feeBpsPositive;                           // commission with positive slippage, bps (max 10000 = 100%)\r\n\r\n    /* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Fees caps \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n\r\n    uint16 public constant MAX_FEE_SWAP_BPS      = 100;      // 1%\r\n    uint16 public constant MAX_FEE_POSITIVE_BPS  = 10_000;   // 100%\r\n\r\n    /* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Events \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n\r\n    event ModuleAdded(address indexed module);\r\n    event ModuleRemoved(address indexed module);\r\n    event ModulesReset(uint256 newCount);\r\n    event FeeConfigUpdated(address indexed recipient, uint16 bpsSwap, uint16 bpsPositive);\r\n    event ERC20Recovered(address indexed token, address indexed to, uint256 amount);\r\n    event ETHSwept(address indexed to, uint256 amount);\r\n\r\n    /**\r\n     * @notice Execution of a single swap.\r\n     * @param  module    Module that executed the route.\r\n     * @param  user      Initiator (msg.sender).\r\n     * @param  to        Recipient of the final funds.\r\n     * @param  tokenIn   Input token.\r\n     * @param  tokenOut  Output token.\r\n     * @param  amountIn  Input amount (withdrawn from the user).\r\n     * @param  amountOut Final amount after fees (net).\r\n     * @param  quotedOut Expected output (quota from payload).\r\n     */\r\n    event SwapExecuted(\r\n        address indexed module,\r\n        address indexed user,\r\n        address indexed to,\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountIn,\r\n        uint256 amountOut,\r\n        uint256 quotedOut\r\n    );\r\n\r\n    /**\r\n     * @notice Execution of a split swap via two routes.\r\n     * @param  user      Initiator (msg.sender).\r\n     * @param  to        Recipient of the final funds.\r\n     * @param  moduleA   Module A.\r\n     * @param  moduleB   Module B.\r\n     * @param  tokenIn   Input token (or WETH for ETH route).\r\n     * @param  tokenOut  Output token.\r\n     * @param  totalIn   Total input.\r\n     * @param  totalOut  Total output (after fees \u2014 if the event is emitted after distribution).\r\n     * @param  bpsA      Share A in percent (0\u2013100).\r\n     */\r\n    event SwapSplitExecuted(\r\n        address indexed user,\r\n        address indexed to,\r\n        address moduleA,\r\n        address moduleB,\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 totalIn,\r\n        uint256 totalOut,\r\n        uint16  bpsA\r\n    );\r\n\r\n    /* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Errors \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n\r\n    error ZeroAddress();\r\n    error DuplicateModule();\r\n    error NotAModule();\r\n    error NoRouteFound();\r\n\r\n    /* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Modifiers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n\r\n    modifier onlyERC20(address token) {\r\n        require(token != address(0) && token.code.length > 0, \"not ERC20\");\r\n        _;\r\n    }\r\n\r\n    /* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 receive \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n\r\n    /// @notice Needed to get native ETH (e.g., with IWETH.withdraw()).\r\n    receive() external payable {}\r\n\r\n    /* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Constructor \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n\r\n    /**\r\n     * @notice Deploys the router and configures modules and commission parameters.\r\n     * @param  _modules        List of module addresses (Curve/UniV2/UniV3/\u2026).\r\n     * @param  _feeRecipient   Address of the commission recipient.\r\n     * @param  _feeBpsSwap     Swap fee, bps (max. limited by require inside).\r\n     * @param  _feeBpsPositive Positive slippage fee, bps (max. limited by require inside).\r\n     */\r\n    constructor(\r\n        address[] memory _modules, \r\n        address _feeRecipient, \r\n        uint16 _feeBpsSwap,\r\n        uint16 _feeBpsPositive\r\n    ) Ownable(msg.sender) {\r\n        _setModules(_modules);\r\n        require(_feeBpsSwap     <= MAX_FEE_SWAP_BPS,     \"UR: swap fee too high\");\r\n        require(_feeBpsPositive <= MAX_FEE_POSITIVE_BPS, \"UR: pos fee too high\");\r\n        feeRecipient   = _feeRecipient;\r\n        feeBpsSwap     = _feeBpsSwap;\r\n        feeBpsPositive = _feeBpsPositive;\r\n\r\n        emit FeeConfigUpdated(feeRecipient, feeBpsSwap, feeBpsPositive);\r\n    }\r\n\r\n    /* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Admin: Registry \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n\r\n    function setFeedRegistry(address reg) external onlyOwner { \r\n        require(reg != address(0), \"UR: bad registry\");\r\n        require(reg.code.length > 0, \"UR: registry not a contract\");\r\n        feedRegistry = reg; \r\n    }\r\n\r\n    /* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Admin: modules mgmt \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n\r\n    /**\r\n     * @notice Complete reset of the module list.\r\n     * @dev    Clears old ones, adds new ones, emits ModulesReset.\r\n     * @param  _modules New list of modules.\r\n     */\r\n    function setModules(address[] calldata _modules) external onlyOwner {\r\n        _clearModules();\r\n        _addModules(_modules);\r\n        emit ModulesReset(_modules.length);\r\n    }\r\n\r\n    /**\r\n     * @notice Add module to allowlist.\r\n     * @param  module Address of IDexModule module.\r\n     */\r\n    function addModule(address module) external onlyOwner {\r\n        _addModule(module);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove module from allowlist.\r\n     * @param  module Address of IDexModule module.\r\n     */\r\n    function removeModule(address module) external onlyOwner {\r\n        _removeModule(module);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the number of connected modules.\r\n     * @return The length of the modules array.\r\n     */\r\n    function modulesLength() external view returns (uint256) {\r\n        return modules.length;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current list of modules.\r\n     * @dev    The array is returned in memory (a copy of the state).\r\n     * @return An  array of module addresses.\r\n     */\r\n    function getModules() external view returns (address[] memory) {\r\n        return modules;\r\n    }\r\n\r\n    /* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Admin \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n    \r\n    /**\r\n     * @notice Rescue all stuck ERC-20 tokens to `to` or owner.\r\n     * @dev    Owner-only. Uses SafeERC20. Always sends the entire token balance\r\n     *         held by this contract. If `to` is zero, defaults to owner().\r\n     * @param  token ERC-20 token address to rescue (must be non-zero).\r\n     * @param  to    Recipient; if zero address, defaults to owner().\r\n     */\r\n    function recoverERC20(address token, address to)\r\n        external\r\n        onlyOwner\r\n        nonReentrant\r\n    {\r\n        require(token != address(0), \"UR: token=0\");\r\n        address recipient = (to == address(0)) ? owner() : to;\r\n\r\n        uint256 amt = IERC20(token).balanceOf(address(this));\r\n        if (amt == 0) return; // nothing to do\r\n\r\n        IERC20(token).safeTransfer(recipient, amt);\r\n        emit ERC20Recovered(token, recipient, amt);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers all remaining ETH from the contract to the owner or specified address.\r\n     * @dev    Only for the owner (onlyOwner). Added nonReentrant to protect against repeated calls.\r\n     *         If the `to` parameter is equal to a zero address, the funds are sent to the contract owner.\r\n     * @param  to The address of the ETH recipient (if 0x0 \u2014 send to the owner).\r\n     */\r\n    function sweepETH(address to)\r\n        external\r\n        onlyOwner\r\n        nonReentrant\r\n    {\r\n        address recipient = (to == address(0)) ? owner() : to;\r\n        uint256 bal = address(this).balance;\r\n        (bool ok,) = recipient.call{value: bal}(\"\");\r\n        require(ok, \"ETH sweep failed\");\r\n        emit ETHSwept(recipient, bal);\r\n    }\r\n\r\n    /* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Admin: fee \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n\r\n    /**\r\n     * @notice Update the address of the commission recipient.\r\n     * @param  _recipient New address of the fee recipient.\r\n     */\r\n    function setFeeRecipient(address _recipient) external onlyOwner {\r\n        feeRecipient = _recipient;\r\n        emit FeeConfigUpdated(feeRecipient, feeBpsSwap, feeBpsPositive);\r\n    }\r\n\r\n    /**\r\n     * @notice Update commission percentages.\r\n     * @dev    Upper limit checked via require; emits FeeConfigUpdated.\r\n     * @param  _feeBpsSwap Swap commission, bps.\r\n     * @param  _feeBpsPositive Positive slippage commission, bps.\r\n     */\r\n    function setFeePercents(uint16 _feeBpsSwap, uint16 _feeBpsPositive) external onlyOwner {\r\n        require(_feeBpsSwap     <= MAX_FEE_SWAP_BPS,     \"UR: swap fee too high\");\r\n        require(_feeBpsPositive <= MAX_FEE_POSITIVE_BPS, \"UR: pos fee too high\");\r\n        feeBpsSwap     = _feeBpsSwap;\r\n        feeBpsPositive = _feeBpsPositive;\r\n        emit FeeConfigUpdated(feeRecipient, feeBpsSwap, feeBpsPositive);\r\n    }\r\n\r\n    /**\r\n     * @notice Completely reinstalls the list of modules.\r\n     * @dev    Clears the current modules, then adds new ones. Emits ModulesReset.\r\n     * @param  _modules New list of modules.\r\n     */\r\n    function _setModules(address[] memory _modules) internal {\r\n        _clearModules();\r\n        uint256 n = _modules.length;\r\n        for (uint256 i; i < n; ) {\r\n            _addModule(_modules[i]);\r\n            unchecked { ++i; }\r\n        }\r\n        emit ModulesReset(n);\r\n    }\r\n\r\n    /**\r\n     * @notice Resets (clears) all modules.\r\n     * @dev    Resets isModule and indexes; clears the modules array.\r\n     */\r\n    function _clearModules() internal {\r\n        uint256 n = modules.length;\r\n        for (uint256 i; i < n; ) {\r\n            address m = modules[i];\r\n            isModule[m] = false;\r\n            moduleIndexPlusOne[m] = 0;\r\n            unchecked { ++i; }\r\n        }\r\n        delete modules;\r\n    }\r\n\r\n    /**\r\n     * @notice Adds modules in bulk.\r\n     * @dev    Calls _addModule for each address.\r\n     * @param  _modules List of module addresses.\r\n     */\r\n    function _addModules(address[] calldata _modules) internal {\r\n        uint256 n = _modules.length;\r\n        for (uint256 i; i < n; ) {\r\n            _addModule(_modules[i]);\r\n            unchecked { ++i; }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Adds one module to the allowlist.\r\n     * @dev    Checks for a non-zero address, the presence of code, and the absence of duplicates.\r\n     *         Updates isModule, modules, and moduleIndexPlusOne. Emits ModuleAdded.\r\n     * @param  module The module contract address.\r\n     */\r\n    function _addModule(address module) internal {\r\n        if (module == address(0)) revert ZeroAddress();\r\n        if (isModule[module]) revert DuplicateModule();\r\n\r\n        // (\u043e\u043f\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u043e) \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u0430\u044f \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043a\u043e\u0434\u0430\r\n        if (module.code.length == 0) revert ZeroAddress();\r\n\r\n        isModule[module] = true;\r\n        modules.push(module);\r\n        moduleIndexPlusOne[module] = modules.length; // 1-based\r\n        emit ModuleAdded(module);\r\n    }\r\n\r\n    /**\r\n     * @notice Removes a module from the allowlist.\r\n     * @dev    Performs O(1) removal via swap-pop, supporting 1-based indexing.\r\n     *         Emit ModuleRemoved.\r\n     * @param  module Address of the module to be removed.\r\n     */\r\n    function _removeModule(address module) internal {\r\n        uint256 idxPlusOne = moduleIndexPlusOne[module];\r\n        if (idxPlusOne == 0) revert NotAModule();\r\n\r\n        uint256 idx = idxPlusOne - 1;\r\n        uint256 lastIdx = modules.length - 1;\r\n\r\n        if (idx != lastIdx) {\r\n            address last = modules[lastIdx];\r\n            modules[idx] = last;\r\n            moduleIndexPlusOne[last] = idx + 1;\r\n        }\r\n        modules.pop();\r\n\r\n        isModule[module] = false;\r\n        moduleIndexPlusOne[module] = 0;\r\n        emit ModuleRemoved(module);\r\n    }\r\n\r\n    /* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 WETH Helpers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n    \r\n    /**\r\n     * @dev    Wraps incoming native ETH into WETH.\r\n     * @param  amount Amount of ETH to wrap (msg.value).\r\n     */\r\n    function _wrapETH(uint256 amount) internal {\r\n        IWETH(WETH).deposit{value: amount}();\r\n    }\r\n\r\n    /**\r\n     * @dev    Converts WETH back to ETH and sends it to the recipient.\r\n     * @param  amount Amount of WETH to convert.\r\n     * @param  to Recipient's native ETH address.\r\n     */\r\n    function _unwrapWETHAndSend(uint256 amount, address to) internal {\r\n        require(IWETH(WETH).balanceOf(address(this)) >= amount, \"UR: insufficient WETH\");\r\n        IWETH(WETH).withdraw(amount);\r\n        // Send native ETH\r\n        (bool success,) = to.call{value: amount}(\"\");\r\n        require(success, \"UR: ETH transfer failed\");\r\n    }\r\n\r\n    /* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 ETH payout/guards \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n\r\n    /**\r\n     * @notice Ensures that tokenIn == WETH in the input payload.\r\n     * @dev    Reads the address from slot 3 of the payload ABI header (see _loadAddressFromPayload).\r\n     * @param  payload ABI-encoded route: (module,index,quotedOut,tokenIn,tokenOut,amountIn,bytes[]).\r\n     */\r\n    function _requireWethIn(bytes calldata payload) internal pure {\r\n        address tokenIn = _loadAddressFromPayload(payload, 3);\r\n        require(tokenIn == WETH, \"UR: payload tokenIn != WETH\");\r\n    }\r\n\r\n    /**\r\n     * @notice Ensures that tokenOut == WETH in the output payload.\r\n     * @dev    Reads the address from the ABI header payload in slot 4 (see _loadAddressFromPayload).\r\n     * @param  payload ABI-encoded route: (module,index,quotedOut,tokenIn,tokenOut,amountIn,bytes[]).\r\n     */\r\n    function _requireWethOut(bytes calldata payload) internal pure {\r\n        address tokenOut = _loadAddressFromPayload(payload, 4);\r\n        require(tokenOut == WETH, \"UR: payload tokenOut != WETH\");\r\n    }\r\n\r\n    /**\r\n     * @notice Quick reading of the address from the ABI header payload.\r\n     * @dev    The slot corresponds to the position of a 32-byte word in abi.encode(...).\r\n     *         0: module, 1: index, 2: quotedOut, 3: tokenIn, 4: tokenOut, 5: amountIn, 6: offset(bytes[]).\r\n     * @param  payload Full ABI payload.\r\n     * @param  slot Slot number (0-based).\r\n     * @return a Address read from the specified slot.\r\n     */\r\n    function _loadAddressFromPayload(bytes calldata payload, uint256 slot) internal pure returns (address a) {\r\n        assembly (\"memory-safe\") {\r\n            a := shr(96, calldataload(add(payload.offset, mul(slot, 32))))\r\n        }\r\n    }\r\n\r\n    /* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Helpers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n\r\n    /**\r\n     * @notice Updates the best quotes in 1-hop and 2-hop segments.\r\n     * @dev    Supports \u201ctop-1\u201d and \u201ctop-2\u201d for each category.\r\n     * @param  currentBest Current best routes.\r\n     * @param  newRoute Candidate for inclusion.\r\n     * @param  is1Hop 1-hop (true) or 2-hop (false) flag.\r\n     */\r\n    function _updateBestQuotes(BestQuotes memory currentBest, TrackedRoute memory newRoute, bool is1Hop) private pure {\r\n        if (is1Hop) {\r\n            if (newRoute.amountOut > currentBest.top1Hop.amountOut) {\r\n                currentBest.second1Hop = currentBest.top1Hop;\r\n                currentBest.top1Hop = newRoute;\r\n            } else if (newRoute.amountOut > currentBest.second1Hop.amountOut) {\r\n                currentBest.second1Hop = newRoute;\r\n            }\r\n        } else { // 2-hop\r\n            if (newRoute.amountOut > currentBest.top2Hop.amountOut) {\r\n                currentBest.second2Hop = currentBest.top2Hop;\r\n                currentBest.top2Hop = newRoute;\r\n            } else if (newRoute.amountOut > currentBest.second2Hop.amountOut) {\r\n                currentBest.second2Hop = newRoute;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the two absolute best routes found so far (overall Top-1 and Top-2).\r\n     * @dev    If the new route beats Top-1, it becomes Top-1 and the old Top-1 shifts to Top-2.\r\n     *         Otherwise, if it only beats Top-2, it replaces Top-2.\r\n     * @param  top1     Current absolute best route (Top-1).\r\n     * @param  top2     Current second absolute best route (Top-2).\r\n     * @param  newRoute Newly observed candidate route to compare against the tops.\r\n     * @return Updated  Top-1 and Top-2 routes (in this order).\r\n     */\r\n    function _updateTopOverall(\r\n        TrackedRoute memory top1,\r\n        TrackedRoute memory top2,\r\n        TrackedRoute memory newRoute\r\n    ) private pure returns (TrackedRoute memory, TrackedRoute memory) {\r\n        if (newRoute.amountOut > top1.amountOut) {\r\n            top2 = top1;\r\n            top1 = newRoute;\r\n        } else if (newRoute.amountOut > top2.amountOut) {\r\n            top2 = newRoute;\r\n        }\r\n        return (top1, top2);\r\n    }\r\n\r\n    /**\r\n     * @notice Queries a module for the best 1-hop and 2-hop quotes and packages them as payloads.\r\n     * @dev    Calls IDexModule.getBestRoute via staticcall and, if non-zero quotes are returned,\r\n     *         encodes payloads as abi.encode(module, index, quotedOut, tokenIn, tokenOut, amountIn, route.data).\r\n     *         If the module is not registered or the call fails/returns empty, the struct remains zeroed.\r\n     * @param  m   Module address being queried.\r\n     * @param  idx Module index (stored for payload bookkeeping).\r\n     * @param  a   Quote arguments (tokenIn, tokenOut, amountIn).\r\n     * @return quotes Struct holding module info, 1-hop/2-hop amounts and payloads (if any).\r\n     */\r\n    function _getModuleQuotes(\r\n        address m,\r\n        uint256 idx,\r\n        QuoteArgs memory a\r\n    ) internal view returns (ModuleQuotes memory quotes) {\r\n        quotes.module = m;\r\n        quotes.moduleIndex = idx;\r\n        \r\n        if (!isModule[m]) return quotes;\r\n\r\n        bytes memory cd = abi.encodeWithSelector(\r\n            IDexModule.getBestRoute.selector,\r\n            a.tokenIn,\r\n            a.tokenOut,\r\n            a.amountIn\r\n        );\r\n\r\n        (bool success, bytes memory ret) = m.staticcall(cd);\r\n        if (!success || ret.length == 0) return quotes;\r\n\r\n        (\r\n            DexRoute memory route1, uint256 out1,\r\n            DexRoute memory route2, uint256 out2\r\n        ) = abi.decode(ret, (DexRoute, uint256, DexRoute, uint256));\r\n\r\n        // Build payloads only for non-zero, non-empty routes.\r\n        if (out1 > 0 && route1.data.length > 0) {\r\n            quotes.amountOut1Hop = out1;\r\n            quotes.payload1Hop = abi.encode(\r\n                m, idx, out1, a.tokenIn, a.tokenOut, a.amountIn, route1.data\r\n            );\r\n        }\r\n        \r\n        if (out2 > 0 && route2.data.length > 0) {\r\n            quotes.amountOut2Hop = out2;\r\n            quotes.payload2Hop = abi.encode(\r\n                m, idx, out2, a.tokenIn, a.tokenOut, a.amountIn, route2.data\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev    Private helper function for calculating the total output amount.\r\n     * @param  percentA Percentage of amountIn for Route A (0-100).\r\n     */\r\n    function _calculateTotalOut(\r\n        address moduleA,\r\n        bytes[] memory routeA,\r\n        address moduleB,\r\n        bytes[] memory routeB,\r\n        uint16 percentA // 0-100\r\n    ) internal view returns (uint256 totalOut) {\r\n        uint16 percentB = 100 - percentA;\r\n        \r\n        // simulateRoute for A (percent 0\u2013100)\r\n        uint256 outA = IDexModule(moduleA).simulateRoute(DexRoute({ data: routeA }), percentA);\r\n        \r\n        // simulateRoute for B (percent 0\u2013100)\r\n        uint256 outB = IDexModule(moduleB).simulateRoute(DexRoute({ data: routeB }), percentB);\r\n        \r\n        return outA + outB;\r\n    }\r\n\r\n    /**\r\n     * @notice Safely sets the allowance to the required minimum.\r\n     * @dev    If the current allowance < amount, first set it to zero (if >0), then set it to type(uint256).max.\r\n     *         Uses    SafeERC20.forceApprove for maximum compatibility.\r\n     * @param  token   ERC20 token address.\r\n     * @param  spender Contract address to which we issue the allowance.\r\n     * @param  amount  Minimum required limit.\r\n     */\r\n    function _smartApprove(address token, address spender, uint256 amount) internal {\r\n        uint256 cur = IERC20(token).allowance(address(this), spender);\r\n        if (cur < amount) {\r\n            if (cur > 0) IERC20(token).forceApprove(spender, 0);\r\n            IERC20(token).forceApprove(spender, type(uint256).max);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Emits the consolidated split-swap execution event.\r\n     * @dev    Packs the essential split data into a single event for off-chain indexing/analytics.\r\n     * @param  r       Split result struct (modules, tokens, totals).\r\n     * @param  user    Original caller (initiator).\r\n     * @param  to      Final receiver of the swapped tokens/ETH.\r\n     * @param  bpsA    Portion routed through module A, in percent (0\u2013100).\r\n     */\r\n    function _emitSwapSplit(\r\n        SplitResult memory r,\r\n        address user,\r\n        address to,\r\n        uint16 bpsA\r\n    ) internal {\r\n        emit SwapSplitExecuted(\r\n            user,\r\n            to,\r\n            r.moduleA,\r\n            r.moduleB,\r\n            r.tokenIn,\r\n            r.tokenOut,\r\n            r.totalIn,\r\n            r.totalOut,\r\n            bpsA\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Decodes a route payload (in memory) into a typed struct used by the router.\r\n     * @dev    Expects payload encoded as:\r\n     *         (address module, uint256 index, uint256 quoted, address tokenIn, address tokenOut, uint256 amountIn, bytes[] route)\r\n     * @param  payload ABI-encoded payload stored in memory.\r\n     * @return d       Decoded LegDecoded struct.\r\n     */\r\n    function _decodeRouteStruct(bytes memory payload)\r\n        internal\r\n        pure\r\n        returns (LegDecoded memory d)\r\n    {\r\n        (d.module, d.index, d.quoted, d.tokenIn, d.tokenOut, d.amountIn, d.route) =\r\n            abi.decode(payload, (address, uint256, uint256, address, address, uint256, bytes[]));\r\n    }\r\n\r\n    /**\r\n     * @notice Decodes a route payload (in calldata) into a typed struct used by the router.\r\n     * @dev    Same layout as the memory version, but reads directly from calldata to save gas.\r\n     * @param  payload ABI-encoded payload residing in calldata.\r\n     * @return d       Decoded LegDecoded struct.\r\n     */\r\n    function _decodeRouteStructCallData(bytes calldata payload)\r\n        internal\r\n        pure\r\n        returns (LegDecoded memory d)\r\n    {\r\n        (d.module, d.index, d.quoted, d.tokenIn, d.tokenOut, d.amountIn, d.route) =\r\n            abi.decode(payload, (address, uint256, uint256, address, address, uint256, bytes[]));\r\n    }\r\n\r\n    /**\r\n     * @notice Distribution of commissions and ERC20 transfer.\r\n     * @dev    Retains fix-fee (feeBpsSwap) and % of positive slippage (feeBpsPositive).\r\n     * @param  token        ERC20 address.\r\n     * @param  to           Recipient.\r\n     * @param  grossOut     Actual output after swap(s).\r\n     * @param  quotedOut    Quote (expectation).\r\n     * @param  minOut       Minimum acceptable output.\r\n     * @return netOut       Amount after commissions.\r\n     */\r\n    function _distributeTokenWithFees(\r\n        address token,\r\n        address to,\r\n        uint256 grossOut,         // actual output after swap(s)\r\n        uint256 quotedOut,        // quoted (expected) output\r\n        uint256 minOut\r\n    ) internal returns (uint256 netOut) {\r\n        if (grossOut == 0) return 0;\r\n\r\n        uint256 baseline = quotedOut > minOut ? quotedOut : minOut;\r\n\r\n        uint256 feeSwap = 0;\r\n        uint256 feePos  = 0;\r\n\r\n        // take fees only if recipient is set and bps > 0\r\n        if (feeRecipient != address(0)) {\r\n            if (feeBpsSwap > 0) {\r\n                unchecked { feeSwap = (grossOut * feeBpsSwap) / 10_000; }\r\n            }\r\n            if (feeBpsPositive > 0 && grossOut > baseline) {\r\n                unchecked { feePos = ((grossOut - baseline) * feeBpsPositive) / 10_000; }\r\n            }\r\n        }\r\n\r\n        uint256 totalFee = feeSwap + feePos;\r\n        // safety guard against overflow/rounding:\r\n        if (totalFee > grossOut) totalFee = grossOut;\r\n\r\n        netOut = grossOut - totalFee;\r\n\r\n        // Payouts: send fee to feeRecipient first, then net to user\r\n        if (totalFee > 0) {\r\n            IERC20(token).safeTransfer(feeRecipient, totalFee);\r\n        }\r\n        IERC20(token).safeTransfer(to, netOut);\r\n    }\r\n\r\n    /**\r\n     * @notice Distribution of fees and transfer of ETH.\r\n     * @dev    Similar      to _distributeTokenWithFees, but for ETH.\r\n     * @param  to           Recipient.\r\n     * @param  grossEth     Actual ETH output.\r\n     * @param  quotedOutEth Expected output.\r\n     * @param  minOutEth    Minimum allowable output.\r\n     * @return netOut       Amount after fees.\r\n     */\r\n    function _distributeETHWithFees(\r\n        address to,\r\n        uint256 grossEth,         // actual ETH output\r\n        uint256 quotedOutEth,     // expected output (WETH==ETH)\r\n        uint256 minOutEth\r\n    ) internal returns (uint256 netOut) {\r\n        if (grossEth == 0) return 0;\r\n\r\n        uint256 baseline = quotedOutEth > minOutEth ? quotedOutEth : minOutEth;\r\n\r\n        uint256 feeSwap = 0;\r\n        uint256 feePos  = 0;\r\n\r\n        if (feeRecipient != address(0)) {\r\n            if (feeBpsSwap > 0) {\r\n                unchecked { feeSwap = (grossEth * feeBpsSwap) / 10_000; }\r\n            }\r\n            if (feeBpsPositive > 0 && grossEth > baseline) {\r\n                unchecked { feePos = ((grossEth - baseline) * feeBpsPositive) / 10_000; }\r\n            }\r\n        }\r\n\r\n        uint256 totalFee = feeSwap + feePos;\r\n        if (totalFee > grossEth) totalFee = grossEth;\r\n\r\n        netOut = grossEth - totalFee;\r\n\r\n        if (totalFee > 0) {\r\n            (bool fs, ) = feeRecipient.call{value: totalFee}(\"\");\r\n            require(fs, \"fee ETH xfer failed\");\r\n        }\r\n        (bool ok, ) = to.call{value: netOut}(\"\");\r\n        require(ok, \"ETH xfer failed\");\r\n    }\r\n\r\n    /**\r\n     * @notice Safely reads the balance and allowance of a token for a pair (wallet, spender).\r\n     * @dev For address(0), we treat it as ETH: we return the ETH balance of the wallet and allowance = 0.\r\n     * Uses low-level staticcall to handle non-standard ERC-20 tokens (e.g., USDT).\r\n     */\r\n    function _safeBalanceAndAllowance(\r\n        address token,\r\n        address wallet,\r\n        address spender\r\n    ) internal view returns (uint256 bal, uint256 allow_) {\r\n        if (token == address(0)) {\r\n            // ETH: allowance not applicable\r\n            return (wallet.balance, 0);\r\n        }\r\n\r\n        // balanceOf(wallet)\r\n        (bool ok1, bytes memory data1) =\r\n            token.staticcall(abi.encodeWithSelector(IERC20.balanceOf.selector, wallet));\r\n        if (ok1 && data1.length >= 32) {\r\n            bal = abi.decode(data1, (uint256));\r\n        } else {\r\n            bal = 0;\r\n        }\r\n\r\n        // allowance(wallet, spender)\r\n        (bool ok2, bytes memory data2) =\r\n            token.staticcall(abi.encodeWithSelector(IERC20.allowance.selector, wallet, spender));\r\n        if (ok2 && data2.length >= 32) {\r\n            allow_ = abi.decode(data2, (uint256));\r\n        } else {\r\n            allow_ = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the price of 1 token in USD (normalized to 1e18) via Chainlink Feed Registry.\r\n     * @dev    Does not check for data \u201cfreshness\u201d and does not revert.\r\n     *         ETH is passed as address(0) and mapped internally to Chainlink DENOM_ETH.\r\n     * @param  token     Token address (or address(0) for ETH).\r\n     * @param  asEth     If true, use the ETH/USD price (e.g., for WETH, stETH, etc.).\r\n     * @return price1e18 The price of 1 token in USD (1e18).\r\n     * @return updatedAt The time of the last feed update.\r\n     */\r\n    function _tryTokenUsdPrice1e18(address token, bool asEth)\r\n        internal\r\n        view\r\n        returns (uint256 price1e18, uint256 updatedAt)\r\n    {\r\n        address reg = feedRegistry;\r\n        if (reg == address(0)) return (0, 0);\r\n\r\n        address base = asEth\r\n            ? DENOM_ETH\r\n            : (token == address(0) ? DENOM_ETH : token);\r\n\r\n        // latestRoundData may throw an error, but as a rule, it works fine on mainnet for known tokens.\r\n        ( , int256 answer, , uint256 upd, ) = IFeedRegistry(reg).latestRoundData(base, DENOM_USD);\r\n        if (answer <= 0) return (0, upd);\r\n\r\n        uint8 pdec = IFeedRegistry(reg).decimals(base, DENOM_USD);\r\n        uint256 u = uint256(answer);\r\n\r\n        // Normalization to 1e18\r\n        if (pdec < 18)      price1e18 = u * 10 ** (18 - pdec);\r\n        else if (pdec > 18) price1e18 = u / 10 ** (pdec - 18);\r\n        else                price1e18 = u;\r\n\r\n        return (price1e18, upd);\r\n    }\r\n\r\n    /* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Read \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n\r\n    /**\r\n     * @notice Reads token\u2192USD price (1e18) via Chainlink Feed Registry without checking \u201cfreshness\u201d.\r\n     * @dev    Returns 0 if the feed is missing or `answer <= 0`. ETH is passed as address(0).\r\n     * @param  token           Token address (or address(0) for ETH).\r\n     * @param  asEth           If true, use ETH/USD price (for WETH, stETH, etc.).\r\n     * @return usdPerToken1e18 Token price in USD (1e18) or 0.\r\n     * @return updatedAt       Time of the last feed update.\r\n     */\r\n    function tryTokenUsdPrice1e18(address token, bool asEth)\r\n        external\r\n        view\r\n        returns (uint256 usdPerToken1e18, uint256 updatedAt)\r\n    {\r\n        (usdPerToken1e18, updatedAt) = _tryTokenUsdPrice1e18(token, asEth);\r\n        return (usdPerToken1e18, updatedAt);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the balance of `wallet` in `token` and the allowance of this token for `spender`.\r\n     * @param  token           ERC-20 token address (or address(0) for ETH)\r\n     * @param  wallet          address of the owner of the funds\r\n     * @param  spender         address of the contract for which we are checking the allowance\r\n     * @return balance         wallet balance in token (or ETH balance if token==address(0))\r\n     * @return allowance_      current token allowance for spender\r\n     */\r\n    function balanceAndAllowanceOf(\r\n        address token,\r\n        address wallet,\r\n        address spender\r\n    ) external view returns (uint256 balance, uint256 allowance_) {\r\n        (balance, allowance_) = _safeBalanceAndAllowance(token, wallet, spender);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns (balance, allowance) and the price of 1 token in USD (1e18) without a validity flag.\r\n     * @dev    ETH = address(0). The price is taken from Chainlink Feed Registry/_tryTokenUsdPrice1e18.\r\n     * @param  token           ERC-20 token address (or address(0) for ETH)\r\n     * @param  wallet          Address of the owner of the funds\r\n     * @param  spender         Address of the contract for which we are checking the assignment\r\n     * @param  asEth           If true, force the ETH/USD price (for WETH, stETH, etc.)\r\n     * @return balance         Wallet balance in tokens (or ETH if token==address(0))\r\n     * @return allowance_      Token allowance for spender (0 for ETH)\r\n     * @return usdPerToken1e18 Price of 1 token in USD (1e18), 0 if no feed/answer<=0\r\n     * @return updatedAt       Last price update in Chainlink\r\n     */\r\n    function balanceAllowanceAndUsd(\r\n        address token,\r\n        address wallet,\r\n        address spender, \r\n        bool    asEth\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256 balance,\r\n            uint256 allowance_,\r\n            uint256 usdPerToken1e18,\r\n            uint256 updatedAt\r\n        )\r\n    {\r\n        // 1) safely read balance/allowance (do not revert to non-standard ERC-20)\r\n        (balance, allowance_) = _safeBalanceAndAllowance(token, wallet, spender);\r\n\r\n        // 2) Let's try to get the price in USD (gently, without revert)\r\n        (usdPerToken1e18, updatedAt) = _tryTokenUsdPrice1e18(token, asEth);\r\n    }\r\n\r\n    /**\r\n     * @notice Return the 4 best routes (Top-1/Top-2 for 1-hop and 2-hop) and (optionally) the optimal split of the two absolute leaders.\r\n     * @param  tokenIn            Input token.\r\n     * @param  tokenOut           Output token.\r\n     * @param  amountIn           Input amount.\r\n     * @return best1HopRouteTop1  Payload of the best 1-hop.\r\n     * @return amountOut1HopTop1  Quote of the best 1-hop.\r\n     * @return best2HopRouteTop1  Payload of the best 2-hop.\r\n     * @return amountOut2HopTop1  Quote for the best 2-hop.\r\n     * @return best1HopRouteTop2  Payload of the second 1-hop.\r\n     * @return amountOut1HopTop2  Quote for the second 1-hop.\r\n     * @return best2HopRouteTop2  Payload of the second 2-hop.\r\n     * @return amountOut2HopTop2  Quote for the second 2-hop.\r\n     * @return splitAmountOut     Best split quote between two absolute tops (0 if split does not improve).\r\n     * @return splitPercentA      Share for route A (in percent, 0\u2013100) for split (0 if split is not applicable).\r\n     */\r\n    function getBestRoute(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountIn\r\n    ) external view returns (\r\n        bytes memory best1HopRouteTop1, uint256 amountOut1HopTop1,\r\n        bytes memory best2HopRouteTop1, uint256 amountOut2HopTop1,\r\n        bytes memory best1HopRouteTop2, uint256 amountOut1HopTop2,\r\n        bytes memory best2HopRouteTop2, uint256 amountOut2HopTop2,\r\n        uint256 splitAmountOut, uint16 splitPercentA\r\n    ) {\r\n        QuoteArgs memory qa = QuoteArgs({\r\n            tokenIn: tokenIn,\r\n            tokenOut: tokenOut,\r\n            amountIn: amountIn\r\n        });\r\n\r\n        BestQuotes memory best; \r\n        TrackedRoute memory top1Overall; // Absolute best route\r\n        TrackedRoute memory top2Overall; // Second best route\r\n\r\n        for (uint256 i = 0; i < modules.length; ) {\r\n            ModuleQuotes memory quotes = _getModuleQuotes(modules[i], i, qa);\r\n\r\n            if (quotes.amountOut1Hop > 0) {\r\n                TrackedRoute memory r1 = TrackedRoute({\r\n                    payload: quotes.payload1Hop,\r\n                    amountOut: quotes.amountOut1Hop,\r\n                    module: quotes.module,\r\n                    moduleIndex: quotes.moduleIndex\r\n                });\r\n                _updateBestQuotes(best, r1, true); \r\n                (top1Overall, top2Overall) = _updateTopOverall(top1Overall, top2Overall, r1);\r\n            }\r\n\r\n            if (quotes.amountOut2Hop > 0) {\r\n                TrackedRoute memory r2 = TrackedRoute({\r\n                    payload: quotes.payload2Hop,\r\n                    amountOut: quotes.amountOut2Hop,\r\n                    module: quotes.module,\r\n                    moduleIndex: quotes.moduleIndex\r\n                });\r\n                _updateBestQuotes(best, r2, false); \r\n                (top1Overall, top2Overall) = _updateTopOverall(top1Overall, top2Overall, r2);\r\n            }\r\n\r\n            unchecked { ++i; }\r\n        }\r\n\r\n        if (top1Overall.amountOut == 0) revert NoRouteFound();\r\n\r\n        // Return the standard 8 fields\r\n        best1HopRouteTop1 = best.top1Hop.payload; amountOut1HopTop1 = best.top1Hop.amountOut;\r\n        best2HopRouteTop1 = best.top2Hop.payload; amountOut2HopTop1 = best.top2Hop.amountOut;\r\n        best1HopRouteTop2 = best.second1Hop.payload; amountOut1HopTop2 = best.second1Hop.amountOut;\r\n        best2HopRouteTop2 = best.second2Hop.payload; amountOut2HopTop2 = best.second2Hop.amountOut;\r\n\r\n        // Compute split between the two overall best routes (T1 and T2)\r\n        if (top2Overall.amountOut > 0 && keccak256(top1Overall.payload) != keccak256(top2Overall.payload)) {\r\n            (splitAmountOut, splitPercentA) = findBestSplit(\r\n                top1Overall.payload, \r\n                top2Overall.payload\r\n            );\r\n            \r\n            // If split provides no improvement, do not return it,\r\n            // since the best will be either T1 or T2 (T1.amountOut >= T2.amountOut).\r\n            if (splitAmountOut <= top1Overall.amountOut) {\r\n                 splitAmountOut = 0;\r\n                 splitPercentA = 0;\r\n            }\r\n        } else {\r\n            // If only one route found, or T1 == T2, split is not applicable\r\n            splitAmountOut = 0;\r\n            splitPercentA = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Return the 4 best routes (Top-1/Top-2 for 1-hop and 2-hop) and (optionally) the optimal split of the two absolute leaders.\r\n     * @param  tokenIn            Input token.\r\n     * @param  tokenOut           Output token.\r\n     * @param  amountIn           Input amount.\r\n     * @param  wallet             address of the owner of the funds\r\n     * @param  spender            address of the contract for which we are checking the allowance\r\n     * @param  asEthIn            If true \u2014 use the ETH/USD price for tokenIn (ignoring its own feed)\r\n     * @param  asEthOut           If true \u2014 use the ETH/USD price for tokenOut (ignoring its own feed)\r\n     * @return best1HopRouteTop1  Payload of the best 1-hop.\r\n     * @return amountOut1HopTop1  Quote of the best 1-hop.\r\n     * @return best2HopRouteTop1  Payload of the best 2-hop.\r\n     * @return amountOut2HopTop1  Quote for the best 2-hop.\r\n     * @return best1HopRouteTop2  Payload of the second 1-hop.\r\n     * @return amountOut1HopTop2  Quote for the second 1-hop.\r\n     * @return best2HopRouteTop2  Payload of the second 2-hop.\r\n     * @return amountOut2HopTop2  Quote for the second 2-hop.\r\n     * @return splitAmountOut     Best split quote between two absolute tops (0 if split does not improve).\r\n     * @return splitPercentA      Share for route A (in percent, 0\u2013100) for split (0 if split is not applicable).\r\n     * @return balance            wallet balance in tokens (ETH, if token==address(0))\r\n     * @return allowance_         token allowance for spender (0 for ETH)\r\n     * @return usdPerToken1e18In  price of 1 token in USD, normalized to 1e18 (0 if hasUsd=false)\r\n     * @return updatedAtIn        time of the last price update from Chainlink\r\n     * @return usdPerToken1e18Out price of 1 token in USD, normalized to 1e18 (0 if hasUsd=false)\r\n     * @return updatedAtOut time  of the last price update from Chainlink\r\n     */\r\n    function getBestRouteSuper(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountIn,\r\n        address wallet,\r\n        address spender,\r\n        bool    asEthIn,\r\n        bool    asEthOut\r\n    ) external view returns (\r\n        bytes memory best1HopRouteTop1, uint256 amountOut1HopTop1,\r\n        bytes memory best2HopRouteTop1, uint256 amountOut2HopTop1,\r\n        bytes memory best1HopRouteTop2, uint256 amountOut1HopTop2,\r\n        bytes memory best2HopRouteTop2, uint256 amountOut2HopTop2,\r\n        uint256 splitAmountOut, uint16 splitPercentA,\r\n\r\n        uint256 balance,\r\n        uint256 allowance_,\r\n\r\n        uint256 usdPerToken1e18In, uint256 updatedAtIn,\r\n        uint256 usdPerToken1e18Out, uint256 updatedAtOut\r\n    ) {\r\n        QuoteArgs memory qa = QuoteArgs({\r\n            tokenIn: tokenIn,\r\n            tokenOut: tokenOut,\r\n            amountIn: amountIn\r\n        });\r\n\r\n        BestQuotes memory best; \r\n        TrackedRoute memory top1Overall; // Absolute best route\r\n        TrackedRoute memory top2Overall; // Second best route\r\n\r\n        for (uint256 i = 0; i < modules.length; ) {\r\n            ModuleQuotes memory quotes = _getModuleQuotes(modules[i], i, qa);\r\n\r\n            if (quotes.amountOut1Hop > 0) {\r\n                TrackedRoute memory r1 = TrackedRoute({\r\n                    payload: quotes.payload1Hop,\r\n                    amountOut: quotes.amountOut1Hop,\r\n                    module: quotes.module,\r\n                    moduleIndex: quotes.moduleIndex\r\n                });\r\n                _updateBestQuotes(best, r1, true); \r\n                (top1Overall, top2Overall) = _updateTopOverall(top1Overall, top2Overall, r1);\r\n            }\r\n\r\n            if (quotes.amountOut2Hop > 0) {\r\n                TrackedRoute memory r2 = TrackedRoute({\r\n                    payload: quotes.payload2Hop,\r\n                    amountOut: quotes.amountOut2Hop,\r\n                    module: quotes.module,\r\n                    moduleIndex: quotes.moduleIndex\r\n                });\r\n                _updateBestQuotes(best, r2, false); \r\n                (top1Overall, top2Overall) = _updateTopOverall(top1Overall, top2Overall, r2);\r\n            }\r\n\r\n            unchecked { ++i; }\r\n        }\r\n\r\n        if (top1Overall.amountOut == 0) revert NoRouteFound();\r\n\r\n        // Return the standard 8 fields\r\n        best1HopRouteTop1 = best.top1Hop.payload; amountOut1HopTop1 = best.top1Hop.amountOut;\r\n        best2HopRouteTop1 = best.top2Hop.payload; amountOut2HopTop1 = best.top2Hop.amountOut;\r\n        best1HopRouteTop2 = best.second1Hop.payload; amountOut1HopTop2 = best.second1Hop.amountOut;\r\n        best2HopRouteTop2 = best.second2Hop.payload; amountOut2HopTop2 = best.second2Hop.amountOut;\r\n\r\n        // Compute split between the two overall best routes (T1 and T2)\r\n        if (top2Overall.amountOut > 0 && keccak256(top1Overall.payload) != keccak256(top2Overall.payload)) {\r\n            (splitAmountOut, splitPercentA) = findBestSplit(\r\n                top1Overall.payload, \r\n                top2Overall.payload\r\n            );\r\n            \r\n            // If split provides no improvement, do not return it,\r\n            // since the best will be either T1 or T2 (T1.amountOut >= T2.amountOut).\r\n            if (splitAmountOut <= top1Overall.amountOut) {\r\n                 splitAmountOut = 0;\r\n                 splitPercentA = 0;\r\n            }\r\n        } else {\r\n            // If only one route found, or T1 == T2, split is not applicable\r\n            splitAmountOut = 0;\r\n            splitPercentA = 0;\r\n        }\r\n\r\n        // safely read balance/allowance (do not revert on non-standard ERC-20)\r\n        (balance, allowance_) = _safeBalanceAndAllowance(tokenIn, wallet, spender);\r\n\r\n        // Let's try to get the price in USD (gently, without revert)\r\n        (usdPerToken1e18In, updatedAtIn)   = _tryTokenUsdPrice1e18(tokenIn, asEthIn);\r\n        (usdPerToken1e18Out, updatedAtOut) = _tryTokenUsdPrice1e18(tokenOut, asEthOut);\r\n    }\r\n\r\n    /**\r\n     * @notice Find the best split ratio between two route payloads.\r\n     * @dev    Discrete search by simulateRoute + local fine-tuning.\r\n     * @param  payloadA          Route A.\r\n     * @param  payloadB          Route B.\r\n     * @return bestAmountOut     Best total quote.\r\n     * @return bestPercentA      Share of A (0\u2013100) giving the maximum.\r\n     */\r\n    function findBestSplit(\r\n        bytes memory payloadA, // \u0418\u0417\u041c\u0415\u041d\u0415\u041d\u0418\u0415: bytes memory\r\n        bytes memory payloadB\r\n    )\r\n        internal \r\n        view\r\n        returns (\r\n            uint256 bestAmountOut,\r\n            uint16 bestPercentA\r\n        )\r\n    {\r\n        // Decode and verify\r\n        LegDecoded memory A = _decodeRouteStruct(payloadA);\r\n        LegDecoded memory B = _decodeRouteStruct(payloadB);\r\n\r\n        require(A.amountIn > 0 && B.amountIn > 0, \"UR: zero amounts\");\r\n        require(A.tokenIn == B.tokenIn, \"UR: in mismatch\");\r\n        require(A.tokenOut == B.tokenOut, \"UR: out mismatch\");\r\n        require(A.amountIn == B.amountIn, \"UR: totalIn mismatch\"); \r\n\r\n        address moduleA = A.module;\r\n        address moduleB = B.module;\r\n        \r\n        // --- Step 1: Initialization (50%) ---\r\n        uint16 initialPercent = 50; // 50%\r\n        \r\n        uint256 currentMaxOut = _calculateTotalOut(\r\n            moduleA, A.route, moduleB, B.route, initialPercent\r\n        );\r\n        uint16 currentBestPercent = initialPercent;\r\n\r\n        // --- Step 2: Main sparse search: 10% to 90% in 10% increments ---\r\n        // Check 10, 20, 30, 40, 60, 70, 80, 90. (50% already checked).\r\n        for (uint16 percent = 10; percent <= 90; percent += 10) {\r\n            if (percent == 50) continue; \r\n\r\n            uint256 totalOut = _calculateTotalOut(\r\n                moduleA, A.route, moduleB, B.route, percent\r\n            );\r\n\r\n            if (totalOut > currentMaxOut) {\r\n                currentMaxOut = totalOut;\r\n                currentBestPercent = percent;\r\n            }\r\n        }\r\n        \r\n        // --- Step 3: Refinement (Local search, +/- 5% step) ---\r\n        uint16 bestPercentFound = currentBestPercent;\r\n        \r\n        // Array of offsets for refinement: [-5, +5] Percent\r\n        int16[] memory offsets = new int16[](2);\r\n        offsets[0] = -5; // Checking -5% from the best point\r\n        offsets[1] = 5;  // Checking +5% from the best point\r\n\r\n        for (uint256 i = 0; i < offsets.length; ) {\r\n            int16 offset = offsets[i];\r\n            \r\n            // Protection against values exceeding the limits (e.g., below 1% or above 99%)\r\n            // Condition: bestPercentFound <= 5 (for -5) or bestPercentFound >= 95 (for +5)\r\n            if (\r\n                (offset < 0 && bestPercentFound <= uint16(-offset)) || \r\n                (offset > 0 && bestPercentFound >= 100 - uint16(offset))\r\n            ) {\r\n                 unchecked { ++i; }\r\n                 continue;\r\n            }\r\n            \r\n            uint16 checkPercent;\r\n            if (offset < 0) {\r\n                checkPercent = bestPercentFound - uint16(-offset);\r\n            } else {\r\n                checkPercent = bestPercentFound + uint16(offset);\r\n            }\r\n            \r\n            // Check that the point is within a reasonable range for swap [1, 99]\r\n            if (checkPercent >= 1 && checkPercent <= 99) { \r\n                uint256 totalOut = _calculateTotalOut(\r\n                    moduleA, A.route, moduleB, B.route, checkPercent\r\n                );\r\n\r\n                if (totalOut > currentMaxOut) {\r\n                    currentMaxOut = totalOut;\r\n                    currentBestPercent = checkPercent;\r\n                }\r\n            }\r\n            unchecked { ++i; }\r\n        }\r\n        \r\n        // 4. Return the result\r\n        bestAmountOut = currentMaxOut;\r\n        bestPercentA = currentBestPercent;\r\n    }\r\n\r\n    /**\r\n     * @notice Decodes the route payload.\r\n     * @param  payload ABI-encoded packet.\r\n     * @return module            Module address.\r\n     * @return moduleIndex       Module index.\r\n     * @return quotedOut         Output quote.\r\n     * @return tokenIn           Input token.\r\n     * @return tokenOut          Output token.\r\n     * @return amountIn          Input amount.\r\n     * @return routeData         Route byte hops.\r\n     */\r\n    function decodeRoute(bytes calldata payload)\r\n        public\r\n        pure\r\n        returns (\r\n            address module,\r\n            uint256 moduleIndex,\r\n            uint256 quotedOut,\r\n            address tokenIn,\r\n            address tokenOut,\r\n            uint256 amountIn,\r\n            bytes[] memory routeData\r\n        )\r\n    {\r\n        (module, moduleIndex, quotedOut, tokenIn, tokenOut, amountIn, routeData) =\r\n            abi.decode(payload, (address, uint256, uint256, address, address, uint256, bytes[]));\r\n    }   \r\n\r\n    /* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Swap \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n\r\n    /* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 ROUTE: Token \u2192 Token \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n\r\n    /**\r\n     * @notice Execute a swap based on a pre-prepared payload.\r\n     * @dev    Takes a commission from the swap and positive slippage; checks minAmountOut; transfers the net amount to `to`.\r\n     * @param  payload           ABI-encoded route (see decodeRoute).\r\n     * @param  to                Recipient of the final tokens.\r\n     * @param  minAmountOut      Minimum allowable output.\r\n     * @return netOut            Net amount after commissions are deducted.\r\n     */\r\n    function swapRoute(bytes calldata payload, address to, uint256 minAmountOut)\r\n        external\r\n        nonReentrant\r\n        returns (uint256 netOut)\r\n    {\r\n        require(to != address(0), \"UR: bad to\");\r\n\r\n        (\r\n            address module, , uint256 quotedOut,\r\n            address tokenIn, address tokenOut, uint256 amountIn,\r\n            bytes[] memory routeData\r\n        ) = decodeRoute(payload);\r\n\r\n        require(isModule[module], \"UR: unknown module\");\r\n        require(amountIn > 0, \"UR: zero amountIn\");\r\n        require(routeData.length > 0, \"UR: empty route\");\r\n\r\n        IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\r\n        _smartApprove(tokenIn, module, amountIn);\r\n\r\n        uint256 amountOut = IDexModule(module).swapRoute(DexRoute({ data: routeData }), address(this), 100);\r\n        require(amountOut >= minAmountOut, \"UR: slippage\");\r\n\r\n        // Pay the user minus the fee \u2014 and return immediately\r\n        netOut = _distributeTokenWithFees(tokenOut, to, amountOut, quotedOut, minAmountOut);\r\n\r\n        emit SwapExecuted(module, msg.sender, to, tokenIn, tokenOut, amountIn, netOut, quotedOut);\r\n    }\r\n\r\n    /* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 ROUTE: ETH \u2192 Token \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n\r\n    /**\r\n     * @notice Swap ETH\u2192Token by payload with WETH as tokenIn.\r\n     * @dev    Wraps ETH in WETH, calls the module, holds commissions, sends net amount `to`.\r\n     * @param  payload           Route packet (tokenIn=WETH, amountIn=msg.value).\r\n     * @param  to                Recipient.\r\n     * @param  minAmountOut      Minimum output.\r\n     * @return netOut            Net amount (ERC20).\r\n     */\r\n    function swapRouteExactETHForTokens(\r\n        bytes calldata payload,      // payload with tokenIn == WETH and amountIn == msg.value\r\n        address to,\r\n        uint256 minAmountOut\r\n    ) external payable nonReentrant returns (uint256 netOut) {\r\n        require(to != address(0), \"UR: bad to\");\r\n        require(msg.value > 0, \"UR: no ETH\");\r\n        _requireWethIn(payload);\r\n\r\n        (\r\n            address module, , uint256 quotedOut,\r\n            , address tokenOut, uint256 amountIn,\r\n            bytes[] memory routeData\r\n        ) = decodeRoute(payload);\r\n\r\n        require(isModule[module], \"UR: unknown module\");\r\n        require(routeData.length > 0, \"UR: empty route\");\r\n        require(amountIn == msg.value, \"UR: value != amountIn\");\r\n\r\n        _wrapETH(msg.value);                       // ETH -> WETH\r\n        _smartApprove(WETH, module, msg.value);    // approve\r\n\r\n        // Send to router \u2192 calculate commission \u2192 pay customer\r\n        uint256 amountOut = IDexModule(module).swapRoute(DexRoute({data: routeData}), address(this), 100);\r\n        require(amountOut >= minAmountOut, \"UR: slippage\");\r\n\r\n        netOut = _distributeTokenWithFees(tokenOut, to, amountOut, quotedOut, minAmountOut);\r\n\r\n        emit SwapExecuted(module, msg.sender, to, WETH, tokenOut, amountIn, netOut, quotedOut);\r\n    }\r\n\r\n    /* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 ROUTE: Token \u2192 ETH \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n\r\n    /**\r\n     * @notice Swap Token\u2192ETH by payload with WETH as tokenOut.\r\n     * @dev    Calls the module before WETH, converts to ETH, holds commissions, sends net amount `to`.\r\n     * @param  payload           Route package (tokenOut=WETH).\r\n     * @param  to                ETH recipient.\r\n     * @param  minAmountOut      Minimum output.\r\n     * @return netEthOut         Net amount (ETH).\r\n     */\r\n    function swapRouteExactTokensForETH(\r\n        bytes calldata payload,      // payload: tokenOut == WETH\r\n        address to,\r\n        uint256 minAmountOut\r\n    ) external nonReentrant returns (uint256 netEthOut) {\r\n        require(to != address(0), \"UR: bad to\");\r\n        _requireWethOut(payload);\r\n\r\n        (\r\n            address module, , uint256 quotedOut,\r\n            address tokenIn, , uint256 amountIn,\r\n            bytes[] memory routeData\r\n        ) = decodeRoute(payload);\r\n\r\n        require(isModule[module], \"UR: unknown module\");\r\n        require(amountIn > 0, \"UR: zero in\");\r\n        require(routeData.length > 0, \"UR: empty route\");\r\n\r\n        IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\r\n        _smartApprove(tokenIn, module, amountIn);\r\n\r\n        uint256 outWeth = IDexModule(module).swapRoute(DexRoute({data: routeData}), address(this), 100);\r\n        require(outWeth >= minAmountOut, \"UR: slippage\");\r\n\r\n        // Unwrap and distribute with fees\r\n        _unwrapWETHAndSend(outWeth, address(this));\r\n\r\n        netEthOut = _distributeETHWithFees(to, outWeth, quotedOut, minAmountOut);\r\n\r\n        emit SwapExecuted(module, msg.sender, to, tokenIn, WETH, amountIn, netEthOut, quotedOut);\r\n    }\r\n\r\n    /* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 SPLIT: Token \u2192 Token \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n\r\n    /**\r\n     * @notice Perform a split swap with two token\u2192token routes.\r\n     * @dev    Splits the input by `percentA`/`100-percentA`; checks minAmountOut; holds commissions; forwards the net amount.\r\n     * @param  payloadA          Route A package.\r\n     * @param  payloadB          Route B package.\r\n     * @param  percentA          Share A (1\u201399).\r\n     * @param  minAmountOut      Minimum total output.\r\n     * @param  to                Recipient.\r\n     * @return netOut            Net amount after fees.\r\n     */\r\n    function swapSplit(\r\n        bytes calldata payloadA,\r\n        bytes calldata payloadB,\r\n        uint16 percentA,\r\n        uint256 minAmountOut,\r\n        address to\r\n    ) external nonReentrant returns (uint256 netOut) {       \r\n        // Decode and verify\r\n        LegDecoded memory A = _decodeRouteStructCallData(payloadA);\r\n        LegDecoded memory B = _decodeRouteStructCallData(payloadB);\r\n        \r\n        require(A.amountIn > 0 && B.amountIn > 0, \"UR: zero amounts\");\r\n        require(A.tokenIn == B.tokenIn, \"UR: in mismatch\");\r\n        require(A.tokenOut == B.tokenOut, \"UR: out mismatch\");\r\n        require(A.amountIn == B.amountIn, \"UR: totalIn mismatch\");\r\n        require(A.route.length > 0 && B.route.length > 0, \"UR: empty route\");\r\n        require(percentA >= 1 && percentA <= 99, \"UR: percent out of bounds\");\r\n        require(isModule[A.module]);\r\n        require(isModule[B.module]);\r\n\r\n        IERC20(A.tokenIn).safeTransferFrom(msg.sender, address(this), A.amountIn); // if A.amountIn equals B.amountIn\r\n        \r\n        _smartApprove(A.tokenIn, A.module, A.amountIn);\r\n        _smartApprove(A.tokenIn, B.module, B.amountIn);\r\n        \r\n        // Perform swaps (call modules)\r\n\r\n        // Route A (percentA)\r\n        // IDexModule.swapRoute passes a percentage (0-100), and the module\r\n        // must internally calculate the exact amountIn for this part of the swap.\r\n        uint256 outA = IDexModule(A.module).swapRoute(\r\n            DexRoute({ data: A.route }), \r\n            address(this), \r\n            percentA\r\n        );\r\n\r\n        // Route B (100 - percentA)\r\n        uint256 outB = IDexModule(B.module).swapRoute(\r\n            DexRoute({ data: B.route }), \r\n            address(this), \r\n            uint16(100 - percentA)\r\n        );\r\n\r\n        // Slip check and return\r\n        require((outA + outB) >= minAmountOut, \"UR: slippage\");\r\n\r\n        uint256 quotedTotal = (A.quoted * percentA) / 100 + (B.quoted * (uint16(100 - percentA))) / 100;\r\n\r\n        // Commission + payment to user\r\n        netOut = _distributeTokenWithFees(A.tokenOut, to, outA + outB, quotedTotal, minAmountOut);\r\n\r\n        SplitResult memory r = SplitResult({\r\n            moduleA: A.module,\r\n            moduleB: B.module,\r\n            tokenIn: A.tokenIn,\r\n            tokenOut: A.tokenOut,\r\n            totalIn: A.amountIn,\r\n            amountInA: (A.amountIn * percentA) / 100,\r\n            amountInB: (B.amountIn * (uint16(100 - percentA))) / 100,\r\n            outA: outA,\r\n            outB: outB,\r\n            totalOut: outA + outB\r\n        });\r\n        _emitSwapSplit(r, msg.sender, to, percentA);\r\n    }\r\n\r\n    /* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 SPLIT: ETH \u2192 Token \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n\r\n    /**\r\n     * @notice Split-swap ETH\u2192Token via two routes (both via WETH).\r\n     * @dev    Converts ETH to WETH; splits input by percentage; holds fees; transfers net amount `to`.\r\n     * @param  payloadA          Package A (tokenIn=WETH, amountIn=msg.value).\r\n     * @param  payloadB          Package B.\r\n     * @param  percentA          Share A (1\u201399).\r\n     * @param  minTotalOut       Minimum total output.\r\n     * @param  to                Recipient.\r\n     * @return netOut            Net result (ERC20).\r\n     */\r\n    function swapSplitExactETHForTokens(\r\n        bytes calldata payloadA,     // both: tokenIn == WETH, amountIn == msg.value\r\n        bytes calldata payloadB,\r\n        uint16 percentA,             // 1..99\r\n        uint256 minTotalOut,\r\n        address to\r\n    ) external payable nonReentrant returns (uint256 netOut) {\r\n        require(to != address(0), \"UR: bad to\");\r\n        require(msg.value > 0, \"UR: no ETH\");\r\n        require(percentA >= 1 && percentA <= 99, \"UR: percent out of bounds\");\r\n\r\n        _requireWethIn(payloadA);\r\n        _requireWethIn(payloadB);\r\n\r\n        LegDecoded memory A = _decodeRouteStructCallData(payloadA);\r\n        LegDecoded memory B = _decodeRouteStructCallData(payloadB);\r\n        require(A.amountIn == B.amountIn, \"UR: split amount mismatch\");\r\n        require(A.amountIn == msg.value, \"UR: value != amountIn\");\r\n        require(A.tokenOut == B.tokenOut, \"UR: out mismatch\");\r\n        require(A.route.length > 0 && B.route.length > 0, \"UR: empty route\");\r\n        require(isModule[A.module]);\r\n        require(isModule[B.module]);\r\n\r\n        _wrapETH(msg.value);\r\n        _smartApprove(WETH, A.module, msg.value);\r\n        _smartApprove(WETH, B.module, msg.value);\r\n\r\n        uint16 percentB = uint16(100 - percentA);\r\n\r\n        // Route execution \u2192 fees \u2192 recipient\r\n        uint256 outA = IDexModule(A.module).swapRoute(DexRoute({data: A.route}), address(this), percentA);\r\n        uint256 outB = IDexModule(B.module).swapRoute(DexRoute({data: B.route}), address(this), percentB);\r\n\r\n        uint256 grossOut = outA + outB;\r\n        require(grossOut >= minTotalOut, \"UR: slippage\");\r\n\r\n        uint256 quotedTotal = (A.quoted * percentA) / 100 + (B.quoted * percentB) / 100;\r\n\r\n        netOut = _distributeTokenWithFees(A.tokenOut, to, grossOut, quotedTotal, minTotalOut);\r\n\r\n        SplitResult memory r = SplitResult({\r\n            moduleA: A.module,\r\n            moduleB: B.module,\r\n            tokenIn: WETH,\r\n            tokenOut: A.tokenOut,\r\n            totalIn: msg.value,\r\n            amountInA: (uint256(msg.value) * percentA) / 100,\r\n            amountInB: (uint256(msg.value) * percentB) / 100,\r\n            outA: outA,\r\n            outB: outB,\r\n            totalOut: grossOut\r\n        });\r\n        _emitSwapSplit(r, msg.sender, to, percentA);\r\n    }\r\n\r\n    /* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 SPLIT: Token \u2192 ETH \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n\r\n    /**\r\n     * @notice Split-swap Token\u2192ETH via two routes (both ending in WETH).\r\n     * @dev    Splits input by percentage; converts WETH\u2192ETH; holds fees; transfers net amount `to`.\r\n     * @param  payloadA          Package A (tokenOut=WETH).\r\n     * @param  payloadB          Package B.\r\n     * @param  percentA          Share A (1\u201399).\r\n     * @param  minTotalEthOut    Minimum total output in ETH.\r\n     * @param  to                ETH recipient.\r\n     * @return netEthOut         Net result (ETH).\r\n     */\r\n    function swapSplitExactTokensForETH(\r\n        bytes calldata payloadA,     // both: tokenOut == WETH, same amountIn\r\n        bytes calldata payloadB,\r\n        uint16 percentA,             // 1..99\r\n        uint256 minTotalEthOut,\r\n        address to\r\n    ) external nonReentrant returns (uint256 netEthOut) {\r\n        require(to != address(0), \"UR: bad to\");\r\n        require(percentA >= 1 && percentA <= 99, \"UR: percent out of bounds\");\r\n\r\n        _requireWethOut(payloadA);\r\n        _requireWethOut(payloadB);\r\n\r\n        LegDecoded memory A = _decodeRouteStructCallData(payloadA);\r\n        LegDecoded memory B = _decodeRouteStructCallData(payloadB);\r\n        require(A.amountIn > 0 && B.amountIn > 0, \"UR: zero in\");\r\n        require(A.amountIn == B.amountIn, \"UR: split amount mismatch\");\r\n        require(A.tokenIn == B.tokenIn, \"UR: in mismatch\");\r\n        require(A.route.length > 0 && B.route.length > 0, \"UR: empty route\");\r\n        require(isModule[A.module]);\r\n        require(isModule[B.module]);\r\n\r\n        IERC20(A.tokenIn).safeTransferFrom(msg.sender, address(this), A.amountIn);\r\n        _smartApprove(A.tokenIn, A.module, A.amountIn);\r\n        _smartApprove(A.tokenIn, B.module, B.amountIn);\r\n\r\n        uint16 percentB = uint16(100 - percentA);\r\n\r\n        uint256 outA = IDexModule(A.module).swapRoute(DexRoute({data: A.route}), address(this), percentA);\r\n        uint256 outB = IDexModule(B.module).swapRoute(DexRoute({data: B.route}), address(this), percentB);\r\n\r\n        uint256 totalWeth = outA + outB;\r\n        require(totalWeth >= minTotalEthOut, \"UR: slippage\");\r\n\r\n        uint256 quotedTotal = (A.quoted * percentA) / 100 + (B.quoted * percentB) / 100;\r\n\r\n        _unwrapWETHAndSend(totalWeth, address(this));\r\n        netEthOut = _distributeETHWithFees(to, totalWeth, quotedTotal, minTotalEthOut);\r\n\r\n        SplitResult memory r = SplitResult({\r\n            moduleA: A.module,\r\n            moduleB: B.module,\r\n            tokenIn: A.tokenIn,\r\n            tokenOut: WETH,\r\n            totalIn: A.amountIn,\r\n            amountInA: (A.amountIn * percentA) / 100,\r\n            amountInB: (B.amountIn * percentB) / 100,\r\n            outA: outA,\r\n            outB: outB,\r\n            totalOut: totalWeth\r\n        });\r\n        _emitSwapSplit(r, msg.sender, to, percentA);\r\n    }\r\n}"}, "@openzeppelin/contracts/security/ReentrancyGuard.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"}, "@openzeppelin/contracts/access/Ownable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.30;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"}, "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"}, "@openzeppelin/contracts/token/ERC20/IERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"}, "@openzeppelin/contracts/interfaces/IERC1363.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"}, "@openzeppelin/contracts/utils/Context.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"}, "@openzeppelin/contracts/interfaces/IERC165.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.30;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"}, "@openzeppelin/contracts/interfaces/IERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"}, "@openzeppelin/contracts/utils/introspection/IERC165.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"}}}