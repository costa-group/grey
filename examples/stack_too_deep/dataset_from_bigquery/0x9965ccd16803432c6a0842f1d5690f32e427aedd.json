{"language": "Solidity", "sources": {"@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool success);\n}\n"}, "@chainlink/contracts/src/v0.8/interfaces/VRFV2WrapperInterface.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface VRFV2WrapperInterface {\n  /**\n   * @return the request ID of the most recent VRF V2 request made by this wrapper. This should only\n   * be relied option within the same transaction that the request was made.\n   */\n  function lastRequestId() external view returns (uint256);\n\n  /**\n   * @notice Calculates the price of a VRF request with the given callbackGasLimit at the current\n   * @notice block.\n   *\n   * @dev This function relies on the transaction gas price which is not automatically set during\n   * @dev simulation. To estimate the price at a specific gas price, use the estimatePrice function.\n   *\n   * @param _callbackGasLimit is the gas limit used to estimate the price.\n   */\n  function calculateRequestPrice(uint32 _callbackGasLimit) external view returns (uint256);\n\n  /**\n   * @notice Estimates the price of a VRF request with a specific gas limit and gas price.\n   *\n   * @dev This is a convenience function that can be called in simulation to better understand\n   * @dev pricing.\n   *\n   * @param _callbackGasLimit is the gas limit used to estimate the price.\n   * @param _requestGasPriceWei is the gas price in wei used for the estimation.\n   */\n  function estimateRequestPrice(uint32 _callbackGasLimit, uint256 _requestGasPriceWei) external view returns (uint256);\n}\n"}, "@chainlink/contracts/src/v0.8/VRFV2WrapperConsumerBase.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"./interfaces/LinkTokenInterface.sol\";\nimport \"./interfaces/VRFV2WrapperInterface.sol\";\n\n/** *******************************************************************************\n * @notice Interface for contracts using VRF randomness through the VRF V2 wrapper\n * ********************************************************************************\n * @dev PURPOSE\n *\n * @dev Create VRF V2 requests without the need for subscription management. Rather than creating\n * @dev and funding a VRF V2 subscription, a user can use this wrapper to create one off requests,\n * @dev paying up front rather than at fulfillment.\n *\n * @dev Since the price is determined using the gas price of the request transaction rather than\n * @dev the fulfillment transaction, the wrapper charges an additional premium on callback gas\n * @dev usage, in addition to some extra overhead costs associated with the VRFV2Wrapper contract.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFV2WrapperConsumerBase. The consumer must be funded\n * @dev with enough LINK to make the request, otherwise requests will revert. To request randomness,\n * @dev call the 'requestRandomness' function with the desired VRF parameters. This function handles\n * @dev paying for the request based on the current pricing.\n *\n * @dev Consumers must implement the fullfillRandomWords function, which will be called during\n * @dev fulfillment with the randomness result.\n */\nabstract contract VRFV2WrapperConsumerBase {\n  LinkTokenInterface internal immutable LINK;\n  VRFV2WrapperInterface internal immutable VRF_V2_WRAPPER;\n\n  /**\n   * @param _link is the address of LinkToken\n   * @param _vrfV2Wrapper is the address of the VRFV2Wrapper contract\n   */\n  constructor(address _link, address _vrfV2Wrapper) {\n    LINK = LinkTokenInterface(_link);\n    VRF_V2_WRAPPER = VRFV2WrapperInterface(_vrfV2Wrapper);\n  }\n\n  /**\n   * @dev Requests randomness from the VRF V2 wrapper.\n   *\n   * @param _callbackGasLimit is the gas limit that should be used when calling the consumer's\n   *        fulfillRandomWords function.\n   * @param _requestConfirmations is the number of confirmations to wait before fulfilling the\n   *        request. A higher number of confirmations increases security by reducing the likelihood\n   *        that a chain re-org changes a published randomness outcome.\n   * @param _numWords is the number of random words to request.\n   *\n   * @return requestId is the VRF V2 request ID of the newly created randomness request.\n   */\n  function requestRandomness(\n    uint32 _callbackGasLimit,\n    uint16 _requestConfirmations,\n    uint32 _numWords\n  ) internal returns (uint256 requestId) {\n    LINK.transferAndCall(\n      address(VRF_V2_WRAPPER),\n      VRF_V2_WRAPPER.calculateRequestPrice(_callbackGasLimit),\n      abi.encode(_callbackGasLimit, _requestConfirmations, _numWords)\n    );\n    return VRF_V2_WRAPPER.lastRequestId();\n  }\n\n  /**\n   * @notice fulfillRandomWords handles the VRF V2 wrapper response. The consuming contract must\n   * @notice implement it.\n   *\n   * @param _requestId is the VRF V2 request ID.\n   * @param _randomWords is the randomness result.\n   */\n  function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal virtual;\n\n  function rawFulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) external {\n    require(msg.sender == address(VRF_V2_WRAPPER), \"only VRF V2 wrapper can fulfill\");\n    fulfillRandomWords(_requestId, _randomWords);\n  }\n}\n"}, "@openzeppelin/contracts/access/Ownable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"}, "@openzeppelin/contracts/interfaces/IERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../token/ERC20/IERC20.sol\";\n"}, "@openzeppelin/contracts/interfaces/IERC2981.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n *\n * _Available since v4.5._\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"}, "@openzeppelin/contracts/interfaces/IERC721.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../token/ERC721/IERC721.sol\";\n"}, "@openzeppelin/contracts/security/ReentrancyGuard.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"}, "@openzeppelin/contracts/token/ERC20/ERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.30;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"}, "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"}, "@openzeppelin/contracts/token/ERC20/IERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"}, "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"}, "@openzeppelin/contracts/token/ERC721/IERC721.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"}, "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"}, "@openzeppelin/contracts/utils/Address.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"}, "@openzeppelin/contracts/utils/Context.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"}, "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"}, "@openzeppelin/contracts/utils/introspection/ERC165.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.30;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"}, "@openzeppelin/contracts/utils/introspection/IERC165.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"}, "@openzeppelin/contracts/utils/math/Math.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"}, "@openzeppelin/contracts/utils/Strings.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.30;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"}, "contracts/Auction.sol": {"content": "//SPDX-License-Identifier: MIT\n/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\n/**\n * @title Auction\n * @author @brougkr\n * @notice A Smart Contract To Facilitate Ascending Auctions (With Ascending Reserve Floor) For Multiple NFTs (Or Whatever Else You Want To Sell) \n */\npragma solidity ^0.8.30;\nimport { DelegateCashEnabled } from \"./DelegateCashEnabled.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\ncontract Auction is DelegateCashEnabled, ReentrancyGuard, Ownable\n{\n    struct Bid\n    {\n        uint ETHValue;  // [0] -> ETH Value Of Bid\n        uint Timestamp; // [1] -> Unix Timestamp Of Bid Confirmation\n        address Bidder; // [2] -> Wallet Address Of Bidder\n        address Vault;  // [3] -> Wallet Address Of Vault (optional `delegate.cash` support)\n        bool Refunded;   // [4] -> If Bidder Refunded ETH From Bid\n        bool Winner;    // [5] -> If Bidder Is A Winner Of The Auction\n    }\n\n    struct Params\n    {\n        bool Active;           // [0] -> Is The Auction Active \n        bool ManualSwitch;     // [1] -> Override For Lowest Valid Bid (For Manual Switching)\n        uint UnixStartTime;    // [2] -> Unix Start Time Of Auction\n        uint UnixEndTime;      // [3] -> Unix End Time Of Auction\n        uint LowestValidBid;   // [4] -> Reserve Price Of Auction (minimum bid)\n        uint GlobalUniqueBids; // [5] -> Total Global Unique Bids In The Auction\n        uint MinBIPSIncrease;  // [6] -> Minimum BIPS (%) Increase On Each Subsequent Bid After 50 Unique Bids \n    }\n\n    /*-----------------------------\n     * STATE VARIABLES & MAPPINGS *\n    ------------------------------*/\n\n    Params public AuctionParams;\n    mapping(uint=>Bid) public Bids;\n    mapping(address=>uint[]) public UserBidIndexes;\n    address private constant _BRT_MULTISIG = 0x0BC56e3c1397e4570069e89C07936A5c6020e3BE;\n\n    /*---------\n     * EVENTS *\n    ----------*/\n\n    event NewBidComplete(uint MessageValue, uint Unixtimestamp, address Bidder, address Vault);\n    event BidToppedUp(uint MessageValue, uint Unixtimestamp, address Bidder, uint[] BidIndexes);\n    event BidReclaimFailed(uint BidIndex);\n\n    /*--------------\n     * CONSTRUCTOR *\n    ---------------*/\n\n    constructor() \n    { \n        AuctionParams.MinBIPSIncrease = 105; // 5% Increase On Each Subsequent Bid After 50 Unique Bids\n        AuctionParams.UnixEndTime = block.timestamp + 10080 minutes; // ends auction 1 week after starting\n        AuctionParams.LowestValidBid = 0.1 ether; // starts auction at 0.1 ETH\n        AuctionParams.Active = true; // activates auction\n    }\n\n    /*-----------------\n     * USER FUNCTIONS *\n    ------------------*/\n\n    /**\n     * @dev Submits A New Bid To The Auction\n     */\n    function NewBid(address Vault) external payable nonReentrant\n    {\n        require(tx.origin == msg.sender, \"Auction: EOA Only, Use `delegate.cash` For Wallet Delegation\"); // Requires `msg.sender` Is A Valid EOA\n        require(AuctionParams.Active, \"Auction: Auction Is Paused\"); // Requires The Auction Is Active\n        require(block.timestamp >= AuctionParams.UnixStartTime, \"Auction: Auction Has Not Started\"); // Requires The Auction Has Started\n        require(block.timestamp < AuctionParams.UnixEndTime, \"Auction: Auction Has Concluded\"); // Requires The Auction Has Not Ended\n        if(Vault != address(0)) { if(!DelegateCash.checkDelegateForAll(msg.sender, Vault)) { Vault = address(0); } } // `delegate.cash` Integration\n        uint NewMinimumBid; // Declares New Minimum Bid Variable\n        if(AuctionParams.ManualSwitch) { NewMinimumBid = AuctionParams.LowestValidBid; } // If Manual Switch Is Active, Use The Manual Lowest Valid\n        else { NewMinimumBid = _ViewMinimumValidBidV2(); } // Auto-Calculates The Required Reserve Price For The Bid (+5%)\n        require(msg.value >= NewMinimumBid, \"Auction: Bid Amount Must Be >= 1.05% * Current Floor Reserve Price\"); // Requires Min Bid\n        AuctionParams.LowestValidBid = NewMinimumBid; // Updates Reserve Price\n        if((AuctionParams.UnixEndTime - block.timestamp) < 5 minutes) { AuctionParams.UnixEndTime = block.timestamp + 5 minutes; } // Extend Auction 5 Minutes\n        Bids[AuctionParams.GlobalUniqueBids] = Bid(msg.value, block.timestamp, msg.sender, Vault, false, false); // Registers New Bid\n        UserBidIndexes[msg.sender].push(AuctionParams.GlobalUniqueBids); // Appends Bid Index To User's Bid Indexes\n        AuctionParams.GlobalUniqueBids = AuctionParams.GlobalUniqueBids + 1; // Increments Global Unique Bids\n        emit NewBidComplete(msg.value, block.timestamp, msg.sender, Vault); // Emits Bid Event\n    }\n\n    /**\n     * @dev Tops Up Bid(s) With Additional ETH\n     */\n    function IncreaseBid(uint[] calldata BidIndexes, uint[] calldata Amounts) external payable nonReentrant\n    {\n        require(tx.origin == msg.sender, \"Auction: EOA Only, Use `delegate.cash` For Wallet Delegation\"); // Requires `msg.sender` Is A Valid EOA\n        require(AuctionParams.Active, \"Auction: Auction Is Paused\"); // Requires The Auction Is Active\n        require(BidIndexes.length == Amounts.length, \"Auction: BidIndexes And Amounts Array Length Mismatch\"); // Requires BidIndexes And Amounts Length Match\n        require(block.timestamp >= AuctionParams.UnixStartTime, \"Auction: Auction Has Not Started\"); // Requires The Auction Has Started\n        require(block.timestamp < AuctionParams.UnixEndTime, \"Auction: Auction Has Concluded\"); // Requires The Auction Has Not Ended\n        require(BidIndexes.length > 0, \"Auction: User Has No Bids To Top Up\"); // Requires User Has Bids To Top Up\n        uint NewMinimumBid; // Declares New Minimum Bid Variable\n        if(AuctionParams.ManualSwitch) { NewMinimumBid = AuctionParams.LowestValidBid; } // If Manual Switch Is Active, Use The Lowest Valid Bid\n        else { NewMinimumBid = _ViewMinimumValidBidV2(); } // Auto-Calculates The Required Reserve Price For The Bid (+5%)\n        uint Delta = NewMinimumBid - AuctionParams.LowestValidBid; \n        uint Total;\n        for(uint x; x < BidIndexes.length; x++)\n        { \n            Total += Amounts[x];\n            require(msg.sender == Bids[BidIndexes[x]].Bidder, \"Auction: `msg.sender` Is Not The Bidder Of Provided Bid Index\");\n            require(Bids[BidIndexes[x]].ETHValue + Amounts[x] >= NewMinimumBid, \"Auction: Bid Amount Must Be At Least 5% More Than The Current Floor Price\");\n            require(Amounts[x] >= Delta, \"Auction: Top Up ETH Value Must Be >= MinimumBid - Lowest Valid Bid\");\n            Bids[BidIndexes[x]].ETHValue += Amounts[x];\n            Bids[BidIndexes[x]].Timestamp = block.timestamp;\n        }\n        require(msg.value == Total, \"Auction: Must Send Exact ETH Value To Top Up Bids\");\n        if((AuctionParams.UnixEndTime - block.timestamp) < 5 minutes) { AuctionParams.UnixEndTime = block.timestamp + 5 minutes; } // Extend Auction 5 Min\n        emit BidToppedUp(msg.value, block.timestamp, msg.sender, BidIndexes);\n    }\n\n    /**\n     * @dev Returns All ETH Bids Sent By `User` If Auction Has Not Ended & `User` Has Bids Before 1hr Auction End Time\n     */\n    function ReclaimETH() external nonReentrant\n    {\n        require(tx.origin == msg.sender, \"Auction: EOA Only, Use `delegate.cash` For Wallet Delegation\"); // Requires `msg.sender` Is A Valid EOA\n        require(block.timestamp < AuctionParams.UnixEndTime, \"Auction: Auction Has Concluded\"); // Requires The Auction Has Not Ended\n        require(AuctionParams.Active, \"Auction: Auction Is Paused\"); // Requires The Auction Is Active\n        uint[] memory BidIndexes = UserBidIndexes[msg.sender];\n        require(BidIndexes.length > 0, \"Auction: User Has No Bids To Reclaim\");\n        for(uint x; x < UserBidIndexes[msg.sender].length; x++) \n        { \n            if(!Bids[BidIndexes[x]].Refunded && !Bids[BidIndexes[x]].Winner) // Ensures Bid Has Not Been Refunded And Is A Valid Bid\n            {\n                if(Bids[BidIndexes[x]].ETHValue < AuctionParams.LowestValidBid) // Ensures Bid Is Not A Currently Valid Bid\n                {\n                    Bids[BidIndexes[x]].Refunded = true;\n                    (bool Success, ) = Bids[BidIndexes[x]].Bidder.call { value: Bids[BidIndexes[x]].ETHValue }(\"\");\n                    if(!Success) { emit BidReclaimFailed(BidIndexes[x]); }\n                }\n            }\n        }\n    }\n\n    /*----------------------\n     * ONLYOWNER FUNCTIONS *\n    -----------------------*/\n\n    /**\n     * @dev Seeds The Floor ETH Value For New Bids & Bid Topups\n     */\n    function ___SeedFloorReserve(uint WEIValue) external onlyOwner { AuctionParams.LowestValidBid = WEIValue; }\n\n    /**\n     * @dev Flips The Manual Auction LowestValidBid Boolean Value\n     */\n    function ___FlipManualSwitch() external onlyOwner { AuctionParams.ManualSwitch = !AuctionParams.ManualSwitch; }\n\n    /**\n     * @dev Sets Winners\n     */\n    function ___SetWinners(uint[] calldata Indexes) external onlyOwner\n    {\n        for(uint x; x < Indexes.length; x++)\n        {\n            require(!Bids[Indexes[x]].Winner, \"Auction: Bid Is Already A Winner\");\n            require(!Bids[Indexes[x]].Refunded, \"Auction: Bid Is Already Refunded\");\n            Bids[Indexes[x]].Winner = true;\n        }\n    }\n\n    /**\n     * @dev Refunds All Unclaimed Bids & Sends Remaining ETH To Multisig\n     */\n    function ___InitiateRefundsAndProceeds() external onlyOwner \n    { \n        for(uint x; x < AuctionParams.GlobalUniqueBids; x++)\n        {\n            if(!Bids[x].Refunded && !Bids[x].Winner) // If Bid Is Not Refunded & Is Not A Winning Bid, Refund ETH\n            {\n                Bids[x].Refunded = true;\n                (bool Refund, ) = Bids[x].Bidder.call { value: Bids[x].ETHValue }(\"\");\n                if(!Refund) { emit BidReclaimFailed(x); }\n            }\n        }\n        (bool MultisigWithdraw, ) = _BRT_MULTISIG.call{ value: address(this).balance }(\"\");\n        require(MultisigWithdraw, \"Auction: Failed To Send ETH To Multisig, Use Failsafe Withdraw\");\n    }\n\n    /**\n     * @dev Flips The Auction Pause State\n     */\n    function ___FlipAuctionState() external onlyOwner { AuctionParams.Active = !AuctionParams.Active; }\n\n    /**\n     * @dev Withdraws All Ether From The Contract\n     */\n    function ___WithdrawEther() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }\n\n    /**\n     * @dev Withdraws Ether From Contract To Address With An Amount\n     */\n    function ___WithdrawEtherToAddress(address payable Recipient, uint Amount) external onlyOwner\n    {\n        require(Amount > 0 && Amount <= address(this).balance, \"Invalid Amount\");\n        (bool Success, ) = Recipient.call{value: Amount}(\"\");\n        require(Success, \"Unable to Withdraw, Recipient May Have Reverted\");\n    }\n\n    /*--------------------------\n     * EXTERNAL VIEW FUNCTIONS *\n    ---------------------------*/\n\n    /**\n     * @dev Returns WEI Value Of Refunds & Proceeds\n     */\n    function ViewRefundsAndProceeds() external view returns (uint, uint)\n    {\n        uint Refunds;\n        uint Proceeds;\n        for(uint x; x < AuctionParams.GlobalUniqueBids; x++) \n        { \n            if(!Bids[x].Refunded && !Bids[x].Winner) { Refunds += Bids[x].ETHValue; } \n            else if (Bids[x].Winner) { Proceeds += Bids[x].ETHValue; }\n        }\n        return (Refunds, Proceeds);\n    }\n\n    /**\n     * @dev View Function For Frontend\n     */\n    function ViewFrontend() external view returns (Params memory, uint[] memory)\n    {\n        uint[] memory _Leaderboard = new uint[](AuctionParams.GlobalUniqueBids);\n        for(uint x; x < AuctionParams.GlobalUniqueBids; x++) { _Leaderboard[x] = Bids[x].ETHValue; }\n        return (AuctionParams, _InsertionSort(_Leaderboard));\n    }\n\n    /**\n     * @dev Returns The Sorted Bid Leaderboard With Original Bid Indexes As A 2D-Array\n     */\n    function ViewLeaderboardWithIndexes() external view returns (uint[][] memory) { return _InsertionSortBidIndexes(); }\n\n    /**\n     * @dev Returns Auction Parameters\n     */\n    function ViewAuctionParams() external view returns (Params memory) { return AuctionParams; }\n\n    /**\n     * @dev Returns Ascending Order Of Highest Unique ETH Bids \n     * note: you should sort off-chain to calculate leaderboard as best practice\n     * note: if you have a more elegant implementation hmu\n     */\n    function ViewLeaderboard() external view returns (uint[] memory)\n    {\n        uint[] memory _Leaderboard = new uint[](AuctionParams.GlobalUniqueBids);\n        for(uint x; x < AuctionParams.GlobalUniqueBids; x++) { _Leaderboard[x] = Bids[x].ETHValue; }\n        return _InsertionSort(_Leaderboard);\n    }\n\n    /**\n     * @dev Returns A Individual 'Bid' Struct Corresponding To Input Index\n     */\n    function ViewBid(uint Index) external view returns (Bid memory) { return Bids[Index]; }\n\n    /**\n     * @dev Returns A 'Bid' Struct Array Corresponding To Input Indexes\n     */\n    function ViewBids(uint[] calldata Indexes) external view returns(Bid[] memory) \n    {\n        Bid[] memory _Bids = new Bid[](Indexes.length);\n        for(uint x; x < Indexes.length; x++) { _Bids[x] = Bids[Indexes[x]]; }\n        return _Bids;\n    }\n\n    /**\n     * @dev Returns A 'Bid' Struct Array Of All Unique Bids In The Auction\n     * note: this will throw `out of gas` after 1648~ unique bids because block gas limit is 30M, use `ViewBids()` with indexes after 1648~ unique bids\n     */\n    function ViewAllUniqueBids() external view returns(Bid[] memory)\n    {\n        uint GlobalUniqueBids = AuctionParams.GlobalUniqueBids;\n        Bid[] memory _Bids = new Bid[](GlobalUniqueBids);\n        for(uint x; x < GlobalUniqueBids; x++) { _Bids[x] = Bids[x]; }\n        return _Bids;\n    }\n\n    /**\n     * @dev Returns A `Bid` Struct Array Of All Unique Bids In The Auction Submitted By `Wallet`\n     */\n    function ViewWalletBids(address Wallet) external view returns(Bid[] memory)\n    {\n        uint[] memory _Indexes = UserBidIndexes[Wallet];\n        Bid[] memory _Bids = new Bid[](_Indexes.length);\n        for(uint x; x < _Indexes.length; x++) { _Bids[x] = Bids[_Indexes[x]]; }\n        return _Bids;\n    }\n\n    /**\n     * @dev Returns An Array Of `Wallet` Submitted Bid Indexes\n     */\n    function ViewUserBidIndexes(address Wallet) external view returns(uint[] memory) { return UserBidIndexes[Wallet]; }\n\n    /**\n     * @dev Returns Minimum Valid Bid For The Auction (less gas efficient)\n     */\n    function ViewMinimumValidBidV1() external view returns (uint) { return _ViewMinimumValidBidV1(); }\n\n    /**\n     * @dev Returns Minimum Valid Bid For The Auction (more gas efficient)\n     */\n    function ViewMinimumValidBidV2() external view returns (uint) { return _ViewMinimumValidBidV2(); }\n    \n    /**\n     * @dev Returns Minimum Valid Bid For The Auction\n     */\n    function ViewMinimumValidBidV3() external view returns (uint) { return _ViewMinimumValidBidV3(); }\n\n    /*--------------------------\n     * INTERNAL VIEW FUNCTIONS *\n    ---------------------------*/\n\n    /**\n     * @dev Returns The Minimum Valid Bid That Can Be Submitted To The Auction After 50 Bids Have Been Reached (50th Lowest Bid * 1.05)\n     * note: uses the complex 2d insertion sort algorithm to sort the bids and their indexes\n     */\n    function _ViewMinimumValidBidV1() internal view returns (uint)\n    {\n        if(AuctionParams.GlobalUniqueBids < 50) { return ((AuctionParams.LowestValidBid * AuctionParams.MinBIPSIncrease) / 100); }\n        else\n        {\n            uint[][] memory BidsAndIndexes = _InsertionSortBidIndexes();\n            uint IndexOfMinimumBid = AuctionParams.GlobalUniqueBids - 50; // Index Of 50th Largest Bid\n            uint LowestValidBid = BidsAndIndexes[IndexOfMinimumBid][0];\n            return ((LowestValidBid * AuctionParams.MinBIPSIncrease) / 100);\n        }\n    }\n\n    /**\n     * @dev Returns The Minimum Valid Bid That Can Be Submitted To The Auction After 50 Bids Have Been Reached (50th Lowest Bid * 1.05)\n     * note: uses the basic insertion sort algorithm to sort only the eth bid values, this is more gas efficient than sorting the entire struct array of bids\n     */\n    function _ViewMinimumValidBidV2() internal view returns (uint)\n    {\n        if(AuctionParams.GlobalUniqueBids < 50) { return ((AuctionParams.LowestValidBid * AuctionParams.MinBIPSIncrease) / 100); }\n        else\n        {\n            uint[] memory _Leaderboard = new uint[](AuctionParams.GlobalUniqueBids);\n            uint IndexOfMinimumBid = AuctionParams.GlobalUniqueBids - 50; // Index Of 50th Largest Bid\n            for(uint x; x < AuctionParams.GlobalUniqueBids; x++) { _Leaderboard[x] = Bids[x].ETHValue; }\n            return ((_InsertionSort(_Leaderboard)[IndexOfMinimumBid] * AuctionParams.MinBIPSIncrease) / 100);\n        }\n    }\n\n    /**\n     * @dev Returns The Minimum Valid Bid That Has Been Submitted To The Auction Or ((LVB * BIPS) / 100) If < Than 50 Unique Bids\n     */\n    function _ViewMinimumValidBidV3() internal view returns (uint MinimumBid)\n    {\n        if(AuctionParams.GlobalUniqueBids > 50)\n        {       \n            uint NewMin = AuctionParams.LowestValidBid; \n            uint Curr = 10000 ether;\n            for(uint x; x < AuctionParams.GlobalUniqueBids; x++) \n            { \n                if(Bids[x].ETHValue <= NewMin && !Bids[x].Refunded && !Bids[x].Winner && Bids[x].ETHValue < Curr) { Curr = Bids[x].ETHValue; }\n            }\n            return ((Curr * AuctionParams.MinBIPSIncrease) / 100);\n        }\n        else { return (AuctionParams.LowestValidBid * AuctionParams.MinBIPSIncrease) / 100; }\n    }\n\n    /**\n     * @dev Returns A Sorted List Of Integers\n     * note: you should (in general) not sort large things in solidity (as of 0.8~) because it is very gas inefficient, this is just for demonstration purposes\n     */\n    function _InsertionSort(uint[] memory Array) internal pure returns (uint[] memory)\n    {\n        for(uint x; x < Array.length; x++)\n         {\n            uint key = Array[x];\n            uint y = x;\n            while(y > 0 && Array[y-1] > key) \n            {\n                Array[y] = Array[y-1];\n                y--;\n            }\n            Array[y] = key;\n        }\n        return Array;\n    }\n\n    /**\n     * @dev Returns A Sorted List Of ETH Bids @ '[n][0]' And The Indexes Of The Original Bids @ '[n][1]'\n     * note: insertion sort O(n^2) seemed like best approach because english auction bids increase as auction progresses, otherwise quicksort prob better O(nlogn)\n     * note: because block gas limit is 30M, this will `out-of-gas` dependant on how much sorting needs done if you have a more eloquent way of doing this hmu\n     * note: you should (in general) not sort large things in solidity (as of 0.8~) because it is very gas inefficient, this is just for demonstration purposes\n     */\n    function _InsertionSortBidIndexes() internal view returns (uint[][] memory)\n    {\n        uint[][] memory BidsAndIndexes = new uint[][](AuctionParams.GlobalUniqueBids);\n        for(uint x; x < BidsAndIndexes.length; x++) \n        {\n            BidsAndIndexes[x] = new uint[](2);       // Init Sub-Array\n            BidsAndIndexes[x][0] = Bids[x].ETHValue; // Assign [x][0] -> ETHValue\n            BidsAndIndexes[x][1] = x;                // Assign [x][1] -> Original Index\n        }\n        for(uint i; i < BidsAndIndexes.length; i++)\n        {\n            uint ETHValue = BidsAndIndexes[i][0];   // Preserve ETHValue\n            uint OGBidIndex = BidsAndIndexes[i][1]; // Preserve OGBidIndex\n            uint j = i;\n            while(j > 0 && BidsAndIndexes[j-1][0] > ETHValue)\n            {\n                BidsAndIndexes[j][0] = BidsAndIndexes[j-1][0]; // Move Larger Element To The Right\n                BidsAndIndexes[j][1] = BidsAndIndexes[j-1][1]; // Move OG Index\n                j--;\n            }\n            BidsAndIndexes[j][0] = ETHValue;   // Insert ETHValue In Correct Location\n            BidsAndIndexes[j][1] = OGBidIndex; // Insert OGBidIndex In Correct Location\n        }\n        return BidsAndIndexes;\n    }\n}"}, "contracts/BatchReader.sol": {"content": "//SPDX-License-Identifier: MIT\n/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\n/**\n * @dev: @brougkr\n */\npragma solidity ^0.8.30;\ncontract BatchReader\n{\n    struct CityInfo\n    {\n        string Name;\n        address NFT;\n        uint StartingIndex;\n    }\n    mapping(uint=>CityInfo) public CityInformation;\n    constructor()\n    {\n        CityInformation[0] = CityInfo('CryptoGalacticans', 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, 0);\n        CityInformation[1] = CityInfo('CryptoVenetians', 0xa7d8d9ef8D8Ce8992Df33D8b8CF4Aebabd5bD270, 95000000);\n        CityInformation[2] = CityInfo('CryptoNewYorkers', 0xa7d8d9ef8D8Ce8992Df33D8b8CF4Aebabd5bD270, 189000000);\n        CityInformation[3] = CityInfo('CryptoBerliners', 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, 3000000);\n        CityInformation[4] = CityInfo('CryptoLondoners', 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, 4000000);\n        CityInformation[5] = CityInfo('CryptoMexas', 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, 5000000);\n        CityInformation[6] = CityInfo('CryptoTokyites', 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, 6000000);\n        CityInformation[7] = CityInfo('City #8', 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, 7000000);\n        CityInformation[8] = CityInfo('City #9', 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, 8000000);\n        CityInformation[9] = CityInfo('City #10', 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, 9000000);\n    }\n\n    /**\n     * @dev Returns An Array Of A Specific CryptoCitizen City Owners\n     */\n    function ReadCitizenCityOwners(uint CityIndex) external view returns (address[] memory)\n    {\n        address NFTAddress = CityInformation[CityIndex].NFT;\n        uint Counter;\n        IERC721 _NFT = IERC721(NFTAddress);\n        address[] memory Owners = new address[](1000);\n        uint Start = CityInformation[CityIndex].StartingIndex;\n        uint Range = Start + 1000;\n        for(Start; Start < Range; Start++)\n        {\n            try _NFT.ownerOf(Start) returns (address Owner) \n            { \n                Owners[Counter] = Owner; \n                Counter++;\n            }\n            catch \n            { \n                Counter++;\n                continue; \n            }\n        }\n        return Owners;\n    }\n}\n\ninterface IERC721 { function ownerOf(uint TokenID) external view returns (address); }"}, "contracts/BatchReaderNew.sol": {"content": "// SPDX-License-Identifier: MIT\n/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\n/**\n * @dev: @brougkr\n */\npragma solidity ^0.8.30;\ncontract BatchReaderNew \n{\n    /**\n     * @dev Returns A Wallet's Owned NFTs (If ArtBlocks, Then ProjectIDs Are Required, Else Input 0 For ProjectIDs & It Will Start @ TokenID 0)\n     */\n    function readNFTsOwnedTokenIDs (\n        address Wallet,\n        address[] calldata NFTs,\n        uint[] calldata ProjectIDs, // If ArtBlocks\n        uint Range\n    ) public view returns(uint[][] memory) {\n        uint[][] memory OwnedIDs = new uint[][](ProjectIDs.length);\n        for(uint x; x < ProjectIDs.length; x++)\n        {\n            IERC721 NFT = IERC721(NFTs[x]);\n            uint[] memory temp = new uint[](Range);\n            uint _TokenID = ProjectIDs[x] * 1000000;\n            uint _Range = _TokenID + Range;\n            uint NumOwnedTokens;\n            for(_TokenID; _TokenID < _Range; _TokenID++)\n            {\n                try NFT.ownerOf(_TokenID) returns (address _Owner)\n                {\n                    if(_Owner == Wallet)\n                    {\n                        temp[NumOwnedTokens] = _TokenID;\n                        NumOwnedTokens++;\n                    }\n                } catch { }\n            }\n            uint[] memory FormattedOwnedIDs = new uint[](NumOwnedTokens);\n            for(uint z; z < NumOwnedTokens; z++) { FormattedOwnedIDs[z] = temp[z]; }\n            OwnedIDs[x] = FormattedOwnedIDs;\n        }\n        return OwnedIDs;\n    }\n}\n\ninterface IERC721 { function ownerOf(uint256 tokenId) external view returns (address owner); }"}, "contracts/DelegateCashEnabled.sol": {"content": "//SPDX-License-Identifier: MIT\n/**\n * @title DelegateCashEnabled\n * @author @brougkr\n * @notice For Easily Integrating `delegate.cash`\n */\npragma solidity ^0.8.30;\nabstract contract DelegateCashEnabled\n{\n    address private constant _DN = 0x00000000000076A84feF008CDAbe6409d2FE638B;\n    IDelegation public constant DelegateCash = IDelegation(_DN);\n}\n\ninterface IDelegation\n{\n    /**\n     * @dev Checks If A Vault Has Delegated To The Delegate\n     */\n    function checkDelegateForAll(address delegate, address vault) external view returns (bool);\n}"}, "contracts/DutchMarketplace.sol": {"content": "//SPDX-License-Identifier: MIT\n/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\n/**\n * @dev: @brougkr\n */\npragma solidity ^0.8.30;\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { MerkleProof } from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport { IMP } from \"./IMP.sol\";\nimport { LaunchpadEnabled } from \"./LaunchpadEnabled.sol\";\ncontract DutchMarketplace is Ownable, ReentrancyGuard, LaunchpadEnabled\n{\n    struct Sale\n    {\n        string _Name;                     // [0] -> _Name\n        uint _ProjectIDMintPass;          // [1] -> _ProjectIDMintPass\n        uint _ProjectIDArtBlocks;         // [2] -> _ProjectIDArtBlocks\n        uint _PriceStart;                 // [3] -> _PriceStart\n        uint _PriceEnd;                   // [4] -> _PriceEnd\n        uint _MaxAmtPerPurchase;          // [5] -> _MaxAmtPerPurchase\n        uint _MaximumAvailableForSale;    // [6] -> _MaximumAvailableForSale\n        uint _StartingBlockUnixTimestamp; // [7] -> _StartingBlockUnixTimestamp\n        uint _SecondsBetweenPriceDecay;   // [8] -> _SecondsBetweenPriceDecay\n        uint _SaleStrip;                  // [9] -> _SaleStrip note: For MintPack Sales, This Is The Default Amount Of Tokens To Mint Per Purchase Per Amount \n    }\n\n    struct InternalSale\n    {\n        address _NFT;           // [0] -> _NFT\n        address _Operator;      // [1] _Operator (Wallet That NFT Is Pulling From)\n        uint _CurrentIndex;     // [2] _CurrentIndex (If Simple Sale Type, This Is The Next Token Index To Iterate Upon)\n        uint _Type;             // [3] _SaleType (0 = Factory MintPass, 1 = Bespoke MintPass, 2 = transferFrom(), 3 = purchaseTo(), 4 = MintPack transferFrom())\n        bool _ActivePublic;     // [4] -> _ActivePublic\n        bool _ActiveBrightList; // [5] -> _ActiveBrightList \n        bool _ActiveDiscount;   // [6] -> _ActiveDiscount\n        bool _ActiveRespend;    // [7] -> _ActiveRespend\n    }\n\n    struct SaleParam\n    {\n        bytes32[] _Roots;        // [0] -> _Roots (Merkle Roots For BrightList)\n        bytes32[] _RootsAmounts; // [1] -> _RootsAmounts (Merkle Roots For BrightList Amounts)\n        uint[] _DiscountAmounts; // [2] -> _DiscountAmounts (Discount Amounts For Each Discount Priority Tier)\n    }\n\n    struct MiscSale\n    {\n        uint _AmountSold;         // [0] -> _AmountSold\n        uint _UniqueSales;        // [1] -> _UniqueSales\n        uint _FinalClearingPrice; // [2] -> _FinalClearingPrice\n        uint _CurrentRefundIndex; // [3] -> _CurrentRefundIndex\n    }\n\n    struct Order\n    {\n        address _Purchaser;       // [0] _Purchaser\n        uint _PurchaseValue;      // [1] _PurchaseValue\n        uint _PurchaseAmount;     // [2] _PurchaseAmount\n        uint _Priority;           // [3] _BrightList Priority Status note: (0 Is Highest Priority)\n        bool _BrightListPurchase; // [4] _BrightListPurchase\n        bool _Claimed;            // [5] _Claimed\n    }\n\n    struct _UserSaleInformation\n    {\n        uint[] _UserOrderIndexes;        // [0] -> _UserOrderIndexes        | The Indexes Of The User's Orders\n        uint[] _AmountPurchasedPriority; // [1] -> _AmountPurchasedPriority | The Amount Of Tokens Purchased By The User For The Provided Priority\n        uint _PurchasedAmount;           // [2] -> _PurchaseAmount          | The Amount Of Tokens Purchased By The User\n        uint _RemainingPurchaseAmount;   // [3] -> _RemainingPurchaseAmount | The Amount Of Tokens Remaining To Be Purchased Specifically For The User\n        uint _ClaimIndex;                // [4] -> _ClaimIndex              | If ETH-Claims Are Enabled, This Is The User's Current Claim Index\n        uint _AmountRemaining;           // [5] -> _AmountRemaining         | The Amount Of Tokens Remaining To Be Sold\n        uint _CurrentPrice;              // [6] -> _MintPassCurrentPrice    | The Current Price Of The Token To Be Sold\n        uint _Priority;                  // [7] -> _Priority For BrightList | The User's Priority For The BrightList | note: (0 Is Highest Priority) \n        uint _Credit;                    // [8] -> _Credit                  | The Amount Of Credit / Rebate Owed To The User (Without Discount) \n        bool _BrightListEligible;        // [9] -> _BrightListEligible      | If The User Is Eligible For The BrightList\n        bool _MaxAmountVerified;         // [10] -> _MaxAmountVerified      | If The User Passed MaxAmount Correctly\n        bool _ActiveRespend;             // [11] -> _ActiveRespend          | If Purchase Credit Is Able To Be Used\n        bool _Active;                    // [12] -> _Active                 | If The Sale Is Active\n    }\n\n    struct Info\n    {\n        uint _CurrentPrice;            // [0] -> _CurrentPrice\n        uint _MaximumAvailableForSale; // [1] -> _MaximumAvailableForSale\n        uint _AmountRemaining;         // [2] -> _AmountRemaining\n        bool _Active;                  // [3] -> _Active\n    }\n\n    /*------------------\n     * STATE VARIABLES *\n    -------------------*/\n\n    uint public _TOTAL_UNIQUE_SALES_DUTCH;                                               // Total Unique Dutch Sales\n    uint private constant _DEFAULT_PRIORITY = 69420;                                     // Default Priority Value \ud83d\ude09              \n    address private constant _DN = 0x00000000000076A84feF008CDAbe6409d2FE638B;           // `delegate.cash` Delegation Registry \n    address private constant _BRT_MULTISIG = 0x0BC56e3c1397e4570069e89C07936A5c6020e3BE; // `sales.brightmoments.eth`\n    \n    /*-----------\n     * MAPPINGS *\n    ------------*/\n\n    mapping(uint=>Sale) public Sales;                                                   // [SaleIndex] => Sale\n    mapping(uint=>MiscSale) public SaleState;                                           // [SaleIndex] => MiscSale\n    mapping(uint=>InternalSale) public SalesInternal;                                   // [SaleIndex] => InternalSale\n    mapping(uint=>Order[]) public Orders;                                               // [SaleIndex][UniqueSaleIndex] => Order\n    mapping(uint=>mapping(address=>_UserSaleInformation)) public UserInfo;              // [SaleIndex][Wallet] => UserInfo\n    mapping(uint=>SaleParam) private SaleParams;                                        // [SaleIndex] => SaleParam\n    mapping(address=>bool) public Admin;                                                // [Wallet] => IsAdmin\n    mapping(address=>uint) public NFTAddressToSaleIndex;                                // [NFT Address] => SaleIndex\n    mapping(uint=>mapping(address=>mapping(uint=>uint))) public PriorityPurchaseAmount; // [SaleIndex][Wallet][Priority] => Purchased Amount For Priority Level\n\n    /*---------\n     * EVENTS *\n    ----------*/\n\n    event Purchased(uint SaleIndex, address Purchaser, uint Amount, uint PurchaseValue, uint NewAmountSold, bool BrightList, uint Priority, uint AppliedCredit);\n    event Refunded(uint Value);\n    event OrderRefundFailed(uint SaleIndex, uint OrderIndex);\n    event SaleStarted(uint SaleIndex);\n    event RefundClaimed(uint SaleIndex, uint OrderIndex);\n\n    constructor() \n    { \n        Admin[0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700] = true;  // `operator.brightmoments.eth`\n        Admin[msg.sender] = true;\n    }\n\n    /*---------------------\n     * EXTERNAL FUNCTIONS *\n    ----------------------*/\n\n    /**\n     * @dev Purchases NFTs\n     * note: IF YOU PURCHASE THROUGH THE CONTRACT WITHOUT THE FRONTEND YOU WILL NOT BE ELIGIBLE FOR A DISCOUNT REBATE, REQUIRES A MERKLE PROOF\n     * note: `msg.value` Must Be Sufficient To Purchase NFTs @ The Current Price Of The Dutch Auction\n     * @param SaleIndex        | The Sale Index\n     * @param Amount           | The Amount Of NFTs To Purchase\n     * @param MaxAmount        | Optional Maximum Brightlist Purchase Per Wallet Limiter\n     * @param Vault            | Vault (optional delegate.cash) (if opt-out, use address(0) or `` for this value)\n     * @param ProofEligibility | Merkle Proof For Priority Discount Eligibility\n     * @param ProofAmount      | Merkle Proof For Maximum Purchase Amount\n     * note: @param ProofEligibility Input --> [0x0] <-- For Empty Proof\n     * note: @param ProofAmount - Input --> [0x0] <-- For Empty Proof\n     */\n    function Purchase (\n        uint SaleIndex, \n        uint Amount, \n        uint MaxAmount, \n        address Vault, \n        bytes32[] calldata ProofEligibility, \n        bytes32[] calldata ProofAmount\n    ) external payable nonReentrant { \n        require(tx.origin == msg.sender, \"DutchMarketplace: EOA Only, Use `delegate.cash` For Wallet Delegation\");\n        InternalSale memory _IS = SalesInternal[SaleIndex];\n        require(block.timestamp >= Sales[SaleIndex]._StartingBlockUnixTimestamp, \"DutchMarketplace: Sale Not Started\");\n        require(_IS._ActivePublic || _IS._ActiveBrightList, \"DutchMarketplace: Sale Not Active\");\n        address Recipient = msg.sender;\n        uint OrderIndex = SaleState[SaleIndex]._UniqueSales;\n        if(Vault != address(0)) { if(IDelegationRegistry(_DN).checkDelegateForAll(msg.sender, Vault)) { Recipient = Vault; } } \n        require(Recipient != address(0), \"DutchMarketplace: Invalid Recipient\");\n        if(SaleState[SaleIndex]._AmountSold + Amount > Sales[SaleIndex]._MaximumAvailableForSale)\n        {\n            Amount = Sales[SaleIndex]._MaximumAvailableForSale - SaleState[SaleIndex]._AmountSold;\n        }\n        uint NewAmountSold = SaleState[SaleIndex]._AmountSold + Amount;\n        require(NewAmountSold <= Sales[SaleIndex]._MaximumAvailableForSale, \"DutchMarketplace: Sold Out\");\n        uint Priority = _DEFAULT_PRIORITY;\n        bool BrightListEligible;\n        if(_IS._ActiveBrightList)\n        {\n            (BrightListEligible, Priority) = ViewBrightListStatus(SaleIndex, Recipient, ProofEligibility);\n            if(BrightListEligible)\n            {\n                uint UserPriorityPurchasedAmount = PriorityPurchaseAmount[SaleIndex][Recipient][Priority];\n                bytes32 _RootHash = SaleParams[SaleIndex]._RootsAmounts[Priority];\n                require(__VerifyAmount(Recipient, MaxAmount, _RootHash, ProofAmount), \"DutchMarketplace: Invalid Max Amount Merkle Proof For Provided Merkle Priority\");\n                require(UserPriorityPurchasedAmount + Amount <= MaxAmount, \"DutchMarketplace: User Has Purchased All Allocation For Provided Merkle Priority\");\n                PriorityPurchaseAmount[SaleIndex][Recipient][Priority] += Amount;\n            }\n        }\n        require(Amount > 0 && Amount <= Sales[SaleIndex]._MaxAmtPerPurchase, \"DutchMarketplace: Incorrect Desired Purchase Amount\");\n        uint CurrentPrice = __ViewCurrentPrice(SaleIndex);\n        uint PurchaseValue = CurrentPrice * Amount;\n        uint AppliedCredit;\n        if(_IS._ActiveRespend) { AppliedCredit = __ActiveRespend(SaleIndex, CurrentPrice, PurchaseValue, msg.sender); } // AppliedCredit Is Capped @ Purchase Value\n        uint TotalETHContributed = msg.value + AppliedCredit;\n        require(TotalETHContributed >= PurchaseValue, \"DutchMarketplace: Incorrect ETH Amount Sent\");\n        if(TotalETHContributed > PurchaseValue && msg.value > 0) { __Refund(msg.sender, TotalETHContributed - PurchaseValue); }\n        Orders[SaleIndex].push(Order(msg.sender, PurchaseValue, Amount, Priority, BrightListEligible, false));\n        UserInfo[SaleIndex][msg.sender]._UserOrderIndexes.push(OrderIndex);\n        UserInfo[SaleIndex][msg.sender]._PurchasedAmount = UserInfo[SaleIndex][msg.sender]._PurchasedAmount + Amount;\n        SaleState[SaleIndex]._UniqueSales = OrderIndex + 1;\n        SaleState[SaleIndex]._AmountSold = NewAmountSold;\n        require(SaleState[SaleIndex]._AmountSold <= Sales[SaleIndex]._MaximumAvailableForSale, \"DutchMarketplace: Overflow\");\n        if(SaleState[SaleIndex]._AmountSold == Sales[SaleIndex]._MaximumAvailableForSale)\n        { \n            SaleState[SaleIndex]._FinalClearingPrice = CurrentPrice; \n            __EndSale(SaleIndex);\n        }\n        if(_IS._Type == 0) { IERC721(_IS._NFT)._MintToFactory(Sales[SaleIndex]._ProjectIDMintPass, msg.sender, Amount); } // Factory MintPass Direct Mint\n        else if (_IS._Type == 1) { IERC721(_IS._NFT)._MintToBespoke(msg.sender, Amount); } // MintPass Mint To Bespoke\n        else if (_IS._Type == 2) { IERC721(_IS._NFT)._MintToFactoryPack(Sales[SaleIndex]._ProjectIDMintPass, msg.sender, Amount); } // Factory MintPack Direct Mint\n        else if (_IS._Type == 3) // transferFrom() Sale Implementation (NFTs Already Minted)\n        {\n            for(uint x; x < Amount; x++)\n            {\n                IERC721(_IS._NFT).transferFrom(\n                    _IS._Operator,        // `from`\n                    msg.sender,           // `to`\n                    _IS._CurrentIndex + x // `tokenID`\n                );\n            }\n            SalesInternal[SaleIndex]._CurrentIndex = _IS._CurrentIndex + Amount;\n        }\n        else if (_IS._Type == 4) // purchaseTo() Sale Implementation\n        {\n            uint ProjectID = Sales[SaleIndex]._ProjectIDArtBlocks;\n            for(uint x; x < Amount; x++)\n            {\n                IERC721(_IS._NFT).purchaseTo(\n                    msg.sender, // `to`\n                    ProjectID   // `projectID`\n                );\n            }\n        }\n        else if (_IS._Type == 5) \n        {\n            uint _SaleStrip = Sales[SaleIndex]._SaleStrip;\n            uint _Start = _IS._CurrentIndex;\n            for(uint x; x < Amount; x++)\n            {\n                for(uint y; y < _SaleStrip; y++)\n                {\n                    IERC721(_IS._NFT).transferFrom(\n                        _IS._Operator, // `from`\n                        msg.sender,    // `to`\n                        _Start + y     // `tokenID`\n                    );\n                }\n                _Start += _SaleStrip;\n            }\n            SalesInternal[SaleIndex]._CurrentIndex = _IS._CurrentIndex + (_SaleStrip * Amount);\n        }\n        else { revert(\"DutchMarketplace: Incorrect Sale Configuration\"); }\n        emit Purchased(SaleIndex, Recipient, Amount, PurchaseValue, NewAmountSold, BrightListEligible, Priority, AppliedCredit);\n    }\n\n    /*------------------\n     * ADMIN FUNCTIONS *\n    -------------------*/\n\n    /**\n     * @dev Starts A Sale\n     * note: Returns SaleIndex\n     * note: The True Discount Amount Is 100 - _Sale._DiscountAmount\n     * note: Ex. _DiscountAmount = 75 = 25% Discount\n     */\n    function __StartSale(\n        Sale memory _Sale,\n        InternalSale memory _InternalSale,\n        bytes32[] calldata RootsPriority,\n        bytes32[] calldata RootsAmounts,\n        uint[] calldata DiscountAmounts\n    ) external onlyAdmin returns (uint) {\n        NFTAddressToSaleIndex[_InternalSale._NFT] = _TOTAL_UNIQUE_SALES_DUTCH;\n        Sales[_TOTAL_UNIQUE_SALES_DUTCH] = _Sale;\n        SalesInternal[_TOTAL_UNIQUE_SALES_DUTCH] = _InternalSale;\n        SaleParams[_TOTAL_UNIQUE_SALES_DUTCH] = SaleParam(RootsPriority, RootsAmounts, DiscountAmounts);\n        require(\n            _InternalSale._Type == 0 // Factory MintPass Direct Mint (most gas efficient)\n            ||\n            _InternalSale._Type == 1 // Bespoke MintPass Direct Mint (most gas efficient)\n            ||\n            _InternalSale._Type == 2 // Factory MintPack Direct Mint (most gas efficient)\n            ||\n            _InternalSale._Type == 3 // transferFrom() Sale (NFTs Already Minted) (not gas efficient)\n            ||\n            _InternalSale._Type == 4 // purchaseTo() Sale (ArtBlocks Or Custom Mint Pass) (not gas efficient)\n            ||\n            _InternalSale._Type == 5 // transferFrom() MintPack Sale (NFTs Already Minted) (not gas efficient)\n            , \"DutchMarketplace: Invalid Sale Type\"\n        );\n        require(RootsPriority.length == DiscountAmounts.length, \"DutchMarketplace: Invalid Merkle Root Length\");\n        for(uint x; x < SaleParams[_TOTAL_UNIQUE_SALES_DUTCH]._DiscountAmounts.length; x++)\n        {\n            require(DiscountAmounts[x] <= 100, \"DutchMarketplace: Invalid Discount Amount\");\n        }\n        require(Sales[_TOTAL_UNIQUE_SALES_DUTCH]._PriceStart >= Sales[_TOTAL_UNIQUE_SALES_DUTCH]._PriceEnd, \"DutchMarketplace: Invalid Start And End Prices\");\n        emit SaleStarted(_TOTAL_UNIQUE_SALES_DUTCH);\n        _TOTAL_UNIQUE_SALES_DUTCH++;\n        return (_TOTAL_UNIQUE_SALES_DUTCH - 1);\n    }\n\n    /**\n     * @dev Initiates Withdraw Of Refunds & Sale Proceeds\n     * note: This Is Only After The Sale Has Completed\n     */\n    function __InitiateRefundsAndProceeds(uint SaleIndex) external nonReentrant onlyAdmin \n    {\n        bool _TxConfirmed;\n        uint _Proceeds;\n        uint _Refund;\n        require(SaleState[SaleIndex]._FinalClearingPrice > 0, \"DutchMarketplace: Final Clearing Price Not Seeded\");\n        uint[] memory DiscountAmounts = SaleParams[SaleIndex]._DiscountAmounts;\n        for(uint OrderIndex = SaleState[SaleIndex]._CurrentRefundIndex; OrderIndex < SaleState[SaleIndex]._UniqueSales; OrderIndex++)\n        {\n            Order memory _Order = Orders[SaleIndex][OrderIndex];\n            if(!_Order._Claimed)\n            {\n                if(!_Order._BrightListPurchase) // No BrightList\n                {\n                    _Refund = _Order._PurchaseValue - (SaleState[SaleIndex]._FinalClearingPrice * _Order._PurchaseAmount);\n                    _Proceeds += _Order._PurchaseValue - _Refund;\n                    if(_Refund > 0) { (_TxConfirmed,) = _Order._Purchaser.call{ value: _Refund }(\"\"); }\n                }\n                else // BrightList\n                {\n                    _Refund = _Order._PurchaseValue - \n                    (\n                        ((SaleState[SaleIndex]._FinalClearingPrice * DiscountAmounts[_Order._Priority]) / 100)\n                        * \n                        _Order._PurchaseAmount\n                    );\n                    _Proceeds += _Order._PurchaseValue - _Refund;\n                    if(_Refund > 0) { (_TxConfirmed,) = _Order._Purchaser.call{ value: _Refund }(\"\"); }\n                }\n                if(!_TxConfirmed) { emit OrderRefundFailed(SaleIndex, OrderIndex); }\n                Orders[SaleIndex][OrderIndex]._Claimed = true;\n            }\n        }\n        (_TxConfirmed,) = _BRT_MULTISIG.call{ value: _Proceeds }(\"\"); \n        require(_TxConfirmed, \"DutchMarketplace: Multisig Refund Failed, Use Failsafe Withdraw And Manually Process\");\n        SaleState[SaleIndex]._CurrentRefundIndex = SaleState[SaleIndex]._UniqueSales; // Resets Refund Index\n    }\n\n    /*--------------*/\n    /*  ONLY OWNER  */\n    /*--------------*/\n\n    /**\n     * @dev Modifies The Sale Starting Token Index\n     * note: If `Simple` Sale, Then This Is The Current TokenID Being Transferred In The Sale\n     */\n    function ___ModifySaleStartingTokenIndex(uint SaleIndex, uint StartingTokenID) external onlyOwner\n    {\n        SalesInternal[SaleIndex]._CurrentIndex = StartingTokenID;\n    }\n\n    /**\n     * @dev Modifies The Sale Name\n     */\n    function ___ModifySaleName(uint SaleIndex, string calldata Name) external onlyOwner\n    {\n        Sales[SaleIndex]._Name = Name;\n    }\n\n    /**\n     * @dev Modifies The ArtBlocks Sale ProjectID (if applicable)\n     */\n    function ___ModifySaleProjectID(uint SaleIndex, uint ProjectID) external onlyOwner\n    {\n        Sales[SaleIndex]._ProjectIDMintPass = ProjectID;\n    }\n\n    /**\n     * @dev Modifies The Starting Price\n     */\n    function ___ModifyPriceStart(uint SaleIndex, uint PriceStart) external onlyOwner\n    {\n        Sales[SaleIndex]._PriceStart = PriceStart;\n    }\n\n    /**\n     * @dev Modifies The Ending Price\n     */\n    function ___ModifyPriceEnd(uint SaleIndex, uint PriceEnd) external onlyOwner\n    {\n        Sales[SaleIndex]._PriceEnd = PriceEnd;\n    }\n\n    /**\n     * @dev Modifies The Per-Wallet-Limiter\n     */\n    function ___ModifyMaxAmtPerPurchase(uint SaleIndex, uint MaxAmtPerPurchase) external onlyOwner\n    {\n        Sales[SaleIndex]._MaxAmtPerPurchase = MaxAmtPerPurchase;\n    }\n\n    /**\n     * @dev Modifies The Maximum NFTs For Sale\n     */\n    function ___ModifyMaxForSale(uint SaleIndex, uint AmountForSale) external onlyOwner\n    {\n        Sales[SaleIndex]._MaximumAvailableForSale = AmountForSale;\n    }\n\n    /**\n     * @dev Modifies The Starting Unix Timestamp\n     */\n    function ___ModifyTimestampStart(uint SaleIndex, uint Timestamp) external onlyOwner\n    {\n        Sales[SaleIndex]._StartingBlockUnixTimestamp = Timestamp;\n    }\n\n    /**\n     * @dev Modifies The Price Decay (Input In Seconds)\n     */\n    function ___ModifyPriceDecay(uint SaleIndex, uint PriceDecayInSeconds) external onlyOwner\n    {\n        Sales[SaleIndex]._SecondsBetweenPriceDecay = PriceDecayInSeconds;\n    }\n\n    /**\n     * @dev Modifies The Sale Discount Amount\n     * note: Ex. The True Discount Amount = 100 - `DiscountAmount`\n     * note: Ex. `DiscountAmount` = 75 | 100 - `DiscountAmount` = 25% Discount\n     */\n    function ___ModifySaleDiscountAmount(uint SaleIndex, uint[] calldata DiscountAmounts) external onlyOwner\n    {\n        for(uint x; x < DiscountAmounts.length; x++)\n        {\n            require(DiscountAmounts[x] <= 100, \"DutchMarketplace: Invalid Discount Amount\");\n            SaleParams[SaleIndex]._DiscountAmounts[x] = DiscountAmounts[x];\n        }\n    }\n\n    /**\n     * @dev Modifies The NFT Address Of A Sale\n     */\n    function ___ModifySaleNFTAddress(uint SaleIndex, address NFT) external onlyOwner\n    {\n        SalesInternal[SaleIndex]._NFT = NFT;\n    }\n\n    /**\n     * @dev Modifies The Final Clearing Price Of A Sale\n     */\n    function ___ModifySaleClearingPrice(uint SaleIndex, uint ClearingPrice) external onlyOwner\n    {\n        SaleState[SaleIndex]._FinalClearingPrice = ClearingPrice;\n    }\n\n    /**\n     * @dev Modifies The Public Active Sale State\n     */\n    function ___ModifySaleStatePublic(uint SaleIndex, bool State) external onlyOwner\n    {\n        SalesInternal[SaleIndex]._ActivePublic = State;\n    }\n\n    /**\n     * @dev Modifies The BrightList Active Sale State\n     */\n    function ___ModifySaleStateBrightList(uint SaleIndex, bool State) external onlyOwner\n    {\n        SalesInternal[SaleIndex]._ActiveBrightList = State;\n    }\n\n    /**\n     * @dev Modifies The State Of ETH Claims\n     * note: onlyOwner: This Enables Users To Claim ETH Rebate Pending In The Contract Before The Sale Concludes\n     */\n    function ___ModifySaleETHClaimsEnabled(uint SaleIndex, bool State) external onlyOwner\n    {\n        SalesInternal[SaleIndex]._ActiveRespend = State;\n    }\n\n    /**\n     * @dev onlyOwner: Modifies The Merkle Root(s) For Amounts\n     */\n    function ___ModifySaleRootAmounts(uint SaleIndex, bytes32[] calldata RootsAmounts) external onlyOwner\n    {\n        SaleParams[SaleIndex]._RootsAmounts = RootsAmounts;\n    }\n\n    /**\n     * @dev onlyOwner: Modifies The Merkle Root(s) For Eligibility\n     */\n    function ___ModifySaleRootEligibility(uint SaleIndex, bytes32[] calldata Roots) external onlyOwner\n    {\n        SaleParams[SaleIndex]._Roots = Roots;\n    }\n\n    /**\n     * @dev Modifies The Sale Root(s) For Merkle Eligibility & Amounts\n     */\n    function ___ModifySaleRoots(uint SaleIndex, bytes32[] calldata RootsEligibility, bytes32[] calldata RootsAmounts) external onlyOwner\n    {\n        SaleParams[SaleIndex]._Roots = RootsEligibility;\n        SaleParams[SaleIndex]._RootsAmounts = RootsAmounts;\n    }\n\n    /**\n     * @dev onlyOwner: Modifies Sale\n     */\n    function ___ModifySale(uint SaleIndex, Sale memory _Sale) external onlyOwner { Sales[SaleIndex] = _Sale; }\n\n    /**\n     * @dev Modifies The Sale Operator\n     */\n    function ___ModifySaleOperator(uint SaleIndex, address Operator) external onlyOwner { SalesInternal[SaleIndex]._Operator = Operator; }\n\n    /**\n     * @dev onlyOwner: Grants Admin Role\n     */\n    function ___AdminGrant(address _Admin) external onlyOwner { Admin[_Admin] = true; }\n\n    /**\n     * @dev onlyOwner: Removes Admin Role\n     */\n    function ___AdminRemove(address _Admin) external onlyOwner { Admin[_Admin] = false; }\n\n    /**\n     * @dev onlyOwner: Withdraws All Ether From The Contract\n     */\n    function ___WithdrawEther() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }\n\n    /**\n     * @dev onlyOwner: Withdraws Ether From Contract To Address With An Amount\n     */\n    function ___WithdrawEtherToAddress(address payable Recipient, uint Amount) external onlyOwner\n    {\n        require(Amount > 0 && Amount <= address(this).balance, \"Invalid Amount\");\n        (bool Success, ) = Recipient.call{value: Amount}(\"\");\n        require(Success, \"Unable to Withdraw, Recipient May Have Reverted\");\n    }\n\n    /**\n     * @dev Withdraws ERC721s From Contract\n     */\n    function ___WithdrawERC721(address Contract, address Recipient, uint[] calldata TokenIDs) external onlyOwner \n    { \n        for(uint TokenID; TokenID < TokenIDs.length;)\n        {\n            IERC721(Contract).transferFrom(address(this), Recipient, TokenIDs[TokenID]);\n            unchecked { TokenID++; }\n        }\n    }\n\n    /*-----------------\n     * VIEW FUNCTIONS *\n    ------------------*/\n\n    /**\n     * @dev Returns Sale Information For A Given Wallet At `SaleIndex`\n     * @param SaleIndex        | The Sale Index\n     * @param Wallet           | The Currently Connected Wallet\n     * @param MaxAmount        | The Max Amount Of Tokens The User Can Purchase\n     * @param Vault            | The Vault Address\n     * @param ProofEligibility | The Proof For The BrightList\n     * @param ProofAmount      | The Proof For The MaxAmount\n     */\n    function ViewWalletSaleInformation (\n        uint SaleIndex,\n        address Wallet,\n        uint MaxAmount,\n        address Vault,\n        bytes32[] calldata ProofEligibility,\n        bytes32[] calldata ProofAmount\n    ) public view returns ( _UserSaleInformation memory ) {\n        uint[] memory PriorityPurchaseAmounts = new uint[](SaleParams[SaleIndex]._Roots.length);\n        uint CurrentPrice = __ViewCurrentPrice(SaleIndex);\n        uint PurchasableAmount;\n        uint Priority;\n        bool Verified;\n        bool VerifiedAmount;\n        bool Active = SalesInternal[SaleIndex]._ActiveBrightList || SalesInternal[SaleIndex]._ActivePublic;\n        bool ActiveRespend = SalesInternal[SaleIndex]._ActiveRespend;\n        uint Credit = ViewPendingCredit(SaleIndex, Wallet);\n        uint UserPurchasedAmount = UserInfo[SaleIndex][Wallet]._PurchasedAmount;\n        if(Vault != address(0)) { if(IDelegationRegistry(_DN).checkDelegateForAll(Wallet, Vault)) { Wallet = Vault; } }\n        for(uint x; x < SaleParams[SaleIndex]._Roots.length; x++) \n        { \n            PriorityPurchaseAmounts[x] = PriorityPurchaseAmount[SaleIndex][Wallet][x]; \n        }\n        if(MaxAmount < UserPurchasedAmount) { MaxAmount = UserPurchasedAmount; }\n        PurchasableAmount = MaxAmount - UserPurchasedAmount;\n        (Verified, Priority) = ViewBrightListStatus(SaleIndex, Wallet, ProofEligibility);\n        if(Verified) { VerifiedAmount = __VerifyAmount(Wallet, MaxAmount, SaleParams[SaleIndex]._RootsAmounts[Priority], ProofAmount); }\n        return (\n            _UserSaleInformation (\n                UserInfo[SaleIndex][Wallet]._UserOrderIndexes,                                // The User's Order Indexes\n                PriorityPurchaseAmounts,                                                      // The User's Purchase Amounts Corresponding To Priority \n                UserPurchasedAmount,                                                          // The User's Total Purchase Amount For `SaleIndex`\n                PurchasableAmount,                                                            // The User's Purchasable Amount                          \n                UserInfo[SaleIndex][Wallet]._ClaimIndex,                                      // The User's Claim Index\n                Sales[SaleIndex]._MaximumAvailableForSale - SaleState[SaleIndex]._AmountSold, // The Remaining Amount Available For Sale\n                CurrentPrice,                                                                 // The Current Price Of A Sale\n                Priority,                                                                     // The Priority The User Is Eligible For\n                Credit,                                                                       // The User's Pending Credit Available To Use Towards Next Purchase\n                Verified,                                                                     // If The User Is Eligible For BrightList\n                VerifiedAmount,                                                               // If The User Is Eligible For The MaxAmount\n                ActiveRespend,                                                                // If ActiveRespend Credit Is Active\n                Active                                                                        // If The Sale Is Active\n            )\n        );\n    }\n    \n    /**\n     * @dev Batch Returns Multiple Sale Informations For A User\n     */\n    function ViewWalletSaleInformations (\n        uint[] calldata SaleIndexes, \n        address Wallet, \n        uint[] calldata MaxAmounts, \n        address Vault, \n        bytes32[][] calldata ProofEligibilities, \n        bytes32[][] calldata ProofAmounts\n    ) public view returns(_UserSaleInformation[] memory) {\n        require(\n            SaleIndexes.length == MaxAmounts.length \n            && \n            MaxAmounts.length == ProofEligibilities.length \n            && \n            ProofEligibilities.length == ProofAmounts.length, \n            \"DutchMarketplace: Array Lengths Must Match\"\n        );\n        _UserSaleInformation[] memory _UserSaleInformations = new _UserSaleInformation[](SaleIndexes.length);\n        for(uint x; x < SaleIndexes.length; x++)\n        {\n            _UserSaleInformations[x] = ViewWalletSaleInformation (\n                SaleIndexes[x],\n                Wallet,\n                MaxAmounts[x],\n                Vault,\n                ProofEligibilities[x],\n                ProofAmounts[x]\n            );\n        }\n        return _UserSaleInformations;\n    }\n\n    /**\n     * @dev Returns All Orders Of `SaleIndex` Within A Range `StartingIndex` & `EndingIndex` Inclusive\n     */\n    function ViewOrders(uint SaleIndex) external view returns (Order[] memory) { return Orders[SaleIndex]; }\n\n    /**\n     * @dev Returns All Orders Of `SaleIndex` Within A Range `StartingIndex` & `EndingIndex` Inclusive\n     */\n    function ViewOrdersInRange(uint SaleIndex, uint StartingIndex, uint EndingIndex) external view returns (Order[] memory) \n    { \n        uint Range = EndingIndex - StartingIndex;\n        Order[] memory _Orders = new Order[](Range);\n        for(uint x; x < Range; x++) { _Orders[x] = Orders[SaleIndex][StartingIndex+x]; }\n        return _Orders; \n    }\n\n    /**\n     * @dev Returns A [][] Of All Orders On Multiple SaleIndexes Within A Range `StartingIndex` & `EndingIndex` Inclusive\n     */\n    function ViewAllOrders(uint[] calldata SaleIndexes, uint StartingIndex, uint EndingIndex) external view returns (Order[][] memory)\n    {\n        Order[][] memory __Orders = new Order[][](EndingIndex-StartingIndex);\n        for(uint SaleIndex; SaleIndex <= SaleIndexes.length; SaleIndex++) { __Orders[SaleIndex] = Orders[SaleIndex]; }\n        return __Orders;\n    }\n\n    /**\n     * @dev Returns Sale Index By NFT Contract Address\n     */\n    function ViewSaleIndexByNFTAddress(address NFT) public view returns (uint)\n    {\n        uint SaleIndex = NFTAddressToSaleIndex[NFT];\n        if(SaleIndex != 0) { return SaleIndex; }\n        return 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff; // type(uint).max\n    }\n\n    /**\n     * @dev Returns an [] Of Sale States\n     */\n    function ViewSaleStates(uint[] calldata SaleIndexes) public view returns (Sale[] memory, Info[] memory)\n    {\n        Sale[] memory _Sales = new Sale[](SaleIndexes.length);\n        Info[] memory _Infos = new Info[](SaleIndexes.length);\n        bool Active;\n        for(uint x; x < SaleIndexes.length; x++) \n        { \n            Active = SalesInternal[SaleIndexes[x]]._ActivePublic || SalesInternal[SaleIndexes[x]]._ActiveBrightList;\n            _Sales[x] = Sales[SaleIndexes[x]]; \n            _Infos[x] = Info(\n                __ViewCurrentPrice(SaleIndexes[x]),\n                Sales[SaleIndexes[x]]._MaximumAvailableForSale,\n                Sales[SaleIndexes[x]]._MaximumAvailableForSale - SaleState[SaleIndexes[x]]._AmountSold,\n                Active\n            );\n        }\n        return (_Sales, _Infos);\n    }\n\n    /**\n     * @dev Returns The Current Pending Credit / Rebate Of A User (With No Discount) Until The Sale Has Concluded.\n     * note: When The Final Clearing Price Is Seeded, This Function Switches To Show The User's Final Rebate (With Discounts If Eligible)\n     */\n    function ViewPendingCredit(uint SaleIndex, address Wallet) public view returns (uint)\n    {\n        uint CurrentPrice = __ViewCurrentPrice(SaleIndex);\n        uint TotalCredit;\n        uint FinalClearingPrice = SaleState[SaleIndex]._FinalClearingPrice;\n        uint[] memory _UserOrderIndexes = UserInfo[SaleIndex][Wallet]._UserOrderIndexes;\n        uint[] memory _DiscountAmounts = SaleParams[SaleIndex]._DiscountAmounts;\n        for(uint ClaimIndex; ClaimIndex < _UserOrderIndexes.length; ClaimIndex++)\n        {\n            Order memory _Order = Orders[SaleIndex][_UserOrderIndexes[ClaimIndex]];\n            if(FinalClearingPrice > 0 && _Order._BrightListPurchase) \n            {\n                TotalCredit += _Order._PurchaseValue - \n                (\n                    ((SaleState[SaleIndex]._FinalClearingPrice * _DiscountAmounts[_Order._Priority]) / 100)\n                    * \n                    _Order._PurchaseAmount\n                );\n            }\n            else { TotalCredit += (_Order._PurchaseValue - (_Order._PurchaseAmount * CurrentPrice)); }\n        }\n        return TotalCredit;\n    }\n\n    /**\n     * @dev Returns An [] Of Internal Sale States\n     */\n    function ViewInternalSaleStates(uint[] calldata SaleIndexes) public view returns (InternalSale[] memory)\n    {\n        InternalSale[] memory _InternalSales = new InternalSale[](SaleIndexes.length);\n        for(uint x; x < SaleIndexes.length; x++) { _InternalSales[x] = SalesInternal[SaleIndexes[x]]; }\n        return _InternalSales;\n    }\n\n    /**\n     * @dev Returns All Order Information Including Addresses And Corresponding Refund Amounts\n     */\n    function ViewAllOrderRefunds(uint SaleIndex) public view returns (address[] memory, uint[] memory)\n    {\n        address[] memory Addresses = new address[](SaleState[SaleIndex]._UniqueSales);\n        uint[] memory Refunds = new uint[](SaleState[SaleIndex]._UniqueSales);\n        uint[] memory DiscountAmounts = SaleParams[SaleIndex]._DiscountAmounts;\n        uint CurrentPrice = __ViewCurrentPrice(SaleIndex);\n        Order memory _Order;\n        for(uint OrderIndex; OrderIndex < SaleState[SaleIndex]._UniqueSales; OrderIndex++)\n        {\n            _Order = Orders[SaleIndex][OrderIndex];\n            if(_Order._BrightListPurchase)\n            {\n                Refunds[OrderIndex] = _Order._PurchaseValue - (\n                    ((SaleState[SaleIndex]._FinalClearingPrice * DiscountAmounts[_Order._Priority]) / 100) * _Order._PurchaseAmount\n                );\n            }\n            else { Refunds[OrderIndex] = _Order._PurchaseValue - (CurrentPrice * _Order._PurchaseAmount); }\n            Addresses[OrderIndex] = _Order._Purchaser;\n        }\n        return(Addresses, Refunds);\n    }\n\n    /**\n     * @dev Returns A User's Sale Stats Including Total Amount Purchased, Total Amount Spent, And Total Amount Rebated\n     * note: This Function Will Only Return Wallet Stats For A Sale That Has Concluded\n     * note: `NUM_ORDERS` Is The Final Cumulative Order Count Of `Wallet`\n     * note: `NUM_PURCHASED` Is The Total Number Of NFTs Purchased At `SaleIndex` By `Wallet`\n     * note: `FINAL_ETH_SPENT` Is The Cumulative Expended ETH Value From `Wallet` At The Conclusion Of The Sale Based On The Final Clearing Price Of The Dutch Auction\n     * note: `FINAL_ETH_REBATE` Is The Cumulative Unspent ETH That Is Rebated To `Wallet` At The Conclusion Of The Sale Based On The Final Clearing Price Of The Dutch Auction\n     * note: ETH Values Are Returned In WEI\n     * note: This Function Was A Request From The Keith Who Loves Vapes\n     */\n    function ViewSaleStats(uint SaleIndex, address Wallet) public view returns (uint NUM_ORDERS, uint NUM_PURCHASED, uint FINAL_ETH_SPENT, uint FINAL_ETH_REBATE)\n    {\n        require(SaleState[SaleIndex]._FinalClearingPrice > 0, \"Sale Not Concluded\");\n        uint CurrentPrice = __ViewCurrentPrice(SaleIndex);\n        uint FinalRebate;\n        uint Spent;\n        uint NumPurchased;\n        uint OrderRebate;\n        uint FinalClearingPrice = SaleState[SaleIndex]._FinalClearingPrice; // Retrieves The Final Clearing Price\n        uint[] memory _UserOrderIndexes = UserInfo[SaleIndex][Wallet]._UserOrderIndexes; // Retrieves The User's Purchase Order Indexes\n        uint NumOrders = _UserOrderIndexes.length;\n        uint[] memory _DiscountAmounts = SaleParams[SaleIndex]._DiscountAmounts;\n        for(uint ClaimIndex; ClaimIndex < _UserOrderIndexes.length; ClaimIndex++)\n        {\n            Order memory _Order = Orders[SaleIndex][_UserOrderIndexes[ClaimIndex]];\n            if(FinalClearingPrice > 0 && _Order._BrightListPurchase) // brightlist priority discount\n            {\n                OrderRebate = _Order._PurchaseValue - \n                (\n                    ((SaleState[SaleIndex]._FinalClearingPrice * _DiscountAmounts[_Order._Priority]) / 100)\n                    * \n                    _Order._PurchaseAmount\n                );\n            }\n            else { OrderRebate = (_Order._PurchaseValue - (_Order._PurchaseAmount * CurrentPrice));  } // no discount\n            FinalRebate += OrderRebate;\n            Spent += (_Order._PurchaseValue - OrderRebate);\n            NumPurchased += _Order._PurchaseAmount;\n        }\n        return (NumOrders, NumPurchased, Spent, FinalRebate);\n    }\n\n    /**\n     * @dev Returns All State Parameters Of A Sale\n     */\n    function ViewAllSaleInformation(uint SaleIndex) public view returns (Sale memory, InternalSale memory, MiscSale memory, SaleParam memory, uint Price) \n    {\n        return ( Sales[SaleIndex], SalesInternal[SaleIndex], SaleState[SaleIndex], SaleParams[SaleIndex], __ViewCurrentPrice(SaleIndex) );\n    }\n\n    /**\n     * @dev Returns If User Is On BrightList\n     * note: Returns BrightList Status & Best Priority Index\n     */\n    function ViewBrightListStatus(uint SaleIndex, address Recipient, bytes32[] calldata Proof) public view returns (bool, uint)\n    {\n        bool Verified;\n        bytes32 Leaf = keccak256(abi.encodePacked(Recipient));\n        for(uint PriorityIndex; PriorityIndex < SaleParams[SaleIndex]._Roots.length; PriorityIndex++) \n        { \n            Verified = MerkleProof.verify(Proof, SaleParams[SaleIndex]._Roots[PriorityIndex], Leaf); \n            if(Verified) { return (true, PriorityIndex); }\n        }\n        return (false, _DEFAULT_PRIORITY);\n    }\n\n    /*---------------------\n     * INTERNAL FUNCTIONS *\n    ----------------------*/\n\n    /**\n     * @dev Verifies Maximum Purchase Amount Being Passed Is Valid\n     */\n    function __VerifyAmount(address _Wallet, uint _Amount, bytes32 _Root, bytes32[] calldata _Proof) internal pure returns (bool)\n    {\n        bytes32 _Leaf = (keccak256(abi.encodePacked(_Wallet, _Amount)));\n        return MerkleProof.verify(_Proof, _Root, _Leaf);\n    }\n\n    /**\n     * @dev Returns Current Dutch Price For Sale Index\n     */\n    function __ViewCurrentPrice(uint SaleIndex) internal view returns (uint Price)\n    {\n        if(block.timestamp <= Sales[SaleIndex]._StartingBlockUnixTimestamp) { return Sales[SaleIndex]._PriceStart; }  // Sale Not Started\n        if(SaleState[SaleIndex]._FinalClearingPrice > 0) { return SaleState[SaleIndex]._FinalClearingPrice; } // Sale Finished\n        uint CurrentPrice = Sales[SaleIndex]._PriceStart; // Initiates Current Price\n        uint SecondsElapsed = block.timestamp - Sales[SaleIndex]._StartingBlockUnixTimestamp; // Unix Seconds Elapsed At Current Query Timestamp\n        CurrentPrice >>= SecondsElapsed / Sales[SaleIndex]._SecondsBetweenPriceDecay; // Div/2 For Each Half Life Iterated Upon\n        CurrentPrice -= (CurrentPrice * (SecondsElapsed % Sales[SaleIndex]._SecondsBetweenPriceDecay)) / Sales[SaleIndex]._SecondsBetweenPriceDecay / 2;\n        if(CurrentPrice <= Sales[SaleIndex]._PriceEnd) { return Sales[SaleIndex]._PriceEnd; } // Sale Ended At Resting Band\n        return CurrentPrice; // Sale Currently Active\n    }\n\n    /**\n     * @dev Ends A Sale\n     */\n    function __EndSale(uint SaleIndex) internal \n    { \n        SalesInternal[SaleIndex]._ActivePublic = false; \n        SalesInternal[SaleIndex]._ActiveBrightList = false;\n    }\n\n    /**\n     * @dev Refunds `Recipient` ETH Amount `Value`\n     */\n    function __Refund(address Recipient, uint Value) internal\n    {\n        (bool Confirmed,) = Recipient.call{value: Value}(\"\"); \n        require(Confirmed, \"DutchMarketplace: Refund Failed\");\n        emit Refunded(Value);\n    }\n\n    /**\n     * @dev Uses ETH Unspent By A User's Previous Purchase Orders Towards A New Purchase Order\n     */\n    function __ActiveRespend(uint SaleIndex, uint CurrentPrice, uint PurchaseValue, address Recipient) internal returns (uint)\n    {\n        uint TotalCredit;\n        uint PotentialCredit;\n        uint[] memory _UserOrderIndexes = UserInfo[SaleIndex][Recipient]._UserOrderIndexes;\n        for(uint ClaimIndex; ClaimIndex < _UserOrderIndexes.length; ClaimIndex++)\n        {\n            Order memory _Order = Orders[SaleIndex][_UserOrderIndexes[ClaimIndex]];\n            require(Recipient == _Order._Purchaser, \"DutchMarketplace: Invalid State\");\n            if(TotalCredit == PurchaseValue) { return TotalCredit; } // Returns Sufficient Credit For Entire Purchase Order\n            else\n            {\n                PotentialCredit = _Order._PurchaseValue - (_Order._PurchaseAmount * CurrentPrice); \n                if(PotentialCredit + TotalCredit > PurchaseValue) { PotentialCredit = PurchaseValue - TotalCredit; } // Only Pull As Much Credit As Needed\n                Orders[SaleIndex][_UserOrderIndexes[ClaimIndex]]._PurchaseValue = _Order._PurchaseValue - PotentialCredit;\n                TotalCredit += PotentialCredit;\n            }\n        }\n        return TotalCredit; // Returns The Total Amount Of Credit Available\n    }\n\n    /*------------------\n     * ACCESS MODIFIER *\n    -------------------*/\n\n    modifier onlyAdmin\n    {\n        require(Admin[msg.sender] || msg.sender == _LAUNCHPAD || msg.sender == owner());\n        _;\n    }\n}\n\ninterface IERC20 { function approve(address From, address To, uint Amount) external; }\n\ninterface IERC721 \n{ \n    /**\n     * @dev MintPass Factory Direct Mint\n     */\n    function _MintToFactory(uint ProjectID, address To, uint Amount) external;\n\n    /**\n     * @dev MintPass Factory Mint Pack Direct Mint\n     */\n    function _MintToFactoryPack(uint ProjectID, address To, uint Amount) external;\n\n    /**\n     * @dev MintPass Factory Mint Pack Direct Mint For Bespoke Mint Passes\n     */\n    function _MintToBespoke(address To, uint Amount) external;\n\n    /**\n     * @dev Standard ERC721 Transfer\n     */\n    function transferFrom(address From, address To, uint TokenID) external; \n\n    /**\n     * @dev ArtBlocks purchaseTo() Function\n     */\n    function purchaseTo(address _to, uint _projectID) external payable returns (uint _tokenId);\n}\ninterface IDelegationRegistry\n{\n    /**\n     * @dev Checks If A Vault Has Delegated To The Delegate\n     */\n    function checkDelegateForAll(address delegate, address delegator) external view returns (bool);\n}"}, "contracts/ERC2981.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/common/ERC2981.sol)\n\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/interfaces/IERC2981.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\n *\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\n *\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\n * fee is specified in basis points by default.\n *\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\n *\n * _Available since v4.5._\n */\nabstract contract ERC2981 is IERC2981, ERC165 {\n    struct RoyaltyInfo {\n        address receiver;\n        uint96 royaltyFraction;\n    }\n\n    RoyaltyInfo private _defaultRoyaltyInfo;\n    mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @inheritdoc IERC2981\n     */\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) public view virtual override returns (address, uint256) {\n        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[_tokenId];\n\n        if (royalty.receiver == address(0)) {\n            royalty = _defaultRoyaltyInfo;\n        }\n\n        uint256 royaltyAmount = (_salePrice * royalty.royaltyFraction) / _feeDenominator();\n\n        return (royalty.receiver, royaltyAmount);\n    }\n\n    /**\n     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a\n     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an\n     * override.\n     */\n    function _feeDenominator() internal pure virtual returns (uint96) {\n        return 10000;\n    }\n\n    /**\n     * @dev Sets the royalty information that all ids in this contract will default to.\n     *\n     * Requirements:\n     *\n     * - `receiver` cannot be the zero address.\n     * - `feeNumerator` cannot be greater than the fee denominator.\n     */\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\n        require(feeNumerator <= _feeDenominator(), \"ERC2981: royalty fee will exceed salePrice\");\n        require(receiver != address(0), \"ERC2981: invalid receiver\");\n\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\n    }\n\n    /**\n     * @dev Removes default royalty information.\n     */\n    function _deleteDefaultRoyalty() internal virtual {\n        delete _defaultRoyaltyInfo;\n    }\n\n    /**\n     * @dev Sets the royalty information for a specific token id, overriding the global default.\n     *\n     * Requirements:\n     *\n     * - `receiver` cannot be the zero address.\n     * - `feeNumerator` cannot be greater than the fee denominator.\n     */\n    function _setTokenRoyalty(\n        uint256 tokenId,\n        address receiver,\n        uint96 feeNumerator\n    ) internal virtual {\n        require(feeNumerator <= _feeDenominator(), \"ERC2981: royalty fee will exceed salePrice\");\n        require(receiver != address(0), \"ERC2981: Invalid parameters\");\n\n        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\n    }\n\n    /**\n     * @dev Resets royalty information for the token id back to the global default.\n     */\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\n        delete _tokenRoyaltyInfo[tokenId];\n    }\n}\n"}, "contracts/ERC721A.sol": {"content": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v3.3.0\n// Creator: Chiru Labs\n\npragma solidity ^0.8.30;\n\nimport './IERC721A.sol';\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '@openzeppelin/contracts/utils/Context.sol';\nimport '@openzeppelin/contracts/utils/Strings.sol';\nimport '@openzeppelin/contracts/utils/introspection/ERC165.sol';\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension. Built to optimize for lower gas during batch mints.\n *\n * Assumes serials are sequentially minted starting at _startTokenId() (defaults to 0, e.g. 0, 1, 2, 3..).\n *\n * Assumes that an owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\n *\n * Assumes that the maximum token id cannot exceed 2**256 - 1 (max value of uint256).\n */\ncontract ERC721A is Context, ERC165, IERC721A {\n    using Address for address;\n    using Strings for uint256;\n\n    // The tokenId of the next token to be minted.\n    uint256 internal _currentIndex;\n\n    // The number of tokens burned.\n    uint256 internal _burnCounter;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to ownership details\n    // An empty struct value does not necessarily mean the token is unowned. See _ownershipOf implementation for details.\n    mapping(uint256 => TokenOwnership) internal _ownerships;\n\n    // Mapping owner address to address data\n    mapping(address => AddressData) private _addressData;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _currentIndex = _startTokenId();\n    }\n\n    /**\n     * To change the starting tokenId, please override this function.\n     */\n    function _startTokenId() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev Burned tokens are calculated here, use _totalMinted() if you want to count just minted tokens.\n     */\n    function totalSupply() public view override returns (uint256) {\n        // Counter underflow is impossible as _burnCounter cannot be incremented\n        // more than _currentIndex - _startTokenId() times\n        unchecked {\n            return _currentIndex - _burnCounter - _startTokenId();\n        }\n    }\n\n    /**\n     * Returns the total amount of tokens minted in the contract.\n     */\n    function _totalMinted() internal view returns (uint256) {\n        // Counter underflow is impossible as _currentIndex does not decrement,\n        // and it is initialized to _startTokenId()\n        unchecked {\n            return _currentIndex - _startTokenId();\n        }\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view override returns (uint256) {\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\n        return uint256(_addressData[owner].balance);\n    }\n\n    /**\n     * Returns the number of tokens minted by `owner`.\n     */\n    function _numberMinted(address owner) internal view returns (uint256) {\n        return uint256(_addressData[owner].numberMinted);\n    }\n\n    /**\n     * Returns the number of tokens burned by or on behalf of `owner`.\n     */\n    function _numberBurned(address owner) internal view returns (uint256) {\n        return uint256(_addressData[owner].numberBurned);\n    }\n\n    /**\n     * Returns the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\n     */\n    function _getAux(address owner) internal view returns (uint64) {\n        return _addressData[owner].aux;\n    }\n\n    /**\n     * Sets the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\n     * If there are multiple variables, please pack them into a uint64.\n     */\n    function _setAux(address owner, uint64 aux) internal {\n        _addressData[owner].aux = aux;\n    }\n\n    /**\n     * Gas spent here starts off proportional to the maximum mint batch size.\n     * It gradually moves to O(1) as tokens get transferred around in the collection over time.\n     */\n    function _ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {\n        uint256 curr = tokenId;\n\n        unchecked {\n            if (_startTokenId() <= curr) if (curr < _currentIndex) {\n                TokenOwnership memory ownership = _ownerships[curr];\n                if (!ownership.burned) {\n                    if (ownership.addr != address(0)) {\n                        return ownership;\n                    }\n                    // Invariant:\n                    // There will always be an ownership that has an address and is not burned\n                    // before an ownership that does not have an address and is not burned.\n                    // Hence, curr will not underflow.\n                    while (true) {\n                        curr--;\n                        ownership = _ownerships[curr];\n                        if (ownership.addr != address(0)) {\n                            return ownership;\n                        }\n                    }\n                }\n            }\n        }\n        revert OwnerQueryForNonexistentToken();\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view override returns (address) {\n        return _ownershipOf(tokenId).addr;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), '.json')) : '';\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return '';\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public override {\n        address owner = ERC721A.ownerOf(tokenId);\n        if (to == owner) revert ApprovalToCurrentOwner();\n\n        if (_msgSender() != owner) if(!isApprovedForAll(owner, _msgSender())) {\n            revert ApprovalCallerNotOwnerNorApproved();\n        }\n\n        _approve(to, tokenId, owner);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view override returns (address) {\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        if (operator == _msgSender()) revert ApproveToCaller();\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, '');\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        _transfer(from, to, tokenId);\n        if (to.isContract()) if(!_checkContractOnERC721Received(from, to, tokenId, _data)) {\n            revert TransferToNonERC721ReceiverImplementer();\n        }\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        return _startTokenId() <= tokenId && tokenId < _currentIndex && !_ownerships[tokenId].burned;\n    }\n\n    /**\n     * @dev Equivalent to `_safeMint(to, quantity, '')`.\n     */\n    function _safeMint(address to, uint256 quantity) internal {\n        _safeMint(to, quantity, '');\n    }\n\n    /**\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement\n     *   {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(\n        address to,\n        uint256 quantity,\n        bytes memory _data\n    ) internal {\n        uint256 startTokenId = _currentIndex;\n        if (to == address(0)) revert MintToZeroAddress();\n        if (quantity == 0) revert MintZeroQuantity();\n\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\n\n        // Overflows are incredibly unrealistic.\n        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1\n        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1\n        unchecked {\n            _addressData[to].balance += uint64(quantity);\n            _addressData[to].numberMinted += uint64(quantity);\n\n            _ownerships[startTokenId].addr = to;\n            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);\n\n            uint256 updatedIndex = startTokenId;\n            uint256 end = updatedIndex + quantity;\n\n            if (to.isContract()) {\n                do {\n                    emit Transfer(address(0), to, updatedIndex);\n                    if (!_checkContractOnERC721Received(address(0), to, updatedIndex++, _data)) {\n                        revert TransferToNonERC721ReceiverImplementer();\n                    }\n                } while (updatedIndex < end);\n                // Reentrancy protection\n                if (_currentIndex != startTokenId) revert();\n            } else {\n                do {\n                    emit Transfer(address(0), to, updatedIndex++);\n                } while (updatedIndex < end);\n            }\n            _currentIndex = updatedIndex;\n        }\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\n    }\n\n    /**\n     * @dev Mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 quantity) internal {\n        uint256 startTokenId = _currentIndex;\n        if (to == address(0)) revert MintToZeroAddress();\n        if (quantity == 0) revert MintZeroQuantity();\n\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\n\n        // Overflows are incredibly unrealistic.\n        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1\n        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1\n        unchecked {\n            _addressData[to].balance += uint64(quantity);\n            _addressData[to].numberMinted += uint64(quantity);\n\n            _ownerships[startTokenId].addr = to;\n            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);\n\n            uint256 updatedIndex = startTokenId;\n            uint256 end = updatedIndex + quantity;\n\n            do {\n                emit Transfer(address(0), to, updatedIndex++);\n            } while (updatedIndex < end);\n\n            _currentIndex = updatedIndex;\n        }\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) private {\n        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);\n\n        if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();\n\n        bool isApprovedOrOwner = (_msgSender() == from ||\n            isApprovedForAll(from, _msgSender()) ||\n            getApproved(tokenId) == _msgSender());\n\n        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\n        if (to == address(0)) revert TransferToZeroAddress();\n\n        _beforeTokenTransfers(from, to, tokenId, 1);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId, from);\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\n        unchecked {\n            _addressData[from].balance -= 1;\n            _addressData[to].balance += 1;\n\n            TokenOwnership storage currSlot = _ownerships[tokenId];\n            currSlot.addr = to;\n            currSlot.startTimestamp = uint64(block.timestamp);\n\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\n            uint256 nextTokenId = tokenId + 1;\n            TokenOwnership storage nextSlot = _ownerships[nextTokenId];\n            if (nextSlot.addr == address(0)) {\n                // This will suffice for checking _exists(nextTokenId),\n                // as a burned slot cannot contain the zero address.\n                if (nextTokenId != _currentIndex) {\n                    nextSlot.addr = from;\n                    nextSlot.startTimestamp = prevOwnership.startTimestamp;\n                }\n            }\n        }\n\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfers(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Equivalent to `_burn(tokenId, false)`.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        _burn(tokenId, false);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\n        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);\n\n        address from = prevOwnership.addr;\n\n        if (approvalCheck) {\n            bool isApprovedOrOwner = (_msgSender() == from ||\n                isApprovedForAll(from, _msgSender()) ||\n                getApproved(tokenId) == _msgSender());\n\n            if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\n        }\n\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId, from);\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\n        unchecked {\n            AddressData storage addressData = _addressData[from];\n            addressData.balance -= 1;\n            addressData.numberBurned += 1;\n\n            // Keep track of who burned the token, and the timestamp of burning.\n            TokenOwnership storage currSlot = _ownerships[tokenId];\n            currSlot.addr = from;\n            currSlot.startTimestamp = uint64(block.timestamp);\n            currSlot.burned = true;\n\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the burn initiator owns it.\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\n            uint256 nextTokenId = tokenId + 1;\n            TokenOwnership storage nextSlot = _ownerships[nextTokenId];\n            if (nextSlot.addr == address(0)) {\n                // This will suffice for checking _exists(nextTokenId),\n                // as a burned slot cannot contain the zero address.\n                if (nextTokenId != _currentIndex) {\n                    nextSlot.addr = from;\n                    nextSlot.startTimestamp = prevOwnership.startTimestamp;\n                }\n            }\n        }\n\n        emit Transfer(from, address(0), tokenId);\n        _afterTokenTransfers(from, address(0), tokenId, 1);\n\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\n        unchecked {\n            _burnCounter++;\n        }\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(\n        address to,\n        uint256 tokenId,\n        address owner\n    ) private {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkContractOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n            return retval == IERC721Receiver(to).onERC721Received.selector;\n        } catch (bytes memory reason) {\n            if (reason.length == 0) {\n                revert TransferToNonERC721ReceiverImplementer();\n            } else {\n                assembly {\n                    revert(add(32, reason), mload(reason))\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.\n     * And also called before burning one token.\n     *\n     * startTokenId - the first token id to be transferred\n     * quantity - the amount to be transferred\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, `tokenId` will be burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _beforeTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes\n     * minting.\n     * And also called after one token has been burned.\n     *\n     * startTokenId - the first token id to be transferred\n     * quantity - the amount to be transferred\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` has been minted for `to`.\n     * - When `to` is zero, `tokenId` has been burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _afterTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n}\n"}, "contracts/ERC721AO.sol": {"content": "// SPDX-License-Identifier: MIT\n// ERC721AO Contracts v3.3.0\n// Creator: Chiru Labs\n\npragma solidity ^0.8.30;\n\nimport './IERC721A.sol';\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '@openzeppelin/contracts/utils/Context.sol';\nimport '@openzeppelin/contracts/utils/Strings.sol';\nimport '@openzeppelin/contracts/utils/introspection/ERC165.sol';\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension. Built to optimize for lower gas during batch mints.\n *\n * Assumes serials are sequentially minted starting at _startTokenId() (defaults to 0, e.g. 0, 1, 2, 3..).\n *\n * Assumes that an owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\n *\n * Assumes that the maximum token id cannot exceed 2**256 - 1 (max value of uint256).\n */\ncontract ERC721AO is Context, ERC165, IERC721A {\n    using Address for address;\n    using Strings for uint256;\n\n    // The tokenId of the next token to be minted.\n    uint256 internal _currentIndex;\n\n    // The number of tokens burned.\n    uint256 internal _burnCounter;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to ownership details\n    // An empty struct value does not necessarily mean the token is unowned. See _ownershipOf implementation for details.\n    mapping(uint256 => TokenOwnership) internal _ownerships;\n\n    // Mapping owner address to address data\n    mapping(address => AddressData) private _addressData;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _currentIndex = _startTokenId();\n    }\n\n    /**\n     * To change the starting tokenId, please override this function.\n     */\n    function _startTokenId() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev Burned tokens are calculated here, use _totalMinted() if you want to count just minted tokens.\n     */\n    function totalSupply() public view override returns (uint256) {\n        // Counter underflow is impossible as _burnCounter cannot be incremented\n        // more than _currentIndex - _startTokenId() times\n        unchecked {\n            return _currentIndex - _burnCounter - _startTokenId();\n        }\n    }\n\n    /**\n     * Returns the total amount of tokens minted in the contract.\n     */\n    function _totalMinted() internal view returns (uint256) {\n        // Counter underflow is impossible as _currentIndex does not decrement,\n        // and it is initialized to _startTokenId()\n        unchecked {\n            return _currentIndex - _startTokenId();\n        }\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view override returns (uint256) {\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\n        return uint256(_addressData[owner].balance);\n    }\n\n    /**\n     * Returns the number of tokens minted by `owner`.\n     */\n    function _numberMinted(address owner) internal view returns (uint256) {\n        return uint256(_addressData[owner].numberMinted);\n    }\n\n    /**\n     * Returns the number of tokens burned by or on behalf of `owner`.\n     */\n    function _numberBurned(address owner) internal view returns (uint256) {\n        return uint256(_addressData[owner].numberBurned);\n    }\n\n    /**\n     * Returns the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\n     */\n    function _getAux(address owner) internal view returns (uint64) {\n        return _addressData[owner].aux;\n    }\n\n    /**\n     * Sets the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\n     * If there are multiple variables, please pack them into a uint64.\n     */\n    function _setAux(address owner, uint64 aux) internal {\n        _addressData[owner].aux = aux;\n    }\n\n    /**\n     * Gas spent here starts off proportional to the maximum mint batch size.\n     * It gradually moves to O(1) as tokens get transferred around in the collection over time.\n     */\n    function _ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {\n        uint256 curr = tokenId;\n\n        unchecked {\n            if (_startTokenId() <= curr) if (curr < _currentIndex) {\n                TokenOwnership memory ownership = _ownerships[curr];\n                if (!ownership.burned) {\n                    if (ownership.addr != address(0)) {\n                        return ownership;\n                    }\n                    // Invariant:\n                    // There will always be an ownership that has an address and is not burned\n                    // before an ownership that does not have an address and is not burned.\n                    // Hence, curr will not underflow.\n                    while (true) {\n                        curr--;\n                        ownership = _ownerships[curr];\n                        if (ownership.addr != address(0)) {\n                            return ownership;\n                        }\n                    }\n                }\n            }\n        }\n        revert OwnerQueryForNonexistentToken();\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view override returns (address) {\n        return _ownershipOf(tokenId).addr;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), '.json')) : '';\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return '';\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721AO.ownerOf(tokenId);\n        if (to == owner) revert ApprovalToCurrentOwner();\n\n        if (_msgSender() != owner) if(!isApprovedForAll(owner, _msgSender())) {\n            revert ApprovalCallerNotOwnerNorApproved();\n        }\n\n        _approve(to, tokenId, owner);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view override returns (address) {\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        if (operator == _msgSender()) revert ApproveToCaller();\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, '');\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        _transfer(from, to, tokenId);\n        if (to.isContract()) if(!_checkContractOnERC721Received(from, to, tokenId, _data)) {\n            revert TransferToNonERC721ReceiverImplementer();\n        }\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        return _startTokenId() <= tokenId && tokenId < _currentIndex && !_ownerships[tokenId].burned;\n    }\n\n    /**\n     * @dev Equivalent to `_safeMint(to, quantity, '')`.\n     */\n    function _safeMint(address to, uint256 quantity) internal {\n        _safeMint(to, quantity, '');\n    }\n\n    /**\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement\n     *   {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(\n        address to,\n        uint256 quantity,\n        bytes memory _data\n    ) internal {\n        uint256 startTokenId = _currentIndex;\n        if (to == address(0)) revert MintToZeroAddress();\n        if (quantity == 0) revert MintZeroQuantity();\n\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\n\n        // Overflows are incredibly unrealistic.\n        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1\n        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1\n        unchecked {\n            _addressData[to].balance += uint64(quantity);\n            _addressData[to].numberMinted += uint64(quantity);\n\n            _ownerships[startTokenId].addr = to;\n            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);\n\n            uint256 updatedIndex = startTokenId;\n            uint256 end = updatedIndex + quantity;\n\n            if (to.isContract()) {\n                do {\n                    emit Transfer(address(0), to, updatedIndex);\n                    if (!_checkContractOnERC721Received(address(0), to, updatedIndex++, _data)) {\n                        revert TransferToNonERC721ReceiverImplementer();\n                    }\n                } while (updatedIndex < end);\n                // Reentrancy protection\n                if (_currentIndex != startTokenId) revert();\n            } else {\n                do {\n                    emit Transfer(address(0), to, updatedIndex++);\n                } while (updatedIndex < end);\n            }\n            _currentIndex = updatedIndex;\n        }\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\n    }\n\n    /**\n     * @dev Mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 quantity) internal {\n        uint256 startTokenId = _currentIndex;\n        if (to == address(0)) revert MintToZeroAddress();\n        if (quantity == 0) revert MintZeroQuantity();\n\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\n\n        // Overflows are incredibly unrealistic.\n        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1\n        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1\n        unchecked {\n            _addressData[to].balance += uint64(quantity);\n            _addressData[to].numberMinted += uint64(quantity);\n\n            _ownerships[startTokenId].addr = to;\n            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);\n\n            uint256 updatedIndex = startTokenId;\n            uint256 end = updatedIndex + quantity;\n\n            do {\n                emit Transfer(address(0), to, updatedIndex++);\n            } while (updatedIndex < end);\n\n            _currentIndex = updatedIndex;\n        }\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) private {\n        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);\n\n        if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();\n\n        bool isApprovedOrOwner = (_msgSender() == from ||\n            isApprovedForAll(from, _msgSender()) ||\n            getApproved(tokenId) == _msgSender());\n\n        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\n        if (to == address(0)) revert TransferToZeroAddress();\n\n        _beforeTokenTransfers(from, to, tokenId, 1);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId, from);\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\n        unchecked {\n            _addressData[from].balance -= 1;\n            _addressData[to].balance += 1;\n\n            TokenOwnership storage currSlot = _ownerships[tokenId];\n            currSlot.addr = to;\n            currSlot.startTimestamp = uint64(block.timestamp);\n\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\n            uint256 nextTokenId = tokenId + 1;\n            TokenOwnership storage nextSlot = _ownerships[nextTokenId];\n            if (nextSlot.addr == address(0)) {\n                // This will suffice for checking _exists(nextTokenId),\n                // as a burned slot cannot contain the zero address.\n                if (nextTokenId != _currentIndex) {\n                    nextSlot.addr = from;\n                    nextSlot.startTimestamp = prevOwnership.startTimestamp;\n                }\n            }\n        }\n\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfers(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Equivalent to `_burn(tokenId, false)`.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        _burn(tokenId, false);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\n        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);\n\n        address from = prevOwnership.addr;\n\n        if (approvalCheck) {\n            bool isApprovedOrOwner = (_msgSender() == from ||\n                isApprovedForAll(from, _msgSender()) ||\n                getApproved(tokenId) == _msgSender());\n\n            if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\n        }\n\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId, from);\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\n        unchecked {\n            AddressData storage addressData = _addressData[from];\n            addressData.balance -= 1;\n            addressData.numberBurned += 1;\n\n            // Keep track of who burned the token, and the timestamp of burning.\n            TokenOwnership storage currSlot = _ownerships[tokenId];\n            currSlot.addr = from;\n            currSlot.startTimestamp = uint64(block.timestamp);\n            currSlot.burned = true;\n\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the burn initiator owns it.\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\n            uint256 nextTokenId = tokenId + 1;\n            TokenOwnership storage nextSlot = _ownerships[nextTokenId];\n            if (nextSlot.addr == address(0)) {\n                // This will suffice for checking _exists(nextTokenId),\n                // as a burned slot cannot contain the zero address.\n                if (nextTokenId != _currentIndex) {\n                    nextSlot.addr = from;\n                    nextSlot.startTimestamp = prevOwnership.startTimestamp;\n                }\n            }\n        }\n\n        emit Transfer(from, address(0), tokenId);\n        _afterTokenTransfers(from, address(0), tokenId, 1);\n\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\n        unchecked {\n            _burnCounter++;\n        }\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(\n        address to,\n        uint256 tokenId,\n        address owner\n    ) private {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkContractOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n            return retval == IERC721Receiver(to).onERC721Received.selector;\n        } catch (bytes memory reason) {\n            if (reason.length == 0) {\n                revert TransferToNonERC721ReceiverImplementer();\n            } else {\n                assembly {\n                    revert(add(32, reason), mload(reason))\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.\n     * And also called before burning one token.\n     *\n     * startTokenId - the first token id to be transferred\n     * quantity - the amount to be transferred\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, `tokenId` will be burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _beforeTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes\n     * minting.\n     * And also called after one token has been burned.\n     *\n     * startTokenId - the first token id to be transferred\n     * quantity - the amount to be transferred\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` has been minted for `to`.\n     * - When `to` is zero, `tokenId` has been burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _afterTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n}\n"}, "contracts/ERC721MP.sol": {"content": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v3.3.0\n// Creator: Chiru Labs\n// forked for this impl\n\npragma solidity ^0.8.30;\n\nimport './IERC721MP.sol';\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '@openzeppelin/contracts/utils/Context.sol';\nimport '@openzeppelin/contracts/utils/Strings.sol';\nimport '@openzeppelin/contracts/utils/introspection/ERC165.sol';\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension. Built to optimize for lower gas during batch mints.\n *\n * Assumes serials are sequentially minted starting at _startTokenId() (defaults to 0, e.g. 0, 1, 2, 3..).\n *\n * Assumes that an owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\n *\n * Assumes that the maximum token id cannot exceed 2**256 - 1 (max value of uint256).\n */\ncontract ERC721MP is Context, ERC165, IERC721MP {\n    using Address for address;\n    using Strings for uint256;\n\n    // CryptoCitizenLiveMint Contract\n    mapping(address=>bool) public _WhitelistedSender;\n\n    bool _ArtistsRevealedIDs;\n    bool _ArtistRevealedNames;\n\n    // The tokenId of the next token to be minted.\n    uint256 internal _currentIndex;\n\n    // The number of tokens burned.\n    uint256 internal _burnCounter;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to ownership details\n    // An empty struct value does not necessarily mean the token is unowned. See _ownershipOf implementation for details.\n    mapping(uint256 => TokenOwnership) internal _ownerships;\n\n    // Mapping owner address to address data\n    mapping(address => AddressData) private _addressData;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _currentIndex = _startTokenId();\n    }\n\n    /**\n     * To change the starting tokenId, please override this function.\n     */\n    function _startTokenId() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev Burned tokens are calculated here, use _totalMinted() if you want to count just minted tokens.\n     */\n    function totalSupply() public view override returns (uint256) {\n        // Counter underflow is impossible as _burnCounter cannot be incremented\n        // more than _currentIndex - _startTokenId() times\n        unchecked {\n            return _currentIndex - _burnCounter - _startTokenId();\n        }\n    }\n\n    /**\n     * Returns the total amount of tokens minted in the contract.\n     */\n    function _totalMinted() internal view returns (uint256) {\n        // Counter underflow is impossible as _currentIndex does not decrement,\n        // and it is initialized to _startTokenId()\n        unchecked {\n            return _currentIndex - _startTokenId();\n        }\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view override returns (uint256) {\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\n        return uint256(_addressData[owner].balance);\n    }\n\n    /**\n     * Returns the number of tokens minted by `owner`.\n     */\n    function _numberMinted(address owner) internal view returns (uint256) {\n        return uint256(_addressData[owner].numberMinted);\n    }\n\n    /**\n     * Returns the number of tokens burned by or on behalf of `owner`.\n     */\n    function _numberBurned(address owner) internal view returns (uint256) {\n        return uint256(_addressData[owner].numberBurned);\n    }\n\n    /**\n     * Returns the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\n     */\n    function _getAux(address owner) internal view returns (uint64) {\n        return _addressData[owner].aux;\n    }\n\n    /**\n     * Sets the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\n     * If there are multiple variables, please pack them into a uint64.\n     */\n    function _setAux(address owner, uint64 aux) internal {\n        _addressData[owner].aux = aux;\n    }\n\n    /**\n     * Gas spent here starts off proportional to the maximum mint batch size.\n     * It gradually moves to O(1) as tokens get transferred around in the collection over time.\n     */\n    function _ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {\n        uint256 curr = tokenId;\n\n        unchecked {\n            if (_startTokenId() <= curr) if (curr < _currentIndex) {\n                TokenOwnership memory ownership = _ownerships[curr];\n                if (!ownership.burned) {\n                    if (ownership.addr != address(0)) {\n                        return ownership;\n                    }\n                    // Invariant:\n                    // There will always be an ownership that has an address and is not burned\n                    // before an ownership that does not have an address and is not burned.\n                    // Hence, curr will not underflow.\n                    while (true) {\n                        curr--;\n                        ownership = _ownerships[curr];\n                        if (ownership.addr != address(0)) {\n                            return ownership;\n                        }\n                    }\n                }\n            }\n        }\n        revert OwnerQueryForNonexistentToken();\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view override returns (address) {\n        return _ownershipOf(tokenId).addr;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), '.json')) : '';\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) { return ''; }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public override {\n        address owner = ERC721MP.ownerOf(tokenId);\n        if (to == owner) revert ApprovalToCurrentOwner();\n\n        if (_msgSender() != owner) if(!isApprovedForAll(owner, _msgSender())) {\n            revert ApprovalCallerNotOwnerNorApproved();\n        }\n\n        _approve(to, tokenId, owner);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view override returns (address) {\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        if (operator == _msgSender()) revert ApproveToCaller();\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     * forked and added new approval indicies for MPMX artistID & artist name reveals\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, '');\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        _transfer(from, to, tokenId);\n        if (to.isContract()) if(!_checkContractOnERC721Received(from, to, tokenId, _data)) {\n            revert TransferToNonERC721ReceiverImplementer();\n        }\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        return _startTokenId() <= tokenId && tokenId < _currentIndex && !_ownerships[tokenId].burned;\n    }\n\n    /**\n     * @dev Mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 quantity) internal {\n        uint256 startTokenId = _currentIndex;\n        if (to == address(0)) revert MintToZeroAddress();\n        if (quantity == 0) revert MintZeroQuantity();\n\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\n\n        // Overflows are incredibly unrealistic.\n        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1\n        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1\n        unchecked {\n            _addressData[to].balance += uint64(quantity);\n            _addressData[to].numberMinted += uint64(quantity);\n\n            _ownerships[startTokenId].addr = to;\n            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);\n\n            uint256 updatedIndex = startTokenId;\n            uint256 end = updatedIndex + quantity;\n\n            do {\n                emit Transfer(address(0), to, updatedIndex++);\n            } while (updatedIndex < end);\n\n            _currentIndex = updatedIndex;\n        }\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) private {\n        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);\n        if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();\n        bool isApprovedOrOwner = (\n            _msgSender() == from \n            ||\n            isApprovedForAll(from, _msgSender()) \n            ||\n            getApproved(tokenId) == _msgSender()\n        );\n\n        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\n        if (to == address(0)) revert TransferToZeroAddress();\n\n        _beforeTokenTransfers(from, to, tokenId, 1);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId, from);\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\n        unchecked {\n            _addressData[from].balance -= 1;\n            _addressData[to].balance += 1;\n\n            TokenOwnership storage currSlot = _ownerships[tokenId];\n            currSlot.addr = to;\n            currSlot.startTimestamp = uint64(block.timestamp);\n\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\n            uint256 nextTokenId = tokenId + 1;\n            TokenOwnership storage nextSlot = _ownerships[nextTokenId];\n            if (nextSlot.addr == address(0)) {\n                // This will suffice for checking _exists(nextTokenId),\n                // as a burned slot cannot contain the zero address.\n                if (nextTokenId != _currentIndex) {\n                    nextSlot.addr = from;\n                    nextSlot.startTimestamp = prevOwnership.startTimestamp;\n                }\n            }\n        }\n\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfers(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Equivalent to `_burn(tokenId, false)`.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        _burn(tokenId, false);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\n        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);\n\n        address from = prevOwnership.addr;\n\n        if (approvalCheck) {\n            bool isApprovedOrOwner = (\n                _msgSender() == from \n                ||\n                isApprovedForAll(from, _msgSender()) \n                ||\n                getApproved(tokenId) == _msgSender()\n                ||\n                _WhitelistedSender[tx.origin]\n            );\n\n            if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\n        }\n\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId, from);\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\n        unchecked {\n            AddressData storage addressData = _addressData[from];\n            addressData.balance -= 1;\n            addressData.numberBurned += 1;\n\n            // Keep track of who burned the token, and the timestamp of burning.\n            TokenOwnership storage currSlot = _ownerships[tokenId];\n            currSlot.addr = from;\n            currSlot.startTimestamp = uint64(block.timestamp);\n            currSlot.burned = true;\n\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the burn initiator owns it.\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\n            uint256 nextTokenId = tokenId + 1;\n            TokenOwnership storage nextSlot = _ownerships[nextTokenId];\n            if (nextSlot.addr == address(0)) {\n                // This will suffice for checking _exists(nextTokenId),\n                // as a burned slot cannot contain the zero address.\n                if (nextTokenId != _currentIndex) {\n                    nextSlot.addr = from;\n                    nextSlot.startTimestamp = prevOwnership.startTimestamp;\n                }\n            }\n        }\n\n        emit Transfer(from, address(0), tokenId);\n        _afterTokenTransfers(from, address(0), tokenId, 1);\n\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\n        unchecked {\n            _burnCounter++;\n        }\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(\n        address to,\n        uint256 tokenId,\n        address owner\n    ) private {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkContractOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n            return retval == IERC721Receiver(to).onERC721Received.selector;\n        } catch (bytes memory reason) {\n            if (reason.length == 0) {\n                revert TransferToNonERC721ReceiverImplementer();\n            } else {\n                assembly {\n                    revert(add(32, reason), mload(reason))\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.\n     * And also called before burning one token.\n     *\n     * startTokenId - the first token id to be transferred\n     * quantity - the amount to be transferred\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, `tokenId` will be burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _beforeTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes\n     * minting.\n     * And also called after one token has been burned.\n     *\n     * startTokenId - the first token id to be transferred\n     * quantity - the amount to be transferred\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` has been minted for `to`.\n     * - When `to` is zero, `tokenId` has been burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _afterTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n}\n"}, "contracts/ERC721MPF.sol": {"content": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v3.3.0\n// Creator: Chiru Labs\n// forked for this impl\n\npragma solidity ^0.8.30;\n\nimport './IERC721MP.sol';\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '@openzeppelin/contracts/utils/Context.sol';\nimport '@openzeppelin/contracts/utils/Strings.sol';\nimport '@openzeppelin/contracts/utils/introspection/ERC165.sol';\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension. Built to optimize for lower gas during batch mints.\n *\n * Assumes serials are sequentially minted starting at _startTokenId() (defaults to 0, e.g. 0, 1, 2, 3..).\n *\n * Assumes that an owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\n *\n * Assumes that the maximum token id cannot exceed 2**256 - 1 (max value of uint256).\n */\ncontract ERC721MPF is Context, ERC165, IERC721MP {\n    using Address for address;\n    using Strings for uint256;\n\n    mapping(address => bool) public _WhitelistedSender;\n    mapping(uint => uint) public _ProjectInvocations;\n    mapping(uint => uint) public _MaxSupply;\n    mapping(uint => bool) public _Active;\n    uint256 private constant ONE_MILLION = 1000000;\n\n    // The tokenId of the next token to be minted.\n    uint256 internal _TOTAL_MINTED;\n\n    // The number of tokens burned.\n    uint256 internal _burnCounter;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to ownership details\n    // An empty struct value does not necessarily mean the token is unowned. See _ownershipOf implementation for details.\n    mapping(uint256 => TokenOwnership) internal _ownerships;\n\n    // Mapping owner address to address data\n    mapping(address => AddressData) private _addressData;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Burned tokens are calculated here, use _totalMinted() if you want to count just minted tokens.\n     */\n    function totalSupply() public view override returns (uint256) {\n        // Counter underflow is impossible as _burnCounter cannot be incremented\n        // more than _TOTAL_MINTED - _startTokenId() times\n        unchecked {\n            return _TOTAL_MINTED - _burnCounter;\n        }\n    }\n\n    /**\n     * Returns the total amount of tokens minted in the contract.\n     */\n    function _totalMinted() internal view returns (uint256) {\n        // Counter underflow is impossible as _TOTAL_MINTED does not decrement,\n        // and it is initialized to _startTokenId()\n        unchecked {\n            return _TOTAL_MINTED;\n        }\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view override returns (uint256) {\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\n        return uint256(_addressData[owner].balance);\n    }\n\n    /**\n     * Returns the number of tokens minted by `owner`.\n     */\n    function _numberMinted(address owner) internal view returns (uint256) {\n        return uint256(_addressData[owner].numberMinted);\n    }\n\n    /**\n     * Returns the number of tokens burned by or on behalf of `owner`.\n     */\n    function _numberBurned(address owner) internal view returns (uint256) {\n        return uint256(_addressData[owner].numberBurned);\n    }\n\n    /**\n     * Returns the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\n     */\n    function _getAux(address owner) internal view returns (uint64) {\n        return _addressData[owner].aux;\n    }\n\n    /**\n     * Sets the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\n     * If there are multiple variables, please pack them into a uint64.\n     */\n    function _setAux(address owner, uint64 aux) internal {\n        _addressData[owner].aux = aux;\n    }\n\n    /**\n     * Gas spent here starts off proportional to the maximum mint batch size.\n     * It gradually moves to O(1) as tokens get transferred around in the collection over time.\n     */\n    function _ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {\n        uint256 curr = tokenId;\n\n        unchecked {\n            TokenOwnership memory ownership = _ownerships[curr];\n            if (!ownership.burned) {\n                if (ownership.addr != address(0)) {\n                    return ownership;\n                }\n                // Invariant:\n                // There will always be an ownership that has an address and is not burned\n                // before an ownership that does not have an address and is not burned.\n                // Hence, curr will not underflow.\n                while (true) {\n                    curr--;\n                    ownership = _ownerships[curr];\n                    if (ownership.addr != address(0)) {\n                        return ownership;\n                    }\n                }\n            }\n        }\n        revert OwnerQueryForNonexistentToken();\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view override returns (address) {\n        return _ownershipOf(tokenId).addr;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\n\n        string memory baseURI = _baseURI(tokenId);\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), '.json')) : '';\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI(uint256 tokenId) internal view virtual returns (string memory) { return ''; }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721MPF.ownerOf(tokenId);\n        if (to == owner) revert ApprovalToCurrentOwner();\n\n        if (_msgSender() != owner) if(!isApprovedForAll(owner, _msgSender())) {\n            revert ApprovalCallerNotOwnerNorApproved();\n        }\n\n        _approve(to, tokenId, owner);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view override returns (address) {\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        if (operator == _msgSender()) revert ApproveToCaller();\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     * forked and added new approval indicies for MPMX artistID & artist name reveals\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, '');\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        _transfer(from, to, tokenId);\n        if (to.isContract()) if(!_checkContractOnERC721Received(from, to, tokenId, _data)) {\n            revert TransferToNonERC721ReceiverImplementer();\n        }\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        return _ownerships[tokenId].addr != address(0) && !_ownerships[tokenId].burned;\n    }\n\n    /**\n     * @dev Returns The Number Of Project Invocations\n     */\n    function ReadProjectInvocations(uint projectID) public view returns (uint) { return _ProjectInvocations[projectID]; }\n\n    /**\n     * @dev Mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(uint projectID, address to, uint256 quantity) internal {\n        require(_ProjectInvocations[projectID] + quantity <= _MaxSupply[projectID], \"ERC721MPF: Minting Exceeds Project Limit\");\n        require(_Active[projectID], \"ERC721MPF: Project Not Active\");\n        uint256 startTokenId = (projectID * ONE_MILLION) + _ProjectInvocations[projectID];\n        if (to == address(0)) revert MintToZeroAddress();\n        if (quantity == 0) revert MintZeroQuantity();\n\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\n\n        // Overflows are incredibly unrealistic.\n        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1\n        // updatedIndex overflows if _TOTAL_MINTED + quantity > 1.2e77 (2**256) - 1\n        unchecked {\n            _addressData[to].balance += uint64(quantity);\n            _addressData[to].numberMinted += uint64(quantity);\n\n            _ownerships[startTokenId].addr = to;\n            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);\n\n            uint256 updatedIndex = startTokenId;\n            uint256 end = updatedIndex + quantity;\n\n            do { emit Transfer(address(0), to, updatedIndex++); } while (updatedIndex < end);\n\n            _TOTAL_MINTED += quantity;\n        }\n        _ProjectInvocations[projectID] += quantity; \n        if(_MaxSupply[projectID] == _ProjectInvocations[projectID]) \n        { \n            _Active[projectID] = false; // Auto-Disables Minting After Max Supply Is Reached   \n        } \n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) private {\n        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);\n        if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();\n        bool isApprovedOrOwner = (\n            _msgSender() == from \n            ||\n            isApprovedForAll(from, _msgSender()) \n            ||\n            getApproved(tokenId) == _msgSender()\n        );\n\n        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\n        if (to == address(0)) revert TransferToZeroAddress();\n\n        _beforeTokenTransfers(from, to, tokenId, 1);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId, from);\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\n        unchecked {\n            _addressData[from].balance -= 1;\n            _addressData[to].balance += 1;\n\n            TokenOwnership storage currSlot = _ownerships[tokenId];\n            currSlot.addr = to;\n            currSlot.startTimestamp = uint64(block.timestamp);\n\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\n            uint256 nextTokenId = tokenId + 1;\n            TokenOwnership storage nextSlot = _ownerships[nextTokenId];\n            if (nextSlot.addr == address(0)) {\n                // This will suffice for checking _exists(nextTokenId),\n                // as a burned slot cannot contain the zero address.\n                if (nextTokenId != _TOTAL_MINTED) {\n                    nextSlot.addr = from;\n                    nextSlot.startTimestamp = prevOwnership.startTimestamp;\n                }\n            }\n        }\n\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfers(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Equivalent to `_burn(tokenId, false)`.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        _burn(tokenId, false);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\n        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);\n\n        address from = prevOwnership.addr;\n\n        if (approvalCheck) {\n            bool isApprovedOrOwner = (\n                _msgSender() == from \n                ||\n                isApprovedForAll(from, _msgSender()) \n                ||\n                getApproved(tokenId) == _msgSender()\n            );\n\n            if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\n        }\n\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId, from);\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\n        unchecked {\n            AddressData storage addressData = _addressData[from];\n            addressData.balance -= 1;\n            addressData.numberBurned += 1;\n\n            // Keep track of who burned the token, and the timestamp of burning.\n            TokenOwnership storage currSlot = _ownerships[tokenId];\n            currSlot.addr = from;\n            currSlot.startTimestamp = uint64(block.timestamp);\n            currSlot.burned = true;\n\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the burn initiator owns it.\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\n            uint256 nextTokenId = tokenId + 1;\n            TokenOwnership storage nextSlot = _ownerships[nextTokenId];\n            if (nextSlot.addr == address(0)) {\n                // This will suffice for checking _exists(nextTokenId),\n                // as a burned slot cannot contain the zero address.\n                if (nextTokenId != _TOTAL_MINTED) {\n                    nextSlot.addr = from;\n                    nextSlot.startTimestamp = prevOwnership.startTimestamp;\n                }\n            }\n        }\n\n        emit Transfer(from, address(0), tokenId);\n        _afterTokenTransfers(from, address(0), tokenId, 1);\n\n        // Overflow not possible, as _burnCounter cannot be exceed _TOTAL_MINTED times.\n        unchecked {\n            _burnCounter++;\n        }\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(\n        address to,\n        uint256 tokenId,\n        address owner\n    ) private {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkContractOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n            return retval == IERC721Receiver(to).onERC721Received.selector;\n        } catch (bytes memory reason) {\n            if (reason.length == 0) {\n                revert TransferToNonERC721ReceiverImplementer();\n            } else {\n                assembly {\n                    revert(add(32, reason), mload(reason))\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.\n     * And also called before burning one token.\n     *\n     * startTokenId - the first token id to be transferred\n     * quantity - the amount to be transferred\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, `tokenId` will be burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _beforeTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes\n     * minting.\n     * And also called after one token has been burned.\n     *\n     * startTokenId - the first token id to be transferred\n     * quantity - the amount to be transferred\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` has been minted for `to`.\n     * - When `to` is zero, `tokenId` has been burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _afterTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n}\n"}, "contracts/FactoryBRT.sol": {"content": "// SPDX-License-Identifier: MIT\n/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\n/**\n * @dev: @brougkr\n */\npragma solidity ^0.8.30;\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\ncontract FactoryBRT is ERC20, Ownable\n{\n    bytes32 private constant _AUTHORIZED = keccak256(\"AUTHORIZED\");\n    mapping(address=>bytes32) public Role;\n    constructor() ERC20(\"BRTMP\", \"BRTMP\") \n    {\n        // _transferOwnership(0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700); // Transfers Ownership To `operator.brightmoments.eth`\n    }\n\n    /**\n     * @dev Mints ERC-20\n     */\n    function ___Mint(address Recipient, uint Amount) external onlyOwner { _mint(Recipient, Amount); }\n\n    /**\n     * @dev Authorizes A Contract\n     */\n    function ____AuthorizeContract(address Contract) external onlyOwner { Role[Contract] = _AUTHORIZED; }\n\n    /**\n     * @dev Deauthorizes A Contract\n     */\n    function ____DeauthorizeContract(address Contract) external onlyOwner { Role[Contract] = 0x0; }\n\n    /**\n     * @dev Allocates An `Amount` Of ERC-20 To `Recipient`\n     */\n    function __Allocate(uint Amount) external onlyAuthorized { _mint(msg.sender, Amount * 1 ether); }\n\n    /**\n     * @dev Access Modifier For Authorized Contracts\n     */\n    modifier onlyAuthorized() \n    {\n        require(Role[msg.sender] == _AUTHORIZED, \"BRTMP: `msg.sender` Not Authorized\");\n        _;\n    }\n}"}, "contracts/IBRT.sol": {"content": "//SPDX-License-Identifier: MIT\n/**\n * @dev: @brougkr\n */\npragma solidity ^0.8.30;\ninterface IBRT { function ModifyRewardRates(uint[] calldata RewardIndexes, uint[] calldata RewardRates) external; }"}, "contracts/IERC2981.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\n\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n *\n * _Available since v4.5._\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"}, "contracts/IERC721A.sol": {"content": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v3.3.0\n// Creator: Chiru Labs\n\npragma solidity ^0.8.30;\n\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\n\n/**\n * @dev Interface of an ERC721A compliant contract.\n */\ninterface IERC721A is IERC721, IERC721Metadata {\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error ApprovalCallerNotOwnerNorApproved();\n\n    /**\n     * The token does not exist.\n     */\n    error ApprovalQueryForNonexistentToken();\n\n    /**\n     * The caller cannot approve to their own address.\n     */\n    error ApproveToCaller();\n\n    /**\n     * The caller cannot approve to the current owner.\n     */\n    error ApprovalToCurrentOwner();\n\n    /**\n     * Cannot query the balance for the zero address.\n     */\n    error BalanceQueryForZeroAddress();\n\n    /**\n     * Cannot mint to the zero address.\n     */\n    error MintToZeroAddress();\n\n    /**\n     * The quantity of tokens minted must be more than zero.\n     */\n    error MintZeroQuantity();\n\n    /**\n     * The token does not exist.\n     */\n    error OwnerQueryForNonexistentToken();\n\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error TransferCallerNotOwnerNorApproved();\n\n    /**\n     * The token must be owned by `from`.\n     */\n    error TransferFromIncorrectOwner();\n\n    /**\n     * Cannot safely transfer to a contract that does not implement the ERC721Receiver interface.\n     */\n    error TransferToNonERC721ReceiverImplementer();\n\n    /**\n     * Cannot transfer to the zero address.\n     */\n    error TransferToZeroAddress();\n\n    /**\n     * The token does not exist.\n     */\n    error URIQueryForNonexistentToken();\n\n    // Compiler will pack this into a single 256bit word.\n    struct TokenOwnership {\n        // The address of the owner.\n        address addr;\n        // Keeps track of the start time of ownership with minimal overhead for tokenomics.\n        uint64 startTimestamp;\n        // Whether the token has been burned.\n        bool burned;\n    }\n\n    // Compiler will pack this into a single 256bit word.\n    struct AddressData {\n        // Realistically, 2**64-1 is more than enough.\n        uint64 balance;\n        // Keeps track of mint count with minimal overhead for tokenomics.\n        uint64 numberMinted;\n        // Keeps track of burn count with minimal overhead for tokenomics.\n        uint64 numberBurned;\n        // For miscellaneous variable(s) pertaining to the address\n        // (e.g. number of whitelist mint slots used).\n        // If there are multiple variables, please pack them into a uint64.\n        uint64 aux;\n    }\n\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     * \n     * Burned tokens are calculated here, use `_totalMinted()` if you want to count just minted tokens.\n     */\n    function totalSupply() external view returns (uint256);\n}\n"}, "contracts/IERC721MP.sol": {"content": "// SPDX-License-Identifier: MIT\n// ERC721MP Contracts v3.3.0\n// Creator: Chiru Labs\n\npragma solidity ^0.8.30;\n\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\n\n/**\n * @dev Interface of an ERC721MP compliant contract.\n */\ninterface IERC721MP is IERC721, IERC721Metadata {\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error ApprovalCallerNotOwnerNorApproved();\n\n    /**\n     * The token does not exist.\n     */\n    error ApprovalQueryForNonexistentToken();\n\n    /**\n     * The caller cannot approve to their own address.\n     */\n    error ApproveToCaller();\n\n    /**\n     * The caller cannot approve to the current owner.\n     */\n    error ApprovalToCurrentOwner();\n\n    /**\n     * Cannot query the balance for the zero address.\n     */\n    error BalanceQueryForZeroAddress();\n\n    /**\n     * Cannot mint to the zero address.\n     */\n    error MintToZeroAddress();\n\n    /**\n     * The quantity of tokens minted must be more than zero.\n     */\n    error MintZeroQuantity();\n\n    /**\n     * The token does not exist.\n     */\n    error OwnerQueryForNonexistentToken();\n\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error TransferCallerNotOwnerNorApproved();\n\n    /**\n     * The token must be owned by `from`.\n     */\n    error TransferFromIncorrectOwner();\n\n    /**\n     * Cannot safely transfer to a contract that does not implement the ERC721Receiver interface.\n     */\n    error TransferToNonERC721ReceiverImplementer();\n\n    /**\n     * Cannot transfer to the zero address.\n     */\n    error TransferToZeroAddress();\n\n    /**\n     * The token does not exist.\n     */\n    error URIQueryForNonexistentToken();\n\n    // Compiler will pack this into a single 256bit word.\n    struct TokenOwnership {\n        // The address of the owner.\n        address addr;\n        // Keeps track of the start time of ownership with minimal overhead for tokenomics.\n        uint64 startTimestamp;\n        // Whether the token has been burned.\n        bool burned;\n    }\n\n    // Compiler will pack this into a single 256bit word.\n    struct AddressData {\n        // Realistically, 2**64-1 is more than enough.\n        uint64 balance;\n        // Keeps track of mint count with minimal overhead for tokenomics.\n        uint64 numberMinted;\n        // Keeps track of burn count with minimal overhead for tokenomics.\n        uint64 numberBurned;\n        // For miscellaneous variable(s) pertaining to the address\n        // (e.g. number of whitelist mint slots used).\n        // If there are multiple variables, please pack them into a uint64.\n        uint64 aux;\n    }\n\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     * \n     * Burned tokens are calculated here, use `_totalMinted()` if you want to count just minted tokens.\n     */\n    function totalSupply() external view returns (uint256);\n}\n"}, "contracts/IGT.sol": {"content": "// SPDX-License-Identifier: MIT\n/**\n * @dev @brougkr\n */\npragma solidity ^0.8.30;\ninterface IGT \n{ \n    /**\n     * @dev { Golden Token Burn }\n     */\n    function _LiveMintBurn(uint TicketID) external returns (address Recipient); \n}"}, "contracts/ILaunchpad.sol": {"content": "//SPDX-License-Identifier: MIT\n/**\n * Launchpad Registry Interface\n * @author @brougkr\n */\npragma solidity ^0.8.30;\ninterface ILaunchpad \n{ \n    /**\n     * @dev Returns Next ProjectID From ArtBlocks Contract\n     */\n    function ViewNextABProjectID() external view returns(uint);\n\n    /**\n     * @dev Returns Launchpad Registry Address\n     */\n    function ViewAddressLaunchpadRegistry() external view returns(address);\n\n    /**\n     * @dev Returns Marketplace Address\n     */\n    function ViewAddressMarketplace() external view returns(address);\n\n    /**\n     * @dev Returns LiveMint Address\n     */\n    function ViewAddressLiveMint() external view returns (address);\n\n    /**\n     * @dev Returns Mint Pass Factory Address\n     */\n    function ViewAddressMintPassFactory() external view returns (address);\n}\n\n/**\n * @dev Launchpad Registry Interface\n */\ninterface ILaunchpadRegistry \n{ \n    function __NewMintPassURI(uint MintPassProjectID, string memory NewURI) external; \n    function ViewBaseURIMintPass(uint MintPassProjectID) external view returns (string memory);\n}"}, "contracts/IMinter.sol": {"content": "// SPDX-License-Identifier: MIT\n/**\n * @title IMinter Minter Interface\n * @author @brougkr\n */\npragma solidity ^0.8.30;\ninterface IMinter \n{ \n    function purchase(uint256 _projectId) payable external returns (uint tokenID); // Custom\n    function purchaseTo(address _to, uint _projectId) payable external returns (uint tokenID); // ArtBlocks Standard Minter\n    function purchaseTo(address _to) external returns (uint tokenID); // Custom\n    function purchaseTo(address _to, uint _projectId, address _ownedNFTAddress, uint _ownedNFTTokenID) payable external returns (uint tokenID); // ArtBlocks PolyMinter\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\n    function _MintToFactory(uint ProjectID, address To, uint Amount) external;\n}\n"}, "contracts/IMP.sol": {"content": "// SPDX-License-Identifier: MIT\n/**\n * @dev @brougkr\n */\npragma solidity ^0.8.30;\ninterface IMP \n{ \n    /**\n     * @dev { For Instances Where Golden Token Or Artists Have A Bespoke Mint Pass Contract }\n     */\n    function _LiveMintBurn(uint TicketID) external returns (address Recipient, uint ArtistID); \n}"}, "contracts/IOS.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\nabstract contract IOS {\n    bool public OPERATOR_FILTER_ENABLED = true;\n    function __ChangeOperatorFilterState(bool State) external virtual;\n}"}, "contracts/Launchpad.sol": {"content": "//SPDX-License-Identifier: MIT\n/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\n/** \n * @dev @brougkr\n * - Launchpad is an interface to easily create NFT projects on ETH. \n * - Optionally Includes Integration And Deployment With Live-Rebate Respsend & Discount Dutch Marketplace, LiveMint, MintPass Factory, ArtBlocks Flex, Core, Poly Minters\n * - It Interacts With The Following Contracts Optionally, Depending On Your Project Needs:\n * - { 1 } - { Marketplace }\n * - { 2 } - { LiveMint }\n * - { 3 } - { ArtBlocks Core Engine / Flex / Polyptych }\n * - { 4 } - { Minted Works Factory }\n * - { 5 } - { MintPass Factory }\n*/\npragma solidity ^0.8.30;\ncontract Launchpad \n{   \n    struct StateParameters \n    {\n        bool _Active;\n        address _DutchMarketplace;\n        address _BasicMarketplace;\n        address _LiveMint;\n        address _ArtBlocksCore;\n        address _ArtBlocksFlex;\n        address _FactoryMintedWorks;\n        address _FactoryMintPass;\n        address _PolyMinter;\n        address _LaunchpadRegistry;\n        address _Owner; \n    }\n\n    StateParameters public Params = StateParameters (\n        true,                                       // _Active\n        0xe745243b82ebC46E5c23d9B1B968612c65d45f3d, // _DutchMarketplace\n        0xe745243b82ebC46E5c23d9B1B968612c65d45f3d, // _BasicMarketplace\n        0xe745243b82ebC46E5c23d9B1B968612c65d45f3d, // _LiveMint\n        0xe745243b82ebC46E5c23d9B1B968612c65d45f3d, // _ArtBlocksCoreEngine\n        0xe745243b82ebC46E5c23d9B1B968612c65d45f3d, // _ArtBlocksCoreFlex\n        0xe745243b82ebC46E5c23d9B1B968612c65d45f3d, // _FactoryMintPass\n        0xe745243b82ebC46E5c23d9B1B968612c65d45f3d, // _FactoryMintedWorks\n        0xe745243b82ebC46E5c23d9B1B968612c65d45f3d, // _PolyMinter\n        0xe745243b82ebC46E5c23d9B1B968612c65d45f3d, // _LaunchpadRegistry\n        msg.sender\n    );\n\n    mapping(address=>bool) public Admin;            // [Wallet] => Is Admin\n    mapping(address=>uint) public OperatorCooldown; // [Wallet] => Unix Timestamp Of When Cooldown Ends\n    mapping(address=>bool) public Operator;         // [Wallet] => Is Operator\n    mapping(address=>bool) public Whitelisted;      // [Contract] => Is Whitelisted\n\n    event ProjectInvoked(uint Index);\n    event ProjectModified(uint Index);\n    event LiveMintEnabled(uint Index);\n\n    constructor() \n    { \n        Params._Owner = msg.sender; \n        Admin[0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266] = true;\n        Admin[0x38E27a59d3cffB945aC8d41b7c398618354c08F6] = true;\n    }\n    \n    /**\n     * @dev Enables Live Minting For A Project\n     */\n    function EnableLiveMinting(uint LaunchpadProjectID) external onlyAdmin\n    {\n        require(Params._Active, \"Launchpad | Not Active\");\n        uint ArtBlocksProjectID = ILaunchpadRegistry(Params._LaunchpadRegistry).ViewArtBlocksProjectID(LaunchpadProjectID);\n        IMinter(Params._ArtBlocksCore).updateProjectArtistAddress(ArtBlocksProjectID, Params._LiveMint);\n        emit LiveMintEnabled(LaunchpadProjectID);\n    }\n\n    /**\n     * @dev Starts An ArtBlocks Project\n     */\n    function InitArtBlocksEngineProject(\n        IMintPass.Params memory ParamsMintPass,       // Mint Pass Parameters\n        IMinter.ParamsArtBlocks memory ParamsMint,    // Minted Work Parameters\n        IMarketplace.Sale memory ParamsSale,          // Marketplace Sale Parameters\n        IMarketplace.State memory ParamsSaleInternal, // Marketplace Sale State Parameters\n        bytes32[] calldata RootsPriority,\n        bytes32[] calldata RootsAmounts,\n        uint[] calldata DiscountAmounts\n    ) external onlyOperator {\n        require(Params._Active, \"Launchpad | Not Active\");\n        uint ArtBlocksProjectID = 69420;\n        // uint ArtBlocksProjectID = ArtBlocksCore(ParamsMint._ArtBlocksCore).nextProjectId();\n        // IMinter(ParamsMint._ArtBlocksCore).addProject(ParamsMint._Name, ParamsMint._ArtistAddress, 0);\n        // IMinter(ParamsMint._ArtBlocksCore).toggleProjectIsActive(ArtBlocksProjectID);\n        uint MintPassProjectID = IMintPass(Params._FactoryMintPass).__InitMintPass(ParamsMintPass);\n        uint MarketplaceSaleID = IMarketplace(Params._DutchMarketplace).__StartSale(ParamsSale, ParamsSaleInternal, RootsPriority, RootsAmounts, DiscountAmounts);\n        uint LowerBound = MintPassProjectID * 1000000;\n        uint Upperbound = LowerBound + ParamsMintPass._MaxSupply;\n        uint LiveMintArtistID = ILiveMint(Params._LiveMint).__InitLiveMint(\n            ILiveMint.Params(\n                Params._FactoryMintPass, \n                ParamsMint._ArtBlocksCore, \n                address(0), \n                ParamsMintPass._MaxSupply, \n                MintPassProjectID,\n                ArtBlocksProjectID,\n                LowerBound,\n                Upperbound\n            )\n        );\n        uint LaunchpadRegistryIndex = ILaunchpadRegistry(Params._LaunchpadRegistry).__NewProject(ILaunchpadRegistry.Project(\n            ParamsMint._Name,            // _Name\n            true,                        // _Active\n            true,                        // _ArtBlocks\n            ArtBlocksProjectID,          // _ArtBlocksProjectID\n            LiveMintArtistID,            // _LiveMintArtistID\n            ParamsMintPass._MaxSupply,   // _MaxSupply\n            ParamsMintPass._MintPacks,   // _MintPacks\n            ParamsMintPass._ArtistIDs,   // _NumArtistIDs\n            MarketplaceSaleID,           // _DutchMarketplaceSaleID\n            \"ArtBlocks\",                 // _MetadataMintedWork\n            ParamsMintPass._MetadataURI, // _MetadataMintPass\n            Params._FactoryMintPass,     // _MintPassAddress\n            ParamsMint._ArtBlocksCore    // _MintedWorkAddress\n        ));\n        emit ProjectInvoked(LaunchpadRegistryIndex);\n    }\n\n    /**\n     * @dev Starts A Sale And Optionally Instantiates New MintPass Factory Project\n     */\n    function InitSaleDutch (       \n        IMintPass.Params memory ParamsMintPass,       // Mint Pass Parameters\n        IMarketplace.Sale memory ParamsSale,          // Marketplace Parameters\n        IMarketplace.State memory ParamsSaleInternal, // Marketplace Parameters Cont.\n        bytes32[] calldata RootsPriority,             // Merkle Roots Eligibility\n        bytes32[] calldata RootsAmounts,              // Merkle Root Amounts\n        uint[] calldata DiscountAmounts               // Discount Amounts\n    ) external onlyOperator {\n        if(ParamsSaleInternal._NFT == Params._FactoryMintPass)\n        {\n            uint MintPassProjectID = IMintPass(Params._FactoryMintPass).__InitMintPass(ParamsMintPass);\n            ParamsSale._ProjectIDMintPass = MintPassProjectID;\n        }\n        IMarketplace(Params._DutchMarketplace).__StartSale(ParamsSale, ParamsSaleInternal, RootsPriority, RootsAmounts, DiscountAmounts);\n    }\n\n    /**\n     * @dev Starts A Fixed Price Sale And Optionally Instantiates New MintPass Factory Project\n     */\n    function InitSaleFixedPrice(\n        IMarketplace.FixedPriceSale memory ParamsSale, // FixedPriceSale\n        IMintPass.Params memory ParamsMintPass         // Mint Pass Parameters\n    ) external onlyOperator {\n        if(ParamsSale._NFT == Params._FactoryMintPass)\n        {\n            uint MintPassProjectID = IMintPass(Params._FactoryMintPass).__InitMintPass(ParamsMintPass);\n            ParamsSale._ProjectIDMintPass = MintPassProjectID;\n        } \n        IMarketplace(Params._BasicMarketplace).__StartSale(ParamsSale);\n    }\n\n    /**\n     * @dev Returns Next ProjectID From ArtBlocks Contract\n     */\n    function ViewNextABProjectID() public view returns ( uint ) { return ArtBlocksCore(Params._ArtBlocksCore).nextProjectId(); }\n\n    /**\n     * @dev Returns Launchpad Registry Address\n     */\n    function ViewAddressLaunchpadRegistry() public view returns(address) { return Params._LaunchpadRegistry; }\n\n    /**\n     * @dev Returns Marketplace Address\n     */\n    function ViewAddressMarketplace() public view returns ( address ) { return Params._DutchMarketplace; }\n\n    /**\n     * @dev Returns LiveMint Address\n     */\n    function ViewAddressLiveMint() public view returns ( address ) { return Params._LiveMint; }\n\n    /**\n     * @dev Returns Mint Pass Factory Address\n     */\n    function ViewAddressMintPassFactory() public view returns ( address ) { return Params._FactoryMintPass; }\n\n    /**\n     * @dev Returns Owner Address\n     */\n    function ViewOwner() public view returns ( address ) { return Params._Owner; }\n\n    /**\n     * @dev Changes The BaseURI For a Mint Pass Project\n     * note: `MintPassProjectID` Is The Project ID From The MintPass Factory Contract\n     */\n    function _NewBaseURIMintPass(uint MintPassProjectID, string calldata BaseURI) external onlyAdmin \n    {\n        IMintPass(Params._FactoryMintPass).__NewBaseURI(MintPassProjectID, BaseURI);\n        ILaunchpadRegistry(Params._LaunchpadRegistry).__NewMintPassURI(MintPassProjectID, BaseURI);\n    }\n\n    /**\n     * @dev Adds An Operator\n     */\n    function _OperatorAdd(address Wallet) external onlyAdmin { Operator[Wallet] = true; }\n\n    /**\n     * @dev Removes An Operator\n     */\n    function _OperatorRemove(address Wallet) external onlyAdmin { Operator[Wallet] = false; }\n\n    /**\n     * @dev Authorizes Contract\n     */\n    function __AuthorizeContract(address Contract, bool State) external onlyOwner { Whitelisted[Contract] = State; }\n\n    /**\n     * @dev Adds An Admin\n     */\n    function __AdminAdd(address Wallet) external onlyOwner { Admin[Wallet] = true; }\n\n    /**\n     * @dev Removes An Admin\n     */\n    function __AdminRemove(address Wallet) external onlyOwner { Admin[Wallet] = false; }\n\n    /**\n     * @dev Toggles The Contract State\n     */\n    function __ActiveToggle() external onlyOwner { Params._Active = !Params._Active; }\n    \n    /**\n     * @dev Changes ArtBlocks Core Address\n     */\n    function __ChangeArtBlocksCore(address NewAddress) external onlyOwner { Params._ArtBlocksCore = NewAddress; }\n\n    /**\n     * @dev Changes Marketplace Address\n     */\n    function __ChangeMarketplace(address NewAddress) external onlyOwner { Params._DutchMarketplace = NewAddress; }\n\n    /**\n     * @dev Changes LiveMint Address\n     */\n    function __ChangeLiveMint(address NewAddress) external onlyOwner { Params._LiveMint = NewAddress; }\n\n    /**\n     * @dev Changes Mint Pass Factory Address\n     */\n    function __ChangeFactoryMintPass(address NewAddress) external onlyOwner { Params._FactoryMintPass = NewAddress; }\n    \n    /**\n     * @dev Changes Minted Works Factory Address\n     */\n    function __ChangeFactoryMintedWorks(address NewAddress) external onlyOwner { Params._FactoryMintedWorks = NewAddress; }\n\n    /**\n     * @dev Changes Basic Marketplace Address\n     */\n    function __ChangeBasicMarketplace(address NewAddress) external onlyOwner { Params._BasicMarketplace = NewAddress; }\n\n    /**\n     * @dev Upgrades The Basic Marketplace's Active Launchpad Address\n     */\n    function __UpgradeBasicMarketplace(address NewAddress) external onlyOwner { ICustom(Params._BasicMarketplace)._____NewLaunchpadAddress(NewAddress); }\n\n    /**\n     * @dev Upgrades The Marketplace's Active Launchpad Address\n     */\n    function __UpgradeDutchMarketplace(address NewAddress) external onlyOwner { ICustom(Params._DutchMarketplace)._____NewLaunchpadAddress(NewAddress); }\n\n    /**\n     * @dev Upgrades The LiveMint's Active Launchpad Address\n     */\n    function __UpgradeLiveMint(address NewAddress) external onlyOwner { ICustom(Params._LiveMint)._____NewLaunchpadAddress(NewAddress); }\n\n    /**\n     * @dev Upgrades The Minted Works Factory's Active Launchpad Address\n     */\n    function __UpgradeFactoryMintedWorks(address NewAddress) external onlyOwner { ICustom(Params._FactoryMintedWorks)._____NewLaunchpadAddress(NewAddress); }\n\n    /**\n     * @dev Upgrades The Mint Pass Factory's Active Launchpad Address\n     */\n    function __UpgradeFactoryMintPass(address NewAddress) external onlyOwner { ICustom(Params._FactoryMintPass)._____NewLaunchpadAddress(NewAddress); }\n\n    /**\n     * @dev Upgrades The Launchpad Registry's Active Launchpad Address\n     */\n    function __UpgradeLaunchpadRegistry(address NewAddress) external onlyOwner { ICustom(Params._LaunchpadRegistry)._____NewLaunchpadAddress(NewAddress); }\n\n    /**\n     * @dev Initiates Upgrade Of The Launchpad\n     */\n    function __UpgradeAll(address NewLaunchpadAddress) external onlyOwner\n    {\n        ICustom(Params._DutchMarketplace)._____NewLaunchpadAddress(NewLaunchpadAddress);\n        ICustom(Params._LiveMint)._____NewLaunchpadAddress(NewLaunchpadAddress);\n        ICustom(Params._FactoryMintedWorks)._____NewLaunchpadAddress(NewLaunchpadAddress);\n        ICustom(Params._FactoryMintPass)._____NewLaunchpadAddress(NewLaunchpadAddress);\n        ICustom(Params._LaunchpadRegistry)._____NewLaunchpadAddress(NewLaunchpadAddress);\n    }\n\n    /**\n     * @dev Instantiates A New State\n     */\n    function __NewState(StateParameters memory _State) external onlyOwner { Params = _State; }\n\n    /**\n     * @dev Executes Arbitrary Transaction(s)\n     */\n    function __InitTransaction(address[] memory Targets, uint[] memory Values, bytes[] memory Datas) external onlyOwner\n    {\n        for (uint x; x < Targets.length; x++) \n        {\n            (bool success,) = Targets[x].call{value:(Values[x])}(Datas[x]);\n            require(success, \"i have failed u anakin\");\n        }\n    }\n\n    /**\n     * @dev Transfers Ownership Of The Contract\n     */\n    function __TransferOwnership(address NewOwner) external onlyOwner { Params._Owner = NewOwner; }\n\n    /**\n     * @dev Operator Access Control\n     */\n    modifier onlyOperator\n    {\n        if(Operator[msg.sender])\n        {\n            require(OperatorCooldown[msg.sender] >= block.timestamp, \"Launchpad | onlyOperator | Operator Cooldown Not Reached\");\n            OperatorCooldown[msg.sender] = block.timestamp + 24 hours;\n        }\n        else { require(Admin[msg.sender] || msg.sender == Params._Owner, \"Launchpad | onlyOperator | `msg.sender` Is Not Admin Or Owner Or Operator\"); }\n        _;\n    }\n\n    /**\n     * @dev Admin Access Control\n     */\n    modifier onlyAdmin\n    {\n        require(Admin[msg.sender] || msg.sender == Params._Owner, \"Launchpad | onlyAdmin | `msg.sender` Is Not Admin Or Owner\");\n        _;\n    }\n\n    /**\n     * @dev onlyOwner Access Control\n     */\n    modifier onlyOwner\n    {\n        require(msg.sender == Params._Owner, \"Launchpad | onlyOwner | `msg.sender` Is Not Owner\");\n        _;\n    }\n}\n\n/**\n * @dev Interface For The Live Mint Smart Contract\n */\ninterface ILiveMint\n{\n    struct Params\n    {\n        address _MintPass;        // [0] -> _MintPass\n        address _Minter;          // [1] -> _Minter\n        address _PolyptychSource; // [2] -> _PolyptychSource\n        uint _MaxSupply;          // [3] -> _MaxSupply\n        uint _MintPassProjectID;  // [4] -> _MintPassProjectID\n        uint _ArtBlocksProjectID; // [5] -> _ArtBlocksProjectID \n        uint _PolyStart;          // [6] -> _PolyStart\n        uint _PolyEnd;            // [7] -> _PolyEnd\n    }\n\n    /**\n     * @dev Initializes Live Mint & Returns LiveMintProjectID\n     */\n    function __InitLiveMint ( Params memory ) external returns ( uint );\n}\n\n/**\n * @dev Interface For The Marketplace Smart Contract\n */\ninterface IMarketplace \n{ \n    struct Sale\n    {\n        string _Name;                     // [0] -> _Name\n        uint _ProjectIDMintPass;          // [1] -> _ProjectIDMintPass\n        uint _ProjectIDArtBlocks;         // [2] -> _ProjectIDArtBlocks\n        uint _PriceStart;                 // [3] -> _PriceStart\n        uint _PriceEnd;                   // [4] -> _PriceEnd\n        uint _MaxAmtPerPurchase;          // [5] -> _MaxAmtPerPurchase\n        uint _MaximumAvailableForSale;    // [6] -> _MaximumAvailableForSale\n        uint _StartingBlockUnixTimestamp; // [7] -> _StartingBlockUnixTimestamp\n        uint _SecondsBetweenPriceDecay;   // [8] -> _SecondsBetweenPriceDecay\n        uint _SaleStrip;                  // [9] -> _SaleStrip note: For Traditional MintPack transferFrom() Sales \n    }\n\n    struct State\n    {\n        address _NFT;           // [0] -> _NFT\n        address _Operator;      // [1] _Operator (Wallet That NFT Is Pulling From)\n        uint _CurrentIndex;     // [2] _CurrentIndex (If Simple Sale Type, This Is The Next Token Index To Iterate Upon)\n        uint _Type;             // [3] _SaleType (0 = Simple, 1 = TransferFrom, 2 = PurchaseTo, 3 = MintPack)\n        bool _ActivePublic;     // [4] -> _ActivePublic\n        bool _ActiveBrightList; // [5] -> _ActiveBrightList \n        bool _Discount;         // [6] -> _Discount\n        bool _ActiveRespend;    // [7] -> _ActiveRespend\n    }\n\n    struct FixedPriceSale\n    {\n        uint _Price;             // [0] -> _Price\n        uint _ProjectIDMintPass; // [1] -> _ProjectIDMintPass\n        uint _Type;              // [2] -> _Type\n        uint _ABProjectID;       // [3] -> _ABProjectID\n        uint _AmountSold;        // [4] -> _AmountSold\n        uint _AmountForSale;     // [5] -> _AmountForSale\n        address _NFT;            // [6] -> _NFT\n        bytes32 _Root;           // [7] -> _Root\n    }\n\n    /**\n     * @dev Starts A Sale On The BasicMarketplace Contract\n     */\n    function __StartSale(FixedPriceSale memory) external;\n\n    /**\n     * @dev Initiates A New Sale On The DutchMarketplace Contract\n     * Returns MarketplaceSaleID\n     */\n    function __StartSale (\n        Sale memory _Sale, \n        State memory _State, \n        bytes32[] calldata RootsPrioriy, \n        bytes32[] calldata RootsAmounts, \n        uint[] calldata DiscountAmounts\n    ) external returns ( uint );\n}\n\n/**\n * @dev Interface For Mint Pass Factory\n */\ninterface IMintPass\n{\n    struct Params\n    {\n        uint _MaxSupply;\n        uint _MintPacks;\n        uint _ArtistIDs;\n        uint _ArtBlocksProjectID;\n        uint _Reserve;\n        string _MetadataURI;\n    }\n\n    /**\n     * @dev Creates A New Mint Pass Project & Returns MintPassProjectID\n     */\n    function __InitMintPass ( Params memory ) external returns ( uint _MintPassID );\n\n    /**\n     * @dev Updates The Base URI For A Mint Pass Project\n     */\n    function __NewBaseURI ( uint MintPassProjectID, string calldata BaseURI ) external;\n}\n\n/**\n * @dev Interface For Minted Works, Either ArtBlocks or Non-ArtBlocks\n */\ninterface IMinter \n{ \n    /**\n     * @dev Paramters For Custom Minted Work\n     */\n    struct ParamsCustom\n    {\n        string _Name;\n        string _Symbol;\n        string _MetadataMintedWork;\n    }\n\n    /**\n     * @dev Paramters For Minted Work\n     */\n    struct ParamsArtBlocks\n    {\n        string _Name;\n        address _ArtistAddress;\n        address _ArtBlocksCore;\n    }\n\n    /**\n     * @dev ArtBlocks Add Project\n     */\n    function addProject ( string calldata Name, address ArtistAddress, uint PricePerTokenInWei ) external;\n\n    /**\n     * @dev ArtBlocks Toggle Project Active\n     */\n    function toggleProjectIsActive( uint ProjectID ) external;\n\n    /**\n     * @dev Custom Add Project\n     */\n    function __addProject( ParamsCustom memory ) external;\n\n    /**\n     * @dev Updates Project Artist Address\n     */\n    function updateProjectArtistAddress ( uint ProjectID, address ArtistAddress ) external;\n\n    /**\n     * @dev Updates Project Currency Info\n     */\n    function updateProjectCurrencyInfo ( uint ProjectID, string memory CurrencySymbol, address ERC20 ) external;\n}\n\n/**\n * @dev Interface For The Launchpad Registry\n */\ninterface ILaunchpadRegistry\n{\n    struct Project\n    {\n        string _Name;\n        bool _Active;\n        bool _ArtBlocks;\n        uint _ArtBlocksProjectID;\n        uint _LiveMintArtistID;\n        uint _MaxSupply;\n        uint _MintPacks;\n        uint _NumArtistIDs;\n        uint _DutchMarketplaceSaleID;\n        string _MetadataMintPass;\n        string _MetadataMintedWork;\n        address _MintPassAddress;\n        address _MintedWorkAddress;\n    }\n\n    /**\n     * @dev Adds A New Project To The Launchpad Registry\n     */\n    function __NewProject ( Project memory ) external returns (uint);\n\n    /**\n     * @dev Updates The Mint Pass URI For A Project \n     */\n    function __NewMintPassURI ( uint MintPassProjectID, string calldata URI ) external;\n    \n    /**\n     * @dev Returns ArtBlocksProjectID Of LaunchpadProjectID\n     */\n    function ViewArtBlocksProjectID ( uint ProjectID ) external view returns ( uint );\n}\n\n/**\n * @dev Interface To Upgrade The Launchpad Contract\n */\ninterface ICustom { function _____NewLaunchpadAddress ( address NewAddress ) external; }\n\n/**\n * @dev Abstract Contract To Recieve The Next ProjectID From ArtBlocks\n */\nabstract contract ArtBlocksCore { uint public nextProjectId; }"}, "contracts/LaunchpadEnabled.sol": {"content": "//SPDX-License-Identifier: MIT\n/**\n * @dev @brougkr\n */\npragma solidity ^0.8.30;\nabstract contract LaunchpadEnabled\n{\n    /**\n     * @dev The Launchpad Address\n     */\n    address public _LAUNCHPAD = 0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700;\n\n    /**\n     * @dev Updates The Launchpad Address From Launchpad (batch upgrade)\n     */ \n    function _____NewLaunchpadAddress(address NewAddress) external onlyLaunchpad { _LAUNCHPAD = NewAddress; }\n\n    /**\n     * @dev Access Control Needed For A Contract To Be Able To Use The Launchpad\n    */\n    modifier onlyLaunchpad()\n    {\n        require(_LAUNCHPAD == msg.sender, \"onlyLaunchpad: Caller Is Not Launchpad\");\n        _;\n    }\n}"}, "contracts/LaunchpadRegistry.sol": {"content": "//SPDX-License-Identifier: MIT\n/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\n/** \n * @dev @brougkr\n * The Launchpad Registry Contains Information About All Projects That Have Been Created Through The Launchpad Contract\n */\npragma solidity ^0.8.30;\ncontract LaunchpadRegistry\n{   \n    struct Project\n    {\n        string _Name;\n        bool _Active;\n        bool _ArtBlocks;\n        uint _ArtBlocksProjectID;\n        uint _LiveMintArtistID;\n        uint _MaxSupply;\n        uint _MintPacks;\n        uint _NumArtistIDs;\n        uint _MarketplaceSaleID;\n        string _MetadataMintedWork;\n        string _MetadataMintPass;\n        address _MintPassAddress;\n        address _MintedWorkAddress;\n    }\n\n    uint public UniqueProjectsInvoked;\n    bytes32 private constant _AUTHORIZED = keccak256(\"AUTHORIZED\");\n    bytes32 private constant _ADMIN = keccak256(\"ADMIN\");\n    bytes32 private constant _OWNER = keccak256(\"OWNER\");\n    mapping(uint=>Project) public Projects;\n    mapping(address=>bytes32) public Role;\n\n    event NewProjectInvoked(uint ProjectID);\n    event OwnershipTransferred(address OldOwner, address NewOwner);\n\n    constructor() \n    { \n        Role[0xB96E81f80b3AEEf65CB6d0E280b15FD5DBE71937] = _ADMIN; // brightmoments.eth\n        Role[0x18B7511938FBe2EE08ADf3d4A24edB00A5C9B783] = _ADMIN; // phil.brightmoments.eth\n        Role[0x38E27a59d3cffB945aC8d41b7c398618354c08F6] = _ADMIN; // gitpancake.brightmoments.eth\n        Role[msg.sender] = _OWNER;\n    }\n\n    /**\n     * @dev Initializes A New Project Into The Launchpad Registry\n     */\n    function __NewProject(Project memory _Project) external onlyAuthorized returns (uint)\n    {\n        Projects[UniqueProjectsInvoked] = _Project;\n        emit NewProjectInvoked(UniqueProjectsInvoked);\n        UniqueProjectsInvoked++;\n        return (UniqueProjectsInvoked - 1);\n    }\n\n    /**\n     * @dev Updates The BaseURI For A Project\n     */\n    function __NewMintPassURI(uint ProjectID, string memory URI) external onlyAuthorized { Projects[ProjectID]._MetadataMintedWork = URI; }\n\n    /**\n     * @dev Updates The Minted Work Address\n     */\n    function ___NewMintedWorkURI(uint ProjectID, string calldata URI) external onlyAdmin { Projects[ProjectID]._MetadataMintedWork = URI; }\n\n    /**\n     * @dev Updates The Minted Pass Metadata URI\n     */\n    function ___NewMintPassURI(uint ProjectID, string calldata URI) external onlyAdmin { Projects[ProjectID]._MetadataMintPass = URI; }\n\n    /**\n     * @dev Adds An Admin\n     */\n    function ____AdminAdd(address Wallet) external onlyOwner { Role[Wallet] = _ADMIN; }\n\n    /**\n     * @dev Removes An Admin\n     */\n    function ____AdminRemove(address Wallet) external onlyOwner { Role[Wallet] = 0x0; }\n\n    /**\n     * @dev Authorizes A Contract Address\n     */\n    function ____AuthorizeContract(address ContractAddress) external onlyOwner { Role[ContractAddress] = _AUTHORIZED; }\n\n    /**\n     * @dev Deauthorizes A Contract Address\n     */\n    function ____DeauthorizeContract(address ContractAddress) external onlyOwner { Role[ContractAddress] = 0x0; }\n\n    /**\n     * @dev Transfers Ownership Of The Contract\n     */\n    function ____TransferOwnership(address NewOwner) external onlyOwner \n    { \n        Role[msg.sender] = 0x0;\n        Role[NewOwner] = _OWNER; \n        emit OwnershipTransferred(msg.sender, NewOwner);\n    }\n\n    /**\n     * @dev Views A Project\n     */\n    function ViewProject(uint ProjectID) public view returns(Project memory) { return Projects[ProjectID]; }\n\n    /**\n     * @dev Returns An Array Of Projects\n     */\n    function ViewProjects(uint[] calldata Indexes) public view returns(Project[] memory) \n    { \n        Project[] memory _Projects = new Project[](Indexes.length);\n        for(uint x; x < Indexes.length; x++) { _Projects[x] = Projects[Indexes[x]]; }\n        return _Projects;\n    }\n\n    /**\n     * @dev Views Projects Within A Range (StartingIndex, EndingIndex) Inclusive\n     */\n    function ViewProjectsInRange(uint StartingIndex, uint EndingIndex) public view returns(Project[] memory) \n    { \n        Project[] memory _Projects = new Project[](EndingIndex - StartingIndex);\n        for(uint x; x < EndingIndex - StartingIndex; x++) { _Projects[x] = Projects[StartingIndex + x]; }\n        return _Projects;\n    }\n\n    /**\n     * @dev Returns Active Projects\n     */\n    function ViewActiveProjects() public view returns(Project[] memory) \n    { \n        uint Found;\n        uint[] memory ProjectIDs = new uint[](UniqueProjectsInvoked);\n        for(uint x; x < UniqueProjectsInvoked; x++)\n        {\n            if(Projects[x]._Active)\n            {\n                ProjectIDs[Found] = x;\n                Found++;\n            }\n        }\n        Project[] memory _ProjectIDs = new Project[](Found);\n        for(uint y; y < Found; y++)\n        {\n            _ProjectIDs[y] = Projects[ProjectIDs[y]];\n        }\n        return _ProjectIDs;\n    }\n\n    /**\n     * @dev Returns The Associated ArtBlocks ProjectID Of A Launchpad Project (if applicable)\n     * note: Returns Max Integer If The Launchpad ProjectID Is Not Associated With An ArtBlocks Project\n     */\n    function ViewArtBlocksProjectID(uint LaunchpadProjectID) public view returns(uint) \n    { \n        return Projects[LaunchpadProjectID]._ArtBlocksProjectID; \n    }\n\n    /**\n     * @dev Returns The Minted Work BaseURI For A Project\n     */\n    function ViewBaseURIMintedWork(uint ProjectID) public view returns(string memory) \n    { \n        return Projects[ProjectID]._MetadataMintedWork; \n    }\n    \n    /**\n     * @dev Returns The Mint Pass BaseURI For A Project\n     */\n    function ViewBaseURIMintPass(uint ProjectID) public view returns(string memory) \n    { \n        return Projects[ProjectID]._MetadataMintPass; \n    }\n\n    /**\n     * @dev Admin Access Modifier\n     */\n    modifier onlyAuthorized\n    {\n        require(Role[msg.sender] == _AUTHORIZED, \"Registry: `msg.sender` Is Not Authorized\");\n        _;\n    }\n\n    /**\n     * @dev Admin Access Modifier\n     */\n    modifier onlyAdmin\n    {\n        require(Role[msg.sender] == _ADMIN || Role[msg.sender] == _OWNER, \"Registry: `msg.sender` Is Not Admin Or Owner\");\n        _;\n    }\n\n    /**\n     * @dev Owner Access Modifier\n     */\n    modifier onlyOwner\n    {\n        require(Role[msg.sender] == _OWNER, \"Registry: `msg.sender` Is Not Owner\");\n        _;\n    }\n}"}, "contracts/LiveMintBuenosAires.sol": {"content": "// SPDX-License-Identifier: MIT\n/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\n/**\n * @dev: @brougkr\n */\npragma solidity ^0.8.30;\nimport { IERC721 } from \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { MerkleProof } from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport { IMinter } from \"./IMinter.sol\";\nimport { IMP } from \"./IMP.sol\";\nimport { IGT } from \"./IGT.sol\";\nimport { LaunchpadEnabled } from \"./LaunchpadEnabled.sol\";\ncontract LiveMintBuenosAires is Ownable, ReentrancyGuard, LaunchpadEnabled\n{  \n    struct City\n    {\n        string _Name;         // _Name\n        uint _QRCurrentIndex; // _QRCurrentIndex (Should be Always Be 333 + (333 * (City# % 6))\n        address _ERC20;       // _ERC20  \n        bytes32 _Root;        // _Root\n    }\n\n    struct Artist\n    {\n        address _MintPass;        // _MintPass\n        address _Minter;          // _Minter\n        address _PolyptychSource; // _PolyptychSource\n        uint _MaxSupply;          // _MaxSupply\n        uint _MintPassProjectID;  // _MintPassProjectID\n        uint _ArtBlocksProjectID; // _ArtBlocksProjectID \n        uint _PolyStart;          // _PolyStart\n        uint _PolyEnd;            // _PolyEnd\n    }\n\n    struct User\n    {\n        bool _Eligible;   // _Eligible\n        uint _Allocation; // _Allocation\n    }\n\n    /*-------------------*/\n    /*  STATE VARIABLES  */\n    /*-------------------*/\n\n    bytes32 private constant _AUTHORIZED = keccak256(\"AUTHORIZED\");                        // Authorized Role\n    bytes32 private constant _MINTER_ROLE = keccak256(\"MINTER_ROLE\");                      // Minter Role\n    address private constant _DN = 0x00000000000076A84feF008CDAbe6409d2FE638B;             // delegate.cash Delegation Registry\n    address private constant _GOLDEN_TOKEN = 0x985e1932FFd2aA4bC9cE611DFe12816A248cD2cE;   // Golden Token Address\n    address private constant _CITIZEN_MINTER = 0xDd06d8483868Cd0C5E69C24eEaA2A5F2bEaFd42b; // ArtBlocks Minter Contract\n    address private constant _BRT_MULTISIG = 0xB96E81f80b3AEEf65CB6d0E280b15FD5DBE71937;   // BRT Multisig\n    address public _Pindar;                                                                // Pindar Van Arman's Custom Minter Contract\n    uint public _CurrentCityIndex = 6;                                                     // Current City Index\n    uint public _UniqueArtistsInvoked;                                                     // Unique Artists Invoked\n\n    /*-------------------*/\n    /*     MAPPINGS      */\n    /*-------------------*/\n    \n    mapping(uint => Artist) public Artists;                              // [ArtistID] => Artist\n    mapping(uint => City) public Cities;                                 // [CityIndex] => City Struct\n    mapping(uint => mapping(address => bool)) public _QRRedeemed;        // [CityIndex][Wallet] => If User Has Redeemed QR\n    mapping(uint => mapping(address => uint)) public _QRAllocation;      // [CityIndex][Wallet] => Wallet's QR Code Allocation\n    mapping(uint => mapping(uint => address)) public _BrightListCitizen; // [CityIndex][TicketID] => Address Of CryptoCitizen Minting Recipient \n    mapping(uint => mapping(uint => address)) public _BrightListArtist;  // [ArtistID][TicketID] => Address Of Artist NFT Recipient\n    mapping(uint => mapping(uint => string)) public _DataArtists;        // [ArtistID][TicketID] => Artist Data\n    mapping(uint => mapping(uint => string)) public _DataCitizens;       // [CityIndex][TicketID] => Data For Golden Token Checkins\n    mapping(uint => mapping(uint => uint)) public _MintedTokenIDCitizen; // [CityIndex][TicketID] => MintedTokenID\n    mapping(uint => mapping(uint => uint)) public _MintedTokenIDArtist;  // [ArtistID][TicketID] => MintedTokenID\n    mapping(uint => mapping(uint => bool)) public _MintedArtist;         // [ArtistID][TicketID] => If Minted\n    mapping(uint => mapping(uint => bool)) public _MintedCitizen;        // [CityIndex][TicketID] => If Golden Ticket ID Has Minted Or Not\n    mapping(uint => mapping(uint => uint)) public _ArtBlocksProjectID;   // [ArtistID][TicketID] => ArtBlocksProjectID\n    mapping(address => bytes32) public Role;                             // [Wallet] => BRT Minter Role\n    mapping(uint => uint) public AmountRemaining;                        // [ArtistID] => Mints Remaining\n\n    /*-------------------*/\n    /*      EVENTS       */\n    /*-------------------*/\n\n    /**\n     * @dev Emitted When `Redeemer` IRL-mints CryptoCitizen Corresponding To Their Redeemed `TicketID`.\n     **/\n    event LiveMintComplete(address Redeemer, uint TicketID, uint TokenID, string Data);\n\n    /**\n     * @dev Emitted When `Redeemer` IRL-mints A Artist NFT Corresponding To Their Redeemed `TicketID`.\n     */\n    event LiveMintCompleteArtist(address Recipient, uint ArtistID, uint TicketID, uint MintedWorkTokenID);\n\n    /**\n     * @dev Emitted When `Redeemer` Redeems Golden Token Corresponding To `TicketID` \n     **/\n    event QRRedeemed(address Redeemer, uint TicketID, string Data, string Type);\n\n    /**\n     * @dev Emitted When A Contract Is Authorized\n     */\n    event AuthorizedContract(address NewAddress);\n\n    /**\n     * @dev Emitted When A Contract Is Deauthorized\n     */\n    event DeauthorizedContract(address NewAddress);\n\n    /*-------------------*/\n    /*    CONSTRUCTOR    */\n    /*-------------------*/\n\n    constructor()\n    { \n        Cities[0]._Name = \"CryptoGalacticans\";  \n        Cities[1]._Name = \"CryptoVenetians\";    \n        Cities[2]._Name = \"CryptoNewYorkers\";   \n        Cities[3]._Name = \"CryptoBerliners\";    \n        Cities[4]._Name = \"CryptoLondoners\";    \n        Cities[5]._Name = \"CryptoMexas\";        \n        Cities[6]._Name = \"CryptoTokyites\";     \n        Cities[6]._QRCurrentIndex = 333;\n        Cities[6]._Root = 0x255b8b82ee0d1823cdc3cf859efacfee1111414bacab649a7e8bea9cd48a0ed3;\n        Cities[7]._Name = \"CryptoCitizen City #8\"; \n        Cities[7]._QRCurrentIndex = 666;\n        Cities[8]._Name = \"CryptoCitizen City #9\";\n        Cities[8] ._QRCurrentIndex = 999;\n        Cities[9]._Name = \"CryptoCitizen City #10\";\n        Cities[10]._QRCurrentIndex = 1332; \n        Role[0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700] = _AUTHORIZED;  // `operator.brightmoments.eth`\n        Role[0x1A0a3E3AE390a0710f8A6d00587082273eA8F6C9] = _MINTER_ROLE; // BRT Minter #1\n        Role[0x4d8013b0c264034CBf22De9DF33e22f58D52F207] = _MINTER_ROLE; // BRT Minter #2\n        Role[0x4D9A8CF2fE52b8D49C7F7EAA87b2886c2bCB4160] = _MINTER_ROLE; // BRT Minter #3\n        Role[0x124fd966A0D83aA020D3C54AE2c9f4800b46F460] = _MINTER_ROLE; // BRT Minter #4\n        Role[0x100469feA90Ac1Fe1073E1B2b5c020A8413635c4] = _MINTER_ROLE; // BRT Minter #5\n        Role[0x756De4236373fd17652b377315954ca327412bBA] = _MINTER_ROLE; // BRT Minter #6\n        Role[0xc5Dfba6ef7803665C1BDE478B51Bd7eB257A2Cb9] = _MINTER_ROLE; // BRT Minter #7\n        Role[0xFBF32b29Bcf8fEe32d43a4Bfd3e7249daec457C0] = _MINTER_ROLE; // BRT Minter #8\n        Role[0xF2A15A83DEE7f03C70936449037d65a1C100FF27] = _MINTER_ROLE; // BRT Minter #9\n        Role[0x1D2BAB965a4bB72f177Cd641C7BacF3d8257230D] = _MINTER_ROLE; // BRT Minter #10\n        Role[0x2e51E8b950D72BDf003b58E357C2BA28FB77c7fB] = _MINTER_ROLE; // BRT Minter #11\n        Role[0x8a7186dECb91Da854090be8226222eA42c5eeCb6] = _MINTER_ROLE; // BRT Minter #12\n    }\n\n    /*---------------------*/\n    /*    QR REDEMPTION    */\n    /*---------------------*/\n\n    /**\n     * @dev Redeems Spot For IRL Minting\n     */\n    function RedeemQR(string[] calldata Data, string[] calldata Type, bytes32[] calldata Proof, address Vault, uint Amount) external nonReentrant \n    {        \n        address Recipient = msg.sender;\n        if(Vault != address(0)) { if(IDelegationRegistry(_DN).checkDelegateForAll(msg.sender, Vault)) { Recipient = Vault; } } \n        require(readQREligibility(Recipient, Proof), \"LiveMint: User Is Not Eligible To Redeem QR\");\n        if(_QRAllocation[_CurrentCityIndex][Recipient] == 0) // User Is Able To Redeem Explicitly 1 QR Code\n        {\n            require(!_QRRedeemed[_CurrentCityIndex][Recipient], \"LiveMint: User Has Already Redeemed\");\n            _DataCitizens[_CurrentCityIndex][Cities[_CurrentCityIndex]._QRCurrentIndex] = Data[0];\n            _BrightListCitizen[_CurrentCityIndex][Cities[_CurrentCityIndex]._QRCurrentIndex] = Recipient;\n            emit QRRedeemed(Recipient, Cities[_CurrentCityIndex]._QRCurrentIndex, Data[0], Type[0]);\n            Cities[_CurrentCityIndex]._QRCurrentIndex++; \n        }\n        else // User Is Able To Redeem More Than 1 QR Code Because Their QRAllocation > 0\n        {\n            require(Amount <= _QRAllocation[_CurrentCityIndex][Recipient], \"LiveMint: Amount Must Be Less Than Or Equal To QRAllocation\");\n            uint _CurrentQR = Cities[_CurrentCityIndex]._QRCurrentIndex;\n            uint _Limit = Amount + _CurrentQR;\n            uint _Counter;\n            _QRAllocation[_CurrentCityIndex][Recipient] -= Amount;\n            Cities[_CurrentCityIndex]._QRCurrentIndex = _Limit;\n            for(_CurrentQR; _CurrentQR < _Limit; _CurrentQR++)\n            {\n                _DataCitizens[_CurrentCityIndex][_CurrentQR] = Data[_Counter];\n                _BrightListCitizen[_CurrentCityIndex][_CurrentQR] = Recipient;\n                emit QRRedeemed(Recipient, _CurrentQR, Data[_Counter], Type[_Counter]);\n                _Counter++;\n            }\n        }\n        _QRRedeemed[_CurrentCityIndex][Recipient] = true;\n    }\n\n    /*--------------------*/\n    /*    LIVE MINTING    */\n    /*--------------------*/\n\n    /**\n     * @dev Batch Mints Verified Users On The Brightlist CryptoCitizens\n     * note: { For CryptoCitizen Cities }\n     */\n    function _LiveMintCitizen(uint[] calldata TicketIDs) external onlyMinter\n    {\n        address Recipient;\n        uint MintedWorkTokenID;\n        for(uint TicketID; TicketID < TicketIDs.length; TicketID++)\n        {\n            require(!_MintedCitizen[_CurrentCityIndex][TicketIDs[TicketID]], \"LiveMint: Golden Token Already Minted\");\n            if(_BrightListCitizen[_CurrentCityIndex][TicketIDs[TicketID]] != address(0))\n            {\n                Recipient = _BrightListCitizen[_CurrentCityIndex][TicketIDs[TicketID]];\n            }\n            else if (TicketIDs[TicketID] <= 333) { Recipient = IGT(_GOLDEN_TOKEN)._LiveMintBurn(TicketIDs[TicketID]); }\n            else { revert(\"LiveMint: Invalid TicketID\"); }\n            require(Recipient != address(0), \"LiveMint: Invalid Recipient\");\n            _MintedCitizen[_CurrentCityIndex][TicketIDs[TicketID]] = true;\n            MintedWorkTokenID = IMinter(_CITIZEN_MINTER).purchaseTo(Recipient, _CurrentCityIndex);\n            _MintedTokenIDCitizen[_CurrentCityIndex][TicketIDs[TicketID]] = MintedWorkTokenID;\n            emit LiveMintComplete(Recipient, TicketIDs[TicketID], MintedWorkTokenID, _DataCitizens[_CurrentCityIndex][TicketIDs[TicketID]]); \n        }\n    }\n\n    /**\n     * @dev Burns Artist Mint Pass In Exchange For The Minted Work\n     * note: { For Instances Where Multiple Artists Share The Same Mint Pass & Return (Recipient, ArtBlocksProjectID) }\n     */\n    function _LiveMintArtist(uint ArtistID, uint[] calldata TicketIDs) external onlyMinter\n    {\n        address Recipient;\n        address MintPass = Artists[ArtistID]._MintPass;\n        address Minter = Artists[ArtistID]._Minter;\n        uint ArtBlocksProjectID;\n        uint MintedWorkTokenID;\n        uint TicketID;\n        require(AmountRemaining[ArtistID] > 0, \"LiveMint: ArtistID Mint Limit Reached\");\n        require(TicketIDs.length <= AmountRemaining[ArtistID], \"LiveMint: TicketID Length Exceeds ArtistID Mint Limit\");\n        AmountRemaining[ArtistID] = AmountRemaining[ArtistID] - TicketIDs.length;\n        for(uint x; x < TicketIDs.length; x++)\n        {\n            TicketID = TicketIDs[x];\n            require(!_MintedArtist[ArtistID][TicketID], \"LiveMint: Artist Mint Pass Already Minted\");\n            _MintedArtist[ArtistID][TicketID] = true;\n            (Recipient, ArtBlocksProjectID) = IMP(MintPass)._LiveMintBurn(TicketID);\n            if(ArtBlocksProjectID == 100) { MintedWorkTokenID = IMinter(_Pindar).purchaseTo(Recipient); } // Pindar Custom Contract \n            else { MintedWorkTokenID = IMinter(Minter).purchaseTo(Recipient, ArtBlocksProjectID); } // Pre-Defined Minter Contract\n            _MintedTokenIDArtist[ArtistID][TicketID] = MintedWorkTokenID;\n            emit LiveMintCompleteArtist(Recipient, ArtistID, TicketID, MintedWorkTokenID);\n        }\n    }\n\n    /**\n     * @dev Burns Artist Mint Pass In Exchange For The Minted Work\n     * note: { For Instances Where Multiple Artists Share The Same Mint Pass & Return (Recipient, ArtBlocksProjectID) }\n     */\n    function _LiveMintArtistBatch(uint[] calldata ArtistIDs, uint[][] calldata TicketIDs) external onlyMinter\n    {\n        address Recipient;\n        address MintPass;\n        address Minter;\n        uint ArtBlocksProjectID;\n        uint MintedWorkTokenID;\n        uint TicketID;\n        uint ActiveArtistID;\n        for(uint ArtistIDIndex; ArtistIDIndex < ArtistIDs.length; ArtistIDIndex++)\n        {\n            ActiveArtistID = ArtistIDs[ArtistIDIndex];\n            MintPass = Artists[ActiveArtistID]._MintPass;\n            Minter = Artists[ActiveArtistID]._Minter;\n            for(uint TicketIDIndex; TicketIDIndex < TicketIDs[ArtistIDIndex].length; TicketIDIndex++)\n            {\n                TicketID = TicketIDs[ArtistIDIndex][TicketIDIndex];\n                require(!_MintedArtist[ActiveArtistID][TicketID], \"LiveMint: Artist Mint Pass Already Minted\");\n                _MintedArtist[ActiveArtistID][TicketID] = true;\n                (Recipient, ArtBlocksProjectID) = IMP(MintPass)._LiveMintBurn(TicketID);\n                if(ArtBlocksProjectID == 100) { MintedWorkTokenID = IMinter(_Pindar).purchaseTo(Recipient); }\n                else { MintedWorkTokenID = IMinter(Minter).purchaseTo(Recipient, ArtBlocksProjectID); }\n                _MintedTokenIDArtist[ActiveArtistID][TicketID] = MintedWorkTokenID;\n                emit LiveMintCompleteArtist(Recipient, ActiveArtistID, TicketID, MintedWorkTokenID);\n            }\n        }\n    }\n\n    /*-------------------*/\n    /*  OWNER FUNCTIONS  */\n    /*-------------------*/\n\n    /**\n     * @dev Grants Address BRT Minter Role\n     **/\n    function __AddMinter(address Minter) external onlyOwner { Role[Minter] = _MINTER_ROLE; }\n    \n    /**\n     * @dev Deactivates Address From BRT Minter Role\n     **/\n    function __RemoveMinter(address Minter) external onlyOwner { Role[Minter] = 0x0; }\n\n    /**\n     * @dev Changes Mint Pass Address For Artist LiveMints\n     */\n    function __ChangeMintPass(uint ProjectID, address Contract) external onlyOwner { Artists[ProjectID]._MintPass = Contract; }\n\n    /**\n     * @dev Changes Merkle Root For Citizen LiveMints\n     */\n    function __ChangeRootCitizen(bytes32 NewRoot) external onlyOwner { Cities[_CurrentCityIndex]._Root = NewRoot; }\n\n    /**\n     * @dev Overwrites QR Allocation\n     */\n    function __QRAllocationsOverwrite(address[] calldata Addresses, uint[] calldata Amounts) external onlyOwner\n    {\n        require(Addresses.length == Amounts.length, \"LiveMint: Input Arrays Must Match\");\n        for(uint x; x < Addresses.length; x++) { _QRAllocation[_CurrentCityIndex][Addresses[x]] = Amounts[x]; }\n    }\n\n    /**\n     * @dev Increments QR Allocations\n     */\n    function __QRAllocationsIncrement(address[] calldata Addresses, uint[] calldata Amounts) external onlyOwner\n    {\n        require(Addresses.length == Amounts.length, \"LiveMint: Input Arrays Must Match\");\n        for(uint x; x < Addresses.length; x++) { _QRAllocation[_CurrentCityIndex][Addresses[x]] += Amounts[x]; }\n    }\n\n    /**\n     * @dev Mints To Multisig\n     */\n    function __QRAllocationsSetNoShow(uint[] calldata TicketIDs) external onlyOwner\n    {\n        for(uint TicketIndex; TicketIndex < TicketIDs.length; TicketIndex++)\n        {\n            require(!_MintedCitizen[_CurrentCityIndex][TicketIDs[TicketIndex]], \"LiveMint: Ticket ID Already Minted\");\n            _BrightListCitizen[_CurrentCityIndex][TicketIDs[TicketIndex]] = _BRT_MULTISIG;\n        }\n    }\n\n    /**\n     * @dev Changes QR Current Index\n     */\n    function __ChangeQRIndex(uint NewIndex) external onlyOwner { Cities[_CurrentCityIndex]._QRCurrentIndex = NewIndex; }\n\n    /**\n     * @dev Changes Pindar's Minter Address\n     */\n    function __ChangePindarAddress(address NewAddress) external onlyOwner { _Pindar = NewAddress; }\n\n    /**\n     * @dev Batch Approves BRT For Purchasing\n     */\n    function __BatchApproveERC20(address[] calldata ERC20s, address[] calldata Operators) external onlyOwner\n    {\n        require(ERC20s.length == Operators.length, \"LiveMint: Arrays Must Be Equal Length\");\n        for(uint x; x < ERC20s.length; x++) { IERC20(ERC20s[x]).approve(Operators[x], 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff); }\n    }\n\n    /**\n     * @dev Instantiates New City\n     * note: CityIndex Always Corresponds To ArtBlocks ProjectID\n     */\n    function __NewCity (\n        string calldata Name,\n        uint CityIndex,\n        uint QRIndex,\n        address ERC20\n    ) external onlyOwner {\n        Cities[CityIndex] = City(\n            Name,\n            QRIndex,\n            ERC20,\n            0x6942069420694206942069420694206942069420694206942069420694206942\n        );\n    }\n\n    /**\n     * @dev Overrides An Artist\n     */\n    function __OverrideArtist(uint ArtistID, Artist memory NewArtist) external onlyOwner { Artists[ArtistID] = NewArtist; }\n\n    /**\n     * @dev Instantiates A New City\n     */\n    function __NewCityStruct(uint CityIndex, City memory NewCity) external onlyOwner { Cities[CityIndex] = NewCity; }\n\n    /**\n     * @dev Returns An Artist Struct\n     */\n    function __NewArtistStruct(uint ArtistID, Artist memory NewArtist) external onlyOwner { Artists[ArtistID] = NewArtist; }\n\n    /**\n     * @dev Changes The Minter Address For An Artist\n     */\n    function __NewArtistMinter(uint ArtistID, address Minter) external onlyOwner { Artists[ArtistID]._Minter = Minter; }\n\n    /**\n     * @dev Withdraws Any Ether Mistakenly Sent to Contract to Multisig\n     **/\n    function __WithdrawEther() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }\n\n    /**\n     * @dev Withdraws ERC20 Tokens to Multisig\n     **/\n    function __WithdrawERC20(address TokenAddress) external onlyOwner \n    { \n        IERC20 erc20Token = IERC20(TokenAddress);\n        uint balance = erc20Token.balanceOf(address(this));\n        require(balance > 0, \"LiveMint: 0 ERC20 Balance At `TokenAddress`\");\n        erc20Token.transfer(msg.sender, balance);\n    }\n\n    /**\n     * @dev Withdraws Any NFT Mistakenly Sent To This Contract.\n     */\n    function __WithdrawERC721(address ContractAddress, address Recipient, uint TokenID) external onlyOwner\n    {\n        IERC721(ContractAddress).transferFrom(address(this), Recipient, TokenID);\n    }\n\n    /**\n     * @dev Authorizes A Contract To Mint\n     */\n    function ____AuthorizeContract(address NewAddress) external onlyOwner \n    { \n        Role[NewAddress] = _AUTHORIZED; \n        emit AuthorizedContract(NewAddress);\n    }\n\n    /**\n     * @dev Deauthorizes A Contract From Minting\n     */\n    function ___DeauthorizeContract(address NewAddress) external onlyOwner \n    { \n        Role[NewAddress] = 0x0; \n        emit DeauthorizedContract(NewAddress);\n    }\n    \n    /*-------------------*/\n    /*    PUBLIC VIEW    */\n    /*-------------------*/\n\n    /**\n     * @dev Returns A User's QR Allocation Amount, Or 0 If Not Eligible\n     */\n    function readEligibility(address Recipient, bytes32[] memory Proof) public view returns(uint)\n    {\n        bool Eligible = readQREligibility(Recipient, Proof);\n        if(!Eligible) { return 0; }\n        else if(Eligible && _QRAllocation[_CurrentCityIndex][Recipient] > 0) { return _QRAllocation[_CurrentCityIndex][Recipient]; }\n        else if(Eligible) { return 1; }\n        else { return 0; }\n    }\n\n    /**\n     * @dev Returns If User Is Eligible To Redeem QR Code\n     */\n    function readQREligibility(address Recipient, bytes32[] memory Proof) public view returns(bool)\n    {\n        bytes32 Leaf = keccak256(abi.encodePacked(Recipient));\n        bool BrightListEligible = MerkleProof.verify(Proof, Cities[_CurrentCityIndex]._Root, Leaf);\n        if(\n            (BrightListEligible && !_QRRedeemed[_CurrentCityIndex][Recipient])\n            || \n            (BrightListEligible && _QRAllocation[_CurrentCityIndex][Recipient] > 0)\n            \n        ) { return true; }\n        else { return false; }\n    }\n\n    /**\n     * @dev Returns An Array Of Unminted Golden Tokens\n     */\n    function readCitizenUnmintedTicketIDs() public view returns(uint[] memory)\n    {\n        uint[] memory UnmintedTokenIDs = new uint[](1000);\n        uint Counter;\n        uint CityIDBuffer = _CurrentCityIndex % 6 * 333;\n        uint _TokenID;\n        for(uint TokenID; TokenID < 1000; TokenID++)\n        {\n            _TokenID = TokenID + CityIDBuffer;\n            if\n            (\n                !_MintedCitizen[_CurrentCityIndex][_TokenID]\n                &&\n                _BrightListCitizen[_CurrentCityIndex][_TokenID] != address(0)\n            ) \n            { \n                UnmintedTokenIDs[Counter] = _TokenID; \n                Counter++;\n            }\n        }\n        uint[] memory FormattedUnMintedTokenIDs = new uint[](Counter);\n        uint Found;\n        for(uint FormattedTokenID; FormattedTokenID < Counter; FormattedTokenID++)\n        {\n            if(UnmintedTokenIDs[FormattedTokenID] != 0 || (UnmintedTokenIDs[FormattedTokenID] == 0 && FormattedTokenID == 0))\n            {\n                FormattedUnMintedTokenIDs[Found] = UnmintedTokenIDs[FormattedTokenID];\n                Found++;\n            }\n        }\n        return FormattedUnMintedTokenIDs;\n    }\n\n    /**\n     * @dev Returns An Array Of Unminted Golden Tokens\n     */\n    function readCitizenMintedTicketIDs(uint CityID) public view returns(uint[] memory)\n    {\n        uint[] memory MintedTokenIDs = new uint[](1000);\n        uint Counter;\n        uint CityIDBuffer = (CityID % 6) * 333;\n        uint _TicketID;\n        for(uint TicketID; TicketID < 1000; TicketID++)\n        {\n            _TicketID = TicketID + CityIDBuffer;\n            if(_MintedCitizen[CityID][_TicketID]) \n            { \n                MintedTokenIDs[Counter] = _TicketID; \n                Counter++;\n            }\n        }\n        uint[] memory FormattedMintedTokenIDs = new uint[](Counter);\n        uint Found;\n        for(uint FormattedTokenID; FormattedTokenID < Counter; FormattedTokenID++)\n        {\n            if(MintedTokenIDs[FormattedTokenID] != 0 || (MintedTokenIDs[FormattedTokenID] == 0 && FormattedTokenID == 0))\n            {\n                FormattedMintedTokenIDs[Found] = MintedTokenIDs[FormattedTokenID];\n                Found++;\n            }\n        }\n        return FormattedMintedTokenIDs;\n    }\n\n    /**\n     * @dev Returns A 2d Array Of Checked In & Unminted TicketIDs Awaiting A Mint\n     */\n    function readCitizenCheckedInTicketIDs() public view returns(uint[] memory TokenIDs)\n    {\n        uint[] memory _TokenIDs = new uint[](1000);\n        uint CityIDBuffer = (_CurrentCityIndex % 6) * 333;\n        uint _TicketID;\n        uint Counter;\n        for(uint TicketID; TicketID < 1000; TicketID++)\n        {\n            _TicketID = TicketID + CityIDBuffer;\n            if(\n                !_MintedCitizen[_CurrentCityIndex][_TicketID]\n                &&\n                _BrightListCitizen[_CurrentCityIndex][_TicketID] != address(0)\n            ) \n            { \n                _TokenIDs[Counter] = _TicketID; \n                Counter++;\n            }\n        }\n        uint[] memory FormattedCheckedInTickets = new uint[](Counter);\n        uint Found;\n        for(uint x; x < Counter; x++)\n        {\n            if(_TokenIDs[x] != 0 || (_TokenIDs[x] == 0 && x == 0))\n            {\n                FormattedCheckedInTickets[Found] = _TokenIDs[x];\n                Found++;\n            }\n        }\n        return FormattedCheckedInTickets;\n    }\n\n    /**\n     * @dev Returns A 2d Array Of Minted ArtistIDs\n     */\n    function readArtistUnmintedTicketIDs(uint[] calldata ArtistIDs, uint Range) public view returns(uint[][] memory TokenIDs)\n    {\n        uint[][] memory _TokenIDs = new uint[][](ArtistIDs.length);\n        uint Index;\n        for(uint ArtistID; ArtistID < ArtistIDs.length; ArtistID++)\n        {\n            address _Mintpass = Artists[ArtistID]._MintPass;\n            uint[] memory UnmintedArtistTokenIDs = new uint[](Range);\n            uint Counter;\n            for(uint TokenID; TokenID < Range; TokenID++)\n            {\n                bool TicketIDBurned;\n                try IERC721(_Mintpass).ownerOf(TokenID) { } // checks if token is burned\n                catch { TicketIDBurned = true; }\n                if(\n                    !_MintedArtist[ArtistIDs[ArtistID]][TokenID]\n                    &&\n                    (\n                        _BrightListArtist[ArtistIDs[ArtistID]][TokenID] != address(0)\n                        ||\n                        TicketIDBurned == false\n                    )\n                ) \n                { \n                    UnmintedArtistTokenIDs[Counter] = TokenID; \n                    Counter++;\n                }\n            }\n            uint[] memory FormattedUnMintedArtistIDs = new uint[](Counter);\n            uint Found;\n            for(uint x; x < Counter; x++)\n            {\n                if(UnmintedArtistTokenIDs[x] != 0 || (UnmintedArtistTokenIDs[x] == 0 && x == 0))\n                {\n                    FormattedUnMintedArtistIDs[Found] = UnmintedArtistTokenIDs[x];\n                    Found++;\n                }\n            }\n            _TokenIDs[Index] = FormattedUnMintedArtistIDs;\n            Index++;\n        }\n        return (_TokenIDs);\n    }\n\n    /**\n     * @dev Returns A 2d Array Of Minted ArtistIDs\n     */\n    function readArtistMintedTicketIDs(uint[] calldata ArtistIDs, uint Range) public view returns(uint[][] memory TokenIDs)\n    {\n        uint[][] memory _TokenIDs = new uint[][](ArtistIDs.length);\n        uint Index;\n        for(uint ArtistID; ArtistID < ArtistIDs.length; ArtistID++)\n        {\n            uint[] memory MintedTokenIDs = new uint[](Range);\n            uint Counter;\n            for(uint TokenID; TokenID < Range; TokenID++)\n            {\n                if(_MintedArtist[ArtistIDs[ArtistID]][TokenID])\n                { \n                    MintedTokenIDs[Counter] = TokenID; \n                    Counter++;\n                }\n            }\n            uint[] memory FormattedMintedTokenIDs = new uint[](Counter);\n            uint Found;\n            for(uint x; x < Counter; x++)\n            {\n                if(MintedTokenIDs[x] != 0 || (MintedTokenIDs[x] == 0 && x == 0))\n                {\n                    FormattedMintedTokenIDs[Found] = MintedTokenIDs[x];\n                    Found++;\n                }\n            }\n            _TokenIDs[Index] = FormattedMintedTokenIDs;\n            Index++;\n        }\n        return (_TokenIDs);\n    }\n\n    /**\n     * @dev Returns Original Recipients Of CryptoCitizens\n     */\n    function readCitizenBrightList(uint CityIndex) public view returns(address[] memory Recipients)\n    {\n        address[] memory _Recipients = new address[](1000);\n        uint Start = (CityIndex % 6) * 333;\n        for(uint x; x < 1000; x++) { _Recipients[x] = _BrightListCitizen[CityIndex][Start+x]; }\n        return _Recipients;\n    }\n\n    /**\n     * @dev Returns Original Recipient Of Artist NFTs\n     */\n    function readArtistBrightList(uint ArtistID, uint Range) public view returns(address[] memory Recipients)\n    {\n        address[] memory _Recipients = new address[](Range);\n        for(uint x; x < Range; x++) { _Recipients[x] = _BrightListArtist[ArtistID][x]; }\n        return _Recipients;    \n    }\n\n    /**\n     * @dev Returns The City Struct At Index Of `CityIndex`\n     */\n    function readCitizenCity(uint CityIndex) public view returns(City memory) { return Cities[CityIndex]; }\n\n    /**\n     * @dev Returns The Artist Struct At Index Of `ArtistID`\n     */\n    function readArtist(uint ArtistID) public view returns(Artist memory) { return Artists[ArtistID]; }\n\n    /**\n     * @dev Returns A Minted Work TokenID Corresponding To The Input Artist TicketID \n     */\n    function readArtistMintedTokenID(uint ArtistID, uint TicketID) external view returns (uint)\n    {\n        if(!_MintedArtist[ArtistID][TicketID]) { return 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff; }\n        else { return _MintedTokenIDArtist[ArtistID][TicketID]; }\n    }\n\n    /**\n     * @dev Returns A Minted Citizen TokenID Corresponding To Input TicketID\n     */\n    function readCitizenMintedTokenID(uint CityIndex, uint TicketID) external view returns(uint)\n    {\n        if(!_MintedCitizen[CityIndex][TicketID]) { return type(uint).max; }\n        else { return _MintedTokenIDCitizen[CityIndex][TicketID]; }  \n    }\n    \n    /*-------------------------*/\n    /*        LAUNCHPAD        */\n    /*-------------------------*/\n\n    /**\n     * @dev Initializes A LiveMint Artist\n     */\n    function __InitLiveMint(Artist memory _Params) external onlyAdmin returns (uint)\n    {\n        AmountRemaining[_UniqueArtistsInvoked] = _Params._MaxSupply;\n        Artists[_UniqueArtistsInvoked] = _Params;\n        _UniqueArtistsInvoked++;\n        return _UniqueArtistsInvoked - 1;\n    }\n\n    /*-------------------------*/\n    /*     ACCESS MODIFIERS    */\n    /*-------------------------*/\n\n    /**\n     * @dev Access Modifier That Allows Only BrightListed BRT Minters\n     **/\n    modifier onlyMinter() \n    {\n        require(Role[msg.sender] == _MINTER_ROLE, \"LiveMint | onlyMinter | Caller Is Not Approved BRT Minter\");\n        _;\n    }\n\n    /**\n     * @dev Access Modifier That Allows Only Authorized Contracts\n     */\n    modifier onlyAdmin()\n    {\n        require(Role[msg.sender] == _AUTHORIZED || msg.sender == _LAUNCHPAD || msg.sender == owner(), \"LiveMint | onlyAdmin | Caller Is Not Approved Admin\");\n        _;\n    }\n}\ninterface IDelegationRegistry\n{\n    /**\n     * @dev Checks If A Vault Has Delegated To The Delegate\n     */\n    function checkDelegateForAll(address delegate, address delegator) external view returns (bool);\n}"}, "contracts/LiveMintEnabled.sol": {"content": "//SPDX-License-Identifier: MIT\n/**\n * @title LiveMintEnabled\n * @dev @brougkr\n * note: This Contract Is Used To Enable LiveMint To Purchase Tokens From Your Contract\n * note: This Contract Should Be Imported and Included In The `is` Portion Of The Contract Declaration, ex. `contract NFT is Ownable, LiveMintEnabled`\n * note: You Can Copy Or Modify The Example Functions Below To Implement The Two Functions In Your Contract\n */\npragma solidity ^0.8.30;\nabstract contract LiveMintEnabled\n{\n    /**\n     * @dev LiveMint purchaseTo\n     * note: Should Be Implemented With onlyLiveMint Access Modifier\n     * note: Should Return The TokenID Being Transferred To The Recipient\n     */\n    function purchaseTo(address Recipient) external virtual returns (uint tokenID);\n\n    // purchaseTo() EXAMPLE: \n    // Here Is An Example Of The Function Implemented In An Standard ERC721 Contract (you can copy paste the function below into your contract)\n    // function purchaseTo(address Recipient) override virtual external onlyLiveMint returns (uint tokenID) \n    // {\n    //     _mint(Recipient, 1);\n    //     return (totalSupply() - 1);\n    // }\n\n    /**\n     * @dev ChangeLiveMintAddress Changes The LiveMint Address | note: Should Be Implemented To Include onlyOwner Or Similar Access Modifier\n     */\n    function _ChangeLiveMintAddress(address LiveMintAddress) external virtual;\n\n    // _ChangeLiveMintAddress EXAMPLE: \n    // Here Is An Example Of The Function Implemented In An Standard ERC721 Contract (you can copy paste the function below into your contract)\n    // function _ChangeLiveMintAddress(address LiveMintAddress) override virtual external onlyOwner { _LIVE_MINT_ADDRESS = LiveMintAddress; }\n\n    /**\n     * @dev LiveMint Address\n     */\n    address public _LIVE_MINT_ADDRESS = 0x76375092724A9cE835d117106E0F374E85EFa42B; \n\n    /**\n     * @dev Access Modifier For LiveMint\n     */\n    modifier onlyLiveMint\n    {\n        require(msg.sender == _LIVE_MINT_ADDRESS, \"onlyLiveMint: msg.sender Is Not The LiveMint Contract\");\n        _;\n    }\n}"}, "contracts/LiveMintTokyo.sol": {"content": "// SPDX-License-Identifier: MIT\n/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\n/**\n * @dev: @brougkr\n */\npragma solidity ^0.8.30;\nimport { IERC721 } from \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { MerkleProof } from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport { IMinter } from \"./IMinter.sol\";\nimport { IMP } from \"./IMP.sol\";\nimport { IGT } from \"./IGT.sol\";\nimport { LaunchpadEnabled } from \"./LaunchpadEnabled.sol\";\ncontract LiveMintTokyo is Ownable, ReentrancyGuard, LaunchpadEnabled\n{  \n    struct City\n    {\n        string _Name;         // _Name\n        uint _QRCurrentIndex; // _QRCurrentIndex (Should be Always Be 333 + (333 * (City# % 6))\n        address _ERC20;       // _ERC20 \n        bytes32 _Root;        // _Root\n    }\n\n    struct Artist\n    {\n        address _MintPass;        // _MintPass\n        address _Minter;          // _Minter\n        address _PolyptychSource; // _PolyptychSource\n        uint _MaxSupply;          // _MaxSupply\n        uint _MintPassProjectID;  // _MintPassProjectID\n        uint _ArtBlocksProjectID; // _ArtBlocksProjectID \n        uint _PolyStart;          // _PolyStart\n        uint _PolyEnd;            // _PolyEnd\n    }\n\n    struct User\n    {\n        bool _Eligible;   // _Eligible\n        uint _Allocation; // _Allocation\n    }\n\n    /*-------------------*/\n    /*  STATE VARIABLES  */\n    /*-------------------*/\n\n    bytes32 private constant _AUTHORIZED = keccak256(\"AUTHORIZED\");                        // Authorized Role\n    bytes32 private constant _MINTER_ROLE = keccak256(\"MINTER_ROLE\");                      // Minter Role\n    address private constant _DN = 0x00000000000076A84feF008CDAbe6409d2FE638B;             // delegate.cash Delegation Registry\n    address private constant _GOLDEN_TOKEN = 0x985e1932FFd2aA4bC9cE611DFe12816A248cD2cE;   // Golden Token Address\n    address private constant _CITIZEN_MINTER = 0xDd06d8483868Cd0C5E69C24eEaA2A5F2bEaFd42b; // ArtBlocks Minter Contract\n    address private constant _BRT_MULTISIG = 0xB96E81f80b3AEEf65CB6d0E280b15FD5DBE71937;   // BRT Multisig\n    address public _Pindar;                                                                // Pindar Van Arman's Custom Minter Contract\n    uint public _CurrentCityIndex = 6;                                                     // Current City Index\n    uint public _UniqueArtistsInvoked;                                                     // Unique Artists Invoked\n\n    /*-------------------*/\n    /*     MAPPINGS      */\n    /*-------------------*/\n    \n    mapping(uint => Artist) public Artists;                              // [ArtistID] => Artist\n    mapping(uint => City) public Cities;                                 // [CityIndex] => City Struct\n    mapping(uint => mapping(address => bool)) public _QRRedeemed;        // [CityIndex][Wallet] => If User Has Redeemed QR\n    mapping(uint => mapping(address => uint)) public _QRAllocation;      // [CityIndex][Wallet] => Wallet's QR Code Allocation\n    mapping(uint => mapping(uint => address)) public _BrightListCitizen; // [CityIndex][TicketID] => Address Of CryptoCitizen Minting Recipient \n    mapping(uint => mapping(uint => address)) public _BrightListArtist;  // [ArtistID][TicketID] => Address Of Artist NFT Recipient\n    mapping(uint => mapping(uint => string)) public _DataArtists;        // [ArtistID][TicketID] => Artist Data\n    mapping(uint => mapping(uint => string)) public _DataCitizens;       // [CityIndex][TicketID] => Data For Golden Token Checkins\n    mapping(uint => mapping(uint => uint)) public _MintedTokenIDCitizen; // [CityIndex][TicketID] => MintedTokenID\n    mapping(uint => mapping(uint => uint)) public _MintedTokenIDArtist;  // [ArtistID][TicketID] => MintedTokenID\n    mapping(uint => mapping(uint => bool)) public _MintedArtist;         // [ArtistID][TicketID] => If Minted\n    mapping(uint => mapping(uint => bool)) public _MintedCitizen;        // [CityIndex][TicketID] => If Golden Ticket ID Has Minted Or Not\n    mapping(uint => mapping(uint => uint)) public _ArtBlocksProjectID;   // [ArtistID][TicketID] => ArtBlocksProjectID\n    mapping(address => bytes32) public Role;                             // [Wallet] => BRT Minter Role\n    mapping(uint => uint) public AmountRemaining;                        // [ArtistID] => Mints Remaining\n\n    /*-------------------*/\n    /*      EVENTS       */\n    /*-------------------*/\n\n    /**\n     * @dev Emitted When `Redeemer` IRL-mints CryptoCitizen Corresponding To Their Redeemed `TicketID`.\n     **/\n    event LiveMintComplete(address Redeemer, uint TicketID, uint TokenID, string Data);\n\n    /**\n     * @dev Emitted When `Redeemer` IRL-mints A Artist NFT Corresponding To Their Redeemed `TicketID`.\n     */\n    event LiveMintCompleteArtist(address Recipient, uint ArtistID, uint TicketID, uint MintedWorkTokenID);\n\n    /**\n     * @dev Emitted When `Redeemer` Redeems Golden Token Corresponding To `TicketID` \n     **/\n    event QRRedeemed(address Redeemer, uint TicketID, string Data, string Type);\n\n    /**\n     * @dev Emitted When A Contract Is Authorized\n     */\n    event AuthorizedContract(address NewAddress);\n\n    /**\n     * @dev Emitted When A Contract Is Deauthorized\n     */\n    event DeauthorizedContract(address NewAddress);\n\n    /*-------------------*/\n    /*    CONSTRUCTOR    */\n    /*-------------------*/\n\n    constructor()\n    { \n        Cities[0]._Name = \"CryptoGalacticans\";  \n        Cities[1]._Name = \"CryptoVenetians\";    \n        Cities[2]._Name = \"CryptoNewYorkers\";   \n        Cities[3]._Name = \"CryptoBerliners\";    \n        Cities[4]._Name = \"CryptoLondoners\";    \n        Cities[5]._Name = \"CryptoMexas\";        \n        Cities[6]._Name = \"CryptoTokyites\";     \n        Cities[6]._QRCurrentIndex = 333;\n        Cities[6]._Root = 0x255b8b82ee0d1823cdc3cf859efacfee1111414bacab649a7e8bea9cd48a0ed3;\n        Cities[7]._Name = \"CryptoCitizen City #8\"; \n        Cities[7]._QRCurrentIndex = 666;\n        Cities[8]._Name = \"CryptoCitizen City #9\";\n        Cities[8] ._QRCurrentIndex = 999;\n        Cities[9]._Name = \"CryptoCitizen City #10\";\n        Cities[10]._QRCurrentIndex = 1332; \n        Role[0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700] = _AUTHORIZED;  // `operator.brightmoments.eth`\n        Role[0x1A0a3E3AE390a0710f8A6d00587082273eA8F6C9] = _MINTER_ROLE; // BRT Minter #1\n        Role[0x4d8013b0c264034CBf22De9DF33e22f58D52F207] = _MINTER_ROLE; // BRT Minter #2\n        Role[0x4D9A8CF2fE52b8D49C7F7EAA87b2886c2bCB4160] = _MINTER_ROLE; // BRT Minter #3\n        Role[0x124fd966A0D83aA020D3C54AE2c9f4800b46F460] = _MINTER_ROLE; // BRT Minter #4\n        Role[0x100469feA90Ac1Fe1073E1B2b5c020A8413635c4] = _MINTER_ROLE; // BRT Minter #5\n        Role[0x756De4236373fd17652b377315954ca327412bBA] = _MINTER_ROLE; // BRT Minter #6\n        Role[0xc5Dfba6ef7803665C1BDE478B51Bd7eB257A2Cb9] = _MINTER_ROLE; // BRT Minter #7\n        Role[0xFBF32b29Bcf8fEe32d43a4Bfd3e7249daec457C0] = _MINTER_ROLE; // BRT Minter #8\n        Role[0xF2A15A83DEE7f03C70936449037d65a1C100FF27] = _MINTER_ROLE; // BRT Minter #9\n        Role[0x1D2BAB965a4bB72f177Cd641C7BacF3d8257230D] = _MINTER_ROLE; // BRT Minter #10\n        Role[0x2e51E8b950D72BDf003b58E357C2BA28FB77c7fB] = _MINTER_ROLE; // BRT Minter #11\n        Role[0x8a7186dECb91Da854090be8226222eA42c5eeCb6] = _MINTER_ROLE; // BRT Minter #12\n    }\n\n    /*---------------------*/\n    /*    QR REDEMPTION    */\n    /*---------------------*/\n\n    /**\n     * @dev Redeems Spot For IRL Minting\n     */\n    function RedeemQR(string[] calldata Data, string[] calldata Type, bytes32[] calldata Proof, address Vault, uint Amount) external nonReentrant \n    {        \n        address Recipient = msg.sender;\n        if(Vault != address(0)) { if(IDelegationRegistry(_DN).checkDelegateForAll(msg.sender, Vault)) { Recipient = Vault; } } \n        require(readQREligibility(Recipient, Proof), \"LiveMint: User Is Not Eligible To Redeem QR\");\n        if(_QRAllocation[_CurrentCityIndex][Recipient] == 0) // User Is Able To Redeem Explicitly 1 QR Code\n        {\n            require(!_QRRedeemed[_CurrentCityIndex][Recipient], \"LiveMint: User Has Already Redeemed\");\n            _DataCitizens[_CurrentCityIndex][Cities[_CurrentCityIndex]._QRCurrentIndex] = Data[0];\n            _BrightListCitizen[_CurrentCityIndex][Cities[_CurrentCityIndex]._QRCurrentIndex] = Recipient;\n            emit QRRedeemed(Recipient, Cities[_CurrentCityIndex]._QRCurrentIndex, Data[0], Type[0]);\n            Cities[_CurrentCityIndex]._QRCurrentIndex++; \n        }\n        else // User Is Able To Redeem More Than 1 QR Code Because Their QRAllocation > 0\n        {\n            require(Amount <= _QRAllocation[_CurrentCityIndex][Recipient], \"LiveMint: Amount Must Be Less Than Or Equal To QRAllocation\");\n            uint _CurrentQR = Cities[_CurrentCityIndex]._QRCurrentIndex;\n            uint _Limit = Amount + _CurrentQR;\n            uint _Counter;\n            _QRAllocation[_CurrentCityIndex][Recipient] -= Amount;\n            Cities[_CurrentCityIndex]._QRCurrentIndex = _Limit;\n            for(_CurrentQR; _CurrentQR < _Limit; _CurrentQR++)\n            {\n                _DataCitizens[_CurrentCityIndex][_CurrentQR] = Data[_Counter];\n                _BrightListCitizen[_CurrentCityIndex][_CurrentQR] = Recipient;\n                emit QRRedeemed(Recipient, _CurrentQR, Data[_Counter], Type[_Counter]);\n                _Counter++;\n            }\n        }\n        _QRRedeemed[_CurrentCityIndex][Recipient] = true;\n    }\n\n    /*--------------------*/\n    /*    LIVE MINTING    */\n    /*--------------------*/\n\n    /**\n     * @dev Batch Mints Verified Users On The Brightlist CryptoCitizens\n     * note: { For CryptoCitizen Cities }\n     */\n    function _LiveMintCitizen(uint[] calldata TicketIDs) external onlyMinter\n    {\n        address Recipient;\n        uint MintedWorkTokenID;\n        for(uint TicketID; TicketID < TicketIDs.length; TicketID++)\n        {\n            require(!_MintedCitizen[_CurrentCityIndex][TicketIDs[TicketID]], \"LiveMint: Golden Token Already Minted\");\n            if(_BrightListCitizen[_CurrentCityIndex][TicketIDs[TicketID]] != address(0))\n            {\n                Recipient = _BrightListCitizen[_CurrentCityIndex][TicketIDs[TicketID]];\n            }\n            else if (TicketIDs[TicketID] <= 333) { Recipient = IGT(_GOLDEN_TOKEN)._LiveMintBurn(TicketIDs[TicketID]); }\n            else { revert(\"LiveMint: Invalid TicketID\"); }\n            require(Recipient != address(0), \"LiveMint: Invalid Recipient\");\n            _MintedCitizen[_CurrentCityIndex][TicketIDs[TicketID]] = true;\n            MintedWorkTokenID = IMinter(_CITIZEN_MINTER).purchaseTo(Recipient, _CurrentCityIndex);\n            _MintedTokenIDCitizen[_CurrentCityIndex][TicketIDs[TicketID]] = MintedWorkTokenID;\n            emit LiveMintComplete(Recipient, TicketIDs[TicketID], MintedWorkTokenID, _DataCitizens[_CurrentCityIndex][TicketIDs[TicketID]]); \n        }\n    }\n\n    /**\n     * @dev Burns Artist Mint Pass In Exchange For The Minted Work\n     * note: { For Instances Where Multiple Artists Share The Same Mint Pass & Return (Recipient, ArtBlocksProjectID) }\n     */\n    function _LiveMintArtist(uint ArtistID, uint[] calldata TicketIDs) external onlyMinter\n    {\n        address Recipient;\n        address MintPass = Artists[ArtistID]._MintPass;\n        address Minter = Artists[ArtistID]._Minter;\n        uint ArtBlocksProjectID;\n        uint MintedWorkTokenID;\n        uint TicketID;\n        require(AmountRemaining[ArtistID] > 0, \"LiveMint: ArtistID Mint Limit Reached\");\n        require(TicketIDs.length <= AmountRemaining[ArtistID], \"LiveMint: TicketID Length Exceeds ArtistID Mint Limit\");\n        AmountRemaining[ArtistID] = AmountRemaining[ArtistID] - TicketIDs.length;\n        for(uint x; x < TicketIDs.length; x++)\n        {\n            TicketID = TicketIDs[x];\n            require(!_MintedArtist[ArtistID][TicketID], \"LiveMint: Artist Mint Pass Already Minted\");\n            _MintedArtist[ArtistID][TicketID] = true;\n            (Recipient, ArtBlocksProjectID) = IMP(MintPass)._LiveMintBurn(TicketID);\n            if(ArtBlocksProjectID == 100) { MintedWorkTokenID = IMinter(_Pindar).purchaseTo(Recipient); } // Pindar Custom Contract \n            else { MintedWorkTokenID = IMinter(Minter).purchaseTo(Recipient, ArtBlocksProjectID); } // Pre-Defined Minter Contract\n            _MintedTokenIDArtist[ArtistID][TicketID] = MintedWorkTokenID;\n            emit LiveMintCompleteArtist(Recipient, ArtistID, TicketID, MintedWorkTokenID);\n        }\n    }\n\n    /**\n     * @dev Burns Artist Mint Pass In Exchange For The Minted Work\n     * note: { For Instances Where Multiple Artists Share The Same Mint Pass & Return (Recipient, ArtBlocksProjectID) }\n     */\n    function _LiveMintArtistBatch(uint[] calldata ArtistIDs, uint[][] calldata TicketIDs) external onlyMinter\n    {\n        address Recipient;\n        address MintPass;\n        address Minter;\n        uint ArtBlocksProjectID;\n        uint MintedWorkTokenID;\n        uint TicketID;\n        uint ActiveArtistID;\n        for(uint ArtistIDIndex; ArtistIDIndex < ArtistIDs.length; ArtistIDIndex++)\n        {\n            ActiveArtistID = ArtistIDs[ArtistIDIndex];\n            MintPass = Artists[ActiveArtistID]._MintPass;\n            Minter = Artists[ActiveArtistID]._Minter;\n            for(uint TicketIDIndex; TicketIDIndex < TicketIDs[ArtistIDIndex].length; TicketIDIndex++)\n            {\n                TicketID = TicketIDs[ArtistIDIndex][TicketIDIndex];\n                require(!_MintedArtist[ActiveArtistID][TicketID], \"LiveMint: Artist Mint Pass Already Minted\");\n                _MintedArtist[ActiveArtistID][TicketID] = true;\n                (Recipient, ArtBlocksProjectID) = IMP(MintPass)._LiveMintBurn(TicketID);\n                if(ArtBlocksProjectID == 100) { MintedWorkTokenID = IMinter(_Pindar).purchaseTo(Recipient); }\n                else { MintedWorkTokenID = IMinter(Minter).purchaseTo(Recipient, ArtBlocksProjectID); }\n                _MintedTokenIDArtist[ActiveArtistID][TicketID] = MintedWorkTokenID;\n                emit LiveMintCompleteArtist(Recipient, ActiveArtistID, TicketID, MintedWorkTokenID);\n            }\n        }\n    }\n\n    /*-------------------*/\n    /*  OWNER FUNCTIONS  */\n    /*-------------------*/\n\n    /**\n     * @dev Grants Address BRT Minter Role\n     **/\n    function __AddMinter(address Minter) external onlyOwner { Role[Minter] = _MINTER_ROLE; }\n    \n    /**\n     * @dev Deactivates Address From BRT Minter Role\n     **/\n    function __RemoveMinter(address Minter) external onlyOwner { Role[Minter] = 0x0; }\n\n    /**\n     * @dev Changes Mint Pass Address For Artist LiveMints\n     */\n    function __ChangeMintPass(uint ProjectID, address Contract) external onlyOwner { Artists[ProjectID]._MintPass = Contract; }\n\n    /**\n     * @dev Changes Merkle Root For Citizen LiveMints\n     */\n    function __ChangeRootCitizen(bytes32 NewRoot) external onlyOwner { Cities[_CurrentCityIndex]._Root = NewRoot; }\n\n    /**\n     * @dev Overwrites QR Allocation\n     */\n    function __QRAllocationsOverwrite(address[] calldata Addresses, uint[] calldata Amounts) external onlyOwner\n    {\n        require(Addresses.length == Amounts.length, \"LiveMint: Input Arrays Must Match\");\n        for(uint x; x < Addresses.length; x++) { _QRAllocation[_CurrentCityIndex][Addresses[x]] = Amounts[x]; }\n    }\n\n    /**\n     * @dev Increments QR Allocations\n     */\n    function __QRAllocationsIncrement(address[] calldata Addresses, uint[] calldata Amounts) external onlyOwner\n    {\n        require(Addresses.length == Amounts.length, \"LiveMint: Input Arrays Must Match\");\n        for(uint x; x < Addresses.length; x++) { _QRAllocation[_CurrentCityIndex][Addresses[x]] += Amounts[x]; }\n    }\n\n    /**\n     * @dev Mints To Multisig\n     */\n    function __QRAllocationsSetNoShow(uint[] calldata TicketIDs) external onlyOwner\n    {\n        for(uint TicketIndex; TicketIndex < TicketIDs.length; TicketIndex++)\n        {\n            require(!_MintedCitizen[_CurrentCityIndex][TicketIDs[TicketIndex]], \"LiveMint: Ticket ID Already Minted\");\n            _BrightListCitizen[_CurrentCityIndex][TicketIDs[TicketIndex]] = _BRT_MULTISIG;\n        }\n    }\n\n    /**\n     * @dev Changes QR Current Index\n     */\n    function __ChangeQRIndex(uint NewIndex) external onlyOwner { Cities[_CurrentCityIndex]._QRCurrentIndex = NewIndex; }\n\n    /**\n     * @dev Changes Pindar's Minter Address\n     */\n    function __ChangePindarAddress(address NewAddress) external onlyOwner { _Pindar = NewAddress; }\n\n    /**\n     * @dev Batch Approves BRT For Purchasing\n     */\n    function __BatchApproveERC20(address[] calldata ERC20s, address[] calldata Operators) external onlyOwner\n    {\n        require(ERC20s.length == Operators.length, \"LiveMint: Arrays Must Be Equal Length\");\n        for(uint x; x < ERC20s.length; x++) { IERC20(ERC20s[x]).approve(Operators[x], 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff); }\n    }\n\n    /**\n     * @dev Instantiates New City\n     * note: CityIndex Always Corresponds To ArtBlocks ProjectID\n     */\n    function __NewCity (\n        string calldata Name,\n        uint CityIndex,\n        uint QRIndex,\n        address ERC20\n    ) external onlyOwner {\n        Cities[CityIndex] = City(\n            Name,\n            QRIndex,\n            ERC20,\n            0x6942069420694206942069420694206942069420694206942069420694206942\n        );\n    }\n\n    /**\n     * @dev Overrides An Artist\n     */\n    function __OverrideArtist(uint ArtistID, Artist memory NewArtist) external onlyOwner { Artists[ArtistID] = NewArtist; }\n\n    /**\n     * @dev Instantiates A New City\n     */\n    function __NewCityStruct(uint CityIndex, City memory NewCity) external onlyOwner { Cities[CityIndex] = NewCity; }\n\n    /**\n     * @dev Returns An Artist Struct\n     */\n    function __NewArtistStruct(uint ArtistID, Artist memory NewArtist) external onlyOwner { Artists[ArtistID] = NewArtist; }\n\n    /**\n     * @dev Changes The Minter Address For An Artist\n     */\n    function __NewArtistMinter(uint ArtistID, address Minter) external onlyOwner { Artists[ArtistID]._Minter = Minter; }\n\n    /**\n     * @dev Withdraws Any Ether Mistakenly Sent to Contract to Multisig\n     **/\n    function __WithdrawEther() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }\n\n    /**\n     * @dev Withdraws ERC20 Tokens to Multisig\n     **/\n    function __WithdrawERC20(address TokenAddress) external onlyOwner \n    { \n        IERC20 erc20Token = IERC20(TokenAddress);\n        uint balance = erc20Token.balanceOf(address(this));\n        require(balance > 0, \"LiveMint: 0 ERC20 Balance At `TokenAddress`\");\n        erc20Token.transfer(msg.sender, balance);\n    }\n\n    /**\n     * @dev Withdraws Any NFT Mistakenly Sent To This Contract.\n     */\n    function __WithdrawERC721(address ContractAddress, address Recipient, uint TokenID) external onlyOwner\n    {\n        IERC721(ContractAddress).transferFrom(address(this), Recipient, TokenID);\n    }\n\n    /**\n     * @dev Authorizes A Contract To Mint\n     */\n    function ____AuthorizeContract(address NewAddress) external onlyOwner \n    { \n        Role[NewAddress] = _AUTHORIZED; \n        emit AuthorizedContract(NewAddress);\n    }\n\n    /**\n     * @dev Deauthorizes A Contract From Minting\n     */\n    function ___DeauthorizeContract(address NewAddress) external onlyOwner \n    { \n        Role[NewAddress] = 0x0; \n        emit DeauthorizedContract(NewAddress);\n    }\n    \n    /*-------------------*/\n    /*    PUBLIC VIEW    */\n    /*-------------------*/\n\n    /**\n     * @dev Returns A User's QR Allocation Amount, Or 0 If Not Eligible\n     */\n    function readEligibility(address Recipient, bytes32[] memory Proof) public view returns(uint)\n    {\n        bool Eligible = readQREligibility(Recipient, Proof);\n        if(!Eligible) { return 0; }\n        else if(Eligible && _QRAllocation[_CurrentCityIndex][Recipient] > 0) { return _QRAllocation[_CurrentCityIndex][Recipient]; }\n        else if(Eligible) { return 1; }\n        else { return 0; }\n    }\n\n    /**\n     * @dev Returns If User Is Eligible To Redeem QR Code\n     */\n    function readQREligibility(address Recipient, bytes32[] memory Proof) public view returns(bool)\n    {\n        bytes32 Leaf = keccak256(abi.encodePacked(Recipient));\n        bool BrightListEligible = MerkleProof.verify(Proof, Cities[_CurrentCityIndex]._Root, Leaf);\n        if(\n            (BrightListEligible && !_QRRedeemed[_CurrentCityIndex][Recipient])\n            || \n            (BrightListEligible && _QRAllocation[_CurrentCityIndex][Recipient] > 0)\n            \n        ) { return true; }\n        else { return false; }\n    }\n\n    /**\n     * @dev Returns An Array Of Unminted Golden Tokens\n     */\n    function readCitizenUnmintedTicketIDs() public view returns(uint[] memory)\n    {\n        uint[] memory UnmintedTokenIDs = new uint[](1000);\n        uint Counter;\n        uint CityIDBuffer = _CurrentCityIndex % 6 * 333;\n        uint _TokenID;\n        for(uint TokenID; TokenID < 1000; TokenID++)\n        {\n            _TokenID = TokenID + CityIDBuffer;\n            if\n            (\n                !_MintedCitizen[_CurrentCityIndex][_TokenID]\n                &&\n                _BrightListCitizen[_CurrentCityIndex][_TokenID] != address(0)\n            ) \n            { \n                UnmintedTokenIDs[Counter] = _TokenID; \n                Counter++;\n            }\n        }\n        uint[] memory FormattedUnMintedTokenIDs = new uint[](Counter);\n        uint Found;\n        for(uint FormattedTokenID; FormattedTokenID < Counter; FormattedTokenID++)\n        {\n            if(UnmintedTokenIDs[FormattedTokenID] != 0 || (UnmintedTokenIDs[FormattedTokenID] == 0 && FormattedTokenID == 0))\n            {\n                FormattedUnMintedTokenIDs[Found] = UnmintedTokenIDs[FormattedTokenID];\n                Found++;\n            }\n        }\n        return FormattedUnMintedTokenIDs;\n    }\n\n    /**\n     * @dev Returns An Array Of Unminted Golden Tokens\n     */\n    function readCitizenMintedTicketIDs(uint CityID) public view returns(uint[] memory)\n    {\n        uint[] memory MintedTokenIDs = new uint[](1000);\n        uint Counter;\n        uint CityIDBuffer = (CityID % 6) * 333;\n        uint _TicketID;\n        for(uint TicketID; TicketID < 1000; TicketID++)\n        {\n            _TicketID = TicketID + CityIDBuffer;\n            if(_MintedCitizen[CityID][_TicketID]) \n            { \n                MintedTokenIDs[Counter] = _TicketID; \n                Counter++;\n            }\n        }\n        uint[] memory FormattedMintedTokenIDs = new uint[](Counter);\n        uint Found;\n        for(uint FormattedTokenID; FormattedTokenID < Counter; FormattedTokenID++)\n        {\n            if(MintedTokenIDs[FormattedTokenID] != 0 || (MintedTokenIDs[FormattedTokenID] == 0 && FormattedTokenID == 0))\n            {\n                FormattedMintedTokenIDs[Found] = MintedTokenIDs[FormattedTokenID];\n                Found++;\n            }\n        }\n        return FormattedMintedTokenIDs;\n    }\n\n    /**\n     * @dev Returns A 2d Array Of Checked In & Unminted TicketIDs Awaiting A Mint\n     */\n    function readCitizenCheckedInTicketIDs() public view returns(uint[] memory TokenIDs)\n    {\n        uint[] memory _TokenIDs = new uint[](1000);\n        uint CityIDBuffer = (_CurrentCityIndex % 6) * 333;\n        uint _TicketID;\n        uint Counter;\n        for(uint TicketID; TicketID < 1000; TicketID++)\n        {\n            _TicketID = TicketID + CityIDBuffer;\n            if(\n                !_MintedCitizen[_CurrentCityIndex][_TicketID]\n                &&\n                _BrightListCitizen[_CurrentCityIndex][_TicketID] != address(0)\n            ) \n            { \n                _TokenIDs[Counter] = _TicketID; \n                Counter++;\n            }\n        }\n        uint[] memory FormattedCheckedInTickets = new uint[](Counter);\n        uint Found;\n        for(uint x; x < Counter; x++)\n        {\n            if(_TokenIDs[x] != 0 || (_TokenIDs[x] == 0 && x == 0))\n            {\n                FormattedCheckedInTickets[Found] = _TokenIDs[x];\n                Found++;\n            }\n        }\n        return FormattedCheckedInTickets;\n    }\n\n    /**\n     * @dev Returns A 2d Array Of Minted ArtistIDs\n     */\n    function readArtistUnmintedTicketIDs(uint[] calldata ArtistIDs, uint Range) public view returns(uint[][] memory TokenIDs)\n    {\n        uint[][] memory _TokenIDs = new uint[][](ArtistIDs.length);\n        uint Index;\n        for(uint ArtistID; ArtistID < ArtistIDs.length; ArtistID++)\n        {\n            address _Mintpass = Artists[ArtistID]._MintPass;\n            uint[] memory UnmintedArtistTokenIDs = new uint[](Range);\n            uint Counter;\n            for(uint TokenID; TokenID < Range; TokenID++)\n            {\n                bool TicketIDBurned;\n                try IERC721(_Mintpass).ownerOf(TokenID) { } // checks if token is burned\n                catch { TicketIDBurned = true; }\n                if(\n                    !_MintedArtist[ArtistIDs[ArtistID]][TokenID]\n                    &&\n                    (\n                        _BrightListArtist[ArtistIDs[ArtistID]][TokenID] != address(0)\n                        ||\n                        TicketIDBurned == false\n                    )\n                ) \n                { \n                    UnmintedArtistTokenIDs[Counter] = TokenID; \n                    Counter++;\n                }\n            }\n            uint[] memory FormattedUnMintedArtistIDs = new uint[](Counter);\n            uint Found;\n            for(uint x; x < Counter; x++)\n            {\n                if(UnmintedArtistTokenIDs[x] != 0 || (UnmintedArtistTokenIDs[x] == 0 && x == 0))\n                {\n                    FormattedUnMintedArtistIDs[Found] = UnmintedArtistTokenIDs[x];\n                    Found++;\n                }\n            }\n            _TokenIDs[Index] = FormattedUnMintedArtistIDs;\n            Index++;\n        }\n        return (_TokenIDs);\n    }\n\n    /**\n     * @dev Returns A 2d Array Of Minted ArtistIDs\n     */\n    function readArtistMintedTicketIDs(uint[] calldata ArtistIDs, uint Range) public view returns(uint[][] memory TokenIDs)\n    {\n        uint[][] memory _TokenIDs = new uint[][](ArtistIDs.length);\n        uint Index;\n        for(uint ArtistID; ArtistID < ArtistIDs.length; ArtistID++)\n        {\n            uint[] memory MintedTokenIDs = new uint[](Range);\n            uint Counter;\n            for(uint TokenID; TokenID < Range; TokenID++)\n            {\n                if(_MintedArtist[ArtistIDs[ArtistID]][TokenID])\n                { \n                    MintedTokenIDs[Counter] = TokenID; \n                    Counter++;\n                }\n            }\n            uint[] memory FormattedMintedTokenIDs = new uint[](Counter);\n            uint Found;\n            for(uint x; x < Counter; x++)\n            {\n                if(MintedTokenIDs[x] != 0 || (MintedTokenIDs[x] == 0 && x == 0))\n                {\n                    FormattedMintedTokenIDs[Found] = MintedTokenIDs[x];\n                    Found++;\n                }\n            }\n            _TokenIDs[Index] = FormattedMintedTokenIDs;\n            Index++;\n        }\n        return (_TokenIDs);\n    }\n\n    /**\n     * @dev Returns Original Recipients Of CryptoCitizens\n     */\n    function readCitizenBrightList(uint CityIndex) public view returns(address[] memory Recipients)\n    {\n        address[] memory _Recipients = new address[](1000);\n        uint Start = (CityIndex % 6) * 333;\n        for(uint x; x < 1000; x++) { _Recipients[x] = _BrightListCitizen[CityIndex][Start+x]; }\n        return _Recipients;\n    }\n\n    /**\n     * @dev Returns Original Recipient Of Artist NFTs\n     */\n    function readArtistBrightList(uint ArtistID, uint Range) public view returns(address[] memory Recipients)\n    {\n        address[] memory _Recipients = new address[](Range);\n        for(uint x; x < Range; x++) { _Recipients[x] = _BrightListArtist[ArtistID][x]; }\n        return _Recipients;    \n    }\n\n    /**\n     * @dev Returns The City Struct At Index Of `CityIndex`\n     */\n    function readCitizenCity(uint CityIndex) public view returns(City memory) { return Cities[CityIndex]; }\n\n    /**\n     * @dev Returns The Artist Struct At Index Of `ArtistID`\n     */\n    function readArtist(uint ArtistID) public view returns(Artist memory) { return Artists[ArtistID]; }\n\n    /**\n     * @dev Returns A Minted Work TokenID Corresponding To The Input Artist TicketID \n     */\n    function readArtistMintedTokenID(uint ArtistID, uint TicketID) external view returns (uint)\n    {\n        if(!_MintedArtist[ArtistID][TicketID]) { return 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff; }\n        else { return _MintedTokenIDArtist[ArtistID][TicketID]; }\n    }\n\n    /**\n     * @dev Returns A Minted Citizen TokenID Corresponding To Input TicketID\n     */\n    function readCitizenMintedTokenID(uint CityIndex, uint TicketID) external view returns(uint)\n    {\n        if(!_MintedCitizen[CityIndex][TicketID]) { return type(uint).max; }\n        else { return _MintedTokenIDCitizen[CityIndex][TicketID]; }  \n    }\n    \n    /*-------------------------*/\n    /*        LAUNCHPAD        */\n    /*-------------------------*/\n\n    /**\n     * @dev Initializes A LiveMint Artist\n     */\n    function __InitLiveMint(Artist memory _Params) external onlyAdmin returns (uint)\n    {\n        AmountRemaining[_UniqueArtistsInvoked] = _Params._MaxSupply;\n        Artists[_UniqueArtistsInvoked] = _Params;\n        _UniqueArtistsInvoked++;\n        return _UniqueArtistsInvoked - 1;\n    }\n\n    /*-------------------------*/\n    /*     ACCESS MODIFIERS    */\n    /*-------------------------*/\n\n    /**\n     * @dev Access Modifier That Allows Only BrightListed BRT Minters\n     **/\n    modifier onlyMinter() \n    {\n        require(Role[msg.sender] == _MINTER_ROLE, \"LiveMint | onlyMinter | Caller Is Not Approved BRT Minter\");\n        _;\n    }\n\n    /**\n     * @dev Access Modifier That Allows Only Authorized Contracts\n     */\n    modifier onlyAdmin()\n    {\n        require(Role[msg.sender] == _AUTHORIZED || msg.sender == _LAUNCHPAD || msg.sender == owner(), \"LiveMint | onlyAdmin | Caller Is Not Approved Admin\");\n        _;\n    }\n}\ninterface IDelegationRegistry\n{\n    /**\n     * @dev Checks If A Vault Has Delegated To The Delegate\n     */\n    function checkDelegateForAll(address delegate, address delegator) external view returns (bool);\n}"}, "contracts/Marketplace.sol": {"content": "//SPDX-License-Identifier: MIT\n/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\n/**\n * @dev: @brougkr\n */\npragma solidity ^0.8.30;\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { MerkleProof } from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IMinter } from \"./IMinter.sol\";\nimport { DelegateCashEnabled } from \"./DelegateCashEnabled.sol\";\ncontract Marketplace is Ownable, ReentrancyGuard, DelegateCashEnabled\n{\n    struct PresaleSale \n    {\n        address _Operator;\n        address _NFT;\n        uint _MaxForSale;\n        uint _MaxPerPurchase;\n        uint _PricePresale;\n        uint _PricePublic;\n        uint _TimestampEndFullSet;\n        uint _TimestampEndCitizen;\n        uint _TimestampSaleStart;\n        uint _Type;\n        uint _ProjectID;\n    }\n\n    struct InternalPresaleSale\n    {\n        bool _Active;\n        uint _AmountSold;\n        uint _GlobalPurchasesFullSet;\n        uint _GlobalPurchasesCitizen;\n        uint _GlobalPurchasesPublic;\n        uint _CurrentTokenIndex;\n        uint _AmountSoldFullSet;\n        uint _AmountSoldCitizen;\n        uint _AmountSoldPublic;\n    }\n\n    struct InternalPresaleSaleRoots\n    {\n        bytes32 _RootEligibilityFullSet;\n        bytes32 _RootEligibilityCitizen;\n        bytes32 _RootAmountFullSet;\n        bytes32 _RootAmountCitizen;\n    }\n\n    struct InternalWalletInfo    \n    {\n        uint _AmountPurchasedFullSetWindow;\n        uint _AmountPurchasedCitizenWindow;\n        uint _AmountPurchasedWallet;\n    }\n\n    struct WalletSaleInfo\n    {\n        uint _PricePresale;\n        uint _PricePublic;\n        uint _AmountSold;\n        uint _MintPassesAvailable;\n        uint _MintPassesRemaining;\n        uint _TimestampEndFullSet;\n        uint _TimestampEndCitizen;\n        uint _TimestampSaleStart;\n        uint _AmountPurchasableFullSet;\n        uint _AmountPurchasableCitizen;\n        uint _AmountPurchasedFullSetWindow;\n        uint _AmountPurchasedCitizenWindow;\n        uint _GlobalPurchasesFullSet;\n        uint _GlobalPurchasesCitizen;\n        uint _GlobalPurchasesPublic;\n        uint _AmountPurchasedWallet;\n        bool _EligibleFullSet;\n        bool _EligibleCitizen;\n        bool _ValidMaxAmountFullSet;\n        bool _ValidMaxAmountCitizen;\n    }\n\n    struct Sale\n    {\n        uint _Price;\n        uint _MintPassProjectID;\n        uint _Type;\n        uint _ABProjectID;\n        uint _AmountForSale;\n        uint _TimestampStart;\n        address _NFT;\n        bytes32 _Root;\n    }\n\n    struct FixedPriceSaleInfo\n    {\n        uint _Price;\n        uint _AmountForSale;\n        uint _AmountSold;\n        uint _TimestampStart;\n        uint _Priority;\n        bool _BrightlistEligible;\n        bytes32 _Root;\n    }\n\n    struct SaleInfo\n    {\n        uint _PricePresale;\n        uint _PricePublic;\n        uint _AmountSold;\n        uint _MintPassesAvailable;\n        uint _MintPassesRemaining;\n        uint _TimestampEndFullSet;\n        uint _TimestampEndCitizen;\n        uint _TimestampSaleStart;\n        uint _GlobalPurchasesFullSet;\n        uint _GlobalPurchasesCitizen;\n        uint _GlobalPurchasesPublic;\n    }\n\n    /*------------------\n     * STATE VARIABLES *\n    -------------------*/\n\n    uint public _TOTAL_UNIQUE_SALES; // Total Unique Presale Sales                \n    address private constant _BRT_MULTISIG = 0x0BC56e3c1397e4570069e89C07936A5c6020e3BE; // `sales.brightmoments.eth`\n    \n    /*-----------\n     * MAPPINGS *\n    ------------*/\n\n    mapping(uint=>Sale) public FixedPriceSales;\n    mapping(uint=>uint) public AmountSold;\n    mapping(uint=>uint[]) public DiscountAmounts;\n    mapping(address=>bool) public Admin;  \n    mapping(uint=>PresaleSale) public PresaleSales;                           \n    mapping(uint=>InternalPresaleSale) public PresaleSalesInternal;            \n    mapping(uint=>InternalPresaleSaleRoots) public InternalRoots;              \n    mapping(uint=>mapping(address=>InternalWalletInfo)) public InternalSaleWalletInfo;\n\n    event PurchasedPresale(uint SaleIndex, address Purchaser, uint DesiredAmount, uint MessageValue, bool PresaleEnded);    \n    event SaleStarted(uint SaleIndex);\n    event Refunded(address Refundee, uint Amount);\n    event Purchased(uint SaleIndex, address Purchaser, uint Amount);\n    event Fullset();\n    event Citizen();\n    event Public();\n\n    constructor() \n    { \n        Admin[msg.sender] = true; \n        Admin[0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700] = true;\n        Admin[0x90D98d5A1fD21B7cEa4D5c18341607ed1a8345c0] = true;\n        Admin[0x18B7511938FBe2EE08ADf3d4A24edB00A5C9B783] = true;\n        _transferOwnership(0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700);\n    }\n\n    /*---------------------\n     * EXTERNAL FUNCTIONS *\n    ----------------------*/\n\n    /**\n     * @dev Presale Purchase\n     */\n    function PurchasePresale (\n        uint SaleIndex,                // Index Of Sale\n        uint DesiredAmount,            // Desired Purchase Amount\n        uint MaxAmount,                // Maximum Purchase Allocation Per Wallet\n        address Vault,                 // Delegate.Cash Delegation Registry\n        bytes32[] calldata Proof,      // MerkleProof For Eligibility\n        bytes32[] calldata ProofAmount // MerkleProof For MaxAmount\n    ) external payable nonReentrant {\n        require(tx.origin == msg.sender, \"Marketplace: EOA Only\");\n        require(block.timestamp >= PresaleSales[SaleIndex]._TimestampSaleStart, \"Marketplace: Sale Not Started\");\n        address Recipient = msg.sender;\n        if(Vault != address(0)) { if(DelegateCash.checkDelegateForAll(msg.sender, Vault)) { Recipient = Vault; } }\n        InternalPresaleSale memory _InternalPresaleSale = PresaleSalesInternal[SaleIndex];\n        PresaleSale memory _PresaleSale = PresaleSales[SaleIndex];\n        bool PresaleEnded;\n        uint _Price;\n        uint _MaxPerPurchase = _PresaleSale._MaxPerPurchase;\n        if(_InternalPresaleSale._AmountSold + DesiredAmount > _PresaleSale._MaxForSale) \n        { \n            DesiredAmount = _PresaleSale._MaxForSale - _InternalPresaleSale._AmountSold; // Partial Fill\n        } \n        if(block.timestamp <= _PresaleSale._TimestampEndCitizen) // Presale\n        {\n            if(block.timestamp <= _PresaleSale._TimestampEndFullSet) // Full Set Window\n            { \n                require ( // Eligible For Full Set Window\n                    VerifyBrightList(Recipient, InternalRoots[SaleIndex]._RootEligibilityFullSet, Proof), \n                    \"Full Set Window: Not Eligible For Presale Window Or Block Pending, Please Try Again In A Few Seconds...\"\n                ); \n                require(VerifyAmount(Recipient, MaxAmount, InternalRoots[SaleIndex]._RootAmountFullSet, ProofAmount), \"Invalid Full Set Amount Proof\");\n                require(InternalSaleWalletInfo[SaleIndex][Recipient]._AmountPurchasedWallet + DesiredAmount <= MaxAmount, \"All Full Set Allocation Used\");\n                InternalSaleWalletInfo[SaleIndex][Recipient]._AmountPurchasedFullSetWindow += DesiredAmount;\n                PresaleSalesInternal[SaleIndex]._GlobalPurchasesFullSet += DesiredAmount;\n                emit Fullset();\n            }\n            else // Citizen Window\n            { \n                require ( // Eligible For Citizen Window\n                    VerifyBrightList(Recipient, InternalRoots[SaleIndex]._RootEligibilityCitizen, Proof), \n                    \"Citizen Window: Not Eligible For Presale Window Or Block Pending, Please Try Again In A Few Seconds...\"\n                ); \n                require(VerifyAmount(Recipient, MaxAmount, InternalRoots[SaleIndex]._RootAmountCitizen, ProofAmount), \"Invalid Citizen Amount Proof\");\n                require(InternalSaleWalletInfo[SaleIndex][Recipient]._AmountPurchasedCitizenWindow + DesiredAmount <= MaxAmount, \"All Citizen Allocation Used\");\n                InternalSaleWalletInfo[SaleIndex][Recipient]._AmountPurchasedWallet += DesiredAmount;\n                PresaleSalesInternal[SaleIndex]._GlobalPurchasesCitizen += DesiredAmount;\n                emit Citizen();\n            } \n            _Price = _PresaleSale._PricePresale * DesiredAmount;\n        }\n        else // Public Sale\n        { \n            _Price = _PresaleSale._PricePublic * DesiredAmount;\n            PresaleSalesInternal[SaleIndex]._GlobalPurchasesPublic += DesiredAmount;\n            PresaleEnded = true; \n            emit Public();\n        }\n        require(DesiredAmount <= _MaxPerPurchase, \"Invalid Desired Purchase Amount. Must Be <= Max Purchase Limit\"); // Purchase Limiter\n        require(_InternalPresaleSale._AmountSold + DesiredAmount <= _PresaleSale._MaxForSale, \"Sale Ended\"); // Sale End State\n        require(DesiredAmount > 0 && _Price > 0, \"Sale Ended\"); // Sale End State\n        require(msg.value >= _Price, \"Invalid ETH Amount\"); // Ensures ETH Amount Sent Is Correct\n        if(msg.value > _Price) { __Refund(msg.sender, msg.value - _Price); } // Refunds The Difference\n        if(_PresaleSale._Type == 0) { IMinter(_PresaleSale._NFT)._MintToFactory(0, msg.sender, DesiredAmount); }\n        else if (_PresaleSale._Type == 1) \n        { \n            for(uint x; x < DesiredAmount; x++) { IMinter(_PresaleSale._NFT).purchaseTo(msg.sender, _PresaleSale._ProjectID); }\n        }\n        PresaleSalesInternal[SaleIndex]._AmountSold += DesiredAmount;\n        PresaleSalesInternal[SaleIndex]._CurrentTokenIndex += DesiredAmount;\n        InternalSaleWalletInfo[SaleIndex][Recipient]._AmountPurchasedWallet += DesiredAmount;\n        emit PurchasedPresale(SaleIndex, Recipient, DesiredAmount, msg.value, PresaleEnded);\n    }\n\n    /**\n     * @dev Fixed Price Purchase\n     */\n    function PurchaseFixedPrice(uint SaleIndex, uint Amount, bytes32[] calldata Proof) external payable nonReentrant\n    {\n        require(tx.origin == msg.sender, \"Marketplace: EOA Only\");\n        require(block.timestamp >= FixedPriceSales[SaleIndex]._TimestampStart, \"Marketplace: Sale Not Started\");\n        (bool Brightlist, uint Priority) = VerifyBrightListWithPriority(SaleIndex, msg.sender, FixedPriceSales[SaleIndex]._Root, Proof);\n        if(Brightlist)  \n        {\n            require (\n                msg.value \n                == \n                (((FixedPriceSales[SaleIndex]._Price * Amount) * DiscountAmounts[SaleIndex][Priority] ) / 100), \n                \"Marketplace: Incorrect ETH Amount Sent\"\n            );\n        }\n        else { require(msg.value == FixedPriceSales[SaleIndex]._Price * Amount, \"Marketplace: Incorrect ETH Amount Sent\"); }\n        require(AmountSold[SaleIndex] + Amount <= FixedPriceSales[SaleIndex]._AmountForSale, \"Marketplace: Not Enough NFTs Left For Sale\");\n        AmountSold[SaleIndex] = AmountSold[SaleIndex] + Amount;\n        if(FixedPriceSales[SaleIndex]._Type == 0) // Factory MintPass Direct Mint\n        { \n            IMinter(FixedPriceSales[SaleIndex]._NFT)._MintToFactory(FixedPriceSales[SaleIndex]._MintPassProjectID, msg.sender, Amount); \n        }\n        else // ArtBlocks Style purchaseTo() Mint\n        { \n            uint ProjectID = FixedPriceSales[SaleIndex]._ABProjectID;\n            for(uint x; x < Amount; x++) { IMinter(FixedPriceSales[SaleIndex]._NFT).purchaseTo(msg.sender, ProjectID); }\n        } \n        emit Purchased(SaleIndex, msg.sender, Amount);\n    }\n\n    /*------------------\n     * ADMIN FUNCTIONS *\n    -------------------*/\n\n    /**\n     * @dev Instantiates A New Presale Sale\n     */\n    function __StartPresaleSale (\n        PresaleSale memory _Sale,\n        InternalPresaleSaleRoots memory _Roots\n    ) external onlyAdmin { \n        PresaleSales[_TOTAL_UNIQUE_SALES] = _Sale; \n        PresaleSalesInternal[_TOTAL_UNIQUE_SALES]._Active = true;\n        InternalRoots[_TOTAL_UNIQUE_SALES] = _Roots;\n        emit SaleStarted(_TOTAL_UNIQUE_SALES);\n        _TOTAL_UNIQUE_SALES++;\n    }\n\n    /**\n     * @dev Overwrites A Presale Sale\n     */\n    function __OverwritePresaleSale(uint SaleIndex, PresaleSale memory _Sale) external onlyAdmin { PresaleSales[SaleIndex] = _Sale; }\n    \n    /**\n     * @dev Changes The Presale Sale Type\n     */\n    function __ChangePresaleType(uint SaleIndex, uint Type) external onlyAdmin\n    {\n        PresaleSales[SaleIndex]._Type = Type;\n    }\n\n    /**\n     * @dev Changes Presale ArtBlocks ProjectID\n     */\n    function __ChangePresaleProjectID(uint SaleIndex, uint ProjectID) external onlyAdmin\n    {\n        PresaleSales[SaleIndex]._ProjectID = ProjectID;\n    }\n\n    /**\n     * @dev Changes Presale Times\n     */\n    function __ChangePresaleTimes (\n        uint SaleIndex,\n        uint TimestampSaleStart,\n        uint TimestampFullSetEnd,\n        uint TimestampCitizenEnd\n    ) external onlyAdmin {\n        PresaleSales[SaleIndex]._TimestampSaleStart = TimestampSaleStart;\n        PresaleSales[SaleIndex]._TimestampEndFullSet = TimestampFullSetEnd;\n        PresaleSales[SaleIndex]._TimestampEndCitizen = TimestampCitizenEnd;\n    }\n\n    /**\n     * @dev Changes All Presale Roots\n     */\n    function __ChangePresaleRootsAll (\n        uint SaleIndex,\n        bytes32 RootEligibilityFullSet,\n        bytes32 RootAmountsFullSet,\n        bytes32 RootEligibilityCitizen,\n        bytes32 RootAmountsCitizen\n    ) external onlyAdmin { \n        InternalRoots[SaleIndex]._RootEligibilityFullSet = RootEligibilityFullSet;\n        InternalRoots[SaleIndex]._RootEligibilityCitizen = RootEligibilityCitizen;\n        InternalRoots[SaleIndex]._RootAmountFullSet = RootAmountsFullSet;\n        InternalRoots[SaleIndex]._RootAmountCitizen = RootAmountsCitizen;\n    }\n\n    /**\n     * @dev Changes The Presale Roots For Merkle Eligibility\n     */\n    function __ChangePresaleRootsEligibility (\n        uint SaleIndex, \n        bytes32 RootCitizen,\n        bytes32 RootFullSet\n    ) external onlyAdmin {\n        InternalRoots[SaleIndex]._RootEligibilityCitizen = RootCitizen;\n        InternalRoots[SaleIndex]._RootEligibilityFullSet = RootFullSet;\n    }\n\n    /**\n     * @dev Changes The Presale Roots For Merkle Amounts\n     */\n    function __ChangePresaleRootsAmounts (\n        uint SaleIndex,\n        bytes32 RootCitizen,\n        bytes32 RootFullSet\n    ) external onlyAdmin {\n        InternalRoots[SaleIndex]._RootAmountCitizen = RootCitizen;\n        InternalRoots[SaleIndex]._RootAmountFullSet = RootFullSet;\n    }\n\n    /**\n     * @dev Changes Presale Sale Max For Sale\n     */\n    function __ChangePresaleSaleMaxForSale(uint SaleIndex, uint MaxForSale) external onlyAdmin \n    {   \n        require(PresaleSalesInternal[SaleIndex]._Active, \"Marketplace: Sale Not Active\");\n        PresaleSales[SaleIndex]._MaxForSale = MaxForSale; \n    }\n\n    /**\n     * @dev Change Presale Sale Max Per Purchase\n     */\n    function __ChangePresaleSaleMaxPerPurchase(uint SaleIndex, uint MaxPerPurchase) external onlyAdmin \n    {   \n        require(PresaleSalesInternal[SaleIndex]._Active, \"Marketplace: Sale Not Active\");\n        PresaleSales[SaleIndex]._MaxPerPurchase = MaxPerPurchase; \n    }\n\n    /**\n     * @dev Changes Presale Sale Mint Pass Price\n     */\n    function __ChangePresaleSalePresalePrice(uint SaleIndex, uint Price) external onlyAdmin \n    {   \n        require(PresaleSalesInternal[SaleIndex]._Active, \"Marketplace: Sale Not Active\");\n        PresaleSales[SaleIndex]._PricePresale = Price; \n    }\n\n    /**\n     * @dev Changes Presale Sale Public Price\n     */\n    function __ChangePresaleSalePublicPrice(uint SaleIndex, uint Price) external onlyAdmin \n    {   \n        require(PresaleSalesInternal[SaleIndex]._Active, \"Marketplace: Sale Not Active\");\n        PresaleSales[SaleIndex]._PricePublic = Price; \n    }\n\n    /**\n     * @dev Changes Timestamp End Full Set\n     */\n    function __ChangePresaleSaleEndFullSet(uint SaleIndex, uint Timestamp) external onlyAdmin \n    {   \n        require(PresaleSalesInternal[SaleIndex]._Active, \"Marketplace: Sale Not Active\");\n        PresaleSales[SaleIndex]._TimestampEndFullSet = Timestamp; \n    }\n\n    /**\n     * @dev Changes Timestamp End Citizen\n     */\n    function __ChangePresaleSaleEndCitizen(uint SaleIndex, uint Timestamp) external onlyAdmin\n    {\n        require(PresaleSalesInternal[SaleIndex]._Active, \"Marketplace: Sale Not Active\");\n        PresaleSales[SaleIndex]._TimestampEndCitizen = Timestamp; \n    }\n\n    /**\n     * @dev Changes Timestamp Sale Start\n     */\n    function __ChangePresaleSaleStart(uint SaleIndex, uint Timestamp) external onlyAdmin\n    {\n        require(PresaleSalesInternal[SaleIndex]._Active, \"Marketplace: Sale Not Active\");\n        PresaleSales[SaleIndex]._TimestampSaleStart = Timestamp; \n    }\n\n    /**\n     * @dev Changes Presale Sale Full Set Root\n     */\n    function __ChangePresaleSaleRootFullSet(uint SaleIndex, bytes32 RootFullSet) external onlyAdmin \n    { \n        InternalRoots[SaleIndex]._RootEligibilityFullSet = RootFullSet; \n    }\n\n    /**\n     * @dev Changes Presale Sale Citizen Root\n     */\n    function __ChangePresaleSaleRootCitizen(uint SaleIndex, bytes32 RootCitizen) external onlyAdmin\n    {\n        InternalRoots[SaleIndex]._RootAmountCitizen = RootCitizen; \n    }\n\n    /**\n     * @dev Initializes A Sale Via A Struct\n     */\n    function __StartFixedPriceSale (\n        uint SaleIndex, \n        Sale memory _Sale, \n        uint[] calldata Discounts\n    ) external onlyAdmin { \n        FixedPriceSales[SaleIndex] = _Sale; \n        DiscountAmounts[SaleIndex] = Discounts;\n    }\n\n    /**\n     * @dev Changes Presale Sale Discount Amounts (IN BIPS)\n     */\n    function __ChangeFixedPriceDiscountAmounts(uint SaleIndex, uint[] calldata Discounts) external onlyAdmin\n    {\n        DiscountAmounts[SaleIndex] = Discounts;\n    }\n\n    /**\n     * @dev Changes The NFT Address Of A Sale\n     */\n    function __ChangeFixedPriceNFTAddress(uint SaleIndex, address NewAddress) external onlyAdmin { FixedPriceSales[SaleIndex]._NFT = NewAddress; }\n\n    /**\n     * @dev Changes The Price Of A Sale\n     */\n    function __ChangeFixedPrice(uint SaleIndex, uint Price) external onlyAdmin { FixedPriceSales[SaleIndex]._Price = Price; }\n\n    /**\n     * @dev Changes The MintPass ProjectID\n     */\n    function __ChangeFixedPriceMintPassProjectID(uint SaleIndex, uint MintPassProjectID) external onlyAdmin \n    { \n        FixedPriceSales[SaleIndex]._MintPassProjectID = MintPassProjectID; \n    }\n\n    /**\n     * @dev Changes The ArtBlocks ProjectID\n     */\n    function __ChangeFixedPriceABProjectID(uint SaleIndex, uint ABProjectID) external onlyAdmin { FixedPriceSales[SaleIndex]._ABProjectID = ABProjectID; }\n\n    /**\n     * @dev Changes The Amount Of NFTs For Sale\n     */\n    function __ChangeFixedPriceAmountForSale(uint SaleIndex, uint AmountForSale) external onlyAdmin { FixedPriceSales[SaleIndex]._AmountForSale = AmountForSale; }\n\n    /**\n     * @dev Changes The Type Of A Sale\n     */\n    function __ChangeFixedPriceType(uint SaleIndex, uint Type) external onlyAdmin { FixedPriceSales[SaleIndex]._Type = Type; }\n\n    /*--------------*/\n    /*  ONLY OWNER  */\n    /*--------------*/\n\n    /**\n     * @dev onlyOwner: Grants Admin Role\n     */\n    function ___AdminGrant(address _Admin) external onlyOwner { Admin[_Admin] = true; }\n\n    /**\n     * @dev onlyOwner: Removes Admin Role\n     */\n    function ___AdminRemove(address _Admin) external onlyOwner { Admin[_Admin] = false; }\n\n    /**\n     * @dev onlyOwner: Withdraws All Ether From The Contract\n     */\n    function ___WithdrawEther() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }\n\n    /**\n     * @dev onlyOwner: Withdraws Ether From Contract To Address With An Amount\n     */\n    function ___WithdrawEtherToAddress(address payable Recipient, uint Amount) external onlyOwner\n    {\n        require(Amount > 0 && Amount <= address(this).balance, \"Invalid Amount\");\n        (bool Success, ) = Recipient.call{value: Amount}(\"\");\n        require(Success, \"Unable to Withdraw, Recipient May Have Reverted\");\n    }\n\n    /**\n     * @dev Withdraws ETH To Multisig\n     */\n    function ___WithdrawETHToMultisig() external onlyOwner \n    {\n        (bool success,) = _BRT_MULTISIG.call { value: address(this).balance }(\"\"); \n        require(success, \"Marketplace: ETH Withdraw Failed\"); \n    }\n\n    /**\n     * @dev Withdraws ERC721s From Contract\n     */\n    function ___WithdrawERC721(address Contract, address Recipient, uint[] calldata TokenIDs) external onlyOwner \n    { \n        for(uint TokenID; TokenID < TokenIDs.length;)\n        {\n            IERC721(Contract).transferFrom(address(this), Recipient, TokenIDs[TokenID]);\n            unchecked { TokenID++; }\n        }\n    }\n\n    /*-----------------\n     * VIEW FUNCTIONS *\n    ------------------*/\n\n    /**\n     * @dev Verifies Brightlist For Presale\n     */\n    function VerifyBrightList(address _Wallet, bytes32 _Root, bytes32[] calldata _Proof) public pure returns(bool)\n    {\n        bytes32 _Leaf = keccak256(abi.encodePacked(_Wallet));\n        return MerkleProof.verify(_Proof, _Root, _Leaf);\n    }\n\n    /**\n     * @dev Verifies Brightlist For Presale Fixed Price Sale\n     */\n    function VerifyBrightListWithPriority(uint SaleIndex, address _Wallet, bytes32 _Root, bytes32[] calldata _Proof) public view returns (bool, uint)\n    {\n        bytes32 _Leaf = keccak256(abi.encodePacked(_Wallet));\n        for(uint x; x < DiscountAmounts[SaleIndex].length; x++) { if(MerkleProof.verify(_Proof, _Root, _Leaf)) { return (true, x); } }\n        return (false, 69420);\n    }\n\n    /**\n     * @dev Verifies Maximum Purchase Amount Being Passed Is Valid\n     */\n    function VerifyAmount(address _Wallet, uint _Amount, bytes32 _Root, bytes32[] calldata _Proof) public pure returns(bool)\n    {\n        bytes32 _Leaf = (keccak256(abi.encodePacked(_Wallet, _Amount)));\n        return MerkleProof.verify(_Proof, _Root, _Leaf);\n    }\n\n    /**\n     * @dev Refunds `Recipient` ETH Amount `Value`\n     */\n    function __Refund(address Recipient, uint Value) internal\n    {\n        (bool Confirmed,) = Recipient.call{value: Value}(\"\"); \n        require(Confirmed, \"Marketplace: Refund failed\");\n        emit Refunded(Recipient, Value);\n    }\n\n    /**\n     * @dev Returns Sale Information for Presale Sale\n     */\n    function SaleInformation(uint SaleIndex) public view returns (SaleInfo memory) \n    {\n        PresaleSale memory _Sale = PresaleSales[SaleIndex];\n        InternalPresaleSale memory _SaleInternal = PresaleSalesInternal[SaleIndex];\n        uint AmountRemaining = _Sale._MaxForSale - PresaleSalesInternal[SaleIndex]._AmountSold;\n        return SaleInfo (\n            _Sale._PricePresale,\n            _Sale._PricePublic,\n            _SaleInternal._AmountSold,\n            _Sale._MaxForSale,\n            AmountRemaining,\n            _Sale._TimestampEndFullSet,\n            _Sale._TimestampEndCitizen,\n            _Sale._TimestampSaleStart,\n            _SaleInternal._GlobalPurchasesFullSet,\n            _SaleInternal._GlobalPurchasesCitizen,\n            _SaleInternal._GlobalPurchasesPublic\n        );\n    }\n\n    /**\n     * @dev Returns A Wallet's Sale Information For A Presale Sale\n     */\n    function WalletSaleInformation (\n        uint SaleIndex,\n        address Wallet,\n        uint MaxAmountFullSet,\n        uint MaxAmountCitizen,\n        bytes32[] calldata FullsetProof, \n        bytes32[] calldata CitizenProof,\n        bytes32[] calldata ProofAmountFullSet,\n        bytes32[] calldata ProofAmountCitizen\n    ) public view returns (WalletSaleInfo memory) {\n        uint AmountPurchaseableFullset;\n        uint AmountPurchaseableCitizen;\n        PresaleSale memory _Sale = PresaleSales[SaleIndex];\n        InternalPresaleSale memory _SaleInternal = PresaleSalesInternal[SaleIndex];\n        InternalWalletInfo memory _WalletInfo = InternalSaleWalletInfo[SaleIndex][Wallet];\n        if(_WalletInfo._AmountPurchasedFullSetWindow >= MaxAmountFullSet) { AmountPurchaseableFullset = 0; }\n        else { AmountPurchaseableFullset = MaxAmountFullSet - _WalletInfo._AmountPurchasedFullSetWindow; }\n        if(_WalletInfo._AmountPurchasedCitizenWindow >= MaxAmountCitizen) { AmountPurchaseableCitizen = 0; }\n        else { AmountPurchaseableCitizen = MaxAmountCitizen - _WalletInfo._AmountPurchasedCitizenWindow; }\n        return WalletSaleInfo (\n            _Sale._PricePresale, // _PricePresale\n            _Sale._PricePublic, // _PricePublic\n            _SaleInternal._AmountSold, // _AmountSold\n            _Sale._MaxForSale, // _MintPassesAvailable\n            _Sale._MaxForSale - _SaleInternal._AmountSold, // _MintPassesRemaining\n            _Sale._TimestampEndFullSet, // _TimestampEndFullSet\n            _Sale._TimestampEndCitizen, // _TimestampEndCitizen\n            _Sale._TimestampSaleStart, // _TimestampSaleStart\n            AmountPurchaseableFullset, // _AmountPurchasableFullSet\n            AmountPurchaseableCitizen, // _AmountPurchasableCitizen\n            _WalletInfo._AmountPurchasedFullSetWindow, // _AmountPurchasedFullSetWindow\n            _WalletInfo._AmountPurchasedCitizenWindow, // _AmountPurchasedCitizenWindow\n            _SaleInternal._GlobalPurchasesFullSet, // _GlobalPurchasesFullSet\n            _SaleInternal._GlobalPurchasesCitizen, // _GlobalPurchasesCitizen\n            _SaleInternal._GlobalPurchasesPublic, // _GlobalPurchasesPublic\n            _WalletInfo._AmountPurchasedWallet, // _AmountPurchasedWallet\n            VerifyBrightList(Wallet, InternalRoots[SaleIndex]._RootEligibilityFullSet, FullsetProof), // _EligibleFullSet\n            VerifyBrightList(Wallet, InternalRoots[SaleIndex]._RootEligibilityCitizen, CitizenProof), // _EligibleCitizen\n            VerifyAmount(Wallet, MaxAmountFullSet, InternalRoots[SaleIndex]._RootAmountFullSet, ProofAmountFullSet), // _ValidMaxAmountFullSet\n            VerifyAmount(Wallet, MaxAmountCitizen, InternalRoots[SaleIndex]._RootAmountCitizen, ProofAmountCitizen) // _ValidMaxAmountCitizen\n        );\n    }\n\n    /**\n     * @dev Returns The Sale Info For A Fixed Price Sale\n     */\n    function ViewFixedPriceSaleInfo (\n        uint SaleIndex,\n        address Wallet,\n        bytes32[] calldata Proof\n    ) public view returns (FixedPriceSaleInfo memory) {\n        uint Price = FixedPriceSales[SaleIndex]._Price;\n        uint AmountForSale = FixedPriceSales[SaleIndex]._AmountForSale;\n        uint AmountSoldFixed = AmountSold[SaleIndex];\n        uint TimestampStart = FixedPriceSales[SaleIndex]._TimestampStart;\n        (bool Eligible, uint Priority) = VerifyBrightListWithPriority(SaleIndex, Wallet, FixedPriceSales[SaleIndex]._Root, Proof);\n        bytes32 Root = FixedPriceSales[SaleIndex]._Root;\n        return FixedPriceSaleInfo(Price, AmountForSale, AmountSoldFixed, TimestampStart, Priority, Eligible, Root);\n    }\n\n    /*-----------\n     * MODIFIER *\n    ------------*/\n\n    modifier onlyAdmin\n    {\n        require(Admin[msg.sender]);\n        _;\n    }\n}\n\ninterface IERC20 { function approve(address From, address To, uint Amount) external; }\ninterface IERC721 { function transferFrom(address From, address To, uint TokenID) external; }"}, "contracts/MarketplaceEnabled.sol": {"content": "//SPDX-License-Identifier: MIT\n/**\n * @title MarketplaceEnabled\n * @dev @brougkr\n * note: This Contract Is Used To Enable DutchMarketplace To Purchase Tokens From Your Contract\n * note: This Contract Should Be Imported and Included In The `is` Portion Of The Contract Declaration, ex. `contract NFT is Ownable, MarketplaceEnabled`\n * note: You Can Copy Or Modify The Example Functions Below To Implement The Two Functions In Your Contract Required By MarketplaceEnabled\n */\npragma solidity ^0.8.30;\nabstract contract MarketplaceEnabled\n{\n    /**\n     * @dev Marketplace Mint\n     * note: Should Be Implemented With onlyMarketplace Access Modifier\n     * note: Should Return The TokenID Being Transferred To The Recipient\n     */\n    function _MintToFactory(uint ProjectID, address Recipient, uint Amount) external virtual;\n    // EXAMPLE:\n    // function _MintToFactory(uint ProjectID, address Recipient, uint Amount) override virtual external onlyMarketplace\n    // {\n    //     require(totalSupply() + Amount <= 100, \"MP: Max Supply Reached\");\n    //     _mint(Recipient, Amount); \n    // }\n\n    /**\n     * @dev ChangeMarketplaceAddress Changes The Marketplace Address | note: Should Be Implemented To Include onlyOwner Or Similar Access Modifier\n     */\n    function __ChangeMarketplaceAddress(address NewAddress) external virtual;\n    // EXAMPLE: \n    // function __ChangeMarketplaceAddress(address NewAddress) override virtual external onlyOwner { _MARKETPLACE = NewAddress; }\n\n    /**\n     * @dev Marketplace Address\n     */\n    address public _MARKETPLACE_ADDRESS = 0x3725a379F90BeB320101453A0C75196C40749571; // GOERLI\n    // address _MARKETPLACE_ADDRESS = 0x295f593B7A162B68b4353444cA622209492bCA2E; // MAINNET\n\n    /**\n     * @dev Access Modifier For Marketplace\n     */\n    modifier onlyMarketplace\n    {\n        require(msg.sender == _MARKETPLACE_ADDRESS, \"onlyMarketplace: `msg.sender` Is Not The Marketplace Contract\");\n        _;\n    }\n}"}, "contracts/MerkleClaimer.sol": {"content": "// SPDX-License-Identifier: MIT\n/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\n/**\n * @dev: @brougkr\n */\npragma solidity ^0.8.30;\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {IMinter} from \"./IMinter.sol\";\nimport {IMP} from \"./IMP.sol\";\ncontract MerkleClaimer is Ownable, ReentrancyGuard\n{\n    /*-------------------*/\n    /*      STRUCT       */\n    /*-------------------*/\n\n    struct User\n    {\n        bool[] RegularClaim;\n        uint _UserPurchasedAmount;\n    }\n\n    struct Claim\n    {\n        string _Name;\n        address _NFT; \n        address _Operator; \n        address _BurnNFT; \n        uint _ClaimCost; \n        uint _ProjectID; \n        uint _ClaimableAmount; \n        uint _AmountClaimed; \n        bytes32 _Root; \n    }\n\n    address private constant _BURN_ADDRESS = 0xcff43A597911a9457071d89d2b2AC3D5b1862b86;\n    address private constant _DR = 0x00000000000076A84feF008CDAbe6409d2FE638B;\n\n    /*-------------------*/\n    /*     MAPPINGS      */\n    /*-------------------*/\n\n    mapping(uint=>Claim) public Claims;                               // [ClaimIndex] => Claim\n    mapping(uint=>mapping(uint=>bool)) public ClaimedTokenID;         // [ClaimIndex][TokenID] => Minted\n    mapping(uint=>mapping(address=>uint)) public UserPurchasedAmount; // [ClaimIndex][Wallet] => Total Purchased Amount\n    \n    /*-------------------*/\n    /*      EVENTS       */\n    /*-------------------*/\n\n    event TokensClaimed(address Redeemer, uint[] TokenIDs);\n    event TokensClaimedAndBurned(address Redeemer, uint[] ClaimTokenIDs, uint[] BurnTokenIDs);\n    event TokensClaimedPurchaseTo(address Redeemer, uint ProjectID, uint Amount);\n\n    /*-------------------*/\n    /*    CONSTRUCTOR    */\n    /*-------------------*/\n\n    constructor() \n    { \n        Claims[0] = Claim( \n            'GTMX | Citizen',                           // [0] -> _Name\n            0xa7923530DE01B7019688a6CB0ff5f5388185200f, // [1] -> _NFT\n            0x93F01412C062C99C6ef105b1BAd93800B5635479, // [2] -> _Operator\n            0x7581e6E514bac22B6303e92A5eAa4bfF3167142D, // [3] -> _BurnNFT\n            0,                                          // [4] -> _ClaimCost\n            0,                                          // [5] -> _ProjectID\n            10,                                         // [6] -> _ClaimableAmount\n            0,                                          // [7] -> _AmountClaimed\n            0x80ed4a6987e367e9b9a580b9eea7c9f4459c5e64f69b43d72adc3ef29e519ef5 // [8] -> _Root\n        );\n        Claims[1] = Claim(\n            'Spongenuity',                              // [0] -> _Name               \n            0x7c3Ea2b7B3beFA1115aB51c09F0C9f245C500B18, // [1] -> _NFT\n            0x5A9C8Ab74D4d42525Be6501140C4c77006fa0c18, // [2] -> _Operator\n            address(0),                                 // [3] -> _BurnNFT\n            0,                                          // [4] -> _ClaimCost\n            0,                                          // [5] -> _ProjectID\n            100,                                        // [6] -> _ClaimableAmount\n            0,                                          // [7] -> _AmountClaimed\n            0x9605a751aedb82194538399866198355d24c9ab5fc8e1c923078b54c818f9013 // [8] -> _Root\n        );\n        Claims[2] = Claim( \n            'MPTK Option | MPTK',\n            0xA636d716024fAf7Db5876DD817859984f00E7AEF, // [0] -> _NFT\n            0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700, // [1] -> _Operator\n            0x140D6adB981c8a0781326214f3c8154D2F01b6ac, // [2] -> _BurnNFT\n            211959783913565000,                         // [3] -> _ClaimCost\n            0,                                          // [4] -> _ProjectID\n            100,                                        // [5] -> _ClaimableAmount\n            0,                                          // [6] -> _AmountClaimed\n            0x82b9b7a8cb49eeef9375e423cf350974c42f2a2da238b9fd59e5cd092ff6c9c8 // [8] -> _Root\n        );\n        Claims[3] = Claim(\n            'AIR | March 2023 | Intricada | Camille Roux',\n            0x7b9a45E278b5B374bb2d96C65665d4360C97BF01, // [0] -> _NFT\n            address(0),                                 // [1] -> _Operator\n            address(0),                                 // [2] -> _BurnNFT\n            0,                                          // [3] -> _ClaimCost\n            37,                                         // [4] -> _ProjectID\n            6000,                                       // [5] -> _ClaimableAmount\n            0,                                          // [6] -> _AmountClaimed\n            0x49078eeb447ca042a99c4aa849693be36de6549fb9914d6581b49c6cd3aadff2 // [8] -> _Root\n        );\n        _transferOwnership(0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700); // `operator.brightmoments.eth`\n    }\n\n    /*----------------------*/\n    /*  EXTERNAL FUNCTIONS  */\n    /*----------------------*/\n\n    /**\n     * @dev Claims TokenID(s) With Merkle\n     * note: transferFrom Implementation For NFT Transfer\n     */\n    function MerkleClaim (\n        uint ClaimIndex,\n        uint[] calldata TokenIDs,\n        bytes32[][] calldata Proof,\n        address Vault\n    ) external payable nonReentrant {\n        require(msg.value == (Claims[ClaimIndex]._ClaimCost * TokenIDs.length), \"Claimer: Invalid Message Value Sent\");\n        require(Proof.length > 0 && TokenIDs.length > 0, \"Claimer: Invalid Input\");\n        require(Proof.length == TokenIDs.length, \"Claimer: Arrays Must Match\");\n        address Recipient = msg.sender;\n        if(Vault != address(0)) { if(IDelegationRegistry(_DR).checkDelegateForAll(msg.sender, Vault)) { Recipient = Vault; } } \n        bool[] memory Eligibles = ReadEligibilityMerkleClaim(ClaimIndex, Recipient, TokenIDs, Proof);\n        for(uint Index; Index < TokenIDs.length; Index++)\n        {\n            require(Eligibles[Index], \"Claimer: Invalid Merkle\");\n            require(!ClaimedTokenID[ClaimIndex][TokenIDs[Index]], \"Claimer: NFT TokenID Already Claimed\");\n            ClaimedTokenID[ClaimIndex][TokenIDs[Index]] = true;\n            IERC721(Claims[ClaimIndex]._NFT).transferFrom(Claims[ClaimIndex]._Operator, msg.sender, TokenIDs[Index]);\n        }\n        emit TokensClaimed(msg.sender, TokenIDs);\n    }\n\n    /**\n     * @dev Claims TokenID(s) With Merkle\n     * note: purchaseTo Implementation For NFT Transfer\n     */\n    function MerkleClaimPurchaseTo (\n        uint ClaimIndex,\n        uint DesiredAmount,\n        uint MaxAmount,\n        bytes32[] calldata Proof,\n        address Vault\n    ) external payable nonReentrant {\n        address Recipient = msg.sender;\n        if(Vault != address(0)) { if(IDelegationRegistry(_DR).checkDelegateForAll(msg.sender, Vault)) { Recipient = Vault; } } \n        require(ReadEligibilityMerkleAmount(ClaimIndex, Recipient, MaxAmount, Proof), \"Claimer: Invalid Merkle\");\n        require(msg.value == (Claims[ClaimIndex]._ClaimCost * DesiredAmount), \"Claimer: Invalid Message Value Sent\");\n        require(DesiredAmount > 0 && UserPurchasedAmount[ClaimIndex][Recipient] + DesiredAmount <= MaxAmount, \"Claimer: Invalid DesiredAmount\");\n        require(Claims[ClaimIndex]._ClaimableAmount >= Claims[ClaimIndex]._AmountClaimed + DesiredAmount, \"Claimer: Too Many\");\n        UserPurchasedAmount[ClaimIndex][Recipient] += DesiredAmount;\n        Claims[ClaimIndex]._AmountClaimed += DesiredAmount;\n        for(uint Index; Index < DesiredAmount; Index++) { IMinter(Claims[ClaimIndex]._NFT).purchaseTo(msg.sender, Claims[ClaimIndex]._ProjectID); }\n        emit TokensClaimedPurchaseTo(msg.sender, Claims[ClaimIndex]._ProjectID, DesiredAmount);\n    }\n\n    /**\n     * @dev Claims TokenID(s) With Merkle\n     * note: This Is For 1:1 Mapping Burn To Redeem. Ex. Burn (NFT A TokenID 1) for (NFT B TokenID 90069420)\n     * note: transferFrom Implementation For NFT Burn & Transfer\n     */\n    function MerkleClaimAndBurn (\n        uint ClaimIndex,\n        uint[] calldata BurnTokenIDs,\n        uint[] calldata ClaimTokenIDs,\n        bytes32[][] calldata Proof\n    ) external payable nonReentrant {\n        require(msg.value == (Claims[ClaimIndex]._ClaimCost * ClaimTokenIDs.length), \"Claimer: Invalid Message Value Sent\");\n        require(Proof.length > 0 && BurnTokenIDs.length > 0 && ClaimTokenIDs.length > 0, \"Claimer: Invalid Input\");\n        require(BurnTokenIDs.length == ClaimTokenIDs.length && ClaimTokenIDs.length == Proof.length, \"Claimer: Arrays Must Match\");\n        bool[] memory Eligibles = ReadEligibilityMerkleClaimAndBurn(ClaimIndex, BurnTokenIDs, ClaimTokenIDs, Proof);\n        for(uint Index; Index < BurnTokenIDs.length; Index++)\n        {\n            require(IERC721(Claims[ClaimIndex]._BurnNFT).ownerOf(BurnTokenIDs[Index]) == msg.sender, \"Claimer: User Does Not Own Input TokenID\");\n            IERC721(Claims[ClaimIndex]._BurnNFT).transferFrom(msg.sender, _BURN_ADDRESS, BurnTokenIDs[Index]);\n            require(Eligibles[Index], \"Claimer: Invalid Merkle\");\n            require(!ClaimedTokenID[ClaimIndex][ClaimTokenIDs[Index]], \"Claimer: NFT Already Claimed\");\n            ClaimedTokenID[ClaimIndex][ClaimTokenIDs[Index]] = true;\n            IERC721(Claims[ClaimIndex]._NFT).transferFrom(Claims[ClaimIndex]._Operator, msg.sender, ClaimTokenIDs[Index]);\n        }\n        emit TokensClaimedAndBurned(msg.sender, ClaimTokenIDs, BurnTokenIDs);\n    }\n\n    /**\n     * @dev Claims TokenID(s) With Merkle\n     * note: This Is For 1:1 Mapping Burn To Redeem. Ex. Burn (NFT A TokenID 1) for (NFT B TokenID 90069420)\n     * note: transferFrom Implementation For NFT Burn & Transfer\n     */\n    function MerkleClaimAndBurnLive (\n        uint ClaimIndex,\n        uint[] calldata BurnTokenIDs,\n        uint[] calldata ClaimTokenIDs,\n        bytes32[][] calldata Proof\n    ) external payable nonReentrant {\n        require(msg.value == (Claims[ClaimIndex]._ClaimCost * ClaimTokenIDs.length), \"Claimer: Invalid Message Value Sent\");\n        require(Proof.length > 0 && BurnTokenIDs.length > 0 && ClaimTokenIDs.length > 0, \"Claimer: Invalid Input\");\n        require(BurnTokenIDs.length == ClaimTokenIDs.length && ClaimTokenIDs.length == Proof.length, \"Claimer: Arrays Must Match\"); \n        bool[] memory Eligibles = ReadEligibilityMerkleClaimAndBurn(ClaimIndex, BurnTokenIDs, ClaimTokenIDs, Proof);\n        for(uint Index; Index < BurnTokenIDs.length; Index++)\n        {\n            require(IERC721(Claims[ClaimIndex]._BurnNFT).ownerOf(BurnTokenIDs[Index]) == msg.sender, \"Claimer: User Does Not Own Input TokenID\");\n            require(Eligibles[Index], \"Claimer: Invalid Merkle\");\n            IMP(Claims[ClaimIndex]._BurnNFT)._LiveMintBurn(BurnTokenIDs[Index]);\n            require(!ClaimedTokenID[ClaimIndex][ClaimTokenIDs[Index]], \"Claimer: NFT Already Claimed\");\n            ClaimedTokenID[ClaimIndex][ClaimTokenIDs[Index]] = true;\n            IERC721(Claims[ClaimIndex]._NFT).transferFrom(Claims[ClaimIndex]._Operator, msg.sender, ClaimTokenIDs[Index]);\n        }\n        emit TokensClaimedAndBurned(msg.sender, ClaimTokenIDs, BurnTokenIDs);\n    }\n\n    /*-------------------*/\n    /*  OWNER FUNCTIONS  */\n    /*-------------------*/\n\n    /**\n     * @dev Approves ERC20 Address For Claim\n     */\n    function __ApproveERC20(uint ClaimIndex, address ERC20) external onlyOwner \n    { \n        IERC20(ERC20).approve(Claims[ClaimIndex]._NFT, type(uint).max); \n    }\n\n    /**\n     * @dev Starts A New Claim\n     */\n    function __NewClaim(\n        uint ClaimIndex,\n        string calldata Name,\n        address NFT,\n        address Operator,\n        address BurnNFT,\n        uint ClaimCost,\n        uint ProjectID,\n        uint PurchaseableAmount,\n        bytes32 Root\n    ) external onlyOwner {\n        Claims[ClaimIndex] = Claim(\n            Name,\n            NFT,\n            Operator,\n            BurnNFT,\n            ClaimCost,\n            ProjectID,\n            PurchaseableAmount,\n            0,\n            Root\n        );\n    }\n\n    \n    /**\n     * @dev Changes NFT\n     */\n    function __ChangeNFT(uint ClaimIndex, address NFT) external onlyOwner { Claims[ClaimIndex]._NFT = NFT; }\n\n    /**\n     * @dev Changes Operator\n     */\n    function __ChangeOperator(uint ClaimIndex, address Operator) external onlyOwner { Claims[ClaimIndex]._Operator = Operator; }\n\n    /**\n     * @dev Changes BurnNFT\n     */\n    function __ChangeBurnNFT(uint ClaimIndex, address BurnNFT) external onlyOwner { Claims[ClaimIndex]._BurnNFT = BurnNFT; }\n\n    /**\n     * @dev Changes ClaimCost\n     */\n    function __ChangeClaimCost(uint ClaimIndex, uint ClaimCost) external onlyOwner { Claims[ClaimIndex]._ClaimCost = ClaimCost; }\n\n    /**\n     * @dev Changes ProjectID\n     */\n    function __ChangeProjectID(uint ClaimIndex, uint ProjectID) external onlyOwner { Claims[ClaimIndex]._ProjectID = ProjectID; }\n    \n    /**\n     * @dev Changes PurchaseableAmount\n     */\n    function __ChangePurchaseableAmount(uint ClaimIndex, uint PurchaseableAmount) external onlyOwner { Claims[ClaimIndex]._ClaimableAmount = PurchaseableAmount; }\n\n    /**\n     * @dev Changes Root\n     */\n    function __ChangeRoot(uint ClaimIndex, bytes32 Root) external onlyOwner { Claims[ClaimIndex]._Root = Root; }\n\n    /**\n     * @dev Withdraws All Ether From The Contract\n     */\n    function ___WithdrawEther() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }\n\n    /**\n     * @dev Withdraws Ether From Contract To Address With An Amount\n     */\n    function ___WithdrawEtherToAddress(address payable Recipient, uint Amount) external onlyOwner\n    {\n        require(Amount > 0 && Amount <= address(this).balance, \"Claimer: Invalid Amount\");\n        (bool Success, ) = Recipient.call{value: Amount}(\"\");\n        require(Success, \"Claimer: Unable to Withdraw, Recipient May Have Reverted\");\n    }\n\n    /*------------------*/\n    /*  VIEW FUNCTIONS  */\n    /*------------------*/\n\n    /**\n     * @dev Returns A Wallet's Merkle Eligibility\n     */\n    function ReadEligibilityMerkleClaim (\n        uint ClaimIndex,\n        address Wallet,\n        uint[] calldata TokenIDs,\n        bytes32[][] calldata Proof\n    ) public view returns (bool[] memory) {\n        bool[] memory Eligibles = new bool[](TokenIDs.length);\n        for(uint Index; Index < TokenIDs.length; Index++)\n        {\n            bytes32 Leaf = keccak256(abi.encodePacked(Wallet, TokenIDs[Index]));\n            if(!ClaimedTokenID[ClaimIndex][TokenIDs[Index]]) { Eligibles[Index] = MerkleProof.verify(Proof[Index], Claims[ClaimIndex]._Root, Leaf); }\n        }\n        return Eligibles;\n    }\n\n    /**\n     * @dev Returns A Wallet's Merkle Eligibility\n     */\n    function ReadEligibilityMerkleClaimAndBurn (\n        uint ClaimIndex,\n        uint[] calldata BurnTokenIDs, \n        uint[] calldata ClaimTokenIDs,\n        bytes32[][] calldata Proof\n    ) public view returns (bool[] memory) {\n        bool[] memory Eligibles = new bool[](BurnTokenIDs.length);\n        for(uint Index; Index < BurnTokenIDs.length; Index++)\n        {\n            bytes32 Leaf = keccak256(abi.encodePacked(BurnTokenIDs[Index], ClaimTokenIDs[Index]));\n            if(!ClaimedTokenID[ClaimIndex][ClaimTokenIDs[Index]]) { Eligibles[Index] = MerkleProof.verify(Proof[Index], Claims[ClaimIndex]._Root, Leaf); }\n        }\n        return Eligibles;\n    }\n\n    /**\n     * @dev Returns A Wallet's Merkle Eligibility\n     * note: For Claims Where There Is A Derived Max Amount Per Wallet\n     */\n    function ReadEligibilityMerkleAmount (\n        uint ClaimIndex,\n        address Wallet,\n        uint MaxAmount,\n        bytes32[] calldata Proof\n    ) public view returns (bool) {\n        bytes32 Leaf = keccak256(abi.encodePacked(Wallet, MaxAmount));\n        return MerkleProof.verify(Proof, Claims[ClaimIndex]._Root, Leaf);\n    }\n\n    /**\n     * @dev Returns Merkle Eligibilities\n     */\n    function ReadEligibility (\n        uint ClaimIndex,\n        address Wallet,\n        uint[] calldata TokenIDs,\n        bytes32[][] calldata Proofs\n    ) public view returns (User memory) {\n        return User (\n            ReadEligibilityMerkleClaim(ClaimIndex, Wallet, TokenIDs, Proofs),\n            UserPurchasedAmount[ClaimIndex][Wallet]\n        );\n    }\n}\n\ninterface IDelegationRegistry\n{\n    /**\n     * @dev Checks If A Vault Has Delegated To The Delegate\n     */\n    function checkDelegateForAll(address delegate, address delegator) external view returns (bool);\n}"}, "contracts/MintPassFactory.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\nimport { DefaultOperatorFilterer } from \"operator-filter-registry/src/DefaultOperatorFilterer.sol\";\nimport { ERC721MPF } from \"./ERC721MPF.sol\";\nimport { ILaunchpad , ILaunchpadRegistry } from \"./ILaunchpad.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { LaunchpadEnabled } from \"./LaunchpadEnabled.sol\";\nimport { IOS } from \"./IOS.sol\";\ncontract MintPassFactory is Ownable, ERC721MPF, DefaultOperatorFilterer, LaunchpadEnabled, IOS\n{\n    struct MintPass\n    {\n        uint _MaxSupply;          // _MaxSupply\n        uint _MintPacks;          // _MintPacks\n        uint _ArtistIDs;          // _ArtistIDs\n        uint _ArtBlocksProjectID; // _ArtBlocksProjectID note: For Cases Where Mint Pass ProjectID 1:1 With ProjectIDs\n        uint _ReserveAmount;      // _Reserve\n        string _MetadataURI;      // _MetadataURI\n    }\n\n    uint public _TotalUniqueProjects;  // Total Projects Invoked\n    address public _Multisig; // test\n    uint private constant _ONE_MILLY = 1000000;\n    uint private constant _DEFAULT = type(uint).max; // max integer\n\n    mapping(uint=>MintPass) public MintPasses;\n    mapping(uint=>uint) public ArtistIDs;\n    mapping(address=>bool) public Authorized;\n    mapping(uint=>uint[]) public MintPackIndexes;\n    \n    event MintPassProjectCreated(uint MintPassProjectID);\n    event AuthorizedContract(address ContractAddress);\n    event DeauthorizedContract(address ContractAddress);\n\n    /**\n     * @dev Mint Pass Factory Constructor\n     */\n    constructor() ERC721MPF(\"Bright Moments Mint Pass | MPBRT\", \"MPBRT\") \n    { \n        Authorized[msg.sender] = true; \n        _Multisig = msg.sender;\n    }\n\n    /**\n     * @dev Returns All Mint Pack Indexes\n     */\n    function ReadMintPackIndexes(uint MintPassProjectID) public view returns (uint[] memory) { return MintPackIndexes[MintPassProjectID]; }\n\n    /**\n     * @dev Direct Mint Function\n     */\n    function _MintToFactory(uint MintPassProjectID, address Recipient, uint Amount) external onlyAuthorized\n    {\n        require(_Active[MintPassProjectID], \"MintPassFactory: ProjectID: `MintPassProjectID` Is Not Active\");\n        _mint(MintPassProjectID, Recipient, Amount);\n    }\n\n    /**\n     * @dev Direct Mint To Factory Pack\n     */\n    function _MintToFactoryPack(uint MintPassProjectID, address Recipient, uint Amount) external onlyAuthorized\n    {\n        require(_Active[MintPassProjectID], \"MintPassFactory: ProjectID: `MintPassProjectID` Is Not Active\");\n        uint NumArtists = MintPasses[MintPassProjectID]._ArtistIDs;\n        uint NumToMint = NumArtists * Amount;\n        uint StartingTokenID = ReadProjectInvocations(MintPassProjectID);\n        _mint(MintPassProjectID, Recipient, NumToMint);\n        for(uint x; x < Amount; x++) { MintPackIndexes[MintPassProjectID].push(StartingTokenID + (NumArtists * x)); }\n    }\n\n    /**\n     * @dev LiveMint Redeems Mint Pass If Not Already Burned & Sends Minted Work To Owner's Wallet\n     */\n    function _LiveMintBurn(uint TokenID) external onlyAuthorized returns (address _Recipient, uint _ArtistID)\n    {\n        address Recipient = IERC721(address(this)).ownerOf(TokenID);\n        require(Recipient != address(0), \"MPMX: Invalid Recipient\");\n        _burn(TokenID, false);\n        uint MintPassProjectID = TokenID % _ONE_MILLY;\n        if(MintPasses[MintPassProjectID]._ArtBlocksProjectID == _DEFAULT) { return (Recipient, ArtistIDs[TokenID]); }\n        else { return (Recipient, MintPasses[MintPassProjectID]._ArtBlocksProjectID); }\n    }\n\n    /**\n     * @dev Initializes A New Mint Pass\n     */\n    function __InitMintPass(MintPass memory _MintPass) external onlyAuthorized returns (uint MintPassProjectID)\n    {   \n        _Active[_TotalUniqueProjects] = true;\n        require(_MintPass._ArtistIDs * _MintPass._MintPacks <= _MintPass._MaxSupply, \"MintPassFactory: Invalid Mint Pass Parameters\");\n        _MaxSupply[_TotalUniqueProjects] = _MintPass._MaxSupply; // Internal Max Supply\n        MintPasses[_TotalUniqueProjects] = _MintPass;            // Struct Assignment\n        MintPasses[_TotalUniqueProjects]._MetadataURI = _MintPass._MetadataURI;\n        if(_MintPass._ReserveAmount > 0)\n        { \n            _mint(\n                _TotalUniqueProjects,    // MintPassProjectID\n                _Multisig,               // Multisig\n                _MintPass._ReserveAmount // Reserve Amount\n            );\n        }\n        emit MintPassProjectCreated(_TotalUniqueProjects);\n        _TotalUniqueProjects++;\n        return (_TotalUniqueProjects - 1);\n    }\n\n    /**\n     * @dev Updates The BaseURI For A Project\n     */\n    function __NewBaseURI(uint MintPassProjectID, string memory NewURI) external onlyAuthorized \n    { \n        require(_Active[MintPassProjectID], \"MintPassFactory: Mint Pass Is Not Active\");\n        MintPasses[MintPassProjectID]._MetadataURI = NewURI; \n    }\n\n    /**\n     * @dev Overrides The Operator Filter Active State\n     */\n    function __ChangeOperatorFilterState(bool State) external override onlyOwner { OPERATOR_FILTER_ENABLED = State; }\n\n    /**\n     * @dev Overrides The Launchpad Registry Address\n     */\n    function __NewLaunchpadAddress(address NewAddress) external onlyAuthorized { _LAUNCHPAD = NewAddress; }\n\n    /**\n     * @dev Authorizes A Contract To Mint\n     */\n    function ____AuthorizeContract(address NewAddress) external onlyOwner \n    { \n        Authorized[NewAddress] = true; \n        emit AuthorizedContract(NewAddress);\n    }\n\n    /**\n     * @dev Deauthorizes A Contract From Minting\n     */\n    function ___DeauthorizeContract(address NewAddress) external onlyOwner \n    { \n        Authorized[NewAddress] = false; \n        emit DeauthorizedContract(NewAddress);\n    }\n\n    /**\n     * @dev Overrides The Active State For A MintPassProjectID\n     */\n    function ____OverrideActiveState(uint MintPassProjectID, bool State) external onlyOwner { _Active[MintPassProjectID] = State; }\n\n    /**\n     * @dev Overrides The Max Supply For A MintPassProjectID\n     */\n    function ____OverrideMaxSupply(uint MintPassProjectID, uint NewMaxSupply) external onlyOwner \n    { \n        _MaxSupply[MintPassProjectID] = NewMaxSupply; \n        MintPasses[MintPassProjectID]._MaxSupply = NewMaxSupply;\n    }\n\n    /**\n     * @dev Owner Burn Function\n     */\n    function ____OverrideBurn(uint[] calldata TokenIDs) external onlyOwner\n    {\n        for(uint x; x < TokenIDs.length; x++) { _burn(TokenIDs[x], false); }\n    }\n\n    /**\n     * @dev Mints To Owner\n     */\n    function ___OverrideMint(uint MintPassProjectID, uint Amount) external onlyOwner\n    {\n        require(_Active[MintPassProjectID], \"MintPassFactory: Mint Pass Is Not Active\");\n        _mint(MintPassProjectID, msg.sender, Amount);\n    }\n\n    /**\n     * @dev Returns A MintPassProjectID From A TokenID\n     */\n    function ViewProjectID(uint TokenID) public pure returns (uint) { return (TokenID - (TokenID % 1000000)) / 1000000; }\n\n    /**\n     * @dev Returns The totalSupply() For A Specific MintPass ProjectID\n     */\n    function totalSupplyOfMintPassProject(uint[] calldata MintPassProjectIDs) external view returns (uint[] memory)\n    {\n        uint[] memory Supplies = new uint[](MintPassProjectIDs.length);\n        for(uint x; x < MintPassProjectIDs.length; x++)\n        {\n            uint MaxSupply = MintPasses[MintPassProjectIDs[x]]._MaxSupply; \n            uint Start = MintPassProjectIDs[x] * _ONE_MILLY;\n            uint Range = Start + MaxSupply;\n            uint Supply;\n            for(Start; Start < Range; Start++) { if(_ownerships[Start].addr != address(0)) { Supply += 1; } }\n        }\n        return Supplies;\n    }\n\n    /**\n     * @dev Returns The totalSupply() For A Specific MintPass ProjectID\n     */\n    function totalSupplyOfMintPassProjectID(uint MintPassProjectID) external view returns (uint)\n    {\n            uint MaxSupply = MintPasses[MintPassProjectID]._MaxSupply; \n            uint Start = MintPassProjectID * _ONE_MILLY;\n            uint Range = Start + MaxSupply;\n            uint Supply;\n            for(Start; Start < Range; Start++) \n            { \n                if(_ownerships[Start].addr != address(0) || !_ownerships[Start].burned) { Supply += 1; } \n            }\n    \n        return Supply;\n    }\n\n    /**\n     * @dev Returns Base URI Of Desired TokenID\n     */\n    function _baseURI(uint TokenID) internal view virtual override returns (string memory) \n    { \n        uint MintPassProjectID = ViewProjectID(TokenID);\n        return MintPasses[MintPassProjectID]._MetadataURI;\n        // return ILaunchpadRegistry(ILaunchpad(_LAUNCHPAD).ViewAddressLaunchpadRegistry()).ViewBaseURIMintPass(MintPassProjectID);\n    }\n\n    /*---------------------\n     * OVERRIDE FUNCTIONS *\n    ----------------------*/\n\n    function setApprovalForAll(\n        address operator, \n        bool approved\n    ) public override onlyAllowedOperatorApproval(operator) { super.setApprovalForAll(operator, approved); }\n\n    function approve(\n        address operator, \n        uint256 tokenId\n    ) public override onlyAllowedOperatorApproval(operator) { super.approve(operator, tokenId); }\n\n    function transferFrom(\n        address from, \n        address to, \n        uint256 tokenId\n    ) public override onlyAllowedOperator(from) { super.transferFrom(from, to, tokenId); }\n\n    function safeTransferFrom(\n        address from, \n        address to, \n        uint256 tokenId\n    ) public override onlyAllowedOperator(from) { super.safeTransferFrom(from, to, tokenId); }\n\n    function safeTransferFrom(\n        address from, \n        address to, \n        uint256 tokenId, \n        bytes memory data\n    ) public override onlyAllowedOperator(from) { super.safeTransferFrom(from, to, tokenId, data); }\n\n    /**\n     * @dev Access Modifier For External Smart Contracts\n     * note: This Is A Custom Access Modifier That Is Used To Restrict Access To Only Authorized Contracts\n     */\n    modifier onlyAuthorized()\n    {\n        if(msg.sender != owner()) \n        { \n            require(Authorized[msg.sender], \"MintPassFactory: Sender Is Not Authorized Contract\"); \n        }\n        _;\n    }\n}"}, "contracts/MPTM.sol": {"content": "//SPDX-License-Identifier: MIT\n/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\n/**\n * @dev: @brougkr\n */\npragma solidity ^0.8.30;\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { ERC721AO } from \"./ERC721AO.sol\";\nimport { DefaultOperatorFilterer } from \"operator-filter-registry/src/DefaultOperatorFilterer.sol\";\nimport { IOS } from \"./IOS.sol\";\nimport { MarketplaceEnabled } from \"./MarketplaceEnabled.sol\";\ncontract MPTM is Ownable, ERC721AO, DefaultOperatorFilterer, MarketplaceEnabled\n{\n    uint public _CurrentSeedIndex;\n    uint public _ArtBlocksProjectID = 16;\n    uint public _TOTAL_SUPPLY = 100;\n    string public baseURI = \"ipfs://QmXzsJ9UVN5uQ9Sibuf7jKge2KpXxjLyhBLwU7YBVFrM8n/\";\n    address public _LIVE_MINT = 0x1668f841ed817f5622a8480136B8c9CA1Fd09E6c;\n\n    constructor() ERC721AO(\"Mint Pass Totem | Beer Vangeer x Bright Moments | MPTM\", \"MPTM\") \n    { \n        // _mint(0xB96E81f80b3AEEf65CB6d0E280b15FD5DBE71937, 5);\n        // _transferOwnership(0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700); // `operator.brightmoments.eth`\n    }\n\n    /**\n     * @dev Factory Mint\n     */\n    function _MintToFactory(uint ProjectID, address Recipient, uint Amount) override virtual external onlyMarketplace\n    {\n        require(totalSupply() + Amount <= _TOTAL_SUPPLY, \"MP: Max Supply Reached\");\n        _mint(Recipient, Amount); \n    }\n\n    /**\n     * @dev Changes The Total Supply\n     */\n    function __ChangeTotalSupply(uint NewSupply) external onlyOwner { _TOTAL_SUPPLY = NewSupply; }\n\n    /**\n     * @dev Changes The Marketplace Address\n     */\n    function __ChangeMarketplaceAddress(address NewAddress) override virtual external onlyOwner { _MARKETPLACE_ADDRESS = NewAddress; }\n\n    /**\n     * @dev Changes ArtBlocks ProjectID Returned From LiveMint\n     */\n    function __ChangeArtBlocksProjectID(uint NewArtistID) external onlyOwner { _ArtBlocksProjectID = NewArtistID; }\n\n    /**\n     * @dev Executes Arbitrary Transaction(s)\n     */\n    function ___Execute(address[] memory Targets, uint[] memory Values, bytes[] memory Datas) external onlyOwner\n    {\n        for (uint x; x < Targets.length; x++) \n        {\n            (bool success,) = Targets[x].call{value:(Values[x])}(Datas[x]);\n            require(success, \"i have failed u anakin\");\n        }\n    }\n\n    /**\n     * @dev Instantiates New LiveMint Address\n     */\n    function ___NewLiveMintAddress(address NewAddress) external onlyOwner { _LIVE_MINT = NewAddress; }\n\n    /**\n     * @dev Changes The BaseURI For JSON Metadata \n     */\n    function ___NewBaseURI(string calldata NewURI) external onlyOwner { baseURI = NewURI; }\n\n    /**\n     * @dev Burns Golden Token(s)\n     */\n    function ___OwnerBurn(uint[] calldata TokenIDs) external onlyOwner { for(uint x; x < TokenIDs.length; x++){ _burn(TokenIDs[x], false); } }\n\n    /**\n     * @dev Withdraws All Ether From The Contract\n     */\n    function ___WithdrawEther() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }\n\n    /**\n     * @dev Withdraws Ether From Contract To Address With An Amount\n     */\n    function ___WithdrawEtherToAddress(address payable Recipient, uint Amount) external onlyOwner\n    {\n        require(Amount > 0 && Amount <= address(this).balance, \"Invalid Amount\");\n        (bool Success, ) = Recipient.call{value: Amount}(\"\");\n        require(Success, \"Unable to Withdraw, Recipient May Have Reverted\");\n    }\n\n    /**\n     * @dev Withdraws ERC20 Tokens\n     **/\n    function __WithdrawERC20(address TokenAddress) external onlyOwner \n    { \n        IERC20 erc20Token = IERC20(TokenAddress);\n        uint balance = erc20Token.balanceOf(address(this));\n        require(balance > 0, \"0 ERC20 Balance At `TokenAddress`\");\n        erc20Token.transfer(msg.sender, balance);\n    }\n\n    /**\n     * @dev Withdraws ERC721(s) Mistakenly Sent To Contract, From The Contract\n     */\n    function ___WithdrawERC721(address Contract, address Recipient, uint[] calldata TokenIDs) external onlyOwner \n    { \n        for(uint TokenID; TokenID < TokenIDs.length; TokenID++)\n        {\n            IERC721(Contract).transferFrom(address(this), Recipient, TokenIDs[TokenID]);\n        }\n    }\n    \n    /**\n     * @dev Returns Base URI\n     */\n    function _baseURI() internal view virtual override returns (string memory) { return baseURI; }\n\n    /*---------------------\n     * OVERRIDE FUNCTIONS *\n    ----------------------*/\n\n    function setApprovalForAll(\n        address operator, \n        bool approved\n    ) public override onlyAllowedOperatorApproval(operator) { super.setApprovalForAll(operator, approved); }\n\n    function approve(\n        address operator, \n        uint256 tokenId\n    ) public override onlyAllowedOperatorApproval(operator) { super.approve(operator, tokenId); }\n\n    function transferFrom(\n        address from, \n        address to, \n        uint256 tokenId\n    ) public override onlyAllowedOperator(from) { super.transferFrom(from, to, tokenId); }\n\n    function safeTransferFrom(\n        address from, \n        address to, \n        uint256 tokenId\n    ) public override onlyAllowedOperator(from) { super.safeTransferFrom(from, to, tokenId); }\n\n    function safeTransferFrom(\n        address from, \n        address to, \n        uint256 tokenId, \n        bytes memory data\n    ) public override onlyAllowedOperator(from) { super.safeTransferFrom(from, to, tokenId, data); }\n\n    /*--------------------\n     * LIVEMINT FUNCTION *\n    ---------------------*/\n\n    /**\n     * @dev LiveMint Redeems Golden Token If Not Already Burned & Sends Minted Work To Owner's Wallet\n     */\n    function _LiveMintBurn(uint TokenID) external returns (address _Recipient, uint _ArtistID)\n    {\n        require(msg.sender == _LIVE_MINT, \"MP: Sender Is Not Live Mint\");\n        address Recipient = IERC721(address(this)).ownerOf(TokenID);\n        require(Recipient != address(0), \"MP: Invalid Recipient\");\n        _burn(TokenID, false);\n        return (Recipient, _ArtBlocksProjectID);\n    }\n}"}, "contracts/RandomCollectorSelector.sol": {"content": "//SPDX-License-Identifier: MIT\n/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\n/**\n * @dev: @brougkr\n */\npragma solidity ^0.8.30;\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {VRFV2WrapperConsumerBase} from \"@chainlink/contracts/src/v0.8/VRFV2WrapperConsumerBase.sol\";\ncontract RandomCollectorSelector is Ownable, VRFV2WrapperConsumerBase\n{    \n    struct RequestStatus \n    {\n        uint paid;   // amount paid in link\n        bool fulfilled; // whether the request has been successfully fulfilled\n        uint[] randomWords; // random results\n    }\n\n    struct RCSParams\n    {\n        string Name;\n        string IPFSHash;\n        uint NumWinners;\n        uint SnapshotEntries;\n    }\n\n    mapping(uint => RCSParams) public RCSInfo;\n    mapping(address => bool) public Admin;            // [Wallet] -> Is Admin\n    mapping(uint => RequestStatus) public s_requests; // [RequestID] => `requestStatus`\n    uint[] public _RandomResults;                                                 \n    uint[] public requestIds;               // Array of request IDs\n    uint32 public numWords = 1;             // Number of random words to request from Chainlink VRF\n    uint16 public requestConfirmations = 1; // Number of confirmations to wait for before updating the request status\n    uint public lastRequestId;              // Last request ID\n    bool public _VRF;                       // VRF Status\n    bool public _VRFResponseStatus;         // VRF Response Status\n    uint public _CurrentRCSIndex;           // Current RCS Index\n\n    event RCSComplete(string _Name, uint _CurrentRCSIndex, uint _NumWinners, uint _SnapshotEntries, string _IPFSHash);\n    event RequestSent(uint requestId, uint32 numWords);\n    event RequestFulfilled(uint requestId, uint[] randomWords, uint payment);\n    event Winners(uint VRFRandomness, uint[] WinningIndexes);\n\n    constructor() VRFV2WrapperConsumerBase(0x5947BB275c521040051D82396192181b413227A3, 0x721DFbc5Cfe53d32ab00A9bdFa605d3b8E1f3f42)\n    {\n        Admin[msg.sender] = true; // deployer.brightmoments.eth\n        Admin[0xB96E81f80b3AEEf65CB6d0E280b15FD5DBE71937] = true; // brightmoments.eth\n        Admin[0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700] = true; // operator.brightmoments.eth\n        Admin[0x18B7511938FBe2EE08ADf3d4A24edB00A5C9B783] = true; // phil.brightmoments.eth\n        Admin[0x91594b5E5d74FCCB3f71674eE74C5F4D44f333D5] = true; // gitpancake.brightmoments.eth\n        Admin[0x65d674F2220Fa844c1e390AAf6739eC07519146E] = true; // irina.brightmoments.eth\n    } \n\n    /*-----------------\n     * VIEW FUNCTIONS *\n    ------------------*/\n\n    /**\n     * @dev Step 1: Request Random Number From Chainlink VRF\n     */\n    function VRFRandomSeed(uint32 CallbackGasLimit) external onlyAdmin returns (uint256 requestId)\n    {\n        require(!_VRF, \"Please Run RCS After This Function\");\n        _VRF = true;\n        requestId = requestRandomness(\n            CallbackGasLimit,\n            requestConfirmations,\n            numWords\n        );\n        s_requests[requestId] = RequestStatus({\n            paid: VRF_V2_WRAPPER.calculateRequestPrice(CallbackGasLimit),\n            randomWords: new uint256[](0),\n            fulfilled: false\n        });\n        requestIds.push(requestId);\n        lastRequestId = requestId;\n        emit RequestSent(requestId, numWords);\n        return requestId;\n    }\n\n    /**\n     * @dev Step 2: Emits Chainlink VRF Random Winners\n     */\n    function RCS(\n        string memory _Name,\n        string memory _IPFSHash, \n        uint _NumWinners, \n        uint _SnapshotEntries\n    ) external onlyAdmin {\n        require(_VRFResponseStatus, \"Must Wait Until VRF Random Seed Has Been Returned\"); \n        RCSInfo[_CurrentRCSIndex] = RCSParams({\n            Name: _Name,\n            IPFSHash: _IPFSHash,\n            NumWinners: _NumWinners,\n            SnapshotEntries: _SnapshotEntries\n        });\n        generateWinners(_NumWinners, _CurrentRCSIndex, _SnapshotEntries);\n        _CurrentRCSIndex++;\n        _VRFResponseStatus = false;\n        _VRF = false;\n        emit RCSComplete(_Name, _CurrentRCSIndex, _NumWinners, _SnapshotEntries, _IPFSHash);\n    }\n\n    /*----------------\n     * VRF FUNCTIONS *\n    -----------------*/\n    event Value(uint);\n    /**\n     * @dev Generates Winners From VRF Random Seed\n     */\n    function generateWinners(uint numWinners, uint drawId, uint snapshotEntries) private\n    {\n        uint[] memory WinningIndexes = new uint[](numWinners);\n        for(uint x; x < numWinners; x++) \n        {\n            WinningIndexes[x] = (uint(keccak256(abi.encode(_RandomResults[drawId], x))) % snapshotEntries) + 1;\n        }\n        emit Winners(_RandomResults[drawId], WinningIndexes);\n    }\n\n    /**\n     * @dev Withdraws ERC20 From Contract\n     */\n    function __WithdrawERC20(address ERC20) external onlyOwner\n    {\n        IERC20 token = IERC20(ERC20);\n        token.transfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    /**\n     * @dev VRF Callback Function\n     */\n    function fulfillRandomWords(uint _requestId, uint[] memory _randomWords) internal override \n    {\n        require(s_requests[_requestId].paid > 0, \"request not found\");\n        _VRFResponseStatus = true;\n        s_requests[_requestId].fulfilled = true;\n        s_requests[_requestId].randomWords = _randomWords;\n        _RandomResults.push(_randomWords[0]);\n        emit RequestFulfilled(_requestId, _randomWords, s_requests[_requestId].paid);\n    }\n\n    modifier onlyAdmin\n    {\n        require(Admin[msg.sender], \"onlyAdmin: Message Sender Is Not BRT Admin\");\n        _;\n    }\n}"}, "operator-filter-registry/src/DefaultOperatorFilterer.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {OperatorFilterer} from \"./OperatorFilterer.sol\";\nimport {CANONICAL_CORI_SUBSCRIPTION} from \"./lib/Constants.sol\";\n/**\n * @title  DefaultOperatorFilterer\n * @notice Inherits from OperatorFilterer and automatically subscribes to the default OpenSea subscription.\n * @dev    Please note that if your token contract does not provide an owner with EIP-173, it must provide\n *         administration methods on the contract itself to interact with the registry otherwise the subscription\n *         will be locked to the options set during construction.\n */\n\nabstract contract DefaultOperatorFilterer is OperatorFilterer {\n    /// @dev The constructor that is called when the contract is being deployed.\n    constructor() OperatorFilterer(CANONICAL_CORI_SUBSCRIPTION, true) {}\n}\n"}, "operator-filter-registry/src/IOperatorFilterRegistry.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IOperatorFilterRegistry {\n    /**\n     * @notice Returns true if operator is not filtered for a given token, either by address or codeHash. Also returns\n     *         true if supplied registrant address is not registered.\n     */\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool);\n\n    /**\n     * @notice Registers an address with the registry. May be called by address itself or by EIP-173 owner.\n     */\n    function register(address registrant) external;\n\n    /**\n     * @notice Registers an address with the registry and \"subscribes\" to another address's filtered operators and codeHashes.\n     */\n    function registerAndSubscribe(address registrant, address subscription) external;\n\n    /**\n     * @notice Registers an address with the registry and copies the filtered operators and codeHashes from another\n     *         address without subscribing.\n     */\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\n\n    /**\n     * @notice Unregisters an address with the registry and removes its subscription. May be called by address itself or by EIP-173 owner.\n     *         Note that this does not remove any filtered addresses or codeHashes.\n     *         Also note that any subscriptions to this registrant will still be active and follow the existing filtered addresses and codehashes.\n     */\n    function unregister(address addr) external;\n\n    /**\n     * @notice Update an operator address for a registered address - when filtered is true, the operator is filtered.\n     */\n    function updateOperator(address registrant, address operator, bool filtered) external;\n\n    /**\n     * @notice Update multiple operators for a registered address - when filtered is true, the operators will be filtered. Reverts on duplicates.\n     */\n    function updateOperators(address registrant, address[] calldata operators, bool filtered) external;\n\n    /**\n     * @notice Update a codeHash for a registered address - when filtered is true, the codeHash is filtered.\n     */\n    function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;\n\n    /**\n     * @notice Update multiple codeHashes for a registered address - when filtered is true, the codeHashes will be filtered. Reverts on duplicates.\n     */\n    function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;\n\n    /**\n     * @notice Subscribe an address to another registrant's filtered operators and codeHashes. Will remove previous\n     *         subscription if present.\n     *         Note that accounts with subscriptions may go on to subscribe to other accounts - in this case,\n     *         subscriptions will not be forwarded. Instead the former subscription's existing entries will still be\n     *         used.\n     */\n    function subscribe(address registrant, address registrantToSubscribe) external;\n\n    /**\n     * @notice Unsubscribe an address from its current subscribed registrant, and optionally copy its filtered operators and codeHashes.\n     */\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\n\n    /**\n     * @notice Get the subscription address of a given registrant, if any.\n     */\n    function subscriptionOf(address addr) external returns (address registrant);\n\n    /**\n     * @notice Get the set of addresses subscribed to a given registrant.\n     *         Note that order is not guaranteed as updates are made.\n     */\n    function subscribers(address registrant) external returns (address[] memory);\n\n    /**\n     * @notice Get the subscriber at a given index in the set of addresses subscribed to a given registrant.\n     *         Note that order is not guaranteed as updates are made.\n     */\n    function subscriberAt(address registrant, uint256 index) external returns (address);\n\n    /**\n     * @notice Copy filtered operators and codeHashes from a different registrantToCopy to addr.\n     */\n    function copyEntriesOf(address registrant, address registrantToCopy) external;\n\n    /**\n     * @notice Returns true if operator is filtered by a given address or its subscription.\n     */\n    function isOperatorFiltered(address registrant, address operator) external returns (bool);\n\n    /**\n     * @notice Returns true if the hash of an address's code is filtered by a given address or its subscription.\n     */\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\n\n    /**\n     * @notice Returns true if a codeHash is filtered by a given address or its subscription.\n     */\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\n\n    /**\n     * @notice Returns a list of filtered operators for a given address or its subscription.\n     */\n    function filteredOperators(address addr) external returns (address[] memory);\n\n    /**\n     * @notice Returns the set of filtered codeHashes for a given address or its subscription.\n     *         Note that order is not guaranteed as updates are made.\n     */\n    function filteredCodeHashes(address addr) external returns (bytes32[] memory);\n\n    /**\n     * @notice Returns the filtered operator at the given index of the set of filtered operators for a given address or\n     *         its subscription.\n     *         Note that order is not guaranteed as updates are made.\n     */\n    function filteredOperatorAt(address registrant, uint256 index) external returns (address);\n\n    /**\n     * @notice Returns the filtered codeHash at the given index of the list of filtered codeHashes for a given address or\n     *         its subscription.\n     *         Note that order is not guaranteed as updates are made.\n     */\n    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\n\n    /**\n     * @notice Returns true if an address has registered\n     */\n    function isRegistered(address addr) external returns (bool);\n\n    /**\n     * @dev Convenience method to compute the code hash of an arbitrary contract\n     */\n    function codeHashOf(address addr) external returns (bytes32);\n}\n"}, "operator-filter-registry/src/lib/Constants.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\naddress constant CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS = 0x000000000000AAeB6D7670E522A718067333cd4E;\naddress constant CANONICAL_CORI_SUBSCRIPTION = 0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6;\n"}, "operator-filter-registry/src/OperatorFilterer.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IOperatorFilterRegistry} from \"./IOperatorFilterRegistry.sol\";\nimport {CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS} from \"./lib/Constants.sol\";\n/**\n * @title  OperatorFilterer\n * @notice Abstract contract whose constructor automatically registers and optionally subscribes to or copies another\n *         registrant's entries in the OperatorFilterRegistry.\n * @dev    This smart contract is meant to be inherited by token contracts so they can use the following:\n *         - `onlyAllowedOperator` modifier for `transferFrom` and `safeTransferFrom` methods.\n *         - `onlyAllowedOperatorApproval` modifier for `approve` and `setApprovalForAll` methods.\n *         Please note that if your token contract does not provide an owner with EIP-173, it must provide\n *         administration methods on the contract itself to interact with the registry otherwise the subscription\n *         will be locked to the options set during construction.\n */\n\nabstract contract OperatorFilterer {\n    /// @dev Emitted when an operator is not allowed.\n    error OperatorNotAllowed(address operator);\n\n    IOperatorFilterRegistry public constant OPERATOR_FILTER_REGISTRY =\n        IOperatorFilterRegistry(CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS);\n\n    /// @dev The constructor that is called when the contract is being deployed.\n    constructor(address subscriptionOrRegistrantToCopy, bool subscribe) {\n        // If an inheriting token contract is deployed to a network without the registry deployed, the modifier\n        // will not revert, but the contract will need to be registered with the registry once it is deployed in\n        // order for the modifier to filter addresses.\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\n            if (subscribe) {\n                OPERATOR_FILTER_REGISTRY.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);\n            } else {\n                if (subscriptionOrRegistrantToCopy != address(0)) {\n                    OPERATOR_FILTER_REGISTRY.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);\n                } else {\n                    OPERATOR_FILTER_REGISTRY.register(address(this));\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev A helper function to check if an operator is allowed.\n     */\n    modifier onlyAllowedOperator(address from) virtual {\n        // Allow spending tokens from addresses with balance\n        // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred\n        // from an EOA.\n        if (from != msg.sender) {\n            _checkFilterOperator(msg.sender);\n        }\n        _;\n    }\n\n    /**\n     * @dev A helper function to check if an operator approval is allowed.\n     */\n    modifier onlyAllowedOperatorApproval(address operator) virtual {\n        _checkFilterOperator(operator);\n        _;\n    }\n\n    /**\n     * @dev A helper function to check if an operator is allowed.\n     */\n    function _checkFilterOperator(address operator) internal view virtual {\n        // Check registry code length to facilitate testing in environments without a deployed registry.\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\n            // under normal circumstances, this function will revert rather than return false, but inheriting contracts\n            // may specify their own OperatorFilterRegistry implementations, which may behave differently\n            if (!OPERATOR_FILTER_REGISTRY.isOperatorAllowed(address(this), operator)) {\n                revert OperatorNotAllowed(operator);\n            }\n        }\n    }\n}\n"}}, "settings": {"viaIR": false, "optimizer": {"enabled": true}, "outputSelection": {"*": {"*": ["evm.legacyAssembly"]}}, "libraries": {}}}