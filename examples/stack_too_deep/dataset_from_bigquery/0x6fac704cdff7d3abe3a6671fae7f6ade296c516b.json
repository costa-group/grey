{"language": "Solidity", "sources": {"@openzeppelin/contracts/access/Ownable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.30;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"}, "@openzeppelin/contracts/access/Ownable2Step.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.30;\n\nimport {Ownable} from \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\n * old one. This can help prevent common mistakes, such as transfers of ownership to\n * incorrect accounts, or to contracts that are unable to interact with the\n * permission system.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     *\n     * Setting `newOwner` to the zero address is allowed; this can be used to cancel an initiated ownership transfer.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n"}, "@openzeppelin/contracts/interfaces/IERC1363.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"}, "@openzeppelin/contracts/interfaces/IERC165.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.30;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"}, "@openzeppelin/contracts/interfaces/IERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"}, "@openzeppelin/contracts/token/ERC20/IERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"}, "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"}, "@openzeppelin/contracts/utils/Context.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"}, "@openzeppelin/contracts/utils/introspection/IERC165.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"}, "@zetachain/protocol-contracts/contracts/evm/interfaces/IGatewayEVM.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"../../../contracts/Revert.sol\";\n\n/// @title IGatewayEVMEvents\n/// @notice Interface for the events emitted by the GatewayEVM contract.\ninterface IGatewayEVMEvents {\n    /// @notice Emitted when a contract call is executed.\n    /// @param destination The address of the contract called.\n    /// @param value The amount of ETH sent with the call.\n    /// @param data The calldata passed to the contract call.\n    event Executed(address indexed destination, uint256 value, bytes data);\n\n    /// @notice Emitted when a contract call is reverted.\n    /// @param to The address of the contract called.\n    /// @param token The address of the ERC20 token, empty if gas token\n    /// @param amount The amount of ETH sent with the call.\n    /// @param data The calldata passed to the contract call.\n    /// @param revertContext Revert context to pass to onRevert.\n    event Reverted(address indexed to, address indexed token, uint256 amount, bytes data, RevertContext revertContext);\n\n    /// @notice Emitted when a contract call with ERC20 tokens is executed.\n    /// @param token The address of the ERC20 token.\n    /// @param to The address of the contract called.\n    /// @param amount The amount of tokens transferred.\n    /// @param data The calldata passed to the contract call.\n    event ExecutedWithERC20(address indexed token, address indexed to, uint256 amount, bytes data);\n\n    /// @notice Emitted when a deposit is made.\n    /// @param sender The address of the sender.\n    /// @param receiver The address of the receiver.\n    /// @param amount The amount of ETH or tokens deposited.\n    /// @param asset The address of the ERC20 token (zero address if ETH).\n    /// @param payload The calldata passed with the deposit. No longer used. Kept to maintain compatibility.\n    /// @param revertOptions Revert options.\n    event Deposited(\n        address indexed sender,\n        address indexed receiver,\n        uint256 amount,\n        address asset,\n        bytes payload,\n        RevertOptions revertOptions\n    );\n\n    /// @notice Emitted when a deposit and call is made.\n    /// @param sender The address of the sender.\n    /// @param receiver The address of the receiver.\n    /// @param amount The amount of ETH or tokens deposited.\n    /// @param asset The address of the ERC20 token (zero address if ETH).\n    /// @param payload The calldata passed with the deposit.\n    /// @param revertOptions Revert options.\n    event DepositedAndCalled(\n        address indexed sender,\n        address indexed receiver,\n        uint256 amount,\n        address asset,\n        bytes payload,\n        RevertOptions revertOptions\n    );\n\n    /// @notice Emitted when an omnichain smart contract call is made without asset transfer.\n    /// @param sender The address of the sender.\n    /// @param receiver The address of the receiver.\n    /// @param payload The calldata passed to the call.\n    /// @param revertOptions Revert options.\n    event Called(address indexed sender, address indexed receiver, bytes payload, RevertOptions revertOptions);\n\n    /// @notice Emitted when tss address is updated\n    /// @param oldTSSAddress old tss address\n    /// @param newTSSAddress new tss address\n    event UpdatedGatewayTSSAddress(address oldTSSAddress, address newTSSAddress);\n}\n\n/// @title IGatewayEVMErrors\n/// @notice Interface for the errors used in the GatewayEVM contract.\ninterface IGatewayEVMErrors {\n    /// @notice Error for failed execution.\n    error ExecutionFailed();\n\n    /// @notice Error for failed deposit.\n    error DepositFailed();\n\n    /// @notice Error for insufficient ETH amount.\n    error InsufficientETHAmount();\n\n    /// @notice Error for insufficient ERC20 token amount.\n    error InsufficientERC20Amount();\n\n    /// @notice Error for zero address input.\n    error ZeroAddress();\n\n    /// @notice Error for failed token approval.\n    error ApprovalFailed();\n\n    /// @notice Error for already initialized custody.\n    error CustodyInitialized();\n\n    /// @notice Error for already initialized connector.\n    error ConnectorInitialized();\n\n    /// @notice Error when trying to transfer not whitelisted token to custody.\n    error NotWhitelistedInCustody();\n\n    /// @notice Error when trying to call onCall method using arbitrary call.\n    error NotAllowedToCallOnCall();\n\n    /// @notice Error when trying to call onRevert method using arbitrary call.\n    error NotAllowedToCallOnRevert();\n\n    /// @notice Error indicating payload size exceeded in external functions.\n    error PayloadSizeExceeded();\n}\n\n/// @title IGatewayEVM\n/// @notice Interface for the GatewayEVM contract.\ninterface IGatewayEVM is IGatewayEVMErrors, IGatewayEVMEvents {\n    /// @notice Executes a call to a contract using ERC20 tokens.\n    /// @param messageContext Message context containing sender and arbitrary call flag.\n    /// @param token The address of the ERC20 token.\n    /// @param to The address of the contract to call.\n    /// @param amount The amount of tokens to transfer.\n    /// @param data The calldata to pass to the contract call.\n    function executeWithERC20(\n        MessageContext calldata messageContext,\n        address token,\n        address to,\n        uint256 amount,\n        bytes calldata data\n    )\n        external;\n\n    /// @notice Transfers msg.value to destination contract and executes it's onRevert function.\n    /// @dev This function can only be called by the TSS address and it is payable.\n    /// @param destination Address to call.\n    /// @param data Calldata to pass to the call.\n    /// @param revertContext Revert context to pass to onRevert.\n    function executeRevert(\n        address destination,\n        bytes calldata data,\n        RevertContext calldata revertContext\n    )\n        external\n        payable;\n\n    /// @notice Executes a call to a destination address without ERC20 tokens.\n    /// @dev This function can only be called by the TSS address and it is payable.\n    /// @param messageContext Message context containing sender and arbitrary call flag.\n    /// @param destination Address to call.\n    /// @param data Calldata to pass to the call.\n    /// @return The result of the call.\n    function execute(\n        MessageContext calldata messageContext,\n        address destination,\n        bytes calldata data\n    )\n        external\n        payable\n        returns (bytes memory);\n\n    /// @notice Executes a revertable call to a contract using ERC20 tokens.\n    /// @param token The address of the ERC20 token.\n    /// @param to The address of the contract to call.\n    /// @param amount The amount of tokens to transfer.\n    /// @param data The calldata to pass to the contract call.\n    /// @param revertContext Revert context to pass to onRevert.\n    function revertWithERC20(\n        address token,\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        RevertContext calldata revertContext\n    )\n        external;\n\n    /// @notice Deposits ETH to the TSS address.\n    /// @param receiver Address of the receiver.\n    /// @param revertOptions Revert options.\n    function deposit(address receiver, RevertOptions calldata revertOptions) external payable;\n\n    /// @notice Deposits ERC20 tokens to the custody or connector contract.\n    /// @param receiver Address of the receiver.\n    /// @param amount Amount of tokens to deposit.\n    /// @param asset Address of the ERC20 token.\n    /// @param revertOptions Revert options.\n    function deposit(address receiver, uint256 amount, address asset, RevertOptions calldata revertOptions) external;\n\n    /// @notice Deposits ETH to the TSS address and calls an omnichain smart contract.\n    /// @param receiver Address of the receiver.\n    /// @param payload Calldata to pass to the call.\n    /// @param revertOptions Revert options.\n    function depositAndCall(\n        address receiver,\n        bytes calldata payload,\n        RevertOptions calldata revertOptions\n    )\n        external\n        payable;\n\n    /// @notice Deposits ERC20 tokens to the custody or connector contract and calls an omnichain smart contract.\n    /// @param receiver Address of the receiver.\n    /// @param amount Amount of tokens to deposit.\n    /// @param asset Address of the ERC20 token.\n    /// @param payload Calldata to pass to the call.\n    /// @param revertOptions Revert options.\n    function depositAndCall(\n        address receiver,\n        uint256 amount,\n        address asset,\n        bytes calldata payload,\n        RevertOptions calldata revertOptions\n    )\n        external;\n\n    /// @notice Calls an omnichain smart contract without asset transfer.\n    /// @param receiver Address of the receiver.\n    /// @param payload Calldata to pass to the call.\n    /// @param revertOptions Revert options.\n    function call(address receiver, bytes calldata payload, RevertOptions calldata revertOptions) external;\n}\n\n/// @notice Message context passed to execute function.\n/// @param sender Sender from omnichain contract.\nstruct MessageContext {\n    address sender;\n}\n\n/// @notice Interface implemented by contracts receiving authenticated calls.\ninterface Callable {\n    function onCall(MessageContext calldata context, bytes calldata message) external payable returns (bytes memory);\n}\n"}, "@zetachain/protocol-contracts/contracts/Revert.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Struct containing revert options\n/// @param revertAddress Address to receive revert.\n/// @param callOnRevert Flag if onRevert hook should be called.\n/// @param abortAddress Address to receive funds if aborted.\n/// @param revertMessage Arbitrary data sent back in onRevert.\n/// @param onRevertGasLimit Gas limit for revert tx, unused on GatewayZEVM methods\nstruct RevertOptions {\n    address revertAddress;\n    bool callOnRevert;\n    address abortAddress;\n    bytes revertMessage;\n    uint256 onRevertGasLimit;\n}\n\n/// @notice Struct containing revert context passed to onRevert.\n/// @param sender Address of account that initiated smart contract call.\n/// @param asset Address of asset, empty if it's gas token.\n/// @param amount Amount specified with the transaction.\n/// @param revertMessage Arbitrary data sent back in onRevert.\nstruct RevertContext {\n    address sender;\n    address asset;\n    uint256 amount;\n    bytes revertMessage;\n}\n\n/// @title Revertable\n/// @notice Interface for contracts that support revertable calls.\ninterface Revertable {\n    /// @notice Called when a revertable call is made.\n    /// @param revertContext Revert context to pass to onRevert.\n    function onRevert(RevertContext calldata revertContext) external;\n}\n"}, "contracts/interfaces/I4626Vault.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface I4626Vault {\n    function deposit(\n        uint256 assets,\n        address receiver\n    ) external returns (uint256);\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256);\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function convertToAssets(uint256 shares) external view returns (uint256);\n\n    function convertToShares(uint256 assets) external view returns (uint256);\n\n    function maxWithdraw(address account) external view returns (uint256);\n}\n"}, "contracts/interfaces/IConvexBooster.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IConvexBooster {\n    function deposit(\n        uint256 _pid,\n        uint256 _amount,\n        bool _stake\n    ) external returns (bool);\n\n    function poolLength() external view returns (uint256);\n\n    function poolInfo(\n        uint256 pid\n    )\n        external\n        view\n        returns (\n            address lptoken,\n            address token,\n            address gauge,\n            address crvRewards,\n            address stash,\n            bool shutdown\n        );\n}\n"}, "contracts/interfaces/IConvexRewardPool.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IConvexRewardPool {\n    function getReward(\n        address _account,\n        bool _claimExtras\n    ) external returns (bool);\n\n    function earned(address _account) external view returns (uint256);\n\n    function withdrawAndUnwrap(\n        uint256 _amount,\n        bool _claim\n    ) external returns (bool);\n\n    function balanceOf(address _account) external view returns (uint256);\n\n    function stakeFor(address _for, uint256 _amount) external returns (bool);\n\n    function withdrawAll(bool claim) external;\n\n    function stakingToken() external view returns (address);\n}\n"}, "contracts/interfaces/ICurvePoolFixed.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ICurvePoolFixed is IERC20 {\n    function exchange(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external returns (uint256);\n\n    function coins(uint256 i) external view returns (address);\n\n    function get_dy(\n        uint256 i,\n        uint256 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function add_liquidity(\n        uint256[2] memory amounts,\n        uint256 min_mint_amount\n    ) external returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 _token_amount,\n        int128 i,\n        uint256 min_amount\n    ) external returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n\n    function calc_token_amount(\n        uint256[2] memory amounts,\n        bool is_deposit\n    ) external view returns (uint256);\n\n    function calc_withdraw_one_coin(\n        uint256 _token_amount,\n        int128 i\n    ) external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n}\n"}, "contracts/interfaces/IDistributor.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IDistributor {\n    function toggleOperator(address user, address operator) external;\n}\n"}, "contracts/interfaces/IErrors.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IErrors {\n    error OnlyGateway();\n    error OnlyVault();\n    error InvalidAddress();\n    error OldStrategyNotSet();\n    error NotAuthorized();\n    error NoFundsReceived();\n    error NothingToWithdraw();\n    error InsufficientOut();\n    error TransferFailed();\n    error ExceedsMaxSharesOut();\n    error InvalidStrategyChainId();\n    error FeeExceedsLimit();\n    error AmountCantBeZero();\n    error DepositExceedsLimit();\n    error MintExceedsLimit();\n    error WithdrawExceedsLimit();\n    error RedeemExceedsLimit();\n    error ConfirmationAlreadyProcessed();\n    error StrategyAlreadySet();\n    error NoAssetsToSwitch();\n    error DepositsPaused();\n\n    error InsufficientBalance();\n    error VaultAlreadyAuthorized();\n\n    error InvalidPathLength();\n    error InsufficientLiquidity();\n    error InsufficientInputAmount();\n    error InvalidPath();\n    error InvalidTokenPair();\n\n    error InvalidMessage();\n    error InvalidAmanaVault();\n}\n"}, "contracts/interfaces/IStrategy.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IStrategy {\n    function invest(uint256 amount, uint256 minimumOut) external;\n\n    function withdraw(\n        uint256 _fraction,\n        uint256 minAmountOut\n    ) external returns (uint256);\n\n    function depositFromOldStrategy(\n        uint256 amount,\n        uint256 minimumOut,\n        uint256 _executionNonce,\n        bytes32 _crossChainTxId\n    ) external payable;\n\n    function totalUnderlyingAssets() external view returns (uint256);\n\n    function amanaVault() external view returns (address);\n\n    function checkRewards() external view returns (uint256);\n}\n"}, "contracts/interfaces/ISwapHelper.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\ninterface ISwapHelper {\n    /// @notice Swaps a specified amount of ZRC20 tokens for another ZRC20 token.\n    /// @param zrc20 The address of the ZRC20 token to swap from.\n    /// @param amount The amount of ZRC20 tokens to swap.\n    /// @param targetZRC20 The address of the ZRC20 token to swap to.\n    /// @param slippageBps The maximum slippage allowed in basis points.\n    /// @param vault The address of the vault to use for the swap.\n    /// @param maxDeadline The maximum deadline for the swap in seconds.\n    function swap(\n        address zrc20,\n        uint256 amount,\n        address targetZRC20,\n        uint16 slippageBps,\n        address vault,\n        uint16 maxDeadline,\n        bytes calldata data\n    ) external returns (uint256 amountOut);\n\n    /// @notice Swaps an amount of ZRC20 tokens for a specified amount ofanother ZRC20 token, with the option to specify a maximum amount in.\n    /// @param zrc20 The address of the ZRC20 token to swap from.\n    /// @param amountOut The amount of ZRC20 tokens to swap for.\n    /// @param targetZRC20 The address of the ZRC20 token to swap to.\n    /// @param slippageBps The maximum slippage allowed in basis points.\n    /// @param vault The address of the vault to use for the swap.\n    /// @param maxDeadline The maximum deadline for the swap in seconds.\n    /// @param data Additional data for the swap.\n    /// @return amountIn The amount of ZRC20 tokens swapped in.\n    function swapExactOut(\n        uint256 totalAmountAvailable,\n        address zrc20,\n        uint256 amountOut,\n        address targetZRC20,\n        uint16 slippageBps,\n        address vault,\n        uint16 maxDeadline,\n        bytes calldata data\n    ) external returns (uint256 amountIn);\n}\n"}, "contracts/interfaces/IWETH.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n\n    function withdraw(uint256) external;\n}\n"}, "contracts/strategies/ConvexEthStrategy.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./EthStrategyParent.sol\";\n\nimport \"../interfaces/ICurvePoolFixed.sol\";\nimport \"../interfaces/ISwapHelper.sol\";\nimport \"../interfaces/IConvexBooster.sol\";\nimport \"../interfaces/IConvexRewardPool.sol\";\n\ncontract ConvexEthStrategy is EthStrategyParent {\n    using SafeERC20 for IERC20;\n\n    ICurvePoolFixed public immutable receiptToken;\n    IConvexBooster public immutable booster;\n    IConvexRewardPool public immutable rewardPool;\n\n    IWETH public immutable weth;\n    address public immutable cvxToken;\n    address public immutable crvToken;\n\n    address public swapHelperEthereum;\n    uint256 public inputTokenIndex;\n    uint256 public convexPid;\n\n    uint16 public harvestSwapSlippage = 500; // 5% slippage\n\n    constructor(\n        string memory _name,\n        address _amanaVault,\n        address _withdrawHelper,\n        address _swapHelper,\n        address _receiptTokenAddress,\n        address _inputTokenAddress,\n        address _rewardPoolAddress,\n        address _crvToken,\n        uint256 _inputTokenIndex,\n        uint256 _convexPid,\n        address _boosterAddress,\n        address _cvxToken\n    ) StrategyParent(_name, _amanaVault, GATEWAY_ADDRESS, _withdrawHelper) {\n        receiptToken = ICurvePoolFixed(_receiptTokenAddress);\n        weth = IWETH(_inputTokenAddress);\n        swapHelperEthereum = _swapHelper;\n        booster = IConvexBooster(_boosterAddress);\n        rewardPool = IConvexRewardPool(_rewardPoolAddress);\n        crvToken = _crvToken;\n        cvxToken = _cvxToken;\n        inputTokenIndex = _inputTokenIndex;\n        convexPid = _convexPid;\n    }\n\n    function setHarvestSwapSlippage(uint16 _slippage) external onlyOwner {\n        harvestSwapSlippage = _slippage;\n    }\n\n    function setSwapHelperEthereum(address _swapHelper) external onlyOwner {\n        swapHelperEthereum = _swapHelper;\n    }\n\n    function swapToWeth(\n        address token,\n        uint256 amountIn,\n        uint16 slippageBps\n    ) internal returns (uint256 amountOut) {\n        require(amountIn > 0, \"Amount must be greater than zero\");\n\n        SafeERC20.safeTransfer(IERC20(token), swapHelperEthereum, amountIn);\n        uint16 maxDeadline = uint16(block.timestamp + 1 hours);\n        amountOut = ISwapHelper(swapHelperEthereum).swap(\n            token,\n            amountIn,\n            address(weth),\n            slippageBps,\n            address(this),\n            maxDeadline,\n            \"\"\n        );\n\n        require(\n            amountOut > 0,\n            \"Swap failed: Amount out must be greater than zero\"\n        );\n\n        return amountOut;\n    }\n\n    function claimRewards() public returns (uint256) {\n        uint256 earnedCrv = IConvexRewardPool(rewardPool).earned(address(this));\n        if (earnedCrv < 1e15) {\n            return 0; // Skip claiming if there's too little to claim\n        }\n        // Get the balance of CRV before claiming\n        uint256 amountBefore = IERC20(crvToken).balanceOf(address(this));\n\n        // Call Convex rewards contract to claim CRV + extras\n        IConvexRewardPool(rewardPool).getReward(address(this), true);\n\n        // Get the balance of CRV after claiming\n        uint256 amountAfter = IERC20(crvToken).balanceOf(address(this));\n\n        uint256 claimed = amountAfter - amountBefore;\n\n        emit RewardsClaimed(address(this), crvToken, claimed);\n        return claimed;\n    }\n\n    function harvest() public {\n        claimRewards();\n        _reinvestRewards();\n    }\n\n    function _reinvestRewards() internal {\n        uint256 crvBalance = IERC20(crvToken).balanceOf(address(this));\n        uint256 cvxBalance = IERC20(cvxToken).balanceOf(address(this));\n        if (crvBalance == 0 && cvxBalance == 0) return;\n        uint256 wethFromCrv;\n        uint256 wethFromCvx;\n        if (crvBalance > 0) {\n            wethFromCrv = swapToWeth(crvToken, crvBalance, harvestSwapSlippage);\n        }\n        if (cvxBalance > 0) {\n            wethFromCvx = swapToWeth(cvxToken, cvxBalance, harvestSwapSlippage);\n        }\n\n        uint256 totalWeth = wethFromCrv + wethFromCvx;\n\n        uint256[2] memory amounts;\n        amounts[inputTokenIndex] = totalWeth;\n\n        approveOrIncreaseAllowance(\n            IERC20(weth),\n            address(receiptToken),\n            totalWeth\n        );\n        uint256 shares = receiptToken.add_liquidity(amounts, 0);\n\n        approveOrIncreaseAllowance(\n            IERC20(receiptToken),\n            address(booster),\n            shares\n        );\n        booster.deposit(convexPid, shares, true);\n\n        emit RewardsHarvested(crvBalance + cvxBalance, crvBalance, wethFromCrv);\n    }\n\n    function _depositFundsIntoYieldSource(\n        uint256 amount,\n        uint256 minimumOut\n    ) internal override {\n        harvest();\n        weth.deposit{value: amount}();\n\n        uint256[2] memory amounts;\n        amounts[inputTokenIndex] = amount;\n\n        approveOrIncreaseAllowance(IERC20(weth), address(receiptToken), amount);\n        uint256 shares = receiptToken.add_liquidity(amounts, minimumOut);\n\n        approveOrIncreaseAllowance(\n            IERC20(receiptToken),\n            address(booster),\n            shares\n        );\n        booster.deposit(convexPid, shares, true);\n    }\n\n    function _withdrawFundsFromYieldSource(\n        uint256 fractionToWithdraw,\n        uint256 minAmountOut\n    ) internal override returns (uint256 amountWithdrawn) {\n        uint256 sharesToWithdraw = getStrategyWithdrawShareAmount(\n            fractionToWithdraw\n        );\n\n        harvest();\n        sharesToWithdraw = getStrategyWithdrawShareAmount(fractionToWithdraw);\n        rewardPool.withdrawAndUnwrap(sharesToWithdraw, false);\n\n        amountWithdrawn = receiptToken.remove_liquidity_one_coin(\n            sharesToWithdraw,\n            int128(int256(inputTokenIndex)),\n            minAmountOut\n        );\n        weth.withdraw(amountWithdrawn);\n    }\n\n    function _transferAssetsToNewStrategy(\n        uint256 minAmountOut,\n        uint256 minimumSharesOut,\n        address newStrategy,\n        uint256 currentExecutionNonce,\n        bytes32 _crossChainTxId\n    ) internal override {\n        if (IStrategy(newStrategy).amanaVault() != amanaVault)\n            revert InvalidAmanaVault();\n        harvest();\n\n        rewardPool.withdrawAll(false);\n        uint256 withdrawnAmount = IERC20(rewardPool.stakingToken()).balanceOf(\n            address(this)\n        );\n        approveOrIncreaseAllowance(\n            IERC20(rewardPool.stakingToken()),\n            address(rewardPool),\n            withdrawnAmount\n        );\n        rewardPool.stakeFor(newStrategy, withdrawnAmount);\n        IStrategy(newStrategy).depositFromOldStrategy(\n            withdrawnAmount,\n            minimumSharesOut,\n            currentExecutionNonce,\n            _crossChainTxId\n        );\n        emit AssetsTransferredToNewStrategy(\n            newStrategy,\n            withdrawnAmount,\n            currentExecutionNonce,\n            _crossChainTxId\n        );\n    }\n\n    /**\n     * @dev Handles deposits from an old strategy into this strategy during a strategy switch.\n     *      This function ensures the deposit comes from the old strategy, updates the execution nonce, and invests the funds.\n     * @param currentExecutionNonce The current execution nonce from the old strategy.\n     * @param _crossChainTxId The cross-chain transaction ID associated with this deposit.\n     */\n    function depositFromOldStrategy(\n        uint256 amount,\n        uint256,\n        uint256 currentExecutionNonce,\n        bytes32 _crossChainTxId\n    ) external payable override {\n        if (oldStrategy == address(0)) revert OldStrategyNotSet();\n        if (msg.sender != oldStrategy) revert NotAuthorized();\n        executionNonce = currentExecutionNonce + 1;\n        _sendInvestConfirmation(\n            address(0),\n            amount,\n            totalUnderlyingAssets(),\n            currentExecutionNonce,\n            _crossChainTxId\n        );\n        emit AssetsReceivedFromOldStrategy(\n            oldStrategy,\n            amount,\n            currentExecutionNonce,\n            _crossChainTxId\n        );\n        oldStrategy = address(0);\n    }\n\n    function totalUnderlyingAssets() public view override returns (uint256) {\n        uint256 lpTokensStaked = rewardPool.balanceOf(address(this));\n        uint256 lpTokensHeld = receiptToken.balanceOf(address(this));\n        uint256 totalLPTokens = lpTokensHeld + lpTokensStaked;\n        return totalLPTokens == 0 ? 0 : convertToAssets(totalLPTokens);\n    }\n\n    function getStrategyWithdrawShareAmount(\n        uint256 fractionOfTotalShares\n    ) public view override returns (uint256) {\n        uint256 totalShares = rewardPool.balanceOf(address(this));\n        uint256 withdrawShareAmount = (fractionOfTotalShares *\n            totalShares +\n            5e17) / 1e18;\n        return\n            withdrawShareAmount > totalShares\n                ? totalShares\n                : withdrawShareAmount;\n    }\n\n    function convertToShares(\n        uint256 assetAmount\n    ) public view override returns (uint256) {\n        uint256[2] memory amounts;\n        amounts[inputTokenIndex] = assetAmount;\n        return receiptToken.calc_token_amount(amounts, false);\n    }\n\n    function convertToAssets(\n        uint256 shares\n    ) public view override returns (uint256) {\n        if (shares == 0) return 0;\n        return\n            receiptToken.calc_withdraw_one_coin(\n                shares,\n                int128(int256(inputTokenIndex))\n            );\n    }\n\n    function checkRewards() public view returns (uint256) {\n        return rewardPool.earned(address(this));\n    }\n}\n"}, "contracts/strategies/EthStrategyParent.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"./StrategyParent.sol\";\n\n/// @title EthStrategyParent\n/// @notice Base contract for cross-chain investment strategies.\n/// @dev Handles common logic for investing, divesting, and cross-chain messaging.\nabstract contract EthStrategyParent is StrategyParent {\n    using SafeERC20 for IERC20;\n\n    /// @notice Invests ETH into the Aave pool.\n    /// @param receiverAddress Address of the user whose funds are being invested.\n    /// @param amount Amount of ETH to invest.\n    /// @param _executionNonce Current execution nonce for the transaction.\n    /// @param _crossChainTxId Cross-chain transaction ID.\n    function _invest(\n        address receiverAddress,\n        uint256 amount,\n        uint256 minimumOut,\n        uint256 _executionNonce,\n        bytes32 _crossChainTxId\n    ) internal override {\n        if (msg.value == 0) revert NoFundsReceived();\n        _depositFundsIntoYieldSource(msg.value, minimumOut);\n\n        _sendInvestConfirmation(\n            receiverAddress,\n            amount,\n            totalUnderlyingAssets(),\n            _executionNonce,\n            _crossChainTxId\n        );\n\n        emit FundsInvested(_crossChainTxId, receiverAddress, amount);\n    }\n\n    /**\n     * @dev Sends a deposit and calls the `amanaVault` with the specified outgoing message and revert options.\n     * @param amount The amount of native tokens to send with the transaction.\n     * @param amanaVault The address of the vault to which the deposit and call are sent.\n     * @param outgoingMessage The payload to be passed to the `amanaVault`.\n     * @param revertOptions Options specifying how to handle transaction reverts.\n     */\n    function _sendDepositAndCall(\n        uint256 amount,\n        address amanaVault,\n        bytes memory outgoingMessage,\n        RevertOptions memory revertOptions\n    ) internal override {\n        IGatewayEVM(_GATEWAY_ADDRESS).depositAndCall{value: amount}(\n            amanaVault,\n            outgoingMessage,\n            revertOptions\n        );\n    }\n\n    /**\n     * @dev Handles deposits from an old strategy into this strategy during a strategy switch.\n     *      This function ensures the deposit comes from the old strategy, updates the execution nonce, and invests the funds.\n     * @param currentExecutionNonce The current execution nonce from the old strategy.\n     * @param _crossChainTxId The cross-chain transaction ID associated with this deposit.\n     */\n    function depositFromOldStrategy(\n        uint256,\n        uint256 minimumOut,\n        uint256 currentExecutionNonce,\n        bytes32 _crossChainTxId\n    ) external payable virtual {\n        if (oldStrategy == address(0)) revert OldStrategyNotSet();\n        if (msg.sender != oldStrategy) revert NotAuthorized();\n        if (msg.value == 0) revert NoFundsReceived();\n        executionNonce = currentExecutionNonce + 1;\n        _invest(\n            address(0),\n            msg.value,\n            minimumOut,\n            currentExecutionNonce,\n            _crossChainTxId\n        );\n        oldStrategy = address(0);\n    }\n\n    function emergencyWithdrawETH() external onlyOwner {\n        uint256 balance = address(this).balance;\n        if (balance == 0) {\n            revert NothingToWithdraw();\n        }\n        (bool success, ) = payable(owner()).call{value: balance}(\"\");\n        if (!success) {\n            revert IErrors.TransferFailed();\n        }\n    }\n\n    function emergencyWithdraw(address _token) external onlyOwner {\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n        if (balance == 0) {\n            revert NothingToWithdraw();\n        }\n        IERC20(_token).safeTransfer(owner(), balance);\n    }\n\n    /// @notice Allows the contract to receive ETH.\n    receive() external payable {}\n}\n"}, "contracts/strategies/StrategyParent.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport \"@zetachain/protocol-contracts/contracts/evm/interfaces/IGatewayEVM.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../interfaces/I4626Vault.sol\";\nimport \"../interfaces/IStrategy.sol\";\nimport \"../interfaces/IErrors.sol\";\nimport \"../interfaces/IDistributor.sol\";\n\n/// @title StrategyParent\n/// @notice Base contract for cross-chain investment strategies.\n/// @dev Handles common logic for investing, divesting, and cross-chain messaging.\nabstract contract StrategyParent is Ownable2Step, IErrors {\n    using SafeERC20 for IERC20;\n\n    address constant GATEWAY_ADDRESS =\n        0x48B9AACC350b20147001f88821d31731Ba4C30ed;\n\n    string public name;\n    address public amanaVault;\n    address public withdrawHelper;\n    uint256 public executionNonce = 1;\n    address public oldStrategy;\n    address public rewardsDistributor;\n\n    event FundsInvested(\n        bytes32 indexed crossChainTxId,\n        address user,\n        uint256 amount\n    );\n    event FundsDivested(\n        bytes32 indexed crossChainTxId,\n        address user,\n        uint256 amount\n    );\n    event InvestConfirmFailed(bytes32 indexed crossChainTxId);\n    event ReturnFundsFromStrategyFailed(bytes32 indexed crossChainTxId);\n    event TotalUnderlyingAssetsSent(\n        address indexed vaultAddress,\n        uint256 totalUnderlyingAssets,\n        uint256 blockNumber,\n        uint256 blockTimestamp\n    );\n    event SendTotalUnderlyingAssetsFailed();\n    event AssetsTransferredToNewStrategy(\n        address indexed newStrategy,\n        uint256 totalAssetsTransferrred,\n        uint256 executionNonce,\n        bytes32 crossChainTxId\n    );\n    event AssetsReceivedFromOldStrategy(\n        address indexed oldStrategy,\n        uint256 totalAssetsTransferrred,\n        uint256 executionNonce,\n        bytes32 crossChainTxId\n    );\n    event RewardsClaimed(\n        address indexed receiver,\n        address indexed rewardToken,\n        uint256 amount\n    );\n    event RewardsHarvested(\n        uint256 rewardsClaimed,\n        uint256 rewardsSwapped,\n        uint256 inputTokenReinvested\n    );\n    address immutable _GATEWAY_ADDRESS;\n\n    modifier onlyGateway() {\n        if (msg.sender != _GATEWAY_ADDRESS) {\n            revert OnlyGateway();\n        }\n        _;\n    }\n\n    constructor(\n        string memory _name,\n        address _amanaVault,\n        address _gateway,\n        address _withdrawHelper\n    ) Ownable(msg.sender) {\n        if (_amanaVault == address(0)) revert InvalidAddress();\n        name = _name;\n        amanaVault = _amanaVault;\n        _GATEWAY_ADDRESS = _gateway;\n        withdrawHelper = _withdrawHelper;\n    }\n\n    /// @notice Processes calls from the Gateway for deposits or withdrawals.\n    /// @param context The message context from the Gateway.\n    /// @param message Encoded data specifying the transaction details.\n    function onCall(\n        MessageContext calldata context,\n        bytes calldata message\n    ) external payable onlyGateway returns (bytes memory result) {\n        if (\n            context.sender != address(amanaVault) &&\n            context.sender != withdrawHelper\n        ) {\n            revert OnlyVault();\n        }\n        (\n            address user,\n            address receiver,\n            address ZRC20AddressOrNewStrategy,\n            address withdrawERC20,\n            uint256 amount,\n            uint256 fraction,\n            uint256 minimumOut,\n            uint32 withdrawChainId,\n            bool isDeposit,\n            bytes32 crossChainTxId,\n            uint16 slippage\n        ) = abi.decode(\n                message,\n                (\n                    address,\n                    address,\n                    address,\n                    address,\n                    uint256,\n                    uint256,\n                    uint256,\n                    uint32,\n                    bool,\n                    bytes32,\n                    uint16\n                )\n            );\n\n        uint256 currentExecutionNonce = executionNonce;\n        executionNonce++;\n\n        if (user == address(0) && receiver == address(0)) {\n            _transferAssetsToNewStrategy(\n                fraction,\n                minimumOut,\n                ZRC20AddressOrNewStrategy,\n                currentExecutionNonce,\n                crossChainTxId\n            );\n            return abi.encode(true);\n        } else if (isDeposit) {\n            _invest(\n                receiver,\n                amount,\n                minimumOut,\n                currentExecutionNonce,\n                crossChainTxId\n            );\n            return abi.encode(true);\n        } else {\n            _divest(\n                user,\n                receiver,\n                ZRC20AddressOrNewStrategy,\n                withdrawERC20,\n                amount,\n                fraction,\n                minimumOut,\n                withdrawChainId,\n                currentExecutionNonce,\n                crossChainTxId,\n                slippage\n            );\n            return abi.encode(true);\n        }\n    }\n\n    function updateWithdrawHelper(address _withdrawHelper) external onlyOwner {\n        if (_withdrawHelper == address(0)) revert InvalidAddress();\n        withdrawHelper = _withdrawHelper;\n    }\n\n    function updateVault(address _amanaVault) external onlyOwner {\n        if (_amanaVault == address(0)) revert InvalidAddress();\n        amanaVault = _amanaVault;\n    }\n\n    /**\n     * @dev Sets the address of the old strategy to enable migration of funds.\n     * @param _oldStrategy The address of the old strategy contract.\n     */\n    function setOldStrategy(address _oldStrategy) external onlyOwner {\n        if (_oldStrategy == address(0)) revert InvalidAddress();\n        if (_oldStrategy == address(this)) revert InvalidAddress();\n        oldStrategy = _oldStrategy;\n    }\n\n    function setExecutionNonce(uint256 _executionNonce) external onlyOwner {\n        executionNonce = _executionNonce;\n    }\n\n    /**\n     * @notice Sets the address of the Merkl rewards distributor contract.\n     * @param _rewardsDistributor The address of the rewards distributor contract.\n     */\n    function setRewardsDistributor(\n        address _rewardsDistributor\n    ) external onlyOwner {\n        rewardsDistributor = _rewardsDistributor;\n    }\n\n    /**\n     * @notice Whitelists an operator for rewards distribution.\n     * @param operator can whitelist a wallet that can claim merkl rewards on behalf of this strategy\n     */\n    function whitelistOperatorForRewards(address operator) external onlyOwner {\n        IDistributor(rewardsDistributor).toggleOperator(\n            address(this),\n            operator\n        );\n    }\n\n    /**\n     * @notice Returns the total underlying assets managed by the contract.\n     * @return The total amount of underlying assets in the contract.\n     */\n    function totalUnderlyingAssets() public view virtual returns (uint256);\n\n    function convertToShares(\n        uint256 assetAmount\n    ) public view virtual returns (uint256) {\n        return assetAmount;\n    }\n\n    function convertToAssets(\n        uint256 shares\n    ) public view virtual returns (uint256) {\n        return shares;\n    }\n\n    function getStrategyWithdrawShareAmount(\n        uint256 fractionOfTotalShares\n    ) public view virtual returns (uint256 withdrawShareAmount);\n\n    /// @notice Invests assets into the yield source\n    /// @param receiver Address of the receiver whose funds are being invested.\n    /// @param amount Amount of asset to invest.\n    /// @param _executionNonce Current execution nonce for the transaction.\n    /// @param _crossChainTxId Cross-chain transaction ID.\n    function _invest(\n        address receiver,\n        uint256 amount,\n        uint256 minimumOut,\n        uint256 _executionNonce,\n        bytes32 _crossChainTxId\n    ) internal virtual;\n\n    /**\n     * @notice Deposits funds into the configured yield source.\n     * @dev This function is intended to be overridden in derived contracts to define specific deposit logic.\n     * @param amount The amount of funds to deposit into the yield source.\n     */\n    function _depositFundsIntoYieldSource(\n        uint256 amount,\n        uint256 minimumOut\n    ) internal virtual;\n\n    /**\n     * @notice Allows the owner to manually resend an investment confirmation message.\n     * @param receiver The address of the receiver to whom the confirmation is sent.\n     * @param amount The amount of assets being invested.\n     * @param totalUnderlyingAssetsAfter The total underlying assets after the investment.\n     * @param _executionNonce The execution nonce associated with the investment.\n     * @param _crossChainTxId The cross-chain transaction ID.\n     */\n    function manualResendInvestConfirmation(\n        address receiver,\n        uint256 amount,\n        uint256 totalUnderlyingAssetsAfter,\n        uint256 _executionNonce,\n        bytes32 _crossChainTxId\n    ) external onlyOwner {\n        _sendInvestConfirmation(\n            receiver,\n            amount,\n            totalUnderlyingAssetsAfter,\n            _executionNonce,\n            _crossChainTxId\n        );\n    }\n\n    /**\n     * @dev Sends an investment confirmation message to the gateway.\n     * @param receiver The address of the receiver to whom the confirmation is sent.\n     * @param amount The amount of assets being invested.\n     * @param totalUnderlyingAssetsAfter The total underlying assets after the investment.\n     * @param _executionNonce The execution nonce associated with the investment.\n     * @param _crossChainTxId The cross-chain transaction ID.\n     *\n     * Notes:\n     * - This function encodes the investment details and sends them via the gateway contract.\n     * - Includes revert options in case of failure.\n     */\n    function _sendInvestConfirmation(\n        address receiver,\n        uint256 amount,\n        uint256 totalUnderlyingAssetsAfter,\n        uint256 _executionNonce,\n        bytes32 _crossChainTxId\n    ) internal {\n        bytes memory outgoingMessage = abi.encode(\n            address(0), // user\n            receiver,\n            address(this), // withdrawZRC20\n            address(0), // withdrawERC20\n            amount,\n            0, // fractionOfTotalShares\n            0, // withdrawChainId\n            true, // isDeposit\n            totalUnderlyingAssetsAfter,\n            _executionNonce,\n            _crossChainTxId,\n            0\n        );\n\n        RevertOptions memory revertOptions = RevertOptions(\n            address(this),\n            false,\n            address(this),\n            abi.encode(\n                \"_investConfirmFailed\",\n                _crossChainTxId,\n                _executionNonce,\n                amount,\n                receiver,\n                0 // vaultSharesToBeBurnt\n            ),\n            uint256(1000000)\n        );\n        IGatewayEVM(_GATEWAY_ADDRESS).call(\n            amanaVault,\n            outgoingMessage,\n            revertOptions\n        );\n    }\n\n    /**\n     * @notice Transfers assets from the current strategy to a new strategy during a strategy switch.\n     * @dev This function is intended to be overridden in derived contracts to define specific transfer logic.\n     * @param newStrategy The address of the new strategy contract.\n     * @param currentExecutionNonce The current execution nonce for the transaction.\n     * @param _crossChainTxId The cross-chain transaction ID.\n     */\n    function _transferAssetsToNewStrategy(\n        uint256 minimumAmountOut,\n        uint256 minimumSharesOut,\n        address newStrategy,\n        uint256 currentExecutionNonce,\n        bytes32 _crossChainTxId\n    ) internal virtual;\n\n    /// @notice Withdraws funds from the yield source.\n    /// @param user Address of the user whose funds are being withdrawn.\n    /// @param withdrawZRC20 ZRC20 token address for the withdrawal.\n    /// @param vaultSharesToBeBurnt amount of vault shares to be burnt.\n    /// @param fractionOfTotalShares Amount to withdraw.\n    /// @param withdrawChainId Chain ID for the withdrawal.\n    /// @param _executionNonce Current execution nonce for the transaction.\n    /// @param _crossChainTxId Cross-chain transaction ID.\n    function _divest(\n        address user,\n        address receiver,\n        address withdrawZRC20,\n        address withdrawERC20,\n        uint256 vaultSharesToBeBurnt,\n        uint256 fractionOfTotalShares,\n        uint256 minAmountOut,\n        uint32 withdrawChainId,\n        uint256 _executionNonce,\n        bytes32 _crossChainTxId,\n        uint16 slippage\n    ) internal virtual {\n        uint256 amountWithdrawn = _withdrawFundsFromYieldSource(\n            fractionOfTotalShares,\n            minAmountOut\n        );\n\n        uint256 totalUnderlyingAssetsAfter = totalUnderlyingAssets();\n\n        _sendFundsAndDivestConfirmation(\n            user,\n            receiver,\n            withdrawZRC20,\n            withdrawERC20,\n            amountWithdrawn,\n            vaultSharesToBeBurnt,\n            withdrawChainId,\n            totalUnderlyingAssetsAfter,\n            _executionNonce,\n            _crossChainTxId,\n            slippage\n        );\n\n        emit FundsDivested(_crossChainTxId, user, amountWithdrawn);\n    }\n\n    /**\n     * @notice Allows the owner to manually resend a funds and divest confirmation message.\n     * @dev Calls the internal `_sendFundsAndDivestConfirmation` function with the provided parameters.\n     * @param user The address of the user whose funds are being processed.\n     * @param receiver The address of the receiver of the funds.\n     * @param withdrawZRC20 The ZRC20 token address for withdrawal.\n     * @param amountWithdrawn The amount of funds to process.\n     * @param withdrawChainId The ID of the chain to which the funds are being withdrawn.\n     * @param totalUnderlyingAssetsAfter The total underlying assets after the divestment.\n     * @param _executionNonce The execution nonce associated with the transaction.\n     * @param _crossChainTxId The cross-chain transaction ID.\n     */\n    function manualResendFundsAndDivestConfirmation(\n        address user,\n        address receiver,\n        address withdrawZRC20,\n        address withdrawERC20,\n        uint256 amountWithdrawn,\n        uint256 vaultSharesToBeBurnt,\n        uint32 withdrawChainId,\n        uint256 totalUnderlyingAssetsAfter,\n        uint256 _executionNonce,\n        bytes32 _crossChainTxId,\n        uint16 slippage\n    ) external onlyOwner {\n        _sendFundsAndDivestConfirmation(\n            user,\n            receiver,\n            withdrawZRC20,\n            withdrawERC20,\n            amountWithdrawn,\n            vaultSharesToBeBurnt,\n            withdrawChainId,\n            totalUnderlyingAssetsAfter,\n            _executionNonce,\n            _crossChainTxId,\n            slippage\n        );\n    }\n\n    /**\n     * @dev Sends a funds and divest confirmation message to the Amana vault.\n     * @param user The address of the user whose funds are being processed.\n     * @param receiver The address of the receiver of the funds.\n     * @param withdrawZRC20 The ZRC20 token address for withdrawal.\n     * @param amountWithdrawn The amount of funds to process.\n     * @param withdrawChainId The ID of the chain to which the funds are being withdrawn.\n     * @param totalUnderlyingAssetsAfter The total underlying assets after the divestment.\n     * @param _executionNonce The execution nonce associated with the transaction.\n     * @param _crossChainTxId The cross-chain transaction ID.\n     *\n     * Notes:\n     * - Constructs the message payload for the funds and divestment confirmation.\n     * - Configures revert options in case of failure and sends the message using `_sendDepositAndCall`.\n     */\n    function _sendFundsAndDivestConfirmation(\n        address user,\n        address receiver,\n        address withdrawZRC20,\n        address withdrawERC20,\n        uint256 amountWithdrawn,\n        uint256 vaultSharesToBeBurnt,\n        uint32 withdrawChainId,\n        uint256 totalUnderlyingAssetsAfter,\n        uint256 _executionNonce,\n        bytes32 _crossChainTxId,\n        uint16 slippage\n    ) internal {\n        bytes memory outgoingMessage = abi.encode(\n            user,\n            receiver,\n            withdrawZRC20,\n            withdrawERC20,\n            amountWithdrawn,\n            vaultSharesToBeBurnt,\n            withdrawChainId,\n            false,\n            totalUnderlyingAssetsAfter,\n            _executionNonce,\n            _crossChainTxId,\n            slippage\n        );\n\n        RevertOptions memory revertOptions = RevertOptions(\n            address(this),\n            true,\n            address(this),\n            abi.encode(\n                \"_returnFundsFromStrategyFailed\",\n                _crossChainTxId,\n                _executionNonce,\n                amountWithdrawn,\n                user,\n                vaultSharesToBeBurnt\n            ),\n            uint256(1000000)\n        );\n        _sendDepositAndCall(\n            amountWithdrawn,\n            amanaVault,\n            outgoingMessage,\n            revertOptions\n        );\n    }\n\n    /**\n     * @dev Sends a deposit and calls the `amanaVault` with the specified outgoing message and revert options.\n     * @param amountWithdrawn The amount of native tokens to send with the transaction.\n     * @param amanaVault The address of the vault to which the deposit and call are sent.\n     * @param outgoingMessage The payload to be passed to the `amanaVault`.\n     * @param revertOptions Options specifying how to handle transaction reverts.\n     */\n    function _sendDepositAndCall(\n        uint256 amountWithdrawn,\n        address amanaVault,\n        bytes memory outgoingMessage,\n        RevertOptions memory revertOptions\n    ) internal virtual;\n\n    /**\n     * @notice Withdraws funds from the configured yield source.\n     * @dev This function is intended to be overridden in derived contracts to define specific withdrawal logic.\n     * @param fractionOfTotalShares The fraction of shares to withdraw from the yield source.\n     * @param minAmountOut The minimum amount of funds to withdraw.\n     * @return The amount of funds successfully withdrawn.\n     */\n    function _withdrawFundsFromYieldSource(\n        uint256 fractionOfTotalShares,\n        uint256 minAmountOut\n    ) internal virtual returns (uint256);\n\n    /**\n     * @notice Sends an update of total underlying assets managed by this contract to the configured vault.\n     * @dev Encodes the message payload and uses the GatewayEVM contract to send the message.\n     *\n     * Notes:\n     * - Configures revert options in case of failure.\n     * - Emits a `TotalUnderlyingAssetsSent` event upon successful execution.\n     */\n    function sendTotalUnderlyingAssetsToVault() external {\n        uint256 nonceToUse = executionNonce;\n        address user = address(0);\n        uint256 vaultSharesToBeBurnt = 0;\n        executionNonce++;\n        _sendUpdateToVault(user, vaultSharesToBeBurnt, nonceToUse);\n    }\n\n    function _sendUpdateToVault(\n        address user,\n        uint256 vaultSharesToBeBurnt,\n        uint256 nonceToUse\n    ) internal {\n        bytes memory outgoingMessage = abi.encode(\n            user,\n            address(0),\n            address(0),\n            address(0),\n            block.number,\n            vaultSharesToBeBurnt,\n            0,\n            false,\n            totalUnderlyingAssets(),\n            nonceToUse,\n            0,\n            0\n        );\n\n        RevertOptions memory revertOptions = RevertOptions(\n            address(this),\n            false,\n            address(this),\n            abi.encode(\n                \"_handleRevertOnSendTotalUnderlyingAssets\",\n                bytes32(0),\n                nonceToUse,\n                totalUnderlyingAssets(),\n                user,\n                vaultSharesToBeBurnt\n            ),\n            1_000_000\n        );\n\n        IGatewayEVM(_GATEWAY_ADDRESS).call(\n            amanaVault,\n            outgoingMessage,\n            revertOptions\n        );\n\n        emit TotalUnderlyingAssetsSent(\n            amanaVault,\n            totalUnderlyingAssets(),\n            block.number,\n            block.timestamp\n        );\n    }\n\n    /// @notice Safely approves an allowance for a spender.\n    function approveOrIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 currentAllowance = token.allowance(msg.sender, spender);\n\n        if (currentAllowance == 0) {\n            // First-time approval\n            token.approve(spender, amount);\n        } else {\n            // Handle USDT-like tokens by forcing reset to zero first\n            token.approve(spender, 0); // Reset to zero\n            token.approve(spender, amount); // Set new allowance\n        }\n    }\n\n    /// @notice Handles reverts from the Gateway.\n    /// @param context Context of the revert.\n    function onRevert(\n        RevertContext calldata context\n    ) external virtual onlyGateway {\n        (\n            string memory revertMessage,\n            bytes32 _crossChainTxId,\n            uint256 _executionNonce,\n            uint256 amount,\n            address userOrReceiver,\n            uint256 vaultSharesToBeBurnt\n        ) = abi.decode(\n                context.revertMessage,\n                (string, bytes32, uint256, uint256, address, uint256)\n            );\n\n        if (\n            keccak256(bytes(revertMessage)) ==\n            keccak256(bytes(\"_investConfirmFailed\"))\n        ) {\n            emit InvestConfirmFailed(_crossChainTxId);\n        } else if (\n            keccak256(bytes(revertMessage)) ==\n            keccak256(bytes(\"_returnFundsFromStrategyFailed\"))\n        ) {\n            _depositFundsIntoYieldSource(context.amount, 0);\n            _sendUpdateToVault(\n                userOrReceiver,\n                vaultSharesToBeBurnt,\n                _executionNonce\n            );\n            emit ReturnFundsFromStrategyFailed(_crossChainTxId);\n        } else if (\n            keccak256(bytes(revertMessage)) ==\n            keccak256(bytes(\"_handleRevertOnSendTotalUnderlyingAssets\"))\n        ) {\n            emit SendTotalUnderlyingAssetsFailed();\n        } else {\n            revert(\"Revert not handled\");\n        }\n    }\n}\n"}}, "settings": {"evmVersion": "paris", "optimizer": {"enabled": true}, "viaIR": false, "outputSelection": {"*": {"*": ["evm.legacyAssembly"]}}, "libraries": {}}}