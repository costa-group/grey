{"language": "Solidity", "sources": {"src/chains/Mainnet.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {SettlerBase} from \"../SettlerBase.sol\";\nimport {Settler} from \"../Settler.sol\";\nimport {SettlerMetaTxn} from \"../SettlerMetaTxn.sol\";\n\nimport {IERC20, IERC20Meta} from \"../IERC20.sol\";\nimport {IPSM, MakerPSM} from \"../core/MakerPSM.sol\";\nimport {CurveTricrypto} from \"../core/CurveTricrypto.sol\";\nimport {DodoV1} from \"../core/DodoV1.sol\";\nimport {FreeMemory} from \"../utils/FreeMemory.sol\";\n\nimport {ISettlerActions} from \"../ISettlerActions.sol\";\nimport {ISignatureTransfer} from \"permit2/src/interfaces/ISignatureTransfer.sol\";\nimport {UnknownForkId} from \"../core/SettlerErrors.sol\";\n\nimport {uniswapV3MainnetFactory, uniswapV3InitHash, IUniswapV3Callback} from \"../core/univ3forks/UniswapV3.sol\";\nimport {\n    pancakeSwapV3MainnetFactory,\n    pancakeSwapV3InitHash,\n    IPancakeSwapV3Callback\n} from \"../core/univ3forks/PancakeSwapV3.sol\";\nimport {solidlyV3Factory, solidlyV3InitHash, ISolidlyV3Callback} from \"../core/univ3forks/SolidlyV3.sol\";\n\n// Solidity inheritance is stupid\nimport {SettlerAbstract} from \"../SettlerAbstract.sol\";\nimport {AbstractContext} from \"../Context.sol\";\nimport {Permit2PaymentBase} from \"../core/Permit2Payment.sol\";\nimport {Permit2PaymentAbstract} from \"../core/Permit2PaymentAbstract.sol\";\n\nabstract contract MainnetMixin is FreeMemory, SettlerBase, MakerPSM, CurveTricrypto, DodoV1 {\n    constructor() {\n        assert(block.chainid == 1 || block.chainid == 31337);\n    }\n\n    function _dispatch(uint256 i, bytes4 action, bytes calldata data)\n        internal\n        virtual\n        override(SettlerAbstract, SettlerBase)\n        DANGEROUS_freeMemory\n        returns (bool)\n    {\n        if (super._dispatch(i, action, data)) {\n            return true;\n        } else if (action == ISettlerActions.MAKERPSM_SELL.selector) {\n            (address recipient, IERC20Meta gemToken, uint256 bps, IPSM psm) =\n                abi.decode(data, (address, IERC20Meta, uint256, IPSM));\n\n            makerPsmSellGem(recipient, gemToken, bps, psm);\n        } else if (action == ISettlerActions.MAKERPSM_BUY.selector) {\n            (address recipient, IERC20Meta gemToken, uint256 bps, IPSM psm) =\n                abi.decode(data, (address, IERC20Meta, uint256, IPSM));\n\n            makerPsmBuyGem(recipient, gemToken, bps, psm);\n        } else if (action == ISettlerActions.DODOV1.selector) {\n            (IERC20 sellToken, uint256 bps, address dodo, bool quoteForBase, uint256 minBuyAmount) =\n                abi.decode(data, (IERC20, uint256, address, bool, uint256));\n\n            sellToDodoV1(sellToken, bps, dodo, quoteForBase, minBuyAmount);\n        } else {\n            return false;\n        }\n        return true;\n    }\n\n    function _uniV3ForkInfo(uint8 forkId)\n        internal\n        pure\n        override\n        returns (address factory, bytes32 initHash, bytes4 callbackSelector)\n    {\n        if (forkId == 0) {\n            factory = uniswapV3MainnetFactory;\n            initHash = uniswapV3InitHash;\n            callbackSelector = IUniswapV3Callback.uniswapV3SwapCallback.selector;\n        } else if (forkId == 1) {\n            factory = pancakeSwapV3MainnetFactory;\n            initHash = pancakeSwapV3InitHash;\n            callbackSelector = IPancakeSwapV3Callback.pancakeV3SwapCallback.selector;\n        } else if (forkId == 2) {\n            factory = solidlyV3Factory;\n            initHash = solidlyV3InitHash;\n            callbackSelector = ISolidlyV3Callback.solidlyV3SwapCallback.selector;\n        } else {\n            revert UnknownForkId(forkId);\n        }\n    }\n}\n\n/// @custom:security-contact security@0x.org\ncontract MainnetSettler is Settler, MainnetMixin {\n    constructor(bytes20 gitCommit) SettlerBase(gitCommit) {}\n\n    function _dispatchVIP(bytes4 action, bytes calldata data) internal override DANGEROUS_freeMemory returns (bool) {\n        if (super._dispatchVIP(action, data)) {\n            return true;\n        } else if (action == ISettlerActions.CURVE_TRICRYPTO_VIP.selector) {\n            (\n                address recipient,\n                uint80 poolInfo,\n                ISignatureTransfer.PermitTransferFrom memory permit,\n                bytes memory sig,\n                uint256 minBuyAmount\n            ) = abi.decode(data, (address, uint80, ISignatureTransfer.PermitTransferFrom, bytes, uint256));\n\n            sellToCurveTricryptoVIP(recipient, poolInfo, permit, sig, minBuyAmount);\n        } else {\n            return false;\n        }\n        return true;\n    }\n\n    // Solidity inheritance is stupid\n    function _isRestrictedTarget(address target)\n        internal\n        pure\n        override(Settler, Permit2PaymentBase, Permit2PaymentAbstract)\n        returns (bool)\n    {\n        return super._isRestrictedTarget(target);\n    }\n\n    function _dispatch(uint256 i, bytes4 action, bytes calldata data)\n        internal\n        override(SettlerBase, MainnetMixin)\n        returns (bool)\n    {\n        return super._dispatch(i, action, data);\n    }\n\n    function _msgSender() internal view override(Settler, Permit2PaymentBase, AbstractContext) returns (address) {\n        return super._msgSender();\n    }\n}\n\n/// @custom:security-contact security@0x.org\ncontract MainnetSettlerMetaTxn is SettlerMetaTxn, MainnetMixin {\n    constructor(bytes20 gitCommit) SettlerBase(gitCommit) {}\n\n    function _dispatchVIP(bytes4 action, bytes calldata data, bytes calldata sig)\n        internal\n        override\n        DANGEROUS_freeMemory\n        returns (bool)\n    {\n        if (super._dispatchVIP(action, data, sig)) {\n            return true;\n        } else if (action == ISettlerActions.METATXN_CURVE_TRICRYPTO_VIP.selector) {\n            (\n                address recipient,\n                uint80 poolInfo,\n                ISignatureTransfer.PermitTransferFrom memory permit,\n                uint256 minBuyAmount\n            ) = abi.decode(data, (address, uint80, ISignatureTransfer.PermitTransferFrom, uint256));\n\n            sellToCurveTricryptoVIP(recipient, poolInfo, permit, sig, minBuyAmount);\n        } else {\n            return false;\n        }\n        return true;\n    }\n\n    // Solidity inheritance is stupid\n    function _dispatch(uint256 i, bytes4 action, bytes calldata data)\n        internal\n        override(SettlerBase, MainnetMixin)\n        returns (bool)\n    {\n        return super._dispatch(i, action, data);\n    }\n\n    function _msgSender()\n        internal\n        view\n        override(SettlerMetaTxn, Permit2PaymentBase, AbstractContext)\n        returns (address)\n    {\n        return super._msgSender();\n    }\n}\n"}, "src/SettlerBase.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IERC20, IERC20Meta} from \"./IERC20.sol\";\nimport {ISignatureTransfer} from \"permit2/src/interfaces/ISignatureTransfer.sol\";\n\nimport {Permit2Payment} from \"./core/Permit2Payment.sol\";\nimport {Basic} from \"./core/Basic.sol\";\nimport {RfqOrderSettlement} from \"./core/RfqOrderSettlement.sol\";\nimport {UniswapV3Fork} from \"./core/UniswapV3Fork.sol\";\nimport {UniswapV2} from \"./core/UniswapV2.sol\";\n\nimport {SafeTransferLib} from \"./vendor/SafeTransferLib.sol\";\n\nimport {ISettlerActions} from \"./ISettlerActions.sol\";\nimport {TooMuchSlippage} from \"./core/SettlerErrors.sol\";\n\n/// @dev This library omits index bounds/overflow checking when accessing calldata arrays for gas efficiency\nlibrary CalldataDecoder {\n    function decodeCall(bytes[] calldata data, uint256 i)\n        internal\n        pure\n        returns (bytes4 selector, bytes calldata args)\n    {\n        assembly (\"memory-safe\") {\n            // initially, we set `args.offset` to the pointer to the length. this is 32 bytes before the actual start of data\n            args.offset :=\n                add(\n                    data.offset,\n                    // We allow the indirection/offset to `calls[i]` to be negative\n                    calldataload(\n                        add(shl(5, i), data.offset) // can't overflow; we assume `i` is in-bounds\n                    )\n                )\n            // now we load `args.length` and set `args.offset` to the start of data\n            args.length := calldataload(args.offset)\n            args.offset := add(args.offset, 0x20)\n\n            // slice off the first 4 bytes of `args` as the selector\n            selector := calldataload(args.offset) // solidity cleans dirty bits automatically\n            args.length := sub(args.length, 4)\n            args.offset := add(args.offset, 4)\n        }\n    }\n}\n\nabstract contract SettlerBase is Permit2Payment, Basic, RfqOrderSettlement, UniswapV3Fork, UniswapV2 {\n    using SafeTransferLib for IERC20;\n    using SafeTransferLib for address payable;\n\n    receive() external payable {}\n\n    fallback(bytes calldata data) external returns (bytes memory) {\n        return _invokeCallback(data);\n    }\n\n    event GitCommit(bytes20 indexed);\n\n    // When you change this, you must make corresponding changes to\n    // `sh/deploy_new_chain.sh` and 'sh/common_deploy_settler.sh' to set\n    // `constructor_args`.\n    constructor(bytes20 gitCommit) {\n        assert((gitCommit == bytes20(0)) == (block.chainid == 31337));\n        emit GitCommit(gitCommit);\n    }\n\n    struct AllowedSlippage {\n        address recipient;\n        IERC20 buyToken;\n        uint256 minAmountOut;\n    }\n\n    function _checkSlippageAndTransfer(AllowedSlippage calldata slippage) internal {\n        // This final slippage check effectively prohibits custody optimization on the\n        // final hop of every swap. This is gas-inefficient. This is on purpose. Because\n        // ISettlerActions.BASIC could interact with an intents-based settlement\n        // mechanism, we must ensure that the user's want token increase is coming\n        // directly from us instead of from some other form of exchange of value.\n        (address recipient, IERC20 buyToken, uint256 minAmountOut) =\n            (slippage.recipient, slippage.buyToken, slippage.minAmountOut);\n        if (minAmountOut != 0 || address(buyToken) != address(0)) {\n            if (buyToken == ETH_ADDRESS) {\n                uint256 amountOut = address(this).balance;\n                if (amountOut < minAmountOut) {\n                    revert TooMuchSlippage(buyToken, minAmountOut, amountOut);\n                }\n                payable(recipient).safeTransferETH(amountOut);\n            } else {\n                uint256 amountOut = buyToken.balanceOf(address(this));\n                if (amountOut < minAmountOut) {\n                    revert TooMuchSlippage(buyToken, minAmountOut, amountOut);\n                }\n                buyToken.safeTransfer(recipient, amountOut);\n            }\n        }\n    }\n\n    function _dispatch(uint256, bytes4 action, bytes calldata data) internal virtual override returns (bool) {\n        if (action == ISettlerActions.TRANSFER_FROM.selector) {\n            (address recipient, ISignatureTransfer.PermitTransferFrom memory permit, bytes memory sig) =\n                abi.decode(data, (address, ISignatureTransfer.PermitTransferFrom, bytes));\n            (ISignatureTransfer.SignatureTransferDetails memory transferDetails,,) =\n                _permitToTransferDetails(permit, recipient);\n            _transferFrom(permit, transferDetails, sig);\n        } else if (action == ISettlerActions.RFQ.selector) {\n            (\n                address recipient,\n                ISignatureTransfer.PermitTransferFrom memory permit,\n                address maker,\n                bytes memory makerSig,\n                IERC20 takerToken,\n                uint256 maxTakerAmount\n            ) = abi.decode(data, (address, ISignatureTransfer.PermitTransferFrom, address, bytes, IERC20, uint256));\n\n            fillRfqOrderSelfFunded(recipient, permit, maker, makerSig, takerToken, maxTakerAmount);\n        } else if (action == ISettlerActions.UNISWAPV3.selector) {\n            (address recipient, uint256 bps, bytes memory path, uint256 amountOutMin) =\n                abi.decode(data, (address, uint256, bytes, uint256));\n\n            sellToUniswapV3(recipient, bps, path, amountOutMin);\n        } else if (action == ISettlerActions.UNISWAPV2.selector) {\n            (address recipient, address sellToken, uint256 bps, address pool, uint24 swapInfo, uint256 amountOutMin) =\n                abi.decode(data, (address, address, uint256, address, uint24, uint256));\n\n            sellToUniswapV2(recipient, sellToken, bps, pool, swapInfo, amountOutMin);\n        } else if (action == ISettlerActions.BASIC.selector) {\n            (IERC20 sellToken, uint256 bps, address pool, uint256 offset, bytes memory _data) =\n                abi.decode(data, (IERC20, uint256, address, uint256, bytes));\n\n            basicSellToPool(sellToken, bps, pool, offset, _data);\n        } else if (action == ISettlerActions.POSITIVE_SLIPPAGE.selector) {\n            (address recipient, IERC20 token, uint256 expectedAmount) = abi.decode(data, (address, IERC20, uint256));\n            if (token == IERC20(ETH_ADDRESS)) {\n                uint256 balance = address(this).balance;\n                if (balance > expectedAmount) {\n                    unchecked {\n                        payable(recipient).safeTransferETH(balance - expectedAmount);\n                    }\n                }\n            } else {\n                uint256 balance = token.balanceOf(address(this));\n                if (balance > expectedAmount) {\n                    unchecked {\n                        token.safeTransfer(recipient, balance - expectedAmount);\n                    }\n                }\n            }\n        } else {\n            return false;\n        }\n        return true;\n    }\n}\n"}, "src/Settler.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IERC20, IERC20Meta} from \"./IERC20.sol\";\nimport {ISignatureTransfer} from \"permit2/src/interfaces/ISignatureTransfer.sol\";\n\nimport {Permit2PaymentBase} from \"./core/Permit2Payment.sol\";\nimport {Permit2PaymentAbstract} from \"./core/Permit2PaymentAbstract.sol\";\n\nimport {AbstractContext} from \"./Context.sol\";\nimport {AllowanceHolderContext} from \"./allowanceholder/AllowanceHolderContext.sol\";\nimport {CalldataDecoder, SettlerBase} from \"./SettlerBase.sol\";\nimport {UnsafeMath} from \"./utils/UnsafeMath.sol\";\n\nimport {ISettlerActions} from \"./ISettlerActions.sol\";\nimport {ActionInvalid} from \"./core/SettlerErrors.sol\";\n\nabstract contract Settler is AllowanceHolderContext, SettlerBase {\n    using UnsafeMath for uint256;\n    using CalldataDecoder for bytes[];\n\n    function _hasMetaTxn() internal pure override returns (bool) {\n        return false;\n    }\n\n    function _isRestrictedTarget(address target)\n        internal\n        pure\n        virtual\n        override(Permit2PaymentAbstract, Permit2PaymentBase)\n        returns (bool)\n    {\n        return target == address(_ALLOWANCE_HOLDER) || super._isRestrictedTarget(target);\n    }\n\n    function _allowanceHolderTransferFrom(address token, address owner, address recipient, uint256 amount)\n        internal\n        override\n    {\n        // `owner` is always `_msgSender()` here, but we leave it to Permit2Payment.sol to enforce that\n        _ALLOWANCE_HOLDER.transferFrom(token, owner, recipient, amount);\n    }\n\n    function _operator() internal view override returns (address) {\n        return AllowanceHolderContext._msgSender();\n    }\n\n    function _msgSender()\n        internal\n        view\n        virtual\n        // Solidity inheritance is so stupid\n        override(Permit2PaymentBase, AllowanceHolderContext, AbstractContext)\n        returns (address)\n    {\n        return Permit2PaymentBase._msgSender();\n    }\n\n    function _dispatchVIP(bytes4 action, bytes calldata data) internal virtual returns (bool) {\n        if (action == ISettlerActions.RFQ_VIP.selector) {\n            (\n                address recipient,\n                ISignatureTransfer.PermitTransferFrom memory makerPermit,\n                address maker,\n                bytes memory makerSig,\n                ISignatureTransfer.PermitTransferFrom memory takerPermit,\n                bytes memory takerSig\n            ) = abi.decode(\n                data,\n                (\n                    address,\n                    ISignatureTransfer.PermitTransferFrom,\n                    address,\n                    bytes,\n                    ISignatureTransfer.PermitTransferFrom,\n                    bytes\n                )\n            );\n\n            fillRfqOrderVIP(recipient, makerPermit, maker, makerSig, takerPermit, takerSig);\n        } else if (action == ISettlerActions.UNISWAPV3_VIP.selector) {\n            (\n                address recipient,\n                bytes memory path,\n                ISignatureTransfer.PermitTransferFrom memory permit,\n                bytes memory sig,\n                uint256 amountOutMin\n            ) = abi.decode(data, (address, bytes, ISignatureTransfer.PermitTransferFrom, bytes, uint256));\n\n            sellToUniswapV3VIP(recipient, path, permit, sig, amountOutMin);\n        } else {\n            return false;\n        }\n        return true;\n    }\n\n    function execute(AllowedSlippage calldata slippage, bytes[] calldata actions)\n        public\n        payable\n        takerSubmitted\n        returns (bool)\n    {\n        for (uint256 i; i < actions.length; i = i.unsafeInc()) {\n            (bytes4 action, bytes calldata data) = actions.decodeCall(i);\n            if (!((i == 0 && _dispatchVIP(action, data)) || _dispatch(i, action, data))) {\n                revert ActionInvalid(i, action, data);\n            }\n        }\n\n        _checkSlippageAndTransfer(slippage);\n        return true;\n    }\n}\n"}, "src/SettlerMetaTxn.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IERC20, IERC20Meta} from \"./IERC20.sol\";\nimport {ISignatureTransfer} from \"permit2/src/interfaces/ISignatureTransfer.sol\";\n\nimport {Permit2PaymentBase} from \"./core/Permit2Payment.sol\";\n\nimport {Context, AbstractContext} from \"./Context.sol\";\nimport {CalldataDecoder, SettlerBase} from \"./SettlerBase.sol\";\nimport {UnsafeMath} from \"./utils/UnsafeMath.sol\";\n\nimport {ISettlerActions} from \"./ISettlerActions.sol\";\nimport {ConfusedDeputy, ActionInvalid} from \"./core/SettlerErrors.sol\";\n\nabstract contract SettlerMetaTxn is Context, SettlerBase {\n    using UnsafeMath for uint256;\n    using CalldataDecoder for bytes[];\n\n    function _hasMetaTxn() internal pure override returns (bool) {\n        return true;\n    }\n\n    function _allowanceHolderTransferFrom(address, address, address, uint256) internal pure override {\n        revert ConfusedDeputy();\n    }\n\n    function _operator() internal view override returns (address) {\n        return Context._msgSender();\n    }\n\n    // Solidity inheritance is so stupid\n    function _msgSender()\n        internal\n        view\n        virtual\n        override(Permit2PaymentBase, Context, AbstractContext)\n        returns (address)\n    {\n        return Permit2PaymentBase._msgSender();\n    }\n\n    function _hashArrayOfBytes(bytes[] calldata actions) internal pure returns (bytes32 result) {\n        // This function deliberately does no bounds checking on `actions` for\n        // gas efficiency. We assume that `actions` will get used elsewhere in\n        // this context and any OOB or other malformed calldata will result in a\n        // revert later.\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            let hashesLength := shl(5, actions.length)\n            for {\n                let i := actions.offset\n                let dst := ptr\n                let end := add(i, hashesLength)\n            } lt(i, end) {\n                i := add(i, 0x20)\n                dst := add(dst, 0x20)\n            } {\n                let src := add(actions.offset, calldataload(i))\n                let length := calldataload(src)\n                calldatacopy(dst, add(src, 0x20), length)\n                mstore(dst, keccak256(dst, length))\n            }\n            result := keccak256(ptr, hashesLength)\n        }\n    }\n\n    function _hashActionsAndSlippage(bytes[] calldata actions, AllowedSlippage calldata slippage)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        // This function does not check for or clean any dirty bits that might\n        // exist in `slippage`. We assume that `slippage` will be used elsewhere\n        // in this context and that if there are dirty bits it will result in a\n        // revert later.\n        bytes32 arrayOfBytesHash = _hashArrayOfBytes(actions);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(ptr, SLIPPAGE_AND_ACTIONS_TYPEHASH)\n            calldatacopy(add(ptr, 0x20), slippage, 0x60)\n            mstore(add(ptr, 0x80), arrayOfBytesHash)\n            result := keccak256(ptr, 0xa0)\n        }\n    }\n\n    function _dispatchVIP(bytes4 action, bytes calldata data, bytes calldata sig) internal virtual returns (bool) {\n        if (action == ISettlerActions.METATXN_RFQ_VIP.selector) {\n            // An optimized path involving a maker/taker in a single trade\n            // The RFQ order is signed by both maker and taker, validation is\n            // performed inside the RfqOrderSettlement so there is no need to\n            // validate `sig` against `actions` here\n            (\n                address recipient,\n                ISignatureTransfer.PermitTransferFrom memory makerPermit,\n                address maker,\n                bytes memory makerSig,\n                ISignatureTransfer.PermitTransferFrom memory takerPermit\n            ) = abi.decode(\n                data,\n                (address, ISignatureTransfer.PermitTransferFrom, address, bytes, ISignatureTransfer.PermitTransferFrom)\n            );\n\n            fillRfqOrderVIP(recipient, makerPermit, maker, makerSig, takerPermit, sig);\n        } else if (action == ISettlerActions.METATXN_TRANSFER_FROM.selector) {\n            (address recipient, ISignatureTransfer.PermitTransferFrom memory permit) =\n                abi.decode(data, (address, ISignatureTransfer.PermitTransferFrom));\n            (ISignatureTransfer.SignatureTransferDetails memory transferDetails,,) =\n                _permitToTransferDetails(permit, recipient);\n\n            // We simultaneously transfer-in the taker's tokens and authenticate the\n            // metatransaction.\n            _transferFrom(permit, transferDetails, sig);\n        } else if (action == ISettlerActions.METATXN_UNISWAPV3_VIP.selector) {\n            (\n                address recipient,\n                bytes memory path,\n                ISignatureTransfer.PermitTransferFrom memory permit,\n                uint256 amountOutMin\n            ) = abi.decode(data, (address, bytes, ISignatureTransfer.PermitTransferFrom, uint256));\n\n            sellToUniswapV3VIP(recipient, path, permit, sig, amountOutMin);\n        } else {\n            return false;\n        }\n        return true;\n    }\n\n    function executeMetaTxn(\n        AllowedSlippage calldata slippage,\n        bytes[] calldata actions,\n        address msgSender,\n        bytes calldata sig\n    ) public metaTx(msgSender, _hashActionsAndSlippage(actions, slippage)) returns (bool) {\n        require(actions.length != 0);\n        {\n            (bytes4 action, bytes calldata data) = actions.decodeCall(0);\n\n            // By forcing the first action to be one of the witness-aware\n            // actions, we ensure that the entire sequence of actions is\n            // authorized. `msgSender` is the signer of the metatransaction.\n            if (!_dispatchVIP(action, data, sig)) {\n                revert ActionInvalid(0, action, data);\n            }\n        }\n\n        for (uint256 i = 1; i < actions.length; i = i.unsafeInc()) {\n            (bytes4 action, bytes calldata data) = actions.decodeCall(i);\n            if (!_dispatch(i, action, data)) {\n                revert ActionInvalid(i, action, data);\n            }\n        }\n\n        _checkSlippageAndTransfer(slippage);\n        return true;\n    }\n}\n"}, "src/IERC20.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address) external view returns (uint256);\n    function transfer(address, uint256) external returns (bool);\n    function transferFrom(address, address, uint256) external returns (bool);\n    function approve(address, uint256) external returns (bool);\n    function allowance(address, address) external view returns (uint256);\n\n    event Transfer(address indexed, address indexed, uint256);\n    event Approval(address indexed, address indexed, uint256);\n}\n\ninterface IERC20Meta is IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n}\n"}, "src/core/MakerPSM.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IERC20, IERC20Meta} from \"../IERC20.sol\";\n\nimport {SafeTransferLib} from \"../vendor/SafeTransferLib.sol\";\nimport {UnsafeMath} from \"../utils/UnsafeMath.sol\";\n\ninterface IPSM {\n    /// @dev Get the fee for selling DAI to USDC in PSM\n    /// @return tout toll out [wad]\n    function tout() external view returns (uint256);\n\n    /// @dev Get the address of the underlying vault powering PSM\n    /// @return address of gemJoin contract\n    function gemJoin() external view returns (address);\n\n    /// @dev Sell USDC for DAI\n    /// @param usr The address of the account trading USDC for DAI.\n    /// @param gemAmt The amount of USDC to sell in USDC base units\n    function sellGem(address usr, uint256 gemAmt) external;\n\n    /// @dev Buy USDC for DAI\n    /// @param usr The address of the account trading DAI for USDC\n    /// @param gemAmt The amount of USDC to buy in USDC base units\n    function buyGem(address usr, uint256 gemAmt) external;\n}\n\nabstract contract MakerPSM {\n    using UnsafeMath for uint256;\n    using SafeTransferLib for IERC20;\n    using SafeTransferLib for IERC20Meta;\n\n    // Maker units https://github.com/makerdao/dss/blob/master/DEVELOPING.md\n    // wad: fixed point decimal with 18 decimals (for basic quantities, e.g. balances)\n    uint256 internal constant WAD = 10 ** 18;\n\n    IERC20 internal constant DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n\n    constructor() {\n        assert(block.chainid == 1 || block.chainid == 31337);\n    }\n\n    function makerPsmSellGem(address recipient, IERC20Meta gemToken, uint256 bps, IPSM psm) internal {\n        // phantom overflow can't happen here because PSM prohibits gemToken with decimals > 18\n        uint256 sellAmount = (gemToken.balanceOf(address(this)) * bps).unsafeDiv(10_000);\n        gemToken.safeApproveIfBelow(psm.gemJoin(), sellAmount);\n        psm.sellGem(recipient, sellAmount);\n    }\n\n    function makerPsmBuyGem(address recipient, IERC20Meta gemToken, uint256 bps, IPSM psm) internal {\n        // phantom overflow can't happen here because DAI has decimals = 18\n        uint256 sellAmount = (DAI.balanceOf(address(this)) * bps).unsafeDiv(10_000);\n        unchecked {\n            uint256 feeDivisor = psm.tout() + WAD; // eg. 1.001 * 10 ** 18 with 0.1% fee [tout is in wad];\n            // overflow can't happen at all because DAI is reasonable and PSM prohibits gemToken with decimals > 18\n            uint256 buyAmount = (sellAmount * 10 ** uint256(gemToken.decimals())).unsafeDiv(feeDivisor);\n\n            DAI.safeApproveIfBelow(address(psm), sellAmount);\n            psm.buyGem(recipient, buyAmount);\n        }\n    }\n}\n"}, "src/core/CurveTricrypto.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {ISignatureTransfer} from \"permit2/src/interfaces/ISignatureTransfer.sol\";\nimport {UnsafeMath} from \"../utils/UnsafeMath.sol\";\nimport {SafeTransferLib} from \"../vendor/SafeTransferLib.sol\";\nimport {Panic} from \"../utils/Panic.sol\";\nimport {AddressDerivation} from \"../utils/AddressDerivation.sol\";\n\nimport {SettlerAbstract} from \"../SettlerAbstract.sol\";\nimport {ConfusedDeputy} from \"./SettlerErrors.sol\";\n\ninterface ICurveTricrypto {\n    function exchange_extended(\n        uint256 sellIndex,\n        uint256 buyIndex,\n        uint256 sellAmount,\n        uint256 minBuyAmount,\n        bool useEth,\n        address payer,\n        address receiver,\n        bytes32 callbackSelector\n    ) external returns (uint256 buyAmount);\n}\n\ninterface ICurveTricryptoCallback {\n    // The function name/selector is arbitrary, but the arguments are controlled by the pool\n    function curveTricryptoSwapCallback(\n        address payer,\n        address receiver,\n        IERC20 sellToken,\n        uint256 sellAmount,\n        uint256 buyAmount\n    ) external;\n}\n\nabstract contract CurveTricrypto is SettlerAbstract {\n    using UnsafeMath for uint256;\n    using SafeTransferLib for IERC20;\n    using AddressDerivation for address;\n\n    address private constant curveFactory = 0x0c0e5f2fF0ff18a3be9b835635039256dC4B4963;\n    // uint256 private constant codePrefixLen = 0x539d;\n    // bytes32 private constant codePrefixHash = 0xec96085e693058e09a27755c07882ced27117a3161b1fdaf131a14c7db9978b7;\n\n    function sellToCurveTricryptoVIP(\n        address recipient,\n        uint80 poolInfo,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        bytes memory sig,\n        uint256 minBuyAmount\n    ) internal {\n        uint64 factoryNonce = uint64(poolInfo >> 16);\n        uint8 sellIndex = uint8(poolInfo >> 8);\n        uint8 buyIndex = uint8(poolInfo);\n        address pool = curveFactory.deriveContract(factoryNonce);\n        /*\n        bytes32 codePrefixHashActual;\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            extcodecopy(pool, ptr, 0x00, codePrefixLen)\n            codePrefixHashActual := keccak256(ptr, codePrefixLen)\n        }\n        if (codePrefixHashActual != codePrefixHash) {\n            revert ConfusedDeputy();\n        }\n        */\n        bool isForwarded = _isForwarded();\n        assembly (\"memory-safe\") {\n            tstore(0x00, isForwarded)\n            tstore(0x01, mload(add(0x20, permit))) // nonce\n            tstore(0x02, mload(add(0x40, permit))) // deadline\n            for {\n                let src := add(0x20, sig)\n                let end\n                {\n                    let len := mload(sig)\n                    end := add(len, src)\n                    tstore(0x03, len)\n                }\n                let dst := 0x04\n            } lt(src, end) {\n                src := add(0x20, src)\n                dst := add(0x01, dst)\n            } { tstore(dst, mload(src)) }\n        }\n        _setOperatorAndCall(\n            pool,\n            abi.encodeCall(\n                ICurveTricrypto.exchange_extended,\n                (\n                    sellIndex,\n                    buyIndex,\n                    permit.permitted.amount,\n                    minBuyAmount,\n                    false,\n                    address(0), // payer\n                    recipient,\n                    bytes32(ICurveTricryptoCallback.curveTricryptoSwapCallback.selector)\n                )\n            ),\n            uint32(ICurveTricryptoCallback.curveTricryptoSwapCallback.selector),\n            _curveTricryptoSwapCallback\n        );\n    }\n\n    function _curveTricryptoSwapCallback(bytes calldata data) private returns (bytes memory) {\n        require(data.length == 0xa0);\n        address payer;\n        IERC20 sellToken;\n        uint256 sellAmount;\n        assembly (\"memory-safe\") {\n            payer := calldataload(data.offset)\n            let err := shr(0xa0, payer)\n            sellToken := calldataload(add(0x40, data.offset))\n            err := or(shr(0xa0, sellToken), err)\n            sellAmount := calldataload(add(0x60, data.offset))\n            if err { revert(0x00, 0x00) }\n        }\n        curveTricryptoSwapCallback(payer, address(0), sellToken, sellAmount, 0);\n        return new bytes(0);\n    }\n\n    function curveTricryptoSwapCallback(address payer, address, IERC20 sellToken, uint256 sellAmount, uint256)\n        private\n    {\n        assert(payer == address(0));\n        bool isForwarded;\n        uint256 nonce;\n        uint256 deadline;\n        bytes memory sig;\n        assembly (\"memory-safe\") {\n            isForwarded := tload(0x00)\n            tstore(0x00, 0x00)\n            nonce := tload(0x01)\n            tstore(0x01, 0x00)\n            deadline := tload(0x02)\n            tstore(0x02, 0x00)\n            sig := mload(0x40)\n            for {\n                let dst := add(0x20, sig)\n                let end\n                {\n                    let len := tload(0x03)\n                    end := add(dst, len)\n                    mstore(sig, len)\n                    mstore(0x40, end)\n                }\n                let src := 0x04\n            } lt(dst, end) {\n                src := add(0x01, src)\n                dst := add(0x20, dst)\n            } {\n                mstore(dst, tload(src))\n                tstore(src, 0x00)\n            }\n        }\n        ISignatureTransfer.PermitTransferFrom memory permit = ISignatureTransfer.PermitTransferFrom({\n            permitted: ISignatureTransfer.TokenPermissions({token: address(sellToken), amount: sellAmount}),\n            nonce: nonce,\n            deadline: deadline\n        });\n        (ISignatureTransfer.SignatureTransferDetails memory transferDetails,,) =\n            _permitToTransferDetails(permit, msg.sender);\n        _transferFrom(permit, transferDetails, sig, isForwarded);\n    }\n}\n"}, "src/core/DodoV1.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {SettlerAbstract} from \"../SettlerAbstract.sol\";\nimport {TooMuchSlippage} from \"./SettlerErrors.sol\";\nimport {FullMath} from \"../vendor/FullMath.sol\";\nimport {SafeTransferLib} from \"../vendor/SafeTransferLib.sol\";\n\n// see below for explanation\n/*\nimport {ISignatureTransfer} from \"permit2/src/interfaces/ISignatureTransfer.sol\";\nimport {AddressDerivation} from \"../utils/AddressDerivation.sol\";\nimport {ConfusedDeputy} from from \"./SettlerErrors.sol\";\n*/\n\ninterface IDodo {\n    function init(\n        address owner,\n        address supervisor,\n        address maintainer,\n        address baseToken,\n        address quoteToken,\n        address oracle,\n        uint256 lpFeeRate,\n        uint256 mtFeeRate,\n        uint256 k,\n        uint256 gasPriceLimit\n    ) external;\n\n    function transferOwnership(address newOwner) external;\n\n    function claimOwnership() external;\n\n    function sellBaseToken(uint256 amount, uint256 minReceiveQuote, bytes calldata data) external returns (uint256);\n\n    function buyBaseToken(uint256 amount, uint256 maxPayQuote, bytes calldata data) external returns (uint256);\n\n    function querySellBaseToken(uint256 amount) external view returns (uint256 receiveQuote);\n\n    function queryBuyBaseToken(uint256 amount) external view returns (uint256 payQuote);\n\n    function depositBaseTo(address to, uint256 amount) external returns (uint256);\n\n    function withdrawBase(uint256 amount) external returns (uint256);\n\n    function withdrawAllBase() external returns (uint256);\n\n    function depositQuoteTo(address to, uint256 amount) external returns (uint256);\n\n    function withdrawQuote(uint256 amount) external returns (uint256);\n\n    function withdrawAllQuote() external returns (uint256);\n\n    function _BASE_CAPITAL_TOKEN_() external returns (address);\n\n    function _QUOTE_CAPITAL_TOKEN_() external returns (address);\n\n    function _BASE_TOKEN_() external returns (address);\n\n    function _QUOTE_TOKEN_() external returns (address);\n\n    function _R_STATUS_() external view returns (uint8);\n\n    function _QUOTE_BALANCE_() external view returns (uint256);\n\n    function _BASE_BALANCE_() external view returns (uint256);\n\n    function _K_() external view returns (uint256);\n\n    function _MT_FEE_RATE_() external view returns (uint256);\n\n    function _LP_FEE_RATE_() external view returns (uint256);\n\n    function getExpectedTarget() external view returns (uint256 baseTarget, uint256 quoteTarget);\n\n    function getOraclePrice() external view returns (uint256);\n}\n\nlibrary Math {\n    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 quotient = a / b;\n        unchecked {\n            uint256 remainder = a - quotient * b;\n            if (remainder > 0) {\n                return quotient + 1;\n            } else {\n                return quotient;\n            }\n        }\n    }\n\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\n        unchecked {\n            uint256 z = x / 2 + 1;\n            y = x;\n            while (z < y) {\n                y = z;\n                z = (x / z + z) / 2;\n            }\n        }\n    }\n}\n\nlibrary DecimalMath {\n    using Math for uint256;\n\n    uint256 constant ONE = 10 ** 18;\n\n    function mul(uint256 target, uint256 d) internal pure returns (uint256) {\n        return target * d / ONE;\n    }\n\n    function mulCeil(uint256 target, uint256 d) internal pure returns (uint256) {\n        return (target * d).divCeil(ONE);\n    }\n\n    function divFloor(uint256 target, uint256 d) internal pure returns (uint256) {\n        return target * ONE / d;\n    }\n\n    function divCeil(uint256 target, uint256 d) internal pure returns (uint256) {\n        return (target * ONE).divCeil(d);\n    }\n}\n\nlibrary DodoMath {\n    using Math for uint256;\n\n    /*\n        Integrate dodo curve fron V1 to V2\n        require V0>=V1>=V2>0\n        res = (1-k)i(V1-V2)+ikV0*V0(1/V2-1/V1)\n        let V1-V2=delta\n        res = i*delta*(1-k+k(V0^2/V1/V2))\n    */\n    function _GeneralIntegrate(uint256 V0, uint256 V1, uint256 V2, uint256 i, uint256 k)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 fairAmount = DecimalMath.mul(i, V1 - V2); // i*delta\n        uint256 V0V0V1V2 = DecimalMath.divCeil(V0 * V0 / V1, V2);\n        uint256 penalty = DecimalMath.mul(k, V0V0V1V2); // k(V0^2/V1/V2)\n        return DecimalMath.mul(fairAmount, DecimalMath.ONE - k + penalty);\n    }\n\n    /*\n        The same with integration expression above, we have:\n        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\n        Given Q1 and deltaB, solve Q2\n        This is a quadratic function and the standard version is\n        aQ2^2 + bQ2 + c = 0, where\n        a=1-k\n        -b=(1-k)Q1-kQ0^2/Q1+i*deltaB\n        c=-kQ0^2\n        and Q2=(-b+sqrt(b^2+4(1-k)kQ0^2))/2(1-k)\n        note: another root is negative, abondan\n        if deltaBSig=true, then Q2>Q1\n        if deltaBSig=false, then Q2<Q1\n    */\n    function _SolveQuadraticFunctionForTrade(uint256 Q0, uint256 Q1, uint256 ideltaB, bool deltaBSig, uint256 k)\n        internal\n        pure\n        returns (uint256)\n    {\n        // calculate -b value and sig\n        // -b = (1-k)Q1-kQ0^2/Q1+i*deltaB\n        uint256 kQ02Q1 = DecimalMath.mul(k, Q0) * Q0 / Q1; // kQ0^2/Q1\n        uint256 b = DecimalMath.mul(DecimalMath.ONE - k, Q1); // (1-k)Q1\n        bool minusbSig = true;\n        if (deltaBSig) {\n            b += ideltaB; // (1-k)Q1+i*deltaB\n        } else {\n            kQ02Q1 += ideltaB; // i*deltaB+kQ0^2/Q1\n        }\n        if (b >= kQ02Q1) {\n            b -= kQ02Q1;\n            minusbSig = true;\n        } else {\n            b = kQ02Q1 - b;\n            minusbSig = false;\n        }\n\n        // calculate sqrt\n        uint256 squareRoot = DecimalMath.mul((DecimalMath.ONE - k) * 4, DecimalMath.mul(k, Q0) * Q0); // 4(1-k)kQ0^2\n        squareRoot = (b * b + squareRoot).sqrt(); // sqrt(b*b+4(1-k)kQ0*Q0)\n\n        // final res\n        uint256 denominator = (DecimalMath.ONE - k) * 2; // 2(1-k)\n        uint256 numerator;\n        if (minusbSig) {\n            numerator = b + squareRoot;\n        } else {\n            numerator = squareRoot - b;\n        }\n\n        if (deltaBSig) {\n            return DecimalMath.divFloor(numerator, denominator);\n        } else {\n            return DecimalMath.divCeil(numerator, denominator);\n        }\n    }\n\n    /*\n        Start from the integration function\n        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\n        Assume Q2=Q0, Given Q1 and deltaB, solve Q0\n        let fairAmount = i*deltaB\n    */\n    function _SolveQuadraticFunctionForTarget(uint256 V1, uint256 k, uint256 fairAmount)\n        internal\n        pure\n        returns (uint256 V0)\n    {\n        // V0 = V1+V1*(sqrt-1)/2k\n        uint256 sqrt = DecimalMath.divCeil(DecimalMath.mul(k, fairAmount) * 4, V1);\n        sqrt = ((sqrt + DecimalMath.ONE) * DecimalMath.ONE).sqrt();\n        uint256 premium = DecimalMath.divCeil(sqrt - DecimalMath.ONE, k * 2);\n        // V0 is greater than or equal to V1 according to the solution\n        return DecimalMath.mul(V1, DecimalMath.ONE + premium);\n    }\n}\n\nabstract contract DodoSellHelper {\n    using Math for uint256;\n\n    enum RStatus {\n        ONE,\n        ABOVE_ONE,\n        BELOW_ONE\n    }\n\n    struct DodoState {\n        uint256 oraclePrice;\n        uint256 K;\n        uint256 B;\n        uint256 Q;\n        uint256 baseTarget;\n        uint256 quoteTarget;\n        RStatus rStatus;\n    }\n\n    function dodoQuerySellQuoteToken(IDodo dodo, uint256 amount) internal view returns (uint256) {\n        DodoState memory state;\n        (state.baseTarget, state.quoteTarget) = dodo.getExpectedTarget();\n        state.rStatus = RStatus(dodo._R_STATUS_());\n        state.oraclePrice = dodo.getOraclePrice();\n        state.Q = dodo._QUOTE_BALANCE_();\n        state.B = dodo._BASE_BALANCE_();\n        state.K = dodo._K_();\n\n        uint256 boughtAmount;\n        // Determine the status (RStatus) and calculate the amount based on the\n        // state\n        if (state.rStatus == RStatus.ONE) {\n            boughtAmount = _ROneSellQuoteToken(amount, state);\n        } else if (state.rStatus == RStatus.ABOVE_ONE) {\n            boughtAmount = _RAboveSellQuoteToken(amount, state);\n        } else {\n            uint256 backOneBase = state.B - state.baseTarget;\n            uint256 backOneQuote = state.quoteTarget - state.Q;\n            if (amount <= backOneQuote) {\n                boughtAmount = _RBelowSellQuoteToken(amount, state);\n            } else {\n                boughtAmount = backOneBase + _ROneSellQuoteToken(amount - backOneQuote, state);\n            }\n        }\n        // Calculate fees\n        return DecimalMath.divFloor(boughtAmount, DecimalMath.ONE + dodo._MT_FEE_RATE_() + dodo._LP_FEE_RATE_());\n    }\n\n    function _ROneSellQuoteToken(uint256 amount, DodoState memory state)\n        private\n        pure\n        returns (uint256 receiveBaseToken)\n    {\n        uint256 i = DecimalMath.divFloor(DecimalMath.ONE, state.oraclePrice);\n        uint256 B2 = DodoMath._SolveQuadraticFunctionForTrade(\n            state.baseTarget, state.baseTarget, DecimalMath.mul(i, amount), false, state.K\n        );\n        return state.baseTarget - B2;\n    }\n\n    function _RAboveSellQuoteToken(uint256 amount, DodoState memory state)\n        private\n        pure\n        returns (uint256 receieBaseToken)\n    {\n        uint256 i = DecimalMath.divFloor(DecimalMath.ONE, state.oraclePrice);\n        uint256 B2 = DodoMath._SolveQuadraticFunctionForTrade(\n            state.baseTarget, state.B, DecimalMath.mul(i, amount), false, state.K\n        );\n        return state.B - B2;\n    }\n\n    function _RBelowSellQuoteToken(uint256 amount, DodoState memory state)\n        private\n        pure\n        returns (uint256 receiveBaseToken)\n    {\n        uint256 Q1 = state.Q + amount;\n        uint256 i = DecimalMath.divFloor(DecimalMath.ONE, state.oraclePrice);\n        return DodoMath._GeneralIntegrate(state.quoteTarget, Q1, state.Q, i, state.K);\n    }\n}\n\n// see below for explanation\n/*\ninterface IDodoCallee {\n    function dodoCall(bool isBuyBaseToken, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external;\n}\n*/\n\nabstract contract DodoV1 is SettlerAbstract, DodoSellHelper {\n    using FullMath for uint256;\n    using SafeTransferLib for IERC20;\n\n    function sellToDodoV1(IERC20 sellToken, uint256 bps, address dodo, bool quoteForBase, uint256 minBuyAmount)\n        internal\n    {\n        uint256 sellAmount = sellToken.balanceOf(address(this)).mulDiv(bps, 10_000);\n        sellToken.safeApproveIfBelow(dodo, sellAmount);\n        if (quoteForBase) {\n            uint256 buyAmount = dodoQuerySellQuoteToken(IDodo(dodo), sellAmount);\n            if (buyAmount < minBuyAmount) {\n                revert TooMuchSlippage(sellToken, minBuyAmount, buyAmount);\n            }\n            IDodo(dodo).buyBaseToken(buyAmount, sellAmount, new bytes(0));\n        } else {\n            IDodo(dodo).sellBaseToken(sellAmount, minBuyAmount, new bytes(0));\n        }\n    }\n\n    // In spite of the fact that DodoV1 pools have a callback function as\n    // specified in `IDodoCallee` above, they don't actually support flash\n    // swaps. The approve/transferFrom flow is completely mandatory. Therefore,\n    // it is not possible to custody optimize using a VIP that spends the\n    // taker's coupon as part of the callback. This code is maintained here as\n    // an example of a way to obtain a trusted callback.\n    /*\n    using AddressDerivation for address;\n\n    address private constant dodoDeployer = 0x5E5a7b76462E4BdF83Aa98795644281BdbA80B88;\n    address private constant dodoPrototype = 0xF6A8E47daEEdDcCe297e7541523e27DF2f167BF3;\n    // this is the ERC1167 runtime code\n    bytes32 private constant dodoCodehash =\n        keccak256(abi.encodePacked(hex\"363d3d373d3d3d363d73\", dodoPrototype, hex\"5af43d82803e903d91602b57fd5bf3\"));\n\n    constructor() {\n        assert(block.chainid == 1 || block.chainid == 31337);\n    }\n\n    function _dodoV1Callback(bytes calldata data) private returns (bytes memory) {\n        require(data.length >= 0xa0);\n        bool isBuyBaseToken;\n        uint256 baseAmount;\n        uint256 quoteAmount;\n        assembly (\"memory-safe\") {\n            isBuyBaseToken := calldataload(data.offset)\n            if shr(0x01, isBuyBaseToken) { revert(0x00, 0x00) }\n            baseAmount := calldataload(add(0x20, data.offset))\n            quoteAmount := calldataload(add(0x40, data.offset))\n            data.offset := add(data.offset, calldataload(add(0x60, data.offset)))\n            data.length := calldataload(data.offset)\n            data.offset := add(0x20, data.offset)\n        }\n        dodoCall(isBuyBaseToken, baseAmount, quoteAmount, data);\n        return new bytes(0);\n    }\n\n    function dodoCall(bool quoteForBase, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) private {\n        (ISignatureTransfer.PermitTransferFrom memory permit, bytes memory sig, bool isForwarded) =\n            abi.decode(data, (ISignatureTransfer.PermitTransferFrom, bytes, bool));\n        _transferFrom(\n            permit,\n            ISignatureTransfer.SignatureTransferDetails({\n                to: msg.sender,\n                requestedAmount: quoteForBase ? quoteAmount : baseAmount\n            }),\n            sig,\n            isForwarded\n        );\n    }\n\n    function sellToDodoV1VIP(\n        uint64 deployerNonce,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        bytes memory sig,\n        bool quoteForBase,\n        uint256 minBuyAmount\n    ) internal {\n        // deriving the contract address from the factory nonce verifies the initcode conforms to ERC1167\n        address dodo = dodoDeployer.deriveContract(deployerNonce);\n        // checking the codehash against the one computed from the prototype verifies the implementation\n        if (dodo.codehash != dodoCodehash) {\n            revert ConfusedDeputy();\n        }\n        // now we know that we can trust `dodo`\n\n        uint256 sellAmount = permit.permitted.amount;\n        bytes memory callbackData = abi.encode(permit, sig, _isForwarded());\n        if (quoteForBase) {\n            uint256 buyAmount = dodoQuerySellQuoteToken(IDodo(dodo), sellAmount);\n            if (buyAmount < minBuyAmount) {\n                revert TooMuchSlippage(permit.permitted.token, minBuyAmount, buyAmount);\n            }\n            callbackData = abi.encodeCall(IDodo.buyBaseToken, (buyAmount, sellAmount, callbackData));\n        } else {\n            callbackData = abi.encodeCall(IDodo.sellBaseToken, (sellAmount, minBuyAmount, callbackData));\n        }\n        _setOperatorAndCall(dodo, callbackData, uint32(IDodoCallee.dodoCall.selector), _dodoV1Callback);\n    }\n    */\n}\n"}, "src/utils/FreeMemory.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nabstract contract FreeMemory {\n    modifier DANGEROUS_freeMemory() {\n        uint256 freeMemPtr;\n        assembly (\"memory-safe\") {\n            freeMemPtr := mload(0x40)\n        }\n        _;\n        assembly (\"memory-safe\") {\n            mstore(0x40, freeMemPtr)\n        }\n    }\n}\n"}, "src/ISettlerActions.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {ISignatureTransfer} from \"permit2/src/interfaces/ISignatureTransfer.sol\";\n\ninterface ISettlerActions {\n    /// @dev Transfer funds from msg.sender Permit2.\n    function TRANSFER_FROM(address recipient, ISignatureTransfer.PermitTransferFrom memory permit, bytes memory sig)\n        external;\n\n    /// @dev Transfer funds from metatransaction requestor into the Settler contract using Permit2. Only for use in `Settler.executeMetaTxn` where the signature is provided as calldata\n    function METATXN_TRANSFER_FROM(address recipient, ISignatureTransfer.PermitTransferFrom memory permit) external;\n\n    /// @dev Settle an RfqOrder between maker and taker transfering funds directly between the parties\n    // Post-req: Payout if recipient != taker\n    function RFQ_VIP(\n        address recipient,\n        ISignatureTransfer.PermitTransferFrom memory makerPermit,\n        address maker,\n        bytes memory makerSig,\n        ISignatureTransfer.PermitTransferFrom memory takerPermit,\n        bytes memory takerSig\n    ) external;\n\n    /// @dev Settle an RfqOrder between maker and taker transfering funds directly between the parties for the entire amount\n    function METATXN_RFQ_VIP(\n        address recipient,\n        ISignatureTransfer.PermitTransferFrom memory makerPermit,\n        address maker,\n        bytes memory makerSig,\n        ISignatureTransfer.PermitTransferFrom memory takerPermit\n    ) external;\n\n    /// @dev Settle an RfqOrder between Maker and Settler. Transfering funds from the Settler contract to maker.\n    /// Retaining funds in the settler contract.\n    // Pre-req: Funded\n    // Post-req: Payout\n    function RFQ(\n        address recipient,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        address maker,\n        bytes memory makerSig,\n        address takerToken,\n        uint256 maxTakerAmount\n    ) external;\n\n    /// @dev Trades against UniswapV3 using the contracts balance for funding\n    // Pre-req: Funded\n    // Post-req: Payout\n    function UNISWAPV3(address recipient, uint256 bps, bytes memory path, uint256 amountOutMin) external;\n\n    /// @dev Trades against UniswapV3 using user funds via Permit2 for funding\n    function UNISWAPV3_VIP(\n        address recipient,\n        bytes memory path,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        bytes memory sig,\n        uint256 amountOutMin\n    ) external;\n\n    function MAKERPSM_SELL(address recipient, address gemToken, uint256 bps, address psm) external;\n    function MAKERPSM_BUY(address recipient, address gemToken, uint256 bps, address psm) external;\n\n    function CURVE_TRICRYPTO_VIP(\n        address recipient,\n        uint80 poolInfo,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        bytes memory sig,\n        uint256 minBuyAmount\n    ) external;\n    function METATXN_CURVE_TRICRYPTO_VIP(\n        address recipient,\n        uint80 poolInfo,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        uint256 minBuyAmount\n    ) external;\n\n    function DODOV1(address sellToken, uint256 bps, address pool, bool quoteForBase, uint256 minBuyAmount) external;\n\n    /// @dev Trades against UniswapV3 using user funds via Permit2 for funding. Metatransaction variant. Signature is over all actions.\n    function METATXN_UNISWAPV3_VIP(\n        address recipient,\n        bytes memory path,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        uint256 amountOutMin\n    ) external;\n\n    /// @dev Trades against UniswapV2 using the contracts balance for funding\n    /// @param swapInfo is encoded as the upper 16 bits as the fee of the pool in bps, the second\n    ///                 lowest bit as \"sell token has transfer fee\", and the lowest bit as the\n    ///                 \"token0 for token1\" flag.\n    function UNISWAPV2(\n        address recipient,\n        address sellToken,\n        uint256 bps,\n        address pool,\n        uint24 swapInfo,\n        uint256 amountOutMin\n    ) external;\n\n    function POSITIVE_SLIPPAGE(address recipient, address token, uint256 expectedAmount) external;\n\n    /// @dev Trades against a basic AMM which follows the approval, transferFrom(msg.sender) interaction\n    // Pre-req: Funded\n    // Post-req: Payout\n    function BASIC(address sellToken, uint256 bps, address pool, uint256 offset, bytes calldata data) external;\n}\n"}, "lib/permit2/src/interfaces/ISignatureTransfer.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IEIP712} from \"./IEIP712.sol\";\n\n/// @title SignatureTransfer\n/// @notice Handles ERC20 token transfers through signature based actions\n/// @dev Requires user's token approval on the Permit2 contract\ninterface ISignatureTransfer is IEIP712 {\n    /// @notice Thrown when the requested amount for a transfer is larger than the permissioned amount\n    /// @param maxAmount The maximum amount a spender can request to transfer\n    error InvalidAmount(uint256 maxAmount);\n\n    /// @notice Thrown when the number of tokens permissioned to a spender does not match the number of tokens being transferred\n    /// @dev If the spender does not need to transfer the number of tokens permitted, the spender can request amount 0 to be transferred\n    error LengthMismatch();\n\n    /// @notice Emits an event when the owner successfully invalidates an unordered nonce.\n    event UnorderedNonceInvalidation(address indexed owner, uint256 word, uint256 mask);\n\n    /// @notice The token and amount details for a transfer signed in the permit transfer signature\n    struct TokenPermissions {\n        // ERC20 token address\n        address token;\n        // the maximum amount that can be spent\n        uint256 amount;\n    }\n\n    /// @notice The signed permit message for a single token transfer\n    struct PermitTransferFrom {\n        TokenPermissions permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice Specifies the recipient address and amount for batched transfers.\n    /// @dev Recipients and amounts correspond to the index of the signed token permissions array.\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount.\n    struct SignatureTransferDetails {\n        // recipient address\n        address to;\n        // spender requested amount\n        uint256 requestedAmount;\n    }\n\n    /// @notice Used to reconstruct the signed permit message for multiple token transfers\n    /// @dev Do not need to pass in spender address as it is required that it is msg.sender\n    /// @dev Note that a user still signs over a spender address\n    struct PermitBatchTransferFrom {\n        // the tokens and corresponding amounts permitted for a transfer\n        TokenPermissions[] permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice A map from token owner address and a caller specified word index to a bitmap. Used to set bits in the bitmap to prevent against signature replay protection\n    /// @dev Uses unordered nonces so that permit messages do not need to be spent in a certain order\n    /// @dev The mapping is indexed first by the token owner, then by an index specified in the nonce\n    /// @dev It returns a uint256 bitmap\n    /// @dev The index, or wordPosition is capped at type(uint248).max\n    function nonceBitmap(address, uint256) external view returns (uint256);\n\n    /// @notice Transfers a token using a signed permit message\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers a token using a signed permit message\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Invalidates the bits specified in mask for the bitmap at the word position\n    /// @dev The wordPos is maxed at type(uint248).max\n    /// @param wordPos A number to index the nonceBitmap at\n    /// @param mask A bitmap masked against msg.sender's current bitmap at the word position\n    function invalidateUnorderedNonces(uint256 wordPos, uint256 mask) external;\n}\n"}, "src/core/SettlerErrors.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/// @notice Thrown when an offset is not the expected value\nerror InvalidOffset();\n\n/// @notice Thrown when a validating a target contract to avoid certain types of targets\nerror ConfusedDeputy();\n\n/// @notice Thrown when a target contract is invalid given the context\nerror InvalidTarget();\n\n/// @notice Thrown when validating the caller against the expected caller\nerror InvalidSender();\n\n/// @notice Thrown in cases when using a Trusted Forwarder / AllowanceHolder is not allowed\nerror ForwarderNotAllowed();\n\n/// @notice Thrown when a signature length is not the expected length\nerror InvalidSignatureLen();\n\n/// @notice Thrown when a slippage limit is exceeded\nerror TooMuchSlippage(IERC20 token, uint256 expected, uint256 actual);\n\n/// @notice Thrown when a byte array that is supposed to encode a function from ISettlerActions is\n///         not recognized in context.\nerror ActionInvalid(uint256 i, bytes4 action, bytes data);\n\n/// @notice Thrown when the encoded fork ID as part of UniswapV3 fork path is not on the list of\n///         recognized forks for this chain.\nerror UnknownForkId(uint8 forkId);\n\n/// @notice Thrown when an AllowanceHolder transfer's permit is past its deadline\nerror SignatureExpired(uint256 deadline);\n\n/// @notice An internal error that should never be thrown. Thrown when a callback reenters the\n///         entrypoint and attempts to clobber the existing callback.\nerror ReentrantCallback(uint256 callbackInt);\n\n/// @notice An internal error that should never be thrown. This error can only be thrown by\n///         non-metatx-supporting Settler instances. Thrown when a callback-requiring liquidity\n///         source is called, but Settler never receives the callback.\nerror CallbackNotSpent(uint256 callbackInt);\n\n/// @notice Thrown when a metatransaction has reentrancy.\nerror ReentrantMetatransaction(bytes32 oldWitness);\n\n/// @notice Thrown when any transaction has reentrancy, not just taker-submitted or metatransaction.\nerror ReentrantPayer(address oldPayer);\n\n/// @notice An internal error that should never be thrown. Thrown when a metatransaction fails to\n///         spend a coupon.\nerror WitnessNotSpent(bytes32 oldWitness);\n\n/// @notice An internal error that should never be thrown. Thrown when the payer is unset\n///         unexpectedly.\nerror PayerSpent();\n"}, "src/core/univ3forks/UniswapV3.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\naddress constant uniswapV3MainnetFactory = 0x1F98431c8aD98523631AE4a59f267346ea31F984;\naddress constant uniswapV3SepoliaFactory = 0x0227628f3F023bb0B980b67D528571c95c6DaC1c;\naddress constant uniswapV3BaseFactory = 0x33128a8fC17869897dcE68Ed026d694621f6FDfD;\naddress constant uniswapV3BnbFactory = 0xdB1d10011AD0Ff90774D0C6Bb92e5C5c8b4461F7;\naddress constant uniswapV3AvalancheFactory = 0x740b1c1de25031C31FF4fC9A62f554A55cdC1baD;\nbytes32 constant uniswapV3InitHash = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\n\ninterface IUniswapV3Callback {\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external;\n}\n"}, "src/core/univ3forks/PancakeSwapV3.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\naddress constant pancakeSwapV3MainnetFactory = 0x41ff9AA7e16B8B1a8a8dc4f0eFacd93D02d071c9;\naddress constant pancakeSwapV3BnbFactory = 0x0BFbCF9fa4f9C56B0F40a671Ad40E0805A091865;\nbytes32 constant pancakeSwapV3InitHash = 0x6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2;\n\ninterface IPancakeSwapV3Callback {\n    function pancakeV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external;\n}\n"}, "src/core/univ3forks/SolidlyV3.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\naddress constant solidlyV3Factory = 0x70Fe4a44EA505cFa3A57b95cF2862D4fd5F0f687;\nbytes32 constant solidlyV3InitHash = 0xe9b68c5f77858eecac2e651646e208175e9b1359d68d0e14fc69f8c54e5010bf;\n\ninterface ISolidlyV3Callback {\n    function solidlyV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external;\n}\n"}, "src/SettlerAbstract.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Permit2PaymentAbstract} from \"./core/Permit2PaymentAbstract.sol\";\n\nabstract contract SettlerAbstract is Permit2PaymentAbstract {\n    // Permit2 Witness for meta transactions\n    string internal constant SLIPPAGE_AND_ACTIONS_TYPE =\n        \"SlippageAndActions(address recipient,address buyToken,uint256 minAmountOut,bytes[] actions)\";\n    bytes32 internal constant SLIPPAGE_AND_ACTIONS_TYPEHASH =\n        0x615e8d716cef7295e75dd3f1f10d679914ad6d7759e8e9459f0109ef75241701;\n\n    constructor() {\n        assert(SLIPPAGE_AND_ACTIONS_TYPEHASH == keccak256(bytes(SLIPPAGE_AND_ACTIONS_TYPE)));\n    }\n\n    function _hasMetaTxn() internal pure virtual returns (bool);\n\n    function _dispatch(uint256 i, bytes4 action, bytes calldata data) internal virtual returns (bool);\n}\n"}, "src/Context.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nabstract contract AbstractContext {\n    function _msgSender() internal view virtual returns (address);\n\n    function _msgData() internal view virtual returns (bytes calldata);\n\n    function _isForwarded() internal view virtual returns (bool);\n}\n\nabstract contract Context is AbstractContext {\n    function _msgSender() internal view virtual override returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _isForwarded() internal view virtual override returns (bool) {\n        return false;\n    }\n}\n"}, "src/core/Permit2Payment.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {\n    CallbackNotSpent,\n    ConfusedDeputy,\n    ForwarderNotAllowed,\n    InvalidSignatureLen,\n    PayerSpent,\n    ReentrantCallback,\n    ReentrantMetatransaction,\n    ReentrantPayer,\n    SignatureExpired,\n    WitnessNotSpent\n} from \"./SettlerErrors.sol\";\n\nimport {SettlerAbstract} from \"../SettlerAbstract.sol\";\nimport {Panic} from \"../utils/Panic.sol\";\n\nimport {ISignatureTransfer} from \"permit2/src/interfaces/ISignatureTransfer.sol\";\nimport {Revert} from \"../utils/Revert.sol\";\n\nlibrary TransientStorage {\n    // bytes32(uint256(keccak256(\"operator slot\")) - 1)\n    bytes32 private constant _OPERATOR_SLOT = 0x009355806b743562f351db2e3726091207f49fa1cdccd5c65a7d4860ce3abbe9;\n    // bytes32(uint256(keccak256(\"witness slot\")) - 1)\n    bytes32 private constant _WITNESS_SLOT = 0x1643bf8e9fdaef48c4abf5a998de359be44a235ac7aebfbc05485e093720deaa;\n    // bytes32(uint256(keccak256(\"payer slot\")) - 1)\n    bytes32 private constant _PAYER_SLOT = 0x46bacb9b87ba1d2910347e4a3e052d06c824a45acd1e9517bb0cb8d0d5cde893;\n\n    function setOperatorAndCallback(\n        address operator,\n        uint32 selector,\n        function (bytes calldata) internal returns (bytes memory) callback\n    ) internal {\n        address currentSigner;\n        assembly (\"memory-safe\") {\n            currentSigner := tload(_PAYER_SLOT)\n        }\n        if (operator == currentSigner) {\n            revert ConfusedDeputy();\n        }\n        uint256 callbackInt;\n        assembly (\"memory-safe\") {\n            callbackInt := tload(_OPERATOR_SLOT)\n        }\n        if (callbackInt != 0) {\n            // It should be impossible to reach this error because the first thing the fallback does\n            // is clear the operator. It's also not possible to reenter the entrypoint function\n            // because `_PAYER_SLOT` is an implicit reentrancy guard.\n            revert ReentrantCallback(callbackInt);\n        }\n        assembly (\"memory-safe\") {\n            tstore(\n                _OPERATOR_SLOT,\n                or(\n                    shl(0xe0, selector),\n                    or(shl(0xa0, and(0xffff, callback)), and(0xffffffffffffffffffffffffffffffffffffffff, operator))\n                )\n            )\n        }\n    }\n\n    function checkSpentOperatorAndCallback() internal view {\n        uint256 callbackInt;\n        assembly (\"memory-safe\") {\n            callbackInt := tload(_OPERATOR_SLOT)\n        }\n        if (callbackInt != 0) {\n            revert CallbackNotSpent(callbackInt);\n        }\n    }\n\n    function getAndClearOperatorAndCallback()\n        internal\n        returns (bytes4 selector, function (bytes calldata) internal returns (bytes memory) callback, address operator)\n    {\n        assembly (\"memory-safe\") {\n            selector := tload(_OPERATOR_SLOT)\n            callback := and(0xffff, shr(0xa0, selector))\n            operator := and(0xffffffffffffffffffffffffffffffffffffffff, selector)\n            tstore(_OPERATOR_SLOT, 0x00)\n        }\n    }\n\n    function setWitness(bytes32 newWitness) internal {\n        bytes32 currentWitness;\n        assembly (\"memory-safe\") {\n            currentWitness := tload(_WITNESS_SLOT)\n        }\n        if (currentWitness != bytes32(0)) {\n            // It should be impossible to reach this error because the first thing a metatransaction\n            // does on entry is to spend the `witness` (either directly or via a callback)\n            revert ReentrantMetatransaction(currentWitness);\n        }\n        assembly (\"memory-safe\") {\n            tstore(_WITNESS_SLOT, newWitness)\n        }\n    }\n\n    function checkSpentWitness() internal view {\n        bytes32 currentWitness;\n        assembly (\"memory-safe\") {\n            currentWitness := tload(_WITNESS_SLOT)\n        }\n        if (currentWitness != bytes32(0)) {\n            revert WitnessNotSpent(currentWitness);\n        }\n    }\n\n    function getAndClearWitness() internal returns (bytes32 witness) {\n        assembly (\"memory-safe\") {\n            witness := tload(_WITNESS_SLOT)\n            tstore(_WITNESS_SLOT, 0)\n        }\n    }\n\n    function setPayer(address payer) internal {\n        if (payer == address(0)) {\n            revert ConfusedDeputy();\n        }\n        address oldPayer;\n        assembly (\"memory-safe\") {\n            oldPayer := tload(_PAYER_SLOT)\n        }\n        if (oldPayer != address(0)) {\n            revert ReentrantPayer(oldPayer);\n        }\n        assembly (\"memory-safe\") {\n            tstore(_PAYER_SLOT, and(0xffffffffffffffffffffffffffffffffffffffff, payer))\n        }\n    }\n\n    function getPayer() internal view returns (address payer) {\n        assembly (\"memory-safe\") {\n            payer := tload(_PAYER_SLOT)\n        }\n    }\n\n    function clearPayer() internal {\n        address oldPayer;\n        assembly (\"memory-safe\") {\n            oldPayer := tload(_PAYER_SLOT)\n        }\n        if (oldPayer == address(0)) {\n            revert PayerSpent();\n        }\n        assembly (\"memory-safe\") {\n            tstore(_PAYER_SLOT, 0x00)\n        }\n    }\n}\n\nabstract contract Permit2PaymentBase is SettlerAbstract {\n    using Revert for bool;\n\n    /// @dev Permit2 address\n    ISignatureTransfer internal constant _PERMIT2 = ISignatureTransfer(0x000000000022D473030F116dDEE9F6B43aC78BA3);\n\n    function _isRestrictedTarget(address target) internal pure virtual override returns (bool) {\n        return target == address(_PERMIT2);\n    }\n\n    function _msgSender() internal view virtual override returns (address) {\n        return TransientStorage.getPayer();\n    }\n\n    /// @dev You must ensure that `target` is derived by hashing trusted initcode or another\n    ///      equivalent mechanism that guarantees \"reasonable\"ness. `target` must not be\n    ///      user-supplied or attacker-controlled. This is required for security and is not checked\n    ///      here. For example, it must not do something weird like modifying the spender (possibly\n    ///      setting it to itself). If the callback is expected to relay a\n    ///      `ISignatureTransfer.PermitTransferFrom` struct, then the computation of `target` using\n    ///      the trusted initcode (or equivalent) must ensure that that calldata is relayed\n    ///      unmodified. The library function `AddressDerivation.deriveDeterministicContract` is\n    ///      recommended.\n    function _setOperatorAndCall(\n        address payable target,\n        uint256 value,\n        bytes memory data,\n        uint32 selector,\n        function (bytes calldata) internal returns (bytes memory) callback\n    ) internal returns (bytes memory) {\n        TransientStorage.setOperatorAndCallback(target, selector, callback);\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        success.maybeRevert(returndata);\n        TransientStorage.checkSpentOperatorAndCallback();\n        return returndata;\n    }\n\n    function _setOperatorAndCall(\n        address target,\n        bytes memory data,\n        uint32 selector,\n        function (bytes calldata) internal returns (bytes memory) callback\n    ) internal override returns (bytes memory) {\n        return _setOperatorAndCall(payable(target), 0, data, selector, callback);\n    }\n\n    modifier metaTx(address msgSender, bytes32 witness) override {\n        assert(_hasMetaTxn());\n        if (_isForwarded()) {\n            revert ForwarderNotAllowed();\n        }\n        TransientStorage.setWitness(witness);\n        TransientStorage.setPayer(msgSender);\n        _;\n        TransientStorage.clearPayer();\n        // It should not be possible for this check to revert because the very first thing that a\n        // metatransaction does is spend the witness.\n        TransientStorage.checkSpentWitness();\n    }\n\n    modifier takerSubmitted() override {\n        assert(!_hasMetaTxn());\n        TransientStorage.setPayer(_operator());\n        _;\n        TransientStorage.clearPayer();\n    }\n\n    function _invokeCallback(bytes calldata data) internal returns (bytes memory) {\n        (bytes4 selector, function (bytes calldata) internal returns (bytes memory) callback, address operator) =\n            TransientStorage.getAndClearOperatorAndCallback();\n        require(bytes4(data) == selector);\n        require(msg.sender == operator);\n        return callback(data[4:]);\n    }\n}\n\nabstract contract Permit2Payment is Permit2PaymentBase {\n    // `string.concat` isn't recognized by solc as compile-time constant, but `abi.encodePacked` is\n    // This is defined here as `private` and not in `SettlerAbstract` as `internal` because no other\n    // contract/file should reference it. The *ONLY* approved way to make a transfer using this\n    // witness string is by setting the witness with modifier `metaTx`\n    string private constant _SLIPPAGE_AND_ACTIONS_WITNESS = string(\n        abi.encodePacked(\"SlippageAndActions slippageAndActions)\", SLIPPAGE_AND_ACTIONS_TYPE, TOKEN_PERMISSIONS_TYPE)\n    );\n\n    function _permitToTransferDetails(ISignatureTransfer.PermitTransferFrom memory permit, address recipient)\n        internal\n        pure\n        override\n        returns (ISignatureTransfer.SignatureTransferDetails memory transferDetails, address token, uint256 amount)\n    {\n        transferDetails.to = recipient;\n        transferDetails.requestedAmount = amount = permit.permitted.amount;\n        token = permit.permitted.token;\n    }\n\n    // This function is provided *EXCLUSIVELY* for use here and in RfqOrderSettlement. Any other use\n    // of this function is forbidden. You must use the overload that does *NOT* take a `witness`\n    // argument.\n    function _transferFrom(\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        ISignatureTransfer.SignatureTransferDetails memory transferDetails,\n        address from,\n        bytes32 witness,\n        string memory witnessTypeString,\n        bytes memory sig,\n        bool isForwarded\n    ) internal override {\n        if (isForwarded) revert ForwarderNotAllowed();\n        _PERMIT2.permitWitnessTransferFrom(permit, transferDetails, from, witness, witnessTypeString, sig);\n    }\n\n    // See comment in above overload; don't use this function\n    function _transferFrom(\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        ISignatureTransfer.SignatureTransferDetails memory transferDetails,\n        address from,\n        bytes32 witness,\n        string memory witnessTypeString,\n        bytes memory sig\n    ) internal override {\n        _transferFrom(permit, transferDetails, from, witness, witnessTypeString, sig, _isForwarded());\n    }\n\n    function _transferFrom(\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        ISignatureTransfer.SignatureTransferDetails memory transferDetails,\n        bytes memory sig,\n        bool isForwarded\n    ) internal override {\n        // Because `_hasMetaTxn()` is `pure`, this `if` statement is branching on a compile-time\n        // constant. The branch not taken is dead code and is eliminated by the compiler. Only one\n        // branch is reachable from a given `Settler` instance.\n        if (_hasMetaTxn()) {\n            bytes32 witness = TransientStorage.getAndClearWitness();\n            if (witness == bytes32(0)) {\n                revert ConfusedDeputy();\n            }\n            _transferFrom(\n                permit, transferDetails, _msgSender(), witness, _SLIPPAGE_AND_ACTIONS_WITNESS, sig, isForwarded\n            );\n        } else {\n            if (isForwarded) {\n                if (sig.length != 0) revert InvalidSignatureLen();\n                if (permit.nonce != 0) Panic.panic(Panic.ARITHMETIC_OVERFLOW);\n                if (block.timestamp > permit.deadline) revert SignatureExpired(permit.deadline);\n                // we don't check `requestedAmount` because it's checked by AllowanceHolder itself\n                _allowanceHolderTransferFrom(\n                    permit.permitted.token, _msgSender(), transferDetails.to, transferDetails.requestedAmount\n                );\n            } else {\n                _PERMIT2.permitTransferFrom(permit, transferDetails, _msgSender(), sig);\n            }\n        }\n    }\n\n    function _transferFrom(\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        ISignatureTransfer.SignatureTransferDetails memory transferDetails,\n        bytes memory sig\n    ) internal override {\n        _transferFrom(permit, transferDetails, sig, _isForwarded());\n    }\n}\n"}, "src/core/Permit2PaymentAbstract.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {AbstractContext} from \"../Context.sol\";\n\nimport {ISignatureTransfer} from \"permit2/src/interfaces/ISignatureTransfer.sol\";\n\nabstract contract Permit2PaymentAbstract is AbstractContext {\n    string internal constant TOKEN_PERMISSIONS_TYPE = \"TokenPermissions(address token,uint256 amount)\";\n\n    function _isRestrictedTarget(address) internal view virtual returns (bool);\n\n    function _operator() internal view virtual returns (address);\n\n    function _permitToTransferDetails(ISignatureTransfer.PermitTransferFrom memory permit, address recipient)\n        internal\n        pure\n        virtual\n        returns (ISignatureTransfer.SignatureTransferDetails memory transferDetails, address token, uint256 amount);\n\n    function _transferFrom(\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        ISignatureTransfer.SignatureTransferDetails memory transferDetails,\n        address from,\n        bytes32 witness,\n        string memory witnessTypeString,\n        bytes memory sig,\n        bool isForwarded\n    ) internal virtual;\n\n    function _transferFrom(\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        ISignatureTransfer.SignatureTransferDetails memory transferDetails,\n        address from,\n        bytes32 witness,\n        string memory witnessTypeString,\n        bytes memory sig\n    ) internal virtual;\n\n    function _transferFrom(\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        ISignatureTransfer.SignatureTransferDetails memory transferDetails,\n        bytes memory sig,\n        bool isForwarded\n    ) internal virtual;\n\n    function _transferFrom(\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        ISignatureTransfer.SignatureTransferDetails memory transferDetails,\n        bytes memory sig\n    ) internal virtual;\n\n    function _setOperatorAndCall(\n        address target,\n        bytes memory data,\n        uint32 selector,\n        function (bytes calldata) internal returns (bytes memory) callback\n    ) internal virtual returns (bytes memory);\n\n    modifier metaTx(address msgSender, bytes32 witness) virtual;\n\n    modifier takerSubmitted() virtual;\n\n    function _allowanceHolderTransferFrom(address token, address owner, address recipient, uint256 amount)\n        internal\n        virtual;\n}\n"}, "src/core/Basic.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {SettlerAbstract} from \"../SettlerAbstract.sol\";\nimport {InvalidOffset, ConfusedDeputy, InvalidTarget} from \"./SettlerErrors.sol\";\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {SafeTransferLib} from \"../vendor/SafeTransferLib.sol\";\nimport {FullMath} from \"../vendor/FullMath.sol\";\nimport {Panic} from \"../utils/Panic.sol\";\nimport {Revert} from \"../utils/Revert.sol\";\n\nabstract contract Basic is SettlerAbstract {\n    using SafeTransferLib for IERC20;\n    using FullMath for uint256;\n    using Revert for bool;\n\n    IERC20 internal constant ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    /// @dev Sell to a pool with a generic approval, transferFrom interaction.\n    /// offset in the calldata is used to update the sellAmount given a proportion of the sellToken balance\n    function basicSellToPool(IERC20 sellToken, uint256 bps, address pool, uint256 offset, bytes memory data) internal {\n        if (_isRestrictedTarget(pool)) {\n            revert ConfusedDeputy();\n        }\n\n        bool success;\n        bytes memory returnData;\n        uint256 value;\n        if (sellToken == IERC20(ETH_ADDRESS)) {\n            value = address(this).balance.mulDiv(bps, 10_000);\n            if (data.length == 0) {\n                if (offset != 0) revert InvalidOffset();\n                (success, returnData) = payable(pool).call{value: value}(\"\");\n                success.maybeRevert(returnData);\n                return;\n            } else {\n                if ((offset += 32) > data.length) {\n                    Panic.panic(Panic.ARRAY_OUT_OF_BOUNDS);\n                }\n                assembly (\"memory-safe\") {\n                    mstore(add(data, offset), value)\n                }\n            }\n        } else if (address(sellToken) == address(0)) {\n            // TODO: check for zero `bps`\n            if (offset != 0) revert InvalidOffset();\n        } else {\n            uint256 amount = sellToken.balanceOf(address(this)).mulDiv(bps, 10_000);\n            if ((offset += 32) > data.length) {\n                Panic.panic(Panic.ARRAY_OUT_OF_BOUNDS);\n            }\n            assembly (\"memory-safe\") {\n                mstore(add(data, offset), amount)\n            }\n            if (address(sellToken) != pool) {\n                sellToken.safeApproveIfBelow(pool, amount);\n            }\n        }\n        (success, returnData) = payable(pool).call{value: value}(data);\n        success.maybeRevert(returnData);\n        // forbid sending data to EOAs\n        if (returnData.length == 0 && pool.code.length == 0) revert InvalidTarget();\n    }\n}\n"}, "src/core/RfqOrderSettlement.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {ISignatureTransfer} from \"permit2/src/interfaces/ISignatureTransfer.sol\";\nimport {SettlerAbstract} from \"../SettlerAbstract.sol\";\n\nimport {SafeTransferLib} from \"../vendor/SafeTransferLib.sol\";\nimport {FullMath} from \"../vendor/FullMath.sol\";\n\nabstract contract RfqOrderSettlement is SettlerAbstract {\n    using SafeTransferLib for IERC20;\n    using FullMath for uint256;\n\n    struct Consideration {\n        address token;\n        uint256 amount;\n        address counterparty;\n        bool partialFillAllowed;\n    }\n\n    string internal constant CONSIDERATION_TYPE =\n        \"Consideration(address token,uint256 amount,address counterparty,bool partialFillAllowed)\";\n    // `string.concat` isn't recognized by solc as compile-time constant, but `abi.encodePacked` is\n    string internal constant CONSIDERATION_WITNESS =\n        string(abi.encodePacked(\"Consideration consideration)\", CONSIDERATION_TYPE, TOKEN_PERMISSIONS_TYPE));\n    bytes32 internal constant CONSIDERATION_TYPEHASH =\n        0x7d806873084f389a66fd0315dead7adaad8ae6e8b6cf9fb0d3db61e5a91c3ffa;\n\n    string internal constant RFQ_ORDER_TYPE =\n        \"RfqOrder(Consideration makerConsideration,Consideration takerConsideration)\";\n    string internal constant RFQ_ORDER_TYPE_RECURSIVE = string(abi.encodePacked(RFQ_ORDER_TYPE, CONSIDERATION_TYPE));\n    bytes32 internal constant RFQ_ORDER_TYPEHASH = 0x49fa719b76f0f6b7e76be94b56c26671a548e1c712d5b13dc2874f70a7598276;\n\n    function _hashConsideration(Consideration memory consideration) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            let ptr := sub(consideration, 0x20)\n            let oldValue := mload(ptr)\n            mstore(ptr, CONSIDERATION_TYPEHASH)\n            result := keccak256(ptr, 0xa0)\n            mstore(ptr, oldValue)\n        }\n    }\n\n    function _logRfqOrder(bytes32 makerConsiderationHash, bytes32 takerConsiderationHash, uint128 makerFilledAmount)\n        private\n    {\n        assembly (\"memory-safe\") {\n            mstore(0x00, RFQ_ORDER_TYPEHASH)\n            mstore(0x20, makerConsiderationHash)\n            let ptr := mload(0x40)\n            mstore(0x40, takerConsiderationHash)\n            let orderHash := keccak256(0x00, 0x60)\n            mstore(0x40, ptr)\n            mstore(0x10, makerFilledAmount)\n            mstore(0x00, orderHash)\n            log0(0x00, 0x30)\n        }\n    }\n\n    constructor() {\n        assert(CONSIDERATION_TYPEHASH == keccak256(bytes(CONSIDERATION_TYPE)));\n        assert(RFQ_ORDER_TYPEHASH == keccak256(bytes(RFQ_ORDER_TYPE_RECURSIVE)));\n    }\n\n    /// @dev Settle an RfqOrder between maker and taker transfering funds directly between the counterparties. Either\n    ///      two Permit2 signatures are consumed, with the maker Permit2 containing a witness of the RfqOrder, or\n    ///      AllowanceHolder is supported for the taker payment. The Maker has signed the same order as the\n    ///      Taker. Submission may be directly by the taker or via a third party with the Taker signing a witness.\n    /// @dev if used, the taker's witness is not calculated nor verified here as calling function is trusted\n    function fillRfqOrderVIP(\n        address recipient,\n        ISignatureTransfer.PermitTransferFrom memory makerPermit,\n        address maker,\n        bytes memory makerSig,\n        ISignatureTransfer.PermitTransferFrom memory takerPermit,\n        bytes memory takerSig\n    ) internal {\n        (\n            ISignatureTransfer.SignatureTransferDetails memory makerTransferDetails,\n            address makerToken,\n            uint256 makerAmount\n        ) = _permitToTransferDetails(makerPermit, recipient);\n        (\n            ISignatureTransfer.SignatureTransferDetails memory takerTransferDetails,\n            address takerToken,\n            uint256 takerAmount\n        ) = _permitToTransferDetails(takerPermit, maker);\n\n        bytes32 witness = _hashConsideration(\n            Consideration({\n                token: takerToken,\n                amount: takerAmount,\n                counterparty: _msgSender(),\n                partialFillAllowed: false\n            })\n        );\n        _transferFrom(takerPermit, takerTransferDetails, takerSig);\n        _transferFrom(makerPermit, makerTransferDetails, maker, witness, CONSIDERATION_WITNESS, makerSig, false);\n\n        _logRfqOrder(\n            witness,\n            _hashConsideration(\n                Consideration({token: makerToken, amount: makerAmount, counterparty: maker, partialFillAllowed: false})\n            ),\n            uint128(makerAmount)\n        );\n    }\n\n    /// @dev Settle an RfqOrder between maker and Settler retaining funds in this contract.\n    /// @dev pre-condition: msgSender has been authenticated against the requestor\n    /// One Permit2 signature is consumed, with the maker Permit2 containing a witness of the RfqOrder.\n    // In this variant, Maker pays recipient and Settler pays Maker\n    function fillRfqOrderSelfFunded(\n        address recipient,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        address maker,\n        bytes memory makerSig,\n        IERC20 takerToken,\n        uint256 maxTakerAmount\n    ) internal {\n        // Compute witnesses. These are based on the quoted maximum amounts. We will modify them\n        // later to adjust for the actual settled amount, which may be modified by encountered\n        // slippage.\n        (ISignatureTransfer.SignatureTransferDetails memory transferDetails, address makerToken, uint256 makerAmount) =\n            _permitToTransferDetails(permit, recipient);\n        bytes32 takerWitness = _hashConsideration(\n            Consideration({token: makerToken, amount: makerAmount, counterparty: maker, partialFillAllowed: true})\n        );\n        bytes32 makerWitness = _hashConsideration(\n            Consideration({\n                token: address(takerToken),\n                amount: maxTakerAmount,\n                counterparty: _msgSender(),\n                partialFillAllowed: true\n            })\n        );\n\n        // Now we adjust the transfer amounts to compensate for encountered slippage. Rounding is\n        // performed in the maker's favor.\n        uint256 takerAmount = takerToken.balanceOf(address(this));\n        if (takerAmount > maxTakerAmount) {\n            takerAmount = maxTakerAmount;\n        }\n        transferDetails.requestedAmount = makerAmount = makerAmount.unsafeMulDiv(takerAmount, maxTakerAmount);\n\n        // Now that we have all the relevant information, make the transfers and log the order.\n        takerToken.safeTransfer(maker, takerAmount);\n        _transferFrom(permit, transferDetails, maker, makerWitness, CONSIDERATION_WITNESS, makerSig, false);\n\n        _logRfqOrder(makerWitness, takerWitness, uint128(makerAmount));\n    }\n}\n"}, "src/core/UniswapV3Fork.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {ISignatureTransfer} from \"permit2/src/interfaces/ISignatureTransfer.sol\";\nimport {UnsafeMath} from \"../utils/UnsafeMath.sol\";\nimport {Panic} from \"../utils/Panic.sol\";\nimport {SafeTransferLib} from \"../vendor/SafeTransferLib.sol\";\nimport {AddressDerivation} from \"../utils/AddressDerivation.sol\";\nimport {SettlerAbstract} from \"../SettlerAbstract.sol\";\n\nimport {TooMuchSlippage, ConfusedDeputy} from \"./SettlerErrors.sol\";\n\ninterface IUniswapV3Pool {\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive),\n    /// or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n}\n\nabstract contract UniswapV3Fork is SettlerAbstract {\n    using UnsafeMath for uint256;\n    using SafeTransferLib for IERC20;\n\n    /// @dev Minimum size of an encoded swap path:\n    ///      sizeof(address(inputToken) | uint8(forkId) | uint24(poolId) | address(outputToken))\n    uint256 private constant SINGLE_HOP_PATH_SIZE = 0x2c;\n    /// @dev How many bytes to skip ahead in an encoded path to start at the next hop:\n    ///      sizeof(address(inputToken) | uint8(forkId) | uint24(poolId))\n    uint256 private constant PATH_SKIP_HOP_SIZE = 0x18;\n    /// @dev The size of the swap callback prefix data before the Permit2 data.\n    uint256 private constant SWAP_CALLBACK_PREFIX_DATA_SIZE = 0x28;\n    /// @dev The offset from the pointer to the length of the swap callback prefix data to the start of the Permit2 data.\n    uint256 private constant SWAP_CALLBACK_PERMIT2DATA_OFFSET = 0x48;\n    uint256 private constant PERMIT_DATA_SIZE = 0x60;\n    uint256 private constant ISFORWARDED_DATA_SIZE = 0x01;\n    /// @dev Minimum tick price sqrt ratio.\n    uint160 private constant MIN_PRICE_SQRT_RATIO = 4295128739;\n    /// @dev Minimum tick price sqrt ratio.\n    uint160 private constant MAX_PRICE_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n    /// @dev Mask of lower 20 bytes.\n    uint256 private constant ADDRESS_MASK = 0x00ffffffffffffffffffffffffffffffffffffffff;\n    /// @dev Mask of lower 3 bytes.\n    uint256 private constant UINT24_MASK = 0xffffff;\n\n    /// @dev Sell a token for another token directly against uniswap v3.\n    /// @param encodedPath Uniswap-encoded path.\n    /// @param bps proportion of current balance of the first token in the path to sell.\n    /// @param minBuyAmount Minimum amount of the last token in the path to buy.\n    /// @param recipient The recipient of the bought tokens.\n    /// @return buyAmount Amount of the last token in the path bought.\n    function sellToUniswapV3(address recipient, uint256 bps, bytes memory encodedPath, uint256 minBuyAmount)\n        internal\n        returns (uint256 buyAmount)\n    {\n        buyAmount = _uniV3ForkSwap(\n            recipient,\n            encodedPath,\n            // We don't care about phantom overflow here because reserves are\n            // limited to 128 bits. Any token balance that would overflow here\n            // would also break UniV3.\n            (IERC20(address(bytes20(encodedPath))).balanceOf(address(this)) * bps).unsafeDiv(10_000),\n            minBuyAmount,\n            address(this), // payer\n            new bytes(SWAP_CALLBACK_PREFIX_DATA_SIZE)\n        );\n    }\n\n    /// @dev Sell a token for another token directly against uniswap v3. Payment is using a Permit2 signature (or AllowanceHolder).\n    /// @param encodedPath Uniswap-encoded path.\n    /// @param minBuyAmount Minimum amount of the last token in the path to buy.\n    /// @param recipient The recipient of the bought tokens.\n    /// @param permit The PermitTransferFrom allowing this contract to spend the taker's tokens\n    /// @param sig The taker's signature for Permit2\n    /// @return buyAmount Amount of the last token in the path bought.\n    function sellToUniswapV3VIP(\n        address recipient,\n        bytes memory encodedPath,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        bytes memory sig,\n        uint256 minBuyAmount\n    ) internal returns (uint256 buyAmount) {\n        bytes memory swapCallbackData =\n            new bytes(SWAP_CALLBACK_PREFIX_DATA_SIZE + PERMIT_DATA_SIZE + ISFORWARDED_DATA_SIZE + sig.length);\n        _encodePermit2Data(swapCallbackData, permit, sig, _isForwarded());\n\n        buyAmount = _uniV3ForkSwap(\n            recipient,\n            encodedPath,\n            permit.permitted.amount,\n            minBuyAmount,\n            address(0), // payer\n            swapCallbackData\n        );\n    }\n\n    // Executes successive swaps along an encoded uniswap path.\n    function _uniV3ForkSwap(\n        address recipient,\n        bytes memory encodedPath,\n        uint256 sellAmount,\n        uint256 minBuyAmount,\n        address payer,\n        bytes memory swapCallbackData\n    ) internal returns (uint256 buyAmount) {\n        if (sellAmount > uint256(type(int256).max)) {\n            Panic.panic(Panic.ARITHMETIC_OVERFLOW);\n        }\n\n        IERC20 outputToken;\n        while (true) {\n            bool isPathMultiHop = _isPathMultiHop(encodedPath);\n            bool zeroForOne;\n            IUniswapV3Pool pool;\n            bytes4 callbackSelector;\n            {\n                (IERC20 token0, uint8 forkId, uint24 poolId, IERC20 token1) = _decodeFirstPoolInfoFromPath(encodedPath);\n                outputToken = token1;\n                if (!(zeroForOne = token0 < token1)) {\n                    (token0, token1) = (token1, token0);\n                }\n                address factory;\n                bytes32 initHash;\n                (factory, initHash, callbackSelector) = _uniV3ForkInfo(forkId);\n                pool = _toPool(factory, initHash, token0, poolId, token1);\n                _updateSwapCallbackData(swapCallbackData, zeroForOne ? token0 : token1, payer);\n            }\n\n            int256 amount0;\n            int256 amount1;\n            if (isPathMultiHop) {\n                uint256 freeMemPtr;\n                assembly (\"memory-safe\") {\n                    freeMemPtr := mload(0x40)\n                }\n                (amount0, amount1) = abi.decode(\n                    _setOperatorAndCall(\n                        address(pool),\n                        abi.encodeCall(\n                            pool.swap,\n                            (\n                                // Intermediate tokens go to this contract.\n                                address(this),\n                                zeroForOne,\n                                int256(sellAmount),\n                                zeroForOne ? MIN_PRICE_SQRT_RATIO + 1 : MAX_PRICE_SQRT_RATIO - 1,\n                                swapCallbackData\n                            )\n                        ),\n                        uint32(callbackSelector),\n                        _uniV3ForkCallback\n                    ),\n                    (int256, int256)\n                );\n                assembly (\"memory-safe\") {\n                    mstore(0x40, freeMemPtr)\n                }\n            } else {\n                (amount0, amount1) = abi.decode(\n                    _setOperatorAndCall(\n                        address(pool),\n                        abi.encodeCall(\n                            pool.swap,\n                            (\n                                recipient,\n                                zeroForOne,\n                                int256(sellAmount),\n                                zeroForOne ? MIN_PRICE_SQRT_RATIO + 1 : MAX_PRICE_SQRT_RATIO - 1,\n                                swapCallbackData\n                            )\n                        ),\n                        uint32(callbackSelector),\n                        _uniV3ForkCallback\n                    ),\n                    (int256, int256)\n                );\n            }\n\n            {\n                int256 _buyAmount = -(zeroForOne ? amount1 : amount0);\n                if (_buyAmount < 0) {\n                    Panic.panic(Panic.ARITHMETIC_OVERFLOW);\n                }\n                buyAmount = uint256(_buyAmount);\n            }\n            if (!isPathMultiHop) {\n                // Done.\n                break;\n            }\n            // Continue with next hop.\n            payer = address(this); // Subsequent hops are paid for by us.\n            sellAmount = buyAmount;\n            // Skip to next hop along path.\n            encodedPath = _shiftHopFromPathInPlace(encodedPath);\n            assembly (\"memory-safe\") {\n                mstore(swapCallbackData, SWAP_CALLBACK_PREFIX_DATA_SIZE)\n            }\n        }\n        if (buyAmount < minBuyAmount) {\n            revert TooMuchSlippage(outputToken, minBuyAmount, buyAmount);\n        }\n    }\n\n    // Return whether or not an encoded uniswap path contains more than one hop.\n    function _isPathMultiHop(bytes memory encodedPath) private pure returns (bool) {\n        return encodedPath.length > SINGLE_HOP_PATH_SIZE;\n    }\n\n    function _decodeFirstPoolInfoFromPath(bytes memory encodedPath)\n        private\n        pure\n        returns (IERC20 inputToken, uint8 forkId, uint24 poolId, IERC20 outputToken)\n    {\n        if (encodedPath.length < SINGLE_HOP_PATH_SIZE) {\n            Panic.panic(Panic.ARRAY_OUT_OF_BOUNDS);\n        }\n        assembly (\"memory-safe\") {\n            // Solidity cleans dirty bits automatically\n            inputToken := mload(add(encodedPath, 0x14))\n            forkId := mload(add(encodedPath, 0x15))\n            poolId := mload(add(encodedPath, 0x18))\n            outputToken := mload(add(encodedPath, SINGLE_HOP_PATH_SIZE))\n        }\n    }\n\n    // Skip past the first hop of an encoded uniswap path in-place.\n    function _shiftHopFromPathInPlace(bytes memory encodedPath) private pure returns (bytes memory) {\n        if (encodedPath.length < PATH_SKIP_HOP_SIZE) {\n            Panic.panic(Panic.ARRAY_OUT_OF_BOUNDS);\n        }\n        assembly (\"memory-safe\") {\n            let length := sub(mload(encodedPath), PATH_SKIP_HOP_SIZE)\n            encodedPath := add(encodedPath, PATH_SKIP_HOP_SIZE)\n            mstore(encodedPath, length)\n        }\n        return encodedPath;\n    }\n\n    function _encodePermit2Data(\n        bytes memory swapCallbackData,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        bytes memory sig,\n        bool isForwarded\n    ) private pure {\n        assembly (\"memory-safe\") {\n            mstore(add(SWAP_CALLBACK_PERMIT2DATA_OFFSET, swapCallbackData), mload(add(0x20, mload(permit))))\n            mcopy(add(add(SWAP_CALLBACK_PERMIT2DATA_OFFSET, 0x20), swapCallbackData), add(0x20, permit), 0x40)\n            mstore8(add(add(SWAP_CALLBACK_PERMIT2DATA_OFFSET, PERMIT_DATA_SIZE), swapCallbackData), isForwarded)\n            mcopy(\n                add(\n                    add(add(SWAP_CALLBACK_PERMIT2DATA_OFFSET, PERMIT_DATA_SIZE), ISFORWARDED_DATA_SIZE),\n                    swapCallbackData\n                ),\n                add(0x20, sig),\n                mload(sig)\n            )\n        }\n    }\n\n    // Update `swapCallbackData` in place with new values.\n    function _updateSwapCallbackData(bytes memory swapCallbackData, IERC20 sellToken, address payer) private pure {\n        assembly (\"memory-safe\") {\n            let length := mload(swapCallbackData)\n            mstore(add(0x28, swapCallbackData), sellToken)\n            mstore(add(0x14, swapCallbackData), payer)\n            mstore(swapCallbackData, length)\n        }\n    }\n\n    // Compute the pool address given two tokens and a poolId.\n    function _toPool(address factory, bytes32 initHash, IERC20 inputToken, uint24 poolId, IERC20 outputToken)\n        private\n        pure\n        returns (IUniswapV3Pool)\n    {\n        // address(keccak256(abi.encodePacked(\n        //     hex\"ff\",\n        //     factory,\n        //     keccak256(abi.encode(inputToken, outputToken, poolId)),\n        //     initHash\n        // )))\n        (IERC20 token0, IERC20 token1) =\n            inputToken < outputToken ? (inputToken, outputToken) : (outputToken, inputToken);\n        bytes32 salt;\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(0x00, and(ADDRESS_MASK, token0))\n            mstore(0x20, and(ADDRESS_MASK, token1))\n            mstore(0x40, and(UINT24_MASK, poolId))\n            salt := keccak256(0x00, 0x60)\n            mstore(0x40, ptr)\n        }\n        return IUniswapV3Pool(AddressDerivation.deriveDeterministicContract(factory, salt, initHash));\n    }\n\n    function _uniV3ForkInfo(uint8 forkId) internal view virtual returns (address, bytes32, bytes4);\n\n    function _uniV3ForkCallback(bytes calldata data) private returns (bytes memory) {\n        require(data.length >= 0x80);\n        int256 amount0Delta;\n        int256 amount1Delta;\n        assembly (\"memory-safe\") {\n            amount0Delta := calldataload(data.offset)\n            amount1Delta := calldataload(add(0x20, data.offset))\n            data.offset := add(data.offset, calldataload(add(0x40, data.offset)))\n            data.length := calldataload(data.offset)\n            data.offset := add(0x20, data.offset)\n        }\n        uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n        return new bytes(0);\n    }\n\n    /// @dev The UniswapV3 pool swap callback which pays the funds requested\n    ///      by the caller/pool to the pool. Can only be called by a valid\n    ///      UniswapV3 pool.\n    /// @param amount0Delta Token0 amount owed.\n    /// @param amount1Delta Token1 amount owed.\n    /// @param data Arbitrary data forwarded from swap() caller. A packed encoding of: payer, sellToken, (optionally: permit[0x20:], isForwarded, sig)\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) private {\n        address payer = address(uint160(bytes20(data)));\n        data = data[0x14:];\n        uint256 sellAmount = amount0Delta > 0 ? uint256(amount0Delta) : uint256(amount1Delta);\n        _pay(payer, sellAmount, data);\n    }\n\n    function _pay(address payer, uint256 amount, bytes calldata permit2Data) private {\n        if (payer == address(this)) {\n            IERC20(address(uint160(bytes20(permit2Data)))).safeTransfer(msg.sender, amount);\n        } else {\n            assert(payer == address(0));\n            ISignatureTransfer.PermitTransferFrom calldata permit;\n            bool isForwarded;\n            bytes calldata sig;\n            assembly (\"memory-safe\") {\n                // this is super dirty, but it works because although `permit` is aliasing in the\n                // middle of `payer`, because `payer` is all zeroes, it's treated as padding for the\n                // first word of `permit`, which is the sell token\n                permit := sub(permit2Data.offset, 0x0c)\n                isForwarded := and(0x01, calldataload(add(0x55, permit2Data.offset)))\n                sig.offset := add(0x75, permit2Data.offset)\n                sig.length := sub(permit2Data.length, 0x75)\n            }\n            _transferFrom(\n                permit,\n                ISignatureTransfer.SignatureTransferDetails({to: msg.sender, requestedAmount: amount}),\n                sig,\n                isForwarded\n            );\n        }\n    }\n}\n"}, "src/core/UniswapV2.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {UnsafeMath} from \"../utils/UnsafeMath.sol\";\nimport {Panic} from \"../utils/Panic.sol\";\nimport {TooMuchSlippage} from \"./SettlerErrors.sol\";\n\ninterface IUniV2Pair {\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112, uint112, uint32);\n    function swap(uint256, uint256, address, bytes calldata) external;\n}\n\nabstract contract UniswapV2 {\n    using UnsafeMath for uint256;\n\n    // bytes4(keccak256(\"getReserves()\"))\n    uint32 private constant UNI_PAIR_RESERVES_SELECTOR = 0x0902f1ac;\n    // bytes4(keccak256(\"swap(uint256,uint256,address,bytes)\"))\n    uint32 private constant UNI_PAIR_SWAP_SELECTOR = 0x022c0d9f;\n    // bytes4(keccak256(\"transfer(address,uint256)\"))\n    uint32 private constant ERC20_TRANSFER_SELECTOR = 0xa9059cbb;\n    // bytes4(keccak256(\"balanceOf(address)\"))\n    uint32 private constant ERC20_BALANCEOF_SELECTOR = 0x70a08231;\n\n    /// @dev Sell a token for another token using UniswapV2.\n    function sellToUniswapV2(\n        address recipient,\n        address sellToken,\n        uint256 bps,\n        address pool,\n        uint24 swapInfo,\n        uint256 minBuyAmount\n    ) internal {\n        // Preventing calls to Permit2 or AH is not explicitly required as neither of these contracts implement the `swap` nor `transfer` selector\n\n        // |7|6|5|4|3|2|1|0| - bit positions in swapInfo (uint8)\n        // |0|0|0|0|0|0|F|Z| - Z: zeroForOne flag, F: sellTokenHasFee flag\n        bool zeroForOne = (swapInfo & 1) == 1; // Extract the least significant bit (bit 0)\n        bool sellTokenHasFee = (swapInfo & 2) >> 1 == 1; // Extract the second least significant bit (bit 1) and shift it right\n        uint256 feeBps = swapInfo >> 8;\n\n        uint256 sellAmount;\n        uint256 buyAmount;\n        // If bps is zero we assume there are no funds within this contract, skip the updating sellAmount.\n        // This case occurs if the pool is being chained, in which the funds have been sent directly to the pool\n        if (bps != 0) {\n            // We don't care about phantom overflow here because reserves are\n            // limited to 112 bits. Any token balance that would overflow here would\n            // also break UniV2.\n            // It is *possible* to set `bps` above the basis and therefore\n            // cause an overflow on this multiplication. However, `bps` is\n            // passed as authenticated calldata, so this is a GIGO error that we\n            // do not attempt to fix.\n            unchecked {\n                sellAmount = (IERC20(sellToken).balanceOf(address(this)) * bps).unsafeDiv(10_000);\n            }\n        }\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n\n            // transfer sellAmount (a non zero amount) of sellToken to the pool\n            if sellAmount {\n                mstore(ptr, ERC20_TRANSFER_SELECTOR)\n                mstore(add(ptr, 0x20), pool)\n                mstore(add(ptr, 0x40), sellAmount)\n                // ...||ERC20_TRANSFER_SELECTOR|pool|sellAmount|\n                if iszero(call(gas(), sellToken, 0, add(ptr, 0x1c), 0x44, 0x00, 0x20)) { bubbleRevert(ptr) }\n                if iszero(or(iszero(returndatasize()), and(iszero(lt(returndatasize(), 0x20)), eq(mload(0x00), 1)))) {\n                    revert(0, 0)\n                }\n            }\n\n            // get pool reserves\n            let sellReserve\n            let buyReserve\n            mstore(0x00, UNI_PAIR_RESERVES_SELECTOR)\n            // ||UNI_PAIR_RESERVES_SELECTOR|\n            if iszero(staticcall(gas(), pool, 0x1c, 0x04, 0x00, 0x40)) { bubbleRevert(ptr) }\n            if lt(returndatasize(), 0x40) { revert(0, 0) }\n            {\n                let r := shl(5, zeroForOne)\n                buyReserve := mload(r)\n                sellReserve := mload(xor(0x20, r))\n            }\n\n            // Update the sell amount in the following cases:\n            //   the funds are in the pool already (flagged by sellAmount being 0)\n            //   the sell token has a fee (flagged by sellTokenHasFee)\n            if or(iszero(sellAmount), sellTokenHasFee) {\n                // retrieve the sellToken balance of the pool\n                mstore(0x00, ERC20_BALANCEOF_SELECTOR)\n                mstore(0x20, and(0xffffffffffffffffffffffffffffffffffffffff, pool))\n                // ||ERC20_BALANCEOF_SELECTOR|pool|\n                if iszero(staticcall(gas(), sellToken, 0x1c, 0x24, 0x00, 0x20)) { bubbleRevert(ptr) }\n                if lt(returndatasize(), 0x20) { revert(0, 0) }\n                let bal := mload(0x00)\n\n                // determine real sellAmount by comparing pool's sellToken balance to reserve amount\n                if lt(bal, sellReserve) {\n                    mstore(0x00, 0x4e487b71) // selector for `Panic(uint256)`\n                    mstore(0x20, 0x11) // panic code for arithmetic underflow\n                    revert(0x1c, 0x24)\n                }\n                sellAmount := sub(bal, sellReserve)\n            }\n\n            // compute buyAmount based on sellAmount and reserves\n            let sellAmountWithFee := mul(sellAmount, sub(10000, feeBps))\n            buyAmount := div(mul(sellAmountWithFee, buyReserve), add(sellAmountWithFee, mul(sellReserve, 10000)))\n            let swapCalldata := add(ptr, 0x1c)\n            // set up swap call selector and empty callback data\n            mstore(ptr, UNI_PAIR_SWAP_SELECTOR)\n            mstore(add(ptr, 0x80), 0x80) // offset to length of data\n            mstore(add(ptr, 0xa0), 0) // length of data\n\n            // set amount0Out and amount1Out\n            {\n                // If `zeroForOne`, offset is 0x24, else 0x04\n                let offset := add(0x04, shl(5, zeroForOne))\n                mstore(add(swapCalldata, offset), buyAmount)\n                mstore(add(swapCalldata, xor(0x20, offset)), 0)\n            }\n\n            mstore(add(swapCalldata, 0x44), and(0xffffffffffffffffffffffffffffffffffffffff, recipient))\n            // ...||UNI_PAIR_SWAP_SELECTOR|amount0Out|amount1Out|recipient|data|\n\n            // perform swap at the pool sending bought tokens to the recipient\n            if iszero(call(gas(), pool, 0, swapCalldata, 0xa4, 0, 0)) { bubbleRevert(swapCalldata) }\n\n            // revert with the return data from the most recent call\n            function bubbleRevert(p) {\n                returndatacopy(p, 0, returndatasize())\n                revert(p, returndatasize())\n            }\n        }\n        if (buyAmount < minBuyAmount) {\n            revert TooMuchSlippage(\n                IERC20(zeroForOne ? IUniV2Pair(pool).token1() : IUniV2Pair(pool).token0()), minBuyAmount, sellAmount\n            );\n        }\n    }\n}\n"}, "src/vendor/SafeTransferLib.sol": {"content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    uint32 private constant _TRANSFER_FROM_FAILED_SELECTOR = 0x7939f424; // bytes4(keccak256(\"TransferFromFailed()\"))\n    uint32 private constant _TRANSFER_FAILED_SELECTOR = 0x90b8ec18; // bytes4(keccak256(\"TransferFailed()\"))\n    uint32 private constant _APPROVE_FAILED_SELECTOR = 0x3e3f8f73; // bytes4(keccak256(\"ApproveFailed()\"))\n\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address payable to, uint256 amount) internal {\n        assembly (\"memory-safe\") {\n            // Transfer the ETH and store if it succeeded or not.\n            if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\n                let freeMemoryPointer := mload(0x40)\n                returndatacopy(freeMemoryPointer, 0, returndatasize())\n                revert(freeMemoryPointer, returndatasize())\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 amount) internal {\n        assembly (\"memory-safe\") {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n            // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n            if iszero(call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)) {\n                returndatacopy(freeMemoryPointer, 0, returndatasize())\n                revert(freeMemoryPointer, returndatasize())\n            }\n            // We check that the call either returned exactly 1 (can't just be non-zero data), or had no\n            // return data.\n            if iszero(or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize()))) {\n                mstore(0, _TRANSFER_FROM_FAILED_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\n        assembly (\"memory-safe\") {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n            // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n            if iszero(call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)) {\n                returndatacopy(freeMemoryPointer, 0, returndatasize())\n                revert(freeMemoryPointer, returndatasize())\n            }\n            // We check that the call either returned exactly 1 (can't just be non-zero data), or had no\n            // return data.\n            if iszero(or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize()))) {\n                mstore(0, _TRANSFER_FAILED_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    function safeApprove(IERC20 token, address to, uint256 amount) internal {\n        assembly (\"memory-safe\") {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n            // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n            if iszero(call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)) {\n                returndatacopy(freeMemoryPointer, 0, returndatasize())\n                revert(freeMemoryPointer, returndatasize())\n            }\n            // We check that the call either returned exactly 1 (can't just be non-zero data), or had no\n            // return data.\n            if iszero(or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize()))) {\n                mstore(0, _APPROVE_FAILED_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    function safeApproveIfBelow(IERC20 token, address spender, uint256 amount) internal {\n        uint256 allowance = token.allowance(address(this), spender);\n        if (allowance < amount) {\n            if (allowance != 0) {\n                safeApprove(token, spender, 0);\n            }\n            safeApprove(token, spender, type(uint256).max);\n        }\n    }\n}\n"}, "src/allowanceholder/AllowanceHolderContext.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Context} from \"../Context.sol\";\nimport {IAllowanceHolder} from \"./IAllowanceHolder.sol\";\n\nabstract contract AllowanceHolderContext is Context {\n    IAllowanceHolder internal constant _ALLOWANCE_HOLDER = IAllowanceHolder(0x0000000000001fF3684f28c67538d4D072C22734);\n\n    function _isForwarded() internal view virtual override returns (bool) {\n        return super._isForwarded() || super._msgSender() == address(_ALLOWANCE_HOLDER);\n    }\n\n    function _msgSender() internal view virtual override returns (address sender) {\n        sender = super._msgSender();\n        if (sender == address(_ALLOWANCE_HOLDER)) {\n            // ERC-2771 like usage where the _trusted_ `AllowanceHolder` has appended the appropriate\n            // msg.sender to the msg data\n            assembly (\"memory-safe\") {\n                sender := shr(0x60, calldataload(sub(calldatasize(), 0x14)))\n            }\n        }\n    }\n\n    // this is here to avoid foot-guns and make it very explicit that we intend\n    // to pass the confused deputy check in AllowanceHolder\n    function balanceOf(address) external pure {\n        assembly (\"memory-safe\") {\n            mstore8(0x00, 0x00)\n            revert(0x00, 0x01)\n        }\n    }\n}\n"}, "src/utils/UnsafeMath.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nlibrary UnsafeMath {\n    function unsafeInc(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return x + 1;\n        }\n    }\n\n    function unsafeInc(int256 x) internal pure returns (int256) {\n        unchecked {\n            return x + 1;\n        }\n    }\n\n    function unsafeNeg(int256 x) internal pure returns (int256) {\n        unchecked {\n            return -x;\n        }\n    }\n\n    function unsafeDiv(uint256 numerator, uint256 denominator) internal pure returns (uint256 quotient) {\n        assembly (\"memory-safe\") {\n            quotient := div(numerator, denominator)\n        }\n    }\n\n    function unsafeDiv(int256 numerator, int256 denominator) internal pure returns (int256 quotient) {\n        assembly (\"memory-safe\") {\n            quotient := sdiv(numerator, denominator)\n        }\n    }\n\n    function unsafeMod(uint256 numerator, uint256 denominator) internal pure returns (uint256 remainder) {\n        assembly (\"memory-safe\") {\n            remainder := mod(numerator, denominator)\n        }\n    }\n\n    function unsafeMod(int256 numerator, int256 denominator) internal pure returns (int256 remainder) {\n        assembly (\"memory-safe\") {\n            remainder := smod(numerator, denominator)\n        }\n    }\n\n    function unsafeMulMod(uint256 a, uint256 b, uint256 m) internal pure returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            r := mulmod(a, b, m)\n        }\n    }\n\n    function unsafeAddMod(uint256 a, uint256 b, uint256 m) internal pure returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            r := addmod(a, b, m)\n        }\n    }\n}\n"}, "src/utils/Panic.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nlibrary Panic {\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71) // selector for `Panic(uint256)`\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n\n    // https://docs.soliditylang.org/en/latest/control-structures.html#panic-via-assert-and-error-via-require\n    uint8 internal constant GENERIC = 0x00;\n    uint8 internal constant ASSERT_FAIL = 0x01;\n    uint8 internal constant ARITHMETIC_OVERFLOW = 0x11;\n    uint8 internal constant DIVISION_BY_ZERO = 0x12;\n    uint8 internal constant ENUM_CAST = 0x21;\n    uint8 internal constant CORRUPT_STORAGE_ARRAY = 0x22;\n    uint8 internal constant POP_EMPTY_ARRAY = 0x31;\n    uint8 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    uint8 internal constant OUT_OF_MEMORY = 0x41;\n    uint8 internal constant ZERO_FUNCTION_POINTER = 0x51;\n}\n"}, "src/utils/AddressDerivation.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Panic} from \"./Panic.sol\";\nimport {UnsafeMath} from \"./UnsafeMath.sol\";\n\nlibrary AddressDerivation {\n    using UnsafeMath for uint256;\n\n    uint256 internal constant _SECP256K1_P = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;\n    uint256 internal constant _SECP256K1_N = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;\n    uint256 internal constant SECP256K1_GX = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798;\n    uint256 internal constant SECP256K1_GY = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8;\n\n    error InvalidCurve(uint256 x, uint256 y);\n\n    // keccak256(abi.encodePacked(ECMUL([x, y], k)))[12:]\n    function deriveEOA(uint256 x, uint256 y, uint256 k) internal pure returns (address) {\n        if (k == 0) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        if (k >= _SECP256K1_N || x >= _SECP256K1_P || y >= _SECP256K1_P) {\n            Panic.panic(Panic.ARITHMETIC_OVERFLOW);\n        }\n\n        // +/-7 are neither square nor cube mod p, so we only have to check one\n        // coordinate against 0. if it is 0, then the other is too (the point at\n        // infinity) or the point is invalid\n        if (\n            x == 0\n                || y.unsafeMulMod(y, _SECP256K1_P)\n                    != x.unsafeMulMod(x, _SECP256K1_P).unsafeMulMod(x, _SECP256K1_P).unsafeAddMod(7, _SECP256K1_P)\n        ) {\n            revert InvalidCurve(x, y);\n        }\n\n        unchecked {\n            // https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384\n            return ecrecover(\n                bytes32(0), uint8(27 + (y & 1)), bytes32(x), bytes32(UnsafeMath.unsafeMulMod(x, k, _SECP256K1_N))\n            );\n        }\n    }\n\n    // keccak256(RLP([deployer, nonce]))[12:]\n    function deriveContract(address deployer, uint64 nonce) internal pure returns (address result) {\n        if (nonce == 0) {\n            assembly (\"memory-safe\") {\n                mstore(\n                    0x00,\n                    or(\n                        0xd694000000000000000000000000000000000000000080,\n                        shl(8, and(0xffffffffffffffffffffffffffffffffffffffff, deployer))\n                    )\n                )\n                result := keccak256(0x09, 0x17)\n            }\n        } else if (nonce < 0x80) {\n            assembly (\"memory-safe\") {\n                // we don't care about dirty bits in `deployer`; they'll be overwritten later\n                mstore(0x14, deployer)\n                mstore(0x00, 0xd694)\n                mstore8(0x34, nonce)\n                result := keccak256(0x1e, 0x17)\n            }\n        } else {\n            // compute ceil(log_256(nonce)) + 1\n            uint256 nonceLength = 8;\n            unchecked {\n                if ((uint256(nonce) >> 32) != 0) {\n                    nonceLength += 32;\n                    if (nonce == type(uint64).max) {\n                        Panic.panic(Panic.ARITHMETIC_OVERFLOW);\n                    }\n                }\n                if ((uint256(nonce) >> 8) >= (1 << nonceLength)) {\n                    nonceLength += 16;\n                }\n                if (uint256(nonce) >= (1 << nonceLength)) {\n                    nonceLength += 8;\n                }\n                // ceil\n                if ((uint256(nonce) << 8) >= (1 << nonceLength)) {\n                    nonceLength += 8;\n                }\n                // bytes, not bits\n                nonceLength >>= 3;\n            }\n            assembly (\"memory-safe\") {\n                // we don't care about dirty bits in `deployer` or `nonce`. they'll be overwritten later\n                mstore(nonceLength, nonce)\n                mstore8(0x20, add(0x7f, nonceLength))\n                mstore(0x00, deployer)\n                mstore8(0x0a, add(0xd5, nonceLength))\n                mstore8(0x0b, 0x94)\n                result := keccak256(0x0a, add(0x16, nonceLength))\n            }\n        }\n    }\n\n    // keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, initHash))[12:]\n    function deriveDeterministicContract(address deployer, bytes32 salt, bytes32 initHash)\n        internal\n        pure\n        returns (address result)\n    {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // we don't care about dirty bits in `deployer`; they'll be overwritten later\n            mstore(ptr, deployer)\n            mstore8(add(ptr, 0x0b), 0xff)\n            mstore(add(ptr, 0x20), salt)\n            mstore(add(ptr, 0x40), initHash)\n            result := keccak256(add(ptr, 0x0b), 0x55)\n        }\n    }\n}\n"}, "src/vendor/FullMath.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {UnsafeMath} from \"../utils/UnsafeMath.sol\";\nimport {Panic} from \"../utils/Panic.sol\";\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\n/// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\nlibrary FullMath {\n    using UnsafeMath for uint256;\n\n    /// @notice 512-bit multiply [prod1 prod0] = a * b\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return prod0 Least significant 256 bits of the product\n    /// @return prod1 Most significant 256 bits of the product\n    /// @return remainder Remainder of full-precision division\n    function _mulDivSetup(uint256 a, uint256 b, uint256 denominator)\n        private\n        pure\n        returns (uint256 prod0, uint256 prod1, uint256 remainder)\n    {\n        // Compute the product mod 2**256 and mod 2**256 - 1 then use the Chinese\n        // Remainder Theorem to reconstruct the 512 bit result. The result is stored\n        // in two 256 variables such that product = prod1 * 2**256 + prod0\n        assembly (\"memory-safe\") {\n            // Full-precision multiplication\n            {\n                let mm := mulmod(a, b, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n                prod0 := mul(a, b)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            remainder := mulmod(a, b, denominator)\n        }\n    }\n\n    /// @notice 512-bit by 256-bit division.\n    /// @param prod0 Least significant 256 bits of the product\n    /// @param prod1 Most significant 256 bits of the product\n    /// @param denominator The divisor\n    /// @param remainder Remainder of full-precision division\n    /// @return The 256-bit result\n    /// @dev Overflow and division by zero aren't checked and are GIGO errors\n    function _mulDivInvert(uint256 prod0, uint256 prod1, uint256 denominator, uint256 remainder)\n        private\n        pure\n        returns (uint256)\n    {\n        uint256 inv;\n        assembly (\"memory-safe\") {\n            // Make division exact by rounding [prod1 prod0] down to a multiple of\n            // denominator\n            // Subtract 256 bit number from 512 bit number\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n\n            // Factor powers of two out of denominator\n            {\n                // Compute largest power of two divisor of denominator.\n                // Always >= 1.\n                let twos := and(sub(0, denominator), denominator)\n\n                // Divide denominator by power of two\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by the factors of two\n                prod0 := div(prod0, twos)\n                // Shift in bits from prod1 into prod0. For this we need to flip `twos`\n                // such that it is 2**256 / twos.\n                // If twos is zero, then it becomes one\n                twos := add(div(sub(0, twos), twos), 1)\n                prod0 := or(prod0, mul(prod1, twos))\n            }\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse modulo 2**256\n            // such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct correct for\n            // four bits. That is, denominator * inv = 1 mod 2**4\n            inv := xor(mul(3, denominator), 2)\n\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv := mul(inv, sub(2, mul(denominator, inv))) // inverse mod 2**8\n            inv := mul(inv, sub(2, mul(denominator, inv))) // inverse mod 2**16\n            inv := mul(inv, sub(2, mul(denominator, inv))) // inverse mod 2**32\n            inv := mul(inv, sub(2, mul(denominator, inv))) // inverse mod 2**64\n            inv := mul(inv, sub(2, mul(denominator, inv))) // inverse mod 2**128\n            inv := mul(inv, sub(2, mul(denominator, inv))) // inverse mod 2**256\n        }\n\n        // Because the division is now exact we can divide by multiplying with the\n        // modular inverse of denominator. This will give us the correct result\n        // modulo 2**256. Since the precoditions guarantee that the outcome is less\n        // than 2**256, this is the final result.  We don't need to compute the high\n        // bits of the result and prod1 is no longer required.\n        unchecked {\n            return prod0 * inv;\n        }\n    }\n\n    /// @notice Calculates a\u00d7b\u00f7denominator with full precision then rounds towards 0. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return The 256-bit result\n    function mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256) {\n        (uint256 prod0, uint256 prod1, uint256 remainder) = _mulDivSetup(a, b, denominator);\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n        if (denominator <= prod1) {\n            Panic.panic(denominator == 0 ? Panic.DIVISION_BY_ZERO : Panic.ARITHMETIC_OVERFLOW);\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            return prod0.unsafeDiv(denominator);\n        }\n        return _mulDivInvert(prod0, prod1, denominator, remainder);\n    }\n\n    /// @notice Calculates a\u00d7b\u00f7denominator with full precision then rounds towards 0. Overflowing a uint256 or denominator == 0 are GIGO errors\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return The 256-bit result\n    function unsafeMulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256) {\n        (uint256 prod0, uint256 prod1, uint256 remainder) = _mulDivSetup(a, b, denominator);\n        // Overflow and zero-division checks are skipped\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            return prod0.unsafeDiv(denominator);\n        }\n        return _mulDivInvert(prod0, prod1, denominator, remainder);\n    }\n}\n"}, "lib/permit2/src/interfaces/IEIP712.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IEIP712 {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"}, "src/utils/Revert.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nlibrary Revert {\n    function _revert(bytes memory reason) internal pure {\n        assembly (\"memory-safe\") {\n            revert(add(reason, 0x20), mload(reason))\n        }\n    }\n\n    function maybeRevert(bool success, bytes memory reason) internal pure {\n        if (!success) {\n            _revert(reason);\n        }\n    }\n}\n"}, "src/allowanceholder/IAllowanceHolder.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IAllowanceHolder {\n    /// @notice Executes against `target` with the `data` payload. Prior to execution, token permits\n    ///         are temporarily stored for the duration of the transaction. These permits can be\n    ///         consumed by the `operator` during the execution\n    /// @notice `operator` consumes the funds during its operations by calling back into\n    ///         `AllowanceHolder` with `transferFrom`, consuming a token permit.\n    /// @dev Neither `exec` nor `transferFrom` check that `token` contains code.\n    /// @dev msg.sender is forwarded to target appended to the msg data (similar to ERC-2771)\n    /// @param operator An address which is allowed to consume the token permits\n    /// @param token The ERC20 token the caller has authorised to be consumed\n    /// @param amount The quantity of `token` the caller has authorised to be consumed\n    /// @param target A contract to execute operations with `data`\n    /// @param data The data to forward to `target`\n    /// @return result The returndata from calling `target` with `data`\n    /// @notice If calling `target` with `data` reverts, the revert is propagated\n    function exec(address operator, address token, uint256 amount, address payable target, bytes calldata data)\n        external\n        payable\n        returns (bytes memory result);\n\n    /// @notice The counterpart to `exec` which allows for the consumption of token permits later\n    ///         during execution\n    /// @dev *DOES NOT* check that `token` contains code. This function vacuously succeeds if\n    ///      `token` is empty.\n    /// @dev can only be called by the `operator` previously registered in `exec`\n    /// @param token The ERC20 token to transfer\n    /// @param owner The owner of tokens to transfer\n    /// @param recipient The destination/beneficiary of the ERC20 `transferFrom`\n    /// @param amount The quantity of `token` to transfer`\n    /// @return true\n    function transferFrom(address token, address owner, address recipient, uint256 amount) external returns (bool);\n}\n"}}, "settings": {"remappings": ["solmate/=lib/solmate/", "permit2/=lib/permit2/", "forge-std/=lib/forge-std/src/", "forge-gas-snapshot/=lib/forge-gas-snapshot/src/", "ds-test/=lib/forge-std/lib/ds-test/src/"], "optimizer": {"enabled": true}, "metadata": {"useLiteralContent": false, "bytecodeHash": "none", "appendCBOR": false}, "outputSelection": {"*": {"*": ["evm.legacyAssembly"]}}, "evmVersion": "cancun", "viaIR": false, "libraries": {}}}