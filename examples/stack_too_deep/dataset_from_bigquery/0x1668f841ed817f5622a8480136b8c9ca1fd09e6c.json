{"language": "Solidity", "sources": {"@openzeppelin/contracts/access/Ownable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"}, "@openzeppelin/contracts/interfaces/IERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../token/ERC20/IERC20.sol\";\n"}, "@openzeppelin/contracts/interfaces/IERC721.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../token/ERC721/IERC721.sol\";\n"}, "@openzeppelin/contracts/security/ReentrancyGuard.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"}, "@openzeppelin/contracts/token/ERC20/IERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"}, "@openzeppelin/contracts/token/ERC721/IERC721.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"}, "@openzeppelin/contracts/utils/Context.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"}, "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"}, "@openzeppelin/contracts/utils/introspection/IERC165.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"}, "contracts/IGT.sol": {"content": "// SPDX-License-Identifier: MIT\n/**\n * @dev @brougkr\n */\npragma solidity ^0.8.30;\ninterface IGT \n{ \n    /**\n     * @dev { Golden Token Burn }\n     */\n    function _LiveMintBurn(uint TicketID) external returns (address Recipient); \n}"}, "contracts/IMinter.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\ninterface IMinter \n{ \n    function purchase(uint256 _projectId) payable external returns (uint tokenID); \n    function purchaseTo(address _to, uint _projectId) payable external returns (uint tokenID);\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\n}"}, "contracts/IMP.sol": {"content": "// SPDX-License-Identifier: MIT\n/**\n * @dev @brougkr\n */\npragma solidity ^0.8.30;\ninterface IMP \n{ \n    /**\n     * @dev { For Instances Where Golden Token Or Artists Have A Bespoke Mint Pass Contract }\n     */\n    function _LiveMintBurn(uint TicketID) external returns (address Recipient, uint ArtistID); \n}"}, "contracts/IPoly.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\ninterface IPoly \n{ \n    // without delegate.cash\n    function purchaseTo(\n        address _to, \n        uint _projectId, \n        address _ownedNFTAddress, \n        uint _ownedNFTTokenID\n    ) payable external returns (uint tokenID);\n}"}, "contracts/LiveMint.sol": {"content": "// SPDX-License-Identifier: MIT\n/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\n/**\n * @dev: @brougkr\n */\npragma solidity ^0.8.30;\nimport { IERC721 } from \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { MerkleProof } from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport { IMinter } from \"./IMinter.sol\";\nimport { IMP } from \"./IMP.sol\";\nimport { IGT } from \"./IGT.sol\";\nimport { IPoly } from \"./IPoly.sol\";\ncontract LiveMint is Ownable, ReentrancyGuard\n{  \n    struct City\n    {\n        string _Name;         // _Name\n        uint _QRCurrentIndex; // _QRCurrentIndex (Should be Always Be (333 * (City# % 7)) + 1000\n        address _ERC20;       // _ERC20 \n        bytes32 _Root;        // _Root\n    }\n\n    struct Artist\n    {\n        address _MintPass;        // _MintPass\n        address _Minter;          // _Minter\n        address _PolyptychSource; // _PolyptychSource\n        uint _MaxSupply;          // _MaxSupply\n        uint _MintPassProjectID;  // _MintPassProjectID\n        uint _ArtBlocksProjectID; // _ArtBlocksProjectID \n        uint _PolyStart;          // _PolyStart\n        uint _PolyEnd;            // _PolyEnd\n    }\n\n    struct User\n    {\n        bool _Eligible;   // _Eligible\n        uint _Allocation; // _Allocation\n    }\n\n    /*-------------------*/\n    /*  STATE VARIABLES  */\n    /*-------------------*/\n\n    bytes32 private constant _AUTHORIZED = keccak256(\"AUTHORIZED\");                      // Authorized Role\n    bytes32 private constant _MINTER_ROLE = keccak256(\"MINTER_ROLE\");                    // Minter Role\n    bytes32 private constant _ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");                      // Admin Role\n    uint private constant ONE_MILLION = 1000000;                                         // One Million         \n    address public _GOLDEN_TOKEN = 0x985e1932FFd2aA4bC9cE611DFe12816A248cD2cE;           // Golden Token Address\n    address public _CITIZEN_MINTER = 0xDd06d8483868Cd0C5E69C24eEaA2A5F2bEaFd42b;         // ArtBlocks Minter Contract\n    address public _BRT_MULTISIG = 0xB96E81f80b3AEEf65CB6d0E280b15FD5DBE71937;           // BRT Multisig\n    address public _ERC20Factory;                                                        // ERC20 Factory\n    address public _MintPassFactory;                                                     // MintPass Factory    \n    uint public _CurrentCityIndex = 6;                                                   // Current City Index\n    uint public _UniqueArtistsInvoked;                                                   // Unique Artists Invoked\n\n    /*-------------------*/\n    /*     MAPPINGS      */\n    /*-------------------*/\n    \n    mapping(uint => Artist) public Artists;                              // [ArtistID] => Artist\n    mapping(uint => City) public Cities;                                 // [CityIndex] => City Struct\n    mapping(uint => mapping(address => bool)) public _QRRedeemed;        // [CityIndex][Wallet] => If User Has Redeemed QR\n    mapping(uint => mapping(address => uint)) public _QRAllocation;      // [CityIndex][Wallet] => Wallet's QR Code Allocation\n    mapping(uint => mapping(uint => address)) public _BrightListCitizen; // [CityIndex][TicketID] => Address Of CryptoCitizen Minting Recipient \n    mapping(uint => mapping(uint => address)) public _BrightListArtist;  // [ArtistID][TicketID] => Address Of Artist NFT Recipient\n    mapping(uint => mapping(uint => string)) public _DataArtists;        // [ArtistID][TicketID] => Artist Data\n    mapping(uint => mapping(uint => string)) public _DataCitizens;       // [CityIndex][TicketID] => Data For Golden Token Checkins\n    mapping(uint => mapping(uint => uint)) public _MintedTokenIDCitizen; // [CityIndex][TicketID] => MintedTokenID\n    mapping(uint => mapping(uint => uint)) public _MintedTokenIDArtist;  // [ArtistID][TicketID] => MintedTokenID\n    mapping(uint => mapping(uint => bool)) public _MintedArtist;         // [ArtistID][TicketID] => If Minted\n    mapping(uint => mapping(uint => bool)) public _MintedCitizen;        // [CityIndex][TicketID] => If Golden Ticket ID Has Minted Or Not\n    mapping(address => bytes32) public Role;                             // [Wallet] => BRT Minter Role\n    mapping(uint=>uint) public AmountRemaining;                          // [ArtistID] => Mints Remaining\n    mapping(uint=>mapping(uint=>uint)) public _ArtBlocksProjectID;       // [ArtistID][TicketID] => ArtBlocksProjectID\n\n    /*-------------------*/\n    /*      EVENTS       */\n    /*-------------------*/\n\n    /**\n     * @dev Emitted When `Redeemer` IRL-mints CryptoCitizen Corresponding To Their Redeemed `TicketID`.\n     **/\n    event LiveMintComplete(address indexed Redeemer, uint TicketID, uint TokenID, string Data);\n\n    /**\n     * @dev Emitted When `Redeemer` IRL-mints A Artist NFT Corresponding To Their Redeemed `TicketID`.\n     */\n    event LiveMintCompleteArtist(address Recipient, uint ArtistID, uint TicketID, uint MintedWorkTokenID);\n\n    /**\n     * @dev Emitted When An Artist Mint Pass Is Redeemed\n     */\n    event ArtistMintPassRedeemed(address Redeemer, uint ArtistIDs, uint TicketIDs, string Data, string Type);\n\n    /**\n     * @dev Emitted When `Redeemer` Redeems Golden Token Corresponding To `TicketID` \n     **/\n    event GoldenTokenRedeemed(address indexed Redeemer, uint TicketID, string Data, string Type);\n\n    /**\n     * @dev Emitted When `Redeemer` Redeems Golden Token Corresponding To `TicketID` \n     **/\n    event QRRedeemed(address indexed Redeemer, uint TicketID, string Data, string Type);\n    \n    /**\n     * @dev Emitted When A Reservation Is Wiped\n     */\n    event ReservationWiped(uint TicketID, address Redeemer, string Data);\n\n    /**\n     * @dev Emitted When A Contract Is Authorized\n     */\n    event AuthorizedContract(address NewAddress);\n\n    /**\n     * @dev Emitted When A Contract Is Deauthorized\n     */\n    event DeauthorizedContract(address NewAddress);\n\n\n    /*-------------------*/\n    /*    CONSTRUCTOR    */\n    /*-------------------*/\n\n    constructor()\n    { \n        Cities[0]._Name = \"CryptoGalacticans\"; \n        Cities[1]._Name = \"CryptoVenetians\";\n        Cities[2]._Name = \"CryptoNewYorkers\";\n        Cities[3]._Name = \"CryptoBerliners\";\n        Cities[4]._Name = \"CryptoLondoners\";\n        Cities[5]._Name = \"CryptoMexas\";\n        Cities[6]._Name = \"CryptoTokyites\";\n        Cities[7]._Name = \"CryptoCitizen City #8\";\n        Cities[8]._Name = \"CryptoCitizen City #9\";\n        Cities[9]._Name = \"CryptoCitizen City #10\";\n        Role[0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700] = _ADMIN_ROLE;  // `operator.brightmoments.eth`\n        Role[0x1A0a3E3AE390a0710f8A6d00587082273eA8F6C9] = _MINTER_ROLE; // BRT Minter #1\n        Role[0x4d8013b0c264034CBf22De9DF33e22f58D52F207] = _MINTER_ROLE; // BRT Minter #2\n        Role[0x4D9A8CF2fE52b8D49C7F7EAA87b2886c2bCB4160] = _MINTER_ROLE; // BRT Minter #3\n        Role[0x124fd966A0D83aA020D3C54AE2c9f4800b46F460] = _MINTER_ROLE; // BRT Minter #4\n        Role[0x100469feA90Ac1Fe1073E1B2b5c020A8413635c4] = _MINTER_ROLE; // BRT Minter #5\n        Role[0x756De4236373fd17652b377315954ca327412bBA] = _MINTER_ROLE; // BRT Minter #6\n        Role[0xc5Dfba6ef7803665C1BDE478B51Bd7eB257A2Cb9] = _MINTER_ROLE; // BRT Minter #7\n        Role[0xFBF32b29Bcf8fEe32d43a4Bfd3e7249daec457C0] = _MINTER_ROLE; // BRT Minter #8\n        Role[0xF2A15A83DEE7f03C70936449037d65a1C100FF27] = _MINTER_ROLE; // BRT Minter #9\n        Role[0x1D2BAB965a4bB72f177Cd641C7BacF3d8257230D] = _MINTER_ROLE; // BRT Minter #10\n        Role[0x2e51E8b950D72BDf003b58E357C2BA28FB77c7fB] = _MINTER_ROLE; // BRT Minter #11\n        Role[0x8a7186dECb91Da854090be8226222eA42c5eeCb6] = _MINTER_ROLE; // BRT Minter #12\n        Role[0x7603C5eed8e57Ad795ec5F0081eFB21d1eEBf937] = _MINTER_ROLE; // BRT Minter #13\n        Role[msg.sender] = _AUTHORIZED; // `operator.brightmoments.eth`\n        Role[0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700] = _AUTHORIZED;\n    }\n\n    /*-------------------*/\n    /*  PUBLIC FUNCTIONS */\n    /*-------------------*/\n\n    /**\n     * @dev Redeems Golden Tokens & BrightLists Address To Receive CryptoCitizen\n     **/\n    function RedeemGT (\n        uint[] calldata TicketIDs, \n        string[] calldata Data,\n        string[] calldata Type\n    ) external nonReentrant {\n        address Recipient;\n        for(uint x; x < TicketIDs.length; x++)\n        {\n            require(\n                IERC721(_GOLDEN_TOKEN).ownerOf(TicketIDs[x]) == msg.sender, \n                \"LiveMint: Sender Does Not Own Token With The Input Token ID\"\n            );\n            Recipient = IGT(_GOLDEN_TOKEN)._LiveMintBurn(TicketIDs[x]);\n            require(Recipient == msg.sender, \"LiveMint: Recipient Must Be Valid Owner\");\n            _BrightListCitizen[_CurrentCityIndex][TicketIDs[x]] = msg.sender;\n            _DataCitizens[_CurrentCityIndex][TicketIDs[x]] = Data[x];\n            emit GoldenTokenRedeemed(msg.sender, TicketIDs[x], Data[x], Type[x]);\n        }\n    }\n\n    /**\n     * @dev Redeems Artist Mint Pass & BrightLists Address To Receive A NFT\n     **/\n    function RedeemAP (\n        uint[] calldata ArtistIDs,\n        uint[] calldata TicketIDs, \n        string[] calldata Data,\n        string[] calldata Type\n    ) external nonReentrant {\n        address Recipient;\n        uint ArtBlocksProjectID;\n        uint Start;\n        uint MaxSupply;\n        uint End;\n        uint CurrentTicketID;\n        for(uint ArtistID; ArtistID < ArtistIDs.length; ArtistID++)\n        {\n            Start = Artists[ArtistIDs[ArtistID]]._MintPassProjectID * ONE_MILLION;\n            MaxSupply = Artists[ArtistIDs[ArtistID]]._MaxSupply;\n            End = Start + MaxSupply;\n            for(uint TicketID; TicketID < TicketIDs.length; TicketID++)\n            {\n                CurrentTicketID = TicketIDs[TicketID];\n                require(\n                    CurrentTicketID >= Start && CurrentTicketID < End,\n                    \"LiveMint: Ticket ID Is Not Valid For The Input Artist ID\"\n                );\n                require(\n                    IERC721(_MintPassFactory).ownerOf(CurrentTicketID) == msg.sender, \n                    \"LiveMint: Sender Does Not Own Token With The Input Token ID\"\n                );\n                require(\n                    _BrightListArtist[ArtistIDs[ArtistID]][CurrentTicketID] == address(0),\n                    \"LiveMint: Address Cannot Be Overwritten\"\n                );\n                (Recipient, ArtBlocksProjectID) = IMP(_MintPassFactory)._LiveMintBurn(CurrentTicketID);\n                _BrightListArtist[ArtistIDs[ArtistID]][CurrentTicketID] = Recipient;\n                _ArtBlocksProjectID[ArtistIDs[ArtistID]][CurrentTicketID] = ArtBlocksProjectID;\n                _DataArtists[ArtistIDs[ArtistID]][CurrentTicketID] = Data[TicketID];\n                emit ArtistMintPassRedeemed(Recipient, ArtistIDs[ArtistID], CurrentTicketID, Data[TicketID], Type[TicketID]);\n            }\n        }\n    } \n    \n    /**\n     * @dev Redeems Spot For IRL Minting\n     */\n    function RedeemQR(string calldata Data, string calldata Type, bytes32[] calldata Proof) external nonReentrant \n    {\n        require(readQREligibility(msg.sender, Proof), \"LiveMint: User Is Not Eligible To Redeem QR\");\n        if(_QRAllocation[_CurrentCityIndex][msg.sender] == 0) // User Is Able To Redeem Explicitly 1 QR Code\n        {\n            require(!_QRRedeemed[_CurrentCityIndex][msg.sender], \"LiveMint: User Has Already Redeemed\");\n            _DataCitizens[_CurrentCityIndex][Cities[_CurrentCityIndex]._QRCurrentIndex] = Data;\n            _BrightListCitizen[_CurrentCityIndex][Cities[_CurrentCityIndex]._QRCurrentIndex] = msg.sender;\n            emit QRRedeemed(msg.sender, Cities[_CurrentCityIndex]._QRCurrentIndex, Data, Type);\n            Cities[_CurrentCityIndex]._QRCurrentIndex++; \n        }\n        else // User Is Able To Redeem More Than 1 QR Code Because Their Integer Allocation > 0\n        {\n            uint _Allocation = _QRAllocation[_CurrentCityIndex][msg.sender];\n            uint _CurrentQR = Cities[_CurrentCityIndex]._QRCurrentIndex;\n            uint _Limit = _Allocation + _CurrentQR;\n            _QRAllocation[_CurrentCityIndex][msg.sender] = 0;\n            Cities[_CurrentCityIndex]._QRCurrentIndex = _Limit;\n            for(_CurrentQR; _CurrentQR < _Limit; _CurrentQR++)\n            {\n                _DataCitizens[_CurrentCityIndex][_CurrentQR] = Data;\n                _BrightListCitizen[_CurrentCityIndex][_CurrentQR] = msg.sender;\n                emit QRRedeemed(msg.sender, _CurrentQR, Data, Type);\n            }\n        }\n        _QRRedeemed[_CurrentCityIndex][msg.sender] = true;\n    }\n\n    /*--------------------*/\n    /*    LIVE MINTING    */\n    /*--------------------*/\n\n    /**\n     * @dev Batch Mints Verified Users On The Brightlist CryptoCitizens\n     * note: { For CryptoCitizen Cities }\n     */\n    function _LiveMintCitizen(uint[] calldata TicketIDs) external onlyMinter\n    {\n        address Recipient;\n        uint MintedWorkTokenID;\n        for(uint TicketID; TicketID < TicketIDs.length; TicketID++)\n        {\n            require(!_MintedCitizen[_CurrentCityIndex][TicketIDs[TicketID]], \"LiveMint: Golden Token Already Minted\");\n            if(_BrightListCitizen[_CurrentCityIndex][TicketIDs[TicketID]] != address(0))\n            {\n                Recipient = _BrightListCitizen[_CurrentCityIndex][TicketIDs[TicketID]];\n            }\n            else { Recipient = IGT(_GOLDEN_TOKEN)._LiveMintBurn(TicketIDs[TicketID]); }\n            require(Recipient != address(0), \"LiveMint: Invalid Recipient\");\n            _MintedCitizen[_CurrentCityIndex][TicketIDs[TicketID]] = true;\n            MintedWorkTokenID = IMinter(_CITIZEN_MINTER).purchaseTo(Recipient, _CurrentCityIndex);\n            _MintedTokenIDCitizen[_CurrentCityIndex][TicketIDs[TicketID]] = MintedWorkTokenID;\n            emit LiveMintComplete(Recipient, TicketIDs[TicketID], MintedWorkTokenID, _DataCitizens[_CurrentCityIndex][TicketIDs[TicketID]]); \n        }\n    }\n\n    /**\n     * @dev Burns Artist Mint Pass In Exchange For The Minted Work\n     * note: { For Instances Where Multiple Artists Share The Same Mint Pass & Return (Recipient, ArtBlocksProjectID) }\n     */\n    function _LiveMintArtist(uint ArtistID, uint[] calldata TicketIDs) external onlyMinter\n    {\n        address Recipient;\n        address MintPass = Artists[ArtistID]._MintPass;\n        address Minter = Artists[ArtistID]._Minter;\n        uint ArtBlocksProjectID;\n        uint MintedWorkTokenID;\n        uint TicketID;\n        uint Start = Artists[ArtistID]._MintPassProjectID * ONE_MILLION;\n        uint MaxSupply = Artists[ArtistID]._MaxSupply;\n        uint End = Start + MaxSupply;\n        require(AmountRemaining[ArtistID] > 0, \"LiveMint: ArtistID Mint Limit Reached\");\n        require(TicketIDs.length <= AmountRemaining[ArtistID], \"LiveMint: TicketID Length Exceeds ArtistID Mint Limit\");\n        AmountRemaining[ArtistID] = AmountRemaining[ArtistID] - TicketIDs.length;\n        for(uint x; x < TicketIDs.length; x++)\n        {\n            TicketID = TicketIDs[x];\n            require(TicketID >= Start && TicketID < End, \"LiveMint: Ticket ID Is Not Valid For The Input Artist ID\");\n            require(!_MintedArtist[ArtistID][TicketID], \"LiveMint: Artist Mint Pass Already Minted\");\n            _MintedArtist[ArtistID][TicketID] = true;\n            if(_BrightListArtist[ArtistID][TicketID] == address(0))\n            {\n                (Recipient, ArtBlocksProjectID) = IMP(MintPass)._LiveMintBurn(TicketID);\n            }\n            else\n            {\n                Recipient = _BrightListArtist[ArtistID][TicketID];\n                ArtBlocksProjectID = _ArtBlocksProjectID[ArtistID][TicketID];\n            }\n            MintedWorkTokenID = IMinter(Minter).purchaseTo(Recipient, ArtBlocksProjectID);\n            _MintedTokenIDArtist[ArtistID][TicketID] = MintedWorkTokenID;\n            emit LiveMintCompleteArtist(Recipient, ArtistID, TicketID, MintedWorkTokenID);\n        }\n    }\n\n    /**\n     * @dev Batch Mints Artists With ArtBlocks Polyptych Minter\n     */\n    function _LiveMintArtistPoly(uint ArtistID, uint[] calldata TicketIDs) external onlyMinter\n    {\n        address Source = Artists[ArtistID]._PolyptychSource;\n        address Minter = Artists[ArtistID]._Minter;\n        uint ArtBlocksProjectID = Artists[ArtistID]._ArtBlocksProjectID;\n        uint PolyStart = Artists[ArtistID]._PolyStart;\n        uint PolyEnd = Artists[ArtistID]._PolyEnd;\n        require(Source != address(0), \"LiveMint: Invalid Minter Setup\");\n        require(AmountRemaining[ArtistID] > 0, \"LiveMint: ArtistID Mint Limit Reached\");\n        require(TicketIDs.length <= AmountRemaining[ArtistID], \"LiveMint: TicketID [] Length Exceeds ArtistID Mint Limit\");\n        address Recipient;\n        uint MintedWorkTokenID;\n        uint TicketID;\n        AmountRemaining[ArtistID] = AmountRemaining[ArtistID] - TicketIDs.length;\n        for(uint x; x < TicketIDs.length; x++)\n        {\n            TicketID = TicketIDs[x];\n            require(!_MintedArtist[ArtistID][TicketID], \"LiveMint: Input TicketID Already Minted\");\n            _MintedArtist[ArtistID][TicketID] = true;\n            require(TicketID >= PolyStart && TicketID <= PolyEnd, \"LiveMint: Input TicketID Is Not Valid For The Input Artist ID\");\n            Recipient = IERC721(Source).ownerOf(TicketID);\n            require(Recipient != address(0), \"LiveMint: Invalid Recipient\");\n            MintedWorkTokenID = IPoly(Minter).purchaseTo(Recipient, ArtBlocksProjectID, Source, TicketID);\n            _MintedTokenIDArtist[ArtistID][TicketID] = MintedWorkTokenID;\n            emit LiveMintCompleteArtist(Recipient, ArtistID, TicketID, MintedWorkTokenID);\n        }\n    }\n\n    /*-------------------*/\n    /*  OWNER FUNCTIONS  */\n    /*-------------------*/\n\n    /**\n     * @dev Grants Address BRT Minter Role\n     **/\n    function __AddMinter(address Minter) external onlyOwner { Role[Minter] = _MINTER_ROLE; }\n    \n    /**\n     * @dev Deactivates Address From BRT Minter Role\n     **/\n    function __RemoveMinter(address Minter) external onlyOwner { Role[Minter] = 0x0; }\n\n    /**\n     * @dev Changes The Mint Pass Factory Contract Address\n     */\n    function __ChangeMintPassFactory(address Contract) external onlyOwner { _MintPassFactory = Contract; }\n\n    /**\n     * @dev Changes Mint Pass Address For Artist LiveMints\n     */\n    function __ChangeMintPass(uint ProjectID, address Contract) external onlyOwner { Artists[ProjectID]._MintPass = Contract; }\n\n    /**\n     * @dev Changes Merkle Root For Citizen LiveMints\n     */\n    function __ChangeRootCitizen(bytes32 NewRoot) external onlyOwner { Cities[_CurrentCityIndex]._Root = NewRoot; }\n\n    /**\n     * @dev Overwrites QR Allocation\n     */\n    function __QRAllocationsOverwrite(address[] calldata Addresses, uint[] calldata Amounts) external onlyOwner\n    {\n        require(Addresses.length == Amounts.length, \"LiveMint: Input Arrays Must Match\");\n        for(uint x; x < Addresses.length; x++) { _QRAllocation[_CurrentCityIndex][Addresses[x]] = Amounts[x]; }\n    }\n\n    /**\n     * @dev Increments QR Allocations\n     */\n    function __QRAllocationsIncrement(address[] calldata Addresses, uint[] calldata Amounts) external onlyOwner\n    {\n        require(Addresses.length == Amounts.length, \"LiveMint: Input Arrays Must Match\");\n        for(uint x; x < Addresses.length; x++) { _QRAllocation[_CurrentCityIndex][Addresses[x]] += Amounts[x]; }\n    }\n\n    /**\n     * @dev Mints To Multisig\n     */\n    function __QRAllocationsSetNoShow(uint[] calldata TicketIDs) external onlyOwner\n    {\n        for(uint TicketIndex; TicketIndex < TicketIDs.length; TicketIndex++)\n        {\n            require(!_MintedCitizen[_CurrentCityIndex][TicketIDs[TicketIndex]], \"LiveMint: Ticket ID Already Minted\");\n            _BrightListCitizen[_CurrentCityIndex][TicketIDs[TicketIndex]] = _BRT_MULTISIG;\n        }\n    }\n\n    /**\n     * @dev Changes ArtBlocks CryptoCitizen Minter Address\n     */\n    function __ChangeArtBlocksMinterCitizens(address ContractAddress) external onlyOwner { _CITIZEN_MINTER = ContractAddress; }\n\n    /**\n     * @dev Changes Multisig Address\n     */\n    function __ChangeMultisigAddress(address Recipient) external onlyOwner { _BRT_MULTISIG = Recipient; }\n\n    /**\n     * @dev Changes QR Current Index\n     */\n    function __ChangeQRIndex(uint NewIndex) external onlyOwner { Cities[_CurrentCityIndex]._QRCurrentIndex = NewIndex; }\n\n    /**\n     * @dev Batch Approves BRT For Purchasing\n     */\n    function __BatchApproveERC20(address[] calldata ERC20s, address[] calldata Operators) external onlyOwner\n    {\n        require(ERC20s.length == Operators.length, \"LiveMint: Arrays Must Be Equal Length\");\n        for(uint x; x < ERC20s.length; x++) { IERC20(ERC20s[x]).approve(Operators[x], 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff); }\n    }\n\n    /**\n     * @dev Instantiates New City\n     * note: CityIndex Always Corresponds To ArtBlocks ProjectID\n     */\n    function __NewCity (\n        string calldata Name,\n        uint CityIndex,\n        uint QRIndex,\n        address ERC20\n    ) external onlyOwner {\n        Cities[CityIndex] = City(\n            Name,\n            QRIndex,\n            ERC20,\n            0x6942069420694206942069420694206942069420694206942069420694206942\n        );\n    }\n\n    /**\n     * @dev Overrides An Artist\n     */\n    function __OverrideArtist(uint ArtistID, Artist memory NewArtist) external onlyOwner { Artists[ArtistID] = NewArtist; }\n\n    /**\n     * @dev Instantiates A New City\n     */\n    function __NewCityStruct(uint CityIndex, City memory NewCity) external onlyOwner { Cities[CityIndex] = NewCity; }\n\n    /**\n     * @dev Returns An Artist Struct\n     */\n    function __NewArtistStruct(uint ArtistID, Artist memory NewArtist) external onlyOwner { Artists[ArtistID] = NewArtist; }\n\n    /**\n     * @dev Changes The Minter Address For An Artist\n     */\n    function __NewArtistMinter(uint ArtistID, address Minter) external onlyOwner { Artists[ArtistID]._Minter = Minter; }\n\n    /**\n     * @dev Withdraws Any Ether Mistakenly Sent to Contract to Multisig\n     **/\n    function __WithdrawEther() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }\n\n    /**\n     * @dev Withdraws ERC20 Tokens to Multisig\n     **/\n    function __WithdrawERC20(address TokenAddress) external onlyOwner \n    { \n        IERC20 erc20Token = IERC20(TokenAddress);\n        uint balance = erc20Token.balanceOf(address(this));\n        require(balance > 0, \"0 ERC20 Balance At `TokenAddress`\");\n        erc20Token.transfer(msg.sender, balance);\n    }\n\n    /**\n     * @dev Withdraws Any NFT Mistakenly Sent To This Contract.\n     */\n    function __WithdrawERC721(address ContractAddress, address Recipient, uint TokenID) external onlyOwner\n    {\n        IERC721(ContractAddress).transferFrom(address(this), Recipient, TokenID);\n    }\n\n    /**\n     * @dev Authorizes A Contract To Mint\n     */\n    function ____AuthorizeContract(address NewAddress) external onlyOwner \n    { \n        Role[NewAddress] = _AUTHORIZED; \n        emit AuthorizedContract(NewAddress);\n    }\n\n    /**\n     * @dev Deauthorizes A Contract From Minting\n     */\n    function ___DeauthorizeContract(address NewAddress) external onlyOwner \n    { \n        Role[NewAddress] = 0x0; \n        emit DeauthorizedContract(NewAddress);\n    }\n    \n    /*-------------------*/\n    /*    PUBLIC VIEW    */\n    /*-------------------*/\n\n    /**\n     * @dev Returns If User Is Eligible To Redeem QR Code\n     */\n    function readEligibility(address Recipient, bytes32[] memory Proof) public view returns(User memory)\n    {\n        bool Eligible = readQREligibility(Recipient, Proof);\n        uint Allocation;\n        if(Eligible && _QRAllocation[_CurrentCityIndex][Recipient] > 0) { Allocation = _QRAllocation[_CurrentCityIndex][Recipient]; }\n        return User(Eligible, Allocation);\n    }\n\n    /**\n     * @dev Returns If User Is Eligible To Redeem QR Code\n     */\n    function readQREligibility(address Recipient, bytes32[] memory Proof) public view returns(bool)\n    {\n        bytes32 Leaf = keccak256(abi.encodePacked(Recipient));\n        bool BrightListEligible = MerkleProof.verify(Proof, Cities[_CurrentCityIndex]._Root, Leaf);\n        if(\n            (BrightListEligible && !_QRRedeemed[_CurrentCityIndex][Recipient])\n            || \n            (BrightListEligible && _QRAllocation[_CurrentCityIndex][Recipient] > 0)\n            \n        ) { return true; }\n        else { return false; }\n    }\n\n    /**\n     * @dev Returns An Array Of Unminted Golden Tokens\n     */\n    function readCitizenUnmintedTicketIDs() public view returns(uint[] memory)\n    {\n        uint[] memory UnmintedTokenIDs = new uint[](1000);\n        uint Counter;\n        uint CityIDBuffer = _CurrentCityIndex % 7 * 1000;\n        for(uint TokenID; TokenID < 1000; TokenID++)\n        {\n            uint _TokenID = TokenID + CityIDBuffer;\n            if(\n                !_MintedCitizen[_CurrentCityIndex][_TokenID]\n                &&\n                _BrightListCitizen[_CurrentCityIndex][_TokenID] != address(0)\n            ) \n            { \n                UnmintedTokenIDs[Counter] = _TokenID; \n                Counter++;\n            }\n        }\n        uint[] memory FormattedUnMintedTokenIDs = new uint[](Counter);\n        uint Found;\n        for(uint FormattedTokenID; FormattedTokenID < Counter; FormattedTokenID++)\n        {\n            if(UnmintedTokenIDs[FormattedTokenID] != 0 || (UnmintedTokenIDs[FormattedTokenID] == 0 && FormattedTokenID == 0))\n            {\n                FormattedUnMintedTokenIDs[Found] = UnmintedTokenIDs[FormattedTokenID];\n                Found++;\n            }\n        }\n        return FormattedUnMintedTokenIDs;\n    }\n\n    /**\n     * @dev Returns An Array Of Unminted Golden Tokens\n     */\n    function readCitizenMintedTicketIDs(uint CityID) public view returns(uint[] memory)\n    {\n        uint[] memory MintedTokenIDs = new uint[](1000);\n        uint Counter;\n        uint CityIDBuffer = (CityID % 7) * 1000;\n        uint _TicketID;\n        for(uint TicketID; TicketID < 1000; TicketID++)\n        {\n            _TicketID = TicketID + CityIDBuffer;\n            if(_MintedCitizen[CityID][_TicketID]) \n            { \n                MintedTokenIDs[Counter] = _TicketID; \n                Counter++;\n            }\n        }\n        uint[] memory FormattedMintedTokenIDs = new uint[](Counter);\n        uint Found;\n        for(uint FormattedTokenID; FormattedTokenID < Counter; FormattedTokenID++)\n        {\n            if(MintedTokenIDs[FormattedTokenID] != 0 || (MintedTokenIDs[FormattedTokenID] == 0 && FormattedTokenID == 0))\n            {\n                FormattedMintedTokenIDs[Found] = MintedTokenIDs[FormattedTokenID];\n                Found++;\n            }\n        }\n        return FormattedMintedTokenIDs;\n    }\n\n    /**\n     * @dev Returns A 2d Array Of Checked In & Unminted TicketIDs Awaiting A Mint\n     */\n    function readCitizenCheckedInTicketIDs() public view returns(uint[] memory TokenIDs)\n    {\n        uint[] memory _TokenIDs = new uint[](1000);\n        uint CityIDBuffer = (_CurrentCityIndex % 7) * 1000;\n        uint _TicketID;\n        uint Counter;\n        for(uint TicketID; TicketID < 1000; TicketID++)\n        {\n            _TicketID = TicketID + CityIDBuffer;\n            if(\n                !_MintedCitizen[_CurrentCityIndex][_TicketID]\n                &&\n                _BrightListCitizen[_CurrentCityIndex][_TicketID] != address(0)\n            ) \n            { \n                _TokenIDs[Counter] = _TicketID; \n                Counter++;\n            }\n        }\n        uint[] memory FormattedCheckedInTickets = new uint[](Counter);\n        uint Found;\n        for(uint x; x < Counter; x++)\n        {\n            if(_TokenIDs[x] != 0 || (_TokenIDs[x] == 0 && x == 0))\n            {\n                FormattedCheckedInTickets[Found] = _TokenIDs[x];\n                Found++;\n            }\n        }\n        return FormattedCheckedInTickets;\n    }\n\n    /**\n     * @dev Returns A 2d Array Of Minted ArtistIDs\n     */\n    function readArtistUnmintedTicketIDs(uint[] calldata ArtistIDs, uint Range) public view returns(uint[][] memory TokenIDs)\n    {\n        uint[][] memory _TokenIDs = new uint[][](ArtistIDs.length);\n        uint Index;\n        for(uint ArtistID; ArtistID < ArtistIDs.length; ArtistID++)\n        {\n            uint[] memory UnmintedArtistTokenIDs = new uint[](Range);\n            uint Counter;\n            for(uint TokenID; TokenID < Range; TokenID++)\n            {\n                bool TicketIDBurned;\n                try IERC721(_MintPassFactory).ownerOf(TokenID) { } // checks if token is burned\n                catch { TicketIDBurned = true; }\n                if(\n                    !_MintedArtist[ArtistIDs[ArtistID]][TokenID]\n                    &&\n                    (\n                        _BrightListArtist[ArtistIDs[ArtistID]][TokenID] != address(0)\n                        ||\n                        TicketIDBurned == false\n                    )\n                ) \n                { \n                    UnmintedArtistTokenIDs[Counter] = TokenID; \n                    Counter++;\n                }\n            }\n            uint[] memory FormattedUnMintedArtistIDs = new uint[](Counter);\n            uint Found;\n            for(uint x; x < Counter; x++)\n            {\n                if(UnmintedArtistTokenIDs[x] != 0 || (UnmintedArtistTokenIDs[x] == 0 && x == 0))\n                {\n                    FormattedUnMintedArtistIDs[Found] = UnmintedArtistTokenIDs[x];\n                    Found++;\n                }\n            }\n            _TokenIDs[Index] = FormattedUnMintedArtistIDs;\n            Index++;\n        }\n        return (_TokenIDs);\n    }\n\n    /**\n     * @dev Returns A 2d Array Of Minted ArtistIDs\n     */\n    function readArtistMintedTicketIDs(uint[] calldata ArtistIDs, uint Range) public view returns(uint[][] memory TokenIDs)\n    {\n        uint[][] memory _TokenIDs = new uint[][](ArtistIDs.length);\n        uint Index;\n        for(uint ArtistID; ArtistID < ArtistIDs.length; ArtistID++)\n        {\n            uint[] memory MintedTokenIDs = new uint[](Range);\n            uint Counter;\n            for(uint TokenID; TokenID < Range; TokenID++)\n            {\n                if(_MintedArtist[ArtistIDs[ArtistID]][TokenID])\n                { \n                    MintedTokenIDs[Counter] = TokenID; \n                    Counter++;\n                }\n            }\n            uint[] memory FormattedMintedTokenIDs = new uint[](Counter);\n            uint Found;\n            for(uint x; x < Counter; x++)\n            {\n                if(MintedTokenIDs[x] != 0 || (MintedTokenIDs[x] == 0 && x == 0))\n                {\n                    FormattedMintedTokenIDs[Found] = MintedTokenIDs[x];\n                    Found++;\n                }\n            }\n            _TokenIDs[Index] = FormattedMintedTokenIDs;\n            Index++;\n        }\n        return (_TokenIDs);\n    }\n\n    /**\n     * @dev Returns Original Recipients Of CryptoCitizens\n     */\n    function readCitizenBrightList(uint CityIndex) public view returns(address[] memory Recipients)\n    {\n        address[] memory _Recipients = new address[](1000);\n        uint Start = (CityIndex % 7) * 1000;\n        for(uint x; x < 1000; x++) { _Recipients[x] = _BrightListCitizen[CityIndex][Start+x]; }\n        return _Recipients;\n    }\n\n    /**\n     * @dev Returns Original Recipient Of Artist NFTs\n     */\n    function readArtistBrightList(uint ArtistID, uint Range) public view returns(address[] memory Recipients)\n    {\n        address[] memory _Recipients = new address[](Range);\n        for(uint x; x < Range; x++) { _Recipients[x] = _BrightListArtist[ArtistID][x]; }\n        return _Recipients;    \n    }\n\n    /**\n     * @dev Returns The City Struct At Index Of `CityIndex`\n     */\n    function readCitizenCity(uint CityIndex) public view returns(City memory) { return Cities[CityIndex]; }\n\n    /**\n     * @dev Returns The Artist Struct At Index Of `ArtistID`\n     */\n    function readArtist(uint ArtistID) public view returns(Artist memory) { return Artists[ArtistID]; }\n\n    /**\n     * @dev Returns A Minted Work TokenID Corresponding To The Input Artist TicketID \n     */\n    function readArtistMintedTokenID(uint ArtistID, uint TicketID) external view returns (uint)\n    {\n        if(!_MintedArtist[ArtistID][TicketID]) { return 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff; }\n        else { return _MintedTokenIDArtist[ArtistID][TicketID]; }\n    }\n\n    /**\n     * @dev Returns A Minted Citizen TokenID Corresponding To Input TicketID\n     */\n    function readCitizenMintedTokenID(uint CityIndex, uint TicketID) external view returns(uint)\n    {\n        if(!_MintedCitizen[CityIndex][TicketID]) { return type(uint).max; }\n        else { return _MintedTokenIDCitizen[CityIndex][TicketID]; }  \n    }\n    \n    /*-------------------------*/\n    /*        LAUNCHPAD        */\n    /*-------------------------*/\n\n    /**\n     * @dev Initializes A LiveMint Artist\n     */\n    function __InitLiveMint(Artist memory _Params) external onlyAuthorized returns (uint)\n    {\n        AmountRemaining[_UniqueArtistsInvoked] = _Params._MaxSupply;\n        Artists[_UniqueArtistsInvoked] = _Params;\n        _UniqueArtistsInvoked++;\n        return _UniqueArtistsInvoked - 1;\n    }\n\n    /*-------------------------*/\n    /*     ACCESS MODIFIERS    */\n    /*-------------------------*/\n\n    /**\n     * @dev Access Modifier That Allows Only BrightListed BRT Minters\n     **/\n    modifier onlyMinter() \n    {\n        require(Role[msg.sender] == _MINTER_ROLE, \"LiveMint: OnlyMinter Caller Is Not Approved BRT Minter\");\n        _;\n    }\n\n    /**\n     * @dev Access Modifier That Allows Only Authorized Contracts\n     */\n    modifier onlyAuthorized()\n    {\n        require(Role[msg.sender] == _AUTHORIZED, \"LiveMint: OnlyAuthorized Caller Is Not Approved Contract\");\n        _;\n    }\n}"}}, "settings": {"viaIR": false, "optimizer": {"enabled": true}, "outputSelection": {"*": {"*": ["evm.legacyAssembly"]}}, "libraries": {}}}