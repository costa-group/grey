{"language": "Solidity", "sources": {"src/lib/RebalanceLogic.sol": {"content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.30;\n\nimport \"@uniswap/v4-core/src/types/Currency.sol\";\nimport {TickMath} from \"@uniswap/v4-core/src/libraries/TickMath.sol\";\n\nimport \"flood-contracts/src/interfaces/IZone.sol\";\nimport \"flood-contracts/src/interfaces/IFloodPlain.sol\";\nimport \"flood-contracts/src/interfaces/IOnChainOrders.sol\";\n\nimport {IEIP712} from \"permit2/src/interfaces/IEIP712.sol\";\n\nimport {ERC20} from \"solady/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport \"./VaultMath.sol\";\nimport \"../types/PoolState.sol\";\nimport \"../types/IdleBalance.sol\";\nimport \"../base/SharedStructs.sol\";\nimport {Oracle} from \"./Oracle.sol\";\nimport {queryLDF} from \"./QueryLDF.sol\";\nimport {FullMathX96} from \"./FullMathX96.sol\";\nimport {BunniHookLogic} from \"./BunniHookLogic.sol\";\nimport {OrderHashMemory} from \"./OrderHashMemory.sol\";\n\nlibrary RebalanceLogic {\n    using FullMathX96 for *;\n    using SafeTransferLib for *;\n    using FixedPointMathLib for *;\n    using IdleBalanceLibrary for *;\n    using Oracle for Oracle.Observation[MAX_CARDINALITY];\n\n    /// @dev Creates a rebalance order on FloodPlain.\n    function rebalance(\n        HookStorage storage s,\n        BunniHookLogic.Env calldata env,\n        BunniHookLogic.RebalanceInput calldata input\n    ) external {\n        // compute rebalance params\n        (bool success, Currency inputToken, Currency outputToken, uint256 inputAmount, uint256 outputAmount) =\n            _computeRebalanceParams(s, env, input);\n        if (!success) return;\n\n        // create rebalance order\n        _createRebalanceOrder(\n            s,\n            env,\n            input.id,\n            input.key,\n            input.hookParams.rebalanceOrderTTL,\n            inputToken,\n            outputToken,\n            inputAmount,\n            outputAmount\n        );\n    }\n\n    function _computeRebalanceParams(\n        HookStorage storage s,\n        BunniHookLogic.Env calldata env,\n        BunniHookLogic.RebalanceInput calldata input\n    )\n        private\n        view\n        returns (bool success, Currency inputToken, Currency outputToken, uint256 inputAmount, uint256 outputAmount)\n    {\n        // compute the ratio (excessLiquidity / totalLiquidity)\n        // excessLiquidity is the minimum amount of liquidity that can be supported by the excess tokens\n\n        // load fresh state\n        PoolState memory bunniState = env.hub.poolState(input.id);\n\n        // get fresh token balances\n        (uint256 balance0, uint256 balance1) = (\n            bunniState.rawBalance0 + getReservesInUnderlying(bunniState.reserve0, bunniState.vault0),\n            bunniState.rawBalance1 + getReservesInUnderlying(bunniState.reserve1, bunniState.vault1)\n        );\n\n        // compute total liquidity and densities\n        (uint256 totalLiquidity,,,,,,,) = queryLDF({\n            key: input.key,\n            sqrtPriceX96: input.updatedSqrtPriceX96,\n            tick: input.updatedTick,\n            arithmeticMeanTick: input.arithmeticMeanTick,\n            ldf: bunniState.liquidityDensityFunction,\n            ldfParams: bunniState.ldfParams,\n            ldfState: input.newLdfState,\n            balance0: balance0,\n            balance1: balance1,\n            idleBalance: bunniState.idleBalance\n        });\n\n        // compute excess liquidity if there's any\n        (uint256 idleBalance, bool willRebalanceToken0) = bunniState.idleBalance.fromIdleBalance();\n        uint256 excessLiquidity = willRebalanceToken0\n            ? idleBalance.divWad(\n                bunniState.liquidityDensityFunction.cumulativeAmount0(\n                    input.key,\n                    TickMath.minUsableTick(input.key.tickSpacing),\n                    WAD,\n                    input.arithmeticMeanTick,\n                    input.updatedTick,\n                    bunniState.ldfParams,\n                    input.newLdfState\n                )\n            )\n            : idleBalance.divWad(\n                bunniState.liquidityDensityFunction.cumulativeAmount1(\n                    input.key,\n                    TickMath.maxUsableTick(input.key.tickSpacing) - input.key.tickSpacing,\n                    WAD,\n                    input.arithmeticMeanTick,\n                    input.updatedTick,\n                    bunniState.ldfParams,\n                    input.newLdfState\n                )\n            );\n\n        // should rebalance if excessLiquidity / totalLiquidity >= 1 / rebalanceThreshold\n        bool shouldRebalance =\n            excessLiquidity != 0 && excessLiquidity >= totalLiquidity / input.hookParams.rebalanceThreshold;\n        if (!shouldRebalance) return (false, inputToken, outputToken, inputAmount, outputAmount);\n\n        // compute target token densities of the excess liquidity after rebalancing\n        // this is done by querying the LDF using a TWAP as the spot price to prevent manipulation\n        int24 rebalanceSpotPriceTick = _getTwap(\n            s,\n            input.id,\n            input.updatedTick,\n            input.hookParams.rebalanceTwapSecondsAgo,\n            input.updatedIntermediate,\n            input.updatedIndex,\n            input.updatedCardinality\n        );\n        uint160 rebalanceSpotPriceSqrtRatioX96 = TickMath.getSqrtPriceAtTick(rebalanceSpotPriceTick);\n        // totalDensity0X96 and totalDensity1X96 are the token densities of the excess liquidity\n        // after rebalancing\n        (, uint256 totalDensity0X96, uint256 totalDensity1X96,,,,,) = queryLDF({\n            key: input.key,\n            sqrtPriceX96: rebalanceSpotPriceSqrtRatioX96,\n            tick: rebalanceSpotPriceTick,\n            arithmeticMeanTick: input.arithmeticMeanTick,\n            ldf: bunniState.liquidityDensityFunction,\n            ldfParams: bunniState.ldfParams,\n            ldfState: input.newLdfState,\n            balance0: 0,\n            balance1: 0,\n            idleBalance: IdleBalanceLibrary.ZERO\n        });\n\n        // compute target amounts (i.e. the token amounts of the excess liquidity)\n        uint256 targetAmount0 = excessLiquidity.fullMulX96(totalDensity0X96);\n        uint256 targetAmount1 = excessLiquidity.fullMulX96(totalDensity1X96);\n\n        // determine input & output\n        (inputToken, outputToken) = willRebalanceToken0\n            ? (input.key.currency0, input.key.currency1)\n            : (input.key.currency1, input.key.currency0);\n        uint256 inputTokenTarget = willRebalanceToken0 ? targetAmount0 : targetAmount1;\n        uint256 outputTokenTarget = willRebalanceToken0 ? targetAmount1 : targetAmount0;\n        if (idleBalance < inputTokenTarget) {\n            // should never happen\n            return (false, inputToken, outputToken, inputAmount, outputAmount);\n        }\n        inputAmount = idleBalance - inputTokenTarget;\n        outputAmount = outputTokenTarget.mulDivUp(\n            REBALANCE_MAX_SLIPPAGE_BASE - input.hookParams.rebalanceMaxSlippage, REBALANCE_MAX_SLIPPAGE_BASE\n        );\n\n        success = true;\n    }\n\n    function _createRebalanceOrder(\n        HookStorage storage s,\n        BunniHookLogic.Env calldata env,\n        PoolId id,\n        PoolKey calldata key,\n        uint16 rebalanceOrderTTL,\n        Currency inputToken,\n        Currency outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount\n    ) private {\n        // create Flood order\n        ERC20 inputERC20Token = inputToken.isAddressZero() ? env.weth : ERC20(Currency.unwrap(inputToken));\n        ERC20 outputERC20Token = outputToken.isAddressZero() ? env.weth : ERC20(Currency.unwrap(outputToken));\n        IFloodPlain.Item[] memory offer = new IFloodPlain.Item[](1);\n        offer[0] = IFloodPlain.Item({token: address(inputERC20Token), amount: inputAmount});\n        IFloodPlain.Item memory consideration =\n            IFloodPlain.Item({token: address(outputERC20Token), amount: outputAmount});\n\n        IBunniHook.RebalanceOrderHookArgs memory hookArgs = IBunniHook.RebalanceOrderHookArgs({\n            key: key,\n            preHookArgs: IBunniHook.RebalanceOrderPreHookArgs({currency: inputToken, amount: inputAmount}),\n            postHookArgs: IBunniHook.RebalanceOrderPostHookArgs({currency: outputToken})\n        });\n\n        // prehook should pull input tokens from BunniHub to BunniHook and update pool balances\n        IFloodPlain.Hook[] memory preHooks = new IFloodPlain.Hook[](1);\n        preHooks[0] = IFloodPlain.Hook({\n            target: address(this),\n            data: abi.encodeCall(IBunniHook.rebalanceOrderPreHook, (hookArgs))\n        });\n\n        // posthook should push output tokens from BunniHook to BunniHub and update pool balances\n        IFloodPlain.Hook[] memory postHooks = new IFloodPlain.Hook[](1);\n        postHooks[0] = IFloodPlain.Hook({\n            target: address(this),\n            data: abi.encodeCall(IBunniHook.rebalanceOrderPostHook, (hookArgs))\n        });\n\n        IFloodPlain.Order memory order = IFloodPlain.Order({\n            offerer: address(this),\n            zone: address(env.floodZone),\n            recipient: address(this),\n            offer: offer,\n            consideration: consideration,\n            deadline: block.timestamp + rebalanceOrderTTL,\n            nonce: uint256(keccak256(abi.encode(block.number, id))), // combine block.number and pool id to avoid nonce collisions between pools\n            preHooks: preHooks,\n            postHooks: postHooks\n        });\n\n        // record order for verification later\n        (s.rebalanceOrderHash[id], s.rebalanceOrderPermit2Hash[id]) = _hashFloodOrder(order, env);\n        s.rebalanceOrderDeadline[id] = order.deadline;\n\n        // approve input token to permit2\n        if (inputERC20Token.allowance(address(this), env.permit2) < inputAmount) {\n            address(inputERC20Token).safeApproveWithRetry(env.permit2, type(uint256).max);\n        }\n\n        // etch order so fillers can pick it up\n        // use PoolId as signature to enable isValidSignature() to find the correct order hash\n        IOnChainOrders(address(env.floodPlain)).etchOrder(\n            IFloodPlain.SignedOrder({order: order, signature: abi.encode(id)})\n        );\n    }\n\n    function _getTwap(\n        HookStorage storage s,\n        PoolId id,\n        int24 currentTick,\n        uint32 twapSecondsAgo,\n        Oracle.Observation calldata updatedIntermediate,\n        uint32 updatedIndex,\n        uint32 updatedCardinality\n    ) private view returns (int24 arithmeticMeanTick) {\n        (int56 tickCumulative0, int56 tickCumulative1) = s.observations[id].observeDouble(\n            updatedIntermediate,\n            uint32(block.timestamp),\n            twapSecondsAgo,\n            0,\n            currentTick,\n            updatedIndex,\n            updatedCardinality\n        );\n        int56 tickCumulativesDelta = tickCumulative1 - tickCumulative0;\n        arithmeticMeanTick = int24(tickCumulativesDelta / int56(uint56(twapSecondsAgo)));\n    }\n\n    /// @dev The hash that Permit2 uses when verifying the order's signature.\n    /// See https://github.com/Uniswap/permit2/blob/cc56ad0f3439c502c246fc5cfcc3db92bb8b7219/src/SignatureTransfer.sol#L65\n    /// Always calls permit2 for the domain separator to maintain cross-chain replay protection in the event of a fork\n    /// Also returns the Flood order hash\n    function _hashFloodOrder(IFloodPlain.Order memory order, BunniHookLogic.Env calldata env)\n        private\n        view\n        returns (bytes32 orderHash, bytes32 permit2Hash)\n    {\n        (orderHash, permit2Hash) = OrderHashMemory.hashAsWitness(order, address(env.floodPlain));\n        permit2Hash = keccak256(abi.encodePacked(\"\\x19\\x01\", IEIP712(env.permit2).DOMAIN_SEPARATOR(), permit2Hash));\n    }\n}\n"}, "lib/v4-core/src/types/Currency.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IERC20Minimal} from \"../interfaces/external/IERC20Minimal.sol\";\nimport {CustomRevert} from \"../libraries/CustomRevert.sol\";\n\ntype Currency is address;\n\nusing {greaterThan as >, lessThan as <, greaterThanOrEqualTo as >=, equals as ==} for Currency global;\nusing CurrencyLibrary for Currency global;\n\nfunction equals(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) == Currency.unwrap(other);\n}\n\nfunction greaterThan(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) > Currency.unwrap(other);\n}\n\nfunction lessThan(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) < Currency.unwrap(other);\n}\n\nfunction greaterThanOrEqualTo(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) >= Currency.unwrap(other);\n}\n\n/// @title CurrencyLibrary\n/// @dev This library allows for transferring and holding native tokens and ERC20 tokens\nlibrary CurrencyLibrary {\n    /// @notice Additional context for ERC-7751 wrapped error when a native transfer fails\n    error NativeTransferFailed();\n\n    /// @notice Additional context for ERC-7751 wrapped error when an ERC20 transfer fails\n    error ERC20TransferFailed();\n\n    /// @notice A constant to represent the native currency\n    Currency public constant ADDRESS_ZERO = Currency.wrap(address(0));\n\n    function transfer(Currency currency, address to, uint256 amount) internal {\n        // altered from https://github.com/transmissions11/solmate/blob/44a9963d4c78111f77caa0e65d677b8b46d6f2e6/src/utils/SafeTransferLib.sol\n        // modified custom error selectors\n\n        bool success;\n        if (currency.isAddressZero()) {\n            assembly (\"memory-safe\") {\n                // Transfer the ETH and revert if it fails.\n                success := call(gas(), to, amount, 0, 0, 0, 0)\n            }\n            // revert with NativeTransferFailed, containing the bubbled up error as an argument\n            if (!success) {\n                CustomRevert.bubbleUpAndRevertWith(to, bytes4(0), NativeTransferFailed.selector);\n            }\n        } else {\n            assembly (\"memory-safe\") {\n                // Get a pointer to some free memory.\n                let fmp := mload(0x40)\n\n                // Write the abi-encoded calldata into memory, beginning with the function selector.\n                mstore(fmp, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n                mstore(add(fmp, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n                mstore(add(fmp, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n                success :=\n                    and(\n                        // Set success to whether the call reverted, if not we check it either\n                        // returned exactly 1 (can't just be non-zero data), or had no return data.\n                        or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                        // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                        // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                        // Counterintuitively, this call must be positioned second to the or() call in the\n                        // surrounding and() call or else returndatasize() will be zero during the computation.\n                        call(gas(), currency, 0, fmp, 68, 0, 32)\n                    )\n\n                // Now clean the memory we used\n                mstore(fmp, 0) // 4 byte `selector` and 28 bytes of `to` were stored here\n                mstore(add(fmp, 0x20), 0) // 4 bytes of `to` and 28 bytes of `amount` were stored here\n                mstore(add(fmp, 0x40), 0) // 4 bytes of `amount` were stored here\n            }\n            // revert with ERC20TransferFailed, containing the bubbled up error as an argument\n            if (!success) {\n                CustomRevert.bubbleUpAndRevertWith(\n                    Currency.unwrap(currency), IERC20Minimal.transfer.selector, ERC20TransferFailed.selector\n                );\n            }\n        }\n    }\n\n    function balanceOfSelf(Currency currency) internal view returns (uint256) {\n        if (currency.isAddressZero()) {\n            return address(this).balance;\n        } else {\n            return IERC20Minimal(Currency.unwrap(currency)).balanceOf(address(this));\n        }\n    }\n\n    function balanceOf(Currency currency, address owner) internal view returns (uint256) {\n        if (currency.isAddressZero()) {\n            return owner.balance;\n        } else {\n            return IERC20Minimal(Currency.unwrap(currency)).balanceOf(owner);\n        }\n    }\n\n    function isAddressZero(Currency currency) internal pure returns (bool) {\n        return Currency.unwrap(currency) == Currency.unwrap(ADDRESS_ZERO);\n    }\n\n    function toId(Currency currency) internal pure returns (uint256) {\n        return uint160(Currency.unwrap(currency));\n    }\n\n    // If the upper 12 bytes are non-zero, they will be zero-ed out\n    // Therefore, fromId() and toId() are not inverses of each other\n    function fromId(uint256 id) internal pure returns (Currency) {\n        return Currency.wrap(address(uint160(id)));\n    }\n}\n"}, "lib/v4-core/src/libraries/TickMath.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {BitMath} from \"./BitMath.sol\";\nimport {CustomRevert} from \"./CustomRevert.sol\";\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    using CustomRevert for bytes4;\n\n    /// @notice Thrown when the tick passed to #getSqrtPriceAtTick is not between MIN_TICK and MAX_TICK\n    error InvalidTick(int24 tick);\n    /// @notice Thrown when the price passed to #getTickAtSqrtPrice does not correspond to a price between MIN_TICK and MAX_TICK\n    error InvalidSqrtPrice(uint160 sqrtPriceX96);\n\n    /// @dev The minimum tick that may be passed to #getSqrtPriceAtTick computed from log base 1.0001 of 2**-128\n    /// @dev If ever MIN_TICK and MAX_TICK are not centered around 0, the absTick logic in getSqrtPriceAtTick cannot be used\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtPriceAtTick computed from log base 1.0001 of 2**128\n    /// @dev If ever MIN_TICK and MAX_TICK are not centered around 0, the absTick logic in getSqrtPriceAtTick cannot be used\n    int24 internal constant MAX_TICK = 887272;\n\n    /// @dev The minimum tick spacing value drawn from the range of type int16 that is greater than 0, i.e. min from the range [1, 32767]\n    int24 internal constant MIN_TICK_SPACING = 1;\n    /// @dev The maximum tick spacing value drawn from the range of type int16, i.e. max from the range [1, 32767]\n    int24 internal constant MAX_TICK_SPACING = type(int16).max;\n\n    /// @dev The minimum value that can be returned from #getSqrtPriceAtTick. Equivalent to getSqrtPriceAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_PRICE = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtPriceAtTick. Equivalent to getSqrtPriceAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_PRICE = 1461446703485210103287273052203988822378723970342;\n    /// @dev A threshold used for optimized bounds check, equals `MAX_SQRT_PRICE - MIN_SQRT_PRICE - 1`\n    uint160 internal constant MAX_SQRT_PRICE_MINUS_MIN_SQRT_PRICE_MINUS_ONE =\n        1461446703485210103287273052203988822378723970342 - 4295128739 - 1;\n\n    /// @notice Given a tickSpacing, compute the maximum usable tick\n    function maxUsableTick(int24 tickSpacing) internal pure returns (int24) {\n        unchecked {\n            return (MAX_TICK / tickSpacing) * tickSpacing;\n        }\n    }\n\n    /// @notice Given a tickSpacing, compute the minimum usable tick\n    function minUsableTick(int24 tickSpacing) internal pure returns (int24) {\n        unchecked {\n            return (MIN_TICK / tickSpacing) * tickSpacing;\n        }\n    }\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the price of the two assets (currency1/currency0)\n    /// at the given tick\n    function getSqrtPriceAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        unchecked {\n            uint256 absTick;\n            assembly (\"memory-safe\") {\n                tick := signextend(2, tick)\n                // mask = 0 if tick >= 0 else -1 (all 1s)\n                let mask := sar(255, tick)\n                // if tick >= 0, |tick| = tick = 0 ^ tick\n                // if tick < 0, |tick| = ~~|tick| = ~(-|tick| - 1) = ~(tick - 1) = (-1) ^ (tick - 1)\n                // either way, |tick| = mask ^ (tick + mask)\n                absTick := xor(mask, add(mask, tick))\n            }\n\n            if (absTick > uint256(int256(MAX_TICK))) InvalidTick.selector.revertWith(tick);\n\n            // The tick is decomposed into bits, and for each bit with index i that is set, the product of 1/sqrt(1.0001^(2^i))\n            // is calculated (using Q128.128). The constants used for this calculation are rounded to the nearest integer\n\n            // Equivalent to:\n            //     price = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n            //     or price = int(2**128 / sqrt(1.0001)) if (absTick & 0x1) else 1 << 128\n            uint256 price;\n            assembly (\"memory-safe\") {\n                price := xor(shl(128, 1), mul(xor(shl(128, 1), 0xfffcb933bd6fad37aa2d162d1a594001), and(absTick, 0x1)))\n            }\n            if (absTick & 0x2 != 0) price = (price * 0xfff97272373d413259a46990580e213a) >> 128;\n            if (absTick & 0x4 != 0) price = (price * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n            if (absTick & 0x8 != 0) price = (price * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n            if (absTick & 0x10 != 0) price = (price * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n            if (absTick & 0x20 != 0) price = (price * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n            if (absTick & 0x40 != 0) price = (price * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n            if (absTick & 0x80 != 0) price = (price * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n            if (absTick & 0x100 != 0) price = (price * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n            if (absTick & 0x200 != 0) price = (price * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n            if (absTick & 0x400 != 0) price = (price * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n            if (absTick & 0x800 != 0) price = (price * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n            if (absTick & 0x1000 != 0) price = (price * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n            if (absTick & 0x2000 != 0) price = (price * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n            if (absTick & 0x4000 != 0) price = (price * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n            if (absTick & 0x8000 != 0) price = (price * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n            if (absTick & 0x10000 != 0) price = (price * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n            if (absTick & 0x20000 != 0) price = (price * 0x5d6af8dedb81196699c329225ee604) >> 128;\n            if (absTick & 0x40000 != 0) price = (price * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n            if (absTick & 0x80000 != 0) price = (price * 0x48a170391f7dc42444e8fa2) >> 128;\n\n            assembly (\"memory-safe\") {\n                // if (tick > 0) price = type(uint256).max / price;\n                if sgt(tick, 0) { price := div(not(0), price) }\n\n                // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n                // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n                // we round up in the division so getTickAtSqrtPrice of the output price is always consistent\n                // `sub(shl(32, 1), 1)` is `type(uint32).max`\n                // `price + type(uint32).max` will not overflow because `price` fits in 192 bits\n                sqrtPriceX96 := shr(32, add(price, sub(shl(32, 1), 1)))\n            }\n        }\n    }\n\n    /// @notice Calculates the greatest tick value such that getSqrtPriceAtTick(tick) <= sqrtPriceX96\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_PRICE, as MIN_SQRT_PRICE is the lowest value getSqrtPriceAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt price for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the getSqrtPriceAtTick(tick) is less than or equal to the input sqrtPriceX96\n    function getTickAtSqrtPrice(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        unchecked {\n            // Equivalent: if (sqrtPriceX96 < MIN_SQRT_PRICE || sqrtPriceX96 >= MAX_SQRT_PRICE) revert InvalidSqrtPrice();\n            // second inequality must be >= because the price can never reach the price at the max tick\n            // if sqrtPriceX96 < MIN_SQRT_PRICE, the `sub` underflows and `gt` is true\n            // if sqrtPriceX96 >= MAX_SQRT_PRICE, sqrtPriceX96 - MIN_SQRT_PRICE > MAX_SQRT_PRICE - MIN_SQRT_PRICE - 1\n            if ((sqrtPriceX96 - MIN_SQRT_PRICE) > MAX_SQRT_PRICE_MINUS_MIN_SQRT_PRICE_MINUS_ONE) {\n                InvalidSqrtPrice.selector.revertWith(sqrtPriceX96);\n            }\n\n            uint256 price = uint256(sqrtPriceX96) << 32;\n\n            uint256 r = price;\n            uint256 msb = BitMath.mostSignificantBit(r);\n\n            if (msb >= 128) r = price >> (msb - 127);\n            else r = price << (127 - msb);\n\n            int256 log_2 = (int256(msb) - 128) << 64;\n\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(63, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(62, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(61, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(60, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(59, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(58, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(57, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(56, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(55, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(54, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(53, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(52, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(51, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(50, f))\n            }\n\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // Q22.128 number\n\n            // Magic number represents the ceiling of the maximum value of the error when approximating log_sqrt10001(x)\n            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n\n            // Magic number represents the minimum value of the error when approximating log_sqrt10001(x), when\n            // sqrtPrice is from the range (2^-64, 2^64). This is safe as MIN_SQRT_PRICE is more than 2^-64. If MIN_SQRT_PRICE\n            // is changed, this may need to be changed too\n            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n            tick = tickLow == tickHi ? tickLow : getSqrtPriceAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n        }\n    }\n}\n"}, "lib/flood-contracts/src/interfaces/IZone.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IFloodPlain} from \"./IFloodPlain.sol\";\n\ninterface IZone {\n    struct FeeInfo {\n        address recipient;\n        uint64 bps;\n    }\n\n    /**\n     * @notice Check if a fulfiller belongs to the zone.\n     *\n     * @dev Fulfiller must still ensure that\n     *      - msg.sender is a the BOOK.\n     *      - Book caller is authorized.\n     *\n     * @param order Order being fulfilled.\n     * @param fulfiller The address that will fulfill the order by supplying consideration items.\n     *\n     * @return True if fulfiller is enabled, false if fulfiller is not enabled.\n     */\n    function validate(IFloodPlain.Order calldata order, address fulfiller) external view returns (bool);\n\n    /**\n     * @notice Get the fee information.\n     *\n     * @dev It is up to Fulfiller to respect the fees set in a zone.\n     *\n     * @return The address of the fee recipient who should receive the fees.\n     *         The fee cut in BPS that should be taken from the output tokens.\n     */\n    function fee(IFloodPlain.Order calldata order, address fulfiller) external view returns (FeeInfo memory);\n}\n"}, "lib/flood-contracts/src/interfaces/IFloodPlain.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {ISignatureTransfer} from \"permit2/src/interfaces/ISignatureTransfer.sol\";\n\ninterface IFloodPlain {\n    error InsufficientAmountReceived();\n\n    error NotAContract();\n\n    error ZoneDenied();\n\n    error DuplicateItems();\n\n    error ArrayLengthMismatch();\n\n    event OrderFulfilled(bytes32 indexed orderHash, address indexed zone, address indexed fulfiller, uint256 amountOut);\n\n    struct SignedOrder {\n        Order order;\n        bytes signature;\n    }\n\n    struct Order {\n        address offerer;\n        address zone;\n        address recipient;\n        Item[] offer;\n        Item consideration;\n        uint256 deadline;\n        uint256 nonce;\n        Hook[] preHooks;\n        Hook[] postHooks;\n    }\n\n    struct Item {\n        address token;\n        uint256 amount;\n    }\n\n    struct Hook {\n        address target;\n        bytes data;\n    }\n\n    /**\n     * @notice Get Permit2 SignatureTransfer contract that is used in verifying orders.\n     */\n    function PERMIT2() external view returns (ISignatureTransfer);\n\n    /**\n     * @notice Retrieve the permit2 hash for a given order.\n     *\n     * @param order The components of the order.\n     *\n     * @return permitHash The permit2 hash as order as the witness.\n     */\n    function getPermitHash(Order calldata order) external view returns (bytes32 permitHash);\n\n    /**\n     * @notice Retrieve the order hash for a given order.\n     *\n     * @param order The components of the order.\n     *\n     * @return orderHash The order hash.\n     */\n    function getOrderHash(Order calldata order) external view returns (bytes32 orderHash);\n\n    /**\n     * @notice Check if the order deadline has passed or its nonce has been cancelled or used.\n     *\n     * @param order The components of the order.\n     *\n     * @return isValid A boolean guaranteeing the order cannot be fulfilled if false.\n     */\n    function getOrderStatus(Order calldata order) external view returns (bool isValid);\n\n    /**\n     * @notice Check if the nonce of a user is available.\n     *\n     * @param user  The address of the user to check the nonce of.\n     * @param nonce The nonce of the user to check.\n     *\n     * @return isValid A boolean returning true if the nonce is not flipped.\n     */\n    function getNonceStatus(address user, uint256 nonce) external view returns (bool isValid);\n\n    /**\n     * @notice Allow receiving ether from Fulfiller. No checks are made to ensure the ether is\n     *         sent from a Fulfiller. If ether is sent directly, it can be stolen.\n     */\n    receive() external payable;\n\n    /**\n     * @notice Fulfill an order directly by transferring consideration from caller to offerer.\n     *\n     * @param package The order to fulfill and the permit2 signature with the order as the witness.\n     *                Note that the offerer must first approve Permit2 contract to transfer any\n     *                relevant tokens on their behalf.\n     */\n    function fulfillOrder(SignedOrder calldata package) external payable;\n\n    /**\n     * @notice Fulfill single order.\n     *\n     * @param package   The order to fulfill and its signatures. The offerer must first approve\n     *                  Permit2 contract to transfer any relevant tokens on their behalf.\n     * @param fulfiller The address that will receive offer items, then source consideration for\n     *                  the offerer.\n     * @param swapData  Extra bytes passed to the Fulfiller.\n     */\n    function fulfillOrder(SignedOrder calldata package, address fulfiller, bytes calldata swapData) external;\n\n    /**\n     * @notice Fulfill series of orders.\n     *\n     * @param packages  The orders to fulfill and their signatures. The offerer must first approve\n     *                  Permit2 contract to transfer any relevant tokens on their behalf.\n     * @param fulfiller The address that will receive offer items, then source consideration items\n     *                  for the offerer.\n     * @param swapData  Extra bytes passed to the Fulfiller.\n     */\n    function fulfillOrders(SignedOrder[] calldata packages, address fulfiller, bytes calldata swapData) external;\n}\n"}, "lib/flood-contracts/src/interfaces/IOnChainOrders.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IFloodPlain} from \"./IFloodPlain.sol\";\n\ninterface IOnChainOrders {\n    event OrderEtched(bytes32 indexed orderHash, IFloodPlain.SignedOrder signedOrder);\n\n    /**\n     * @notice Record an order on-chain for ease of use by other contracts.\n     *\n     * @param signedOrder The order and its signature to record.\n     */\n    function etchOrder(IFloodPlain.SignedOrder calldata signedOrder) external;\n}\n"}, "lib/permit2/src/interfaces/IEIP712.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IEIP712 {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"}, "lib/solady/src/tokens/ERC20.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Simple ERC20 + EIP-2612 implementation.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)\n///\n/// @dev Note:\n/// - The ERC20 standard allows minting and transferring to and from the zero address,\n///   minting and transferring zero tokens, as well as self-approvals.\n///   For performance, this implementation WILL NOT revert for such actions.\n///   Please add any checks with overrides if desired.\n/// - The `permit` function uses the ecrecover precompile (0x1).\n///\n/// If you are overriding:\n/// - NEVER violate the ERC20 invariant:\n///   the total sum of all balances must be equal to `totalSupply()`.\n/// - Check that the overridden function is actually used in the function you want to\n///   change the behavior of. Much of the code has been manually inlined for performance.\nabstract contract ERC20 {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The total supply has overflowed.\n    error TotalSupplyOverflow();\n\n    /// @dev The allowance has overflowed.\n    error AllowanceOverflow();\n\n    /// @dev The allowance has underflowed.\n    error AllowanceUnderflow();\n\n    /// @dev Insufficient balance.\n    error InsufficientBalance();\n\n    /// @dev Insufficient allowance.\n    error InsufficientAllowance();\n\n    /// @dev The permit is invalid.\n    error InvalidPermit();\n\n    /// @dev The permit has expired.\n    error PermitExpired();\n\n    /// @dev The allowance of Permit2 is fixed at infinity.\n    error Permit2AllowanceIsFixedAtInfinity();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                           EVENTS                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /// @dev `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\n\n    /// @dev `keccak256(bytes(\"Approval(address,address,uint256)\"))`.\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          STORAGE                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The storage slot for the total supply.\n    uint256 private constant _TOTAL_SUPPLY_SLOT = 0x05345cdf77eb68f44c;\n\n    /// @dev The balance slot of `owner` is given by:\n    /// ```\n    ///     mstore(0x0c, _BALANCE_SLOT_SEED)\n    ///     mstore(0x00, owner)\n    ///     let balanceSlot := keccak256(0x0c, 0x20)\n    /// ```\n    uint256 private constant _BALANCE_SLOT_SEED = 0x87a211a2;\n\n    /// @dev The allowance slot of (`owner`, `spender`) is given by:\n    /// ```\n    ///     mstore(0x20, spender)\n    ///     mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n    ///     mstore(0x00, owner)\n    ///     let allowanceSlot := keccak256(0x0c, 0x34)\n    /// ```\n    uint256 private constant _ALLOWANCE_SLOT_SEED = 0x7f5e9f20;\n\n    /// @dev The nonce slot of `owner` is given by:\n    /// ```\n    ///     mstore(0x0c, _NONCES_SLOT_SEED)\n    ///     mstore(0x00, owner)\n    ///     let nonceSlot := keccak256(0x0c, 0x20)\n    /// ```\n    uint256 private constant _NONCES_SLOT_SEED = 0x38377508;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         CONSTANTS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev `(_NONCES_SLOT_SEED << 16) | 0x1901`.\n    uint256 private constant _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX = 0x383775081901;\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")`.\n    bytes32 private constant _DOMAIN_TYPEHASH =\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    /// @dev `keccak256(\"1\")`.\n    /// If you need to use a different version, override `_versionHash`.\n    bytes32 private constant _DEFAULT_VERSION_HASH =\n        0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\n\n    /// @dev `keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")`.\n    bytes32 private constant _PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @dev The canonical Permit2 address.\n    /// For signature-based allowance granting for single transaction ERC20 `transferFrom`.\n    /// To enable, override `_givePermit2InfiniteAllowance()`.\n    /// [Github](https://github.com/Uniswap/permit2)\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\n    address internal constant _PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       ERC20 METADATA                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the name of the token.\n    function name() public view virtual returns (string memory);\n\n    /// @dev Returns the symbol of the token.\n    function symbol() public view virtual returns (string memory);\n\n    /// @dev Returns the decimals places of the token.\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                           ERC20                            */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the amount of tokens in existence.\n    function totalSupply() public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_TOTAL_SUPPLY_SLOT)\n        }\n    }\n\n    /// @dev Returns the amount of tokens owned by `owner`.\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        if (_givePermit2InfiniteAllowance()) {\n            if (spender == _PERMIT2) return type(uint256).max;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x34))\n        }\n    }\n\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n    ///\n    /// Emits a {Approval} event.\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        if (_givePermit2InfiniteAllowance()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // If `spender == _PERMIT2 && amount != type(uint256).max`.\n                if iszero(or(xor(shr(96, shl(96, spender)), _PERMIT2), iszero(not(amount)))) {\n                    mstore(0x00, 0x3f68539a) // `Permit2AllowanceIsFixedAtInfinity()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and store the amount.\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x34), amount)\n            // Emit the {Approval} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\n        }\n        return true;\n    }\n\n    /// @dev Transfer `amount` tokens from the caller to `to`.\n    ///\n    /// Requirements:\n    /// - `from` must at least have `amount`.\n    ///\n    /// Emits a {Transfer} event.\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        _beforeTokenTransfer(msg.sender, to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, caller())\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance of `to`.\n            // Will not overflow because the sum of all user balances\n            // cannot exceed the maximum uint256 value.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /// @dev Transfers `amount` tokens from `from` to `to`.\n    ///\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\n    ///\n    /// Requirements:\n    /// - `from` must at least have `amount`.\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\n    ///\n    /// Emits a {Transfer} event.\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\n        _beforeTokenTransfer(from, to, amount);\n        // Code duplication is for zero-cost abstraction if possible.\n        if (_givePermit2InfiniteAllowance()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let from_ := shl(96, from)\n                if iszero(eq(caller(), _PERMIT2)) {\n                    // Compute the allowance slot and load its value.\n                    mstore(0x20, caller())\n                    mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\n                    let allowanceSlot := keccak256(0x0c, 0x34)\n                    let allowance_ := sload(allowanceSlot)\n                    // If the allowance is not the maximum uint256 value.\n                    if not(allowance_) {\n                        // Revert if the amount to be transferred exceeds the allowance.\n                        if gt(amount, allowance_) {\n                            mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\n                            revert(0x1c, 0x04)\n                        }\n                        // Subtract and store the updated allowance.\n                        sstore(allowanceSlot, sub(allowance_, amount))\n                    }\n                }\n                // Compute the balance slot and load its value.\n                mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\n                let fromBalanceSlot := keccak256(0x0c, 0x20)\n                let fromBalance := sload(fromBalanceSlot)\n                // Revert if insufficient balance.\n                if gt(amount, fromBalance) {\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                    revert(0x1c, 0x04)\n                }\n                // Subtract and store the updated balance.\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\n                // Compute the balance slot of `to`.\n                mstore(0x00, to)\n                let toBalanceSlot := keccak256(0x0c, 0x20)\n                // Add and store the updated balance of `to`.\n                // Will not overflow because the sum of all user balances\n                // cannot exceed the maximum uint256 value.\n                sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n                // Emit the {Transfer} event.\n                mstore(0x20, amount)\n                log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let from_ := shl(96, from)\n                // Compute the allowance slot and load its value.\n                mstore(0x20, caller())\n                mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\n                let allowanceSlot := keccak256(0x0c, 0x34)\n                let allowance_ := sload(allowanceSlot)\n                // If the allowance is not the maximum uint256 value.\n                if not(allowance_) {\n                    // Revert if the amount to be transferred exceeds the allowance.\n                    if gt(amount, allowance_) {\n                        mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\n                        revert(0x1c, 0x04)\n                    }\n                    // Subtract and store the updated allowance.\n                    sstore(allowanceSlot, sub(allowance_, amount))\n                }\n                // Compute the balance slot and load its value.\n                mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\n                let fromBalanceSlot := keccak256(0x0c, 0x20)\n                let fromBalance := sload(fromBalanceSlot)\n                // Revert if insufficient balance.\n                if gt(amount, fromBalance) {\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                    revert(0x1c, 0x04)\n                }\n                // Subtract and store the updated balance.\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\n                // Compute the balance slot of `to`.\n                mstore(0x00, to)\n                let toBalanceSlot := keccak256(0x0c, 0x20)\n                // Add and store the updated balance of `to`.\n                // Will not overflow because the sum of all user balances\n                // cannot exceed the maximum uint256 value.\n                sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n                // Emit the {Transfer} event.\n                mstore(0x20, amount)\n                log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\n            }\n        }\n        _afterTokenTransfer(from, to, amount);\n        return true;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          EIP-2612                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev For more performance, override to return the constant value\n    /// of `keccak256(bytes(name()))` if `name()` will never change.\n    function _constantNameHash() internal view virtual returns (bytes32 result) {}\n\n    /// @dev If you need a different value, override this function.\n    function _versionHash() internal view virtual returns (bytes32 result) {\n        result = _DEFAULT_VERSION_HASH;\n    }\n\n    /// @dev For inheriting contracts to increment the nonce.\n    function _incrementNonce(address owner) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x0c, _NONCES_SLOT_SEED)\n            mstore(0x00, owner)\n            let nonceSlot := keccak256(0x0c, 0x20)\n            sstore(nonceSlot, add(1, sload(nonceSlot)))\n        }\n    }\n\n    /// @dev Returns the current nonce for `owner`.\n    /// This value is used to compute the signature for EIP-2612 permit.\n    function nonces(address owner) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the nonce slot and load its value.\n            mstore(0x0c, _NONCES_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /// @dev Sets `value` as the allowance of `spender` over the tokens of `owner`,\n    /// authorized by a signed approval by `owner`.\n    ///\n    /// Emits a {Approval} event.\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (_givePermit2InfiniteAllowance()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // If `spender == _PERMIT2 && value != type(uint256).max`.\n                if iszero(or(xor(shr(96, shl(96, spender)), _PERMIT2), iszero(not(value)))) {\n                    mstore(0x00, 0x3f68539a) // `Permit2AllowanceIsFixedAtInfinity()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n        bytes32 nameHash = _constantNameHash();\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\n        bytes32 versionHash = _versionHash();\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Revert if the block timestamp is greater than `deadline`.\n            if gt(timestamp(), deadline) {\n                mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.\n                revert(0x1c, 0x04)\n            }\n            let m := mload(0x40) // Grab the free memory pointer.\n            // Clean the upper 96 bits.\n            owner := shr(96, shl(96, owner))\n            spender := shr(96, shl(96, spender))\n            // Compute the nonce slot and load its value.\n            mstore(0x0e, _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX)\n            mstore(0x00, owner)\n            let nonceSlot := keccak256(0x0c, 0x20)\n            let nonceValue := sload(nonceSlot)\n            // Prepare the domain separator.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), nameHash)\n            mstore(add(m, 0x40), versionHash)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            mstore(0x2e, keccak256(m, 0xa0))\n            // Prepare the struct hash.\n            mstore(m, _PERMIT_TYPEHASH)\n            mstore(add(m, 0x20), owner)\n            mstore(add(m, 0x40), spender)\n            mstore(add(m, 0x60), value)\n            mstore(add(m, 0x80), nonceValue)\n            mstore(add(m, 0xa0), deadline)\n            mstore(0x4e, keccak256(m, 0xc0))\n            // Prepare the ecrecover calldata.\n            mstore(0x00, keccak256(0x2c, 0x42))\n            mstore(0x20, and(0xff, v))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            let t := staticcall(gas(), 1, 0x00, 0x80, 0x20, 0x20)\n            // If the ecrecover fails, the returndatasize will be 0x00,\n            // `owner` will be checked if it equals the hash at 0x00,\n            // which evaluates to false (i.e. 0), and we will revert.\n            // If the ecrecover succeeds, the returndatasize will be 0x20,\n            // `owner` will be compared against the returned address at 0x20.\n            if iszero(eq(mload(returndatasize()), owner)) {\n                mstore(0x00, 0xddafbaef) // `InvalidPermit()`.\n                revert(0x1c, 0x04)\n            }\n            // Increment and store the updated nonce.\n            sstore(nonceSlot, add(nonceValue, t)) // `t` is 1 if ecrecover succeeds.\n            // Compute the allowance slot and store the value.\n            // The `owner` is already at slot 0x20.\n            mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))\n            sstore(keccak256(0x2c, 0x34), value)\n            // Emit the {Approval} event.\n            log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }\n\n    /// @dev Returns the EIP-712 domain separator for the EIP-2612 permit.\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32 result) {\n        bytes32 nameHash = _constantNameHash();\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\n        bytes32 versionHash = _versionHash();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Grab the free memory pointer.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), nameHash)\n            mstore(add(m, 0x40), versionHash)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            result := keccak256(m, 0xa0)\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                  INTERNAL MINT FUNCTIONS                   */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\n    ///\n    /// Emits a {Transfer} event.\n    function _mint(address to, uint256 amount) internal virtual {\n        _beforeTokenTransfer(address(0), to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let totalSupplyBefore := sload(_TOTAL_SUPPLY_SLOT)\n            let totalSupplyAfter := add(totalSupplyBefore, amount)\n            // Revert if the total supply overflows.\n            if lt(totalSupplyAfter, totalSupplyBefore) {\n                mstore(0x00, 0xe5cfe957) // `TotalSupplyOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            // Store the updated total supply.\n            sstore(_TOTAL_SUPPLY_SLOT, totalSupplyAfter)\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(address(0), to, amount);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                  INTERNAL BURN FUNCTIONS                   */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\n    ///\n    /// Emits a {Transfer} event.\n    function _burn(address from, uint256 amount) internal virtual {\n        _beforeTokenTransfer(from, address(0), amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, from)\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Subtract and store the updated total supply.\n            sstore(_TOTAL_SUPPLY_SLOT, sub(sload(_TOTAL_SUPPLY_SLOT), amount))\n            // Emit the {Transfer} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)\n        }\n        _afterTokenTransfer(from, address(0), amount);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Moves `amount` of tokens from `from` to `to`.\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        _beforeTokenTransfer(from, to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let from_ := shl(96, from)\n            // Compute the balance slot and load its value.\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance of `to`.\n            // Will not overflow because the sum of all user balances\n            // cannot exceed the maximum uint256 value.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                INTERNAL ALLOWANCE FUNCTIONS                */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Updates the allowance of `owner` for `spender` based on spent `amount`.\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        if (_givePermit2InfiniteAllowance()) {\n            if (spender == _PERMIT2) return; // Do nothing, as allowance is infinite.\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and load its value.\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            let allowanceSlot := keccak256(0x0c, 0x34)\n            let allowance_ := sload(allowanceSlot)\n            // If the allowance is not the maximum uint256 value.\n            if not(allowance_) {\n                // Revert if the amount to be transferred exceeds the allowance.\n                if gt(amount, allowance_) {\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\n                    revert(0x1c, 0x04)\n                }\n                // Subtract and store the updated allowance.\n                sstore(allowanceSlot, sub(allowance_, amount))\n            }\n        }\n    }\n\n    /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.\n    ///\n    /// Emits a {Approval} event.\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        if (_givePermit2InfiniteAllowance()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // If `spender == _PERMIT2 && amount != type(uint256).max`.\n                if iszero(or(xor(shr(96, shl(96, spender)), _PERMIT2), iszero(not(amount)))) {\n                    mstore(0x00, 0x3f68539a) // `Permit2AllowanceIsFixedAtInfinity()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let owner_ := shl(96, owner)\n            // Compute the allowance slot and store the amount.\n            mstore(0x20, spender)\n            mstore(0x0c, or(owner_, _ALLOWANCE_SLOT_SEED))\n            sstore(keccak256(0x0c, 0x34), amount)\n            // Emit the {Approval} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, owner_), shr(96, mload(0x2c)))\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                     HOOKS TO OVERRIDE                      */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Hook that is called before any transfer of tokens.\n    /// This includes minting and burning.\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /// @dev Hook that is called after any transfer of tokens.\n    /// This includes minting and burning.\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          PERMIT2                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns whether to fix the Permit2 contract's allowance at infinity.\n    ///\n    /// This value should be kept constant after contract initialization,\n    /// or else the actual allowance values may not match with the {Approval} events.\n    /// For best performance, return a compile-time constant for zero-cost abstraction.\n    function _givePermit2InfiniteAllowance() internal view virtual returns (bool) {\n        return true;\n    }\n}\n"}, "lib/solady/src/utils/SafeTransferLib.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\n///\n/// @dev Note:\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\nlibrary SafeTransferLib {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /// @dev The ERC20 `transferFrom` has failed.\n    error TransferFromFailed();\n\n    /// @dev The ERC20 `transfer` has failed.\n    error TransferFailed();\n\n    /// @dev The ERC20 `approve` has failed.\n    error ApproveFailed();\n\n    /// @dev The ERC20 `totalSupply` query has failed.\n    error TotalSupplyQueryFailed();\n\n    /// @dev The Permit2 operation has failed.\n    error Permit2Failed();\n\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\n    error Permit2AmountOverflow();\n\n    /// @dev The Permit2 approve operation has failed.\n    error Permit2ApproveFailed();\n\n    /// @dev The Permit2 lockdown operation has failed.\n    error Permit2LockdownFailed();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         CONSTANTS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\n\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\n    /// storage reads and writes, but low enough to prevent griefing.\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\n\n    /// @dev The unique EIP-712 domain domain separator for the DAI token contract.\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\n\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /// @dev The canonical Permit2 address.\n    /// [Github](https://github.com/Uniswap/permit2)\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       ETH OPERATIONS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\n    //\n    // The regular variants:\n    // - Forwards all remaining gas to the target.\n    // - Reverts if the target reverts.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The force variants:\n    // - Forwards with an optional gas stipend\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\n    // - If the target reverts, or if the gas stipend is exhausted,\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The try variants:\n    // - Forwards with a mandatory gas stipend.\n    // - Instead of reverting, returns whether the transfer succeeded.\n\n    /// @dev Sends `amount` (in wei) ETH to `to`.\n    function safeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`.\n    function safeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer all the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // forgefmt: disable-next-item\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      ERC20 OPERATIONS                      */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for\n    /// the current contract to manage.\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                success := lt(or(iszero(extcodesize(token)), returndatasize()), success)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have their entire balance approved for the current contract to manage.\n    function safeTransferAllFrom(address token, address from, address to)\n        internal\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransfer(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n            mstore(0x20, address()) // Store the address of the current contract.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x14, to) // Store the `to` argument.\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// Reverts upon failure.\n    function safeApprove(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\n    /// Reverts upon failure.\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, retrying upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x34, 0) // Store 0 for the `amount`.\n                    mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n                    pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\n                    mstore(0x34, amount) // Store back the original `amount`.\n                    // Retry the approval, reverting upon failure.\n                    success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                    if iszero(and(eq(mload(0x00), 1), success)) {\n                        // Check the `extcodesize` again just in case the token selfdestructs lol.\n                        if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                            mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                            revert(0x1c, 0x04)\n                        }\n                    }\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\n    /// Returns zero if the `token` does not exist.\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, account) // Store the `account` argument.\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            amount :=\n                mul( // The arguments of `mul` are evaluated from right to left.\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\n                    )\n                )\n        }\n    }\n\n    /// @dev Returns the total supply of the `token`.\n    /// Reverts if the token does not exist or does not implement `totalSupply()`.\n    function totalSupply(address token) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x18160ddd) // `totalSupply()`.\n            if iszero(\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), token, 0x1c, 0x04, 0x00, 0x20))\n            ) {\n                mstore(0x00, 0x54cd9435) // `TotalSupplyQueryFailed()`.\n                revert(0x1c, 0x04)\n            }\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\n        if (!trySafeTransferFrom(token, from, to, amount)) {\n            permit2TransferFrom(token, from, to, amount);\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\n    /// Reverts upon failure.\n    function permit2TransferFrom(address token, address from, address to, uint256 amount)\n        internal\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\n            mstore(add(m, 0x54), amount)\n            mstore(add(m, 0x34), to)\n            mstore(add(m, 0x20), shl(96, from))\n            // `transferFrom(address,address,uint160,address)`.\n            mstore(m, 0x36c78516000000000000000000000000)\n            let p := PERMIT2\n            let exists := eq(chainid(), 1)\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\n            if iszero(\n                and(\n                    call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00),\n                    lt(iszero(extcodesize(token)), exists) // Token has code and Permit2 exists.\n                )\n            ) {\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\n            }\n        }\n    }\n\n    /// @dev Permit a user to spend a given amount of\n    /// another user's tokens via native EIP-2612 permit if possible, falling\n    /// back to Permit2 if native permit fails or is not implemented on the token.\n    function permit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        bool success;\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} shl(96, xor(token, WETH9)) {} {\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\n                if iszero(\n                    and( // The arguments of `and` are evaluated from right to left.\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\n                    )\n                ) { break }\n                // After here, we can be sure that token is a contract.\n                let m := mload(0x40)\n                mstore(add(m, 0x34), spender)\n                mstore(add(m, 0x20), shl(96, owner))\n                mstore(add(m, 0x74), deadline)\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\n                    mstore(0x14, owner)\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\n                    mstore(\n                        add(m, 0x94),\n                        lt(iszero(amount), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\n                    )\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\n                    // `nonces` is already at `add(m, 0x54)`.\n                    // `amount != 0` is already stored at `add(m, 0x94)`.\n                    mstore(add(m, 0xb4), and(0xff, v))\n                    mstore(add(m, 0xd4), r)\n                    mstore(add(m, 0xf4), s)\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\n                    break\n                }\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\n                mstore(add(m, 0x54), amount)\n                mstore(add(m, 0x94), and(0xff, v))\n                mstore(add(m, 0xb4), r)\n                mstore(add(m, 0xd4), s)\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\n                break\n            }\n        }\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\n    }\n\n    /// @dev Simple permit on the Permit2 contract.\n    function simplePermit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\n            {\n                let addressMask := shr(96, not(0))\n                mstore(add(m, 0x20), and(addressMask, owner))\n                mstore(add(m, 0x40), and(addressMask, token))\n                mstore(add(m, 0x60), and(addressMask, spender))\n                mstore(add(m, 0xc0), and(addressMask, spender))\n            }\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\n                )\n            ) {\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\n            }\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\n            // `owner` is already `add(m, 0x20)`.\n            // `token` is already at `add(m, 0x40)`.\n            mstore(add(m, 0x60), amount)\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\n            // `nonce` is already at `add(m, 0xa0)`.\n            // `spender` is already at `add(m, 0xc0)`.\n            mstore(add(m, 0xe0), deadline)\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\n            mstore(add(m, 0x120), 0x41) // `signature` length.\n            mstore(add(m, 0x140), r)\n            mstore(add(m, 0x160), s)\n            mstore(add(m, 0x180), shl(248, v))\n            if iszero( // Revert if token does not have code, or if the call fails.\n            mul(extcodesize(token), call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00))) {\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Approves `spender` to spend `amount` of `token` for `address(this)`.\n    function permit2Approve(address token, address spender, uint160 amount, uint48 expiration)\n        internal\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let addressMask := shr(96, not(0))\n            let m := mload(0x40)\n            mstore(m, 0x87517c45) // `approve(address,address,uint160,uint48)`.\n            mstore(add(m, 0x20), and(addressMask, token))\n            mstore(add(m, 0x40), and(addressMask, spender))\n            mstore(add(m, 0x60), and(addressMask, amount))\n            mstore(add(m, 0x80), and(0xffffffffffff, expiration))\n            if iszero(call(gas(), PERMIT2, 0, add(m, 0x1c), 0xa0, codesize(), 0x00)) {\n                mstore(0x00, 0x324f14ae) // `Permit2ApproveFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Revokes an approval for `token` and `spender` for `address(this)`.\n    function permit2Lockdown(address token, address spender) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0xcc53287f) // `Permit2.lockdown`.\n            mstore(add(m, 0x20), 0x20) // Offset of the `approvals`.\n            mstore(add(m, 0x40), 1) // `approvals.length`.\n            mstore(add(m, 0x60), shr(96, shl(96, token)))\n            mstore(add(m, 0x80), shr(96, shl(96, spender)))\n            if iszero(call(gas(), PERMIT2, 0, add(m, 0x1c), 0xa0, codesize(), 0x00)) {\n                mstore(0x00, 0x96b3de23) // `Permit2LockdownFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"}, "lib/solady/src/utils/FixedPointMathLib.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error ExpOverflow();\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error FactorialOverflow();\n\n    /// @dev The operation failed, due to an overflow.\n    error RPowOverflow();\n\n    /// @dev The mantissa is too big to fit.\n    error MantissaOverflow();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error MulWadFailed();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error SMulWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error DivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error SDivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error MulDivFailed();\n\n    /// @dev The division failed, as the denominator is zero.\n    error DivFailed();\n\n    /// @dev The full precision multiply-divide operation failed, either due\n    /// to the result being larger than 256 bits, or a division by a zero.\n    error FullMulDivFailed();\n\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\n    error LnWadUndefined();\n\n    /// @dev The input outside the acceptable domain.\n    error OutOfDomain();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         CONSTANTS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The scalar of ETH and most ERC20s.\n    uint256 internal constant WAD = 1e18;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if gt(x, div(not(0), y)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function sMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require((x == 0 || z / x == y) && !(x == -1 && y == type(int256).min))`.\n            if iszero(gt(or(iszero(x), eq(sdiv(z, x), y)), lt(not(x), eq(y, shl(255, 1))))) {\n                mstore(0x00, 0xedcd4dd4) // `SMulWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawMulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawSMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if iszero(eq(div(z, y), x)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := add(iszero(iszero(mod(z, WAD))), div(z, WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up, but without overflow checks.\n    function rawMulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function sDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, WAD)\n            // Equivalent to `require(y != 0 && ((x * WAD) / WAD == x))`.\n            if iszero(mul(y, eq(sdiv(z, WAD), x))) {\n                mstore(0x00, 0x5c43740d) // `SDivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawDivWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawSDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up, but without overflow and divide by zero checks.\n    function rawDivWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `x` to the power of `y`.\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\n    /// Note: This function is an approximation.\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Using `ln(x)` means `x` must be greater than 0.\n        return expWad((lnWad(x) * y) / int256(WAD));\n    }\n\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2\u03c0.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is less than 0.5 we return zero.\n            // This happens when `x <= (log(1e-18) * 1e18) ~ -4.15e19`.\n            if (x <= -41446531673892822313) return r;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // When the result is greater than `(2**255 - 1) / 1e18` we can not represent it as\n                // an int. This happens when `x >= floor(log((2**255 - 1) / 1e18) * 1e18) \u2248 135`.\n                if iszero(slt(x, 135305999368893231589)) {\n                    mstore(0x00, 0xa37bfec9) // `ExpOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            // `x` is now in the range `(-42, 136) * 1e18`. Convert to `(-42, 136) * 2**96`\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5 ** 18;\n\n            // Reduce range of x to (-\u00bd ln 2, \u00bd ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // `k` is in the range `[-61, 195]`.\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // `p` is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already `2**96` too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range `(0.09, 0.25) * 2**96`.\n\n            // We now need to multiply r by:\n            // - The scale factor `s \u2248 6.031367120`.\n            // - The `2**k` factor from the range reduction.\n            // - The `1e18 / 2**96` factor for base conversion.\n            // We do this all at once, with an intermediate result in `2**213`\n            // basis, so the final right shift is always by a positive amount.\n            r = int256(\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\n            );\n        }\n    }\n\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2\u03c0.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We want to convert `x` from `10**18` fixed point to `2**96` fixed point.\n            // We do this by multiplying by `2**96 / 10**18`. But since\n            // `ln(x * C) = ln(x) + ln(C)`, we can simply do nothing here\n            // and add `ln(2**96 / 10**18)` at the end.\n\n            // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // We place the check here for more optimal stack operations.\n            if iszero(sgt(x, 0)) {\n                mstore(0x00, 0x1615e638) // `LnWadUndefined()`.\n                revert(0x1c, 0x04)\n            }\n            // forgefmt: disable-next-item\n            r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            x := shr(159, shl(r, x))\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // `p` is made monic, we will multiply by a scale factor later.\n            // forgefmt: disable-next-item\n            let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.\n                sar(96, mul(add(43456485725739037958740375743393,\n                sar(96, mul(add(24828157081833163892658089445524,\n                sar(96, mul(add(3273285459638523848632254066296,\n                    x), x))), x))), x)), 11111509109440967052023855526967)\n            p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)\n            p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)\n            p := sub(mul(p, x), shl(96, 795164235651350426258249787498))\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n\n            // `q` is monic by convention.\n            let q := add(5573035233440673466300451813936, x)\n            q := add(71694874799317883764090561454958, sar(96, mul(x, q)))\n            q := add(283447036172924575727196451306956, sar(96, mul(x, q)))\n            q := add(401686690394027663651624208769553, sar(96, mul(x, q)))\n            q := add(204048457590392012362485061816622, sar(96, mul(x, q)))\n            q := add(31853899698501571402653359427138, sar(96, mul(x, q)))\n            q := add(909429971244387300277376558375, sar(96, mul(x, q)))\n\n            // `p / q` is in the range `(0, 0.125) * 2**96`.\n\n            // Finalization, we need to:\n            // - Multiply by the scale factor `s = 5.549\u2026`.\n            // - Add `ln(2**96 / 10**18)`.\n            // - Add `k * ln(2)`.\n            // - Multiply by `10**18 / 2**96 = 5**18 >> 78`.\n\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already `2**96` too large.\n            p := sdiv(p, q)\n            // Multiply by the scaling factor: `s * 5**18 * 2**96`, base is now `5**18 * 2**192`.\n            p := mul(1677202110996718588342820967067443963516166, p)\n            // Add `ln(2) * k * 5**18 * 2**192`.\n            // forgefmt: disable-next-item\n            p := add(mul(16597577552685614221487285958193947469193820559219878177908093499208371, sub(159, r)), p)\n            // Add `ln(2**96 / 10**18) * 5**18 * 2**192`.\n            p := add(600920179829731861736702779321621459595472258049074101567377883020018308, p)\n            // Base conversion: mul `2**18 / 2**192`.\n            r := sar(174, p)\n        }\n    }\n\n    /// @dev Returns `W_0(x)`, denominated in `WAD`.\n    /// See: https://en.wikipedia.org/wiki/Lambert_W_function\n    /// a.k.a. Product log function. This is an approximation of the principal branch.\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lambertW0Wad(int256 x) internal pure returns (int256 w) {\n        // forgefmt: disable-next-item\n        unchecked {\n            if ((w = x) <= -367879441171442322) revert OutOfDomain(); // `x` less than `-1/e`.\n            (int256 wad, int256 p) = (int256(WAD), x);\n            uint256 c; // Whether we need to avoid catastrophic cancellation.\n            uint256 i = 4; // Number of iterations.\n            if (w <= 0x1ffffffffffff) {\n                if (-0x4000000000000 <= w) {\n                    i = 1; // Inputs near zero only take one step to converge.\n                } else if (w <= -0x3ffffffffffffff) {\n                    i = 32; // Inputs near `-1/e` take very long to converge.\n                }\n            } else if (uint256(w >> 63) == uint256(0)) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // Inline log2 for more performance, since the range is small.\n                    let v := shr(49, w)\n                    let l := shl(3, lt(0xff, v))\n                    l := add(or(l, byte(and(0x1f, shr(shr(l, v), 0x8421084210842108cc6318c6db6d54be)),\n                        0x0706060506020504060203020504030106050205030304010505030400000000)), 49)\n                    w := sdiv(shl(l, 7), byte(sub(l, 31), 0x0303030303030303040506080c13))\n                    c := gt(l, 60)\n                    i := add(2, add(gt(l, 53), c))\n                }\n            } else {\n                int256 ll = lnWad(w = lnWad(w));\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // `w = ln(x) - ln(ln(x)) + b * ln(ln(x)) / ln(x)`.\n                    w := add(sdiv(mul(ll, 1023715080943847266), w), sub(w, ll))\n                    i := add(3, iszero(shr(68, x)))\n                    c := iszero(shr(143, x))\n                }\n                if (c == uint256(0)) {\n                    do { // If `x` is big, use Newton's so that intermediate values won't overflow.\n                        int256 e = expWad(w);\n                        /// @solidity memory-safe-assembly\n                        assembly {\n                            let t := mul(w, div(e, wad))\n                            w := sub(w, sdiv(sub(t, x), div(add(e, t), wad)))\n                        }\n                        if (p <= w) break;\n                        p = w;\n                    } while (--i != uint256(0));\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        w := sub(w, sgt(w, 2))\n                    }\n                    return w;\n                }\n            }\n            do { // Otherwise, use Halley's for faster convergence.\n                int256 e = expWad(w);\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let t := add(w, wad)\n                    let s := sub(mul(w, e), mul(x, wad))\n                    w := sub(w, sdiv(mul(s, wad), sub(mul(e, t), sdiv(mul(add(t, wad), s), add(t, t)))))\n                }\n                if (p <= w) break;\n                p = w;\n            } while (--i != c);\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sub(w, sgt(w, 2))\n            }\n            // For certain ranges of `x`, we'll use the quadratic-rate recursive formula of\n            // R. Iacono and J.P. Boyd for the last iteration, to avoid catastrophic cancellation.\n            if (c == uint256(0)) return w;\n            int256 t = w | 1;\n            /// @solidity memory-safe-assembly\n            assembly {\n                x := sdiv(mul(x, wad), t)\n            }\n            x = (t * (wad + lnWad(x)));\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sdiv(x, add(wad, t))\n            }\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                  GENERAL NUMBER UTILITIES                  */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns `a * b == x * y`, with full precision.\n    function fullMulEq(uint256 a, uint256 b, uint256 x, uint256 y)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(mul(a, b), mul(x, y)), eq(mulmod(x, y, not(0)), mulmod(a, b, not(0))))\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Remco Bloemen under MIT license: https://2\u03c0.com/21/muldiv\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // 512-bit multiply `[p1 p0] = x * y`.\n            // Compute the product mod `2**256` and mod `2**256 - 1`\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that `product = p1 * 2**256 + p0`.\n\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`.\n            for {} 1 {} {\n                // If overflows.\n                if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n\n                    /*------------------- 512 by 256 division --------------------*/\n\n                    // Make division exact by subtracting the remainder from `[p1 p0]`.\n                    let r := mulmod(x, y, d) // Compute remainder using mulmod.\n                    let t := and(d, sub(0, d)) // The least significant bit of `d`. `t >= 1`.\n                    // Make sure `z` is less than `2**256`. Also prevents `d == 0`.\n                    // Placing the check here seems to give more optimal stack operations.\n                    if iszero(gt(d, p1)) {\n                        mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    d := div(d, t) // Divide `d` by `t`, which is a power of two.\n                    // Invert `d mod 2**256`\n                    // Now that `d` is an odd number, it has an inverse\n                    // modulo `2**256` such that `d * inv = 1 mod 2**256`.\n                    // Compute the inverse by starting with a seed that is correct\n                    // correct for four bits. That is, `d * inv = 1 mod 2**4`.\n                    let inv := xor(2, mul(3, d))\n                    // Now use Newton-Raphson iteration to improve the precision.\n                    // Thanks to Hensel's lifting lemma, this also works in modular\n                    // arithmetic, doubling the correct bits in each step.\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\n                    z :=\n                        mul(\n                            // Divide [p1 p0] by the factors of two.\n                            // Shift in bits from `p1` into `p0`. For this we need\n                            // to flip `t` such that it is `2**256 / t`.\n                            or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                            mul(sub(2, mul(d, inv)), inv) // inverse mod 2**256\n                        )\n                    break\n                }\n                z := div(z, d)\n                break\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Behavior is undefined if `d` is zero or the final result cannot fit in 256 bits.\n    /// Performs the full 512 bit calculation regardless.\n    function fullMulDivUnchecked(uint256 x, uint256 y, uint256 d)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            let mm := mulmod(x, y, not(0))\n            let p1 := sub(mm, add(z, lt(mm, z)))\n            let t := and(d, sub(0, d))\n            let r := mulmod(x, y, d)\n            d := div(d, t)\n            let inv := xor(2, mul(3, d))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            z :=\n                mul(\n                    or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                    mul(sub(2, mul(d, inv)), inv)\n                )\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Uniswap-v3-core under MIT license:\n    /// https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/FullMath.sol\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        z = fullMulDiv(x, y, d);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mulmod(x, y, d) {\n                z := add(z, 1)\n                if iszero(z) {\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / 2 ** n)` with full precision.\n    /// Throws if result overflows a uint256.\n    /// Credit to Philogy under MIT license:\n    /// https://github.com/SorellaLabs/angstrom/blob/main/contracts/src/libraries/X128MathLib.sol\n    function fullMulDivN(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`. We'll call this `z`.\n            for {} 1 {} {\n                if iszero(or(iszero(x), eq(div(z, x), y))) {\n                    let k := and(n, 0xff) // `n`, cleaned.\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n                    //         |      p1     |      z     |\n                    // Before: | p1_0 \u00a6 p1_1 | z_0  \u00a6 z_1 |\n                    // Final:  |   0  \u00a6 p1_0 | p1_1 \u00a6 z_0 |\n                    // Check that final `z` doesn't overflow by checking that p1_0 = 0.\n                    if iszero(shr(k, p1)) {\n                        z := add(shl(sub(256, k), p1), shr(k, z))\n                        break\n                    }\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                z := shr(and(n, 0xff), z)\n                break\n            }\n        }\n    }\n\n    /// @dev Returns `floor(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(z, d)\n        }\n    }\n\n    /// @dev Returns `ceil(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(z, d))), div(z, d))\n        }\n    }\n\n    /// @dev Returns `x`, the modular multiplicative inverse of `a`, such that `(a * x) % n == 1`.\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256 x) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let g := n\n            let r := mod(a, n)\n            for { let y := 1 } 1 {} {\n                let q := div(g, r)\n                let t := g\n                g := r\n                r := sub(t, mul(r, q))\n                let u := x\n                x := y\n                y := sub(u, mul(y, q))\n                if iszero(r) { break }\n            }\n            x := mul(eq(g, 1), add(x, mul(slt(x, 0), n)))\n        }\n    }\n\n    /// @dev Returns `ceil(x / d)`.\n    /// Reverts if `d` is zero.\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(d) {\n                mstore(0x00, 0x65244e4e) // `DivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\n        }\n    }\n\n    /// @dev Returns `max(0, x - y)`.\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, address x, address y) internal pure returns (address z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Exponentiate `x` to `y` by squaring, denominated in base `b`.\n    /// Reverts if the computation overflows.\n    function rpow(uint256 x, uint256 y, uint256 b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(b, iszero(y)) // `0 ** 0 = 1`. Otherwise, `0 ** n = 0`.\n            if x {\n                z := xor(b, mul(xor(b, x), and(y, 1))) // `z = isEven(y) ? scale : x`\n                let half := shr(1, b) // Divide `b` by 2.\n                // Divide `y` by 2 every iteration.\n                for { y := shr(1, y) } y { y := shr(1, y) } {\n                    let xx := mul(x, x) // Store x squared.\n                    let xxRound := add(xx, half) // Round to the nearest number.\n                    // Revert if `xx + half` overflowed, or if `x ** 2` overflows.\n                    if or(lt(xxRound, xx), shr(128, x)) {\n                        mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                        revert(0x1c, 0x04)\n                    }\n                    x := div(xxRound, b) // Set `x` to scaled `xxRound`.\n                    // If `y` is odd:\n                    if and(y, 1) {\n                        let zx := mul(z, x) // Compute `z * x`.\n                        let zxRound := add(zx, half) // Round to the nearest number.\n                        // If `z * x` overflowed or `zx + half` overflowed:\n                        if or(xor(div(zx, x), z), lt(zxRound, zx)) {\n                            // Revert if `x` is non-zero.\n                            if x {\n                                mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                                revert(0x1c, 0x04)\n                            }\n                        }\n                        z := div(zxRound, b) // Return properly scaled `zxRound`.\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns the square root of `x`, rounded down.\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // Let `y = x / 2**r`. We check `y >= 2**(k + 8)`\n            // but shift right by `k` bits to ensure that if `x >= 256`, then `y >= 256`.\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\n            z := shl(shr(1, r), z)\n\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\n\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\n\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\n\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\n            // Then we can estimate `sqrt(y)` using\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\n\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If `x+1` is a perfect square, the Babylonian method cycles between\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, rounded down.\n    /// Credit to bout3fiddy and pcaversaccio under AGPLv3 license:\n    /// https://github.com/pcaversaccio/snekmate/blob/main/src/utils/Math.vy\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // Makeshift lookup table to nudge the approximate log2 result.\n            z := div(shl(div(r, 3), shl(lt(0xf, shr(r, x)), 0xf)), xor(7, mod(r, 3)))\n            // Newton-Raphson's.\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            // Round down.\n            z := sub(z, lt(div(x, mul(z, z)), z))\n        }\n    }\n\n    /// @dev Returns the square root of `x`, denominated in `WAD`, rounded down.\n    function sqrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 18) return sqrt(x * 10 ** 18);\n            z = (1 + sqrt(x)) * 10 ** 9;\n            z = (fullMulDivUnchecked(x, 10 ** 18, z) + z) >> 1;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sub(z, gt(999999999999999999, sub(mulmod(z, z, x), 1))) // Round down.\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, denominated in `WAD`, rounded down.\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 36) return cbrt(x * 10 ** 36);\n            z = (1 + cbrt(x)) * 10 ** 12;\n            z = (fullMulDivUnchecked(x, 10 ** 36, z * z) + z + z) / 3;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let p := x\n            for {} 1 {} {\n                if iszero(shr(229, p)) {\n                    if iszero(shr(199, p)) {\n                        p := mul(p, 100000000000000000) // 10 ** 17.\n                        break\n                    }\n                    p := mul(p, 100000000) // 10 ** 8.\n                    break\n                }\n                if iszero(shr(249, p)) { p := mul(p, 100) }\n                break\n            }\n            let t := mulmod(mul(z, z), z, p)\n            z := sub(z, gt(lt(t, shr(1, p)), iszero(t))) // Round down.\n        }\n    }\n\n    /// @dev Returns the factorial of `x`.\n    function factorial(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := 1\n            if iszero(lt(x, 58)) {\n                mstore(0x00, 0xaba0f2a2) // `FactorialOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            for {} x { x := sub(x, 1) } { z := mul(z, x) }\n        }\n    }\n\n    /// @dev Returns the log2 of `x`.\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\n    /// Returns 0 if `x` is zero.\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020504060203020504030106050205030304010505030400000000))\n        }\n    }\n\n    /// @dev Returns the log2 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\n        r = log2(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(r, 1), x))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log10(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, 100000000000000000000000000000000000000)) {\n                x := div(x, 100000000000000000000000000000000000000)\n                r := 38\n            }\n            if iszero(lt(x, 100000000000000000000)) {\n                x := div(x, 100000000000000000000)\n                r := add(r, 20)\n            }\n            if iszero(lt(x, 10000000000)) {\n                x := div(x, 10000000000)\n                r := add(r, 10)\n            }\n            if iszero(lt(x, 100000)) {\n                x := div(x, 100000)\n                r := add(r, 5)\n            }\n            r := add(r, add(gt(x, 9), add(gt(x, 99), add(gt(x, 999), gt(x, 9999)))))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log10Up(uint256 x) internal pure returns (uint256 r) {\n        r = log10(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(exp(10, r), x))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(shr(3, r), lt(0xff, shr(r, x)))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log256Up(uint256 x) internal pure returns (uint256 r) {\n        r = log256(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(shl(3, r), 1), x))\n        }\n    }\n\n    /// @dev Returns the scientific notation format `mantissa * 10 ** exponent` of `x`.\n    /// Useful for compressing prices (e.g. using 25 bit mantissa and 7 bit exponent).\n    function sci(uint256 x) internal pure returns (uint256 mantissa, uint256 exponent) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mantissa := x\n            if mantissa {\n                if iszero(mod(mantissa, 1000000000000000000000000000000000)) {\n                    mantissa := div(mantissa, 1000000000000000000000000000000000)\n                    exponent := 33\n                }\n                if iszero(mod(mantissa, 10000000000000000000)) {\n                    mantissa := div(mantissa, 10000000000000000000)\n                    exponent := add(exponent, 19)\n                }\n                if iszero(mod(mantissa, 1000000000000)) {\n                    mantissa := div(mantissa, 1000000000000)\n                    exponent := add(exponent, 12)\n                }\n                if iszero(mod(mantissa, 1000000)) {\n                    mantissa := div(mantissa, 1000000)\n                    exponent := add(exponent, 6)\n                }\n                if iszero(mod(mantissa, 10000)) {\n                    mantissa := div(mantissa, 10000)\n                    exponent := add(exponent, 4)\n                }\n                if iszero(mod(mantissa, 100)) {\n                    mantissa := div(mantissa, 100)\n                    exponent := add(exponent, 2)\n                }\n                if iszero(mod(mantissa, 10)) {\n                    mantissa := div(mantissa, 10)\n                    exponent := add(exponent, 1)\n                }\n            }\n        }\n    }\n\n    /// @dev Convenience function for packing `x` into a smaller number using `sci`.\n    /// The `mantissa` will be in bits [7..255] (the upper 249 bits).\n    /// The `exponent` will be in bits [0..6] (the lower 7 bits).\n    /// Use `SafeCastLib` to safely ensure that the `packed` number is small\n    /// enough to fit in the desired unsigned integer type:\n    /// ```\n    ///     uint32 packed = SafeCastLib.toUint32(FixedPointMathLib.packSci(777 ether));\n    /// ```\n    function packSci(uint256 x) internal pure returns (uint256 packed) {\n        (x, packed) = sci(x); // Reuse for `mantissa` and `exponent`.\n        /// @solidity memory-safe-assembly\n        assembly {\n            if shr(249, x) {\n                mstore(0x00, 0xce30380c) // `MantissaOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            packed := or(shl(7, x), packed)\n        }\n    }\n\n    /// @dev Convenience function for unpacking a packed number from `packSci`.\n    function unpackSci(uint256 packed) internal pure returns (uint256 unpacked) {\n        unchecked {\n            unpacked = (packed >> 7) * 10 ** (packed & 0x7f);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards zero.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = (x & y) + ((x ^ y) >> 1);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards negative infinity.\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @dev Returns the absolute value of `x`.\n    function abs(int256 x) internal pure returns (uint256 z) {\n        unchecked {\n            z = (uint256(x) + uint256(x >> 255)) ^ uint256(x >> 255);\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, gt(x, y)), sub(y, x)), gt(x, y))\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, sgt(x, y)), sub(y, x)), sgt(x, y))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), lt(y, x)))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), slt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), gt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), gt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), lt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), sgt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), slt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns greatest common divisor of `x` and `y`.\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { z := x } y {} {\n                let t := y\n                y := mod(z, y)\n                z := t\n            }\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`,\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(uint256 a, uint256 b, uint256 t, uint256 begin, uint256 end)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        unchecked {\n            if (b >= a) return a + fullMulDiv(b - a, t - begin, end - begin);\n            return a - fullMulDiv(a - b, t - begin, end - begin);\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`.\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(int256 a, int256 b, int256 t, int256 begin, int256 end)\n        internal\n        pure\n        returns (int256)\n    {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        // forgefmt: disable-next-item\n        unchecked {\n            if (b >= a) return int256(uint256(a) + fullMulDiv(uint256(b - a),\n                uint256(t - begin), uint256(end - begin)));\n            return int256(uint256(a) - fullMulDiv(uint256(a - b),\n                uint256(t - begin), uint256(end - begin)));\n        }\n    }\n\n    /// @dev Returns if `x` is an even number. Some people may need this.\n    function isEven(uint256 x) internal pure returns (bool) {\n        return x & uint256(1) == uint256(0);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                   RAW NUMBER OPERATIONS                    */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(x, y)\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mod(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := smod(x, y)\n        }\n    }\n\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := addmod(x, y, d)\n        }\n    }\n\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mulmod(x, y, d)\n        }\n    }\n}\n"}, "src/lib/VaultMath.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {ERC4626} from \"solady/tokens/ERC4626.sol\";\n\nfunction getReservesInUnderlying(uint256 reserveAmount, ERC4626 vault) view returns (uint256) {\n    return address(vault) == address(0) ? reserveAmount : vault.previewRedeem(reserveAmount);\n}\n"}, "src/types/PoolState.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {PoolId, PoolKey, Currency} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\n\nimport {SSTORE2} from \"solady/utils/SSTORE2.sol\";\nimport {ERC4626} from \"solady/tokens/ERC4626.sol\";\n\nimport \"./LDFType.sol\";\nimport \"./IdleBalance.sol\";\nimport \"../base/Errors.sol\";\nimport {IHooklet} from \"../interfaces/IHooklet.sol\";\nimport {HubStorage} from \"../base/SharedStructs.sol\";\nimport {IBunniToken} from \"../interfaces/IBunniToken.sol\";\nimport {ILiquidityDensityFunction} from \"../interfaces/ILiquidityDensityFunction.sol\";\n\nusing SSTORE2 for address;\n\n/// @notice The state of a Bunni pool\n/// @member liquidityDensityFunction The LDF that dictates how liquidity is distributed\n/// @member bunniToken The BunniToken for this pool\n/// @member hooklet The hooklet for this pool. Set to address(0) if the pool does not have a hooklet.\n/// @member twapSecondsAgo The time window for the TWAP used by the LDF. Set to 0 if the LDF does not use the TWAP.\n/// @member ldfParams The parameters for the LDF\n/// @member hookParams The hook parameters for the pool\n/// @member vault0 The ERC4626 vault used for currency0\n/// @member vault1 The ERC4626 vault used for currency1\n/// @member ldfType The type of LDF. See LDFType.sol for details.\n/// @member minRawTokenRatio0 The minimum (rawBalance / balance) ratio for currency0\n/// @member targetRawTokenRatio0 The target (rawBalance / balance) ratio for currency0\n/// @member maxRawTokenRatio0 The maximum (rawBalance / balance) ratio for currency0\n/// @member minRawTokenRatio1 The minimum (rawBalance / balance) ratio for currency1\n/// @member targetRawTokenRatio1 The target (rawBalance / balance) ratio for currency1\n/// @member maxRawTokenRatio1 The maximum (rawBalance / balance) ratio for currency1\n/// @member rawBalance0 The raw token balance of currency0. Raw just means it's not stored in a ERC4626 vault.\n/// @member rawBalance1 The raw token balance of currency1. Raw just means it's not stored in a ERC4626 vault.\n/// @member reserve0 The vault share tokens owned in vault0\n/// @member reserve1 The vault share tokens owned in vault1\n/// @member idleBalance The balance of the token that's in excess. Used when computing the total liquidity.\nstruct PoolState {\n    ILiquidityDensityFunction liquidityDensityFunction;\n    IBunniToken bunniToken;\n    IHooklet hooklet;\n    uint24 twapSecondsAgo;\n    bytes32 ldfParams;\n    bytes hookParams;\n    ERC4626 vault0;\n    ERC4626 vault1;\n    LDFType ldfType;\n    uint24 minRawTokenRatio0;\n    uint24 targetRawTokenRatio0;\n    uint24 maxRawTokenRatio0;\n    uint24 minRawTokenRatio1;\n    uint24 targetRawTokenRatio1;\n    uint24 maxRawTokenRatio1;\n    uint256 rawBalance0;\n    uint256 rawBalance1;\n    uint256 reserve0;\n    uint256 reserve1;\n    IdleBalance idleBalance;\n}\n\n/// @notice The raw state of a given pool\n/// @dev Since a pool's parameters are immutable, we use SSTORE2 to store them cheaply and store the pointer here.\n/// @member immutableParamsPointer The SSTORE2 pointer to the immutable parameters of the pool\n/// @member rawBalance0 The raw token balance of currency0. Raw just means it's not stored in a ERC4626 vault.\n/// @member rawBalance1 The raw token balance of currency1. Raw just means it's not stored in a ERC4626 vault.\nstruct RawPoolState {\n    address immutableParamsPointer;\n    uint256 rawBalance0;\n    uint256 rawBalance1;\n}\n\nfunction getPoolParams(address ptr) view returns (PoolState memory state) {\n    // read params via SSLOAD2\n    bytes memory immutableParams = ptr.read();\n    {\n        ILiquidityDensityFunction liquidityDensityFunction;\n        /// @solidity memory-safe-assembly\n        assembly {\n            liquidityDensityFunction := shr(96, mload(add(immutableParams, 32)))\n        }\n        state.liquidityDensityFunction = liquidityDensityFunction;\n    }\n\n    {\n        IBunniToken bunniToken;\n        /// @solidity memory-safe-assembly\n        assembly {\n            bunniToken := shr(96, mload(add(immutableParams, 52)))\n        }\n        state.bunniToken = bunniToken;\n    }\n\n    {\n        uint24 twapSecondsAgo;\n        /// @solidity memory-safe-assembly\n        assembly {\n            twapSecondsAgo := shr(232, mload(add(immutableParams, 72)))\n        }\n        state.twapSecondsAgo = twapSecondsAgo;\n    }\n\n    {\n        bytes32 ldfParams;\n        /// @solidity memory-safe-assembly\n        assembly {\n            ldfParams := mload(add(immutableParams, 75))\n        }\n        state.ldfParams = ldfParams;\n    }\n\n    {\n        ERC4626 vault0;\n        /// @solidity memory-safe-assembly\n        assembly {\n            vault0 := shr(96, mload(add(immutableParams, 107)))\n        }\n        state.vault0 = vault0;\n    }\n\n    {\n        ERC4626 vault1;\n        /// @solidity memory-safe-assembly\n        assembly {\n            vault1 := shr(96, mload(add(immutableParams, 127)))\n        }\n        state.vault1 = vault1;\n    }\n\n    {\n        LDFType ldfType;\n        /// @solidity memory-safe-assembly\n        assembly {\n            ldfType := shr(248, mload(add(immutableParams, 147)))\n        }\n        state.ldfType = ldfType;\n    }\n\n    {\n        uint24 minRawTokenRatio0;\n        /// @solidity memory-safe-assembly\n        assembly {\n            minRawTokenRatio0 := shr(232, mload(add(immutableParams, 148)))\n        }\n        state.minRawTokenRatio0 = minRawTokenRatio0;\n    }\n\n    {\n        uint24 targetRawTokenRatio0;\n        /// @solidity memory-safe-assembly\n        assembly {\n            targetRawTokenRatio0 := shr(232, mload(add(immutableParams, 151)))\n        }\n        state.targetRawTokenRatio0 = targetRawTokenRatio0;\n    }\n\n    {\n        uint24 maxRawTokenRatio0;\n        /// @solidity memory-safe-assembly\n        assembly {\n            maxRawTokenRatio0 := shr(232, mload(add(immutableParams, 154)))\n        }\n        state.maxRawTokenRatio0 = maxRawTokenRatio0;\n    }\n\n    {\n        uint24 minRawTokenRatio1;\n        /// @solidity memory-safe-assembly\n        assembly {\n            minRawTokenRatio1 := shr(232, mload(add(immutableParams, 157)))\n        }\n        state.minRawTokenRatio1 = minRawTokenRatio1;\n    }\n\n    {\n        uint24 targetRawTokenRatio1;\n        /// @solidity memory-safe-assembly\n        assembly {\n            targetRawTokenRatio1 := shr(232, mload(add(immutableParams, 160)))\n        }\n        state.targetRawTokenRatio1 = targetRawTokenRatio1;\n    }\n\n    {\n        uint24 maxRawTokenRatio1;\n        /// @solidity memory-safe-assembly\n        assembly {\n            maxRawTokenRatio1 := shr(232, mload(add(immutableParams, 163)))\n        }\n        state.maxRawTokenRatio1 = maxRawTokenRatio1;\n    }\n\n    {\n        IHooklet hooklet;\n        /// @solidity memory-safe-assembly\n        assembly {\n            hooklet := shr(96, mload(add(immutableParams, 166)))\n        }\n        state.hooklet = hooklet;\n    }\n\n    {\n        bytes memory hookParams;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let hookParamsLen := shr(240, mload(add(immutableParams, 186))) // uint16\n            hookParams := add(immutableParams, 156) // 156 = 186 (hookParamsLen location) + 2 (hookParamsLen is uint16) - 32 (expand hookParamsLen to 32 bytes)\n            mstore(hookParams, hookParamsLen) // overwrite length field of `bytes memory hookParams`\n        }\n        state.hookParams = hookParams;\n    }\n}\n\nfunction getPoolState(HubStorage storage s, PoolId poolId) view returns (PoolState memory state) {\n    RawPoolState memory rawState = s.poolState[poolId];\n    if (rawState.immutableParamsPointer == address(0)) revert BunniHub__BunniTokenNotInitialized();\n\n    state = getPoolParams(rawState.immutableParamsPointer);\n    state.rawBalance0 = rawState.rawBalance0;\n    state.rawBalance1 = rawState.rawBalance1;\n    state.reserve0 = address(state.vault0) != address(0) ? s.reserve0[poolId] : 0;\n    state.reserve1 = address(state.vault1) != address(0) ? s.reserve1[poolId] : 0;\n\n    // idle balance is only needed when the LDF is not static since static LDFs\n    // can never become imbalanced\n    state.idleBalance = state.ldfType == LDFType.STATIC ? IdleBalanceLibrary.ZERO : s.idleBalance[poolId];\n}\n"}, "src/types/IdleBalance.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport {subReLU} from \"../lib/Math.sol\";\n\ntype IdleBalance is bytes32;\n\nusing {equals as ==, notEqual as !=} for IdleBalance global;\nusing IdleBalanceLibrary for IdleBalance global;\n\nfunction equals(IdleBalance bal, IdleBalance other) pure returns (bool) {\n    return IdleBalance.unwrap(bal) == IdleBalance.unwrap(other);\n}\n\nfunction notEqual(IdleBalance bal, IdleBalance other) pure returns (bool) {\n    return IdleBalance.unwrap(bal) != IdleBalance.unwrap(other);\n}\n\nlibrary IdleBalanceLibrary {\n    using FixedPointMathLib for uint256;\n    using IdleBalanceLibrary for uint256;\n\n    uint256 private constant _BALANCE_MASK = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    /// @dev Set isToken0 to true in ZERO to keep storage slots dirty\n    IdleBalance internal constant ZERO =\n        IdleBalance.wrap(bytes32(0x8000000000000000000000000000000000000000000000000000000000000000));\n\n    error IdleBalanceLibrary__BalanceOverflow();\n\n    function fromIdleBalance(IdleBalance idleBalance) internal pure returns (uint256 rawBalance, bool isToken0) {\n        uint256 mask = _BALANCE_MASK;\n        assembly (\"memory-safe\") {\n            isToken0 := shr(255, idleBalance)\n            rawBalance := and(mask, idleBalance)\n        }\n    }\n\n    function toIdleBalance(uint256 rawBalance, bool isToken0) internal pure returns (IdleBalance) {\n        // revert if balance overflows 255 bits\n        if (rawBalance > _BALANCE_MASK) revert IdleBalanceLibrary__BalanceOverflow();\n\n        // pack isToken0 and balance into a single uint256\n        bytes32 packed;\n        assembly (\"memory-safe\") {\n            packed := or(shl(255, isToken0), rawBalance)\n        }\n\n        return IdleBalance.wrap(packed);\n    }\n\n    function computeIdleBalance(uint256 activeBalance0, uint256 activeBalance1, uint256 balance0, uint256 balance1)\n        internal\n        pure\n        returns (IdleBalance)\n    {\n        (uint256 extraBalance0, uint256 extraBalance1) =\n            (subReLU(balance0, activeBalance0), subReLU(balance1, activeBalance1));\n        (uint256 extraBalanceProportion0, uint256 extraBalanceProportion1) =\n            (balance0 == 0 ? 0 : extraBalance0.divWad(balance0), balance1 == 0 ? 0 : extraBalance1.divWad(balance1));\n        bool isToken0 = extraBalanceProportion0 >= extraBalanceProportion1;\n        return (isToken0 ? extraBalance0 : extraBalance1).toIdleBalance(isToken0);\n    }\n}\n"}, "src/base/SharedStructs.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\npragma abicoder v2;\n\nimport {PoolId, PoolKey} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\n\nimport {ERC4626} from \"solady/tokens/ERC4626.sol\";\n\nimport \"./Constants.sol\";\nimport \"../types/IdleBalance.sol\";\nimport {Oracle} from \"../lib/Oracle.sol\";\nimport {RawPoolState} from \"../types/PoolState.sol\";\nimport {IBunniHook} from \"../interfaces/IBunniHook.sol\";\nimport {IBunniToken} from \"../interfaces/IBunniToken.sol\";\nimport {ILiquidityDensityFunction} from \"../interfaces/ILiquidityDensityFunction.sol\";\n\n/// @title Contains structs shared between multiple contracts\n\nstruct QueuedWithdrawal {\n    uint200 shareAmount;\n    uint56 unlockTimestamp;\n}\n\n/// @notice The storage of BunniHub\n/// @member poolState The state of a given pool\n/// @member reserve0 The vault share tokens owned in vault0\n/// @member reserve1 The vault share tokens owned in vault1\n/// @member idleBalance The balance of the token that's in excess. Used when computing the total liquidity.\n/// @member nonce The nonce for a given bunniSubspace\n/// @member poolIdOfBunniToken The pool ID of a given BunniToken\n/// @member queuedWithdrawals The queued withdrawals for a given pool & user\n/// @member isPauser The set of addresses that can pause external functions\n/// @member referralRewardRecipient The address of the recipient of referral rewards belonging to the default referrer address(0)\n/// @member pauseFlags Bit flags for pausing external functions\n/// @member unpauseFuse Can be permanently set to true to unpause all external functions\nstruct HubStorage {\n    mapping(PoolId poolId => RawPoolState) poolState;\n    mapping(PoolId poolId => uint256) reserve0;\n    mapping(PoolId poolId => uint256) reserve1;\n    mapping(PoolId poolId => IdleBalance) idleBalance;\n    mapping(bytes32 bunniSubspace => uint24) nonce;\n    mapping(IBunniToken bunniToken => PoolId) poolIdOfBunniToken;\n    mapping(PoolId poolId => mapping(address => QueuedWithdrawal)) queuedWithdrawals;\n    mapping(address guy => bool) isPauser;\n    address referralRewardRecipient;\n    uint8 pauseFlags;\n    bool unpauseFuse;\n}\n\n/// @notice The decoded hook params for a given pool\n/// @member feeMin The minimum swap fee, 6 decimals\n/// @member feeMax The maximum swap fee (may be exceeded if surge fee is active), 6 decimals\n/// @member feeQuadraticMultiplier The quadratic multiplier for the dynamic swap fee formula, 6 decimals\n/// @member feeTwapSecondsAgo The time window for the TWAP used by the dynamic swap fee formula\n/// @member maxAmAmmFee The maximum swap fee that can be set by the am-AMM manager. Must <= MAX_AMAMM_FEE.\n/// @member surgeFeeHalfLife The half-life of the surge fee in seconds. The surge fee decays exponentially, and the half-life is the time it takes for the surge fee to decay to half its value.\n/// @member surgeFeeAutostartThreshold Time after a swap when the surge fee exponential decay autostarts, in seconds. The autostart avoids the pool being stuck on a high fee.\n/// @member vaultSurgeThreshold0 The threshold for the vault0 share price change to trigger the surge fee. Only used if both vaults are set.\n///         1 / vaultSurgeThreshold is the minimum percentage change in the vault share price to trigger the surge fee.\n/// @member vaultSurgeThreshold1 The threshold for the vault1 share price change to trigger the surge fee. Only used if both vaults are set.\n///         1 / vaultSurgeThreshold is the minimum percentage change in the vault share price to trigger the surge fee.\n/// @member rebalanceThreshold The threshold for triggering a rebalance from excess liquidity.\n///         1 / rebalanceThreshold is the minimum ratio of excess liquidity to total liquidity to trigger a rebalance.\n///         When set to 0, rebalancing is disabled.\n/// @member rebalanceMaxSlippage The maximum slippage (vs TWAP) allowed during rebalancing, 5 decimals. At most MAX_REBALANCE_MAX_SLIPPAGE.\n/// @member rebalanceTwapSecondsAgo The time window for the TWAP used during rebalancing. At most MAX_REBALANCE_TWAP_SECONDS_AGO.\n/// @member rebalanceOrderTTL The time-to-live for a rebalance order, in seconds. At most MAX_REBALANCE_ORDER_TTL.\n/// @member amAmmEnabled Whether the am-AMM is enabled for this pool\n/// @member oracleMinInterval The minimum interval between TWAP oracle updates, in seconds\n/// @member minRentMultiplier The multiplier applied to the BunniToken total supply to compute the minimum rent. 18 decimals. Must be > 0 unless amAmmEnabled == false.\nstruct DecodedHookParams {\n    uint24 feeMin;\n    uint24 feeMax;\n    uint24 feeQuadraticMultiplier;\n    uint24 feeTwapSecondsAgo;\n    uint24 maxAmAmmFee;\n    uint16 surgeFeeHalfLife;\n    uint16 surgeFeeAutostartThreshold;\n    uint16 vaultSurgeThreshold0;\n    uint16 vaultSurgeThreshold1;\n    uint16 rebalanceThreshold;\n    uint16 rebalanceMaxSlippage;\n    uint16 rebalanceTwapSecondsAgo;\n    uint16 rebalanceOrderTTL;\n    bool amAmmEnabled;\n    uint32 oracleMinInterval;\n    uint48 minRentMultiplier;\n}\n\n/// @notice Contains mappings used by both BunniHook and BunniLogic. Makes passing\n/// mappings to BunniHookLogic easier & cheaper.\n/// @member observations The list of observations for a given pool ID\n/// @member states The current TWAP oracle state for a given pool ID\n/// @member rebalanceOrderHash The hash of the currently active rebalance order\n/// @member rebalanceOrderPermit2Hash The Permit2 hash that's verified when BunniHook.isValidSignature() is called\n/// @member rebalanceOrderDeadline The deadline for the currently active rebalance order\n/// @member vaultSharePricesAtLastSwap The share prices of the vaults used by the pool at the last swap\n/// @member ldfStates The LDF state for a given pool ID\n/// @member slot0s The slot0 state for a given pool ID\nstruct HookStorage {\n    mapping(PoolId => Oracle.Observation[MAX_CARDINALITY]) observations;\n    mapping(PoolId => IBunniHook.ObservationState) states;\n    mapping(PoolId id => bytes32) rebalanceOrderHash;\n    mapping(PoolId id => bytes32) rebalanceOrderPermit2Hash;\n    mapping(PoolId id => uint256) rebalanceOrderDeadline;\n    mapping(PoolId => VaultSharePrices) vaultSharePricesAtLastSwap;\n    mapping(PoolId => bytes32) ldfStates;\n    mapping(PoolId => Slot0) slot0s;\n}\n\n/// @notice The slot0 state of a given pool\n/// @member sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (currency1/currency0)\n/// @member tick The log base 1.0001 of the ratio of the two assets (currency1/currency0)\n/// @member lastSwapTimestamp The timestamp of the last swap (or rebalance execution)\n/// @member lastSurgeTimestamp The timestamp of the last surge\nstruct Slot0 {\n    uint160 sqrtPriceX96;\n    int24 tick;\n    uint32 lastSwapTimestamp;\n    uint32 lastSurgeTimestamp;\n}\n\n/// @notice Tracks the share prices of vaults used by a pool using vaults for both currencies. Used for computing surges.\n/// @member initialized True if the share prices have been initialized\n/// @member sharePrice0 The underlying assets each share of vault0 represents, scaled by 1e18\n/// @member sharePrice1 The underlying assets each share of vault1 represents, scaled by 1e18\nstruct VaultSharePrices {\n    bool initialized;\n    uint120 sharePrice0;\n    uint120 sharePrice1;\n}\n"}, "src/lib/Oracle.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {MAX_CARDINALITY} from \"../base/Constants.sol\";\n\n/// @title Oracle\n/// @notice Provides price data useful for a wide variety of system designs. Based on Uniswap's\n/// truncated oracle.\n/// @dev Instances of stored oracle data, \"observations\", are collected in the oracle array\n/// Every pool is initialized with an oracle array length of 1. Anyone can pay the SSTOREs to increase the\n/// maximum length of the oracle array. New slots will be added when the array is fully populated.\n/// Observations are overwritten when the full length of the oracle array is populated.\n/// The most recent observation is available, independent of the length of the oracle array, by passing 0 to observe()\n/// A minimum observation interval is enforced to make the choice of cardinality more meaningful. This is done by\n/// only recording an observation if the time elapsed since the last observation is >= minInterval, and recording the data\n/// into a separate \"intermediate\" observation slot otherwise to ensure tickCumulative is accurate.\nlibrary Oracle {\n    /// @notice Thrown when trying to interact with an Oracle of a non-initialized pool\n    error OracleCardinalityCannotBeZero();\n\n    /// @notice Thrown when trying to observe a price that is older than the oldest recorded price\n    /// @param oldestTimestamp Timestamp of the oldest remaining observation\n    /// @param targetTimestamp Invalid timestamp targeted to be observed\n    error TargetPredatesOldestObservation(uint32 oldestTimestamp, uint32 targetTimestamp);\n\n    /// @notice This is the max amount of ticks in either direction that the pool is allowed to move at one time\n    int24 constant MAX_ABS_TICK_MOVE = 9116;\n\n    struct Observation {\n        // the block timestamp of the observation\n        uint32 blockTimestamp;\n        // the previous printed tick to calculate the change from time to time\n        int24 prevTick;\n        // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized\n        int56 tickCumulative;\n        // whether or not the observation is initialized\n        bool initialized;\n    }\n\n    /// @notice Transforms a previous observation into a new observation, given the passage of time and the current tick values\n    /// @dev blockTimestamp _must_ be chronologically equal to or greater than last.blockTimestamp, safe for 0 or 1 overflows\n    /// @param last The specified observation to be transformed\n    /// @param blockTimestamp The timestamp of the new observation\n    /// @param tick The active tick at the time of the new observation\n    /// @return Observation The newly populated observation\n    function transform(Observation memory last, uint32 blockTimestamp, int24 tick)\n        private\n        pure\n        returns (Observation memory)\n    {\n        unchecked {\n            uint32 delta = blockTimestamp - last.blockTimestamp;\n\n            // if the current tick moves more than the max abs tick movement\n            // then we truncate it down\n            if ((tick - last.prevTick) > MAX_ABS_TICK_MOVE) {\n                tick = last.prevTick + MAX_ABS_TICK_MOVE;\n            } else if ((tick - last.prevTick) < -MAX_ABS_TICK_MOVE) {\n                tick = last.prevTick - MAX_ABS_TICK_MOVE;\n            }\n\n            return Observation({\n                blockTimestamp: blockTimestamp,\n                prevTick: tick,\n                tickCumulative: last.tickCumulative + int56(tick) * int56(uint56(delta)),\n                initialized: true\n            });\n        }\n    }\n\n    /// @notice Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array\n    /// @param self The stored oracle array\n    /// @param time The time of the oracle initialization, via block.timestamp truncated to uint32\n    /// @return intermediate The intermediate observation in between min intervals\n    /// @return cardinality The number of populated elements in the oracle array\n    /// @return cardinalityNext The new length of the oracle array, independent of population\n    function initialize(Observation[MAX_CARDINALITY] storage self, uint32 time, int24 tick)\n        internal\n        returns (Observation memory intermediate, uint32 cardinality, uint32 cardinalityNext)\n    {\n        intermediate = Observation({blockTimestamp: time, prevTick: tick, tickCumulative: 0, initialized: true});\n        self[0] = intermediate;\n        return (intermediate, 1, 1);\n    }\n\n    /// @notice Writes an oracle observation to the array\n    /// @dev Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally.\n    /// If the index is at the end of the allowable array length (according to cardinality), and the next cardinality\n    /// is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering.\n    /// @param self The stored oracle array\n    /// @param intermediate The intermediate observation in between min intervals. Always the most recent observation.\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param blockTimestamp The timestamp of the new observation\n    /// @param tick The active tick at the time of the new observation\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @param cardinalityNext The new length of the oracle array, independent of population\n    /// @param minInterval The minimum interval between observations.\n    /// @return intermediateUpdated The updated intermediate observation\n    /// @return indexUpdated The new index of the most recently written element in the oracle array\n    /// @return cardinalityUpdated The new cardinality of the oracle array\n    function write(\n        Observation[MAX_CARDINALITY] storage self,\n        Observation memory intermediate,\n        uint32 index,\n        uint32 blockTimestamp,\n        int24 tick,\n        uint32 cardinality,\n        uint32 cardinalityNext,\n        uint32 minInterval\n    ) internal returns (Observation memory intermediateUpdated, uint32 indexUpdated, uint32 cardinalityUpdated) {\n        unchecked {\n            // early return if we've already written an observation this block\n            if (intermediate.blockTimestamp == blockTimestamp) {\n                return (intermediate, index, cardinality);\n            }\n\n            // update the intermediate observation using the most recent observation\n            // which is always the current intermediate observation\n            intermediateUpdated = transform(intermediate, blockTimestamp, tick);\n\n            // if the time since the last recorded observation is less than the minimum interval, we store the observation in the intermediate observation\n            if (blockTimestamp - self[index].blockTimestamp < minInterval) {\n                return (intermediateUpdated, index, cardinality);\n            }\n\n            // if the conditions are right, we can bump the cardinality\n            if (cardinalityNext > cardinality && index == (cardinality - 1)) {\n                cardinalityUpdated = cardinalityNext;\n            } else {\n                cardinalityUpdated = cardinality;\n            }\n\n            indexUpdated = (index + 1) % cardinalityUpdated;\n            self[indexUpdated] = intermediateUpdated;\n        }\n    }\n\n    /// @notice Prepares the oracle array to store up to `next` observations\n    /// @param self The stored oracle array\n    /// @param current The current next cardinality of the oracle array\n    /// @param next The proposed next cardinality which will be populated in the oracle array\n    /// @return next The next cardinality which will be populated in the oracle array\n    function grow(Observation[MAX_CARDINALITY] storage self, uint32 current, uint32 next) internal returns (uint32) {\n        unchecked {\n            if (current == 0) revert OracleCardinalityCannotBeZero();\n            // no-op if the passed next value isn't greater than the current next value\n            if (next <= current) return current;\n            // store in each slot to prevent fresh SSTOREs in swaps\n            // this data will not be used because the initialized boolean is still false\n            for (uint32 i = current; i < next; i++) {\n                self[i].blockTimestamp = 1;\n            }\n            return next;\n        }\n    }\n\n    /// @notice Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.\n    /// The result may be the same observation, or adjacent observations.\n    /// @dev The answer must be contained in the array, used when the target is located within the stored observation\n    /// boundaries: older than the most recent observation and younger, or the same age as, the oldest observation\n    /// @param self The stored oracle array\n    /// @param time The current block.timestamp\n    /// @param target The timestamp at which the reserved observation should be for\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @return beforeOrAt The observation recorded before, or at, the target\n    /// @return atOrAfter The observation recorded at, or after, the target\n    function binarySearch(\n        Observation[MAX_CARDINALITY] storage self,\n        uint32 time,\n        uint32 target,\n        uint32 index,\n        uint32 cardinality\n    ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {\n        unchecked {\n            uint256 l = (index + 1) % cardinality; // oldest observation\n            uint256 r = l + cardinality - 1; // newest observation\n            uint256 i;\n            while (true) {\n                i = (l + r) / 2;\n\n                beforeOrAt = self[i % cardinality];\n\n                // we've landed on an uninitialized tick, keep searching higher (more recently)\n                if (!beforeOrAt.initialized) {\n                    l = i + 1;\n                    continue;\n                }\n\n                atOrAfter = self[(i + 1) % cardinality];\n\n                bool targetAtOrAfter = lte(time, beforeOrAt.blockTimestamp, target);\n\n                // check if we've found the answer!\n                if (targetAtOrAfter && lte(time, target, atOrAfter.blockTimestamp)) break;\n\n                if (!targetAtOrAfter) r = i - 1;\n                else l = i + 1;\n            }\n        }\n    }\n\n    /// @notice Fetches the observations beforeOrAt and atOrAfter a given target, i.e. where [beforeOrAt, atOrAfter] is satisfied\n    /// @dev Assumes there is at least 1 initialized observation.\n    /// Used by observeSingle() to compute the counterfactual accumulator values as of a given block timestamp.\n    /// @param self The stored oracle array\n    /// @param intermediate The intermediate observation in between min intervals. Always the most recent observation.\n    /// @param time The current block.timestamp\n    /// @param target The timestamp at which the reserved observation should be for\n    /// @param tick The active tick at the time of the returned or simulated observation\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @return beforeOrAt The observation which occurred at, or before, the given timestamp\n    /// @return atOrAfter The observation which occurred at, or after, the given timestamp\n    function getSurroundingObservations(\n        Observation[MAX_CARDINALITY] storage self,\n        Observation memory intermediate,\n        uint32 time,\n        uint32 target,\n        int24 tick,\n        uint32 index,\n        uint32 cardinality\n    ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {\n        unchecked {\n            // optimistically set before to the newest observation\n            beforeOrAt = intermediate;\n\n            // if the target is chronologically at or after the newest observation, we can early return\n            if (lte(time, beforeOrAt.blockTimestamp, target)) {\n                if (beforeOrAt.blockTimestamp == target) {\n                    // if newest observation equals target, we're in the same block, so we can ignore atOrAfter\n                    return (beforeOrAt, atOrAfter);\n                } else {\n                    // otherwise, we need to transform\n                    return (beforeOrAt, transform(beforeOrAt, target, tick));\n                }\n            }\n\n            // now, set before to the newest *recorded* Observation\n            beforeOrAt = self[index];\n            atOrAfter = intermediate;\n\n            // if the target is chronologically at or after the newest recorded observation, we can early return\n            // beforeAt would be self[index] and atOrAfter would be intermediate\n            if (lte(time, beforeOrAt.blockTimestamp, target)) {\n                return (beforeOrAt, atOrAfter);\n            }\n\n            // now, set before to the oldest observation\n            beforeOrAt = self[(index + 1) % cardinality];\n            if (!beforeOrAt.initialized) beforeOrAt = self[0];\n\n            // ensure that the target is chronologically at or after the oldest observation\n            if (!lte(time, beforeOrAt.blockTimestamp, target)) {\n                revert TargetPredatesOldestObservation(beforeOrAt.blockTimestamp, target);\n            }\n\n            // if we've reached this point, we have to binary search\n            return binarySearch(self, time, target, index, cardinality);\n        }\n    }\n\n    /// @dev Reverts if an observation at or before the desired observation timestamp does not exist.\n    /// 0 may be passed as `secondsAgo' to return the current cumulative values.\n    /// If called with a timestamp falling between two observations, returns the counterfactual accumulator values\n    /// at exactly the timestamp between the two observations.\n    /// @param self The stored oracle array\n    /// @param intermediate The intermediate observation in between min intervals. Always the most recent observation.\n    /// @param time The current block timestamp\n    /// @param secondsAgo The amount of time to look back, in seconds, at which point to return an observation\n    /// @param tick The current tick\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @return tickCumulative The tick * time elapsed since the pool was first initialized, as of `secondsAgo`\n    function observeSingle(\n        Observation[MAX_CARDINALITY] storage self,\n        Observation memory intermediate,\n        uint32 time,\n        uint32 secondsAgo,\n        int24 tick,\n        uint32 index,\n        uint32 cardinality\n    ) internal view returns (int56 tickCumulative) {\n        unchecked {\n            if (secondsAgo == 0) {\n                if (intermediate.blockTimestamp != time) intermediate = transform(intermediate, time, tick);\n                return intermediate.tickCumulative;\n            }\n\n            uint32 target = time - secondsAgo;\n\n            (Observation memory beforeOrAt, Observation memory atOrAfter) =\n                getSurroundingObservations(self, intermediate, time, target, tick, index, cardinality);\n\n            if (target == beforeOrAt.blockTimestamp) {\n                // we're at the left boundary\n                return beforeOrAt.tickCumulative;\n            } else if (target == atOrAfter.blockTimestamp) {\n                // we're at the right boundary\n                return atOrAfter.tickCumulative;\n            } else {\n                // we're in the middle\n                uint32 observationTimeDelta = atOrAfter.blockTimestamp - beforeOrAt.blockTimestamp;\n                uint32 targetDelta = target - beforeOrAt.blockTimestamp;\n                return beforeOrAt.tickCumulative\n                    + ((atOrAfter.tickCumulative - beforeOrAt.tickCumulative) / int56(uint56(observationTimeDelta)))\n                        * int56(uint56(targetDelta));\n            }\n        }\n    }\n\n    /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`\n    /// @dev Reverts if `secondsAgos` > oldest observation\n    /// @param self The stored oracle array\n    /// @param intermediate The intermediate observation in between min intervals. Always the most recent observation.\n    /// @param time The current block.timestamp\n    /// @param secondsAgo0 Amount of time to look back, in seconds, at which point to return an observation\n    /// @param secondsAgo1 Amount of time to look back, in seconds, at which point to return an observation\n    /// @param tick The current tick\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @return tickCumulative0 The first tick * time elapsed since the pool was first initialized, as of `secondsAgo0`\n    /// @return tickCumulative1 The second tick * time elapsed since the pool was first initialized, as of `secondsAgo1`\n    function observeDouble(\n        Observation[MAX_CARDINALITY] storage self,\n        Observation memory intermediate,\n        uint32 time,\n        uint32 secondsAgo0,\n        uint32 secondsAgo1,\n        int24 tick,\n        uint32 index,\n        uint32 cardinality\n    ) internal view returns (int56 tickCumulative0, int56 tickCumulative1) {\n        unchecked {\n            if (cardinality == 0) revert OracleCardinalityCannotBeZero();\n\n            tickCumulative0 = observeSingle(self, intermediate, time, secondsAgo0, tick, index, cardinality);\n            tickCumulative1 = observeSingle(self, intermediate, time, secondsAgo1, tick, index, cardinality);\n        }\n    }\n\n    function observeTriple(\n        Oracle.Observation[MAX_CARDINALITY] storage self,\n        Oracle.Observation memory intermediate,\n        uint32 time,\n        uint32 secondsAgo0,\n        uint32 secondsAgo1,\n        uint32 secondsAgo2,\n        int24 tick,\n        uint32 index,\n        uint32 cardinality\n    ) internal view returns (int56 tickCumulative0, int56 tickCumulative1, int56 tickCumulative2) {\n        unchecked {\n            if (cardinality == 0) revert OracleCardinalityCannotBeZero();\n\n            tickCumulative0 = observeSingle(self, intermediate, time, secondsAgo0, tick, index, cardinality);\n            tickCumulative1 = observeSingle(self, intermediate, time, secondsAgo1, tick, index, cardinality);\n            tickCumulative2 = observeSingle(self, intermediate, time, secondsAgo2, tick, index, cardinality);\n        }\n    }\n\n    /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`\n    /// @dev Reverts if `secondsAgos` > oldest observation\n    /// @param self The stored oracle array\n    /// @param intermediate The intermediate observation in between min intervals. Always the most recent observation.\n    /// @param time The current block.timestamp\n    /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return an observation\n    /// @param tick The current tick\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @return tickCumulatives The tick * time elapsed since the pool was first initialized, as of each `secondsAgo`\n    function observe(\n        Observation[MAX_CARDINALITY] storage self,\n        Observation memory intermediate,\n        uint32 time,\n        uint32[] memory secondsAgos,\n        int24 tick,\n        uint32 index,\n        uint32 cardinality\n    ) internal view returns (int56[] memory tickCumulatives) {\n        unchecked {\n            if (cardinality == 0) revert OracleCardinalityCannotBeZero();\n\n            tickCumulatives = new int56[](secondsAgos.length);\n            for (uint256 i = 0; i < secondsAgos.length; i++) {\n                tickCumulatives[i] = observeSingle(self, intermediate, time, secondsAgos[i], tick, index, cardinality);\n            }\n        }\n    }\n\n    /// @notice comparator for 32-bit timestamps\n    /// @dev safe for 0 or 1 overflows, a and b _must_ be chronologically before or equal to time\n    /// @param time A timestamp truncated to 32 bits\n    /// @param a A comparison timestamp from which to determine the relative position of `time`\n    /// @param b From which to determine the relative position of `time`\n    /// @return Whether `a` is chronologically <= `b`\n    function lte(uint32 time, uint32 a, uint32 b) private pure returns (bool) {\n        unchecked {\n            // if there hasn't been overflow, no need to adjust\n            if (a <= time && b <= time) return a <= b;\n\n            uint256 aAdjusted = a > time ? a : a + 2 ** 32;\n            uint256 bAdjusted = b > time ? b : b + 2 ** 32;\n\n            return aAdjusted <= bAdjusted;\n        }\n    }\n}\n"}, "src/lib/QueryLDF.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\nimport {TickMath} from \"@uniswap/v4-core/src/libraries/TickMath.sol\";\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport \"../types/IdleBalance.sol\";\nimport {Q96} from \"../base/Constants.sol\";\nimport {FullMathX96} from \"./FullMathX96.sol\";\nimport {LiquidityAmounts} from \"./LiquidityAmounts.sol\";\nimport {roundTick, roundUpFullMulDivResult} from \"./Math.sol\";\nimport {ILiquidityDensityFunction} from \"../interfaces/ILiquidityDensityFunction.sol\";\n\nusing FullMathX96 for uint256;\nusing FixedPointMathLib for uint256;\n\n/// @notice Queries the liquidity density function for the given pool and tick\n/// @param key The pool key\n/// @param sqrtPriceX96 The current sqrt price of the pool\n/// @param tick The current tick of the pool\n/// @param arithmeticMeanTick The TWAP oracle value\n/// @param ldf The liquidity density function\n/// @param ldfParams The parameters for the liquidity density function\n/// @param ldfState The current state of the liquidity density function\n/// @param balance0 The balance of token0 in the pool\n/// @param balance1 The balance of token1 in the pool\n/// @return totalLiquidity The total liquidity in the pool\n/// @return totalDensity0X96 The total density of token0 in the pool, scaled by Q96\n/// @return totalDensity1X96 The total density of token1 in the pool, scaled by Q96\n/// @return liquidityDensityOfRoundedTickX96 The liquidity density of the rounded tick, scaled by Q96\n/// @return activeBalance0 The active balance of token0 in the pool, which is the amount used by swap liquidity\n/// @return activeBalance1 The active balance of token1 in the pool, which is the amount used by swap liquidity\n/// @return newLdfState The new state of the liquidity density function\n/// @return shouldSurge Whether the pool should surge\nfunction queryLDF(\n    PoolKey memory key,\n    uint160 sqrtPriceX96,\n    int24 tick,\n    int24 arithmeticMeanTick,\n    ILiquidityDensityFunction ldf,\n    bytes32 ldfParams,\n    bytes32 ldfState,\n    uint256 balance0,\n    uint256 balance1,\n    IdleBalance idleBalance\n)\n    view\n    returns (\n        uint256 totalLiquidity,\n        uint256 totalDensity0X96,\n        uint256 totalDensity1X96,\n        uint256 liquidityDensityOfRoundedTickX96,\n        uint256 activeBalance0,\n        uint256 activeBalance1,\n        bytes32 newLdfState,\n        bool shouldSurge\n    )\n{\n    (int24 roundedTick, int24 nextRoundedTick) = roundTick(tick, key.tickSpacing);\n    (uint160 roundedTickSqrtRatio, uint160 nextRoundedTickSqrtRatio) =\n        (TickMath.getSqrtPriceAtTick(roundedTick), TickMath.getSqrtPriceAtTick(nextRoundedTick));\n    uint256 density0RightOfRoundedTickX96;\n    uint256 density1LeftOfRoundedTickX96;\n    (\n        liquidityDensityOfRoundedTickX96,\n        density0RightOfRoundedTickX96,\n        density1LeftOfRoundedTickX96,\n        newLdfState,\n        shouldSurge\n    ) = ldf.query(key, roundedTick, arithmeticMeanTick, tick, ldfParams, ldfState);\n\n    (uint256 density0OfRoundedTickX96, uint256 density1OfRoundedTickX96) = LiquidityAmounts.getAmountsForLiquidity(\n        sqrtPriceX96, roundedTickSqrtRatio, nextRoundedTickSqrtRatio, uint128(liquidityDensityOfRoundedTickX96), true\n    );\n    totalDensity0X96 = density0RightOfRoundedTickX96 + density0OfRoundedTickX96;\n    totalDensity1X96 = density1LeftOfRoundedTickX96 + density1OfRoundedTickX96;\n\n    // modify balance0/balance1 to deduct the idle balance\n    // skip this if a surge happens since the idle balance will need to be recalculated\n    if (!shouldSurge) {\n        (uint256 balance, bool isToken0) = IdleBalanceLibrary.fromIdleBalance(idleBalance);\n        if (isToken0) {\n            balance0 = subReLU(balance0, balance);\n        } else {\n            balance1 = subReLU(balance1, balance);\n        }\n    }\n\n    if (balance0 != 0 || balance1 != 0) {\n        bool noToken0 = balance0 == 0 || totalDensity0X96 == 0;\n        bool noToken1 = balance1 == 0 || totalDensity1X96 == 0;\n        uint256 totalLiquidityEstimate0 = noToken0 ? 0 : balance0.fullMulDiv(Q96, totalDensity0X96);\n        uint256 totalLiquidityEstimate1 = noToken1 ? 0 : balance1.fullMulDiv(Q96, totalDensity1X96);\n        bool useLiquidityEstimate0 =\n            (totalLiquidityEstimate0 < totalLiquidityEstimate1 || totalDensity1X96 == 0) && totalDensity0X96 != 0;\n        if (useLiquidityEstimate0) {\n            totalLiquidity =\n                noToken0 ? 0 : roundUpFullMulDivResult(balance0, Q96, totalDensity0X96, totalLiquidityEstimate0);\n            (activeBalance0, activeBalance1) = (\n                noToken0 ? 0 : FixedPointMathLib.min(balance0, totalLiquidityEstimate0.fullMulX96(totalDensity0X96)),\n                noToken1 ? 0 : FixedPointMathLib.min(balance1, totalLiquidityEstimate0.fullMulX96(totalDensity1X96))\n            );\n        } else {\n            totalLiquidity =\n                noToken1 ? 0 : roundUpFullMulDivResult(balance1, Q96, totalDensity1X96, totalLiquidityEstimate1);\n            (activeBalance0, activeBalance1) = (\n                noToken0 ? 0 : FixedPointMathLib.min(balance0, totalLiquidityEstimate1.fullMulX96(totalDensity0X96)),\n                noToken1 ? 0 : FixedPointMathLib.min(balance1, totalLiquidityEstimate1.fullMulX96(totalDensity1X96))\n            );\n        }\n    }\n}\n"}, "src/lib/FullMathX96.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\nlibrary FullMathX96 {\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n\n    /// @dev Calculates `floor(x * y / 2 ** 96)` with full precision.\n    /// Throws if result overflows a uint256.\n    /// Credit to Philogy under MIT license:\n    /// https://github.com/SorellaLabs/angstrom/blob/main/contracts/src/libraries/X128MathLib.sol\n    function fullMulX96(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`. We'll call this `z`.\n            for {} 1 {} {\n                if iszero(or(iszero(x), eq(div(z, x), y))) {\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n                    //         |      p1     |      z     |\n                    // Before: | p1_0 \u00a6 p1_1 | z_0  \u00a6 z_1 |\n                    // Final:  |   0  \u00a6 p1_0 | p1_1 \u00a6 z_0 |\n                    // Check that final `z` doesn't overflow by checking that p1_0 = 0.\n                    if iszero(shr(96, p1)) {\n                        z := add(shl(160, p1), shr(96, z))\n                        break\n                    }\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                z := shr(96, z)\n                break\n            }\n        }\n    }\n\n    function fullMulX96Up(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = fullMulX96(x, y);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mulmod(x, y, Q96) {\n                z := add(z, 1)\n                if iszero(z) {\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n}\n"}, "src/lib/BunniHookLogic.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"@uniswap/v4-core/src/types/PoolId.sol\";\nimport \"@uniswap/v4-core/src/types/Currency.sol\";\nimport \"@uniswap/v4-core/src/types/BeforeSwapDelta.sol\";\nimport {Hooks} from \"@uniswap/v4-core/src/libraries/Hooks.sol\";\nimport {TickMath} from \"@uniswap/v4-core/src/libraries/TickMath.sol\";\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\nimport {SqrtPriceMath} from \"@uniswap/v4-core/src/libraries/SqrtPriceMath.sol\";\n\nimport {WETH} from \"solady/tokens/WETH.sol\";\nimport {ERC20} from \"solady/tokens/ERC20.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport \"./Math.sol\";\nimport \"./FeeMath.sol\";\nimport \"./VaultMath.sol\";\nimport \"./AmAmmPayload.sol\";\nimport \"../base/Errors.sol\";\nimport \"../types/LDFType.sol\";\nimport \"../base/Constants.sol\";\nimport \"../types/PoolState.sol\";\nimport \"../types/IdleBalance.sol\";\nimport \"../base/SharedStructs.sol\";\nimport {Oracle} from \"./Oracle.sol\";\nimport \"../interfaces/IBunniHook.sol\";\nimport {queryLDF} from \"./QueryLDF.sol\";\nimport {BunniHook} from \"../BunniHook.sol\";\nimport {HookletLib} from \"./HookletLib.sol\";\nimport {BunniSwapMath} from \"./BunniSwapMath.sol\";\nimport {RebalanceLogic} from \"./RebalanceLogic.sol\";\nimport {IHooklet} from \"../interfaces/IHooklet.sol\";\nimport {IBunniHub} from \"../interfaces/IBunniHub.sol\";\nimport {LiquidityAmounts} from \"./LiquidityAmounts.sol\";\n\n/// @title BunniHookLogic\n/// @notice Split from BunniHook to reduce contract size below the Spurious Dragon limit\nlibrary BunniHookLogic {\n    using TickMath for *;\n    using SafeCastLib for *;\n    using SafeTransferLib for *;\n    using FixedPointMathLib for *;\n    using HookletLib for IHooklet;\n    using IdleBalanceLibrary for *;\n    using PoolIdLibrary for PoolKey;\n    using CurrencyLibrary for Currency;\n    using Oracle for Oracle.Observation[MAX_CARDINALITY];\n\n    /// -----------------------------------------------------------------------\n    /// Structs\n    /// -----------------------------------------------------------------------\n\n    struct Env {\n        uint32 hookFeeModifier;\n        uint32 referralRewardModifier;\n        IBunniHub hub;\n        IPoolManager poolManager;\n        IFloodPlain floodPlain;\n        IZone floodZone;\n        WETH weth;\n        address permit2;\n    }\n\n    struct RebalanceInput {\n        PoolId id;\n        PoolKey key;\n        int24 updatedTick;\n        uint160 updatedSqrtPriceX96;\n        int24 arithmeticMeanTick;\n        bytes32 newLdfState;\n        DecodedHookParams hookParams;\n        Oracle.Observation updatedIntermediate;\n        uint32 updatedIndex;\n        uint32 updatedCardinality;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// External functions\n    /// -----------------------------------------------------------------------\n\n    function afterInitialize(\n        HookStorage storage s,\n        address caller,\n        PoolKey calldata key,\n        uint160 sqrtPriceX96,\n        int24 tick,\n        IBunniHub hub\n    ) external {\n        if (caller != address(hub)) revert BunniHook__Unauthorized(); // prevents non-BunniHub contracts from initializing a pool using this hook\n        PoolId id = key.toId();\n\n        // initialize slot0\n        s.slot0s[id] = Slot0({\n            sqrtPriceX96: sqrtPriceX96,\n            tick: tick,\n            lastSwapTimestamp: uint32(block.timestamp),\n            lastSurgeTimestamp: 0\n        });\n\n        // read hook data from hub\n        bytes memory hookData = hub.poolInitData();\n\n        // initialize first observation to be dated in the past\n        // so that we can immediately start querying the oracle\n        (uint24 twapSecondsAgo, bytes memory hookParams) = abi.decode(hookData, (uint24, bytes));\n        DecodedHookParams memory hookParamsDecoded = _decodeParams(hookParams);\n        uint32 maxTwapSecondsAgo = uint32(\n            FixedPointMathLib.max(\n                FixedPointMathLib.max(twapSecondsAgo, hookParamsDecoded.feeTwapSecondsAgo),\n                hookParamsDecoded.rebalanceTwapSecondsAgo\n            )\n        );\n        (s.states[id].intermediateObservation, s.states[id].cardinality, s.states[id].cardinalityNext) =\n            s.observations[id].initialize(uint32(block.timestamp - maxTwapSecondsAgo), tick);\n\n        // increase cardinality target based on maxTwapSecondsAgo\n        uint32 cardinalityNext =\n            (maxTwapSecondsAgo + (hookParamsDecoded.oracleMinInterval >> 1)) / hookParamsDecoded.oracleMinInterval + 1; // round up + 1\n        if (cardinalityNext > 1) {\n            uint32 cardinalityNextNew = s.observations[id].grow(1, cardinalityNext);\n            s.states[id].cardinalityNext = cardinalityNextNew;\n        }\n    }\n\n    function beforeSwap(\n        HookStorage storage s,\n        Env calldata env,\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params\n    )\n        external\n        returns (\n            bool useAmAmmFee,\n            address amAmmManager,\n            Currency amAmmFeeCurrency,\n            uint256 amAmmFeeAmount,\n            BeforeSwapDelta beforeSwapDelta\n        )\n    {\n        // skip 0 amount swaps\n        if (params.amountSpecified == 0) {\n            return (false, address(0), Currency.wrap(address(0)), 0, BeforeSwapDeltaLibrary.ZERO_DELTA);\n        }\n\n        // get pool state\n        PoolId id = key.toId();\n        Slot0 memory slot0 = s.slot0s[id];\n        PoolState memory bunniState = env.hub.poolState(id);\n\n        // hooklet call\n        bool feeOverridden;\n        uint24 feeOverride;\n        {\n            bool priceOverridden;\n            uint160 sqrtPriceX96Override;\n            (feeOverridden, feeOverride, priceOverridden, sqrtPriceX96Override) =\n                bunniState.hooklet.hookletBeforeSwap(sender, key, params);\n\n            // override price if needed\n            if (priceOverridden) {\n                slot0.sqrtPriceX96 = sqrtPriceX96Override;\n                slot0.tick = sqrtPriceX96Override.getTickAtSqrtPrice();\n            }\n        }\n\n        // ensure swap makes sense\n        if (\n            slot0.sqrtPriceX96 == 0\n                || (\n                    params.zeroForOne\n                        && (\n                            params.sqrtPriceLimitX96 >= slot0.sqrtPriceX96\n                                || params.sqrtPriceLimitX96 <= TickMath.MIN_SQRT_PRICE\n                        )\n                )\n                || (\n                    !params.zeroForOne\n                        && (\n                            params.sqrtPriceLimitX96 <= slot0.sqrtPriceX96\n                                || params.sqrtPriceLimitX96 >= TickMath.MAX_SQRT_PRICE\n                        )\n                ) || params.amountSpecified > type(int128).max || params.amountSpecified < type(int128).min\n        ) {\n            revert BunniHook__InvalidSwap();\n        }\n\n        // compute total token balances\n        (uint256 reserveBalance0, uint256 reserveBalance1) = (\n            getReservesInUnderlying(bunniState.reserve0, bunniState.vault0),\n            getReservesInUnderlying(bunniState.reserve1, bunniState.vault1)\n        );\n        (uint256 balance0, uint256 balance1) =\n            (bunniState.rawBalance0 + reserveBalance0, bunniState.rawBalance1 + reserveBalance1);\n\n        // decode hook params\n        DecodedHookParams memory hookParams = _decodeParams(bunniState.hookParams);\n\n        // update TWAP oracle\n        // do it before we fetch the arithmeticMeanTick\n        // which doesn't change the result but gives us updated index and cardinality\n        (Oracle.Observation memory updatedIntermediate, uint32 updatedIndex, uint32 updatedCardinality) =\n            _updateOracle(s, id, slot0.tick, hookParams.oracleMinInterval);\n\n        // get TWAP values\n        int24 arithmeticMeanTick;\n        int24 feeMeanTick;\n        bool useLDFTwap = bunniState.twapSecondsAgo != 0;\n        bool useFeeTwap = !feeOverridden && hookParams.feeTwapSecondsAgo != 0;\n        if (useLDFTwap && useFeeTwap) {\n            (int56 tickCumulatives0, int56 tickCumulatives1, int56 tickCumulatives2) = s.observations[id].observeTriple(\n                updatedIntermediate,\n                uint32(block.timestamp),\n                0,\n                bunniState.twapSecondsAgo,\n                hookParams.feeTwapSecondsAgo,\n                slot0.tick,\n                updatedIndex,\n                updatedCardinality\n            );\n            arithmeticMeanTick = int24((tickCumulatives0 - tickCumulatives1) / int56(uint56(bunniState.twapSecondsAgo)));\n            feeMeanTick = int24((tickCumulatives0 - tickCumulatives2) / int56(uint56(hookParams.feeTwapSecondsAgo)));\n        } else if (useLDFTwap) {\n            arithmeticMeanTick = _getTwap(\n                s, id, slot0.tick, bunniState.twapSecondsAgo, updatedIntermediate, updatedIndex, updatedCardinality\n            );\n        } else if (useFeeTwap) {\n            feeMeanTick = _getTwap(\n                s, id, slot0.tick, hookParams.feeTwapSecondsAgo, updatedIntermediate, updatedIndex, updatedCardinality\n            );\n        }\n\n        // query the LDF to get total liquidity and token densities\n        bytes32 ldfState = bunniState.ldfType == LDFType.DYNAMIC_AND_STATEFUL ? s.ldfStates[id] : bytes32(0);\n        (\n            uint256 totalLiquidity,\n            ,\n            ,\n            uint256 liquidityDensityOfRoundedTickX96,\n            uint256 currentActiveBalance0,\n            uint256 currentActiveBalance1,\n            bytes32 newLdfState,\n            bool shouldSurge\n        ) = queryLDF({\n            key: key,\n            sqrtPriceX96: slot0.sqrtPriceX96,\n            tick: slot0.tick,\n            arithmeticMeanTick: arithmeticMeanTick,\n            ldf: bunniState.liquidityDensityFunction,\n            ldfParams: bunniState.ldfParams,\n            ldfState: ldfState,\n            balance0: balance0,\n            balance1: balance1,\n            idleBalance: bunniState.idleBalance\n        });\n\n        // ensure the current active balance of the requested output token is not zero\n        // or less than the requested output if it's an exact output swap\n        bool exactIn = params.amountSpecified < 0;\n        if (\n            params.zeroForOne && currentActiveBalance1 == 0 || !params.zeroForOne && currentActiveBalance0 == 0\n                || totalLiquidity == 0\n                || (\n                    !exactIn\n                        && uint256(params.amountSpecified) > (params.zeroForOne ? currentActiveBalance1 : currentActiveBalance0)\n                )\n        ) {\n            revert BunniHook__RequestedOutputExceedsBalance();\n        }\n\n        shouldSurge = shouldSurge && bunniState.ldfType != LDFType.STATIC; // only surge from LDF if LDF type is not static\n        if (bunniState.ldfType == LDFType.DYNAMIC_AND_STATEFUL) s.ldfStates[id] = newLdfState;\n\n        if (shouldSurge) {\n            // the LDF has been updated, so we need to update the idle balance\n            env.hub.hookSetIdleBalance(\n                key,\n                IdleBalanceLibrary.computeIdleBalance(currentActiveBalance0, currentActiveBalance1, balance0, balance1)\n            );\n        }\n\n        // check surge based on vault share prices\n        shouldSurge =\n            shouldSurge || _shouldSurgeFromVaults(s, id, bunniState, hookParams, reserveBalance0, reserveBalance1);\n\n        // compute swap result\n        (uint160 updatedSqrtPriceX96, int24 updatedTick, uint256 inputAmount, uint256 outputAmount) = BunniSwapMath\n            .computeSwap({\n            input: BunniSwapMath.BunniComputeSwapInput({\n                key: key,\n                totalLiquidity: totalLiquidity,\n                liquidityDensityOfRoundedTickX96: liquidityDensityOfRoundedTickX96,\n                currentActiveBalance0: currentActiveBalance0,\n                currentActiveBalance1: currentActiveBalance1,\n                sqrtPriceX96: slot0.sqrtPriceX96,\n                currentTick: slot0.tick,\n                liquidityDensityFunction: bunniState.liquidityDensityFunction,\n                arithmeticMeanTick: arithmeticMeanTick,\n                ldfParams: bunniState.ldfParams,\n                ldfState: ldfState,\n                swapParams: params\n            })\n        });\n\n        // revert if it's an exact output swap and outputAmount < params.amountSpecified\n        if (!exactIn && outputAmount < uint256(params.amountSpecified)) {\n            revert BunniHook__InsufficientOutput();\n        }\n\n        // ensure swap never moves price in the opposite direction\n        // ensure the inputAmount and outputAmount are non-zero\n        if (\n            (params.zeroForOne && updatedSqrtPriceX96 > slot0.sqrtPriceX96)\n                || (!params.zeroForOne && updatedSqrtPriceX96 < slot0.sqrtPriceX96)\n                || (outputAmount == 0 || inputAmount == 0)\n        ) {\n            revert BunniHook__InvalidSwap();\n        }\n\n        // update slot0\n        uint32 lastSurgeTimestamp = slot0.lastSurgeTimestamp;\n        {\n            uint32 blockTimestamp32 = uint32(block.timestamp);\n            if (shouldSurge) {\n                // use unchecked so that if uint32 overflows we wrap around\n                // overflows are ok since we only look at differences\n                unchecked {\n                    uint32 timeSinceLastSwap = blockTimestamp32 - slot0.lastSwapTimestamp;\n                    // if more than `surgeFeeAutostartThreshold` seconds has passed since the last swap,\n                    // we pretend that the surge started at `slot0.lastSwapTimestamp + surgeFeeAutostartThreshold`\n                    // so that the pool never gets stuck with a high fee\n                    lastSurgeTimestamp = timeSinceLastSwap >= hookParams.surgeFeeAutostartThreshold\n                        ? slot0.lastSwapTimestamp + hookParams.surgeFeeAutostartThreshold\n                        : blockTimestamp32;\n                }\n            }\n            s.slot0s[id] = Slot0({\n                sqrtPriceX96: updatedSqrtPriceX96,\n                tick: updatedTick,\n                lastSwapTimestamp: blockTimestamp32,\n                lastSurgeTimestamp: lastSurgeTimestamp\n            });\n        }\n\n        // update am-AMM state\n        uint24 amAmmSwapFee;\n        if (hookParams.amAmmEnabled) {\n            bytes6 payload;\n            IAmAmm.Bid memory topBid = IAmAmm(address(this)).getTopBidWrite(id);\n            (amAmmManager, payload) = (topBid.manager, topBid.payload);\n            (uint24 swapFee0For1, uint24 swapFee1For0) = decodeAmAmmPayload(payload);\n            amAmmSwapFee = params.zeroForOne ? swapFee0For1 : swapFee1For0;\n        }\n\n        // charge swap fee\n        // precedence:\n        // 1) am-AMM fee\n        // 2) hooklet override fee\n        // 3) dynamic fee\n        (Currency inputToken, Currency outputToken) =\n            params.zeroForOne ? (key.currency0, key.currency1) : (key.currency1, key.currency0);\n        uint24 swapFee;\n        uint256 swapFeeAmount;\n        useAmAmmFee = hookParams.amAmmEnabled && amAmmManager != address(0);\n        // swap fee used as the basis for computing hookFees when useAmAmmFee == true\n        // this is to avoid a malicious am-AMM manager bypassing hookFees\n        // by setting the swap fee to max and offering a proxy swap contract\n        // that sets the Bunni swap fee to 0 during such swaps and charging swap fees\n        // independently\n        uint24 hookFeesBaseSwapFee = feeOverridden\n            ? feeOverride\n            : computeDynamicSwapFee(\n                updatedSqrtPriceX96,\n                feeMeanTick,\n                lastSurgeTimestamp,\n                hookParams.feeMin,\n                hookParams.feeMax,\n                hookParams.feeQuadraticMultiplier,\n                hookParams.surgeFeeHalfLife\n            );\n        swapFee = useAmAmmFee\n            ? uint24(FixedPointMathLib.max(amAmmSwapFee, computeSurgeFee(lastSurgeTimestamp, hookParams.surgeFeeHalfLife)))\n            : hookFeesBaseSwapFee;\n        uint256 hookFeesAmount;\n        uint256 hookHandleSwapInputAmount;\n        uint256 hookHandleSwapOutoutAmount;\n        if (exactIn) {\n            // compute the swap fee and the hook fee (i.e. protocol fee)\n            // swap fee is taken by decreasing the output amount\n            swapFeeAmount = outputAmount.mulDivUp(swapFee, SWAP_FEE_BASE);\n            if (useAmAmmFee) {\n                // instead of computing hook fees as a portion of the swap fee\n                // and deducting it, we compute hook fees separately using hookFeesBaseSwapFee\n                // and charge it as an extra fee on the swap\n                hookFeesAmount = outputAmount.mulDivUp(hookFeesBaseSwapFee, SWAP_FEE_BASE).mulDivUp(\n                    env.hookFeeModifier, MODIFIER_BASE\n                );\n            } else {\n                hookFeesAmount = swapFeeAmount.mulDivUp(env.hookFeeModifier, MODIFIER_BASE);\n                swapFeeAmount -= hookFeesAmount;\n            }\n\n            // set the am-AMM fee to be the swap fee amount\n            // don't need to check if am-AMM is enabled since if it isn't\n            // BunniHook.beforeSwap() simply ignores the returned values\n            // this saves gas by avoiding an if statement\n            (amAmmFeeCurrency, amAmmFeeAmount) = (outputToken, swapFeeAmount);\n\n            // modify output amount with fees\n            outputAmount -= swapFeeAmount + hookFeesAmount;\n\n            // return beforeSwapDelta\n            // take in max(amountSpecified, inputAmount) such that if amountSpecified is greater we just happily accept it\n            int256 actualInputAmount = FixedPointMathLib.max(-params.amountSpecified, inputAmount.toInt256());\n            inputAmount = uint256(actualInputAmount);\n            beforeSwapDelta = toBeforeSwapDelta({\n                deltaSpecified: actualInputAmount.toInt128(),\n                deltaUnspecified: -outputAmount.toInt256().toInt128()\n            });\n\n            // if am-AMM is used, the swap fee needs to be taken from BunniHub, else it stays in BunniHub with the LPs\n            (hookHandleSwapInputAmount, hookHandleSwapOutoutAmount) = (\n                inputAmount, useAmAmmFee ? outputAmount + swapFeeAmount + hookFeesAmount : outputAmount + hookFeesAmount\n            );\n        } else {\n            // compute the swap fee and the hook fee (i.e. protocol fee)\n            // swap fee is taken by increasing the input amount\n            // need to modify fee rate to maintain the same average price as exactIn case\n            // in / (out * (1 - fee)) = in * (1 + fee') / out => fee' = fee / (1 - fee)\n            swapFeeAmount = inputAmount.mulDivUp(swapFee, SWAP_FEE_BASE - swapFee);\n            if (useAmAmmFee) {\n                // instead of computing hook fees as a portion of the swap fee\n                // and deducting it, we compute hook fees separately using hookFeesBaseSwapFee\n                // and charge it as an extra fee on the swap\n                hookFeesAmount = inputAmount.mulDivUp(hookFeesBaseSwapFee, SWAP_FEE_BASE - hookFeesBaseSwapFee).mulDivUp(\n                    env.hookFeeModifier, MODIFIER_BASE\n                );\n            } else {\n                hookFeesAmount = swapFeeAmount.mulDivUp(env.hookFeeModifier, MODIFIER_BASE);\n                swapFeeAmount -= hookFeesAmount;\n            }\n\n            // set the am-AMM fee to be the swap fee amount\n            // don't need to check if am-AMM is enabled since if it isn't\n            // BunniHook.beforeSwap() simply ignores the returned values\n            // this saves gas by avoiding an if statement\n            (amAmmFeeCurrency, amAmmFeeAmount) = (inputToken, swapFeeAmount);\n\n            // modify input amount with fees\n            inputAmount += swapFeeAmount + hookFeesAmount;\n\n            // return beforeSwapDelta\n            // give out min(amountSpecified, outputAmount) such that we only give out as much as requested\n            int256 actualOutputAmount = FixedPointMathLib.min(params.amountSpecified, outputAmount.toInt256());\n            outputAmount = uint256(actualOutputAmount);\n            beforeSwapDelta = toBeforeSwapDelta({\n                deltaSpecified: -actualOutputAmount.toInt128(),\n                deltaUnspecified: inputAmount.toInt256().toInt128()\n            });\n\n            // if am-AMM is not used, the swap fee needs to be sent to BunniHub to the LPs, else it stays in BunniHook with the am-AMM manager\n            (hookHandleSwapInputAmount, hookHandleSwapOutoutAmount) = (\n                useAmAmmFee ? inputAmount - swapFeeAmount - hookFeesAmount : inputAmount - hookFeesAmount, outputAmount\n            );\n        }\n\n        // take input by minting claim tokens to hook\n        env.poolManager.mint(address(this), inputToken.toId(), inputAmount);\n\n        // call hub to handle swap\n        // - pull input claim tokens from hook\n        // - push output tokens to pool manager and mint claim tokens to hook\n        // - update raw token balances\n        env.hub.hookHandleSwap(key, params.zeroForOne, hookHandleSwapInputAmount, hookHandleSwapOutoutAmount);\n\n        // burn output claim tokens\n        env.poolManager.burn(address(this), outputToken.toId(), outputAmount);\n\n        // distribute part of hookFees to referrers\n        if (hookFeesAmount != 0) {\n            uint256 referrerRewardAmount = hookFeesAmount.mulDiv(env.referralRewardModifier, MODIFIER_BASE);\n            if (referrerRewardAmount != 0) {\n                if (!env.poolManager.isOperator(address(this), address(bunniState.bunniToken))) {\n                    env.poolManager.setOperator(address(bunniState.bunniToken), true);\n                }\n                bool isToken0 = exactIn != params.zeroForOne;\n                bunniState.bunniToken.distributeReferralRewards(isToken0, referrerRewardAmount);\n            }\n        }\n\n        // emit swap event\n        emit IBunniHook.Swap(\n            id,\n            sender,\n            exactIn,\n            params.zeroForOne,\n            inputAmount,\n            outputAmount,\n            updatedSqrtPriceX96,\n            updatedTick,\n            swapFee,\n            totalLiquidity\n        );\n\n        // we should attempt to rebalance if:\n        // 1) rebalanceThreshold != 0, i.e. rebalancing is enabled\n        // 2.a) either shouldSurge == true, since tokens can only go out of balance due to shifting or vault returns, or:\n        // 2.b) the deadline of the last rebalance order has passed and the order wasn't executed, in which case we should reattempt to rebalance\n        uint256 rebalanceOrderDeadline = shouldSurge ? 0 : s.rebalanceOrderDeadline[id]; // gas: only do SLOAD if shouldSurge == false\n        if (\n            hookParams.rebalanceThreshold != 0\n                && (shouldSurge || (block.timestamp > rebalanceOrderDeadline && rebalanceOrderDeadline != 0))\n        ) {\n            if (shouldSurge) {\n                // surging makes any existing rebalance order meaningless\n                // since the desired token ratio will be different\n                // clear the existing rebalance order\n                delete s.rebalanceOrderHash[id];\n                delete s.rebalanceOrderPermit2Hash[id];\n                delete s.rebalanceOrderDeadline[id];\n            }\n\n            RebalanceLogic.rebalance(\n                s,\n                env,\n                RebalanceInput({\n                    id: id,\n                    key: key,\n                    updatedTick: updatedTick,\n                    updatedSqrtPriceX96: updatedSqrtPriceX96,\n                    arithmeticMeanTick: arithmeticMeanTick,\n                    newLdfState: newLdfState,\n                    hookParams: hookParams,\n                    updatedIntermediate: updatedIntermediate,\n                    updatedIndex: updatedIndex,\n                    updatedCardinality: updatedCardinality\n                })\n            );\n        }\n\n        // hooklet call\n        if (bunniState.hooklet.hasPermission(HookletLib.AFTER_SWAP_FLAG)) {\n            bunniState.hooklet.hookletAfterSwap(\n                sender,\n                key,\n                params,\n                IHooklet.SwapReturnData({\n                    updatedSqrtPriceX96: updatedSqrtPriceX96,\n                    updatedTick: updatedTick,\n                    inputAmount: inputAmount,\n                    outputAmount: outputAmount,\n                    swapFee: swapFee,\n                    totalLiquidity: totalLiquidity\n                })\n            );\n        }\n    }\n\n    function recomputeIdleBalance(HookStorage storage s, IBunniHub hub, PoolKey calldata key) external {\n        PoolId id = key.toId();\n        PoolState memory bunniState = hub.poolState(id);\n        Slot0 memory slot0 = s.slot0s[id];\n        (uint256 balance0, uint256 balance1) = (\n            bunniState.rawBalance0 + getReservesInUnderlying(bunniState.reserve0, bunniState.vault0),\n            bunniState.rawBalance1 + getReservesInUnderlying(bunniState.reserve1, bunniState.vault1)\n        );\n        int24 arithmeticMeanTick = bunniState.twapSecondsAgo == 0\n            ? int24(0)\n            : _getTwap(\n                s,\n                id,\n                slot0.tick,\n                bunniState.twapSecondsAgo,\n                s.states[id].intermediateObservation,\n                s.states[id].index,\n                s.states[id].cardinality\n            );\n        bytes32 ldfState = bunniState.ldfType == LDFType.DYNAMIC_AND_STATEFUL ? s.ldfStates[id] : bytes32(0);\n        (,,,, uint256 currentActiveBalance0, uint256 currentActiveBalance1,,) = queryLDF({\n            key: key,\n            sqrtPriceX96: slot0.sqrtPriceX96,\n            tick: slot0.tick,\n            arithmeticMeanTick: arithmeticMeanTick,\n            ldf: bunniState.liquidityDensityFunction,\n            ldfParams: bunniState.ldfParams,\n            ldfState: ldfState,\n            balance0: balance0,\n            balance1: balance1,\n            idleBalance: IdleBalanceLibrary.ZERO // set to zero since we're recomputing the idle balance and shouldSurge isn't necessarily true\n        });\n        hub.hookSetIdleBalance(\n            key, IdleBalanceLibrary.computeIdleBalance(currentActiveBalance0, currentActiveBalance1, balance0, balance1)\n        );\n    }\n\n    function isValidParams(bytes calldata hookParams) external pure returns (bool) {\n        DecodedHookParams memory p = _decodeParams(hookParams);\n        unchecked {\n            return (p.feeMin <= p.feeMax) && (p.feeMax < SWAP_FEE_BASE)\n                && (p.feeQuadraticMultiplier == 0 || p.feeMin == p.feeMax || p.feeTwapSecondsAgo != 0)\n                && (uint256(p.surgeFeeHalfLife) * uint256(p.vaultSurgeThreshold0) * uint256(p.vaultSurgeThreshold1) != 0)\n                && (p.surgeFeeHalfLife < MAX_SURGE_HALFLIFE && p.surgeFeeAutostartThreshold < MAX_SURGE_AUTOSTART_TIME)\n                && (\n                    (\n                        p.rebalanceThreshold == 0 && p.rebalanceMaxSlippage == 0 && p.rebalanceTwapSecondsAgo == 0\n                            && p.rebalanceOrderTTL == 0\n                    )\n                        || (\n                            p.rebalanceThreshold != 0 && p.rebalanceMaxSlippage != 0\n                                && p.rebalanceMaxSlippage < REBALANCE_MAX_SLIPPAGE_BASE && p.rebalanceTwapSecondsAgo != 0\n                                && p.rebalanceTwapSecondsAgo < MAX_REBALANCE_TWAP_SECONDS_AGO && p.rebalanceOrderTTL != 0\n                                && p.rebalanceOrderTTL < MAX_REBALANCE_ORDER_TTL\n                        )\n                ) && (p.oracleMinInterval != 0)\n                && (!p.amAmmEnabled || (p.maxAmAmmFee != 0 && p.maxAmAmmFee <= MAX_AMAMM_FEE && p.minRentMultiplier != 0));\n        }\n    }\n\n    function decodeHookParams(bytes calldata hookParams) external pure returns (DecodedHookParams memory p) {\n        return _decodeParams(hookParams);\n    }\n\n    function observe(HookStorage storage s, PoolKey calldata key, uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives)\n    {\n        PoolId id = key.toId();\n        IBunniHook.ObservationState memory state = s.states[id];\n        Slot0 memory slot0 = s.slot0s[id];\n\n        return s.observations[id].observe(\n            state.intermediateObservation,\n            uint32(block.timestamp),\n            secondsAgos,\n            slot0.tick,\n            state.index,\n            state.cardinality\n        );\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Internal utility functions\n    /// -----------------------------------------------------------------------\n\n    /// @dev Checks if the pool should surge based on the vault share price changes since the last swap.\n    /// Also updates vaultSharePricesAtLastSwap.\n    function _shouldSurgeFromVaults(\n        HookStorage storage s,\n        PoolId id,\n        PoolState memory bunniState,\n        DecodedHookParams memory hookParams,\n        uint256 reserveBalance0,\n        uint256 reserveBalance1\n    ) private returns (bool shouldSurge) {\n        if (address(bunniState.vault0) != address(0) || address(bunniState.vault1) != address(0)) {\n            // only surge if at least one vault is set because otherwise total liquidity won't automatically increase\n            // so there's no risk of being sandwiched\n\n            // load share prices at last swap\n            VaultSharePrices memory prevSharePrices = s.vaultSharePricesAtLastSwap[id];\n\n            // compute current share prices\n            uint120 sharePrice0 =\n                bunniState.reserve0 == 0 ? 0 : reserveBalance0.divWadUp(bunniState.reserve0).toUint120();\n            uint120 sharePrice1 =\n                bunniState.reserve1 == 0 ? 0 : reserveBalance1.divWadUp(bunniState.reserve1).toUint120();\n\n            // compare with share prices at last swap to see if we need to apply the surge fee\n            // surge fee is applied if the share price has increased by more than 1 / vaultSurgeThreshold\n            shouldSurge = prevSharePrices.initialized\n                && (\n                    dist(sharePrice0, prevSharePrices.sharePrice0)\n                        > prevSharePrices.sharePrice0 / hookParams.vaultSurgeThreshold0\n                        || dist(sharePrice1, prevSharePrices.sharePrice1)\n                            > prevSharePrices.sharePrice1 / hookParams.vaultSurgeThreshold1\n                );\n\n            // update share prices at last swap\n            if (\n                !prevSharePrices.initialized || sharePrice0 != prevSharePrices.sharePrice0\n                    || sharePrice1 != prevSharePrices.sharePrice1\n            ) {\n                s.vaultSharePricesAtLastSwap[id] =\n                    VaultSharePrices({initialized: true, sharePrice0: sharePrice0, sharePrice1: sharePrice1});\n            }\n        }\n    }\n\n    function _getTwap(\n        HookStorage storage s,\n        PoolId id,\n        int24 currentTick,\n        uint32 twapSecondsAgo,\n        Oracle.Observation memory updatedIntermediate,\n        uint32 updatedIndex,\n        uint32 updatedCardinality\n    ) internal view returns (int24 arithmeticMeanTick) {\n        (int56 tickCumulative0, int56 tickCumulative1) = s.observations[id].observeDouble(\n            updatedIntermediate,\n            uint32(block.timestamp),\n            twapSecondsAgo,\n            0,\n            currentTick,\n            updatedIndex,\n            updatedCardinality\n        );\n        int56 tickCumulativesDelta = tickCumulative1 - tickCumulative0;\n        arithmeticMeanTick = int24(tickCumulativesDelta / int56(uint56(twapSecondsAgo)));\n    }\n\n    function _updateOracle(HookStorage storage s, PoolId id, int24 tick, uint32 oracleMinInterval)\n        internal\n        returns (Oracle.Observation memory updatedIntermediate, uint32 updatedIndex, uint32 updatedCardinality)\n    {\n        IBunniHook.ObservationState memory state = s.states[id];\n        (updatedIntermediate, updatedIndex, updatedCardinality) = s.observations[id].write(\n            state.intermediateObservation,\n            state.index,\n            uint32(block.timestamp),\n            tick,\n            state.cardinality,\n            state.cardinalityNext,\n            oracleMinInterval\n        );\n        (s.states[id].intermediateObservation, s.states[id].index, s.states[id].cardinality) =\n            (updatedIntermediate, updatedIndex, updatedCardinality);\n    }\n\n    /// @dev Decodes hookParams into params used by this hook\n    /// @param hookParams The hook params raw bytes\n    /// @return p The decoded params struct\n    function _decodeParams(bytes memory hookParams) internal pure returns (DecodedHookParams memory p) {\n        // | feeMin - 3 bytes | feeMax - 3 bytes | feeQuadraticMultiplier - 3 bytes | feeTwapSecondsAgo - 3 bytes | maxAmAmmFee - 3 bytes | surgeFeeHalfLife - 2 bytes | surgeFeeAutostartThreshold - 2 bytes | vaultSurgeThreshold0 - 2 bytes | vaultSurgeThreshold1 - 2 bytes | rebalanceThreshold - 2 bytes | rebalanceMaxSlippage - 2 bytes | rebalanceTwapSecondsAgo - 2 bytes | rebalanceOrderTTL - 2 bytes | amAmmEnabled - 1 byte |\n        bytes32 firstWord;\n        // | oracleMinInterval - 4 bytes | minRentMultiplier - 6 bytes |\n        bytes32 secondWord;\n        /// @solidity memory-safe-assembly\n        assembly {\n            firstWord := mload(add(hookParams, 32))\n            secondWord := mload(add(hookParams, 64))\n        }\n        p.feeMin = uint24(bytes3(firstWord));\n        p.feeMax = uint24(bytes3(firstWord << 24));\n        p.feeQuadraticMultiplier = uint24(bytes3(firstWord << 48));\n        p.feeTwapSecondsAgo = uint24(bytes3(firstWord << 72));\n        p.maxAmAmmFee = uint24(bytes3(firstWord << 96));\n        p.surgeFeeHalfLife = uint16(bytes2(firstWord << 120));\n        p.surgeFeeAutostartThreshold = uint16(bytes2(firstWord << 136));\n        p.vaultSurgeThreshold0 = uint16(bytes2(firstWord << 152));\n        p.vaultSurgeThreshold1 = uint16(bytes2(firstWord << 168));\n        p.rebalanceThreshold = uint16(bytes2(firstWord << 184));\n        p.rebalanceMaxSlippage = uint16(bytes2(firstWord << 200));\n        p.rebalanceTwapSecondsAgo = uint16(bytes2(firstWord << 216));\n        p.rebalanceOrderTTL = uint16(bytes2(firstWord << 232));\n        p.amAmmEnabled = uint8(bytes1(firstWord << 248)) != 0;\n        p.oracleMinInterval = uint32(bytes4(secondWord));\n        p.minRentMultiplier = uint48(bytes6(secondWord << 32));\n    }\n}\n"}, "src/lib/OrderHashMemory.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IFloodPlain} from \"flood-contracts/src/interfaces/IFloodPlain.sol\";\nimport {ISignatureTransfer, PermitHash} from \"permit2/src/libraries/PermitHash.sol\";\n\nlibrary OrderHashMemory {\n    string internal constant _HOOK_STRING = \"Hook(address target,bytes data)\";\n    string internal constant _ITEM_STRING = \"Item(address token,uint256 amount)\";\n    string internal constant _ORDER_STRING =\n        \"Order(address offerer,address zone,address recipient,Item[] offer,Item consideration,uint256 deadline,uint256 nonce,Hook[] preHooks,Hook[] postHooks)\";\n    string internal constant _PERMIT_STRING =\n        \"PermitBatchWitnessTransferFrom(TokenPermissions[] permitted,address spender,uint256 nonce,uint256 deadline,Order witness)\";\n    string internal constant _TOKEN_PERMISSIONS_STRING = \"TokenPermissions(address token,uint256 amount)\";\n\n    string internal constant _PERMIT_STRING_VARIABLE_END = \"Order witness)\";\n\n    bytes32 public constant _ITEM_TYPEHASH = keccak256(bytes(_ITEM_STRING));\n    bytes32 public constant _HOOK_TYPEHASH = keccak256(bytes(_HOOK_STRING));\n    bytes32 public constant _ORDER_TYPEHASH = keccak256(abi.encodePacked(_ORDER_STRING, _HOOK_STRING, _ITEM_STRING));\n    bytes32 public constant _PERMIT_TYPEHASH = keccak256(\n        abi.encodePacked(_PERMIT_STRING, _HOOK_STRING, _ITEM_STRING, _ORDER_STRING, _TOKEN_PERMISSIONS_STRING)\n    );\n    string public constant _WITNESS_TYPESTRING = string(\n        abi.encodePacked(\n            _PERMIT_STRING_VARIABLE_END, _HOOK_STRING, _ITEM_STRING, _ORDER_STRING, _TOKEN_PERMISSIONS_STRING\n        )\n    );\n\n    function hash(IFloodPlain.Hook memory hook) internal pure returns (bytes32) {\n        return keccak256(abi.encode(_HOOK_TYPEHASH, hook.target, keccak256(hook.data)));\n    }\n\n    function hash(IFloodPlain.Item memory item) internal pure returns (bytes32) {\n        return keccak256(abi.encode(_ITEM_TYPEHASH, item.token, item.amount));\n    }\n\n    function hash(IFloodPlain.Order memory order) internal pure returns (bytes32) {\n        // Hash offer array.\n        uint256 length = order.offer.length;\n        bytes32[] memory offerHashes = new bytes32[](length);\n        for (uint256 i; i < length; ++i) {\n            offerHashes[i] = hash(order.offer[i]);\n        }\n\n        // Hash preHooks array.\n        length = order.preHooks.length;\n        bytes32[] memory preHooksHashes = new bytes32[](length);\n        for (uint256 i; i < length; ++i) {\n            preHooksHashes[i] = hash(order.preHooks[i]);\n        }\n\n        // Hash postHooks array.\n        length = order.postHooks.length;\n        bytes32[] memory postHooksHashes = new bytes32[](length);\n        for (uint256 i; i < length; ++i) {\n            postHooksHashes[i] = hash(order.postHooks[i]);\n        }\n\n        // Derive and return the order hash as specified by EIP-712.\n        return keccak256(\n            abi.encode(\n                _ORDER_TYPEHASH,\n                order.offerer,\n                order.zone,\n                order.recipient,\n                keccak256(abi.encodePacked(offerHashes)),\n                hash(order.consideration),\n                order.deadline,\n                order.nonce,\n                keccak256(abi.encodePacked(preHooksHashes)),\n                keccak256(abi.encodePacked(postHooksHashes))\n            )\n        );\n    }\n\n    function hashAsWitness(IFloodPlain.Order memory order, address spender)\n        internal\n        pure\n        returns (bytes32 orderHash, bytes32 hashWithWitness)\n    {\n        IFloodPlain.Item[] memory offer = order.offer;\n        bytes32[] memory tokenPermissionHashes = new bytes32[](offer.length);\n        bytes32[] memory offerHashes = new bytes32[](offer.length);\n        for (uint256 i; i < offer.length; ++i) {\n            IFloodPlain.Item memory item = offer[i];\n\n            offerHashes[i] = hash(item);\n\n            tokenPermissionHashes[i] = keccak256(\n                abi.encode(\n                    PermitHash._TOKEN_PERMISSIONS_TYPEHASH, ISignatureTransfer.TokenPermissions(item.token, item.amount)\n                )\n            );\n        }\n\n        orderHash = hash(order);\n        hashWithWitness = keccak256(\n            abi.encode(\n                _PERMIT_TYPEHASH,\n                keccak256(abi.encodePacked(tokenPermissionHashes)),\n                spender,\n                order.nonce,\n                order.deadline,\n                orderHash\n            )\n        );\n    }\n}\n"}, "lib/v4-core/src/interfaces/external/IERC20Minimal.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title Minimal ERC20 interface for Uniswap\n/// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3\ninterface IERC20Minimal {\n    /// @notice Returns an account's balance in the token\n    /// @param account The account for which to look up the number of tokens it has, i.e. its balance\n    /// @return The number of tokens held by the account\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Transfers the amount of token from the `msg.sender` to the recipient\n    /// @param recipient The account that will receive the amount transferred\n    /// @param amount The number of tokens to send from the sender to the recipient\n    /// @return Returns true for a successful transfer, false for an unsuccessful transfer\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /// @notice Returns the current allowance given to a spender by an owner\n    /// @param owner The account of the token owner\n    /// @param spender The account of the token spender\n    /// @return The current allowance granted by `owner` to `spender`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`\n    /// @param spender The account which will be allowed to spend a given amount of the owners tokens\n    /// @param amount The amount of tokens allowed to be used by `spender`\n    /// @return Returns true for a successful approval, false for unsuccessful\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`\n    /// @param sender The account from which the transfer will be initiated\n    /// @param recipient The recipient of the transfer\n    /// @param amount The amount of the transfer\n    /// @return Returns true for a successful transfer, false for unsuccessful\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.\n    /// @param from The account from which the tokens were sent, i.e. the balance decreased\n    /// @param to The account to which the tokens were sent, i.e. the balance increased\n    /// @param value The amount of tokens that were transferred\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.\n    /// @param owner The account that approved spending of its tokens\n    /// @param spender The account for which the spending allowance was modified\n    /// @param value The new allowance from the owner to the spender\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"}, "lib/v4-core/src/libraries/CustomRevert.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title Library for reverting with custom errors efficiently\n/// @notice Contains functions for reverting with custom errors with different argument types efficiently\n/// @dev To use this library, declare `using CustomRevert for bytes4;` and replace `revert CustomError()` with\n/// `CustomError.selector.revertWith()`\n/// @dev The functions may tamper with the free memory pointer but it is fine since the call context is exited immediately\nlibrary CustomRevert {\n    /// @dev ERC-7751 error for wrapping bubbled up reverts\n    error WrappedError(address target, bytes4 selector, bytes reason, bytes details);\n\n    /// @dev Reverts with the selector of a custom error in the scratch space\n    function revertWith(bytes4 selector) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            revert(0, 0x04)\n        }\n    }\n\n    /// @dev Reverts with a custom error with an address argument in the scratch space\n    function revertWith(bytes4 selector, address addr) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, and(addr, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(0, 0x24)\n        }\n    }\n\n    /// @dev Reverts with a custom error with an int24 argument in the scratch space\n    function revertWith(bytes4 selector, int24 value) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, signextend(2, value))\n            revert(0, 0x24)\n        }\n    }\n\n    /// @dev Reverts with a custom error with a uint160 argument in the scratch space\n    function revertWith(bytes4 selector, uint160 value) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, and(value, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(0, 0x24)\n        }\n    }\n\n    /// @dev Reverts with a custom error with two int24 arguments\n    function revertWith(bytes4 selector, int24 value1, int24 value2) internal pure {\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(fmp, selector)\n            mstore(add(fmp, 0x04), signextend(2, value1))\n            mstore(add(fmp, 0x24), signextend(2, value2))\n            revert(fmp, 0x44)\n        }\n    }\n\n    /// @dev Reverts with a custom error with two uint160 arguments\n    function revertWith(bytes4 selector, uint160 value1, uint160 value2) internal pure {\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(fmp, selector)\n            mstore(add(fmp, 0x04), and(value1, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(add(fmp, 0x24), and(value2, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(fmp, 0x44)\n        }\n    }\n\n    /// @dev Reverts with a custom error with two address arguments\n    function revertWith(bytes4 selector, address value1, address value2) internal pure {\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(fmp, selector)\n            mstore(add(fmp, 0x04), and(value1, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(add(fmp, 0x24), and(value2, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(fmp, 0x44)\n        }\n    }\n\n    /// @notice bubble up the revert message returned by a call and revert with a wrapped ERC-7751 error\n    /// @dev this method can be vulnerable to revert data bombs\n    function bubbleUpAndRevertWith(\n        address revertingContract,\n        bytes4 revertingFunctionSelector,\n        bytes4 additionalContext\n    ) internal pure {\n        bytes4 wrappedErrorSelector = WrappedError.selector;\n        assembly (\"memory-safe\") {\n            // Ensure the size of the revert data is a multiple of 32 bytes\n            let encodedDataSize := mul(div(add(returndatasize(), 31), 32), 32)\n\n            let fmp := mload(0x40)\n\n            // Encode wrapped error selector, address, function selector, offset, additional context, size, revert reason\n            mstore(fmp, wrappedErrorSelector)\n            mstore(add(fmp, 0x04), and(revertingContract, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(\n                add(fmp, 0x24),\n                and(revertingFunctionSelector, 0xffffffff00000000000000000000000000000000000000000000000000000000)\n            )\n            // offset revert reason\n            mstore(add(fmp, 0x44), 0x80)\n            // offset additional context\n            mstore(add(fmp, 0x64), add(0xa0, encodedDataSize))\n            // size revert reason\n            mstore(add(fmp, 0x84), returndatasize())\n            // revert reason\n            returndatacopy(add(fmp, 0xa4), 0, returndatasize())\n            // size additional context\n            mstore(add(fmp, add(0xa4, encodedDataSize)), 0x04)\n            // additional context\n            mstore(\n                add(fmp, add(0xc4, encodedDataSize)),\n                and(additionalContext, 0xffffffff00000000000000000000000000000000000000000000000000000000)\n            )\n            revert(fmp, add(0xe4, encodedDataSize))\n        }\n    }\n}\n"}, "lib/v4-core/src/libraries/BitMath.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title BitMath\n/// @dev This library provides functionality for computing bit properties of an unsigned integer\n/// @author Solady (https://github.com/Vectorized/solady/blob/8200a70e8dc2a77ecb074fc2e99a2a0d36547522/src/utils/LibBit.sol)\nlibrary BitMath {\n    /// @notice Returns the index of the most significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @param x the value for which to compute the most significant bit, must be greater than 0\n    /// @return r the index of the most significant bit\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        assembly (\"memory-safe\") {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020500060203020504000106050205030304010505030400000000))\n        }\n    }\n\n    /// @notice Returns the index of the least significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @param x the value for which to compute the least significant bit, must be greater than 0\n    /// @return r the index of the least significant bit\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        assembly (\"memory-safe\") {\n            // Isolate the least significant bit.\n            x := and(x, sub(0, x))\n            // For the upper 3 bits of the result, use a De Bruijn-like lookup.\n            // Credit to adhusson: https://blog.adhusson.com/cheap-find-first-set-evm/\n            // forgefmt: disable-next-item\n            r := shl(5, shr(252, shl(shl(2, shr(250, mul(x,\n                0xb6db6db6ddddddddd34d34d349249249210842108c6318c639ce739cffffffff))),\n                0x8040405543005266443200005020610674053026020000107506200176117077)))\n            // For the lower 5 bits of the result, use a De Bruijn lookup.\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(div(0xd76453e0, shr(r, x)), 0x1f),\n                0x001f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405))\n        }\n    }\n}\n"}, "lib/permit2/src/interfaces/ISignatureTransfer.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IEIP712} from \"./IEIP712.sol\";\n\n/// @title SignatureTransfer\n/// @notice Handles ERC20 token transfers through signature based actions\n/// @dev Requires user's token approval on the Permit2 contract\ninterface ISignatureTransfer is IEIP712 {\n    /// @notice Thrown when the requested amount for a transfer is larger than the permissioned amount\n    /// @param maxAmount The maximum amount a spender can request to transfer\n    error InvalidAmount(uint256 maxAmount);\n\n    /// @notice Thrown when the number of tokens permissioned to a spender does not match the number of tokens being transferred\n    /// @dev If the spender does not need to transfer the number of tokens permitted, the spender can request amount 0 to be transferred\n    error LengthMismatch();\n\n    /// @notice Emits an event when the owner successfully invalidates an unordered nonce.\n    event UnorderedNonceInvalidation(address indexed owner, uint256 word, uint256 mask);\n\n    /// @notice The token and amount details for a transfer signed in the permit transfer signature\n    struct TokenPermissions {\n        // ERC20 token address\n        address token;\n        // the maximum amount that can be spent\n        uint256 amount;\n    }\n\n    /// @notice The signed permit message for a single token transfer\n    struct PermitTransferFrom {\n        TokenPermissions permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice Specifies the recipient address and amount for batched transfers.\n    /// @dev Recipients and amounts correspond to the index of the signed token permissions array.\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount.\n    struct SignatureTransferDetails {\n        // recipient address\n        address to;\n        // spender requested amount\n        uint256 requestedAmount;\n    }\n\n    /// @notice Used to reconstruct the signed permit message for multiple token transfers\n    /// @dev Do not need to pass in spender address as it is required that it is msg.sender\n    /// @dev Note that a user still signs over a spender address\n    struct PermitBatchTransferFrom {\n        // the tokens and corresponding amounts permitted for a transfer\n        TokenPermissions[] permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice A map from token owner address and a caller specified word index to a bitmap. Used to set bits in the bitmap to prevent against signature replay protection\n    /// @dev Uses unordered nonces so that permit messages do not need to be spent in a certain order\n    /// @dev The mapping is indexed first by the token owner, then by an index specified in the nonce\n    /// @dev It returns a uint256 bitmap\n    /// @dev The index, or wordPosition is capped at type(uint248).max\n    function nonceBitmap(address, uint256) external view returns (uint256);\n\n    /// @notice Transfers a token using a signed permit message\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers a token using a signed permit message\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Invalidates the bits specified in mask for the bitmap at the word position\n    /// @dev The wordPos is maxed at type(uint248).max\n    /// @param wordPos A number to index the nonceBitmap at\n    /// @param mask A bitmap masked against msg.sender's current bitmap at the word position\n    function invalidateUnorderedNonces(uint256 wordPos, uint256 mask) external;\n}\n"}, "lib/solady/src/tokens/ERC4626.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {ERC20} from \"./ERC20.sol\";\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\n\n/// @notice Simple ERC4626 tokenized Vault implementation.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC4626.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC4626.sol)\nabstract contract ERC4626 is ERC20 {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         CONSTANTS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The default underlying decimals.\n    uint8 internal constant _DEFAULT_UNDERLYING_DECIMALS = 18;\n\n    /// @dev The default decimals offset.\n    uint8 internal constant _DEFAULT_DECIMALS_OFFSET = 0;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Cannot deposit more than the max limit.\n    error DepositMoreThanMax();\n\n    /// @dev Cannot mint more than the max limit.\n    error MintMoreThanMax();\n\n    /// @dev Cannot withdraw more than the max limit.\n    error WithdrawMoreThanMax();\n\n    /// @dev Cannot redeem more than the max limit.\n    error RedeemMoreThanMax();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                           EVENTS                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Emitted during a mint call or deposit call.\n    event Deposit(address indexed by, address indexed owner, uint256 assets, uint256 shares);\n\n    /// @dev Emitted during a withdraw call or redeem call.\n    event Withdraw(\n        address indexed by,\n        address indexed to,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// @dev `keccak256(bytes(\"Deposit(address,address,uint256,uint256)\"))`.\n    uint256 private constant _DEPOSIT_EVENT_SIGNATURE =\n        0xdcbc1c05240f31ff3ad067ef1ee35ce4997762752e3a095284754544f4c709d7;\n\n    /// @dev `keccak256(bytes(\"Withdraw(address,address,address,uint256,uint256)\"))`.\n    uint256 private constant _WITHDRAW_EVENT_SIGNATURE =\n        0xfbde797d201c681b91056529119e0b02407c7bb96a4a2c75c01fc9667232c8db;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                     ERC4626 CONSTANTS                      */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev To be overridden to return the address of the underlying asset.\n    ///\n    /// - MUST be an ERC20 token contract.\n    /// - MUST NOT revert.\n    function asset() public view virtual returns (address);\n\n    /// @dev To be overridden to return the number of decimals of the underlying asset.\n    /// Default: 18.\n    ///\n    /// - MUST NOT revert.\n    function _underlyingDecimals() internal view virtual returns (uint8) {\n        return _DEFAULT_UNDERLYING_DECIMALS;\n    }\n\n    /// @dev Override to return a non-zero value to make the inflation attack even more unfeasible.\n    /// Only used when {_useVirtualShares} returns true.\n    /// Default: 0.\n    ///\n    /// - MUST NOT revert.\n    function _decimalsOffset() internal view virtual returns (uint8) {\n        return _DEFAULT_DECIMALS_OFFSET;\n    }\n\n    /// @dev Returns whether virtual shares will be used to mitigate the inflation attack.\n    /// See: https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3706\n    /// Override to return true or false.\n    /// Default: true.\n    ///\n    /// - MUST NOT revert.\n    function _useVirtualShares() internal view virtual returns (bool) {\n        return true;\n    }\n\n    /// @dev Returns the decimals places of the token.\n    ///\n    /// - MUST NOT revert.\n    function decimals() public view virtual override(ERC20) returns (uint8) {\n        if (!_useVirtualShares()) return _underlyingDecimals();\n        return _underlyingDecimals() + _decimalsOffset();\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                ASSET DECIMALS GETTER HELPER                */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Helper function to get the decimals of the underlying asset.\n    /// Useful for setting the return value of `_underlyingDecimals` during initialization.\n    /// If the retrieval succeeds, `success` will be true, and `result` will hold the result.\n    /// Otherwise, `success` will be false, and `result` will be zero.\n    ///\n    /// Example usage:\n    /// ```\n    /// (bool success, uint8 result) = _tryGetAssetDecimals(underlying);\n    /// _decimals = success ? result : _DEFAULT_UNDERLYING_DECIMALS;\n    /// ```\n    function _tryGetAssetDecimals(address underlying)\n        internal\n        view\n        returns (bool success, uint8 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Store the function selector of `decimals()`.\n            mstore(0x00, 0x313ce567)\n            // Arguments are evaluated last to first.\n            success :=\n                and(\n                    // Returned value is less than 256, at left-padded to 32 bytes.\n                    and(lt(mload(0x00), 0x100), gt(returndatasize(), 0x1f)),\n                    // The staticcall succeeds.\n                    staticcall(gas(), underlying, 0x1c, 0x04, 0x00, 0x20)\n                )\n            result := mul(mload(0x00), success)\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      ACCOUNTING LOGIC                      */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the total amount of the underlying asset managed by the Vault.\n    ///\n    /// - SHOULD include any compounding that occurs from the yield.\n    /// - MUST be inclusive of any fees that are charged against assets in the Vault.\n    /// - MUST NOT revert.\n    function totalAssets() public view virtual returns (uint256 assets) {\n        assets = SafeTransferLib.balanceOf(asset(), address(this));\n    }\n\n    /// @dev Returns the amount of shares that the Vault will exchange for the amount of\n    /// assets provided, in an ideal scenario where all conditions are met.\n    ///\n    /// - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// - MUST NOT show any variations depending on the caller.\n    /// - MUST NOT reflect slippage or other on-chain conditions, during the actual exchange.\n    /// - MUST NOT revert.\n    ///\n    /// Note: This calculation MAY NOT reflect the \"per-user\" price-per-share, and instead\n    /// should reflect the \"average-user's\" price-per-share, i.e. what the average user should\n    /// expect to see when exchanging to and from.\n    function convertToShares(uint256 assets) public view virtual returns (uint256 shares) {\n        if (!_useVirtualShares()) {\n            uint256 supply = totalSupply();\n            return _eitherIsZero(assets, supply)\n                ? _initialConvertToShares(assets)\n                : FixedPointMathLib.fullMulDiv(assets, supply, totalAssets());\n        }\n        uint256 o = _decimalsOffset();\n        if (o == uint256(0)) {\n            return FixedPointMathLib.fullMulDiv(assets, totalSupply() + 1, _inc(totalAssets()));\n        }\n        return FixedPointMathLib.fullMulDiv(assets, totalSupply() + 10 ** o, _inc(totalAssets()));\n    }\n\n    /// @dev Returns the amount of assets that the Vault will exchange for the amount of\n    /// shares provided, in an ideal scenario where all conditions are met.\n    ///\n    /// - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// - MUST NOT show any variations depending on the caller.\n    /// - MUST NOT reflect slippage or other on-chain conditions, during the actual exchange.\n    /// - MUST NOT revert.\n    ///\n    /// Note: This calculation MAY NOT reflect the \"per-user\" price-per-share, and instead\n    /// should reflect the \"average-user's\" price-per-share, i.e. what the average user should\n    /// expect to see when exchanging to and from.\n    function convertToAssets(uint256 shares) public view virtual returns (uint256 assets) {\n        if (!_useVirtualShares()) {\n            uint256 supply = totalSupply();\n            return supply == uint256(0)\n                ? _initialConvertToAssets(shares)\n                : FixedPointMathLib.fullMulDiv(shares, totalAssets(), supply);\n        }\n        uint256 o = _decimalsOffset();\n        if (o == uint256(0)) {\n            return FixedPointMathLib.fullMulDiv(shares, totalAssets() + 1, _inc(totalSupply()));\n        }\n        return FixedPointMathLib.fullMulDiv(shares, totalAssets() + 1, totalSupply() + 10 ** o);\n    }\n\n    /// @dev Allows an on-chain or off-chain user to simulate the effects of their deposit\n    /// at the current block, given current on-chain conditions.\n    ///\n    /// - MUST return as close to and no more than the exact amount of Vault shares that\n    ///   will be minted in a deposit call in the same transaction, i.e. deposit should\n    ///   return the same or more shares as `previewDeposit` if call in the same transaction.\n    /// - MUST NOT account for deposit limits like those returned from `maxDeposit` and should\n    ///   always act as if the deposit will be accepted, regardless of approvals, etc.\n    /// - MUST be inclusive of deposit fees. Integrators should be aware of this.\n    /// - MUST not revert.\n    ///\n    /// Note: Any unfavorable discrepancy between `convertToShares` and `previewDeposit` SHOULD\n    /// be considered slippage in share price or some other type of condition, meaning\n    /// the depositor will lose assets by depositing.\n    function previewDeposit(uint256 assets) public view virtual returns (uint256 shares) {\n        shares = convertToShares(assets);\n    }\n\n    /// @dev Allows an on-chain or off-chain user to simulate the effects of their mint\n    /// at the current block, given current on-chain conditions.\n    ///\n    /// - MUST return as close to and no fewer than the exact amount of assets that\n    ///   will be deposited in a mint call in the same transaction, i.e. mint should\n    ///   return the same or fewer assets as `previewMint` if called in the same transaction.\n    /// - MUST NOT account for mint limits like those returned from `maxMint` and should\n    ///   always act as if the mint will be accepted, regardless of approvals, etc.\n    /// - MUST be inclusive of deposit fees. Integrators should be aware of this.\n    /// - MUST not revert.\n    ///\n    /// Note: Any unfavorable discrepancy between `convertToAssets` and `previewMint` SHOULD\n    /// be considered slippage in share price or some other type of condition,\n    /// meaning the depositor will lose assets by minting.\n    function previewMint(uint256 shares) public view virtual returns (uint256 assets) {\n        if (!_useVirtualShares()) {\n            uint256 supply = totalSupply();\n            return supply == uint256(0)\n                ? _initialConvertToAssets(shares)\n                : FixedPointMathLib.fullMulDivUp(shares, totalAssets(), supply);\n        }\n        uint256 o = _decimalsOffset();\n        if (o == uint256(0)) {\n            return FixedPointMathLib.fullMulDivUp(shares, totalAssets() + 1, _inc(totalSupply()));\n        }\n        return FixedPointMathLib.fullMulDivUp(shares, totalAssets() + 1, totalSupply() + 10 ** o);\n    }\n\n    /// @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal\n    /// at the current block, given the current on-chain conditions.\n    ///\n    /// - MUST return as close to and no fewer than the exact amount of Vault shares that\n    ///   will be burned in a withdraw call in the same transaction, i.e. withdraw should\n    ///   return the same or fewer shares as `previewWithdraw` if call in the same transaction.\n    /// - MUST NOT account for withdrawal limits like those returned from `maxWithdraw` and should\n    ///   always act as if the withdrawal will be accepted, regardless of share balance, etc.\n    /// - MUST be inclusive of withdrawal fees. Integrators should be aware of this.\n    /// - MUST not revert.\n    ///\n    /// Note: Any unfavorable discrepancy between `convertToShares` and `previewWithdraw` SHOULD\n    /// be considered slippage in share price or some other type of condition,\n    /// meaning the depositor will lose assets by depositing.\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256 shares) {\n        if (!_useVirtualShares()) {\n            uint256 supply = totalSupply();\n            return _eitherIsZero(assets, supply)\n                ? _initialConvertToShares(assets)\n                : FixedPointMathLib.fullMulDivUp(assets, supply, totalAssets());\n        }\n        uint256 o = _decimalsOffset();\n        if (o == uint256(0)) {\n            return FixedPointMathLib.fullMulDivUp(assets, totalSupply() + 1, _inc(totalAssets()));\n        }\n        return FixedPointMathLib.fullMulDivUp(assets, totalSupply() + 10 ** o, _inc(totalAssets()));\n    }\n\n    /// @dev Allows an on-chain or off-chain user to simulate the effects of their redemption\n    /// at the current block, given current on-chain conditions.\n    ///\n    /// - MUST return as close to and no more than the exact amount of assets that\n    ///   will be withdrawn in a redeem call in the same transaction, i.e. redeem should\n    ///   return the same or more assets as `previewRedeem` if called in the same transaction.\n    /// - MUST NOT account for redemption limits like those returned from `maxRedeem` and should\n    ///   always act as if the redemption will be accepted, regardless of approvals, etc.\n    /// - MUST be inclusive of withdrawal fees. Integrators should be aware of this.\n    /// - MUST NOT revert.\n    ///\n    /// Note: Any unfavorable discrepancy between `convertToAssets` and `previewRedeem` SHOULD\n    /// be considered slippage in share price or some other type of condition,\n    /// meaning the depositor will lose assets by depositing.\n    function previewRedeem(uint256 shares) public view virtual returns (uint256 assets) {\n        assets = convertToAssets(shares);\n    }\n\n    /// @dev Private helper to return if either value is zero.\n    function _eitherIsZero(uint256 a, uint256 b) private pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := or(iszero(a), iszero(b))\n        }\n    }\n\n    /// @dev Private helper to return `x + 1` without the overflow check.\n    /// Used for computing the denominator input to `FixedPointMathLib.fullMulDiv(a, b, x + 1)`.\n    /// When `x == type(uint256).max`, we get `x + 1 == 0` (mod 2**256 - 1),\n    /// and `FixedPointMathLib.fullMulDiv` will revert as the denominator is zero.\n    function _inc(uint256 x) private pure returns (uint256) {\n        unchecked {\n            return x + 1;\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*              DEPOSIT / WITHDRAWAL LIMIT LOGIC              */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the maximum amount of the underlying asset that can be deposited\n    /// into the Vault for `to`, via a deposit call.\n    ///\n    /// - MUST return a limited value if `to` is subject to some deposit limit.\n    /// - MUST return `2**256-1` if there is no maximum limit.\n    /// - MUST NOT revert.\n    function maxDeposit(address to) public view virtual returns (uint256 maxAssets) {\n        to = to; // Silence unused variable warning.\n        maxAssets = type(uint256).max;\n    }\n\n    /// @dev Returns the maximum amount of the Vault shares that can be minter for `to`,\n    /// via a mint call.\n    ///\n    /// - MUST return a limited value if `to` is subject to some mint limit.\n    /// - MUST return `2**256-1` if there is no maximum limit.\n    /// - MUST NOT revert.\n    function maxMint(address to) public view virtual returns (uint256 maxShares) {\n        to = to; // Silence unused variable warning.\n        maxShares = type(uint256).max;\n    }\n\n    /// @dev Returns the maximum amount of the underlying asset that can be withdrawn\n    /// from the `owner`'s balance in the Vault, via a withdraw call.\n    ///\n    /// - MUST return a limited value if `owner` is subject to some withdrawal limit or timelock.\n    /// - MUST NOT revert.\n    function maxWithdraw(address owner) public view virtual returns (uint256 maxAssets) {\n        maxAssets = convertToAssets(balanceOf(owner));\n    }\n\n    /// @dev Returns the maximum amount of Vault shares that can be redeemed\n    /// from the `owner`'s balance in the Vault, via a redeem call.\n    ///\n    /// - MUST return a limited value if `owner` is subject to some withdrawal limit or timelock.\n    /// - MUST return `balanceOf(owner)` otherwise.\n    /// - MUST NOT revert.\n    function maxRedeem(address owner) public view virtual returns (uint256 maxShares) {\n        maxShares = balanceOf(owner);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                 DEPOSIT / WITHDRAWAL LOGIC                 */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Mints `shares` Vault shares to `to` by depositing exactly `assets`\n    /// of underlying tokens.\n    ///\n    /// - MUST emit the {Deposit} event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault\n    ///   contract before the deposit execution, and are accounted for during deposit.\n    /// - MUST revert if all of `assets` cannot be deposited, such as due to deposit limit,\n    ///   slippage, insufficient approval, etc.\n    ///\n    /// Note: Most implementations will require pre-approval of the Vault with the\n    /// Vault's underlying `asset` token.\n    function deposit(uint256 assets, address to) public virtual returns (uint256 shares) {\n        if (assets > maxDeposit(to)) _revert(0xb3c61a83); // `DepositMoreThanMax()`.\n        shares = previewDeposit(assets);\n        _deposit(msg.sender, to, assets, shares);\n    }\n\n    /// @dev Mints exactly `shares` Vault shares to `to` by depositing `assets`\n    /// of underlying tokens.\n    ///\n    /// - MUST emit the {Deposit} event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault\n    ///   contract before the mint execution, and are accounted for during mint.\n    /// - MUST revert if all of `shares` cannot be deposited, such as due to deposit limit,\n    ///   slippage, insufficient approval, etc.\n    ///\n    /// Note: Most implementations will require pre-approval of the Vault with the\n    /// Vault's underlying `asset` token.\n    function mint(uint256 shares, address to) public virtual returns (uint256 assets) {\n        if (shares > maxMint(to)) _revert(0x6a695959); // `MintMoreThanMax()`.\n        assets = previewMint(shares);\n        _deposit(msg.sender, to, assets, shares);\n    }\n\n    /// @dev Burns `shares` from `owner` and sends exactly `assets` of underlying tokens to `to`.\n    ///\n    /// - MUST emit the {Withdraw} event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault\n    ///   contract before the withdraw execution, and are accounted for during withdraw.\n    /// - MUST revert if all of `assets` cannot be withdrawn, such as due to withdrawal limit,\n    ///   slippage, insufficient balance, etc.\n    ///\n    /// Note: Some implementations will require pre-requesting to the Vault before a withdrawal\n    /// may be performed. Those methods should be performed separately.\n    function withdraw(uint256 assets, address to, address owner)\n        public\n        virtual\n        returns (uint256 shares)\n    {\n        if (assets > maxWithdraw(owner)) _revert(0x936941fc); // `WithdrawMoreThanMax()`.\n        shares = previewWithdraw(assets);\n        _withdraw(msg.sender, to, owner, assets, shares);\n    }\n\n    /// @dev Burns exactly `shares` from `owner` and sends `assets` of underlying tokens to `to`.\n    ///\n    /// - MUST emit the {Withdraw} event.\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault\n    ///   contract before the redeem execution, and are accounted for during redeem.\n    /// - MUST revert if all of shares cannot be redeemed, such as due to withdrawal limit,\n    ///   slippage, insufficient balance, etc.\n    ///\n    /// Note: Some implementations will require pre-requesting to the Vault before a redeem\n    /// may be performed. Those methods should be performed separately.\n    function redeem(uint256 shares, address to, address owner)\n        public\n        virtual\n        returns (uint256 assets)\n    {\n        if (shares > maxRedeem(owner)) _revert(0x4656425a); // `RedeemMoreThanMax()`.\n        assets = previewRedeem(shares);\n        _withdraw(msg.sender, to, owner, assets, shares);\n    }\n\n    /// @dev Internal helper for reverting efficiently.\n    function _revert(uint256 s) private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, s)\n            revert(0x1c, 0x04)\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      INTERNAL HELPERS                      */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev For deposits and mints.\n    ///\n    /// Emits a {Deposit} event.\n    function _deposit(address by, address to, uint256 assets, uint256 shares) internal virtual {\n        SafeTransferLib.safeTransferFrom(asset(), by, address(this), assets);\n        _mint(to, shares);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Emit the {Deposit} event.\n            mstore(0x00, assets)\n            mstore(0x20, shares)\n            let m := shr(96, not(0))\n            log3(0x00, 0x40, _DEPOSIT_EVENT_SIGNATURE, and(m, by), and(m, to))\n        }\n        _afterDeposit(assets, shares);\n    }\n\n    /// @dev For withdrawals and redemptions.\n    ///\n    /// Emits a {Withdraw} event.\n    function _withdraw(address by, address to, address owner, uint256 assets, uint256 shares)\n        internal\n        virtual\n    {\n        if (by != owner) _spendAllowance(owner, by, shares);\n        _beforeWithdraw(assets, shares);\n        _burn(owner, shares);\n        SafeTransferLib.safeTransfer(asset(), to, assets);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Emit the {Withdraw} event.\n            mstore(0x00, assets)\n            mstore(0x20, shares)\n            let m := shr(96, not(0))\n            log4(0x00, 0x40, _WITHDRAW_EVENT_SIGNATURE, and(m, by), and(m, to), and(m, owner))\n        }\n    }\n\n    /// @dev Internal conversion function (from assets to shares) to apply when the Vault is empty.\n    /// Only used when {_useVirtualShares} returns false.\n    ///\n    /// Note: Make sure to keep this function consistent with {_initialConvertToAssets}\n    /// when overriding it.\n    function _initialConvertToShares(uint256 assets)\n        internal\n        view\n        virtual\n        returns (uint256 shares)\n    {\n        shares = assets;\n    }\n\n    /// @dev Internal conversion function (from shares to assets) to apply when the Vault is empty.\n    /// Only used when {_useVirtualShares} returns false.\n    ///\n    /// Note: Make sure to keep this function consistent with {_initialConvertToShares}\n    /// when overriding it.\n    function _initialConvertToAssets(uint256 shares)\n        internal\n        view\n        virtual\n        returns (uint256 assets)\n    {\n        assets = shares;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                     HOOKS TO OVERRIDE                      */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Hook that is called before any withdrawal or redemption.\n    function _beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    /// @dev Hook that is called after any deposit or mint.\n    function _afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n}\n"}, "lib/v4-core/src/interfaces/IPoolManager.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Currency} from \"../types/Currency.sol\";\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {IHooks} from \"./IHooks.sol\";\nimport {IERC6909Claims} from \"./external/IERC6909Claims.sol\";\nimport {IProtocolFees} from \"./IProtocolFees.sol\";\nimport {BalanceDelta} from \"../types/BalanceDelta.sol\";\nimport {PoolId} from \"../types/PoolId.sol\";\nimport {IExtsload} from \"./IExtsload.sol\";\nimport {IExttload} from \"./IExttload.sol\";\n\n/// @notice Interface for the PoolManager\ninterface IPoolManager is IProtocolFees, IERC6909Claims, IExtsload, IExttload {\n    /// @notice Thrown when a currency is not netted out after the contract is unlocked\n    error CurrencyNotSettled();\n\n    /// @notice Thrown when trying to interact with a non-initialized pool\n    error PoolNotInitialized();\n\n    /// @notice Thrown when unlock is called, but the contract is already unlocked\n    error AlreadyUnlocked();\n\n    /// @notice Thrown when a function is called that requires the contract to be unlocked, but it is not\n    error ManagerLocked();\n\n    /// @notice Pools are limited to type(int16).max tickSpacing in #initialize, to prevent overflow\n    error TickSpacingTooLarge(int24 tickSpacing);\n\n    /// @notice Pools must have a positive non-zero tickSpacing passed to #initialize\n    error TickSpacingTooSmall(int24 tickSpacing);\n\n    /// @notice PoolKey must have currencies where address(currency0) < address(currency1)\n    error CurrenciesOutOfOrderOrEqual(address currency0, address currency1);\n\n    /// @notice Thrown when a call to updateDynamicLPFee is made by an address that is not the hook,\n    /// or on a pool that does not have a dynamic swap fee.\n    error UnauthorizedDynamicLPFeeUpdate();\n\n    /// @notice Thrown when trying to swap amount of 0\n    error SwapAmountCannotBeZero();\n\n    ///@notice Thrown when native currency is passed to a non native settlement\n    error NonzeroNativeValue();\n\n    /// @notice Thrown when `clear` is called with an amount that is not exactly equal to the open currency delta.\n    error MustClearExactPositiveDelta();\n\n    /// @notice Emitted when a new pool is initialized\n    /// @param id The abi encoded hash of the pool key struct for the new pool\n    /// @param currency0 The first currency of the pool by address sort order\n    /// @param currency1 The second currency of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param hooks The hooks contract address for the pool, or address(0) if none\n    /// @param sqrtPriceX96 The price of the pool on initialization\n    /// @param tick The initial tick of the pool corresponding to the initialized price\n    event Initialize(\n        PoolId indexed id,\n        Currency indexed currency0,\n        Currency indexed currency1,\n        uint24 fee,\n        int24 tickSpacing,\n        IHooks hooks,\n        uint160 sqrtPriceX96,\n        int24 tick\n    );\n\n    /// @notice Emitted when a liquidity position is modified\n    /// @param id The abi encoded hash of the pool key struct for the pool that was modified\n    /// @param sender The address that modified the pool\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param liquidityDelta The amount of liquidity that was added or removed\n    /// @param salt The extra data to make positions unique\n    event ModifyLiquidity(\n        PoolId indexed id, address indexed sender, int24 tickLower, int24 tickUpper, int256 liquidityDelta, bytes32 salt\n    );\n\n    /// @notice Emitted for swaps between currency0 and currency1\n    /// @param id The abi encoded hash of the pool key struct for the pool that was modified\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param amount0 The delta of the currency0 balance of the pool\n    /// @param amount1 The delta of the currency1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of the price of the pool after the swap\n    /// @param fee The swap fee in hundredths of a bip\n    event Swap(\n        PoolId indexed id,\n        address indexed sender,\n        int128 amount0,\n        int128 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick,\n        uint24 fee\n    );\n\n    /// @notice Emitted for donations\n    /// @param id The abi encoded hash of the pool key struct for the pool that was donated to\n    /// @param sender The address that initiated the donate call\n    /// @param amount0 The amount donated in currency0\n    /// @param amount1 The amount donated in currency1\n    event Donate(PoolId indexed id, address indexed sender, uint256 amount0, uint256 amount1);\n\n    /// @notice All interactions on the contract that account deltas require unlocking. A caller that calls `unlock` must implement\n    /// `IUnlockCallback(msg.sender).unlockCallback(data)`, where they interact with the remaining functions on this contract.\n    /// @dev The only functions callable without an unlocking are `initialize` and `updateDynamicLPFee`\n    /// @param data Any data to pass to the callback, via `IUnlockCallback(msg.sender).unlockCallback(data)`\n    /// @return The data returned by the call to `IUnlockCallback(msg.sender).unlockCallback(data)`\n    function unlock(bytes calldata data) external returns (bytes memory);\n\n    /// @notice Initialize the state for a given pool ID\n    /// @dev A swap fee totaling MAX_SWAP_FEE (100%) makes exact output swaps impossible since the input is entirely consumed by the fee\n    /// @param key The pool key for the pool to initialize\n    /// @param sqrtPriceX96 The initial square root price\n    /// @return tick The initial tick of the pool\n    function initialize(PoolKey memory key, uint160 sqrtPriceX96) external returns (int24 tick);\n\n    struct ModifyLiquidityParams {\n        // the lower and upper tick of the position\n        int24 tickLower;\n        int24 tickUpper;\n        // how to modify the liquidity\n        int256 liquidityDelta;\n        // a value to set if you want unique liquidity positions at the same range\n        bytes32 salt;\n    }\n\n    /// @notice Modify the liquidity for the given pool\n    /// @dev Poke by calling with a zero liquidityDelta\n    /// @param key The pool to modify liquidity in\n    /// @param params The parameters for modifying the liquidity\n    /// @param hookData The data to pass through to the add/removeLiquidity hooks\n    /// @return callerDelta The balance delta of the caller of modifyLiquidity. This is the total of both principal, fee deltas, and hook deltas if applicable\n    /// @return feesAccrued The balance delta of the fees generated in the liquidity range. Returned for informational purposes\n    /// @dev Note that feesAccrued can be artificially inflated by a malicious actor and integrators should be careful using the value\n    /// For pools with a single liquidity position, actors can donate to themselves to inflate feeGrowthGlobal (and consequently feesAccrued)\n    /// atomically donating and collecting fees in the same unlockCallback may make the inflated value more extreme\n    function modifyLiquidity(PoolKey memory key, ModifyLiquidityParams memory params, bytes calldata hookData)\n        external\n        returns (BalanceDelta callerDelta, BalanceDelta feesAccrued);\n\n    struct SwapParams {\n        /// Whether to swap token0 for token1 or vice versa\n        bool zeroForOne;\n        /// The desired input amount if negative (exactIn), or the desired output amount if positive (exactOut)\n        int256 amountSpecified;\n        /// The sqrt price at which, if reached, the swap will stop executing\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swap against the given pool\n    /// @param key The pool to swap in\n    /// @param params The parameters for swapping\n    /// @param hookData The data to pass through to the swap hooks\n    /// @return swapDelta The balance delta of the address swapping\n    /// @dev Swapping on low liquidity pools may cause unexpected swap amounts when liquidity available is less than amountSpecified.\n    /// Additionally note that if interacting with hooks that have the BEFORE_SWAP_RETURNS_DELTA_FLAG or AFTER_SWAP_RETURNS_DELTA_FLAG\n    /// the hook may alter the swap input/output. Integrators should perform checks on the returned swapDelta.\n    function swap(PoolKey memory key, SwapParams memory params, bytes calldata hookData)\n        external\n        returns (BalanceDelta swapDelta);\n\n    /// @notice Donate the given currency amounts to the in-range liquidity providers of a pool\n    /// @dev Calls to donate can be frontrun adding just-in-time liquidity, with the aim of receiving a portion donated funds.\n    /// Donors should keep this in mind when designing donation mechanisms.\n    /// @dev This function donates to in-range LPs at slot0.tick. In certain edge-cases of the swap algorithm, the `sqrtPrice` of\n    /// a pool can be at the lower boundary of tick `n`, but the `slot0.tick` of the pool is already `n - 1`. In this case a call to\n    /// `donate` would donate to tick `n - 1` (slot0.tick) not tick `n` (getTickAtSqrtPrice(slot0.sqrtPriceX96)).\n    /// Read the comments in `Pool.swap()` for more information about this.\n    /// @param key The key of the pool to donate to\n    /// @param amount0 The amount of currency0 to donate\n    /// @param amount1 The amount of currency1 to donate\n    /// @param hookData The data to pass through to the donate hooks\n    /// @return BalanceDelta The delta of the caller after the donate\n    function donate(PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)\n        external\n        returns (BalanceDelta);\n\n    /// @notice Writes the current ERC20 balance of the specified currency to transient storage\n    /// This is used to checkpoint balances for the manager and derive deltas for the caller.\n    /// @dev This MUST be called before any ERC20 tokens are sent into the contract, but can be skipped\n    /// for native tokens because the amount to settle is determined by the sent value.\n    /// However, if an ERC20 token has been synced and not settled, and the caller instead wants to settle\n    /// native funds, this function can be called with the native currency to then be able to settle the native currency\n    function sync(Currency currency) external;\n\n    /// @notice Called by the user to net out some value owed to the user\n    /// @dev Will revert if the requested amount is not available, consider using `mint` instead\n    /// @dev Can also be used as a mechanism for free flash loans\n    /// @param currency The currency to withdraw from the pool manager\n    /// @param to The address to withdraw to\n    /// @param amount The amount of currency to withdraw\n    function take(Currency currency, address to, uint256 amount) external;\n\n    /// @notice Called by the user to pay what is owed\n    /// @return paid The amount of currency settled\n    function settle() external payable returns (uint256 paid);\n\n    /// @notice Called by the user to pay on behalf of another address\n    /// @param recipient The address to credit for the payment\n    /// @return paid The amount of currency settled\n    function settleFor(address recipient) external payable returns (uint256 paid);\n\n    /// @notice WARNING - Any currency that is cleared, will be non-retrievable, and locked in the contract permanently.\n    /// A call to clear will zero out a positive balance WITHOUT a corresponding transfer.\n    /// @dev This could be used to clear a balance that is considered dust.\n    /// Additionally, the amount must be the exact positive balance. This is to enforce that the caller is aware of the amount being cleared.\n    function clear(Currency currency, uint256 amount) external;\n\n    /// @notice Called by the user to move value into ERC6909 balance\n    /// @param to The address to mint the tokens to\n    /// @param id The currency address to mint to ERC6909s, as a uint256\n    /// @param amount The amount of currency to mint\n    /// @dev The id is converted to a uint160 to correspond to a currency address\n    /// If the upper 12 bytes are not 0, they will be 0-ed out\n    function mint(address to, uint256 id, uint256 amount) external;\n\n    /// @notice Called by the user to move value from ERC6909 balance\n    /// @param from The address to burn the tokens from\n    /// @param id The currency address to burn from ERC6909s, as a uint256\n    /// @param amount The amount of currency to burn\n    /// @dev The id is converted to a uint160 to correspond to a currency address\n    /// If the upper 12 bytes are not 0, they will be 0-ed out\n    function burn(address from, uint256 id, uint256 amount) external;\n\n    /// @notice Updates the pools lp fees for the a pool that has enabled dynamic lp fees.\n    /// @dev A swap fee totaling MAX_SWAP_FEE (100%) makes exact output swaps impossible since the input is entirely consumed by the fee\n    /// @param key The key of the pool to update dynamic LP fees for\n    /// @param newDynamicLPFee The new dynamic pool LP fee\n    function updateDynamicLPFee(PoolKey memory key, uint24 newDynamicLPFee) external;\n}\n"}, "lib/solady/src/utils/SSTORE2.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SSTORE2.sol)\n/// @author Saw-mon-and-Natalie (https://github.com/Saw-mon-and-Natalie)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\n/// @author Modified from SSTORE3 (https://github.com/Philogy/sstore3)\nlibrary SSTORE2 {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         CONSTANTS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The proxy initialization code.\n    uint256 private constant _CREATE3_PROXY_INITCODE = 0x67363d3d37363d34f03d5260086018f3;\n\n    /// @dev Hash of the `_CREATE3_PROXY_INITCODE`.\n    /// Equivalent to `keccak256(abi.encodePacked(hex\"67363d3d37363d34f03d5260086018f3\"))`.\n    bytes32 internal constant CREATE3_PROXY_INITCODE_HASH =\n        0x21c35dbe1b344a2488cf3321d6ce542f8e9f305544ff09e4993a62319a497c1f;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Unable to deploy the storage contract.\n    error DeploymentFailed();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         WRITE LOGIC                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Writes `data` into the bytecode of a storage contract and returns its address.\n    function write(bytes memory data) internal returns (address pointer) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(data) // Let `l` be `n + 1`. +1 as we prefix a STOP opcode.\n            /**\n             * ---------------------------------------------------+\n             * Opcode | Mnemonic       | Stack     | Memory       |\n             * ---------------------------------------------------|\n             * 61 l   | PUSH2 l        | l         |              |\n             * 80     | DUP1           | l l       |              |\n             * 60 0xa | PUSH1 0xa      | 0xa l l   |              |\n             * 3D     | RETURNDATASIZE | 0 0xa l l |              |\n             * 39     | CODECOPY       | l         | [0..l): code |\n             * 3D     | RETURNDATASIZE | 0 l       | [0..l): code |\n             * F3     | RETURN         |           | [0..l): code |\n             * 00     | STOP           |           |              |\n             * ---------------------------------------------------+\n             * @dev Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n             * Also PUSH2 is used since max contract size cap is 24,576 bytes which is less than 2 ** 16.\n             */\n            // Do a out-of-gas revert if `n + 1` is more than 2 bytes.\n            mstore(add(data, gt(n, 0xfffe)), add(0xfe61000180600a3d393df300, shl(0x40, n)))\n            // Deploy a new contract with the generated creation code.\n            pointer := create(0, add(data, 0x15), add(n, 0xb))\n            if iszero(pointer) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(data, n) // Restore the length of `data`.\n        }\n    }\n\n    /// @dev Writes `data` into the bytecode of a storage contract with `salt`\n    /// and returns its normal CREATE2 deterministic address.\n    function writeCounterfactual(bytes memory data, bytes32 salt)\n        internal\n        returns (address pointer)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(data)\n            // Do a out-of-gas revert if `n + 1` is more than 2 bytes.\n            mstore(add(data, gt(n, 0xfffe)), add(0xfe61000180600a3d393df300, shl(0x40, n)))\n            // Deploy a new contract with the generated creation code.\n            pointer := create2(0, add(data, 0x15), add(n, 0xb), salt)\n            if iszero(pointer) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(data, n) // Restore the length of `data`.\n        }\n    }\n\n    /// @dev Writes `data` into the bytecode of a storage contract and returns its address.\n    /// This uses the so-called \"CREATE3\" workflow,\n    /// which means that `pointer` is agnostic to `data, and only depends on `salt`.\n    function writeDeterministic(bytes memory data, bytes32 salt)\n        internal\n        returns (address pointer)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(data)\n            mstore(0x00, _CREATE3_PROXY_INITCODE) // Store the `_PROXY_INITCODE`.\n            let proxy := create2(0, 0x10, 0x10, salt)\n            if iszero(proxy) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x14, proxy) // Store the proxy's address.\n            // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01).\n            // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex).\n            mstore(0x00, 0xd694)\n            mstore8(0x34, 0x01) // Nonce of the proxy contract (1).\n            pointer := keccak256(0x1e, 0x17)\n\n            // Do a out-of-gas revert if `n + 1` is more than 2 bytes.\n            mstore(add(data, gt(n, 0xfffe)), add(0xfe61000180600a3d393df300, shl(0x40, n)))\n            if iszero(\n                mul( // The arguments of `mul` are evaluated last to first.\n                    extcodesize(pointer),\n                    call(gas(), proxy, 0, add(data, 0x15), add(n, 0xb), codesize(), 0x00)\n                )\n            ) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(data, n) // Restore the length of `data`.\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                    ADDRESS CALCULATIONS                    */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the initialization code hash of the storage contract for `data`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHash(bytes memory data) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(data)\n            // Do a out-of-gas revert if `n + 1` is more than 2 bytes.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xfffe))\n            mstore(data, add(0x61000180600a3d393df300, shl(0x40, n)))\n            hash := keccak256(add(data, 0x15), add(n, 0xb))\n            mstore(data, n) // Restore the length of `data`.\n        }\n    }\n\n    /// @dev Equivalent to `predictCounterfactualAddress(data, salt, address(this))`\n    function predictCounterfactualAddress(bytes memory data, bytes32 salt)\n        internal\n        view\n        returns (address pointer)\n    {\n        pointer = predictCounterfactualAddress(data, salt, address(this));\n    }\n\n    /// @dev Returns the CREATE2 address of the storage contract for `data`\n    /// deployed with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictCounterfactualAddress(bytes memory data, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        bytes32 hash = initCodeHash(data);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, hash)\n            mstore(0x01, shl(96, deployer))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x35, 0)\n        }\n    }\n\n    /// @dev Equivalent to `predictDeterministicAddress(salt, address(this))`.\n    function predictDeterministicAddress(bytes32 salt) internal view returns (address pointer) {\n        pointer = predictDeterministicAddress(salt, address(this));\n    }\n\n    /// @dev Returns the \"CREATE3\" deterministic address for `salt` with `deployer`.\n    function predictDeterministicAddress(bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address pointer)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, deployer) // Store `deployer`.\n            mstore8(0x0b, 0xff) // Store the prefix.\n            mstore(0x20, salt) // Store the salt.\n            mstore(0x40, CREATE3_PROXY_INITCODE_HASH) // Store the bytecode hash.\n\n            mstore(0x14, keccak256(0x0b, 0x55)) // Store the proxy's address.\n            mstore(0x40, m) // Restore the free memory pointer.\n            // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01).\n            // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex).\n            mstore(0x00, 0xd694)\n            mstore8(0x34, 0x01) // Nonce of the proxy contract (1).\n            pointer := keccak256(0x1e, 0x17)\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         READ LOGIC                         */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Equivalent to `read(pointer, 0, 2 ** 256 - 1)`.\n    function read(address pointer) internal view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            data := mload(0x40)\n            let n := and(0xffffffffff, sub(extcodesize(pointer), 0x01))\n            extcodecopy(pointer, add(data, 0x1f), 0x00, add(n, 0x21))\n            mstore(data, n) // Store the length.\n            mstore(0x40, add(n, add(data, 0x40))) // Allocate memory.\n        }\n    }\n\n    /// @dev Equivalent to `read(pointer, start, 2 ** 256 - 1)`.\n    function read(address pointer, uint256 start) internal view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            data := mload(0x40)\n            let n := and(0xffffffffff, sub(extcodesize(pointer), 0x01))\n            let l := sub(n, and(0xffffff, mul(lt(start, n), start)))\n            extcodecopy(pointer, add(data, 0x1f), start, add(l, 0x21))\n            mstore(data, mul(sub(n, start), lt(start, n))) // Store the length.\n            mstore(0x40, add(data, add(0x40, mload(data)))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns a slice of the data on `pointer` from `start` to `end`.\n    /// `start` and `end` will be clamped to the range `[0, args.length]`.\n    /// The `pointer` MUST be deployed via the SSTORE2 write functions.\n    /// Otherwise, the behavior is undefined.\n    /// Out-of-gas reverts if `pointer` does not have any code.\n    function read(address pointer, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory data)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            data := mload(0x40)\n            if iszero(lt(end, 0xffff)) { end := 0xffff }\n            let d := mul(sub(end, start), lt(start, end))\n            extcodecopy(pointer, add(data, 0x1f), start, add(d, 0x01))\n            if iszero(and(0xff, mload(add(data, d)))) {\n                let n := sub(extcodesize(pointer), 0x01)\n                returndatacopy(returndatasize(), returndatasize(), shr(40, n))\n                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))\n            }\n            mstore(data, d) // Store the length.\n            mstore(add(add(data, 0x20), d), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(data, 0x40), d)) // Allocate memory.\n        }\n    }\n}\n"}, "src/types/LDFType.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nenum LDFType {\n    STATIC, // LDF does not change ever\n    DYNAMIC_NOT_STATEFUL, // LDF can change, does not use ldfState\n    DYNAMIC_AND_STATEFUL // LDF can change, uses ldfState\n\n}\n"}, "src/base/Errors.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\npragma abicoder v2;\n\nerror BunniHub__Paused();\nerror BunniHub__ZeroInput();\nerror BunniHub__PastDeadline();\nerror BunniHub__Unauthorized();\nerror BunniHub__InvalidReferrer();\nerror BunniHub__LDFCannotBeZero();\nerror BunniHub__MaxNonceReached();\nerror BunniHub__SlippageTooHigh();\nerror BunniHub__WithdrawalPaused();\nerror BunniHub__HookCannotBeZero();\nerror BunniHub__ZeroSharesMinted();\nerror BunniHub__InvalidLDFParams();\nerror BunniHub__InvalidHookParams();\nerror BunniHub__VaultFeeIncorrect();\nerror BunniHub__VaultAssetMismatch();\nerror BunniHub__GracePeriodExpired();\nerror BunniHub__NoExpiredWithdrawal();\nerror BunniHub__MsgValueInsufficient();\nerror BunniHub__DepositAmountTooSmall();\nerror BunniHub__QueuedWithdrawalNotReady();\nerror BunniHub__BunniTokenNotInitialized();\nerror BunniHub__NeedToUseQueuedWithdrawal();\nerror BunniHub__InvalidRawTokenRatioBounds();\nerror BunniHub__QueuedWithdrawalNonexistent();\nerror BunniHub__MsgValueNotZeroWhenPoolKeyHasNoNativeToken();\n\nerror BunniToken__NotBunniHub();\nerror BunniToken__NotPoolManager();\nerror BunniToken__ReferrerAddressIsZero();\n\nerror BunniHook__InvalidSwap();\nerror BunniHook__Unauthorized();\nerror BunniHook__InvalidModifier();\nerror BunniHook__InsufficientOutput();\nerror BunniHook__InvalidRebalanceOrderHash();\nerror BunniHook__PrehookPostConditionFailed();\nerror BunniHook__RequestedOutputExceedsBalance();\n\nerror BunniSwapMath__SwapFailed();\n"}, "src/interfaces/IHooklet.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\nimport {IPoolManager, PoolKey} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\n\nimport {IBunniHub} from \"./IBunniHub.sol\";\nimport {IBunniToken} from \"./IBunniToken.sol\";\n\n/// @title Hooklet\n/// @notice Hooklets let developers execute custom logic before/after Bunni operations.\n/// Each Bunni pool can have one hooklet attached to it. The least significant bits of the hooklet's\n/// address is used to flag which hooklet functions should be callled.\ninterface IHooklet {\n    /// @notice Return data of an initialize operation.\n    /// @member bunniToken The BunniToken deployed.\n    /// @member key The Uniswap v4 pool's key.\n    struct InitializeReturnData {\n        IBunniToken bunniToken;\n        PoolKey key;\n    }\n\n    /// @notice Return data of a deposit operation.\n    /// @member shares The amount of shares minted.\n    /// @member amount0 The amount of token0 deposited.\n    /// @member amount1 The amount of token1 deposited.\n    struct DepositReturnData {\n        uint256 shares;\n        uint256 amount0;\n        uint256 amount1;\n    }\n\n    /// @notice Return data of a withdraw operation.\n    /// @member amount0 The amount of token0 withdrawn.\n    /// @member amount1 The amount of token1 withdrawn.\n    struct WithdrawReturnData {\n        uint256 amount0;\n        uint256 amount1;\n    }\n\n    /// @notice Return data of a swap operation.\n    /// @member updatedSqrtPriceX96 The pool's updated sqrt price after the swap.\n    /// @member updatedTick The pool's updated tick after the swap.\n    /// @member inputAmount The amount of input tokens swapped.\n    /// @member outputAmount The amount of output tokens received.\n    /// @member swapFee The swap fee used for the swap. 6 decimals.\n    /// @member totalLiquidity The pool's total liquidity after the swap.\n    struct SwapReturnData {\n        uint160 updatedSqrtPriceX96;\n        int24 updatedTick;\n        uint256 inputAmount;\n        uint256 outputAmount;\n        uint24 swapFee;\n        uint256 totalLiquidity;\n    }\n\n    /// @notice Overrides the swap fee of a pool before the swap is executed.\n    /// Ignored if the pool has an am-AMM manager.\n    /// @member overridden If true, the swap fee is overridden.\n    /// @member fee The swap fee to use for the swap. 6 decimals.\n    struct BeforeSwapFeeOverride {\n        bool overridden;\n        uint24 fee;\n    }\n\n    /// @notice Overrides the pool's spot price before the swap is executed.\n    /// @member overridden If true, the pool's spot price is overridden.\n    /// @member sqrtPriceX96 The spot price to use for the swap. Q96 value.\n    struct BeforeSwapPriceOverride {\n        bool overridden;\n        uint160 sqrtPriceX96;\n    }\n\n    /// @notice Called before a BunniToken transfer operation.\n    /// @param sender The address that initiated the transfer.\n    /// @param key The Uniswap v4 pool's key.\n    /// @param bunniToken The BunniToken being transferred.\n    /// @param from The address that is sending the tokens.\n    /// @param to The address that is receiving the tokens.\n    /// @param amount The amount of tokens being transferred.\n    /// @return selector IHooklet.beforeTransfer.selector if the call was successful.\n    function beforeTransfer(\n        address sender,\n        PoolKey calldata key,\n        IBunniToken bunniToken,\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bytes4 selector);\n\n    /// @notice Called after a BunniToken transfer operation.\n    /// @param sender The address that initiated the transfer.\n    /// @param key The Uniswap v4 pool's key.\n    /// @param bunniToken The BunniToken being transferred.\n    /// @param from The address that is sending the tokens.\n    /// @param to The address that is receiving the tokens.\n    /// @param amount The amount of tokens being transferred.\n    /// @return selector IHooklet.afterTransfer.selector if the call was successful.\n    function afterTransfer(\n        address sender,\n        PoolKey calldata key,\n        IBunniToken bunniToken,\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bytes4 selector);\n\n    /// @notice Called before a pool is initialized.\n    /// @param sender The address of the account that initiated the initialization.\n    /// @param params The initialization's input parameters.\n    /// @return selector IHooklet.beforeInitialize.selector if the call was successful.\n    function beforeInitialize(address sender, IBunniHub.DeployBunniTokenParams calldata params)\n        external\n        returns (bytes4 selector);\n\n    /// @notice Called after a pool is initialized.\n    /// @param sender The address of the account that initiated the initialization.\n    /// @param params The initialization's input parameters.\n    /// @param returnData The initialization operation's return data.\n    /// @return selector IHooklet.afterInitialize.selector if the call was successful.\n    function afterInitialize(\n        address sender,\n        IBunniHub.DeployBunniTokenParams calldata params,\n        InitializeReturnData calldata returnData\n    ) external returns (bytes4 selector);\n\n    /// @notice Called before a deposit operation.\n    /// @param sender The address of the account that initiated the deposit.\n    /// @param params The deposit's input parameters.\n    /// @return selector IHooklet.beforeDeposit.selector if the call was successful.\n    function beforeDeposit(address sender, IBunniHub.DepositParams calldata params)\n        external\n        returns (bytes4 selector);\n\n    /// @notice View version of beforeDeposit(), used when computing deposit quotes like in BunniQuoter.\n    /// Should always have the same behavior as beforeDeposit().\n    /// @param sender The address of the account that initiated the deposit.\n    /// @param params The deposit's input parameters.\n    /// @return selector IHooklet.beforeDeposit.selector if the call was successful.\n    function beforeDepositView(address sender, IBunniHub.DepositParams calldata params)\n        external\n        view\n        returns (bytes4 selector);\n\n    /// @notice Called after a deposit operation.\n    /// @param sender The address of the account that initiated the deposit.\n    /// @param params The deposit's input parameters.\n    /// @param returnData The deposit operation's return data.\n    /// @return selector IHooklet.afterDeposit.selector if the call was successful.\n    function afterDeposit(\n        address sender,\n        IBunniHub.DepositParams calldata params,\n        DepositReturnData calldata returnData\n    ) external returns (bytes4 selector);\n\n    /// @notice View version of afterDeposit(), used when computing deposit quotes like in BunniQuoter.\n    /// Should always have the same behavior as afterDeposit().\n    /// @param sender The address of the account that initiated the deposit.\n    /// @param params The deposit's input parameters.\n    /// @param returnData The deposit operation's return data.\n    /// @return selector IHooklet.afterDeposit.selector if the call was successful.\n    function afterDepositView(\n        address sender,\n        IBunniHub.DepositParams calldata params,\n        DepositReturnData calldata returnData\n    ) external view returns (bytes4 selector);\n\n    /// @notice Called before a withdraw operation.\n    /// @param sender The address of the account that initiated the withdraw.\n    /// @param params The withdraw's input parameters.\n    /// @return selector IHooklet.beforeWithdraw.selector if the call was successful.\n    function beforeWithdraw(address sender, IBunniHub.WithdrawParams calldata params)\n        external\n        returns (bytes4 selector);\n\n    /// @notice View version of beforeWithdraw(), used when computing withdraw quotes like in BunniQuoter.\n    /// Should always have the same behavior as beforeWithdraw().\n    /// @param sender The address of the account that initiated the withdraw.\n    /// @param params The withdraw's input parameters.\n    /// @return selector IHooklet.beforeWithdraw.selector if the call was successful.\n    function beforeWithdrawView(address sender, IBunniHub.WithdrawParams calldata params)\n        external\n        view\n        returns (bytes4 selector);\n\n    /// @notice Called after a withdraw operation.\n    /// @param sender The address of the account that initiated the withdraw.\n    /// @param params The withdraw's input parameters.\n    /// @param returnData The withdraw operation's return data.\n    /// @return selector IHooklet.afterWithdraw.selector if the call was successful.\n    function afterWithdraw(\n        address sender,\n        IBunniHub.WithdrawParams calldata params,\n        WithdrawReturnData calldata returnData\n    ) external returns (bytes4 selector);\n\n    /// @notice View version of afterWithdraw(), used when computing withdraw quotes like in BunniQuoter.\n    /// Should always have the same behavior as afterWithdraw().\n    /// @param sender The address of the account that initiated the withdraw.\n    /// @param params The withdraw's input parameters.\n    /// @param returnData The withdraw operation's return data.\n    /// @return selector IHooklet.afterWithdraw.selector if the call was successful.\n    function afterWithdrawView(\n        address sender,\n        IBunniHub.WithdrawParams calldata params,\n        WithdrawReturnData calldata returnData\n    ) external view returns (bytes4 selector);\n\n    /// @notice Called before a swap operation. Allows the hooklet to override the swap fee & price\n    /// of the pool before the swap is executed.\n    /// @param sender The address of the account that initiated the swap.\n    /// @param key The Uniswap v4 pool's key.\n    /// @param params The swap's input parameters.\n    /// @return selector IHooklet.beforeSwap.selector if the call was successful.\n    /// @return feeOverriden If true, the swap fee is overridden. If the pool has an am-AMM manager\n    /// then the fee override is ignored.\n    /// @return fee The swap fee to use for the swap. 6 decimals.\n    /// @return priceOverridden If true, the pool's spot price is overridden.\n    /// @return sqrtPriceX96 The spot price to use for the swap. Q96 value.\n    function beforeSwap(address sender, PoolKey calldata key, IPoolManager.SwapParams calldata params)\n        external\n        returns (bytes4 selector, bool feeOverriden, uint24 fee, bool priceOverridden, uint160 sqrtPriceX96);\n\n    /// @notice View version of beforeSwap(), used when computing swap quotes like in BunniQuoter.\n    /// Should always return the same values as beforeSwap().\n    /// @param sender The address of the account that initiated the swap.\n    /// @param key The Uniswap v4 pool's key.\n    /// @param params The swap's input parameters.\n    /// @return selector IHooklet.beforeSwap.selector if the call was successful.\n    /// @return feeOverriden If true, the swap fee is overridden. If the pool has an am-AMM manager\n    /// then the fee override is ignored.\n    /// @return fee The swap fee to use for the swap. 6 decimals.\n    /// @return priceOverridden If true, the pool's spot price is overridden.\n    /// @return sqrtPriceX96 The spot price to use for the swap. Q96 value.\n    function beforeSwapView(address sender, PoolKey calldata key, IPoolManager.SwapParams calldata params)\n        external\n        view\n        returns (bytes4 selector, bool feeOverriden, uint24 fee, bool priceOverridden, uint160 sqrtPriceX96);\n\n    /// @notice Called after a swap operation.\n    /// @param sender The address of the account that initiated the swap.\n    /// @param key The Uniswap v4 pool's key.\n    /// @param params The swap's input parameters.\n    /// @param returnData The swap operation's return data.\n    function afterSwap(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        SwapReturnData calldata returnData\n    ) external returns (bytes4 selector);\n\n    /// @notice View version of afterSwap(), used when computing swap quotes like in BunniQuoter.\n    /// Should always have the same behavior as afterSwap().\n    /// @param sender The address of the account that initiated the swap.\n    /// @param key The Uniswap v4 pool's key.\n    /// @param params The swap's input parameters.\n    /// @param returnData The swap operation's return data.\n    /// @return selector IHooklet.afterSwap.selector if the call was successful.\n    function afterSwapView(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        SwapReturnData calldata returnData\n    ) external view returns (bytes4 selector);\n}\n"}, "src/interfaces/IBunniToken.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\nimport \"@uniswap/v4-core/src/types/Currency.sol\";\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\nimport {IUnlockCallback} from \"@uniswap/v4-core/src/interfaces/callback/IUnlockCallback.sol\";\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IOwnable} from \"./IOwnable.sol\";\nimport {IHooklet} from \"./IHooklet.sol\";\nimport {IBunniHub} from \"./IBunniHub.sol\";\nimport {IERC20Referrer} from \"./IERC20Referrer.sol\";\nimport {IERC20Lockable} from \"./IERC20Lockable.sol\";\n\n/// @title BunniToken\n/// @author zefram.eth\n/// @notice ERC20 token that represents a user's LP position\ninterface IBunniToken is IERC20, IERC20Referrer, IERC20Lockable, IOwnable, IUnlockCallback {\n    event ClaimReferralRewards(address indexed referrer, uint256 reward0, uint256 reward1);\n\n    event SetMetadataURI(string newURI);\n\n    function hub() external view returns (IBunniHub);\n\n    function token0() external view returns (Currency);\n\n    function token1() external view returns (Currency);\n\n    function poolManager() external view returns (IPoolManager);\n\n    function poolKey() external view returns (PoolKey memory);\n\n    function hooklet() external view returns (IHooklet);\n\n    function mint(address to, uint256 amount) external;\n\n    function mint(address to, uint256 amount, address referrer) external;\n\n    function burn(address from, uint256 amount) external;\n\n    function burn(uint256 amount) external;\n\n    function initialize(address owner_, string calldata metadataURI_) external;\n\n    function metadataURI() external view returns (string memory);\n\n    function setMetadataURI(string calldata metadataURI_) external;\n\n    /// @notice Distributes referral rewards to all referrers. Usually called by the hook but can be called by anyone.\n    /// The referral rewards should be in the form of PoolManager ERC6909 claim tokens.\n    /// @dev Does not early return if the reward amount is 0, so the caller is responsible for not calling this function\n    /// if amount is indeed 0.\n    /// @param isToken0 Whether the rewards are in token0 or token1\n    /// @param amount The amount of rewards to distribute.\n    function distributeReferralRewards(bool isToken0, uint256 amount) external;\n\n    /// @notice Claims referral rewards for a given referrer ID. Can be called by anyone.\n    /// @param referrer The referrer to claim rewards for\n    /// @return reward0 The amount of token0 rewards claimed\n    /// @return reward1 The amount of token1 rewards claimed\n    function claimReferralRewards(address referrer) external returns (uint256 reward0, uint256 reward1);\n\n    /// @notice Returns the amount of referral rewards claimable by a given referrer ID.\n    /// @param referrer The referrer to check rewards for\n    /// @return reward0 The amount of token0 rewards claimable\n    /// @return reward1 The amount of token1 rewards claimable\n    function getClaimableReferralRewards(address referrer) external view returns (uint256 reward0, uint256 reward1);\n\n    /// @notice Increments the EIP-2612 permit nonce of the caller to invalidate permit signatures.\n    function incrementNonce() external;\n}\n"}, "src/interfaces/ILiquidityDensityFunction.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\npragma abicoder v2;\n\nimport {PoolKey} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\n\n/// @title ILiquidityDensityFunction\n/// @author zefram.eth\n/// @notice Interface for liquidity density functions (LDFs) that dictate how liquidity is distributed over a pool's rounded ticks (each with `tickSpacing` ticks).\n/// Each rounded tick is identified by its leftmost tick, which is a multiple of `tickSpacing`. The liquidity density of all rounded ticks should add up to 1, similar to probability density functions (PDFs).\n/// Also contains functions for efficiently computing the cumulative amount of tokens in a consecutive range of rounded ticks, as well as their inverse functions. These are essential for computing swaps.\n/// Enables arbitrary liquidity shapes, shifting liquidity across ticks, and switching from one liquidity shape to another.\ninterface ILiquidityDensityFunction {\n    /// @notice Queries the liquidity density function for the given pool and rounded tick.\n    /// Returns the density of the rounded tick, cumulative token densities at adjacent ticks, and state relevant info.\n    /// @param key The key of the Uniswap v4 pool\n    /// @param roundedTick The rounded tick to query\n    /// @param twapTick The TWAP tick. Is 0 if `twapSecondsAgo` is 0. It's up to `isValidParams` to ensure `twapSecondsAgo != 0` if the LDF uses the TWAP.\n    /// @param spotPriceTick The spot price tick.\n    /// @param ldfParams The parameters for the liquidity density function\n    /// @param ldfState The current state of the liquidity density function\n    /// @return liquidityDensityX96 The density of the rounded tick, scaled by Q96\n    /// @return cumulativeAmount0DensityX96 The cumulative token0 density in rounded ticks [roundedTick + tickSpacing, maxUsableTick], scaled by Q96\n    /// @return cumulativeAmount1DensityX96 The cumulative token1 density in rounded ticks [minUsableTick, roundedTick - tickSpacing], scaled by Q96\n    /// @return newLdfState The new state of the liquidity density function\n    /// @return shouldSurge Whether the pool should surge. Usually corresponds to whether the LDF has shifted / changed shape.\n    function query(\n        PoolKey calldata key,\n        int24 roundedTick,\n        int24 twapTick,\n        int24 spotPriceTick,\n        bytes32 ldfParams,\n        bytes32 ldfState\n    )\n        external\n        view\n        returns (\n            uint256 liquidityDensityX96,\n            uint256 cumulativeAmount0DensityX96,\n            uint256 cumulativeAmount1DensityX96,\n            bytes32 newLdfState,\n            bool shouldSurge\n        );\n\n    /// @notice Aggregates LDF queries used during a swap.\n    /// @dev A Bunni swap uses the inverseCumulativeAmount function to compute the rounded tick for which the cumulativeAmount is the closest to `inverseCumulativeAmountInput`\n    /// and <= `inverseCumulativeAmountInput`. This rounded tick is the starting point for swapping the remaining tokens, which is done via Uniswap math (not done in this function though).\n    /// @param key The key of the Uniswap v4 pool\n    /// @param inverseCumulativeAmountInput The input to the inverseCumulativeAmount function\n    /// @param totalLiquidity The total liquidity in the pool\n    /// @param zeroForOne Whether the input token is token0\n    /// @param exactIn Whether it's an exact input swap or an exact output swap\n    /// @param twapTick The TWAP tick. Is 0 if `twapSecondsAgo` is 0. It's up to `isValidParams` to ensure `twapSecondsAgo != 0` if the LDF uses the TWAP.\n    /// @param spotPriceTick The spot price tick.\n    /// @param ldfParams The parameters for the liquidity density function\n    /// @param ldfState The current state of the liquidity density function\n    /// @return success Whether the swap computation was successful\n    /// @return roundedTick The rounded tick to start the remainder swap from\n    /// @return cumulativeAmount0_ The cumulative amount of token0 to the right of the starting tick of the Uniswap swap\n    /// @return cumulativeAmount1_ The cumulative amount of token1 to the left of the starting tick of the Uniswap swap\n    /// @return swapLiquidity The liquidity used for the remainder swap\n    function computeSwap(\n        PoolKey calldata key,\n        uint256 inverseCumulativeAmountInput,\n        uint256 totalLiquidity,\n        bool zeroForOne,\n        bool exactIn,\n        int24 twapTick,\n        int24 spotPriceTick,\n        bytes32 ldfParams,\n        bytes32 ldfState\n    )\n        external\n        view\n        returns (\n            bool success,\n            int24 roundedTick,\n            uint256 cumulativeAmount0_,\n            uint256 cumulativeAmount1_,\n            uint256 swapLiquidity\n        );\n\n    /// @notice Computes the cumulative amount of token0 in the rounded ticks [roundedTick, maxUsableTick].\n    /// @param key The key of the Uniswap v4 pool\n    /// @param roundedTick The rounded tick to query\n    /// @param totalLiquidity The total liquidity in the pool\n    /// @param twapTick The TWAP tick. Is 0 if `twapSecondsAgo` is 0. It's up to `isValidParams` to ensure `twapSecondsAgo != 0` if the LDF uses the TWAP.\n    /// @param spotPriceTick The spot price tick.\n    /// @param ldfParams The parameters for the liquidity density function\n    /// @param ldfState The current state of the liquidity density function\n    /// @return The cumulative amount of token0 in the rounded ticks [roundedTick, maxUsableTick]\n    function cumulativeAmount0(\n        PoolKey calldata key,\n        int24 roundedTick,\n        uint256 totalLiquidity,\n        int24 twapTick,\n        int24 spotPriceTick,\n        bytes32 ldfParams,\n        bytes32 ldfState\n    ) external view returns (uint256);\n\n    /// @notice Computes the cumulative amount of token1 in the rounded ticks [minUsableTick, roundedTick].\n    /// @param key The key of the Uniswap v4 pool\n    /// @param roundedTick The rounded tick to query\n    /// @param totalLiquidity The total liquidity in the pool\n    /// @param twapTick The TWAP tick. Is 0 if `twapSecondsAgo` is 0. It's up to `isValidParams` to ensure `twapSecondsAgo != 0` if the LDF uses the TWAP.\n    /// @param spotPriceTick The spot price tick.\n    /// @param ldfParams The parameters for the liquidity density function\n    /// @param ldfState The current state of the liquidity density function\n    /// @return The cumulative amount of token1 in the rounded ticks [minUsableTick, roundedTick]\n    function cumulativeAmount1(\n        PoolKey calldata key,\n        int24 roundedTick,\n        uint256 totalLiquidity,\n        int24 twapTick,\n        int24 spotPriceTick,\n        bytes32 ldfParams,\n        bytes32 ldfState\n    ) external view returns (uint256);\n\n    /// @notice Checks if the given LDF parameters are valid.\n    /// @param key The key of the Uniswap v4 pool\n    /// @param twapSecondsAgo The time window for the TWAP\n    /// @param ldfParams The parameters for the liquidity density function\n    /// @return Whether the parameters are valid\n    function isValidParams(PoolKey calldata key, uint24 twapSecondsAgo, bytes32 ldfParams)\n        external\n        view\n        returns (bool);\n}\n"}, "src/lib/Math.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {TickMath} from \"@uniswap/v4-core/src/libraries/TickMath.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport \"../base/Constants.sol\";\n\nusing FixedPointMathLib for int256;\nusing FixedPointMathLib for uint256;\n\n/// @dev modified from solady\nfunction dist(uint256 x, uint256 y) pure returns (uint256 z) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        z := xor(mul(xor(sub(y, x), sub(x, y)), gt(x, y)), sub(y, x))\n    }\n}\n\n/// @dev modified from solady\nfunction absDiff(uint256 x, uint256 y) pure returns (bool positive, uint256 diff) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        positive := gt(x, y)\n        diff := xor(mul(xor(sub(y, x), sub(x, y)), gt(x, y)), sub(y, x))\n    }\n}\n\nfunction roundTick(int24 currentTick, int24 tickSpacing) pure returns (int24 roundedTick, int24 nextRoundedTick) {\n    int24 compressed = currentTick / tickSpacing;\n    if (currentTick < 0 && currentTick % tickSpacing != 0) compressed--; // round towards negative infinity\n    roundedTick = compressed * tickSpacing;\n    nextRoundedTick = roundedTick + tickSpacing;\n}\n\nfunction roundTickSingle(int24 currentTick, int24 tickSpacing) pure returns (int24 roundedTick) {\n    int24 compressed = currentTick / tickSpacing;\n    if (currentTick < 0 && currentTick % tickSpacing != 0) compressed--; // round towards negative infinity\n    roundedTick = compressed * tickSpacing;\n}\n\nfunction boundTick(int24 tick, int24 tickSpacing) pure returns (int24 boundedTick) {\n    (int24 minTick, int24 maxTick) = (TickMath.minUsableTick(tickSpacing), TickMath.maxUsableTick(tickSpacing));\n    return int24(FixedPointMathLib.clamp(tick, minTick, maxTick));\n}\n\nfunction weightedSum(uint256 value0, uint256 weight0, uint256 value1, uint256 weight1) pure returns (uint256) {\n    return (value0 * weight0 + value1 * weight1) / (weight0 + weight1);\n}\n\n/// @dev Converts xWad, the decimal index of a rounded tick scaled by WAD, to the corresponding rounded tick.\nfunction xWadToRoundedTick(int256 xWad, int24 mu, int24 tickSpacing, bool roundUp) pure returns (int24) {\n    int24 x = SafeCastLib.toInt24(xWad / int256(WAD));\n    if (roundUp) {\n        if (xWad > 0 && xWad % int256(WAD) != 0) x++; // round towards positive infinity\n    } else {\n        if (xWad < 0 && xWad % int256(WAD) != 0) x--; // round towards negative infinity\n    }\n    return x * tickSpacing + mu;\n}\n\nfunction percentDelta(uint256 a, uint256 b) pure returns (uint256) {\n    uint256 absDelta = dist(a, b);\n    return FixedPointMathLib.divWad(absDelta, b);\n}\n\n/// @dev Returns ReLU(x - y) = max(x - y, 0)\nfunction subReLU(uint256 x, uint256 y) pure returns (uint256) {\n    unchecked {\n        return x > y ? x - y : 0;\n    }\n}\n\nfunction divQ96RoundUp(uint256 value) pure returns (uint256) {\n    return (value + ((1 << 96) - 1)) >> 96;\n}\n\nfunction roundUpFullMulDivResult(uint256 x, uint256 y, uint256 d, uint256 resultRoundedDown)\n    pure\n    returns (uint256 result)\n{\n    result = resultRoundedDown;\n    /// @solidity memory-safe-assembly\n    assembly {\n        if mulmod(x, y, d) {\n            result := add(resultRoundedDown, 1)\n            if iszero(result) {\n                mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"}, "src/base/Constants.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\npragma abicoder v2;\n\nuint256 constant WAD = 1e18;\nuint256 constant Q96 = 0x1000000000000000000000000;\nuint256 constant MAX_NONCE = 1e6;\nuint256 constant MIN_INITIAL_SHARES = 1e12;\nuint256 constant MAX_SWAP_FEE_RATIO = 2.88e20; // max ratio that avoids overflow in swap fee calculation, roughly sqrt(SWAP_FEE_BASE) * sqrt(sqrt((type(uint256).max - SWAP_FEE_BASE) / type(uint24).max) - 1)\nuint256 constant SWAP_FEE_BASE = 1e6;\nuint256 constant SWAP_FEE_BASE_SQUARED = 1e12;\nuint256 constant RAW_TOKEN_RATIO_BASE = 1e6;\nuint256 constant LN2_WAD = 693147180559945309;\nuint256 constant MAX_VAULT_FEE_ERROR = 1e6;\nuint256 constant MAX_CARDINALITY = 2 ** 24 - 1;\nuint56 constant WITHDRAW_DELAY = 1 minutes;\nuint56 constant WITHDRAW_GRACE_PERIOD = 3 minutes;\nuint256 constant REFERRAL_REWARD_PER_TOKEN_PRECISION = 1e30;\nuint256 constant MODIFIER_BASE = 1e6;\nuint256 constant MIN_DEPOSIT_BALANCE_INCREASE = 1e6;\nuint24 constant MAX_AMAMM_FEE = 0.1e6;\nuint256 constant REBALANCE_MAX_SLIPPAGE_BASE = 1e5;\nuint16 constant MAX_SURGE_HALFLIFE = 1 hours;\nuint16 constant MAX_SURGE_AUTOSTART_TIME = 1 hours;\nuint16 constant MAX_REBALANCE_MAX_SLIPPAGE = 0.25e5; // max value for rebalanceMaxSlippage is 25%\nuint16 constant MAX_REBALANCE_TWAP_SECONDS_AGO = 3 hours;\nuint16 constant MAX_REBALANCE_ORDER_TTL = 1 hours;\n"}, "src/interfaces/IBunniHook.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\nimport {PoolId} from \"@uniswap/v4-core/src/types/PoolId.sol\";\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\nimport {Currency} from \"@uniswap/v4-core/src/types/Currency.sol\";\nimport {IHooks} from \"@uniswap/v4-core/src/interfaces/IHooks.sol\";\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\nimport {IUnlockCallback} from \"@uniswap/v4-core/src/interfaces/callback/IUnlockCallback.sol\";\n\nimport {IAmAmm} from \"biddog/interfaces/IAmAmm.sol\";\n\nimport \"flood-contracts/src/interfaces/IZone.sol\";\nimport \"flood-contracts/src/interfaces/IFloodPlain.sol\";\n\nimport {IERC1271} from \"permit2/src/interfaces/IERC1271.sol\";\n\nimport \"../base/Constants.sol\";\nimport \"../base/SharedStructs.sol\";\nimport {IOwnable} from \"./IOwnable.sol\";\nimport {Oracle} from \"../lib/Oracle.sol\";\nimport {IBunniHub} from \"./IBunniHub.sol\";\nimport {IBaseHook} from \"./IBaseHook.sol\";\n\n/// @title BunniHook\n/// @author zefram.eth\n/// @notice Uniswap v4 hook responsible for handling swaps on Bunni. Implements auto-rebalancing\n/// executed via FloodPlain. Uses am-AMM to recapture LVR & MEV.\ninterface IBunniHook is IBaseHook, IOwnable, IUnlockCallback, IERC1271, IAmAmm {\n    /// -----------------------------------------------------------------------\n    /// Events\n    /// -----------------------------------------------------------------------\n\n    /// @notice Emitted for swaps between currency0 and currency1\n    /// @param id The abi encoded hash of the pool key struct for the pool that was modified\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param zeroForOne True if swapping token0 for token1, false otherwise\n    /// @param inputAmount The input token amount\n    /// @param outputAmount The output token amount\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param tick The log base 1.0001 of the price of the pool after the swap\n    /// @param fee The swap fee rate charged, 6 decimals\n    /// @param totalLiquidity The total virtual liquidity of the pool during and after the swap\n    event Swap(\n        PoolId indexed id,\n        address indexed sender,\n        bool exactIn,\n        bool zeroForOne,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint160 sqrtPriceX96,\n        int24 tick,\n        uint24 fee,\n        uint256 totalLiquidity\n    );\n    event SetZone(IZone zone);\n    event SetHookFeeRecipient(address hookFeeRecipient);\n    event SetModifiers(uint32 indexed hookFeeModifier, uint32 indexed referrerRewardModifier);\n    event ClaimProtocolFees(Currency[] currencyList, address indexed recipient);\n\n    /// -----------------------------------------------------------------------\n    /// Structs and enums\n    /// -----------------------------------------------------------------------\n\n    /// @notice The state of a TWAP oracle for a given pool\n    /// @member index The index of the last written observation for the pool\n    /// @member cardinality The cardinality of the observations array for the pool\n    /// @member cardinalityNext The cardinality target of the observations array for the pool, which will replace cardinality when enough observations are written\n    /// @member intermediateObservation Used to maintain a min interval between observations\n    struct ObservationState {\n        uint32 index;\n        uint32 cardinality;\n        uint32 cardinalityNext;\n        Oracle.Observation intermediateObservation;\n    }\n\n    /// @notice The arguments passed to the rebalance order prehook and posthook.\n    /// @dev The hash of the hook args is used for validation in the prehook and posthook.\n    /// @member key The pool key of the pool being rebalanced\n    /// @member preHookArgs The prehook arguments\n    /// @member postHookArgs The posthook arguments\n    struct RebalanceOrderHookArgs {\n        PoolKey key;\n        RebalanceOrderPreHookArgs preHookArgs;\n        RebalanceOrderPostHookArgs postHookArgs;\n    }\n\n    /// @notice The arguments passed to the rebalance order prehook.\n    /// @member currency The currency to take from BunniHub and sell via the rebalance order\n    /// @member amount The amount of currency to take from BunniHub and sell via the rebalance order\n    struct RebalanceOrderPreHookArgs {\n        Currency currency;\n        uint256 amount;\n    }\n\n    /// @notice The arguments passed to the rebalance order posthook.\n    /// @member currency The currency to receive from the rebalance order and give to BunniHub\n    struct RebalanceOrderPostHookArgs {\n        Currency currency;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// View functions\n    /// -----------------------------------------------------------------------\n\n    /// @notice Returns the observation for the given pool key and observation index\n    /// @param key The pool key\n    /// @param index The observation index\n    /// @return observation The observation struct\n    function getObservation(PoolKey calldata key, uint256 index)\n        external\n        view\n        returns (Oracle.Observation memory observation);\n\n    /// @notice Returns the TWAP oracle observation state for the given pool key\n    /// @param key The pool key\n    /// @return state The state struct\n    function getState(PoolKey calldata key) external view returns (ObservationState memory state);\n\n    /// @notice Observe the given pool for the timestamps\n    /// @param key The pool key\n    /// @param secondsAgos The timestamps to observe\n    /// @return tickCumulatives The tick cumulatives for the given timestamps\n    function observe(PoolKey calldata key, uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives);\n\n    /// @notice Validates if the given hook params are valid\n    /// @param hookParams The hook params\n    /// @return isValid True if the hook params are valid\n    function isValidParams(bytes calldata hookParams) external view returns (bool);\n\n    /// @notice The LDF state of a given pool. Used for evaluating the LDF.\n    /// @param id The pool id\n    /// @return The LDF state\n    function ldfStates(PoolId id) external view returns (bytes32);\n\n    /// @notice The slot0 state of a given pool\n    /// @param id The pool id\n    /// @return sqrtPriceX96\n    /// @return tick The tick of the pool\n    /// @return lastSwapTimestamp The timestamp of the last swap\n    /// @return lastSurgeTimestamp The timestamp of the last surge\n    function slot0s(PoolId id)\n        external\n        view\n        returns (uint160 sqrtPriceX96, int24 tick, uint32 lastSwapTimestamp, uint32 lastSurgeTimestamp);\n\n    /// @notice The share prices of the vaults used by the pool at the last swap\n    /// @param id The pool id\n    /// @return initialized True if the share prices have been initialized\n    /// @return sharePrice0 The underlying assets each share of vault0 represents, scaled by 1e18\n    /// @return sharePrice1 The underlying assets each share of vault1 represents, scaled by 1e18\n    function vaultSharePricesAtLastSwap(PoolId id)\n        external\n        view\n        returns (bool initialized, uint120 sharePrice0, uint120 sharePrice1);\n\n    /// @notice Whether am-AMM is enabled for the given pool.\n    function getAmAmmEnabled(PoolId id) external view returns (bool);\n\n    /// @notice Whether liquidity can be withdrawn from the given pool.\n    /// Currently used for pausing withdrawals when there is an active rebalance order.\n    /// @param id The pool id\n    /// @return Whether liquidity can be withdrawn from the given pool.\n    function canWithdraw(PoolId id) external view returns (bool);\n\n    /// @notice Returns the hook protocol fee recipient\n    function getHookFeeRecipient() external view returns (address);\n\n    /// @notice Returns the modifiers for computing hook fee and referral reward\n    function getModifiers() external view returns (uint32 hookFeeModifier_, uint32 referralRewardModifier_);\n\n    /// @notice Returns the claimable hook fees for the given currencies\n    /// @param currencyList The list of currencies to claim fees for\n    /// @return feeAmounts The list of claimable fees for each currency\n    function getClaimableHookFees(Currency[] calldata currencyList)\n        external\n        view\n        returns (uint256[] memory feeAmounts);\n\n    /// -----------------------------------------------------------------------\n    /// External functions\n    /// -----------------------------------------------------------------------\n\n    /// @notice Increase the cardinality target for the given pool\n    /// @param key The pool key\n    /// @param cardinalityNext The new cardinality target\n    /// @return cardinalityNextOld The old cardinality target\n    /// @return cardinalityNextNew The new cardinality target\n    function increaseCardinalityNext(PoolKey calldata key, uint32 cardinalityNext)\n        external\n        returns (uint32 cardinalityNextOld, uint32 cardinalityNextNew);\n\n    /// @notice Claim protocol fees for the given currency list.\n    /// @param currencyList The list of currencies to claim fees for\n    function claimProtocolFees(Currency[] calldata currencyList) external;\n\n    /// -----------------------------------------------------------------------\n    /// BunniHub functions\n    /// -----------------------------------------------------------------------\n\n    /// @notice Update the LDF state of the given pool. Only callable by BunniHub.\n    /// @param id The pool id\n    /// @param newState The new LDF state\n    function updateLdfState(PoolId id, bytes32 newState) external;\n\n    /// -----------------------------------------------------------------------\n    /// Owner functions\n    /// -----------------------------------------------------------------------\n\n    /// @notice Set the FloodZone contract address. Only callable by the owner.\n    /// @param zone The new FloodZone contract address\n    function setZone(IZone zone) external;\n\n    /// @notice Set the hook protocol fee recipient. Only callable by the owner.\n    /// @param newProtocolFeeRecipient The new protocol fee recipient address\n    function setHookFeeRecipient(address newProtocolFeeRecipient) external;\n\n    /// @notice Set the hook fee & referral reward params. Only callable by the owner.\n    /// @param newHookFeeModifier The new hook fee modifier. 6 decimals.\n    /// @param newReferralRewardModifier The new referral reward modifier. 6 decimals.\n    function setModifiers(uint32 newHookFeeModifier, uint32 newReferralRewardModifier) external;\n\n    /// -----------------------------------------------------------------------\n    /// Rebalance functions\n    /// -----------------------------------------------------------------------\n\n    /// @notice Called by the FloodPlain contract prior to executing a rebalance order.\n    /// Should ensure the hook has exactly `hookArgs.preHookArgs.amount` tokens of `hookArgs.preHookArgs.currency` upon return.\n    /// @param hookArgs The rebalance order hook arguments\n    function rebalanceOrderPreHook(RebalanceOrderHookArgs calldata hookArgs) external;\n\n    /// @notice Called by the FloodPlain contract after executing a rebalance order.\n    /// Should transfer any output tokens from the order to BunniHub and update pool balances.\n    /// @param hookArgs The rebalance order hook arguments\n    function rebalanceOrderPostHook(RebalanceOrderHookArgs calldata hookArgs) external;\n}\n"}, "lib/v4-core/src/types/PoolKey.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Currency} from \"./Currency.sol\";\nimport {IHooks} from \"../interfaces/IHooks.sol\";\nimport {PoolIdLibrary} from \"./PoolId.sol\";\n\nusing PoolIdLibrary for PoolKey global;\n\n/// @notice Returns the key for identifying a pool\nstruct PoolKey {\n    /// @notice The lower currency of the pool, sorted numerically\n    Currency currency0;\n    /// @notice The higher currency of the pool, sorted numerically\n    Currency currency1;\n    /// @notice The pool LP fee, capped at 1_000_000. If the highest bit is 1, the pool has a dynamic fee and must be exactly equal to 0x800000\n    uint24 fee;\n    /// @notice Ticks that involve positions must be a multiple of tick spacing\n    int24 tickSpacing;\n    /// @notice The hooks of the pool\n    IHooks hooks;\n}\n"}, "src/lib/LiquidityAmounts.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@uniswap/v4-core/src/libraries/SqrtPriceMath.sol\";\n\n/// @title Liquidity amount functions\n/// @notice Provides functions for computing liquidity amounts from token amounts and prices\nlibrary LiquidityAmounts {\n    /// @notice Downcasts uint256 to uint128\n    /// @param x The uint258 to be downcasted\n    /// @return y The passed value, downcasted to uint128\n    function toUint128(uint256 x) private pure returns (uint128 y) {\n        require((y = uint128(x)) == x);\n    }\n\n    /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\n    /// pool prices and the prices at the tick boundaries\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param liquidity The liquidity being valued\n    /// @return amount0 The amount of token0\n    /// @return amount1 The amount of token1\n    function getAmountsForLiquidity(\n        uint160 sqrtRatioX96,\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity,\n        bool roundingUp\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\n            amount0 = SqrtPriceMath.getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, liquidity, roundingUp);\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\n            amount0 = SqrtPriceMath.getAmount0Delta(sqrtRatioX96, sqrtRatioBX96, liquidity, roundingUp);\n            amount1 = SqrtPriceMath.getAmount1Delta(sqrtRatioAX96, sqrtRatioX96, liquidity, roundingUp);\n        } else {\n            amount1 = SqrtPriceMath.getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, liquidity, roundingUp);\n        }\n    }\n\n    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\n    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param amount0 The amount0 being sent in\n    /// @return liquidity The amount of returned liquidity\n    function getLiquidityForAmount0(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount0)\n        internal\n        pure\n        returns (uint128 liquidity)\n    {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n        uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);\n        return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));\n    }\n\n    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\n    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param amount1 The amount1 being sent in\n    /// @return liquidity The amount of returned liquidity\n    function getLiquidityForAmount1(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint256 amount1)\n        internal\n        pure\n        returns (uint128 liquidity)\n    {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n        return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));\n    }\n}\n"}, "lib/v4-core/src/types/PoolId.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {PoolKey} from \"./PoolKey.sol\";\n\ntype PoolId is bytes32;\n\n/// @notice Library for computing the ID of a pool\nlibrary PoolIdLibrary {\n    /// @notice Returns value equal to keccak256(abi.encode(poolKey))\n    function toId(PoolKey memory poolKey) internal pure returns (PoolId poolId) {\n        assembly (\"memory-safe\") {\n            // 0xa0 represents the total size of the poolKey struct (5 slots of 32 bytes)\n            poolId := keccak256(poolKey, 0xa0)\n        }\n    }\n}\n"}, "lib/v4-core/src/types/BeforeSwapDelta.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n// Return type of the beforeSwap hook.\n// Upper 128 bits is the delta in specified tokens. Lower 128 bits is delta in unspecified tokens (to match the afterSwap hook)\ntype BeforeSwapDelta is int256;\n\n// Creates a BeforeSwapDelta from specified and unspecified\nfunction toBeforeSwapDelta(int128 deltaSpecified, int128 deltaUnspecified)\n    pure\n    returns (BeforeSwapDelta beforeSwapDelta)\n{\n    assembly (\"memory-safe\") {\n        beforeSwapDelta := or(shl(128, deltaSpecified), and(sub(shl(128, 1), 1), deltaUnspecified))\n    }\n}\n\n/// @notice Library for getting the specified and unspecified deltas from the BeforeSwapDelta type\nlibrary BeforeSwapDeltaLibrary {\n    /// @notice A BeforeSwapDelta of 0\n    BeforeSwapDelta public constant ZERO_DELTA = BeforeSwapDelta.wrap(0);\n\n    /// extracts int128 from the upper 128 bits of the BeforeSwapDelta\n    /// returned by beforeSwap\n    function getSpecifiedDelta(BeforeSwapDelta delta) internal pure returns (int128 deltaSpecified) {\n        assembly (\"memory-safe\") {\n            deltaSpecified := sar(128, delta)\n        }\n    }\n\n    /// extracts int128 from the lower 128 bits of the BeforeSwapDelta\n    /// returned by beforeSwap and afterSwap\n    function getUnspecifiedDelta(BeforeSwapDelta delta) internal pure returns (int128 deltaUnspecified) {\n        assembly (\"memory-safe\") {\n            deltaUnspecified := signextend(15, delta)\n        }\n    }\n}\n"}, "lib/v4-core/src/libraries/Hooks.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {IHooks} from \"../interfaces/IHooks.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\nimport {LPFeeLibrary} from \"./LPFeeLibrary.sol\";\nimport {BalanceDelta, toBalanceDelta, BalanceDeltaLibrary} from \"../types/BalanceDelta.sol\";\nimport {BeforeSwapDelta, BeforeSwapDeltaLibrary} from \"../types/BeforeSwapDelta.sol\";\nimport {IPoolManager} from \"../interfaces/IPoolManager.sol\";\nimport {ParseBytes} from \"./ParseBytes.sol\";\nimport {CustomRevert} from \"./CustomRevert.sol\";\n\n/// @notice V4 decides whether to invoke specific hooks by inspecting the least significant bits\n/// of the address that the hooks contract is deployed to.\n/// For example, a hooks contract deployed to address: 0x0000000000000000000000000000000000002400\n/// has the lowest bits '10 0100 0000 0000' which would cause the 'before initialize' and 'after add liquidity' hooks to be used.\nlibrary Hooks {\n    using LPFeeLibrary for uint24;\n    using Hooks for IHooks;\n    using SafeCast for int256;\n    using BeforeSwapDeltaLibrary for BeforeSwapDelta;\n    using ParseBytes for bytes;\n    using CustomRevert for bytes4;\n\n    uint160 internal constant ALL_HOOK_MASK = uint160((1 << 14) - 1);\n\n    uint160 internal constant BEFORE_INITIALIZE_FLAG = 1 << 13;\n    uint160 internal constant AFTER_INITIALIZE_FLAG = 1 << 12;\n\n    uint160 internal constant BEFORE_ADD_LIQUIDITY_FLAG = 1 << 11;\n    uint160 internal constant AFTER_ADD_LIQUIDITY_FLAG = 1 << 10;\n\n    uint160 internal constant BEFORE_REMOVE_LIQUIDITY_FLAG = 1 << 9;\n    uint160 internal constant AFTER_REMOVE_LIQUIDITY_FLAG = 1 << 8;\n\n    uint160 internal constant BEFORE_SWAP_FLAG = 1 << 7;\n    uint160 internal constant AFTER_SWAP_FLAG = 1 << 6;\n\n    uint160 internal constant BEFORE_DONATE_FLAG = 1 << 5;\n    uint160 internal constant AFTER_DONATE_FLAG = 1 << 4;\n\n    uint160 internal constant BEFORE_SWAP_RETURNS_DELTA_FLAG = 1 << 3;\n    uint160 internal constant AFTER_SWAP_RETURNS_DELTA_FLAG = 1 << 2;\n    uint160 internal constant AFTER_ADD_LIQUIDITY_RETURNS_DELTA_FLAG = 1 << 1;\n    uint160 internal constant AFTER_REMOVE_LIQUIDITY_RETURNS_DELTA_FLAG = 1 << 0;\n\n    struct Permissions {\n        bool beforeInitialize;\n        bool afterInitialize;\n        bool beforeAddLiquidity;\n        bool afterAddLiquidity;\n        bool beforeRemoveLiquidity;\n        bool afterRemoveLiquidity;\n        bool beforeSwap;\n        bool afterSwap;\n        bool beforeDonate;\n        bool afterDonate;\n        bool beforeSwapReturnDelta;\n        bool afterSwapReturnDelta;\n        bool afterAddLiquidityReturnDelta;\n        bool afterRemoveLiquidityReturnDelta;\n    }\n\n    /// @notice Thrown if the address will not lead to the specified hook calls being called\n    /// @param hooks The address of the hooks contract\n    error HookAddressNotValid(address hooks);\n\n    /// @notice Hook did not return its selector\n    error InvalidHookResponse();\n\n    /// @notice Additional context for ERC-7751 wrapped error when a hook call fails\n    error HookCallFailed();\n\n    /// @notice The hook's delta changed the swap from exactIn to exactOut or vice versa\n    error HookDeltaExceedsSwapAmount();\n\n    /// @notice Utility function intended to be used in hook constructors to ensure\n    /// the deployed hooks address causes the intended hooks to be called\n    /// @param permissions The hooks that are intended to be called\n    /// @dev permissions param is memory as the function will be called from constructors\n    function validateHookPermissions(IHooks self, Permissions memory permissions) internal pure {\n        if (\n            permissions.beforeInitialize != self.hasPermission(BEFORE_INITIALIZE_FLAG)\n                || permissions.afterInitialize != self.hasPermission(AFTER_INITIALIZE_FLAG)\n                || permissions.beforeAddLiquidity != self.hasPermission(BEFORE_ADD_LIQUIDITY_FLAG)\n                || permissions.afterAddLiquidity != self.hasPermission(AFTER_ADD_LIQUIDITY_FLAG)\n                || permissions.beforeRemoveLiquidity != self.hasPermission(BEFORE_REMOVE_LIQUIDITY_FLAG)\n                || permissions.afterRemoveLiquidity != self.hasPermission(AFTER_REMOVE_LIQUIDITY_FLAG)\n                || permissions.beforeSwap != self.hasPermission(BEFORE_SWAP_FLAG)\n                || permissions.afterSwap != self.hasPermission(AFTER_SWAP_FLAG)\n                || permissions.beforeDonate != self.hasPermission(BEFORE_DONATE_FLAG)\n                || permissions.afterDonate != self.hasPermission(AFTER_DONATE_FLAG)\n                || permissions.beforeSwapReturnDelta != self.hasPermission(BEFORE_SWAP_RETURNS_DELTA_FLAG)\n                || permissions.afterSwapReturnDelta != self.hasPermission(AFTER_SWAP_RETURNS_DELTA_FLAG)\n                || permissions.afterAddLiquidityReturnDelta != self.hasPermission(AFTER_ADD_LIQUIDITY_RETURNS_DELTA_FLAG)\n                || permissions.afterRemoveLiquidityReturnDelta\n                    != self.hasPermission(AFTER_REMOVE_LIQUIDITY_RETURNS_DELTA_FLAG)\n        ) {\n            HookAddressNotValid.selector.revertWith(address(self));\n        }\n    }\n\n    /// @notice Ensures that the hook address includes at least one hook flag or dynamic fees, or is the 0 address\n    /// @param self The hook to verify\n    /// @param fee The fee of the pool the hook is used with\n    /// @return bool True if the hook address is valid\n    function isValidHookAddress(IHooks self, uint24 fee) internal pure returns (bool) {\n        // The hook can only have a flag to return a hook delta on an action if it also has the corresponding action flag\n        if (!self.hasPermission(BEFORE_SWAP_FLAG) && self.hasPermission(BEFORE_SWAP_RETURNS_DELTA_FLAG)) return false;\n        if (!self.hasPermission(AFTER_SWAP_FLAG) && self.hasPermission(AFTER_SWAP_RETURNS_DELTA_FLAG)) return false;\n        if (!self.hasPermission(AFTER_ADD_LIQUIDITY_FLAG) && self.hasPermission(AFTER_ADD_LIQUIDITY_RETURNS_DELTA_FLAG))\n        {\n            return false;\n        }\n        if (\n            !self.hasPermission(AFTER_REMOVE_LIQUIDITY_FLAG)\n                && self.hasPermission(AFTER_REMOVE_LIQUIDITY_RETURNS_DELTA_FLAG)\n        ) return false;\n\n        // If there is no hook contract set, then fee cannot be dynamic\n        // If a hook contract is set, it must have at least 1 flag set, or have a dynamic fee\n        return address(self) == address(0)\n            ? !fee.isDynamicFee()\n            : (uint160(address(self)) & ALL_HOOK_MASK > 0 || fee.isDynamicFee());\n    }\n\n    /// @notice performs a hook call using the given calldata on the given hook that doesn't return a delta\n    /// @return result The complete data returned by the hook\n    function callHook(IHooks self, bytes memory data) internal returns (bytes memory result) {\n        bool success;\n        assembly (\"memory-safe\") {\n            success := call(gas(), self, 0, add(data, 0x20), mload(data), 0, 0)\n        }\n        // Revert with FailedHookCall, containing any error message to bubble up\n        if (!success) CustomRevert.bubbleUpAndRevertWith(address(self), bytes4(data), HookCallFailed.selector);\n\n        // The call was successful, fetch the returned data\n        assembly (\"memory-safe\") {\n            // allocate result byte array from the free memory pointer\n            result := mload(0x40)\n            // store new free memory pointer at the end of the array padded to 32 bytes\n            mstore(0x40, add(result, and(add(returndatasize(), 0x3f), not(0x1f))))\n            // store length in memory\n            mstore(result, returndatasize())\n            // copy return data to result\n            returndatacopy(add(result, 0x20), 0, returndatasize())\n        }\n\n        // Length must be at least 32 to contain the selector. Check expected selector and returned selector match.\n        if (result.length < 32 || result.parseSelector() != data.parseSelector()) {\n            InvalidHookResponse.selector.revertWith();\n        }\n    }\n\n    /// @notice performs a hook call using the given calldata on the given hook\n    /// @return int256 The delta returned by the hook\n    function callHookWithReturnDelta(IHooks self, bytes memory data, bool parseReturn) internal returns (int256) {\n        bytes memory result = callHook(self, data);\n\n        // If this hook wasn't meant to return something, default to 0 delta\n        if (!parseReturn) return 0;\n\n        // A length of 64 bytes is required to return a bytes4, and a 32 byte delta\n        if (result.length != 64) InvalidHookResponse.selector.revertWith();\n        return result.parseReturnDelta();\n    }\n\n    /// @notice modifier to prevent calling a hook if they initiated the action\n    modifier noSelfCall(IHooks self) {\n        if (msg.sender != address(self)) {\n            _;\n        }\n    }\n\n    /// @notice calls beforeInitialize hook if permissioned and validates return value\n    function beforeInitialize(IHooks self, PoolKey memory key, uint160 sqrtPriceX96) internal noSelfCall(self) {\n        if (self.hasPermission(BEFORE_INITIALIZE_FLAG)) {\n            self.callHook(abi.encodeCall(IHooks.beforeInitialize, (msg.sender, key, sqrtPriceX96)));\n        }\n    }\n\n    /// @notice calls afterInitialize hook if permissioned and validates return value\n    function afterInitialize(IHooks self, PoolKey memory key, uint160 sqrtPriceX96, int24 tick)\n        internal\n        noSelfCall(self)\n    {\n        if (self.hasPermission(AFTER_INITIALIZE_FLAG)) {\n            self.callHook(abi.encodeCall(IHooks.afterInitialize, (msg.sender, key, sqrtPriceX96, tick)));\n        }\n    }\n\n    /// @notice calls beforeModifyLiquidity hook if permissioned and validates return value\n    function beforeModifyLiquidity(\n        IHooks self,\n        PoolKey memory key,\n        IPoolManager.ModifyLiquidityParams memory params,\n        bytes calldata hookData\n    ) internal noSelfCall(self) {\n        if (params.liquidityDelta > 0 && self.hasPermission(BEFORE_ADD_LIQUIDITY_FLAG)) {\n            self.callHook(abi.encodeCall(IHooks.beforeAddLiquidity, (msg.sender, key, params, hookData)));\n        } else if (params.liquidityDelta <= 0 && self.hasPermission(BEFORE_REMOVE_LIQUIDITY_FLAG)) {\n            self.callHook(abi.encodeCall(IHooks.beforeRemoveLiquidity, (msg.sender, key, params, hookData)));\n        }\n    }\n\n    /// @notice calls afterModifyLiquidity hook if permissioned and validates return value\n    function afterModifyLiquidity(\n        IHooks self,\n        PoolKey memory key,\n        IPoolManager.ModifyLiquidityParams memory params,\n        BalanceDelta delta,\n        BalanceDelta feesAccrued,\n        bytes calldata hookData\n    ) internal returns (BalanceDelta callerDelta, BalanceDelta hookDelta) {\n        if (msg.sender == address(self)) return (delta, BalanceDeltaLibrary.ZERO_DELTA);\n\n        callerDelta = delta;\n        if (params.liquidityDelta > 0) {\n            if (self.hasPermission(AFTER_ADD_LIQUIDITY_FLAG)) {\n                hookDelta = BalanceDelta.wrap(\n                    self.callHookWithReturnDelta(\n                        abi.encodeCall(\n                            IHooks.afterAddLiquidity, (msg.sender, key, params, delta, feesAccrued, hookData)\n                        ),\n                        self.hasPermission(AFTER_ADD_LIQUIDITY_RETURNS_DELTA_FLAG)\n                    )\n                );\n                callerDelta = callerDelta - hookDelta;\n            }\n        } else {\n            if (self.hasPermission(AFTER_REMOVE_LIQUIDITY_FLAG)) {\n                hookDelta = BalanceDelta.wrap(\n                    self.callHookWithReturnDelta(\n                        abi.encodeCall(\n                            IHooks.afterRemoveLiquidity, (msg.sender, key, params, delta, feesAccrued, hookData)\n                        ),\n                        self.hasPermission(AFTER_REMOVE_LIQUIDITY_RETURNS_DELTA_FLAG)\n                    )\n                );\n                callerDelta = callerDelta - hookDelta;\n            }\n        }\n    }\n\n    /// @notice calls beforeSwap hook if permissioned and validates return value\n    function beforeSwap(IHooks self, PoolKey memory key, IPoolManager.SwapParams memory params, bytes calldata hookData)\n        internal\n        returns (int256 amountToSwap, BeforeSwapDelta hookReturn, uint24 lpFeeOverride)\n    {\n        amountToSwap = params.amountSpecified;\n        if (msg.sender == address(self)) return (amountToSwap, BeforeSwapDeltaLibrary.ZERO_DELTA, lpFeeOverride);\n\n        if (self.hasPermission(BEFORE_SWAP_FLAG)) {\n            bytes memory result = callHook(self, abi.encodeCall(IHooks.beforeSwap, (msg.sender, key, params, hookData)));\n\n            // A length of 96 bytes is required to return a bytes4, a 32 byte delta, and an LP fee\n            if (result.length != 96) InvalidHookResponse.selector.revertWith();\n\n            // dynamic fee pools that want to override the cache fee, return a valid fee with the override flag. If override flag\n            // is set but an invalid fee is returned, the transaction will revert. Otherwise the current LP fee will be used\n            if (key.fee.isDynamicFee()) lpFeeOverride = result.parseFee();\n\n            // skip this logic for the case where the hook return is 0\n            if (self.hasPermission(BEFORE_SWAP_RETURNS_DELTA_FLAG)) {\n                hookReturn = BeforeSwapDelta.wrap(result.parseReturnDelta());\n\n                // any return in unspecified is passed to the afterSwap hook for handling\n                int128 hookDeltaSpecified = hookReturn.getSpecifiedDelta();\n\n                // Update the swap amount according to the hook's return, and check that the swap type doesn't change (exact input/output)\n                if (hookDeltaSpecified != 0) {\n                    bool exactInput = amountToSwap < 0;\n                    amountToSwap += hookDeltaSpecified;\n                    if (exactInput ? amountToSwap > 0 : amountToSwap < 0) {\n                        HookDeltaExceedsSwapAmount.selector.revertWith();\n                    }\n                }\n            }\n        }\n    }\n\n    /// @notice calls afterSwap hook if permissioned and validates return value\n    function afterSwap(\n        IHooks self,\n        PoolKey memory key,\n        IPoolManager.SwapParams memory params,\n        BalanceDelta swapDelta,\n        bytes calldata hookData,\n        BeforeSwapDelta beforeSwapHookReturn\n    ) internal returns (BalanceDelta, BalanceDelta) {\n        if (msg.sender == address(self)) return (swapDelta, BalanceDeltaLibrary.ZERO_DELTA);\n\n        int128 hookDeltaSpecified = beforeSwapHookReturn.getSpecifiedDelta();\n        int128 hookDeltaUnspecified = beforeSwapHookReturn.getUnspecifiedDelta();\n\n        if (self.hasPermission(AFTER_SWAP_FLAG)) {\n            hookDeltaUnspecified += self.callHookWithReturnDelta(\n                abi.encodeCall(IHooks.afterSwap, (msg.sender, key, params, swapDelta, hookData)),\n                self.hasPermission(AFTER_SWAP_RETURNS_DELTA_FLAG)\n            ).toInt128();\n        }\n\n        BalanceDelta hookDelta;\n        if (hookDeltaUnspecified != 0 || hookDeltaSpecified != 0) {\n            hookDelta = (params.amountSpecified < 0 == params.zeroForOne)\n                ? toBalanceDelta(hookDeltaSpecified, hookDeltaUnspecified)\n                : toBalanceDelta(hookDeltaUnspecified, hookDeltaSpecified);\n\n            // the caller has to pay for (or receive) the hook's delta\n            swapDelta = swapDelta - hookDelta;\n        }\n        return (swapDelta, hookDelta);\n    }\n\n    /// @notice calls beforeDonate hook if permissioned and validates return value\n    function beforeDonate(IHooks self, PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)\n        internal\n        noSelfCall(self)\n    {\n        if (self.hasPermission(BEFORE_DONATE_FLAG)) {\n            self.callHook(abi.encodeCall(IHooks.beforeDonate, (msg.sender, key, amount0, amount1, hookData)));\n        }\n    }\n\n    /// @notice calls afterDonate hook if permissioned and validates return value\n    function afterDonate(IHooks self, PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)\n        internal\n        noSelfCall(self)\n    {\n        if (self.hasPermission(AFTER_DONATE_FLAG)) {\n            self.callHook(abi.encodeCall(IHooks.afterDonate, (msg.sender, key, amount0, amount1, hookData)));\n        }\n    }\n\n    function hasPermission(IHooks self, uint160 flag) internal pure returns (bool) {\n        return uint160(address(self)) & flag != 0;\n    }\n}\n"}, "lib/v4-core/src/libraries/SqrtPriceMath.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {SafeCast} from \"./SafeCast.sol\";\n\nimport {FullMath} from \"./FullMath.sol\";\nimport {UnsafeMath} from \"./UnsafeMath.sol\";\nimport {FixedPoint96} from \"./FixedPoint96.sol\";\n\n/// @title Functions based on Q64.96 sqrt price and liquidity\n/// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas\nlibrary SqrtPriceMath {\n    using SafeCast for uint256;\n\n    error InvalidPriceOrLiquidity();\n    error InvalidPrice();\n    error NotEnoughLiquidity();\n    error PriceOverflow();\n\n    /// @notice Gets the next sqrt price given a delta of currency0\n    /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least\n    /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the\n    /// price less in order to not send too much output.\n    /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),\n    /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).\n    /// @param sqrtPX96 The starting price, i.e. before accounting for the currency0 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of currency0 to add or remove from virtual reserves\n    /// @param add Whether to add or remove the amount of currency0\n    /// @return The price after adding or removing amount, depending on add\n    function getNextSqrtPriceFromAmount0RoundingUp(uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add)\n        internal\n        pure\n        returns (uint160)\n    {\n        // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price\n        if (amount == 0) return sqrtPX96;\n        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n\n        if (add) {\n            unchecked {\n                uint256 product = amount * sqrtPX96;\n                if (product / amount == sqrtPX96) {\n                    uint256 denominator = numerator1 + product;\n                    if (denominator >= numerator1) {\n                        // always fits in 160 bits\n                        return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));\n                    }\n                }\n            }\n            // denominator is checked for overflow\n            return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96) + amount));\n        } else {\n            unchecked {\n                uint256 product = amount * sqrtPX96;\n                // if the product overflows, we know the denominator underflows\n                // in addition, we must check that the denominator does not underflow\n                // equivalent: if (product / amount != sqrtPX96 || numerator1 <= product) revert PriceOverflow();\n                assembly (\"memory-safe\") {\n                    if iszero(\n                        and(\n                            eq(div(product, amount), and(sqrtPX96, 0xffffffffffffffffffffffffffffffffffffffff)),\n                            gt(numerator1, product)\n                        )\n                    ) {\n                        mstore(0, 0xf5c787f1) // selector for PriceOverflow()\n                        revert(0x1c, 0x04)\n                    }\n                }\n                uint256 denominator = numerator1 - product;\n                return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();\n            }\n        }\n    }\n\n    /// @notice Gets the next sqrt price given a delta of currency1\n    /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least\n    /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the\n    /// price less in order to not send too much output.\n    /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the currency1 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of currency1 to add, or remove, from virtual reserves\n    /// @param add Whether to add, or remove, the amount of currency1\n    /// @return The price after adding or removing `amount`\n    function getNextSqrtPriceFromAmount1RoundingDown(uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add)\n        internal\n        pure\n        returns (uint160)\n    {\n        // if we're adding (subtracting), rounding down requires rounding the quotient down (up)\n        // in both cases, avoid a mulDiv for most inputs\n        if (add) {\n            uint256 quotient = (\n                amount <= type(uint160).max\n                    ? (amount << FixedPoint96.RESOLUTION) / liquidity\n                    : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)\n            );\n\n            return (uint256(sqrtPX96) + quotient).toUint160();\n        } else {\n            uint256 quotient = (\n                amount <= type(uint160).max\n                    ? UnsafeMath.divRoundingUp(amount << FixedPoint96.RESOLUTION, liquidity)\n                    : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity)\n            );\n\n            // equivalent: if (sqrtPX96 <= quotient) revert NotEnoughLiquidity();\n            assembly (\"memory-safe\") {\n                if iszero(gt(and(sqrtPX96, 0xffffffffffffffffffffffffffffffffffffffff), quotient)) {\n                    mstore(0, 0x4323a555) // selector for NotEnoughLiquidity()\n                    revert(0x1c, 0x04)\n                }\n            }\n            // always fits 160 bits\n            unchecked {\n                return uint160(sqrtPX96 - quotient);\n            }\n        }\n    }\n\n    /// @notice Gets the next sqrt price given an input amount of currency0 or currency1\n    /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount\n    /// @param liquidity The amount of usable liquidity\n    /// @param amountIn How much of currency0, or currency1, is being swapped in\n    /// @param zeroForOne Whether the amount in is currency0 or currency1\n    /// @return uint160 The price after adding the input amount to currency0 or currency1\n    function getNextSqrtPriceFromInput(uint160 sqrtPX96, uint128 liquidity, uint256 amountIn, bool zeroForOne)\n        internal\n        pure\n        returns (uint160)\n    {\n        // equivalent: if (sqrtPX96 == 0 || liquidity == 0) revert InvalidPriceOrLiquidity();\n        assembly (\"memory-safe\") {\n            if or(\n                iszero(and(sqrtPX96, 0xffffffffffffffffffffffffffffffffffffffff)),\n                iszero(and(liquidity, 0xffffffffffffffffffffffffffffffff))\n            ) {\n                mstore(0, 0x4f2461b8) // selector for InvalidPriceOrLiquidity()\n                revert(0x1c, 0x04)\n            }\n        }\n\n        // round to make sure that we don't pass the target price\n        return zeroForOne\n            ? getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)\n            : getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);\n    }\n\n    /// @notice Gets the next sqrt price given an output amount of currency0 or currency1\n    /// @dev Throws if price or liquidity are 0 or the next price is out of bounds\n    /// @param sqrtPX96 The starting price before accounting for the output amount\n    /// @param liquidity The amount of usable liquidity\n    /// @param amountOut How much of currency0, or currency1, is being swapped out\n    /// @param zeroForOne Whether the amount out is currency1 or currency0\n    /// @return uint160 The price after removing the output amount of currency0 or currency1\n    function getNextSqrtPriceFromOutput(uint160 sqrtPX96, uint128 liquidity, uint256 amountOut, bool zeroForOne)\n        internal\n        pure\n        returns (uint160)\n    {\n        // equivalent: if (sqrtPX96 == 0 || liquidity == 0) revert InvalidPriceOrLiquidity();\n        assembly (\"memory-safe\") {\n            if or(\n                iszero(and(sqrtPX96, 0xffffffffffffffffffffffffffffffffffffffff)),\n                iszero(and(liquidity, 0xffffffffffffffffffffffffffffffff))\n            ) {\n                mstore(0, 0x4f2461b8) // selector for InvalidPriceOrLiquidity()\n                revert(0x1c, 0x04)\n            }\n        }\n\n        // round to make sure that we pass the target price\n        return zeroForOne\n            ? getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)\n            : getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);\n    }\n\n    /// @notice Gets the amount0 delta between two prices\n    /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),\n    /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\n    /// @param sqrtPriceAX96 A sqrt price\n    /// @param sqrtPriceBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param roundUp Whether to round the amount up or down\n    /// @return uint256 Amount of currency0 required to cover a position of size liquidity between the two passed prices\n    function getAmount0Delta(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint128 liquidity, bool roundUp)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            if (sqrtPriceAX96 > sqrtPriceBX96) (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96);\n\n            // equivalent: if (sqrtPriceAX96 == 0) revert InvalidPrice();\n            assembly (\"memory-safe\") {\n                if iszero(and(sqrtPriceAX96, 0xffffffffffffffffffffffffffffffffffffffff)) {\n                    mstore(0, 0x00bfc921) // selector for InvalidPrice()\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n            uint256 numerator2 = sqrtPriceBX96 - sqrtPriceAX96;\n\n            return roundUp\n                ? UnsafeMath.divRoundingUp(FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtPriceBX96), sqrtPriceAX96)\n                : FullMath.mulDiv(numerator1, numerator2, sqrtPriceBX96) / sqrtPriceAX96;\n        }\n    }\n\n    /// @notice Equivalent to: `a >= b ? a - b : b - a`\n    function absDiff(uint160 a, uint160 b) internal pure returns (uint256 res) {\n        assembly (\"memory-safe\") {\n            let diff :=\n                sub(and(a, 0xffffffffffffffffffffffffffffffffffffffff), and(b, 0xffffffffffffffffffffffffffffffffffffffff))\n            // mask = 0 if a >= b else -1 (all 1s)\n            let mask := sar(255, diff)\n            // if a >= b, res = a - b = 0 ^ (a - b)\n            // if a < b, res = b - a = ~~(b - a) = ~(-(b - a) - 1) = ~(a - b - 1) = (-1) ^ (a - b - 1)\n            // either way, res = mask ^ (a - b + mask)\n            res := xor(mask, add(mask, diff))\n        }\n    }\n\n    /// @notice Gets the amount1 delta between two prices\n    /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))\n    /// @param sqrtPriceAX96 A sqrt price\n    /// @param sqrtPriceBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param roundUp Whether to round the amount up, or down\n    /// @return amount1 Amount of currency1 required to cover a position of size liquidity between the two passed prices\n    function getAmount1Delta(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint128 liquidity, bool roundUp)\n        internal\n        pure\n        returns (uint256 amount1)\n    {\n        uint256 numerator = absDiff(sqrtPriceAX96, sqrtPriceBX96);\n        uint256 denominator = FixedPoint96.Q96;\n        uint256 _liquidity = uint256(liquidity);\n\n        /**\n         * Equivalent to:\n         *   amount1 = roundUp\n         *       ? FullMath.mulDivRoundingUp(liquidity, sqrtPriceBX96 - sqrtPriceAX96, FixedPoint96.Q96)\n         *       : FullMath.mulDiv(liquidity, sqrtPriceBX96 - sqrtPriceAX96, FixedPoint96.Q96);\n         * Cannot overflow because `type(uint128).max * type(uint160).max >> 96 < (1 << 192)`.\n         */\n        amount1 = FullMath.mulDiv(_liquidity, numerator, denominator);\n        assembly (\"memory-safe\") {\n            amount1 := add(amount1, and(gt(mulmod(_liquidity, numerator, denominator), 0), roundUp))\n        }\n    }\n\n    /// @notice Helper that gets signed currency0 delta\n    /// @param sqrtPriceAX96 A sqrt price\n    /// @param sqrtPriceBX96 Another sqrt price\n    /// @param liquidity The change in liquidity for which to compute the amount0 delta\n    /// @return int256 Amount of currency0 corresponding to the passed liquidityDelta between the two prices\n    function getAmount0Delta(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, int128 liquidity)\n        internal\n        pure\n        returns (int256)\n    {\n        unchecked {\n            return liquidity < 0\n                ? getAmount0Delta(sqrtPriceAX96, sqrtPriceBX96, uint128(-liquidity), false).toInt256()\n                : -getAmount0Delta(sqrtPriceAX96, sqrtPriceBX96, uint128(liquidity), true).toInt256();\n        }\n    }\n\n    /// @notice Helper that gets signed currency1 delta\n    /// @param sqrtPriceAX96 A sqrt price\n    /// @param sqrtPriceBX96 Another sqrt price\n    /// @param liquidity The change in liquidity for which to compute the amount1 delta\n    /// @return int256 Amount of currency1 corresponding to the passed liquidityDelta between the two prices\n    function getAmount1Delta(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, int128 liquidity)\n        internal\n        pure\n        returns (int256)\n    {\n        unchecked {\n            return liquidity < 0\n                ? getAmount1Delta(sqrtPriceAX96, sqrtPriceBX96, uint128(-liquidity), false).toInt256()\n                : -getAmount1Delta(sqrtPriceAX96, sqrtPriceBX96, uint128(liquidity), true).toInt256();\n        }\n    }\n}\n"}, "lib/solady/src/tokens/WETH.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {ERC20} from \"./ERC20.sol\";\n\n/// @notice Simple Wrapped Ether implementation.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/WETH.sol)\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/WETH.sol)\n/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)\ncontract WETH is ERC20 {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       ERC20 METADATA                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the name of the token.\n    function name() public view virtual override returns (string memory) {\n        return \"Wrapped Ether\";\n    }\n\n    /// @dev Returns the symbol of the token.\n    function symbol() public view virtual override returns (string memory) {\n        return \"WETH\";\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                            WETH                            */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Deposits `amount` ETH of the caller and mints `amount` WETH to the caller.\n    function deposit() public payable virtual {\n        _mint(msg.sender, msg.value);\n    }\n\n    /// @dev Burns `amount` WETH of the caller and sends `amount` ETH to the caller.\n    function withdraw(uint256 amount) public virtual {\n        _burn(msg.sender, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and check if it succeeded or not.\n            if iszero(call(gas(), caller(), amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Equivalent to `deposit()`.\n    receive() external payable virtual {\n        deposit();\n    }\n}\n"}, "lib/solady/src/utils/SafeCastLib.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Safe integer casting library that reverts on overflow.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeCastLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\n/// @dev Optimized for runtime gas for very high number of optimizer runs (i.e. >= 1000000).\nlibrary SafeCastLib {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Unable to cast to the target type due to overflow.\n    error Overflow();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*          UNSIGNED INTEGER SAFE CASTING OPERATIONS          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Casts `x` to a uint8. Reverts on overflow.\n    function toUint8(uint256 x) internal pure returns (uint8) {\n        if (x >= 1 << 8) _revertOverflow();\n        return uint8(x);\n    }\n\n    /// @dev Casts `x` to a uint16. Reverts on overflow.\n    function toUint16(uint256 x) internal pure returns (uint16) {\n        if (x >= 1 << 16) _revertOverflow();\n        return uint16(x);\n    }\n\n    /// @dev Casts `x` to a uint24. Reverts on overflow.\n    function toUint24(uint256 x) internal pure returns (uint24) {\n        if (x >= 1 << 24) _revertOverflow();\n        return uint24(x);\n    }\n\n    /// @dev Casts `x` to a uint32. Reverts on overflow.\n    function toUint32(uint256 x) internal pure returns (uint32) {\n        if (x >= 1 << 32) _revertOverflow();\n        return uint32(x);\n    }\n\n    /// @dev Casts `x` to a uint40. Reverts on overflow.\n    function toUint40(uint256 x) internal pure returns (uint40) {\n        if (x >= 1 << 40) _revertOverflow();\n        return uint40(x);\n    }\n\n    /// @dev Casts `x` to a uint48. Reverts on overflow.\n    function toUint48(uint256 x) internal pure returns (uint48) {\n        if (x >= 1 << 48) _revertOverflow();\n        return uint48(x);\n    }\n\n    /// @dev Casts `x` to a uint56. Reverts on overflow.\n    function toUint56(uint256 x) internal pure returns (uint56) {\n        if (x >= 1 << 56) _revertOverflow();\n        return uint56(x);\n    }\n\n    /// @dev Casts `x` to a uint64. Reverts on overflow.\n    function toUint64(uint256 x) internal pure returns (uint64) {\n        if (x >= 1 << 64) _revertOverflow();\n        return uint64(x);\n    }\n\n    /// @dev Casts `x` to a uint72. Reverts on overflow.\n    function toUint72(uint256 x) internal pure returns (uint72) {\n        if (x >= 1 << 72) _revertOverflow();\n        return uint72(x);\n    }\n\n    /// @dev Casts `x` to a uint80. Reverts on overflow.\n    function toUint80(uint256 x) internal pure returns (uint80) {\n        if (x >= 1 << 80) _revertOverflow();\n        return uint80(x);\n    }\n\n    /// @dev Casts `x` to a uint88. Reverts on overflow.\n    function toUint88(uint256 x) internal pure returns (uint88) {\n        if (x >= 1 << 88) _revertOverflow();\n        return uint88(x);\n    }\n\n    /// @dev Casts `x` to a uint96. Reverts on overflow.\n    function toUint96(uint256 x) internal pure returns (uint96) {\n        if (x >= 1 << 96) _revertOverflow();\n        return uint96(x);\n    }\n\n    /// @dev Casts `x` to a uint104. Reverts on overflow.\n    function toUint104(uint256 x) internal pure returns (uint104) {\n        if (x >= 1 << 104) _revertOverflow();\n        return uint104(x);\n    }\n\n    /// @dev Casts `x` to a uint112. Reverts on overflow.\n    function toUint112(uint256 x) internal pure returns (uint112) {\n        if (x >= 1 << 112) _revertOverflow();\n        return uint112(x);\n    }\n\n    /// @dev Casts `x` to a uint120. Reverts on overflow.\n    function toUint120(uint256 x) internal pure returns (uint120) {\n        if (x >= 1 << 120) _revertOverflow();\n        return uint120(x);\n    }\n\n    /// @dev Casts `x` to a uint128. Reverts on overflow.\n    function toUint128(uint256 x) internal pure returns (uint128) {\n        if (x >= 1 << 128) _revertOverflow();\n        return uint128(x);\n    }\n\n    /// @dev Casts `x` to a uint136. Reverts on overflow.\n    function toUint136(uint256 x) internal pure returns (uint136) {\n        if (x >= 1 << 136) _revertOverflow();\n        return uint136(x);\n    }\n\n    /// @dev Casts `x` to a uint144. Reverts on overflow.\n    function toUint144(uint256 x) internal pure returns (uint144) {\n        if (x >= 1 << 144) _revertOverflow();\n        return uint144(x);\n    }\n\n    /// @dev Casts `x` to a uint152. Reverts on overflow.\n    function toUint152(uint256 x) internal pure returns (uint152) {\n        if (x >= 1 << 152) _revertOverflow();\n        return uint152(x);\n    }\n\n    /// @dev Casts `x` to a uint160. Reverts on overflow.\n    function toUint160(uint256 x) internal pure returns (uint160) {\n        if (x >= 1 << 160) _revertOverflow();\n        return uint160(x);\n    }\n\n    /// @dev Casts `x` to a uint168. Reverts on overflow.\n    function toUint168(uint256 x) internal pure returns (uint168) {\n        if (x >= 1 << 168) _revertOverflow();\n        return uint168(x);\n    }\n\n    /// @dev Casts `x` to a uint176. Reverts on overflow.\n    function toUint176(uint256 x) internal pure returns (uint176) {\n        if (x >= 1 << 176) _revertOverflow();\n        return uint176(x);\n    }\n\n    /// @dev Casts `x` to a uint184. Reverts on overflow.\n    function toUint184(uint256 x) internal pure returns (uint184) {\n        if (x >= 1 << 184) _revertOverflow();\n        return uint184(x);\n    }\n\n    /// @dev Casts `x` to a uint192. Reverts on overflow.\n    function toUint192(uint256 x) internal pure returns (uint192) {\n        if (x >= 1 << 192) _revertOverflow();\n        return uint192(x);\n    }\n\n    /// @dev Casts `x` to a uint200. Reverts on overflow.\n    function toUint200(uint256 x) internal pure returns (uint200) {\n        if (x >= 1 << 200) _revertOverflow();\n        return uint200(x);\n    }\n\n    /// @dev Casts `x` to a uint208. Reverts on overflow.\n    function toUint208(uint256 x) internal pure returns (uint208) {\n        if (x >= 1 << 208) _revertOverflow();\n        return uint208(x);\n    }\n\n    /// @dev Casts `x` to a uint216. Reverts on overflow.\n    function toUint216(uint256 x) internal pure returns (uint216) {\n        if (x >= 1 << 216) _revertOverflow();\n        return uint216(x);\n    }\n\n    /// @dev Casts `x` to a uint224. Reverts on overflow.\n    function toUint224(uint256 x) internal pure returns (uint224) {\n        if (x >= 1 << 224) _revertOverflow();\n        return uint224(x);\n    }\n\n    /// @dev Casts `x` to a uint232. Reverts on overflow.\n    function toUint232(uint256 x) internal pure returns (uint232) {\n        if (x >= 1 << 232) _revertOverflow();\n        return uint232(x);\n    }\n\n    /// @dev Casts `x` to a uint240. Reverts on overflow.\n    function toUint240(uint256 x) internal pure returns (uint240) {\n        if (x >= 1 << 240) _revertOverflow();\n        return uint240(x);\n    }\n\n    /// @dev Casts `x` to a uint248. Reverts on overflow.\n    function toUint248(uint256 x) internal pure returns (uint248) {\n        if (x >= 1 << 248) _revertOverflow();\n        return uint248(x);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*           SIGNED INTEGER SAFE CASTING OPERATIONS           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Casts `x` to a int8. Reverts on overflow.\n    function toInt8(int256 x) internal pure returns (int8) {\n        unchecked {\n            if (((1 << 7) + uint256(x)) >> 8 == uint256(0)) return int8(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int16. Reverts on overflow.\n    function toInt16(int256 x) internal pure returns (int16) {\n        unchecked {\n            if (((1 << 15) + uint256(x)) >> 16 == uint256(0)) return int16(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int24. Reverts on overflow.\n    function toInt24(int256 x) internal pure returns (int24) {\n        unchecked {\n            if (((1 << 23) + uint256(x)) >> 24 == uint256(0)) return int24(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int32. Reverts on overflow.\n    function toInt32(int256 x) internal pure returns (int32) {\n        unchecked {\n            if (((1 << 31) + uint256(x)) >> 32 == uint256(0)) return int32(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int40. Reverts on overflow.\n    function toInt40(int256 x) internal pure returns (int40) {\n        unchecked {\n            if (((1 << 39) + uint256(x)) >> 40 == uint256(0)) return int40(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int48. Reverts on overflow.\n    function toInt48(int256 x) internal pure returns (int48) {\n        unchecked {\n            if (((1 << 47) + uint256(x)) >> 48 == uint256(0)) return int48(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int56. Reverts on overflow.\n    function toInt56(int256 x) internal pure returns (int56) {\n        unchecked {\n            if (((1 << 55) + uint256(x)) >> 56 == uint256(0)) return int56(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int64. Reverts on overflow.\n    function toInt64(int256 x) internal pure returns (int64) {\n        unchecked {\n            if (((1 << 63) + uint256(x)) >> 64 == uint256(0)) return int64(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int72. Reverts on overflow.\n    function toInt72(int256 x) internal pure returns (int72) {\n        unchecked {\n            if (((1 << 71) + uint256(x)) >> 72 == uint256(0)) return int72(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int80. Reverts on overflow.\n    function toInt80(int256 x) internal pure returns (int80) {\n        unchecked {\n            if (((1 << 79) + uint256(x)) >> 80 == uint256(0)) return int80(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int88. Reverts on overflow.\n    function toInt88(int256 x) internal pure returns (int88) {\n        unchecked {\n            if (((1 << 87) + uint256(x)) >> 88 == uint256(0)) return int88(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int96. Reverts on overflow.\n    function toInt96(int256 x) internal pure returns (int96) {\n        unchecked {\n            if (((1 << 95) + uint256(x)) >> 96 == uint256(0)) return int96(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int104. Reverts on overflow.\n    function toInt104(int256 x) internal pure returns (int104) {\n        unchecked {\n            if (((1 << 103) + uint256(x)) >> 104 == uint256(0)) return int104(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int112. Reverts on overflow.\n    function toInt112(int256 x) internal pure returns (int112) {\n        unchecked {\n            if (((1 << 111) + uint256(x)) >> 112 == uint256(0)) return int112(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int120. Reverts on overflow.\n    function toInt120(int256 x) internal pure returns (int120) {\n        unchecked {\n            if (((1 << 119) + uint256(x)) >> 120 == uint256(0)) return int120(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int128. Reverts on overflow.\n    function toInt128(int256 x) internal pure returns (int128) {\n        unchecked {\n            if (((1 << 127) + uint256(x)) >> 128 == uint256(0)) return int128(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int136. Reverts on overflow.\n    function toInt136(int256 x) internal pure returns (int136) {\n        unchecked {\n            if (((1 << 135) + uint256(x)) >> 136 == uint256(0)) return int136(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int144. Reverts on overflow.\n    function toInt144(int256 x) internal pure returns (int144) {\n        unchecked {\n            if (((1 << 143) + uint256(x)) >> 144 == uint256(0)) return int144(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int152. Reverts on overflow.\n    function toInt152(int256 x) internal pure returns (int152) {\n        unchecked {\n            if (((1 << 151) + uint256(x)) >> 152 == uint256(0)) return int152(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int160. Reverts on overflow.\n    function toInt160(int256 x) internal pure returns (int160) {\n        unchecked {\n            if (((1 << 159) + uint256(x)) >> 160 == uint256(0)) return int160(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int168. Reverts on overflow.\n    function toInt168(int256 x) internal pure returns (int168) {\n        unchecked {\n            if (((1 << 167) + uint256(x)) >> 168 == uint256(0)) return int168(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int176. Reverts on overflow.\n    function toInt176(int256 x) internal pure returns (int176) {\n        unchecked {\n            if (((1 << 175) + uint256(x)) >> 176 == uint256(0)) return int176(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int184. Reverts on overflow.\n    function toInt184(int256 x) internal pure returns (int184) {\n        unchecked {\n            if (((1 << 183) + uint256(x)) >> 184 == uint256(0)) return int184(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int192. Reverts on overflow.\n    function toInt192(int256 x) internal pure returns (int192) {\n        unchecked {\n            if (((1 << 191) + uint256(x)) >> 192 == uint256(0)) return int192(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int200. Reverts on overflow.\n    function toInt200(int256 x) internal pure returns (int200) {\n        unchecked {\n            if (((1 << 199) + uint256(x)) >> 200 == uint256(0)) return int200(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int208. Reverts on overflow.\n    function toInt208(int256 x) internal pure returns (int208) {\n        unchecked {\n            if (((1 << 207) + uint256(x)) >> 208 == uint256(0)) return int208(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int216. Reverts on overflow.\n    function toInt216(int256 x) internal pure returns (int216) {\n        unchecked {\n            if (((1 << 215) + uint256(x)) >> 216 == uint256(0)) return int216(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int224. Reverts on overflow.\n    function toInt224(int256 x) internal pure returns (int224) {\n        unchecked {\n            if (((1 << 223) + uint256(x)) >> 224 == uint256(0)) return int224(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int232. Reverts on overflow.\n    function toInt232(int256 x) internal pure returns (int232) {\n        unchecked {\n            if (((1 << 231) + uint256(x)) >> 232 == uint256(0)) return int232(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int240. Reverts on overflow.\n    function toInt240(int256 x) internal pure returns (int240) {\n        unchecked {\n            if (((1 << 239) + uint256(x)) >> 240 == uint256(0)) return int240(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int248. Reverts on overflow.\n    function toInt248(int256 x) internal pure returns (int248) {\n        unchecked {\n            if (((1 << 247) + uint256(x)) >> 248 == uint256(0)) return int248(x);\n            _revertOverflow();\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*               OTHER SAFE CASTING OPERATIONS                */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Casts `x` to a int8. Reverts on overflow.\n    function toInt8(uint256 x) internal pure returns (int8) {\n        if (x >= 1 << 7) _revertOverflow();\n        return int8(int256(x));\n    }\n\n    /// @dev Casts `x` to a int16. Reverts on overflow.\n    function toInt16(uint256 x) internal pure returns (int16) {\n        if (x >= 1 << 15) _revertOverflow();\n        return int16(int256(x));\n    }\n\n    /// @dev Casts `x` to a int24. Reverts on overflow.\n    function toInt24(uint256 x) internal pure returns (int24) {\n        if (x >= 1 << 23) _revertOverflow();\n        return int24(int256(x));\n    }\n\n    /// @dev Casts `x` to a int32. Reverts on overflow.\n    function toInt32(uint256 x) internal pure returns (int32) {\n        if (x >= 1 << 31) _revertOverflow();\n        return int32(int256(x));\n    }\n\n    /// @dev Casts `x` to a int40. Reverts on overflow.\n    function toInt40(uint256 x) internal pure returns (int40) {\n        if (x >= 1 << 39) _revertOverflow();\n        return int40(int256(x));\n    }\n\n    /// @dev Casts `x` to a int48. Reverts on overflow.\n    function toInt48(uint256 x) internal pure returns (int48) {\n        if (x >= 1 << 47) _revertOverflow();\n        return int48(int256(x));\n    }\n\n    /// @dev Casts `x` to a int56. Reverts on overflow.\n    function toInt56(uint256 x) internal pure returns (int56) {\n        if (x >= 1 << 55) _revertOverflow();\n        return int56(int256(x));\n    }\n\n    /// @dev Casts `x` to a int64. Reverts on overflow.\n    function toInt64(uint256 x) internal pure returns (int64) {\n        if (x >= 1 << 63) _revertOverflow();\n        return int64(int256(x));\n    }\n\n    /// @dev Casts `x` to a int72. Reverts on overflow.\n    function toInt72(uint256 x) internal pure returns (int72) {\n        if (x >= 1 << 71) _revertOverflow();\n        return int72(int256(x));\n    }\n\n    /// @dev Casts `x` to a int80. Reverts on overflow.\n    function toInt80(uint256 x) internal pure returns (int80) {\n        if (x >= 1 << 79) _revertOverflow();\n        return int80(int256(x));\n    }\n\n    /// @dev Casts `x` to a int88. Reverts on overflow.\n    function toInt88(uint256 x) internal pure returns (int88) {\n        if (x >= 1 << 87) _revertOverflow();\n        return int88(int256(x));\n    }\n\n    /// @dev Casts `x` to a int96. Reverts on overflow.\n    function toInt96(uint256 x) internal pure returns (int96) {\n        if (x >= 1 << 95) _revertOverflow();\n        return int96(int256(x));\n    }\n\n    /// @dev Casts `x` to a int104. Reverts on overflow.\n    function toInt104(uint256 x) internal pure returns (int104) {\n        if (x >= 1 << 103) _revertOverflow();\n        return int104(int256(x));\n    }\n\n    /// @dev Casts `x` to a int112. Reverts on overflow.\n    function toInt112(uint256 x) internal pure returns (int112) {\n        if (x >= 1 << 111) _revertOverflow();\n        return int112(int256(x));\n    }\n\n    /// @dev Casts `x` to a int120. Reverts on overflow.\n    function toInt120(uint256 x) internal pure returns (int120) {\n        if (x >= 1 << 119) _revertOverflow();\n        return int120(int256(x));\n    }\n\n    /// @dev Casts `x` to a int128. Reverts on overflow.\n    function toInt128(uint256 x) internal pure returns (int128) {\n        if (x >= 1 << 127) _revertOverflow();\n        return int128(int256(x));\n    }\n\n    /// @dev Casts `x` to a int136. Reverts on overflow.\n    function toInt136(uint256 x) internal pure returns (int136) {\n        if (x >= 1 << 135) _revertOverflow();\n        return int136(int256(x));\n    }\n\n    /// @dev Casts `x` to a int144. Reverts on overflow.\n    function toInt144(uint256 x) internal pure returns (int144) {\n        if (x >= 1 << 143) _revertOverflow();\n        return int144(int256(x));\n    }\n\n    /// @dev Casts `x` to a int152. Reverts on overflow.\n    function toInt152(uint256 x) internal pure returns (int152) {\n        if (x >= 1 << 151) _revertOverflow();\n        return int152(int256(x));\n    }\n\n    /// @dev Casts `x` to a int160. Reverts on overflow.\n    function toInt160(uint256 x) internal pure returns (int160) {\n        if (x >= 1 << 159) _revertOverflow();\n        return int160(int256(x));\n    }\n\n    /// @dev Casts `x` to a int168. Reverts on overflow.\n    function toInt168(uint256 x) internal pure returns (int168) {\n        if (x >= 1 << 167) _revertOverflow();\n        return int168(int256(x));\n    }\n\n    /// @dev Casts `x` to a int176. Reverts on overflow.\n    function toInt176(uint256 x) internal pure returns (int176) {\n        if (x >= 1 << 175) _revertOverflow();\n        return int176(int256(x));\n    }\n\n    /// @dev Casts `x` to a int184. Reverts on overflow.\n    function toInt184(uint256 x) internal pure returns (int184) {\n        if (x >= 1 << 183) _revertOverflow();\n        return int184(int256(x));\n    }\n\n    /// @dev Casts `x` to a int192. Reverts on overflow.\n    function toInt192(uint256 x) internal pure returns (int192) {\n        if (x >= 1 << 191) _revertOverflow();\n        return int192(int256(x));\n    }\n\n    /// @dev Casts `x` to a int200. Reverts on overflow.\n    function toInt200(uint256 x) internal pure returns (int200) {\n        if (x >= 1 << 199) _revertOverflow();\n        return int200(int256(x));\n    }\n\n    /// @dev Casts `x` to a int208. Reverts on overflow.\n    function toInt208(uint256 x) internal pure returns (int208) {\n        if (x >= 1 << 207) _revertOverflow();\n        return int208(int256(x));\n    }\n\n    /// @dev Casts `x` to a int216. Reverts on overflow.\n    function toInt216(uint256 x) internal pure returns (int216) {\n        if (x >= 1 << 215) _revertOverflow();\n        return int216(int256(x));\n    }\n\n    /// @dev Casts `x` to a int224. Reverts on overflow.\n    function toInt224(uint256 x) internal pure returns (int224) {\n        if (x >= 1 << 223) _revertOverflow();\n        return int224(int256(x));\n    }\n\n    /// @dev Casts `x` to a int232. Reverts on overflow.\n    function toInt232(uint256 x) internal pure returns (int232) {\n        if (x >= 1 << 231) _revertOverflow();\n        return int232(int256(x));\n    }\n\n    /// @dev Casts `x` to a int240. Reverts on overflow.\n    function toInt240(uint256 x) internal pure returns (int240) {\n        if (x >= 1 << 239) _revertOverflow();\n        return int240(int256(x));\n    }\n\n    /// @dev Casts `x` to a int248. Reverts on overflow.\n    function toInt248(uint256 x) internal pure returns (int248) {\n        if (x >= 1 << 247) _revertOverflow();\n        return int248(int256(x));\n    }\n\n    /// @dev Casts `x` to a int256. Reverts on overflow.\n    function toInt256(uint256 x) internal pure returns (int256) {\n        if (int256(x) >= 0) return int256(x);\n        _revertOverflow();\n    }\n\n    /// @dev Casts `x` to a uint256. Reverts on overflow.\n    function toUint256(int256 x) internal pure returns (uint256) {\n        if (x >= 0) return uint256(x);\n        _revertOverflow();\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    function _revertOverflow() private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Store the function selector of `Overflow()`.\n            mstore(0x00, 0x35278d12)\n            // Revert with (offset, size).\n            revert(0x1c, 0x04)\n        }\n    }\n}\n"}, "src/lib/FeeMath.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\nimport {TickMath} from \"@uniswap/v4-core/src/libraries/TickMath.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport \"./Math.sol\";\nimport \"../base/Constants.sol\";\n\nusing FixedPointMathLib for int256;\nusing FixedPointMathLib for uint256;\n\nfunction computeSurgeFee(uint32 lastSurgeTimestamp, uint16 surgeFeeHalfLife) view returns (uint24 fee) {\n    // compute surge fee\n    // surge fee gets applied after the LDF shifts (if it's dynamic)\n    unchecked {\n        uint256 timeSinceLastSurge = uint32(block.timestamp) - lastSurgeTimestamp;\n        // max surge fee is hardcoded to 100% (SWAP_FEE_BASE)\n        fee = uint24(\n            SWAP_FEE_BASE.mulWadUp(uint256((-int256(timeSinceLastSurge.mulDiv(LN2_WAD, surgeFeeHalfLife))).expWad()))\n        );\n    }\n}\n\nfunction computeDynamicSwapFee(\n    uint160 postSwapSqrtPriceX96,\n    int24 arithmeticMeanTick,\n    uint32 lastSurgeTimestamp,\n    uint24 feeMin,\n    uint24 feeMax,\n    uint24 feeQuadraticMultiplier,\n    uint16 surgeFeeHalfLife\n) view returns (uint24 fee) {\n    // compute surge fee\n    // surge fee gets applied after the LDF shifts (if it's dynamic)\n    fee = computeSurgeFee(lastSurgeTimestamp, surgeFeeHalfLife);\n\n    // special case for fixed fee pools\n    if (feeQuadraticMultiplier == 0 || feeMin == feeMax) return uint24(FixedPointMathLib.max(feeMin, fee));\n\n    uint256 ratio = uint256(postSwapSqrtPriceX96).mulDiv(SWAP_FEE_BASE, TickMath.getSqrtPriceAtTick(arithmeticMeanTick));\n    if (ratio > MAX_SWAP_FEE_RATIO) ratio = MAX_SWAP_FEE_RATIO;\n    ratio = ratio.mulDiv(ratio, SWAP_FEE_BASE); // square the sqrtPrice ratio to get the price ratio\n    uint256 delta = dist(ratio, SWAP_FEE_BASE);\n    // unchecked is safe since we're using uint256 to store the result and the return value is bounded in the range [feeMin, feeMax]\n    unchecked {\n        uint256 quadraticTerm = uint256(feeQuadraticMultiplier).mulDivUp(delta * delta, SWAP_FEE_BASE_SQUARED);\n        return uint24(FixedPointMathLib.max(fee, FixedPointMathLib.min(feeMin + quadraticTerm, feeMax)));\n    }\n}\n"}, "src/lib/AmAmmPayload.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\n/// @dev Decodes the payload specified by the am-AMM manager.\n/// Format:\n/// | swapFee0For1 - 3 bytes | swapFee1For0 - 3 bytes |\n/// @return swapFee0For1 The swap fee for token0 -> token1 swaps\n/// @return swapFee1For0 The swap fee for token1 -> token0 swaps\nfunction decodeAmAmmPayload(bytes6 payload) pure returns (uint24 swapFee0For1, uint24 swapFee1For0) {\n    swapFee0For1 = uint24(bytes3(payload));\n    swapFee1For0 = uint24(bytes3(payload << 24));\n}\n"}, "src/BunniHook.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport \"@uniswap/v4-core/src/types/PoolId.sol\";\nimport \"@uniswap/v4-core/src/types/Currency.sol\";\nimport \"@uniswap/v4-core/src/types/BeforeSwapDelta.sol\";\nimport {Hooks} from \"@uniswap/v4-core/src/libraries/Hooks.sol\";\nimport {TickMath} from \"@uniswap/v4-core/src/libraries/TickMath.sol\";\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\n\nimport {AmAmm} from \"biddog/AmAmm.sol\";\n\nimport \"flood-contracts/src/interfaces/IZone.sol\";\nimport \"flood-contracts/src/interfaces/IFloodPlain.sol\";\n\nimport {IERC1271} from \"permit2/src/interfaces/IERC1271.sol\";\n\nimport {WETH} from \"solady/tokens/WETH.sol\";\nimport {ERC20} from \"solady/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport \"./lib/Math.sol\";\nimport \"./base/Errors.sol\";\nimport \"./base/Constants.sol\";\nimport \"./lib/AmAmmPayload.sol\";\nimport \"./types/IdleBalance.sol\";\nimport \"./base/SharedStructs.sol\";\nimport \"./interfaces/IBunniHook.sol\";\nimport {Oracle} from \"./lib/Oracle.sol\";\nimport {Ownable} from \"./base/Ownable.sol\";\nimport {BaseHook} from \"./base/BaseHook.sol\";\nimport {IBunniHub} from \"./interfaces/IBunniHub.sol\";\nimport {BunniSwapMath} from \"./lib/BunniSwapMath.sol\";\nimport {BunniHookLogic} from \"./lib/BunniHookLogic.sol\";\nimport {ReentrancyGuard} from \"./base/ReentrancyGuard.sol\";\n\n/// @title BunniHook\n/// @author zefram.eth\n/// @notice Uniswap v4 hook responsible for handling swaps on Bunni. Implements auto-rebalancing\n/// executed via FloodPlain. Uses am-AMM to recapture LVR & MEV.\ncontract BunniHook is BaseHook, Ownable, IBunniHook, ReentrancyGuard, AmAmm {\n    /// -----------------------------------------------------------------------\n    /// Library usage\n    /// -----------------------------------------------------------------------\n\n    using SafeTransferLib for *;\n    using FixedPointMathLib for *;\n    using IdleBalanceLibrary for *;\n    using PoolIdLibrary for PoolKey;\n    using CurrencyLibrary for Currency;\n    using Oracle for Oracle.Observation[MAX_CARDINALITY];\n\n    /// -----------------------------------------------------------------------\n    /// Immutable args\n    /// -----------------------------------------------------------------------\n\n    uint48 internal immutable _K;\n    WETH internal immutable weth;\n    IBunniHub internal immutable hub;\n    address internal immutable permit2;\n    IFloodPlain internal immutable floodPlain;\n\n    /// -----------------------------------------------------------------------\n    /// Transient storage variables\n    /// -----------------------------------------------------------------------\n\n    /// @dev Equal to uint256(keccak256(\"REBALANCE_OUTPUT_BALANCE_SLOT\")) - 1\n    uint256 internal constant REBALANCE_OUTPUT_BALANCE_SLOT =\n        0x07bd55ea91cddb9c2c27beeba6deadeb8f557caeb242f82d756cf1d33154a78c;\n\n    /// -----------------------------------------------------------------------\n    /// Storage variables\n    /// -----------------------------------------------------------------------\n\n    /// @dev Contains mappings used by both BunniHook and BunniLogic. Makes passing\n    /// mappings to BunniHookLogic easier & cheaper.\n    HookStorage internal s;\n\n    /// @dev The address that receives the hook protocol fees\n    address internal hookFeeRecipient;\n\n    /// @notice Used for computing the hook fee amount. Fee taken is `amount * swapFee / 1e6 * hookFeesModifier / 1e6`.\n    uint32 internal hookFeeModifier;\n\n    /// @notice Used for computing the referral reward amount. Reward is `hookFee * referralRewardModifier / 1e6`.\n    uint32 internal referralRewardModifier;\n\n    /// @notice The FloodZone contract used in rebalance orders.\n    IZone internal floodZone;\n\n    /// -----------------------------------------------------------------------\n    /// Constructor\n    /// -----------------------------------------------------------------------\n\n    constructor(\n        IPoolManager poolManager_,\n        IBunniHub hub_,\n        IFloodPlain floodPlain_,\n        WETH weth_,\n        IZone floodZone_,\n        address owner_,\n        address hookFeeRecipient_,\n        uint32 hookFeeModifier_,\n        uint32 referralRewardModifier_,\n        uint48 k_\n    ) BaseHook(poolManager_) {\n        if (hookFeeModifier_ > MODIFIER_BASE || referralRewardModifier_ > MODIFIER_BASE) {\n            revert BunniHook__InvalidModifier();\n        }\n\n        hub = hub_;\n        floodPlain = floodPlain_;\n        permit2 = address(floodPlain_.PERMIT2());\n        weth = weth_;\n        _K = k_;\n        require(\n            address(hub_) != address(0) && address(floodPlain_) != address(0) && address(permit2) != address(0)\n                && address(weth_) != address(0) && owner_ != address(0) && k_ != 0\n        );\n\n        hookFeeRecipient = hookFeeRecipient_;\n        hookFeeModifier = hookFeeModifier_;\n        referralRewardModifier = referralRewardModifier_;\n        floodZone = floodZone_;\n\n        _initializeOwner(owner_);\n        poolManager_.setOperator(address(hub_), true);\n\n        emit SetModifiers(hookFeeModifier_, referralRewardModifier_);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// EIP-1271 compliance\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IERC1271\n    function isValidSignature(bytes32 hash, bytes memory signature)\n        external\n        view\n        override\n        returns (bytes4 magicValue)\n    {\n        // verify rebalance order\n        PoolId id = abi.decode(signature, (PoolId)); // we use the signature field to store the pool id\n        if (s.rebalanceOrderPermit2Hash[id] == hash) {\n            return this.isValidSignature.selector;\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// External functions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IBunniHook\n    function increaseCardinalityNext(PoolKey calldata key, uint32 cardinalityNext)\n        public\n        override\n        returns (uint32 cardinalityNextOld, uint32 cardinalityNextNew)\n    {\n        PoolId id = key.toId();\n\n        ObservationState storage state = s.states[id];\n\n        cardinalityNextOld = state.cardinalityNext;\n        cardinalityNextNew = s.observations[id].grow(cardinalityNextOld, cardinalityNext);\n        state.cardinalityNext = cardinalityNextNew;\n    }\n\n    /// @inheritdoc IBunniHook\n    function claimProtocolFees(Currency[] calldata currencyList) external override nonReentrant {\n        poolManager.unlock(abi.encode(HookUnlockCallbackType.CLAIM_FEES, abi.encode(currencyList)));\n    }\n\n    receive() external payable {}\n\n    /// -----------------------------------------------------------------------\n    /// Uniswap lock callback\n    /// -----------------------------------------------------------------------\n\n    enum HookUnlockCallbackType {\n        REBALANCE_PREHOOK,\n        REBALANCE_POSTHOOK,\n        CLAIM_FEES\n    }\n\n    /// @inheritdoc IUnlockCallback\n    function unlockCallback(bytes calldata data) external override poolManagerOnly returns (bytes memory) {\n        // decode input\n        (HookUnlockCallbackType t, bytes memory callbackData) = abi.decode(data, (HookUnlockCallbackType, bytes));\n\n        if (t == HookUnlockCallbackType.REBALANCE_PREHOOK) {\n            _rebalancePrehookCallback(callbackData);\n        } else if (t == HookUnlockCallbackType.REBALANCE_POSTHOOK) {\n            _rebalancePosthookCallback(callbackData);\n        } else if (t == HookUnlockCallbackType.CLAIM_FEES) {\n            _claimFees(callbackData);\n        }\n        return bytes(\"\");\n    }\n\n    /// @dev Calls hub.hookHandleSwap to pull the rebalance swap input tokens from BunniHub.\n    /// Then burns PoolManager claim tokens and takes the underlying tokens from PoolManager.\n    /// Used while executing rebalance orders.\n    function _rebalancePrehookCallback(bytes memory callbackData) internal {\n        // decode data\n        (Currency currency, uint256 amount, PoolKey memory key, bool zeroForOne) =\n            abi.decode(callbackData, (Currency, uint256, PoolKey, bool));\n\n        // pull claim tokens from BunniHub\n        hub.hookHandleSwap({key: key, zeroForOne: zeroForOne, inputAmount: 0, outputAmount: amount});\n\n        // lock BunniHub to prevent reentrancy\n        hub.lockForRebalance(key);\n\n        // burn and take\n        poolManager.burn(address(this), currency.toId(), amount);\n        poolManager.take(currency, address(this), amount);\n    }\n\n    /// @dev Settles tokens sent to PoolManager and mints the corresponding claim tokens.\n    /// Then calls hub.hookHandleSwap to update pool balances with rebalance swap output.\n    /// Used while executing rebalance orders.\n    function _rebalancePosthookCallback(bytes memory callbackData) internal {\n        // decode data\n        (Currency currency, uint256 amount, PoolKey memory key, bool zeroForOne) =\n            abi.decode(callbackData, (Currency, uint256, PoolKey, bool));\n\n        // sync poolManager balance and transfer the output tokens to poolManager\n        poolManager.sync(currency);\n        if (!currency.isAddressZero()) {\n            Currency.unwrap(currency).safeTransfer(address(poolManager), amount);\n        }\n\n        // settle the transferred tokens and mint claim tokens\n        uint256 paid = poolManager.settle{value: currency.isAddressZero() ? amount : 0}();\n        poolManager.mint(address(this), currency.toId(), paid);\n\n        // unlock BunniHub\n        hub.unlockForRebalance(key);\n\n        // push claim tokens to BunniHub\n        hub.hookHandleSwap({key: key, zeroForOne: zeroForOne, inputAmount: paid, outputAmount: 0});\n    }\n\n    /// @dev Claims protocol fees earned and sends it to the recipient.\n    function _claimFees(bytes memory callbackData) internal {\n        // decode data\n        Currency[] memory currencyList = abi.decode(callbackData, (Currency[]));\n        address recipient = hookFeeRecipient;\n\n        // claim protocol fees\n        for (uint256 i; i < currencyList.length; i++) {\n            Currency currency = currencyList[i];\n            // can claim balance - am-AMM accrued fees\n            uint256 balance = poolManager.balanceOf(address(this), currency.toId()) - _totalFees[currency];\n            if (balance != 0) {\n                poolManager.burn(address(this), currency.toId(), balance);\n                if (currency.isAddressZero()) {\n                    // convert ETH to WETH and send to recipient\n                    poolManager.take(currency, address(this), balance);\n                    weth.deposit{value: balance}();\n                    weth.transfer(recipient, balance);\n                } else {\n                    // take tokens directly to recipient\n                    poolManager.take(currency, recipient, balance);\n                }\n            }\n        }\n\n        emit ClaimProtocolFees(currencyList, recipient);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// BunniHub functions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IBunniHook\n    function updateLdfState(PoolId id, bytes32 newState) external override {\n        if (msg.sender != address(hub)) revert BunniHook__Unauthorized();\n\n        s.ldfStates[id] = newState;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Owner functions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IBunniHook\n    function setZone(IZone zone) external onlyOwner {\n        floodZone = zone;\n        emit SetZone(zone);\n    }\n\n    function setHookFeeRecipient(address newHookFeeRecipient) external onlyOwner {\n        hookFeeRecipient = newHookFeeRecipient;\n        emit SetHookFeeRecipient(newHookFeeRecipient);\n    }\n\n    /// @inheritdoc IBunniHook\n    function setModifiers(uint32 newHookFeeModifier, uint32 newReferralRewardModifier) external onlyOwner {\n        if (newHookFeeModifier > MODIFIER_BASE || newReferralRewardModifier > MODIFIER_BASE) {\n            revert BunniHook__InvalidModifier();\n        }\n\n        hookFeeModifier = newHookFeeModifier;\n        referralRewardModifier = newReferralRewardModifier;\n\n        emit SetModifiers(newHookFeeModifier, newReferralRewardModifier);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// View functions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IBunniHook\n    function getObservation(PoolKey calldata key, uint256 index)\n        external\n        view\n        override\n        returns (Oracle.Observation memory observation)\n    {\n        observation = s.observations[key.toId()][index];\n    }\n\n    /// @inheritdoc IBunniHook\n    function getState(PoolKey calldata key) external view override returns (ObservationState memory state) {\n        state = s.states[key.toId()];\n    }\n\n    /// @inheritdoc IBunniHook\n    function observe(PoolKey calldata key, uint32[] calldata secondsAgos)\n        external\n        view\n        override\n        returns (int56[] memory tickCumulatives)\n    {\n        return BunniHookLogic.observe(s, key, secondsAgos);\n    }\n\n    /// @inheritdoc IBunniHook\n    function isValidParams(bytes calldata hookParams) external pure override returns (bool) {\n        return BunniHookLogic.isValidParams(hookParams);\n    }\n\n    /// @inheritdoc IBunniHook\n    function getAmAmmEnabled(PoolId id) external view override returns (bool) {\n        return _amAmmEnabled(id);\n    }\n\n    /// @inheritdoc IBunniHook\n    function ldfStates(PoolId id) external view returns (bytes32) {\n        return s.ldfStates[id];\n    }\n\n    /// @inheritdoc IBunniHook\n    function slot0s(PoolId id)\n        external\n        view\n        returns (uint160 sqrtPriceX96, int24 tick, uint32 lastSwapTimestamp, uint32 lastSurgeTimestamp)\n    {\n        Slot0 memory slot0 = s.slot0s[id];\n        return (slot0.sqrtPriceX96, slot0.tick, slot0.lastSwapTimestamp, slot0.lastSurgeTimestamp);\n    }\n\n    /// @inheritdoc IBunniHook\n    function vaultSharePricesAtLastSwap(PoolId id)\n        external\n        view\n        returns (bool initialized, uint120 sharePrice0, uint120 sharePrice1)\n    {\n        VaultSharePrices memory prices = s.vaultSharePricesAtLastSwap[id];\n        return (prices.initialized, prices.sharePrice0, prices.sharePrice1);\n    }\n\n    /// @inheritdoc IBunniHook\n    function canWithdraw(PoolId id) external view returns (bool) {\n        return block.timestamp > s.rebalanceOrderDeadline[id];\n    }\n\n    /// @inheritdoc IBunniHook\n    function getHookFeeRecipient() external view returns (address) {\n        return hookFeeRecipient;\n    }\n\n    /// @inheritdoc IBunniHook\n    function getModifiers() external view returns (uint32 hookFeeModifier_, uint32 referralRewardModifier_) {\n        return (hookFeeModifier, referralRewardModifier);\n    }\n\n    /// @inheritdoc IBunniHook\n    function getClaimableHookFees(Currency[] calldata currencyList)\n        external\n        view\n        returns (uint256[] memory feeAmounts)\n    {\n        feeAmounts = new uint256[](currencyList.length);\n        for (uint256 i; i < currencyList.length; i++) {\n            // can claim balance - am-AMM accrued fees\n            Currency currency = currencyList[i];\n            feeAmounts[i] = poolManager.balanceOf(address(this), currency.toId()) - _totalFees[currency];\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Hooks\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IBaseHook\n    function afterInitialize(address caller, PoolKey calldata key, uint160 sqrtPriceX96, int24 tick)\n        external\n        override(BaseHook, IBaseHook)\n        poolManagerOnly\n        returns (bytes4)\n    {\n        BunniHookLogic.afterInitialize(s, caller, key, sqrtPriceX96, tick, hub);\n        return BunniHook.afterInitialize.selector;\n    }\n\n    /// @inheritdoc IBaseHook\n    function beforeSwap(address sender, PoolKey calldata key, IPoolManager.SwapParams calldata params, bytes calldata)\n        external\n        override(BaseHook, IBaseHook)\n        poolManagerOnly\n        nonReentrant\n        returns (bytes4, BeforeSwapDelta, uint24)\n    {\n        (\n            bool useAmAmmFee,\n            address amAmmManager,\n            Currency amAmmFeeCurrency,\n            uint256 amAmmFeeAmount,\n            BeforeSwapDelta beforeSwapDelta\n        ) = BunniHookLogic.beforeSwap(\n            s,\n            BunniHookLogic.Env({\n                hookFeeModifier: hookFeeModifier,\n                referralRewardModifier: referralRewardModifier,\n                floodZone: floodZone,\n                hub: hub,\n                poolManager: poolManager,\n                floodPlain: floodPlain,\n                weth: weth,\n                permit2: permit2\n            }),\n            sender,\n            key,\n            params\n        );\n\n        // accrue swap fee to the am-AMM manager if present\n        if (useAmAmmFee) {\n            _accrueFees(amAmmManager, amAmmFeeCurrency, amAmmFeeAmount);\n        }\n\n        return (BunniHook.beforeSwap.selector, beforeSwapDelta, 0);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Rebalancing functions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IBunniHook\n    function rebalanceOrderPreHook(RebalanceOrderHookArgs calldata hookArgs) external override nonReentrant {\n        // verify call came from Flood\n        if (msg.sender != address(floodPlain)) {\n            revert BunniHook__Unauthorized();\n        }\n\n        PoolId id = hookArgs.key.toId();\n\n        // verify the order hash originated from BunniHook\n        // this also verifies hookArgs is valid since it's hashed into the order hash\n        bytes32 orderHash;\n        // orderHash = bytes32(msg.data[msg.data.length - 32:msg.data.length]);\n        assembly (\"memory-safe\") {\n            orderHash := calldataload(sub(calldatasize(), 32))\n        }\n        if (s.rebalanceOrderHash[id] != orderHash) {\n            revert BunniHook__InvalidRebalanceOrderHash();\n        }\n\n        RebalanceOrderPreHookArgs calldata args = hookArgs.preHookArgs;\n\n        // store the order output balance before the order execution in transient storage\n        // this is used to compute the order output amount\n        uint256 outputBalanceBefore = hookArgs.postHookArgs.currency.isAddressZero()\n            ? weth.balanceOf(address(this))\n            : hookArgs.postHookArgs.currency.balanceOfSelf();\n        assembly (\"memory-safe\") {\n            tstore(REBALANCE_OUTPUT_BALANCE_SLOT, outputBalanceBefore)\n        }\n\n        // pull input tokens from BunniHub to BunniHook\n        // received in the form of PoolManager claim tokens\n        // then unwrap claim tokens\n        poolManager.unlock(\n            abi.encode(\n                HookUnlockCallbackType.REBALANCE_PREHOOK,\n                abi.encode(args.currency, args.amount, hookArgs.key, hookArgs.key.currency1 == args.currency)\n            )\n        );\n\n        // ensure we have at least args.amount tokens so that there is enough input for the order\n        if (args.currency.balanceOfSelf() < args.amount) {\n            revert BunniHook__PrehookPostConditionFailed();\n        }\n\n        // wrap native ETH input to WETH\n        // we're implicitly trusting the WETH contract won't charge a fee which is OK in practice\n        if (args.currency.isAddressZero()) {\n            weth.deposit{value: args.amount}();\n        }\n    }\n\n    /// @inheritdoc IBunniHook\n    function rebalanceOrderPostHook(RebalanceOrderHookArgs calldata hookArgs) external override nonReentrant {\n        // verify call came from Flood\n        if (msg.sender != address(floodPlain)) {\n            revert BunniHook__Unauthorized();\n        }\n\n        PoolId id = hookArgs.key.toId();\n\n        // verify the order hash originated from BunniHook\n        // this also verifies hookArgs is valid since it's hashed into the order hash\n        bytes32 orderHash;\n        // orderHash = bytes32(msg.data[msg.data.length - 32:msg.data.length]);\n        assembly (\"memory-safe\") {\n            orderHash := calldataload(sub(calldatasize(), 32))\n        }\n        if (s.rebalanceOrderHash[id] != orderHash) {\n            revert BunniHook__InvalidRebalanceOrderHash();\n        }\n\n        // invalidate the rebalance order\n        delete s.rebalanceOrderHash[id];\n        delete s.rebalanceOrderPermit2Hash[id];\n        delete s.rebalanceOrderDeadline[id];\n\n        // surge fee should be applied after the rebalance has been executed\n        // since totalLiquidity will be increased\n        // no need to check surgeFeeAutostartThreshold since we just increased the liquidity in this tx\n        // so block.timestamp is the exact time when the surge should occur\n        s.slot0s[id].lastSwapTimestamp = uint32(block.timestamp);\n        s.slot0s[id].lastSurgeTimestamp = uint32(block.timestamp);\n\n        RebalanceOrderPostHookArgs calldata args = hookArgs.postHookArgs;\n\n        // compute order output amount by computing the difference in the output token balance\n        uint256 orderOutputAmount;\n        uint256 outputBalanceBefore;\n        assembly (\"memory-safe\") {\n            outputBalanceBefore := tload(REBALANCE_OUTPUT_BALANCE_SLOT)\n        }\n        if (args.currency.isAddressZero()) {\n            // unwrap WETH output to native ETH\n            orderOutputAmount = weth.balanceOf(address(this));\n            weth.withdraw(orderOutputAmount);\n        } else {\n            orderOutputAmount = args.currency.balanceOfSelf();\n        }\n        orderOutputAmount -= outputBalanceBefore;\n\n        // posthook should wrap output tokens as claim tokens and push it from BunniHook to BunniHub and update pool balances\n        poolManager.unlock(\n            abi.encode(\n                HookUnlockCallbackType.REBALANCE_POSTHOOK,\n                abi.encode(args.currency, orderOutputAmount, hookArgs.key, hookArgs.key.currency0 == args.currency)\n            )\n        );\n\n        // recompute idle balance\n        BunniHookLogic.recomputeIdleBalance(s, hub, hookArgs.key);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// AmAmm support\n    /// -----------------------------------------------------------------------\n\n    function K(PoolId) internal view virtual override returns (uint48) {\n        return _K;\n    }\n\n    function MIN_RENT(PoolId id) internal view virtual override returns (uint128) {\n        // minimum rent should be propotional to the pool's BunniToken total supply\n        bytes memory hookParams = hub.hookParams(id);\n        bytes32 secondWord;\n        /// @solidity memory-safe-assembly\n        assembly {\n            secondWord := mload(add(hookParams, 64))\n        }\n        uint48 minRentMultiplier = uint48(bytes6(secondWord << 32));\n        uint256 minRent = hub.bunniTokenOfPool(id).totalSupply().mulWadUp(minRentMultiplier);\n\n        // if the min rent value is somehow more than uint128.max, cap it to uint128.max\n        return minRent > type(uint128).max ? type(uint128).max : uint128(minRent);\n    }\n\n    /// @dev precedence is poolOverride > globalOverride > poolEnabled\n    function _amAmmEnabled(PoolId id) internal view virtual override returns (bool) {\n        bytes memory hookParams = hub.hookParams(id);\n        bytes32 firstWord;\n        /// @solidity memory-safe-assembly\n        assembly {\n            firstWord := mload(add(hookParams, 32))\n        }\n        bool poolEnabled = uint8(bytes1(firstWord << 248)) != 0;\n        return poolEnabled;\n    }\n\n    function _payloadIsValid(PoolId id, bytes6 payload) internal view virtual override returns (bool) {\n        // use feeMax from hookParams\n        bytes memory hookParams = hub.hookParams(id);\n        bytes32 firstWord;\n        /// @solidity memory-safe-assembly\n        assembly {\n            firstWord := mload(add(hookParams, 32))\n        }\n        uint24 maxAmAmmFee = uint24(bytes3(firstWord << 96));\n\n        // payload is valid if swapFee0For1 and swapFee1For0 are at most maxAmAmmFee\n        (uint24 swapFee0For1, uint24 swapFee1For0) = decodeAmAmmPayload(payload);\n        return swapFee0For1 <= maxAmAmmFee && swapFee1For0 <= maxAmAmmFee;\n    }\n\n    function _burnBidToken(PoolId id, uint256 amount) internal virtual override {\n        hub.bunniTokenOfPool(id).burn(amount);\n    }\n\n    function _pullBidToken(PoolId id, address from, uint256 amount) internal virtual override {\n        hub.bunniTokenOfPool(id).transferFrom(from, address(this), amount);\n    }\n\n    function _pushBidToken(PoolId id, address to, uint256 amount) internal virtual override {\n        hub.bunniTokenOfPool(id).transfer(to, amount);\n    }\n\n    function _transferFeeToken(Currency currency, address to, uint256 amount) internal virtual override {\n        poolManager.transfer(to, currency.toId(), amount);\n    }\n}\n"}, "src/lib/HookletLib.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\nimport {TickMath} from \"@uniswap/v4-core/src/libraries/TickMath.sol\";\nimport {CustomRevert} from \"@uniswap/v4-core/src/libraries/CustomRevert.sol\";\nimport {IPoolManager, PoolKey} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport \"../base/Constants.sol\";\nimport {IHooklet} from \"../interfaces/IHooklet.sol\";\nimport {IBunniHub} from \"../interfaces/IBunniHub.sol\";\nimport {IBunniToken} from \"../interfaces/IBunniToken.sol\";\n\n/// @dev Adapted from Uniswap v4's Hooks.sol\nlibrary HookletLib {\n    using CustomRevert for bytes4;\n    using HookletLib for IHooklet;\n    using FixedPointMathLib for *;\n\n    uint160 internal constant ALL_FLAGS_MASK = 0xFFF;\n    uint160 internal constant BEFORE_TRANSFER_FLAG = 1 << 11;\n    uint160 internal constant AFTER_TRANSFER_FLAG = 1 << 10;\n    uint160 internal constant BEFORE_INITIALIZE_FLAG = 1 << 9;\n    uint160 internal constant AFTER_INITIALIZE_FLAG = 1 << 8;\n    uint160 internal constant BEFORE_DEPOSIT_FLAG = 1 << 7;\n    uint160 internal constant AFTER_DEPOSIT_FLAG = 1 << 6;\n    uint160 internal constant BEFORE_WITHDRAW_FLAG = 1 << 5;\n    uint160 internal constant AFTER_WITHDRAW_FLAG = 1 << 4;\n    uint160 internal constant BEFORE_SWAP_FLAG = 1 << 3;\n    uint160 internal constant BEFORE_SWAP_OVERRIDE_FEE_FLAG = 1 << 2;\n    uint160 internal constant BEFORE_SWAP_OVERRIDE_PRICE_FLAG = 1 << 1;\n    uint160 internal constant AFTER_SWAP_FLAG = 1;\n\n    error HookletLib__FailedHookletCall();\n    error HookletLib__InvalidHookletResponse();\n\n    function callHooklet(IHooklet self, bytes4 selector, bytes memory data) internal returns (bytes memory result) {\n        bytes4 decodedSelector;\n        assembly (\"memory-safe\") {\n            if iszero(call(gas(), self, 0, add(data, 0x20), mload(data), 0, 0)) {\n                if iszero(returndatasize()) {\n                    // if the call failed without a revert reason, revert with `HookletLib__FailedHookletCall()`\n                    mstore(0, 0x855e32e7)\n                    revert(0x1c, 0x04)\n                }\n                // bubble up revert\n                let fmp := mload(0x40)\n                returndatacopy(fmp, 0, returndatasize())\n                revert(fmp, returndatasize())\n            }\n            // allocate result byte array from the free memory pointer\n            result := mload(0x40)\n            // store new free memory pointer at the end of the array padded to 32 bytes\n            mstore(0x40, add(result, and(add(returndatasize(), 0x3f), not(0x1f))))\n            // store length in memory\n            mstore(result, returndatasize())\n            // copy return data to result\n            returndatacopy(add(result, 0x20), 0, returndatasize())\n            // get the selector from the return data\n            decodedSelector := mload(add(result, 0x20))\n        }\n        if (decodedSelector != selector) HookletLib__InvalidHookletResponse.selector.revertWith();\n    }\n\n    function staticcallHooklet(IHooklet self, bytes4 selector, bytes memory data)\n        internal\n        view\n        returns (bool success, bytes memory result)\n    {\n        bytes4 decodedSelector;\n        assembly (\"memory-safe\") {\n            switch staticcall(gas(), self, add(data, 0x20), mload(data), 0, 0)\n            case 0 {\n                // call reverted, set success to false\n                success := 0\n            }\n            default {\n                // call succeeded, set success to true\n                success := 1\n                // allocate result byte array from the free memory pointer\n                result := mload(0x40)\n                // store new free memory pointer at the end of the array padded to 32 bytes\n                mstore(0x40, add(result, and(add(returndatasize(), 0x3f), not(0x1f))))\n                // store length in memory\n                mstore(result, returndatasize())\n                // copy return data to result\n                returndatacopy(add(result, 0x20), 0, returndatasize())\n                // get the selector from the return data\n                decodedSelector := mload(add(result, 0x20))\n            }\n        }\n        if (decodedSelector != selector) return (false, bytes(\"\"));\n    }\n\n    modifier noSelfCall(IHooklet self, address sender) {\n        if (sender != address(self)) {\n            _;\n        }\n    }\n\n    /// @dev The hasPermission check is done outside of this function in order to avoid unnecessarily constructing `key`\n    function hookletBeforeTransfer(\n        IHooklet self,\n        address sender,\n        PoolKey memory key,\n        IBunniToken bunniToken,\n        address from,\n        address to,\n        uint256 amount\n    ) internal noSelfCall(self, sender) {\n        self.callHooklet(\n            IHooklet.beforeTransfer.selector,\n            abi.encodeCall(IHooklet.beforeTransfer, (sender, key, bunniToken, from, to, amount))\n        );\n    }\n\n    /// @dev The hasPermission check is done outside of this function in order to avoid unnecessarily constructing `key`\n    function hookletAfterTransfer(\n        IHooklet self,\n        address sender,\n        PoolKey memory key,\n        IBunniToken bunniToken,\n        address from,\n        address to,\n        uint256 amount\n    ) internal noSelfCall(self, sender) {\n        self.callHooklet(\n            IHooklet.afterTransfer.selector,\n            abi.encodeCall(IHooklet.afterTransfer, (sender, key, bunniToken, from, to, amount))\n        );\n    }\n\n    function hookletBeforeInitialize(IHooklet self, address sender, IBunniHub.DeployBunniTokenParams calldata params)\n        internal\n        noSelfCall(self, sender)\n    {\n        if (self.hasPermission(BEFORE_INITIALIZE_FLAG)) {\n            self.callHooklet(\n                IHooklet.beforeInitialize.selector, abi.encodeCall(IHooklet.beforeInitialize, (sender, params))\n            );\n        }\n    }\n\n    function hookletAfterInitialize(\n        IHooklet self,\n        address sender,\n        IBunniHub.DeployBunniTokenParams calldata params,\n        IHooklet.InitializeReturnData memory returnData\n    ) internal noSelfCall(self, sender) {\n        if (self.hasPermission(AFTER_INITIALIZE_FLAG)) {\n            self.callHooklet(\n                IHooklet.afterInitialize.selector,\n                abi.encodeCall(IHooklet.afterInitialize, (sender, params, returnData))\n            );\n        }\n    }\n\n    function hookletBeforeDeposit(IHooklet self, address sender, IBunniHub.DepositParams calldata params)\n        internal\n        noSelfCall(self, sender)\n    {\n        if (self.hasPermission(BEFORE_DEPOSIT_FLAG)) {\n            self.callHooklet(IHooklet.beforeDeposit.selector, abi.encodeCall(IHooklet.beforeDeposit, (sender, params)));\n        }\n    }\n\n    function hookletBeforeDepositView(IHooklet self, address sender, IBunniHub.DepositParams calldata params)\n        internal\n        view\n        noSelfCall(self, sender)\n        returns (bool success)\n    {\n        if (self.hasPermission(BEFORE_DEPOSIT_FLAG)) {\n            (success,) = self.staticcallHooklet(\n                IHooklet.beforeDepositView.selector, abi.encodeCall(IHooklet.beforeDepositView, (sender, params))\n            );\n        } else {\n            success = true;\n        }\n    }\n\n    function hookletAfterDeposit(\n        IHooklet self,\n        address sender,\n        IBunniHub.DepositParams calldata params,\n        IHooklet.DepositReturnData memory returnData\n    ) internal noSelfCall(self, sender) {\n        if (self.hasPermission(AFTER_DEPOSIT_FLAG)) {\n            self.callHooklet(\n                IHooklet.afterDeposit.selector, abi.encodeCall(IHooklet.afterDeposit, (sender, params, returnData))\n            );\n        }\n    }\n\n    function hookletAfterDepositView(\n        IHooklet self,\n        address sender,\n        IBunniHub.DepositParams calldata params,\n        IHooklet.DepositReturnData memory returnData\n    ) internal view noSelfCall(self, sender) returns (bool success) {\n        if (self.hasPermission(AFTER_DEPOSIT_FLAG)) {\n            (success,) = self.staticcallHooklet(\n                IHooklet.afterDepositView.selector,\n                abi.encodeCall(IHooklet.afterDepositView, (sender, params, returnData))\n            );\n        } else {\n            success = true;\n        }\n    }\n\n    function hookletBeforeWithdraw(IHooklet self, address sender, IBunniHub.WithdrawParams calldata params)\n        internal\n        noSelfCall(self, sender)\n    {\n        if (self.hasPermission(BEFORE_WITHDRAW_FLAG)) {\n            self.callHooklet(\n                IHooklet.beforeWithdraw.selector, abi.encodeCall(IHooklet.beforeWithdraw, (sender, params))\n            );\n        }\n    }\n\n    function hookletBeforeWithdrawView(IHooklet self, address sender, IBunniHub.WithdrawParams calldata params)\n        internal\n        view\n        noSelfCall(self, sender)\n        returns (bool success)\n    {\n        if (self.hasPermission(BEFORE_WITHDRAW_FLAG)) {\n            (success,) = self.staticcallHooklet(\n                IHooklet.beforeWithdrawView.selector, abi.encodeCall(IHooklet.beforeWithdrawView, (sender, params))\n            );\n        } else {\n            success = true;\n        }\n    }\n\n    function hookletAfterWithdraw(\n        IHooklet self,\n        address sender,\n        IBunniHub.WithdrawParams calldata params,\n        IHooklet.WithdrawReturnData memory returnData\n    ) internal noSelfCall(self, sender) {\n        if (self.hasPermission(AFTER_WITHDRAW_FLAG)) {\n            self.callHooklet(\n                IHooklet.afterWithdraw.selector, abi.encodeCall(IHooklet.afterWithdraw, (sender, params, returnData))\n            );\n        }\n    }\n\n    function hookletAfterWithdrawView(\n        IHooklet self,\n        address sender,\n        IBunniHub.WithdrawParams calldata params,\n        IHooklet.WithdrawReturnData memory returnData\n    ) internal view noSelfCall(self, sender) returns (bool success) {\n        if (self.hasPermission(AFTER_WITHDRAW_FLAG)) {\n            (success,) = self.staticcallHooklet(\n                IHooklet.afterWithdrawView.selector,\n                abi.encodeCall(IHooklet.afterWithdrawView, (sender, params, returnData))\n            );\n        } else {\n            success = true;\n        }\n    }\n\n    function hookletBeforeSwap(\n        IHooklet self,\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params\n    )\n        internal\n        noSelfCall(self, sender)\n        returns (bool feeOverridden, uint24 fee, bool priceOverridden, uint160 sqrtPriceX96)\n    {\n        if (self.hasPermission(BEFORE_SWAP_FLAG)) {\n            bytes memory result = self.callHooklet(\n                IHooklet.beforeSwap.selector, abi.encodeCall(IHooklet.beforeSwap, (sender, key, params))\n            );\n            (bool canOverrideFee, bool canOverridePrice) =\n                (self.hasPermission(BEFORE_SWAP_OVERRIDE_FEE_FLAG), self.hasPermission(BEFORE_SWAP_OVERRIDE_PRICE_FLAG));\n            if (canOverrideFee || canOverridePrice) {\n                // parse override data\n                // equivalent to the following Solidity code:\n                // (,feeOverridden, fee, priceOverridden, sqrtPriceX96) = abi.decode(result, (bytes4, bool, uint24, bool, uint160));\n                /// @solidity memory-safe-assembly\n                assembly {\n                    feeOverridden := mload(add(result, 0x40))\n                    fee := mload(add(result, 0x60))\n                    priceOverridden := mload(add(result, 0x80))\n                    sqrtPriceX96 := mload(add(result, 0xA0))\n                }\n\n                // ensure that the hooklet is allowed to override the fee and/or price\n                // if the hooklet doesn't have a permission but the override is set, the override is ignored\n                feeOverridden = canOverrideFee && feeOverridden;\n                priceOverridden = canOverridePrice && priceOverridden;\n\n                // clamp the override values to the valid range\n                fee = feeOverridden ? uint24(fee.clamp(0, SWAP_FEE_BASE)) : 0;\n                sqrtPriceX96 =\n                    priceOverridden ? uint160(sqrtPriceX96.clamp(TickMath.MIN_SQRT_PRICE, TickMath.MAX_SQRT_PRICE)) : 0;\n            }\n        }\n    }\n\n    function hookletBeforeSwapView(\n        IHooklet self,\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params\n    )\n        internal\n        view\n        noSelfCall(self, sender)\n        returns (bool success, bool feeOverridden, uint24 fee, bool priceOverridden, uint160 sqrtPriceX96)\n    {\n        if (\n            self.hasPermission(BEFORE_SWAP_FLAG)\n                && (\n                    self.hasPermission(BEFORE_SWAP_OVERRIDE_FEE_FLAG) || self.hasPermission(BEFORE_SWAP_OVERRIDE_PRICE_FLAG)\n                )\n        ) {\n            bytes memory result;\n            (success, result) = self.staticcallHooklet(\n                IHooklet.beforeSwapView.selector, abi.encodeCall(IHooklet.beforeSwapView, (sender, key, params))\n            );\n            if (!success) return (false, false, 0, false, 0);\n            (bool canOverrideFee, bool canOverridePrice) =\n                (self.hasPermission(BEFORE_SWAP_OVERRIDE_FEE_FLAG), self.hasPermission(BEFORE_SWAP_OVERRIDE_PRICE_FLAG));\n\n            // parse override data\n            // equivalent to the following Solidity code:\n            // (,feeOverridden, fee, priceOverridden, sqrtPriceX96) = abi.decode(result, (bytes4, bool, uint24, bool, uint160));\n            /// @solidity memory-safe-assembly\n            assembly {\n                feeOverridden := mload(add(result, 0x40))\n                fee := mload(add(result, 0x60))\n                priceOverridden := mload(add(result, 0x80))\n                sqrtPriceX96 := mload(add(result, 0xA0))\n            }\n\n            // ensure that the hooklet is allowed to override the fee and/or price\n            // if the hooklet doesn't have a permission but the override is set, the override is ignored\n            feeOverridden = canOverrideFee && feeOverridden;\n            priceOverridden = canOverridePrice && priceOverridden;\n\n            // clamp the override values to the valid range\n            fee = feeOverridden ? uint24(fee.clamp(0, SWAP_FEE_BASE)) : 0;\n            sqrtPriceX96 =\n                priceOverridden ? uint160(sqrtPriceX96.clamp(TickMath.MIN_SQRT_PRICE, TickMath.MAX_SQRT_PRICE)) : 0;\n        } else {\n            return (true, false, 0, false, 0);\n        }\n    }\n\n    /// @dev The hasPermission check is done outside of this function in order to avoid unnecessarily constructing returnData\n    /// when calling it.\n    function hookletAfterSwap(\n        IHooklet self,\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        IHooklet.SwapReturnData memory returnData\n    ) internal noSelfCall(self, sender) {\n        self.callHooklet(\n            IHooklet.afterSwap.selector, abi.encodeCall(IHooklet.afterSwap, (sender, key, params, returnData))\n        );\n    }\n\n    function hookletAfterSwapView(\n        IHooklet self,\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        IHooklet.SwapReturnData memory returnData\n    ) internal view noSelfCall(self, sender) returns (bool success) {\n        if (self.hasPermission(AFTER_SWAP_FLAG)) {\n            (success,) = self.staticcallHooklet(\n                IHooklet.afterSwapView.selector,\n                abi.encodeCall(IHooklet.afterSwapView, (sender, key, params, returnData))\n            );\n        } else {\n            success = true;\n        }\n    }\n\n    function hasPermission(IHooklet self, uint160 flag) internal pure returns (bool) {\n        return uint160(address(self)) & flag != 0;\n    }\n}\n"}, "src/lib/BunniSwapMath.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport {TickMath} from \"@uniswap/v4-core/src/libraries/TickMath.sol\";\nimport {IPoolManager, PoolKey} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\n\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport \"./Math.sol\";\nimport \"../base/Errors.sol\";\nimport \"../base/Constants.sol\";\nimport \"../types/IdleBalance.sol\";\nimport {SwapMath} from \"./SwapMath.sol\";\nimport {queryLDF} from \"./QueryLDF.sol\";\nimport {FullMathX96} from \"./FullMathX96.sol\";\nimport {SqrtPriceMath} from \"./SqrtPriceMath.sol\";\nimport {LiquidityAmounts} from \"./LiquidityAmounts.sol\";\nimport {ILiquidityDensityFunction} from \"../interfaces/ILiquidityDensityFunction.sol\";\n\nlibrary BunniSwapMath {\n    using TickMath for *;\n    using FullMathX96 for *;\n    using SafeCastLib for uint256;\n    using FixedPointMathLib for uint256;\n\n    struct BunniComputeSwapInput {\n        PoolKey key;\n        uint256 totalLiquidity;\n        uint256 liquidityDensityOfRoundedTickX96;\n        uint256 currentActiveBalance0;\n        uint256 currentActiveBalance1;\n        uint160 sqrtPriceX96;\n        int24 currentTick;\n        ILiquidityDensityFunction liquidityDensityFunction;\n        int24 arithmeticMeanTick;\n        bytes32 ldfParams;\n        bytes32 ldfState;\n        IPoolManager.SwapParams swapParams;\n    }\n\n    /// @notice Computes the result of a swap given the input parameters\n    /// @param input The input parameters for the swap\n    /// @return updatedSqrtPriceX96 The updated sqrt price after the swap\n    /// @return updatedTick The updated tick after the swap\n    /// @return inputAmount The input amount of the swap\n    /// @return outputAmount The output amount of the swap\n    function computeSwap(BunniComputeSwapInput calldata input)\n        external\n        view\n        returns (uint160 updatedSqrtPriceX96, int24 updatedTick, uint256 inputAmount, uint256 outputAmount)\n    {\n        bool zeroForOne = input.swapParams.zeroForOne;\n        bool exactIn = input.swapParams.amountSpecified < 0;\n\n        // initialize input and output amounts based on initial info\n        inputAmount = exactIn ? uint256(-input.swapParams.amountSpecified) : 0;\n        outputAmount = exactIn ? 0 : uint256(input.swapParams.amountSpecified);\n\n        // compute updated rounded tick liquidity\n        uint256 updatedRoundedTickLiquidity = (input.totalLiquidity * input.liquidityDensityOfRoundedTickX96) >> 96;\n\n        // initialize updatedTick to the current tick\n        updatedTick = input.currentTick;\n\n        // bound sqrtPriceLimitX96 by min/max possible values\n        uint160 sqrtPriceLimitX96 = input.swapParams.sqrtPriceLimitX96;\n        {\n            (uint160 minSqrtPrice, uint160 maxSqrtPrice) = (\n                TickMath.minUsableTick(input.key.tickSpacing).getSqrtPriceAtTick(),\n                TickMath.maxUsableTick(input.key.tickSpacing).getSqrtPriceAtTick()\n            );\n            // bound sqrtPriceLimit so that we never end up at an invalid rounded tick\n            if ((zeroForOne && sqrtPriceLimitX96 <= minSqrtPrice) || (!zeroForOne && sqrtPriceLimitX96 >= maxSqrtPrice))\n            {\n                sqrtPriceLimitX96 = zeroForOne ? minSqrtPrice + 1 : maxSqrtPrice - 1;\n            }\n        }\n\n        {\n            (int24 roundedTick, int24 nextRoundedTick) = roundTick(input.currentTick, input.key.tickSpacing);\n            uint160 naiveSwapResultSqrtPriceX96;\n            uint256 naiveSwapAmountIn;\n            uint256 naiveSwapAmountOut;\n            {\n                // handle the special case when we don't cross rounded ticks\n                if (updatedRoundedTickLiquidity != 0) {\n                    // compute the resulting sqrt price using Uniswap math\n                    int24 tickNext = zeroForOne ? roundedTick : nextRoundedTick;\n                    uint160 sqrtPriceNextX96 = TickMath.getSqrtPriceAtTick(tickNext);\n                    (naiveSwapResultSqrtPriceX96, naiveSwapAmountIn, naiveSwapAmountOut) = SwapMath.computeSwapStep({\n                        sqrtPriceCurrentX96: input.sqrtPriceX96,\n                        sqrtPriceTargetX96: SwapMath.getSqrtPriceTarget(zeroForOne, sqrtPriceNextX96, sqrtPriceLimitX96),\n                        liquidity: updatedRoundedTickLiquidity,\n                        amountRemaining: input.swapParams.amountSpecified\n                    });\n\n                    // check if naive swap exhausted the specified amount\n                    if (\n                        exactIn\n                            ? naiveSwapAmountIn == uint256(-input.swapParams.amountSpecified)\n                            : naiveSwapAmountOut == uint256(input.swapParams.amountSpecified)\n                    ) {\n                        // swap doesn't cross rounded tick\n\n                        // compute the updated tick\n                        // was initialized earlier as input.currentTick\n                        if (naiveSwapResultSqrtPriceX96 == sqrtPriceNextX96) {\n                            // Equivalent to `updatedTick = zeroForOne ? tickNext - 1 : tickNext;`\n                            unchecked {\n                                // cannot cast a bool to an int24 in Solidity\n                                int24 _zeroForOne;\n                                assembly {\n                                    _zeroForOne := zeroForOne\n                                }\n                                updatedTick = tickNext - _zeroForOne;\n                            }\n                        } else if (naiveSwapResultSqrtPriceX96 != input.sqrtPriceX96) {\n                            // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved\n                            updatedTick = TickMath.getTickAtSqrtPrice(naiveSwapResultSqrtPriceX96);\n                        }\n\n                        // naiveSwapAmountOut should be at most the corresponding active balance\n                        // this may be violated due to precision loss\n                        naiveSwapAmountOut = FixedPointMathLib.min(\n                            naiveSwapAmountOut, zeroForOne ? input.currentActiveBalance1 : input.currentActiveBalance0\n                        );\n\n                        // early return\n                        return (naiveSwapResultSqrtPriceX96, updatedTick, naiveSwapAmountIn, naiveSwapAmountOut);\n                    }\n                }\n            }\n\n            // swap crosses rounded tick\n            // need to use LDF to compute the swap\n            // compute updated sqrt ratio & tick\n            uint256 inverseCumulativeAmountFnInput;\n            if (exactIn) {\n                // exact input swap\n                inverseCumulativeAmountFnInput =\n                    zeroForOne ? input.currentActiveBalance0 + inputAmount : input.currentActiveBalance1 + inputAmount;\n            } else {\n                // exact output swap\n                inverseCumulativeAmountFnInput =\n                    zeroForOne ? input.currentActiveBalance1 - outputAmount : input.currentActiveBalance0 - outputAmount;\n            }\n\n            (\n                bool success,\n                int24 updatedRoundedTick,\n                uint256 cumulativeAmount0,\n                uint256 cumulativeAmount1,\n                uint256 swapLiquidity\n            ) = input.liquidityDensityFunction.computeSwap(\n                input.key,\n                inverseCumulativeAmountFnInput,\n                input.totalLiquidity,\n                zeroForOne,\n                exactIn,\n                input.arithmeticMeanTick,\n                input.currentTick,\n                input.ldfParams,\n                input.ldfState\n            );\n\n            if (success) {\n                // edge case: LDF says we're still in the same rounded tick\n                // or in a rounded tick in the opposite direction as the swap\n                // meaning first naive swap was insufficient but it should have been\n                // use the result from the first naive swap\n                if (zeroForOne ? updatedRoundedTick >= roundedTick : updatedRoundedTick <= roundedTick) {\n                    if (updatedRoundedTickLiquidity == 0) {\n                        // no liquidity, return trivial swap\n                        return (input.sqrtPriceX96, input.currentTick, 0, 0);\n                    }\n\n                    // compute the updated tick\n                    // was initialized earlier as input.currentTick\n                    int24 _tickNext = zeroForOne ? roundedTick : nextRoundedTick;\n                    if (naiveSwapResultSqrtPriceX96 == TickMath.getSqrtPriceAtTick(_tickNext)) {\n                        // Equivalent to `updatedTick = zeroForOne ? _tickNext - 1 : _tickNext;`\n                        unchecked {\n                            // cannot cast a bool to an int24 in Solidity\n                            int24 _zeroForOne;\n                            assembly {\n                                _zeroForOne := zeroForOne\n                            }\n                            updatedTick = _tickNext - _zeroForOne;\n                        }\n                    } else if (naiveSwapResultSqrtPriceX96 != input.sqrtPriceX96) {\n                        // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved\n                        updatedTick = TickMath.getTickAtSqrtPrice(naiveSwapResultSqrtPriceX96);\n                    }\n\n                    // naiveSwapAmountOut should be at most the corresponding active balance\n                    // this may be violated due to precision loss\n                    naiveSwapAmountOut = FixedPointMathLib.min(\n                        naiveSwapAmountOut, zeroForOne ? input.currentActiveBalance1 : input.currentActiveBalance0\n                    );\n\n                    // early return\n                    return (naiveSwapResultSqrtPriceX96, updatedTick, naiveSwapAmountIn, naiveSwapAmountOut);\n                }\n\n                // use Uniswap math to compute updated sqrt price\n                // the swap is called \"partial swap\"\n                // which always has the same exactIn and zeroForOne as the overall swap\n                (int24 tickStart, int24 tickNext) = zeroForOne\n                    ? (updatedRoundedTick + input.key.tickSpacing, updatedRoundedTick)\n                    : (updatedRoundedTick, updatedRoundedTick + input.key.tickSpacing);\n                uint160 startSqrtPriceX96 = tickStart.getSqrtPriceAtTick();\n\n                // make sure the price limit is not reached\n                if (\n                    (zeroForOne && sqrtPriceLimitX96 <= startSqrtPriceX96)\n                        || (!zeroForOne && sqrtPriceLimitX96 >= startSqrtPriceX96)\n                ) {\n                    uint160 sqrtPriceNextX96 = tickNext.getSqrtPriceAtTick();\n\n                    // adjust the cumulativeAmount of the input token to be at least the corresponding currentActiveBalance\n                    // we know that we're swapping in a different rounded tick as the starting one (based on the first naive swap)\n                    // so this should be true but sometimes isn't due to precision error which is why the adjustment is necessary\n                    if (zeroForOne) {\n                        cumulativeAmount0 = FixedPointMathLib.max(cumulativeAmount0, input.currentActiveBalance0);\n                    } else {\n                        cumulativeAmount1 = FixedPointMathLib.max(cumulativeAmount1, input.currentActiveBalance1);\n                    }\n\n                    // perform naive swap within the updated rounded tick\n                    bool hitSqrtPriceLimit;\n                    if (swapLiquidity == 0) {\n                        // no liquidity, don't move from the starting price\n                        (naiveSwapResultSqrtPriceX96, naiveSwapAmountIn, naiveSwapAmountOut) = (startSqrtPriceX96, 0, 0);\n                    } else {\n                        // has swap liquidity, use Uniswap math to compute updated sqrt price and input/output amounts\n                        int256 amountSpecifiedRemaining = exactIn\n                            ? -(inverseCumulativeAmountFnInput - (zeroForOne ? cumulativeAmount0 : cumulativeAmount1)).toInt256(\n                            )\n                            : ((zeroForOne ? cumulativeAmount1 : cumulativeAmount0) - inverseCumulativeAmountFnInput)\n                                .toInt256();\n                        (naiveSwapResultSqrtPriceX96, naiveSwapAmountIn, naiveSwapAmountOut) = SwapMath.computeSwapStep({\n                            sqrtPriceCurrentX96: startSqrtPriceX96,\n                            sqrtPriceTargetX96: SwapMath.getSqrtPriceTarget(zeroForOne, sqrtPriceNextX96, sqrtPriceLimitX96),\n                            liquidity: swapLiquidity,\n                            amountRemaining: amountSpecifiedRemaining\n                        });\n                        if (naiveSwapResultSqrtPriceX96 == sqrtPriceLimitX96 && sqrtPriceLimitX96 != sqrtPriceNextX96) {\n                            // give up if the swap hits the sqrt price limit\n                            hitSqrtPriceLimit = true;\n                        }\n                    }\n\n                    if (!hitSqrtPriceLimit) {\n                        // initialize updatedTick to tickStart\n                        updatedTick = tickStart;\n\n                        // compute updatedTick\n                        if (naiveSwapResultSqrtPriceX96 == sqrtPriceNextX96) {\n                            // Equivalent to `updatedTick = zeroForOne ? tickNext - 1 : tickNext;`\n                            unchecked {\n                                // cannot cast a bool to an int24 in Solidity\n                                int24 _zeroForOne;\n                                assembly {\n                                    _zeroForOne := zeroForOne\n                                }\n                                updatedTick = tickNext - _zeroForOne;\n                            }\n                        } else if (naiveSwapResultSqrtPriceX96 != startSqrtPriceX96) {\n                            // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved\n                            updatedTick = TickMath.getTickAtSqrtPrice(naiveSwapResultSqrtPriceX96);\n                        }\n\n                        // set updatedSqrtPriceX96\n                        updatedSqrtPriceX96 = naiveSwapResultSqrtPriceX96;\n\n                        if (\n                            exactIn\n                                ? naiveSwapAmountIn == uint256(-input.swapParams.amountSpecified)\n                                : naiveSwapAmountOut == uint256(input.swapParams.amountSpecified)\n                        ) {\n                            // edge case: the partial swap consumed the entire amount specified\n                            // return the result of the partial swap directly\n\n                            // naiveSwapAmountOut should be at most the corresponding active balance\n                            // this may be violated due to precision loss\n                            naiveSwapAmountOut = FixedPointMathLib.min(\n                                naiveSwapAmountOut,\n                                zeroForOne ? input.currentActiveBalance1 : input.currentActiveBalance0\n                            );\n\n                            return (naiveSwapResultSqrtPriceX96, updatedTick, naiveSwapAmountIn, naiveSwapAmountOut);\n                        }\n\n                        if (\n                            (zeroForOne && cumulativeAmount1 < naiveSwapAmountOut)\n                                || (!zeroForOne && cumulativeAmount0 < naiveSwapAmountOut)\n                        ) {\n                            // in rare cases the rounding error can cause one of the active balances to be negative\n                            // revert in such cases to avoid leaking value\n                            revert BunniSwapMath__SwapFailed();\n                        }\n\n                        (uint256 updatedActiveBalance0, uint256 updatedActiveBalance1) = zeroForOne\n                            ? (cumulativeAmount0 + naiveSwapAmountIn, cumulativeAmount1 - naiveSwapAmountOut)\n                            : (cumulativeAmount0 - naiveSwapAmountOut, cumulativeAmount1 + naiveSwapAmountIn);\n\n                        // compute input and output token amounts\n                        // NOTE: The rounding direction of all the values involved are correct:\n                        // - cumulative amounts are rounded up\n                        // - naiveSwapAmountIn is rounded up\n                        // - naiveSwapAmountOut is rounded down\n                        // - currentActiveBalance0 and currentActiveBalance1 are rounded down\n                        // Overall this leads to inputAmount being rounded up and outputAmount being rounded down\n                        // which is safe.\n                        // Use subReLU so that when the computed output is somehow negative (most likely due to precision loss)\n                        // we output 0 instead of reverting.\n                        (inputAmount, outputAmount) = zeroForOne\n                            ? (\n                                updatedActiveBalance0 - input.currentActiveBalance0,\n                                subReLU(input.currentActiveBalance1, updatedActiveBalance1)\n                            )\n                            : (\n                                updatedActiveBalance1 - input.currentActiveBalance1,\n                                subReLU(input.currentActiveBalance0, updatedActiveBalance0)\n                            );\n\n                        return (updatedSqrtPriceX96, updatedTick, inputAmount, outputAmount);\n                    }\n                }\n            }\n        }\n\n        // the sqrt price limit has been reached\n        (updatedSqrtPriceX96, updatedTick) = (\n            sqrtPriceLimitX96,\n            sqrtPriceLimitX96 == input.sqrtPriceX96 ? input.currentTick : sqrtPriceLimitX96.getTickAtSqrtPrice() // recompute tick unless we haven't moved\n        );\n\n        // Rounding directions:\n        // currentActiveBalance: down\n        // totalDensity: up\n        // updatedActiveBalance: up\n        (, uint256 totalDensity0X96, uint256 totalDensity1X96,,,,,) = queryLDF({\n            key: input.key,\n            sqrtPriceX96: updatedSqrtPriceX96,\n            tick: updatedTick,\n            arithmeticMeanTick: input.arithmeticMeanTick,\n            ldf: input.liquidityDensityFunction,\n            ldfParams: input.ldfParams,\n            ldfState: input.ldfState,\n            balance0: 0,\n            balance1: 0,\n            idleBalance: IdleBalanceLibrary.ZERO\n        });\n        (uint256 _updatedActiveBalance0, uint256 _updatedActiveBalance1) =\n            (totalDensity0X96.fullMulX96Up(input.totalLiquidity), totalDensity1X96.fullMulX96Up(input.totalLiquidity));\n        // Use subReLU so that when the computed output is somehow negative (most likely due to precision loss)\n        // we output 0 instead of reverting.\n        if (zeroForOne) {\n            (inputAmount, outputAmount) = (\n                _updatedActiveBalance0 - input.currentActiveBalance0,\n                subReLU(input.currentActiveBalance1, _updatedActiveBalance1)\n            );\n        } else {\n            (inputAmount, outputAmount) = (\n                _updatedActiveBalance1 - input.currentActiveBalance1,\n                subReLU(input.currentActiveBalance0, _updatedActiveBalance0)\n            );\n        }\n    }\n}\n"}, "src/interfaces/IBunniHub.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\npragma abicoder v2;\n\nimport {PoolId} from \"@uniswap/v4-core/src/types/PoolId.sol\";\nimport {Currency} from \"@uniswap/v4-core/src/types/Currency.sol\";\nimport {IHooks} from \"@uniswap/v4-core/src/interfaces/IHooks.sol\";\nimport {BalanceDelta} from \"@uniswap/v4-core/src/types/BalanceDelta.sol\";\nimport {IPoolManager, PoolKey} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\nimport {IUnlockCallback} from \"@uniswap/v4-core/src/interfaces/callback/IUnlockCallback.sol\";\n\nimport {WETH} from \"solady/tokens/WETH.sol\";\nimport {ERC4626} from \"solady/tokens/ERC4626.sol\";\n\nimport \"../types/LDFType.sol\";\nimport \"../types/IdleBalance.sol\";\nimport \"../base/SharedStructs.sol\";\nimport {IERC20} from \"./IERC20.sol\";\nimport {IHooklet} from \"./IHooklet.sol\";\nimport {IOwnable} from \"./IOwnable.sol\";\nimport {IBunniHook} from \"./IBunniHook.sol\";\nimport {IBunniToken} from \"./IBunniToken.sol\";\nimport {PoolState} from \"../types/PoolState.sol\";\nimport {ILiquidityDensityFunction} from \"./ILiquidityDensityFunction.sol\";\n\n/// @title BunniHub\n/// @author zefram.eth\n/// @notice The main contract LPs interact with. Each BunniKey corresponds to a BunniToken,\n/// which is the ERC20 LP token for the Uniswap V3 position specified by the BunniKey.\n/// Use deposit()/withdraw() to mint/burn LP tokens, and use compound() to compound the swap fees\n/// back into the LP position.\ninterface IBunniHub is IUnlockCallback, IOwnable {\n    /// @notice Emitted when liquidity is increased via deposit\n    /// @param sender The msg.sender address\n    /// @param recipient The address of the account that received the share tokens\n    /// @param poolId The Uniswap V4 pool's ID\n    /// @param amount0 The amount of token0 that was paid for the increase in liquidity\n    /// @param amount1 The amount of token1 that was paid for the increase in liquidity\n    /// @param shares The amount of share tokens minted to the recipient\n    event Deposit(\n        address indexed sender,\n        address indexed recipient,\n        PoolId indexed poolId,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 shares\n    );\n    /// @notice Emitted when a withdrawal is queued\n    /// @param sender The msg.sender address\n    /// @param poolId The Uniswap V4 pool's ID\n    /// @param shares The amount of share tokens queued for withdrawal\n    event QueueWithdraw(address indexed sender, PoolId indexed poolId, uint256 shares);\n    /// @notice Emitted when liquidity is decreased via withdrawal\n    /// @param sender The msg.sender address\n    /// @param recipient The address of the account that received the collected tokens\n    /// @param poolId The Uniswap V4 pool's ID\n    /// @param amount0 The amount of token0 that was accounted for the decrease in liquidity\n    /// @param amount1 The amount of token1 that was accounted for the decrease in liquidity\n    /// @param shares The amount of share tokens burnt from the sender\n    event Withdraw(\n        address indexed sender,\n        address indexed recipient,\n        PoolId indexed poolId,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 shares\n    );\n    /// @notice Emitted when a new IBunniToken is created\n    /// @param bunniToken The BunniToken associated with the call\n    /// @param poolId The Uniswap V4 pool's ID\n    event NewBunni(IBunniToken indexed bunniToken, PoolId indexed poolId);\n    /// @notice Emitted when the recipient of referral rewards of the default referrer address(0) is set\n    /// @param newReferralRewardRecipient The new recipient of referral rewards of the default referrer address(0)\n    event SetReferralRewardRecipient(address indexed newReferralRewardRecipient);\n    /// @notice Emitted when a new address is added to or removed from the pauser set\n    /// @param guy The address that was added or removed from the pauser set\n    /// @param isPauser True if the address was added to the pauser set, false if it was removed\n    event SetPauser(address indexed guy, bool indexed isPauser);\n    /// @notice Emitted when the pause flags are set\n    /// @param pauseFlags The new pause flags, each bit corresponds to a function in BunniHub and is set to 1 if the function is paused\n    event SetPauseFlags(uint8 indexed pauseFlags);\n    /// @notice Emitted when the pause fuse is burned\n    event BurnPauseFuse();\n\n    /// @param poolKey The PoolKey of the Uniswap V4 pool\n    /// @param recipient The recipient of the minted share tokens\n    /// @param refundRecipient The recipient of the refunded ETH\n    /// @param amount0Desired The desired amount of token0 to be spent,\n    /// @param amount1Desired The desired amount of token1 to be spent,\n    /// @param amount0Min The minimum amount of token0 to spend, which serves as a slippage check,\n    /// @param amount1Min The minimum amount of token1 to spend, which serves as a slippage check,\n    /// @param vaultFee0 When we deposit token0 into vault0, the deposit amount is multiplied by WAD / (WAD - vaultFee0),\n    /// @param vaultFee1 When we deposit token1 into vault1, the deposit amount is multiplied by WAD / (WAD - vaultFee1),\n    /// @param deadline The time by which the transaction must be included to effect the change\n    /// @param referrer The referrer of the liquidity provider. Used for fee sharing.\n    struct DepositParams {\n        PoolKey poolKey;\n        address recipient;\n        address refundRecipient;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 vaultFee0;\n        uint256 vaultFee1;\n        uint256 deadline;\n        address referrer;\n    }\n\n    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`\n    /// @dev Must be called after the corresponding BunniToken has been deployed via deployBunniToken()\n    /// @param params The input parameters\n    /// poolKey The PoolKey of the Uniswap V4 pool\n    /// recipient The recipient of the minted share tokens\n    /// refundRecipient The recipient of the refunded ETH\n    /// amount0Desired The desired amount of token0 to be spent,\n    /// amount1Desired The desired amount of token1 to be spent,\n    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,\n    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,\n    /// vaultFee0 When we deposit token0 into vault0, the deposit amount is multiplied by WAD / (WAD - vaultFee0),\n    /// vaultFee1 When we deposit token1 into vault1, the deposit amount is multiplied by WAD / (WAD - vaultFee1),\n    /// deadline The time by which the transaction must be included to effect the change\n    /// @return shares The new share tokens minted to the sender\n    /// @return amount0 The amount of token0 to acheive resulting liquidity\n    /// @return amount1 The amount of token1 to acheive resulting liquidity\n    function deposit(DepositParams calldata params)\n        external\n        payable\n        returns (uint256 shares, uint256 amount0, uint256 amount1);\n\n    /// @param poolKey The PoolKey of the Uniswap V4 pool\n    /// @param shares The amount of share tokens to burn. Ignored if an expired queued withdrawal exists.\n    struct QueueWithdrawParams {\n        PoolKey poolKey;\n        uint200 shares;\n    }\n\n    /// @notice Queues a withdrawal of liquidity. Need to use this before calling withdraw() if am-AMM is enabled\n    /// and a manager exists for the pool. A queued withdrawal is unlocked after WITHDRAW_DELAY (1 minutes) has passed,\n    /// and before WITHDRAW_GRACE_PERIOD (15 minutes) has passed after it's been unlocked. This ensures the am-AMM manager\n    /// has an opportunity to execute any arbitrage trades before a withdrawal is processed.\n    /// @param params The input parameters\n    /// poolKey The PoolKey of the Uniswap V4 pool\n    /// shares The amount of share tokens to burn\n    function queueWithdraw(QueueWithdrawParams calldata params) external;\n\n    /// @param poolKey The PoolKey of the Uniswap V4 pool\n    /// @param recipient The recipient of the withdrawn tokens\n    /// @param shares The amount of share tokens to burn\n    /// @param amount0Min The minimum amount of token0 that should be accounted for the burned liquidity\n    /// @param amount1Min The minimum amount of token1 that should be accounted for the burned liquidity\n    /// @param deadline The time by which the transaction must be included to effect the change\n    /// @param useQueuedWithdrawal If true, queued withdrawal share tokens will be used\n    struct WithdrawParams {\n        PoolKey poolKey;\n        address recipient;\n        uint256 shares;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n        bool useQueuedWithdrawal;\n    }\n\n    /// @notice Decreases the amount of liquidity in the position and sends the tokens to the sender.\n    /// If withdrawing ETH, need to follow up with unwrapWETH9() and sweepToken()\n    /// @dev Must be called after the corresponding BunniToken has been deployed via deployBunniToken()\n    /// @param params The input parameters\n    /// poolKey The Uniswap v4 pool's key\n    /// recipient The recipient of the withdrawn tokens\n    /// shares The amount of share tokens to burn,\n    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,\n    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,\n    /// deadline The time by which the transaction must be included to effect the change\n    /// @return amount0 The amount of token0 withdrawn to the recipient\n    /// @return amount1 The amount of token1 withdrawn to the recipient\n    function withdraw(WithdrawParams calldata params) external returns (uint256 amount0, uint256 amount1);\n\n    /// @param currency0 The token0 of the Uniswap V4 pool\n    /// @param currency1 The token1 of the Uniswap V4 pool\n    /// @param tickSpacing The tick spacing of the Uniswap V4 pool\n    /// @param twapSecondsAgo The TWAP time period to use for the liquidity density function\n    /// @param liquidityDensityFunction The liquidity density function to use\n    /// @param ldfType The type of LDF. See LDFType.sol for details.\n    /// @param hooklet The hooklet to use for the Bunni pool. If it's address(0), then a hooklet is not used.\n    /// @param ldfParams The parameters for the liquidity density function\n    /// @param hooks The hooks to use for the Uniswap V4 pool\n    /// @param hookParams The parameters for the hooks\n    /// @param vault0 The vault for token0. If address(0), then a vault is not used.\n    /// @param vault1 The vault for token1. If address(0), then a vault is not used.\n    /// @param minRawTokenRatio0 The minimum (rawBalance / balance) ratio for token0\n    /// @param targetRawTokenRatio0 The target (rawBalance / balance) ratio for token0\n    /// @param maxRawTokenRatio0 The maximum (rawBalance / balance) ratio for token0\n    /// @param minRawTokenRatio1 The minimum (rawBalance / balance) ratio for token1\n    /// @param targetRawTokenRatio1 The target (rawBalance / balance) ratio for token1\n    /// @param maxRawTokenRatio1 The maximum (rawBalance / balance) ratio for token1\n    /// @param sqrtPriceX96 The initial sqrt price of the Uniswap V4 pool\n    /// @param name The name of the BunniToken\n    /// @param symbol The symbol of the BunniToken\n    /// @param owner The owner of the BunniToken. Only has the power to set the metadata URI.\n    /// @param metadataURI The initial metadata URI of the BunniToken, containing info like description, image, etc.\n    /// @param salt The salt for deploying the BunniToken via CREATE3.\n    struct DeployBunniTokenParams {\n        Currency currency0;\n        Currency currency1;\n        int24 tickSpacing;\n        uint24 twapSecondsAgo;\n        ILiquidityDensityFunction liquidityDensityFunction;\n        IHooklet hooklet;\n        LDFType ldfType;\n        bytes32 ldfParams;\n        IBunniHook hooks;\n        bytes hookParams;\n        ERC4626 vault0;\n        ERC4626 vault1;\n        uint24 minRawTokenRatio0;\n        uint24 targetRawTokenRatio0;\n        uint24 maxRawTokenRatio0;\n        uint24 minRawTokenRatio1;\n        uint24 targetRawTokenRatio1;\n        uint24 maxRawTokenRatio1;\n        uint160 sqrtPriceX96;\n        bytes32 name;\n        bytes32 symbol;\n        address owner;\n        string metadataURI;\n        bytes32 salt;\n    }\n\n    /// @notice Deploys the BunniToken contract for a Bunni position. This token\n    /// represents a user's share in the Uniswap V4 LP position.\n    /// @dev The BunniToken is deployed via CREATE3, which allows for a deterministic address.\n    /// @param params The input parameters\n    /// currency0 The token0 of the Uniswap V4 pool\n    /// currency1 The token1 of the Uniswap V4 pool\n    /// tickSpacing The tick spacing of the Uniswap V4 pool\n    /// twapSecondsAgo The TWAP time period to use for the liquidity density function\n    /// liquidityDensityFunction The liquidity density function to use\n    /// hooklet The hooklet to use for the Bunni pool. If it's address(0), then a hooklet is not used.\n    /// ldfParams The parameters for the liquidity density function\n    /// hooks The hooks to use for the Uniswap V4 pool\n    /// hookParams The parameters for the hooks\n    /// vault0 The vault for token0. If address(0), then a vault is not used.\n    /// vault1 The vault for token1. If address(0), then a vault is not used.\n    /// minRawTokenRatio0 The minimum (rawBalance / balance) ratio for token0\n    /// targetRawTokenRatio0 The target (rawBalance / balance) ratio for token0\n    /// maxRawTokenRatio0 The maximum (rawBalance / balance) ratio for token0\n    /// minRawTokenRatio1 The minimum (rawBalance / balance) ratio for token1\n    /// targetRawTokenRatio1 The target (rawBalance / balance) ratio for token1\n    /// maxRawTokenRatio1 The maximum (rawBalance / balance) ratio for token1\n    /// sqrtPriceX96 The initial sqrt price of the Uniswap V4 pool\n    /// name The name of the BunniToken\n    /// symbol The symbol of the BunniToken\n    /// owner The owner of the BunniToken. Only has the power to set the metadata URI.\n    /// metadataURI The initial metadata URI of the BunniToken, containing info like description, image, etc.\n    /// salt The salt for deploying the BunniToken via CREATE3.\n    /// @return token The deployed BunniToken\n    /// @return key The PoolKey of the Uniswap V4 pool\n    function deployBunniToken(DeployBunniTokenParams calldata params)\n        external\n        returns (IBunniToken token, PoolKey memory key);\n\n    /// @notice Called by the hook to execute a generalized swap from one token to the other. Also used during rebalancing.\n    /// @dev If the raw balance is insufficient, vault reserves will be automatically used.\n    /// Will update vault reserves if the raw/reserve ratio is outside of the bounds.\n    /// @param key The PoolKey of the Uniswap V4 pool\n    /// @param zeroForOne True if the swap is for token0->token1, false if token1->token0\n    /// @param inputAmount The amount of the input token to pull from the hook\n    /// @param outputAmount The amount of the output token to push to the hook\n    function hookHandleSwap(PoolKey calldata key, bool zeroForOne, uint256 inputAmount, uint256 outputAmount)\n        external;\n\n    /// @notice Called by the hook to set the idle balance of a Bunni pool.\n    /// @param key The PoolKey of the Uniswap V4 pool\n    /// @param newIdleBalance The new idle balance of the pool\n    function hookSetIdleBalance(PoolKey calldata key, IdleBalance newIdleBalance) external;\n\n    /// @notice Sets the address of the recipient of referral rewards belonging to the default referrer address(0). Only callable by the owner.\n    /// @param newReferralRewardRecipient The new address of the recipient of referral rewards\n    function setReferralRewardRecipient(address newReferralRewardRecipient) external;\n\n    /// @notice Adds or removes an address from the pauser set. Only callable by the owner.\n    /// @param guy The address to add or remove from the pauser set\n    /// @param isPauser True if the address should be added to the pauser set, false if it should be removed\n    function setPauser(address guy, bool isPauser) external;\n\n    /// @notice Sets the pause flags. Only callable by the owner.\n    /// @param pauseFlags The new pause flags, each bit corresponds to a function in BunniHub and is set to 1 if the function is paused\n    function setPauseFlags(uint8 pauseFlags) external;\n\n    /// @notice Burns the pause fuse. Only callable by the owner.\n    /// All functions are permanently unpaused after this function is called.\n    function burnPauseFuse() external;\n\n    /// @notice Called by key.hooks to lock BunniHub before a rebalance order's execution.\n    /// @param key The PoolKey of the Uniswap v4 pool\n    function lockForRebalance(PoolKey calldata key) external;\n\n    /// @notice Called by key.hooks to unlock BunniHub after a rebalance order's execution.\n    /// @param key The PoolKey of the Uniswap v4 pool\n    function unlockForRebalance(PoolKey calldata key) external;\n\n    /// @notice The state of a Bunni pool.\n    function poolState(PoolId poolId) external view returns (PoolState memory);\n\n    /// @notice The PoolState struct of a given pool with only the immutable params filled out.\n    function poolParams(PoolId poolId) external view returns (PoolState memory);\n\n    /// @notice The BunniToken of a given pool. address(0) if the pool is not a Bunni pool.\n    function bunniTokenOfPool(PoolId poolId) external view returns (IBunniToken);\n\n    /// @notice The params of the given Bunni pool's hook. bytes(\"\") if the pool is not a Bunni pool.\n    function hookParams(PoolId poolId) external view returns (bytes memory);\n\n    /// @notice The next available nonce of the given Bunni subspace.\n    function nonce(bytes32 bunniSubspace) external view returns (uint24);\n\n    /// @notice The PoolId of a given BunniToken.\n    function poolIdOfBunniToken(IBunniToken bunniToken) external view returns (PoolId);\n\n    /// @notice The token balances of a Bunni pool. Reserves in vaults are converted to raw token balances via ERC4626.previewRedeem().\n    function poolBalances(PoolId poolId) external view returns (uint256 balance0, uint256 balance1);\n\n    /// @notice The idle balance of a Bunni pool.\n    function idleBalance(PoolId poolId) external view returns (IdleBalance);\n\n    /// @notice The address of the recipient of referral rewards belonging to the default referrer address(0).\n    function getReferralRewardRecipient() external view returns (address);\n\n    /// @notice Returns true if the given address is a pauser who can pause/unpause external functions.\n    function isPauser(address guy) external view returns (bool);\n\n    /// @notice The pause flags and pause fuse status.\n    /// @return pauseFlags The pause flags, each bit corresponds to a function in BunniHub and is set to 1 if the function is paused\n    /// @return unpauseFuse The pause fuse status. If true, all functions are permanently unpaused\n    function getPauseStatus() external view returns (uint8 pauseFlags, bool unpauseFuse);\n\n    /// @notice The init data of a Bunni pool. Stored in transient storage and used\n    /// during the IHooks.afterInitialize() call.\n    function poolInitData() external view returns (bytes memory);\n}\n"}, "lib/permit2/src/libraries/PermitHash.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IAllowanceTransfer} from \"../interfaces/IAllowanceTransfer.sol\";\nimport {ISignatureTransfer} from \"../interfaces/ISignatureTransfer.sol\";\n\nlibrary PermitHash {\n    bytes32 public constant _PERMIT_DETAILS_TYPEHASH =\n        keccak256(\"PermitDetails(address token,uint160 amount,uint48 expiration,uint48 nonce)\");\n\n    bytes32 public constant _PERMIT_SINGLE_TYPEHASH = keccak256(\n        \"PermitSingle(PermitDetails details,address spender,uint256 sigDeadline)PermitDetails(address token,uint160 amount,uint48 expiration,uint48 nonce)\"\n    );\n\n    bytes32 public constant _PERMIT_BATCH_TYPEHASH = keccak256(\n        \"PermitBatch(PermitDetails[] details,address spender,uint256 sigDeadline)PermitDetails(address token,uint160 amount,uint48 expiration,uint48 nonce)\"\n    );\n\n    bytes32 public constant _TOKEN_PERMISSIONS_TYPEHASH = keccak256(\"TokenPermissions(address token,uint256 amount)\");\n\n    bytes32 public constant _PERMIT_TRANSFER_FROM_TYPEHASH = keccak256(\n        \"PermitTransferFrom(TokenPermissions permitted,address spender,uint256 nonce,uint256 deadline)TokenPermissions(address token,uint256 amount)\"\n    );\n\n    bytes32 public constant _PERMIT_BATCH_TRANSFER_FROM_TYPEHASH = keccak256(\n        \"PermitBatchTransferFrom(TokenPermissions[] permitted,address spender,uint256 nonce,uint256 deadline)TokenPermissions(address token,uint256 amount)\"\n    );\n\n    string public constant _TOKEN_PERMISSIONS_TYPESTRING = \"TokenPermissions(address token,uint256 amount)\";\n\n    string public constant _PERMIT_TRANSFER_FROM_WITNESS_TYPEHASH_STUB =\n        \"PermitWitnessTransferFrom(TokenPermissions permitted,address spender,uint256 nonce,uint256 deadline,\";\n\n    string public constant _PERMIT_BATCH_WITNESS_TRANSFER_FROM_TYPEHASH_STUB =\n        \"PermitBatchWitnessTransferFrom(TokenPermissions[] permitted,address spender,uint256 nonce,uint256 deadline,\";\n\n    function hash(IAllowanceTransfer.PermitSingle memory permitSingle) internal pure returns (bytes32) {\n        bytes32 permitHash = _hashPermitDetails(permitSingle.details);\n        return\n            keccak256(abi.encode(_PERMIT_SINGLE_TYPEHASH, permitHash, permitSingle.spender, permitSingle.sigDeadline));\n    }\n\n    function hash(IAllowanceTransfer.PermitBatch memory permitBatch) internal pure returns (bytes32) {\n        uint256 numPermits = permitBatch.details.length;\n        bytes32[] memory permitHashes = new bytes32[](numPermits);\n        for (uint256 i = 0; i < numPermits; ++i) {\n            permitHashes[i] = _hashPermitDetails(permitBatch.details[i]);\n        }\n        return keccak256(\n            abi.encode(\n                _PERMIT_BATCH_TYPEHASH,\n                keccak256(abi.encodePacked(permitHashes)),\n                permitBatch.spender,\n                permitBatch.sigDeadline\n            )\n        );\n    }\n\n    function hash(ISignatureTransfer.PermitTransferFrom memory permit) internal view returns (bytes32) {\n        bytes32 tokenPermissionsHash = _hashTokenPermissions(permit.permitted);\n        return keccak256(\n            abi.encode(_PERMIT_TRANSFER_FROM_TYPEHASH, tokenPermissionsHash, msg.sender, permit.nonce, permit.deadline)\n        );\n    }\n\n    function hash(ISignatureTransfer.PermitBatchTransferFrom memory permit) internal view returns (bytes32) {\n        uint256 numPermitted = permit.permitted.length;\n        bytes32[] memory tokenPermissionHashes = new bytes32[](numPermitted);\n\n        for (uint256 i = 0; i < numPermitted; ++i) {\n            tokenPermissionHashes[i] = _hashTokenPermissions(permit.permitted[i]);\n        }\n\n        return keccak256(\n            abi.encode(\n                _PERMIT_BATCH_TRANSFER_FROM_TYPEHASH,\n                keccak256(abi.encodePacked(tokenPermissionHashes)),\n                msg.sender,\n                permit.nonce,\n                permit.deadline\n            )\n        );\n    }\n\n    function hashWithWitness(\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        bytes32 witness,\n        string calldata witnessTypeString\n    ) internal view returns (bytes32) {\n        bytes32 typeHash = keccak256(abi.encodePacked(_PERMIT_TRANSFER_FROM_WITNESS_TYPEHASH_STUB, witnessTypeString));\n\n        bytes32 tokenPermissionsHash = _hashTokenPermissions(permit.permitted);\n        return keccak256(abi.encode(typeHash, tokenPermissionsHash, msg.sender, permit.nonce, permit.deadline, witness));\n    }\n\n    function hashWithWitness(\n        ISignatureTransfer.PermitBatchTransferFrom memory permit,\n        bytes32 witness,\n        string calldata witnessTypeString\n    ) internal view returns (bytes32) {\n        bytes32 typeHash =\n            keccak256(abi.encodePacked(_PERMIT_BATCH_WITNESS_TRANSFER_FROM_TYPEHASH_STUB, witnessTypeString));\n\n        uint256 numPermitted = permit.permitted.length;\n        bytes32[] memory tokenPermissionHashes = new bytes32[](numPermitted);\n\n        for (uint256 i = 0; i < numPermitted; ++i) {\n            tokenPermissionHashes[i] = _hashTokenPermissions(permit.permitted[i]);\n        }\n\n        return keccak256(\n            abi.encode(\n                typeHash,\n                keccak256(abi.encodePacked(tokenPermissionHashes)),\n                msg.sender,\n                permit.nonce,\n                permit.deadline,\n                witness\n            )\n        );\n    }\n\n    function _hashPermitDetails(IAllowanceTransfer.PermitDetails memory details) private pure returns (bytes32) {\n        return keccak256(abi.encode(_PERMIT_DETAILS_TYPEHASH, details));\n    }\n\n    function _hashTokenPermissions(ISignatureTransfer.TokenPermissions memory permitted)\n        private\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(_TOKEN_PERMISSIONS_TYPEHASH, permitted));\n    }\n}\n"}, "lib/v4-core/src/interfaces/IHooks.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {BalanceDelta} from \"../types/BalanceDelta.sol\";\nimport {IPoolManager} from \"./IPoolManager.sol\";\nimport {BeforeSwapDelta} from \"../types/BeforeSwapDelta.sol\";\n\n/// @notice V4 decides whether to invoke specific hooks by inspecting the least significant bits\n/// of the address that the hooks contract is deployed to.\n/// For example, a hooks contract deployed to address: 0x0000000000000000000000000000000000002400\n/// has the lowest bits '10 0100 0000 0000' which would cause the 'before initialize' and 'after add liquidity' hooks to be used.\n/// See the Hooks library for the full spec.\n/// @dev Should only be callable by the v4 PoolManager.\ninterface IHooks {\n    /// @notice The hook called before the state of a pool is initialized\n    /// @param sender The initial msg.sender for the initialize call\n    /// @param key The key for the pool being initialized\n    /// @param sqrtPriceX96 The sqrt(price) of the pool as a Q64.96\n    /// @return bytes4 The function selector for the hook\n    function beforeInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96) external returns (bytes4);\n\n    /// @notice The hook called after the state of a pool is initialized\n    /// @param sender The initial msg.sender for the initialize call\n    /// @param key The key for the pool being initialized\n    /// @param sqrtPriceX96 The sqrt(price) of the pool as a Q64.96\n    /// @param tick The current tick after the state of a pool is initialized\n    /// @return bytes4 The function selector for the hook\n    function afterInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96, int24 tick)\n        external\n        returns (bytes4);\n\n    /// @notice The hook called before liquidity is added\n    /// @param sender The initial msg.sender for the add liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for adding liquidity\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidity provider to be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeAddLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after liquidity is added\n    /// @param sender The initial msg.sender for the add liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for adding liquidity\n    /// @param delta The caller's balance delta after adding liquidity; the sum of principal delta, fees accrued, and hook delta\n    /// @param feesAccrued The fees accrued since the last time fees were collected from this position\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidity provider to be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    /// @return BalanceDelta The hook's delta in token0 and token1. Positive: the hook is owed/took currency, negative: the hook owes/sent currency\n    function afterAddLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        BalanceDelta delta,\n        BalanceDelta feesAccrued,\n        bytes calldata hookData\n    ) external returns (bytes4, BalanceDelta);\n\n    /// @notice The hook called before liquidity is removed\n    /// @param sender The initial msg.sender for the remove liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for removing liquidity\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidity provider to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeRemoveLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after liquidity is removed\n    /// @param sender The initial msg.sender for the remove liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for removing liquidity\n    /// @param delta The caller's balance delta after removing liquidity; the sum of principal delta, fees accrued, and hook delta\n    /// @param feesAccrued The fees accrued since the last time fees were collected from this position\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidity provider to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    /// @return BalanceDelta The hook's delta in token0 and token1. Positive: the hook is owed/took currency, negative: the hook owes/sent currency\n    function afterRemoveLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        BalanceDelta delta,\n        BalanceDelta feesAccrued,\n        bytes calldata hookData\n    ) external returns (bytes4, BalanceDelta);\n\n    /// @notice The hook called before a swap\n    /// @param sender The initial msg.sender for the swap call\n    /// @param key The key for the pool\n    /// @param params The parameters for the swap\n    /// @param hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    /// @return BeforeSwapDelta The hook's delta in specified and unspecified currencies. Positive: the hook is owed/took currency, negative: the hook owes/sent currency\n    /// @return uint24 Optionally override the lp fee, only used if three conditions are met: 1. the Pool has a dynamic fee, 2. the value's 2nd highest bit is set (23rd bit, 0x400000), and 3. the value is less than or equal to the maximum fee (1 million)\n    function beforeSwap(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        bytes calldata hookData\n    ) external returns (bytes4, BeforeSwapDelta, uint24);\n\n    /// @notice The hook called after a swap\n    /// @param sender The initial msg.sender for the swap call\n    /// @param key The key for the pool\n    /// @param params The parameters for the swap\n    /// @param delta The amount owed to the caller (positive) or owed to the pool (negative)\n    /// @param hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    /// @return int128 The hook's delta in unspecified currency. Positive: the hook is owed/took currency, negative: the hook owes/sent currency\n    function afterSwap(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        BalanceDelta delta,\n        bytes calldata hookData\n    ) external returns (bytes4, int128);\n\n    /// @notice The hook called before donate\n    /// @param sender The initial msg.sender for the donate call\n    /// @param key The key for the pool\n    /// @param amount0 The amount of token0 being donated\n    /// @param amount1 The amount of token1 being donated\n    /// @param hookData Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeDonate(\n        address sender,\n        PoolKey calldata key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after donate\n    /// @param sender The initial msg.sender for the donate call\n    /// @param key The key for the pool\n    /// @param amount0 The amount of token0 being donated\n    /// @param amount1 The amount of token1 being donated\n    /// @param hookData Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function afterDonate(\n        address sender,\n        PoolKey calldata key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external returns (bytes4);\n}\n"}, "lib/v4-core/src/interfaces/external/IERC6909Claims.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Interface for claims over a contract balance, wrapped as a ERC6909\ninterface IERC6909Claims {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OperatorSet(address indexed owner, address indexed operator, bool approved);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id, uint256 amount);\n\n    event Transfer(address caller, address indexed from, address indexed to, uint256 indexed id, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                                 FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Owner balance of an id.\n    /// @param owner The address of the owner.\n    /// @param id The id of the token.\n    /// @return amount The balance of the token.\n    function balanceOf(address owner, uint256 id) external view returns (uint256 amount);\n\n    /// @notice Spender allowance of an id.\n    /// @param owner The address of the owner.\n    /// @param spender The address of the spender.\n    /// @param id The id of the token.\n    /// @return amount The allowance of the token.\n    function allowance(address owner, address spender, uint256 id) external view returns (uint256 amount);\n\n    /// @notice Checks if a spender is approved by an owner as an operator\n    /// @param owner The address of the owner.\n    /// @param spender The address of the spender.\n    /// @return approved The approval status.\n    function isOperator(address owner, address spender) external view returns (bool approved);\n\n    /// @notice Transfers an amount of an id from the caller to a receiver.\n    /// @param receiver The address of the receiver.\n    /// @param id The id of the token.\n    /// @param amount The amount of the token.\n    /// @return bool True, always, unless the function reverts\n    function transfer(address receiver, uint256 id, uint256 amount) external returns (bool);\n\n    /// @notice Transfers an amount of an id from a sender to a receiver.\n    /// @param sender The address of the sender.\n    /// @param receiver The address of the receiver.\n    /// @param id The id of the token.\n    /// @param amount The amount of the token.\n    /// @return bool True, always, unless the function reverts\n    function transferFrom(address sender, address receiver, uint256 id, uint256 amount) external returns (bool);\n\n    /// @notice Approves an amount of an id to a spender.\n    /// @param spender The address of the spender.\n    /// @param id The id of the token.\n    /// @param amount The amount of the token.\n    /// @return bool True, always\n    function approve(address spender, uint256 id, uint256 amount) external returns (bool);\n\n    /// @notice Sets or removes an operator for the caller.\n    /// @param operator The address of the operator.\n    /// @param approved The approval status.\n    /// @return bool True, always\n    function setOperator(address operator, bool approved) external returns (bool);\n}\n"}, "lib/v4-core/src/interfaces/IProtocolFees.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Currency} from \"../types/Currency.sol\";\nimport {PoolId} from \"../types/PoolId.sol\";\nimport {PoolKey} from \"../types/PoolKey.sol\";\n\n/// @notice Interface for all protocol-fee related functions in the pool manager\ninterface IProtocolFees {\n    /// @notice Thrown when protocol fee is set too high\n    error ProtocolFeeTooLarge(uint24 fee);\n\n    /// @notice Thrown when collectProtocolFees or setProtocolFee is not called by the controller.\n    error InvalidCaller();\n\n    /// @notice Thrown when collectProtocolFees is attempted on a token that is synced.\n    error ProtocolFeeCurrencySynced();\n\n    /// @notice Emitted when the protocol fee controller address is updated in setProtocolFeeController.\n    event ProtocolFeeControllerUpdated(address indexed protocolFeeController);\n\n    /// @notice Emitted when the protocol fee is updated for a pool.\n    event ProtocolFeeUpdated(PoolId indexed id, uint24 protocolFee);\n\n    /// @notice Given a currency address, returns the protocol fees accrued in that currency\n    /// @param currency The currency to check\n    /// @return amount The amount of protocol fees accrued in the currency\n    function protocolFeesAccrued(Currency currency) external view returns (uint256 amount);\n\n    /// @notice Sets the protocol fee for the given pool\n    /// @param key The key of the pool to set a protocol fee for\n    /// @param newProtocolFee The fee to set\n    function setProtocolFee(PoolKey memory key, uint24 newProtocolFee) external;\n\n    /// @notice Sets the protocol fee controller\n    /// @param controller The new protocol fee controller\n    function setProtocolFeeController(address controller) external;\n\n    /// @notice Collects the protocol fees for a given recipient and currency, returning the amount collected\n    /// @dev This will revert if the contract is unlocked\n    /// @param recipient The address to receive the protocol fees\n    /// @param currency The currency to withdraw\n    /// @param amount The amount of currency to withdraw\n    /// @return amountCollected The amount of currency successfully withdrawn\n    function collectProtocolFees(address recipient, Currency currency, uint256 amount)\n        external\n        returns (uint256 amountCollected);\n\n    /// @notice Returns the current protocol fee controller address\n    /// @return address The current protocol fee controller address\n    function protocolFeeController() external view returns (address);\n}\n"}, "lib/v4-core/src/types/BalanceDelta.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {SafeCast} from \"../libraries/SafeCast.sol\";\n\n/// @dev Two `int128` values packed into a single `int256` where the upper 128 bits represent the amount0\n/// and the lower 128 bits represent the amount1.\ntype BalanceDelta is int256;\n\nusing {add as +, sub as -, eq as ==, neq as !=} for BalanceDelta global;\nusing BalanceDeltaLibrary for BalanceDelta global;\nusing SafeCast for int256;\n\nfunction toBalanceDelta(int128 _amount0, int128 _amount1) pure returns (BalanceDelta balanceDelta) {\n    assembly (\"memory-safe\") {\n        balanceDelta := or(shl(128, _amount0), and(sub(shl(128, 1), 1), _amount1))\n    }\n}\n\nfunction add(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta) {\n    int256 res0;\n    int256 res1;\n    assembly (\"memory-safe\") {\n        let a0 := sar(128, a)\n        let a1 := signextend(15, a)\n        let b0 := sar(128, b)\n        let b1 := signextend(15, b)\n        res0 := add(a0, b0)\n        res1 := add(a1, b1)\n    }\n    return toBalanceDelta(res0.toInt128(), res1.toInt128());\n}\n\nfunction sub(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta) {\n    int256 res0;\n    int256 res1;\n    assembly (\"memory-safe\") {\n        let a0 := sar(128, a)\n        let a1 := signextend(15, a)\n        let b0 := sar(128, b)\n        let b1 := signextend(15, b)\n        res0 := sub(a0, b0)\n        res1 := sub(a1, b1)\n    }\n    return toBalanceDelta(res0.toInt128(), res1.toInt128());\n}\n\nfunction eq(BalanceDelta a, BalanceDelta b) pure returns (bool) {\n    return BalanceDelta.unwrap(a) == BalanceDelta.unwrap(b);\n}\n\nfunction neq(BalanceDelta a, BalanceDelta b) pure returns (bool) {\n    return BalanceDelta.unwrap(a) != BalanceDelta.unwrap(b);\n}\n\n/// @notice Library for getting the amount0 and amount1 deltas from the BalanceDelta type\nlibrary BalanceDeltaLibrary {\n    /// @notice A BalanceDelta of 0\n    BalanceDelta public constant ZERO_DELTA = BalanceDelta.wrap(0);\n\n    function amount0(BalanceDelta balanceDelta) internal pure returns (int128 _amount0) {\n        assembly (\"memory-safe\") {\n            _amount0 := sar(128, balanceDelta)\n        }\n    }\n\n    function amount1(BalanceDelta balanceDelta) internal pure returns (int128 _amount1) {\n        assembly (\"memory-safe\") {\n            _amount1 := signextend(15, balanceDelta)\n        }\n    }\n}\n"}, "lib/v4-core/src/interfaces/IExtsload.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Interface for functions to access any storage slot in a contract\ninterface IExtsload {\n    /// @notice Called by external contracts to access granular pool state\n    /// @param slot Key of slot to sload\n    /// @return value The value of the slot as bytes32\n    function extsload(bytes32 slot) external view returns (bytes32 value);\n\n    /// @notice Called by external contracts to access granular pool state\n    /// @param startSlot Key of slot to start sloading from\n    /// @param nSlots Number of slots to load into return value\n    /// @return values List of loaded values.\n    function extsload(bytes32 startSlot, uint256 nSlots) external view returns (bytes32[] memory values);\n\n    /// @notice Called by external contracts to access sparse pool state\n    /// @param slots List of slots to SLOAD from.\n    /// @return values List of loaded values.\n    function extsload(bytes32[] calldata slots) external view returns (bytes32[] memory values);\n}\n"}, "lib/v4-core/src/interfaces/IExttload.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Interface for functions to access any transient storage slot in a contract\ninterface IExttload {\n    /// @notice Called by external contracts to access transient storage of the contract\n    /// @param slot Key of slot to tload\n    /// @return value The value of the slot as bytes32\n    function exttload(bytes32 slot) external view returns (bytes32 value);\n\n    /// @notice Called by external contracts to access sparse transient pool state\n    /// @param slots List of slots to tload\n    /// @return values List of loaded values\n    function exttload(bytes32[] calldata slots) external view returns (bytes32[] memory values);\n}\n"}, "lib/v4-core/src/interfaces/callback/IUnlockCallback.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Interface for the callback executed when an address unlocks the pool manager\ninterface IUnlockCallback {\n    /// @notice Called by the pool manager on `msg.sender` when the manager is unlocked\n    /// @param data The data that was passed to the call to unlock\n    /// @return Any data that you want to be returned from the unlock call\n    function unlockCallback(bytes calldata data) external returns (bytes memory);\n}\n"}, "src/interfaces/IERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n * Modified from OpenZeppelin's IERC20 contract\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @return The name of the token\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @return The symbol of the token\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @return The number of decimal places the token has\n     */\n    function decimals() external view returns (uint8);\n\n    function nonces(address account) external view returns (uint256);\n\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external;\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"}, "src/interfaces/IOwnable.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\ninterface IOwnable {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The caller is not authorized to call the function.\n    error Unauthorized();\n\n    /// @dev The `newOwner` cannot be the zero address.\n    error NewOwnerIsZeroAddress();\n\n    /// @dev The `pendingOwner` does not have a valid handover request.\n    error NoHandoverRequest();\n\n    /// @dev Cannot double-initialize.\n    error AlreadyInitialized();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                           EVENTS                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\n    /// despite it not being as lightweight as a single argument event.\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    /// @dev An ownership handover to `pendingOwner` has been requested.\n    event OwnershipHandoverRequested(address indexed pendingOwner);\n\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                  external UPDATE FUNCTIONS                   */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\n    function transferOwnership(address newOwner) external payable;\n\n    /// @dev Allows the owner to renounce their ownership.\n    function renounceOwnership() external payable;\n\n    /// @dev Request a two-step ownership handover to the caller.\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\n    function requestOwnershipHandover() external payable;\n\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\n    function cancelOwnershipHandover() external payable;\n\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\n    function completeOwnershipHandover(address pendingOwner) external payable;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                   external READ FUNCTIONS                    */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the owner of the contract.\n    function owner() external view returns (address result);\n\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\n    function ownershipHandoverExpiresAt(address pendingOwner) external view returns (uint256 result);\n}\n"}, "src/interfaces/IERC20Referrer.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\ninterface IERC20Referrer {\n    /// @notice Returns the score of a referrer. The score is the sum of all\n    /// balances of accounts that have the referrer as their referrer.\n    /// @param referrer The referrer whose score is to be returned.\n    /// @return score The score of the referrer.\n    function scoreOf(address referrer) external view returns (uint256 score);\n\n    /// @notice Returns the referrer of an account. Default referrer is 0.\n    /// @param account The account whose referrer is to be returned.\n    /// @return referrer The referrer of the account.\n    function referrerOf(address account) external view returns (address referrer);\n}\n"}, "src/interfaces/IERC20Lockable.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\nimport \"./IERC20Unlocker.sol\";\n\n/// @title IERC20Lockable - Interface for a lockable token account.\n/// @notice A token holder can lock their account, preventing any transfers from the account.\n/// An unlocker contract is able to unlock the account. The unlocker contract is expected to\n/// implement the `IERC20Unlocker` interface.\n/// Used mainly for staking contracts that don't require transferring the token into the contract.\ninterface IERC20Lockable {\n    event Lock(address indexed account, IERC20Unlocker indexed unlocker);\n    event Unlock(address indexed account, IERC20Unlocker indexed unlocker);\n\n    /// @dev Error when calling lock() and the account is already locked.\n    error AlreadyLocked();\n\n    /// @dev Error when calling unlock() and the account is already unlocked.\n    error AlreadyUnlocked();\n\n    /// @dev Error when the caller is not the unlocker of the account.\n    error NotUnlocker();\n\n    /// @dev Error when trasferring tokens from a locked account.\n    error AccountLocked();\n\n    /// @notice Called by a token holder to lock their account. Once locked an account\n    /// can no longer transfer tokens until it's been unlocked. Only `unlocker` has the\n    /// ability to unlock the account. Reverts if the account is already locked.\n    /// @dev `unlocker` will receive the data via a `lockCallback()` call from this contract.\n    /// @param unlocker The address that will be able to unlock the account.\n    /// @param data Additional data with no specified format.\n    function lock(IERC20Unlocker unlocker, bytes calldata data) external;\n\n    /// @notice Called by an unlocker contract to unlock an account.\n    /// Reverts if the caller is not the unlocker of the account, or if\n    /// the account is not locked.\n    /// @param account The account to unlock.\n    function unlock(address account) external;\n\n    /// @notice Returns true if the account is locked, false otherwise.\n    /// @param account The account to check.\n    /// @return True if the account is locked, false otherwise.\n    function isLocked(address account) external view returns (bool);\n\n    /// @notice Returns the unlocker of the account. Be aware that the unlocker\n    /// is not set to 0 after the account has been unlocked, so the caller should\n    /// use this function in combination with `isLocked()`.\n    /// @param account The account whose unlocker is to be returned.\n    /// @return unlocker The unlocker of the account.\n    function unlockerOf(address account) external view returns (IERC20Unlocker unlocker);\n}\n"}, "lib/biddog/src/interfaces/IAmAmm.sol": {"content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.30;\n\nimport {PoolId} from \"@uniswap/v4-core/src/types/PoolId.sol\";\nimport {Currency} from \"@uniswap/v4-core/src/types/Currency.sol\";\n\ninterface IAmAmm {\n    error AmAmm__BidLocked();\n    error AmAmm__InvalidBid();\n    error AmAmm__NotEnabled();\n    error AmAmm__Unauthorized();\n    error AmAmm__InvalidDepositAmount();\n\n    event SubmitBid(\n        PoolId indexed id,\n        address indexed manager,\n        uint48 indexed blockIdx,\n        bytes6 payload,\n        uint128 rent,\n        uint128 deposit\n    );\n    event DepositIntoTopBid(PoolId indexed id, address indexed manager, uint128 amount);\n    event WithdrawFromTopBid(PoolId indexed id, address indexed manager, address indexed recipient, uint128 amount);\n    event DepositIntoNextBid(PoolId indexed id, address indexed manager, uint128 amount);\n    event WithdrawFromNextBid(PoolId indexed id, address indexed manager, address indexed recipient, uint128 amount);\n    event ClaimRefund(PoolId indexed id, address indexed manager, address indexed recipient, uint256 refund);\n    event ClaimFees(Currency indexed currency, address indexed manager, address indexed recipient, uint256 fees);\n    event SetBidPayload(PoolId indexed id, address indexed manager, bytes6 payload, bool topBid);\n    event IncreaseBidRent(\n        PoolId indexed id,\n        address indexed manager,\n        uint128 additionalRent,\n        uint128 updatedDeposit,\n        bool topBid,\n        address indexed withdrawRecipient,\n        uint128 amountDeposited,\n        uint128 amountWithdrawn\n    );\n\n    struct Bid {\n        address manager;\n        uint48 blockIdx; // block number (minus contract deployment block) when the bid was created / last charged rent\n        bytes6 payload; // payload specifying what parames the manager wants, e.g. swap fee\n        uint128 rent; // rent per block\n        uint128 deposit; // rent deposit amount\n    }\n\n    /// @notice Places a bid to become the manager of a pool\n    /// @param id The pool id\n    /// @param manager The address of the manager\n    /// @param payload The payload specifying what parameters the manager wants, e.g. swap fee\n    /// @param rent The rent per block\n    /// @param deposit The deposit amount, must be a multiple of rent and cover rent for >=K blocks\n    function bid(PoolId id, address manager, bytes6 payload, uint128 rent, uint128 deposit) external;\n\n    /// @notice Adds deposit to the top bid. Only callable by topBids[id].manager.\n    /// @param id The pool id\n    /// @param amount The amount to deposit, must be a multiple of rent\n    function depositIntoTopBid(PoolId id, uint128 amount) external;\n\n    /// @notice Withdraws from the deposit of the top bid. Only callable by topBids[id].manager. Reverts if D_top / R_top < K.\n    /// @param id The pool id\n    /// @param amount The amount to withdraw, must be a multiple of rent and leave D_top / R_top >= K\n    /// @param recipient The address of the recipient\n    function withdrawFromTopBid(PoolId id, uint128 amount, address recipient) external;\n\n    /// @notice Adds deposit to the next bid. Only callable by nextBids[id].manager.\n    /// @param id The pool id\n    /// @param amount The amount to deposit, must be a multiple of rent\n    function depositIntoNextBid(PoolId id, uint128 amount) external;\n\n    /// @notice Withdraws from the deposit of the next bid. Only callable by nextBids[id].manager. Reverts if D_next / R_next < K.\n    /// @param id The pool id\n    /// @param amount The amount to withdraw, must be a multiple of rent and leave D_next / R_next >= K\n    /// @param recipient The address of the recipient\n    function withdrawFromNextBid(PoolId id, uint128 amount, address recipient) external;\n\n    /// @notice Claims the refundable deposit of a pool owed to msg.sender.\n    /// @param id The pool id\n    /// @param recipient The address of the manager\n    /// @return refund The amount of refund claimed\n    function claimRefund(PoolId id, address recipient) external returns (uint256 refund);\n\n    /// @notice Claims the accrued fees of msg.sender.\n    /// @param currency The currency of the fees\n    /// @param recipient The address of the recipient\n    /// @return fees The amount of fees claimed\n    function claimFees(Currency currency, address recipient) external returns (uint256 fees);\n\n    /// @notice Increases the rent of a bid. Only callable by the manager of the relevant bid. Reverts if D / R < K after the update.\n    /// Reverts if updated deposit is not a multiple of the new rent. Noop if additionalRent is 0. Will take/send the difference between the old and new deposits.\n    /// @param id The pool id\n    /// @param additionalRent The additional rent to add\n    /// @param updatedDeposit The updated deposit amount of the bid\n    /// @param topBid True if the top bid manager is increasing the rent and deposit, false if the next bid manager is increasing the rent and deposit\n    /// @param withdrawRecipient The address to withdraw the difference between the old and new deposits to\n    /// @return amountDeposited The amount of deposit added, if any\n    /// @return amountWithdrawn The amount of deposit withdrawn, if any\n    function increaseBidRent(\n        PoolId id,\n        uint128 additionalRent,\n        uint128 updatedDeposit,\n        bool topBid,\n        address withdrawRecipient\n    ) external returns (uint128 amountDeposited, uint128 amountWithdrawn);\n\n    /// @notice Sets the payload of a pool. Only callable by the manager of either the top bid or the next bid.\n    /// @param id The pool id\n    /// @param payload The payload specifying e.g. the swap fee\n    /// @param topBid True if the top bid manager is setting the fee, false if the next bid manager is setting the fee\n    function setBidPayload(PoolId id, bytes6 payload, bool topBid) external;\n\n    /// @notice Gets the top bid of a pool\n    function getTopBid(PoolId id) external view returns (Bid memory);\n\n    /// @notice Updates the am-AMM state of a pool and then gets the top bid\n    function getTopBidWrite(PoolId id) external returns (Bid memory);\n\n    /// @notice Gets the next bid of a pool\n    function getNextBid(PoolId id) external view returns (Bid memory);\n\n    /// @notice Updates the am-AMM state of a pool and then gets the next bid\n    function getNextBidWrite(PoolId id) external returns (Bid memory);\n\n    /// @notice Gets the refundable deposit of a pool\n    /// @param manager The address of the manager\n    /// @param id The pool id\n    function getRefund(address manager, PoolId id) external view returns (uint256);\n\n    /// @notice Updates the am-AMM state of a pool and then gets the refundable deposit owed to a manager in that pool\n    /// @param manager The address of the manager\n    /// @param id The pool id\n    function getRefundWrite(address manager, PoolId id) external returns (uint256);\n\n    /// @notice Gets the fees accrued by a manager\n    /// @param manager The address of the manager\n    /// @param currency The currency of the fees\n    function getFees(address manager, Currency currency) external view returns (uint256);\n\n    /// @notice Triggers a state machine update for the given pool\n    /// @param id The pool id\n    function updateStateMachine(PoolId id) external;\n}\n"}, "lib/permit2/src/interfaces/IERC1271.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IERC1271 {\n    /// @dev Should return whether the signature provided is valid for the provided data\n    /// @param hash      Hash of the data to be signed\n    /// @param signature Signature byte array associated with _data\n    /// @return magicValue The bytes4 magic value 0x1626ba7e\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"}, "src/interfaces/IBaseHook.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\nimport {Hooks} from \"@uniswap/v4-core/src/libraries/Hooks.sol\";\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\nimport {BeforeSwapDelta} from \"@uniswap/v4-core/src/types/BeforeSwapDelta.sol\";\n\ninterface IBaseHook {\n    error NotPoolManager();\n\n    function poolManager() external view returns (IPoolManager);\n\n    /// @notice The hook called after the state of a pool is initialized\n    /// @param sender The initial msg.sender for the initialize call\n    /// @param key The key for the pool being initialized\n    /// @param sqrtPriceX96 The sqrt(price) of the pool as a Q64.96\n    /// @param tick The current tick after the state of a pool is initialized\n    /// @return bytes4 The function selector for the hook\n    function afterInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96, int24 tick)\n        external\n        returns (bytes4);\n\n    /// @notice The hook called before a swap\n    /// @param sender The initial msg.sender for the swap call\n    /// @param key The key for the pool\n    /// @param params The parameters for the swap\n    /// @param hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    /// @return BeforeSwapDelta The hook's delta in specified and unspecified currencies. Positive: the hook is owed/took currency, negative: the hook owes/sent currency\n    /// @return uint24 Optionally override the lp fee, only used if three conditions are met: 1. the Pool has a dynamic fee, 2. the value's 2nd highest bit is set (23rd bit, 0x400000), and 3. the value is less than or equal to the maximum fee (1 million)\n    function beforeSwap(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        bytes calldata hookData\n    ) external returns (bytes4, BeforeSwapDelta, uint24);\n}\n"}, "lib/v4-core/src/libraries/SafeCast.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {CustomRevert} from \"./CustomRevert.sol\";\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n    using CustomRevert for bytes4;\n\n    error SafeCastOverflow();\n\n    /// @notice Cast a uint256 to a uint160, revert on overflow\n    /// @param x The uint256 to be downcasted\n    /// @return y The downcasted integer, now type uint160\n    function toUint160(uint256 x) internal pure returns (uint160 y) {\n        y = uint160(x);\n        if (y != x) SafeCastOverflow.selector.revertWith();\n    }\n\n    /// @notice Cast a uint256 to a uint128, revert on overflow\n    /// @param x The uint256 to be downcasted\n    /// @return y The downcasted integer, now type uint128\n    function toUint128(uint256 x) internal pure returns (uint128 y) {\n        y = uint128(x);\n        if (x != y) SafeCastOverflow.selector.revertWith();\n    }\n\n    /// @notice Cast a int128 to a uint128, revert on overflow or underflow\n    /// @param x The int128 to be casted\n    /// @return y The casted integer, now type uint128\n    function toUint128(int128 x) internal pure returns (uint128 y) {\n        if (x < 0) SafeCastOverflow.selector.revertWith();\n        y = uint128(x);\n    }\n\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\n    /// @param x The int256 to be downcasted\n    /// @return y The downcasted integer, now type int128\n    function toInt128(int256 x) internal pure returns (int128 y) {\n        y = int128(x);\n        if (y != x) SafeCastOverflow.selector.revertWith();\n    }\n\n    /// @notice Cast a uint256 to a int256, revert on overflow\n    /// @param x The uint256 to be casted\n    /// @return y The casted integer, now type int256\n    function toInt256(uint256 x) internal pure returns (int256 y) {\n        y = int256(x);\n        if (y < 0) SafeCastOverflow.selector.revertWith();\n    }\n\n    /// @notice Cast a uint256 to a int128, revert on overflow\n    /// @param x The uint256 to be downcasted\n    /// @return The downcasted integer, now type int128\n    function toInt128(uint256 x) internal pure returns (int128) {\n        if (x >= 1 << 127) SafeCastOverflow.selector.revertWith();\n        return int128(int256(x));\n    }\n}\n"}, "lib/v4-core/src/libraries/LPFeeLibrary.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {CustomRevert} from \"./CustomRevert.sol\";\n\n/// @notice Library of helper functions for a pools LP fee\nlibrary LPFeeLibrary {\n    using LPFeeLibrary for uint24;\n    using CustomRevert for bytes4;\n\n    /// @notice Thrown when the static or dynamic fee on a pool exceeds 100%.\n    error LPFeeTooLarge(uint24 fee);\n\n    /// @notice An lp fee of exactly 0b1000000... signals a dynamic fee pool. This isn't a valid static fee as it is > MAX_LP_FEE\n    uint24 public constant DYNAMIC_FEE_FLAG = 0x800000;\n\n    /// @notice the second bit of the fee returned by beforeSwap is used to signal if the stored LP fee should be overridden in this swap\n    // only dynamic-fee pools can return a fee via the beforeSwap hook\n    uint24 public constant OVERRIDE_FEE_FLAG = 0x400000;\n\n    /// @notice mask to remove the override fee flag from a fee returned by the beforeSwaphook\n    uint24 public constant REMOVE_OVERRIDE_MASK = 0xBFFFFF;\n\n    /// @notice the lp fee is represented in hundredths of a bip, so the max is 100%\n    uint24 public constant MAX_LP_FEE = 1000000;\n\n    /// @notice returns true if a pool's LP fee signals that the pool has a dynamic fee\n    /// @param self The fee to check\n    /// @return bool True of the fee is dynamic\n    function isDynamicFee(uint24 self) internal pure returns (bool) {\n        return self == DYNAMIC_FEE_FLAG;\n    }\n\n    /// @notice returns true if an LP fee is valid, aka not above the maximum permitted fee\n    /// @param self The fee to check\n    /// @return bool True of the fee is valid\n    function isValid(uint24 self) internal pure returns (bool) {\n        return self <= MAX_LP_FEE;\n    }\n\n    /// @notice validates whether an LP fee is larger than the maximum, and reverts if invalid\n    /// @param self The fee to validate\n    function validate(uint24 self) internal pure {\n        if (!self.isValid()) LPFeeTooLarge.selector.revertWith(self);\n    }\n\n    /// @notice gets and validates the initial LP fee for a pool. Dynamic fee pools have an initial fee of 0.\n    /// @dev if a dynamic fee pool wants a non-0 initial fee, it should call `updateDynamicLPFee` in the afterInitialize hook\n    /// @param self The fee to get the initial LP from\n    /// @return initialFee 0 if the fee is dynamic, otherwise the fee (if valid)\n    function getInitialLPFee(uint24 self) internal pure returns (uint24) {\n        // the initial fee for a dynamic fee pool is 0\n        if (self.isDynamicFee()) return 0;\n        self.validate();\n        return self;\n    }\n\n    /// @notice returns true if the fee has the override flag set (2nd highest bit of the uint24)\n    /// @param self The fee to check\n    /// @return bool True of the fee has the override flag set\n    function isOverride(uint24 self) internal pure returns (bool) {\n        return self & OVERRIDE_FEE_FLAG != 0;\n    }\n\n    /// @notice returns a fee with the override flag removed\n    /// @param self The fee to remove the override flag from\n    /// @return fee The fee without the override flag set\n    function removeOverrideFlag(uint24 self) internal pure returns (uint24) {\n        return self & REMOVE_OVERRIDE_MASK;\n    }\n\n    /// @notice Removes the override flag and validates the fee (reverts if the fee is too large)\n    /// @param self The fee to remove the override flag from, and then validate\n    /// @return fee The fee without the override flag set (if valid)\n    function removeOverrideFlagAndValidate(uint24 self) internal pure returns (uint24 fee) {\n        fee = self.removeOverrideFlag();\n        fee.validate();\n    }\n}\n"}, "lib/v4-core/src/libraries/ParseBytes.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\n/// @notice Parses bytes returned from hooks and the byte selector used to check return selectors from hooks.\n/// @dev parseSelector also is used to parse the expected selector\n/// For parsing hook returns, note that all hooks return either bytes4 or (bytes4, 32-byte-delta) or (bytes4, 32-byte-delta, uint24).\nlibrary ParseBytes {\n    function parseSelector(bytes memory result) internal pure returns (bytes4 selector) {\n        // equivalent: (selector,) = abi.decode(result, (bytes4, int256));\n        assembly (\"memory-safe\") {\n            selector := mload(add(result, 0x20))\n        }\n    }\n\n    function parseFee(bytes memory result) internal pure returns (uint24 lpFee) {\n        // equivalent: (,, lpFee) = abi.decode(result, (bytes4, int256, uint24));\n        assembly (\"memory-safe\") {\n            lpFee := mload(add(result, 0x60))\n        }\n    }\n\n    function parseReturnDelta(bytes memory result) internal pure returns (int256 hookReturn) {\n        // equivalent: (, hookReturnDelta) = abi.decode(result, (bytes4, int256));\n        assembly (\"memory-safe\") {\n            hookReturn := mload(add(result, 0x40))\n        }\n    }\n}\n"}, "lib/v4-core/src/libraries/FullMath.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = a * b\n            // Compute the product mod 2**256 and mod 2**256 - 1\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2**256 + prod0\n            uint256 prod0 = a * b; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly (\"memory-safe\") {\n                let mm := mulmod(a, b, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Make sure the result is less than 2**256.\n            // Also prevents denominator == 0\n            require(denominator > prod1);\n\n            // Handle non-overflow cases, 256 by 256 division\n            if (prod1 == 0) {\n                assembly (\"memory-safe\") {\n                    result := div(prod0, denominator)\n                }\n                return result;\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0]\n            // Compute remainder using mulmod\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                remainder := mulmod(a, b, denominator)\n            }\n            // Subtract 256 bit number from 512 bit number\n            assembly (\"memory-safe\") {\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator\n            // Compute largest power of two divisor of denominator.\n            // Always >= 1.\n            uint256 twos = (0 - denominator) & denominator;\n            // Divide denominator by power of two\n            assembly (\"memory-safe\") {\n                denominator := div(denominator, twos)\n            }\n\n            // Divide [prod1 prod0] by the factors of two\n            assembly (\"memory-safe\") {\n                prod0 := div(prod0, twos)\n            }\n            // Shift in bits from prod1 into prod0. For this we need\n            // to flip `twos` such that it is 2**256 / twos.\n            // If twos is zero, then it becomes one\n            assembly (\"memory-safe\") {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n            uint256 inv = (3 * denominator) ^ 2;\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the preconditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n            return result;\n        }\n    }\n\n    /// @notice Calculates ceil(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            result = mulDiv(a, b, denominator);\n            if (mulmod(a, b, denominator) != 0) {\n                require(++result > 0);\n            }\n        }\n    }\n}\n"}, "lib/v4-core/src/libraries/UnsafeMath.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title Math functions that do not check inputs or outputs\n/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks\nlibrary UnsafeMath {\n    /// @notice Returns ceil(x / y)\n    /// @dev division by 0 will return 0, and should be checked externally\n    /// @param x The dividend\n    /// @param y The divisor\n    /// @return z The quotient, ceil(x / y)\n    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly (\"memory-safe\") {\n            z := add(div(x, y), gt(mod(x, y), 0))\n        }\n    }\n\n    /// @notice Calculates floor(a\u00d7b\u00f7denominator)\n    /// @dev division by 0 will return 0, and should be checked externally\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result, floor(a\u00d7b\u00f7denominator)\n    function simpleMulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n        assembly (\"memory-safe\") {\n            result := div(mul(a, b), denominator)\n        }\n    }\n}\n"}, "lib/v4-core/src/libraries/FixedPoint96.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title FixedPoint96\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n/// @dev Used in SqrtPriceMath.sol\nlibrary FixedPoint96 {\n    uint8 internal constant RESOLUTION = 96;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n}\n"}, "lib/biddog/src/AmAmm.sol": {"content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.30;\n\nimport {LibMulticaller} from \"multicaller/LibMulticaller.sol\";\n\nimport {PoolId} from \"@uniswap/v4-core/src/types/PoolId.sol\";\nimport {Currency} from \"@uniswap/v4-core/src/types/Currency.sol\";\n\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport {IAmAmm} from \"./interfaces/IAmAmm.sol\";\n\n/// @title AmAmm\n/// @author zefram.eth\n/// @notice Implements the auction mechanism from the am-AMM paper (https://arxiv.org/abs/2403.03367)\nabstract contract AmAmm is IAmAmm {\n    /// -----------------------------------------------------------------------\n    /// Library usage\n    /// -----------------------------------------------------------------------\n\n    using SafeCastLib for *;\n    using FixedPointMathLib for *;\n\n    /// -----------------------------------------------------------------------\n    /// Constants\n    /// -----------------------------------------------------------------------\n\n    function K(PoolId) internal view virtual returns (uint48) {\n        return 7200;\n    }\n\n    function MIN_BID_MULTIPLIER(PoolId) internal view virtual returns (uint256) {\n        return 1.1e18;\n    }\n\n    function MIN_RENT(PoolId) internal view virtual returns (uint128) {\n        return 0;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Immutable args\n    /// -----------------------------------------------------------------------\n\n    /// @dev The block number at which the contract was deployed\n    uint256 internal immutable _deploymentBlockNumber;\n\n    /// -----------------------------------------------------------------------\n    /// Storage variables\n    /// -----------------------------------------------------------------------\n\n    mapping(PoolId id => Bid) internal _topBids;\n    mapping(PoolId id => Bid) internal _nextBids;\n    mapping(PoolId id => uint48) internal _lastUpdatedBlockIdx;\n    mapping(Currency currency => uint256) internal _totalFees;\n    mapping(address manager => mapping(PoolId id => uint256)) internal _refunds;\n    mapping(address manager => mapping(Currency currency => uint256)) internal _fees;\n\n    /// -----------------------------------------------------------------------\n    /// Constructor\n    /// -----------------------------------------------------------------------\n\n    constructor() {\n        _deploymentBlockNumber = block.number;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Bidder actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IAmAmm\n    function bid(PoolId id, address manager, bytes6 payload, uint128 rent, uint128 deposit) external virtual override {\n        /// -----------------------------------------------------------------------\n        /// Validation\n        /// -----------------------------------------------------------------------\n\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        if (!_amAmmEnabled(id)) {\n            revert AmAmm__NotEnabled();\n        }\n\n        /// -----------------------------------------------------------------------\n        /// State updates\n        /// -----------------------------------------------------------------------\n\n        // update state machine\n        _updateAmAmmWrite(id);\n\n        // ensure bid is valid\n        // - manager can't be zero address\n        // - bid needs to be greater than the next bid by >10%\n        // - deposit needs to cover the rent for K blocks\n        // - deposit needs to be a multiple of rent\n        // - payload needs to be valid\n        // - rent needs to be at least MIN_RENT\n        if (\n            manager == address(0) || rent <= _nextBids[id].rent.mulWad(MIN_BID_MULTIPLIER(id)) || deposit < rent * K(id)\n                || deposit % rent != 0 || !_payloadIsValid(id, payload) || rent < MIN_RENT(id)\n        ) {\n            revert AmAmm__InvalidBid();\n        }\n\n        // refund deposit of the previous next bid\n        _refunds[_nextBids[id].manager][id] += _nextBids[id].deposit;\n\n        // update next bid\n        uint48 blockIdx = uint48(block.number - _deploymentBlockNumber);\n        _nextBids[id] = Bid(manager, blockIdx, payload, rent, deposit);\n\n        /// -----------------------------------------------------------------------\n        /// External calls\n        /// -----------------------------------------------------------------------\n\n        // transfer deposit from msg.sender to this contract\n        _pullBidToken(id, msgSender, deposit);\n\n        emit SubmitBid(id, manager, blockIdx, payload, rent, deposit);\n    }\n\n    /// @inheritdoc IAmAmm\n    function depositIntoTopBid(PoolId id, uint128 amount) external virtual override {\n        /// -----------------------------------------------------------------------\n        /// Validation\n        /// -----------------------------------------------------------------------\n\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        if (!_amAmmEnabled(id)) {\n            revert AmAmm__NotEnabled();\n        }\n\n        /// -----------------------------------------------------------------------\n        /// State updates\n        /// -----------------------------------------------------------------------\n\n        // update state machine\n        _updateAmAmmWrite(id);\n\n        Bid memory topBid = _topBids[id];\n\n        // only the top bid manager can deposit into the top bid\n        if (msgSender != topBid.manager) {\n            revert AmAmm__Unauthorized();\n        }\n\n        // ensure amount is a multiple of rent\n        if (amount % topBid.rent != 0) {\n            revert AmAmm__InvalidDepositAmount();\n        }\n\n        // add amount to top bid deposit\n        _topBids[id].deposit = topBid.deposit + amount;\n\n        /// -----------------------------------------------------------------------\n        /// External calls\n        /// -----------------------------------------------------------------------\n\n        // transfer amount from msg.sender to this contract\n        _pullBidToken(id, msgSender, amount);\n\n        emit DepositIntoTopBid(id, msgSender, amount);\n    }\n\n    /// @inheritdoc IAmAmm\n    function withdrawFromTopBid(PoolId id, uint128 amount, address recipient) external virtual override {\n        /// -----------------------------------------------------------------------\n        /// Validation\n        /// -----------------------------------------------------------------------\n\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        if (!_amAmmEnabled(id)) {\n            revert AmAmm__NotEnabled();\n        }\n\n        /// -----------------------------------------------------------------------\n        /// State updates\n        /// -----------------------------------------------------------------------\n\n        // update state machine\n        _updateAmAmmWrite(id);\n\n        Bid memory topBid = _topBids[id];\n\n        // only the top bid manager can withdraw from the top bid\n        if (msgSender != topBid.manager) {\n            revert AmAmm__Unauthorized();\n        }\n\n        // ensure amount is a multiple of rent\n        if (amount % topBid.rent != 0) {\n            revert AmAmm__InvalidDepositAmount();\n        }\n\n        // require D_top / R_top >= K\n        if ((topBid.deposit - amount) / topBid.rent < K(id)) {\n            revert AmAmm__BidLocked();\n        }\n\n        // deduct amount from top bid deposit\n        _topBids[id].deposit = topBid.deposit - amount;\n\n        /// -----------------------------------------------------------------------\n        /// External calls\n        /// -----------------------------------------------------------------------\n\n        // transfer amount to recipient\n        _pushBidToken(id, recipient, amount);\n\n        emit WithdrawFromTopBid(id, msgSender, recipient, amount);\n    }\n\n    /// @inheritdoc IAmAmm\n    function depositIntoNextBid(PoolId id, uint128 amount) external virtual override {\n        /// -----------------------------------------------------------------------\n        /// Validation\n        /// -----------------------------------------------------------------------\n\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        if (!_amAmmEnabled(id)) {\n            revert AmAmm__NotEnabled();\n        }\n\n        /// -----------------------------------------------------------------------\n        /// State updates\n        /// -----------------------------------------------------------------------\n\n        // update state machine\n        _updateAmAmmWrite(id);\n\n        Bid memory nextBid = _nextBids[id];\n\n        // only the next bid manager can deposit into the next bid\n        if (msgSender != nextBid.manager) {\n            revert AmAmm__Unauthorized();\n        }\n\n        // ensure amount is a multiple of rent\n        if (amount % nextBid.rent != 0) {\n            revert AmAmm__InvalidDepositAmount();\n        }\n\n        // add amount to next bid deposit\n        _nextBids[id].deposit = nextBid.deposit + amount;\n\n        /// -----------------------------------------------------------------------\n        /// External calls\n        /// -----------------------------------------------------------------------\n\n        // transfer amount from msg.sender to this contract\n        _pullBidToken(id, msgSender, amount);\n\n        emit DepositIntoNextBid(id, msgSender, amount);\n    }\n\n    /// @inheritdoc IAmAmm\n    function withdrawFromNextBid(PoolId id, uint128 amount, address recipient) external virtual override {\n        /// -----------------------------------------------------------------------\n        /// Validation\n        /// -----------------------------------------------------------------------\n\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        if (!_amAmmEnabled(id)) {\n            revert AmAmm__NotEnabled();\n        }\n\n        /// -----------------------------------------------------------------------\n        /// State updates\n        /// -----------------------------------------------------------------------\n\n        // update state machine\n        _updateAmAmmWrite(id);\n\n        Bid memory nextBid = _nextBids[id];\n\n        // only the next bid manager can withdraw from the next bid\n        if (msgSender != nextBid.manager) {\n            revert AmAmm__Unauthorized();\n        }\n\n        // ensure amount is a multiple of rent\n        if (amount % nextBid.rent != 0) {\n            revert AmAmm__InvalidDepositAmount();\n        }\n\n        // require D_next / R_next >= K\n        if ((nextBid.deposit - amount) / nextBid.rent < K(id)) {\n            revert AmAmm__BidLocked();\n        }\n\n        // deduct amount from next bid deposit\n        _nextBids[id].deposit = nextBid.deposit - amount;\n\n        /// -----------------------------------------------------------------------\n        /// External calls\n        /// -----------------------------------------------------------------------\n\n        // transfer amount to recipient\n        _pushBidToken(id, recipient, amount);\n\n        emit WithdrawFromNextBid(id, msgSender, recipient, amount);\n    }\n\n    /// @inheritdoc IAmAmm\n    function claimRefund(PoolId id, address recipient) external virtual override returns (uint256 refund) {\n        /// -----------------------------------------------------------------------\n        /// Validation\n        /// -----------------------------------------------------------------------\n\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        if (!_amAmmEnabled(id)) {\n            revert AmAmm__NotEnabled();\n        }\n\n        /// -----------------------------------------------------------------------\n        /// State updates\n        /// -----------------------------------------------------------------------\n\n        // update state machine\n        _updateAmAmmWrite(id);\n\n        refund = _refunds[msgSender][id];\n        if (refund == 0) {\n            return 0;\n        }\n        delete _refunds[msgSender][id];\n\n        /// -----------------------------------------------------------------------\n        /// External calls\n        /// -----------------------------------------------------------------------\n\n        // transfer refund to recipient\n        _pushBidToken(id, recipient, refund);\n\n        emit ClaimRefund(id, msgSender, recipient, refund);\n    }\n\n    /// @inheritdoc IAmAmm\n    function claimFees(Currency currency, address recipient) external virtual override returns (uint256 fees) {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        /// -----------------------------------------------------------------------\n        /// State updates\n        /// -----------------------------------------------------------------------\n\n        // update manager fees\n        fees = _fees[msgSender][currency];\n        if (fees == 0) {\n            return 0;\n        }\n        delete _fees[msgSender][currency];\n\n        // update total fees\n        unchecked {\n            // safe because _totalFees[currency] is the sum of all managers' fees\n            _totalFees[currency] -= fees;\n        }\n\n        /// -----------------------------------------------------------------------\n        /// External calls\n        /// -----------------------------------------------------------------------\n\n        // transfer fees to recipient\n        _transferFeeToken(currency, recipient, fees);\n\n        emit ClaimFees(currency, msgSender, recipient, fees);\n    }\n\n    /// @inheritdoc IAmAmm\n    function increaseBidRent(\n        PoolId id,\n        uint128 additionalRent,\n        uint128 updatedDeposit,\n        bool topBid,\n        address withdrawRecipient\n    ) external virtual override returns (uint128 amountDeposited, uint128 amountWithdrawn) {\n        /// -----------------------------------------------------------------------\n        /// Validation\n        /// -----------------------------------------------------------------------\n\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        if (!_amAmmEnabled(id)) {\n            revert AmAmm__NotEnabled();\n        }\n\n        // noop if additionalRent is 0\n        if (additionalRent == 0) return (0, 0);\n\n        /// -----------------------------------------------------------------------\n        /// State updates\n        /// -----------------------------------------------------------------------\n\n        // update state machine\n        _updateAmAmmWrite(id);\n\n        Bid storage relevantBidStorage = topBid ? _topBids[id] : _nextBids[id];\n        Bid memory relevantBid = relevantBidStorage;\n\n        // must be the manager of the relevant bid\n        if (msgSender != relevantBid.manager) {\n            revert AmAmm__Unauthorized();\n        }\n\n        uint128 newRent = relevantBid.rent + additionalRent;\n\n        // ensure that:\n        // - updatedDeposit is a multiple of newRent\n        // - newRent is >= MIN_RENT(id)\n        if (updatedDeposit % newRent != 0 || newRent < MIN_RENT(id)) {\n            revert AmAmm__InvalidBid();\n        }\n\n        // require D / R >= K\n        if (updatedDeposit / newRent < K(id)) {\n            revert AmAmm__BidLocked();\n        }\n\n        // update relevant bid\n        relevantBidStorage.rent = newRent;\n        relevantBidStorage.deposit = updatedDeposit;\n\n        /// -----------------------------------------------------------------------\n        /// External calls\n        /// -----------------------------------------------------------------------\n\n        unchecked {\n            // explicitly comparing updatedDeposit and relevantBid.deposit so subtractions are always safe\n            if (updatedDeposit > relevantBid.deposit) {\n                // transfer amount from msg.sender to this contract\n                amountDeposited = updatedDeposit - relevantBid.deposit;\n                _pullBidToken(id, msgSender, amountDeposited);\n            } else if (updatedDeposit < relevantBid.deposit) {\n                // transfer amount from this contract to withdrawRecipient\n                amountWithdrawn = relevantBid.deposit - updatedDeposit;\n                _pushBidToken(id, withdrawRecipient, amountWithdrawn);\n            }\n        }\n\n        emit IncreaseBidRent(\n            id, msgSender, additionalRent, updatedDeposit, topBid, withdrawRecipient, amountDeposited, amountWithdrawn\n        );\n    }\n\n    /// @inheritdoc IAmAmm\n    function setBidPayload(PoolId id, bytes6 payload, bool topBid) external virtual override {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        if (!_amAmmEnabled(id)) {\n            revert AmAmm__NotEnabled();\n        }\n\n        // update state machine\n        _updateAmAmmWrite(id);\n\n        Bid storage relevantBid = topBid ? _topBids[id] : _nextBids[id];\n\n        if (msgSender != relevantBid.manager) {\n            revert AmAmm__Unauthorized();\n        }\n\n        if (!_payloadIsValid(id, payload)) {\n            revert AmAmm__InvalidBid();\n        }\n\n        relevantBid.payload = payload;\n\n        emit SetBidPayload(id, msgSender, payload, topBid);\n    }\n\n    /// @inheritdoc IAmAmm\n    function updateStateMachine(PoolId id) external override {\n        _updateAmAmmWrite(id);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Getters\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IAmAmm\n    function getTopBid(PoolId id) external view override returns (Bid memory topBid) {\n        (topBid,) = _updateAmAmmView(id);\n    }\n\n    /// @inheritdoc IAmAmm\n    function getTopBidWrite(PoolId id) external override returns (Bid memory) {\n        _updateAmAmmWrite(id);\n        return _topBids[id];\n    }\n\n    /// @inheritdoc IAmAmm\n    function getNextBid(PoolId id) external view override returns (Bid memory nextBid) {\n        (, nextBid) = _updateAmAmmView(id);\n    }\n\n    /// @inheritdoc IAmAmm\n    function getNextBidWrite(PoolId id) external override returns (Bid memory) {\n        _updateAmAmmWrite(id);\n        return _nextBids[id];\n    }\n\n    /// @inheritdoc IAmAmm\n    function getRefund(address manager, PoolId id) external view override returns (uint256) {\n        return _refunds[manager][id];\n    }\n\n    /// @inheritdoc IAmAmm\n    function getRefundWrite(address manager, PoolId id) external override returns (uint256) {\n        _updateAmAmmWrite(id);\n        return _refunds[manager][id];\n    }\n\n    /// @inheritdoc IAmAmm\n    function getFees(address manager, Currency currency) external view override returns (uint256) {\n        return _fees[manager][currency];\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Virtual functions\n    /// -----------------------------------------------------------------------\n\n    /// @dev Returns whether the am-AMM is enabled for a given pool\n    function _amAmmEnabled(PoolId id) internal view virtual returns (bool);\n\n    /// @dev Validates a bid payload, e.g. ensure the swap fee is below a certain threshold\n    function _payloadIsValid(PoolId id, bytes6 payload) internal view virtual returns (bool);\n\n    /// @dev Burns bid tokens from address(this)\n    function _burnBidToken(PoolId id, uint256 amount) internal virtual;\n\n    /// @dev Transfers bid tokens from an address that's not address(this) to address(this)\n    function _pullBidToken(PoolId id, address from, uint256 amount) internal virtual;\n\n    /// @dev Transfers bid tokens from address(this) to an address that's not address(this)\n    function _pushBidToken(PoolId id, address to, uint256 amount) internal virtual;\n\n    /// @dev Transfers accrued fees from address(this)\n    function _transferFeeToken(Currency currency, address to, uint256 amount) internal virtual;\n\n    /// @dev Accrues swap fees to the manager\n    function _accrueFees(address manager, Currency currency, uint256 amount) internal virtual {\n        _fees[manager][currency] += amount;\n        _totalFees[currency] += amount;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Internal helpers\n    /// -----------------------------------------------------------------------\n\n    /// @dev Charges rent and updates the top and next bids for a given pool\n    function _updateAmAmmWrite(PoolId id) internal virtual returns (address manager, bytes6 payload) {\n        uint48 currentBlockIdx = uint48(block.number - _deploymentBlockNumber);\n\n        // early return if the pool has already been updated in this block\n        // condition is also true if no update has occurred for type(uint48).max blocks\n        // which is extremely unlikely\n        if (_lastUpdatedBlockIdx[id] == currentBlockIdx) {\n            return (_topBids[id].manager, _topBids[id].payload);\n        }\n\n        Bid memory topBid = _topBids[id];\n        Bid memory nextBid = _nextBids[id];\n        bool updatedTopBid;\n        bool updatedNextBid;\n        uint256 rentCharged;\n\n        // run state machine\n        {\n            bool stepHasUpdatedTopBid;\n            bool stepHasUpdatedNextBid;\n            uint256 stepRentCharged;\n            address stepRefundManager;\n            uint256 stepRefundAmount;\n            while (true) {\n                (\n                    topBid,\n                    nextBid,\n                    stepHasUpdatedTopBid,\n                    stepHasUpdatedNextBid,\n                    stepRentCharged,\n                    stepRefundManager,\n                    stepRefundAmount\n                ) = _stateTransition(currentBlockIdx, id, topBid, nextBid);\n\n                if (!stepHasUpdatedTopBid && !stepHasUpdatedNextBid) {\n                    break;\n                }\n\n                updatedTopBid = updatedTopBid || stepHasUpdatedTopBid;\n                updatedNextBid = updatedNextBid || stepHasUpdatedNextBid;\n                rentCharged += stepRentCharged;\n                if (stepRefundManager != address(0)) {\n                    _refunds[stepRefundManager][id] += stepRefundAmount;\n                }\n            }\n        }\n\n        // update top and next bids\n        if (updatedTopBid) {\n            _topBids[id] = topBid;\n        }\n        if (updatedNextBid) {\n            _nextBids[id] = nextBid;\n        }\n\n        // update last updated blockIdx\n        _lastUpdatedBlockIdx[id] = currentBlockIdx;\n\n        // burn rent charged\n        if (rentCharged != 0) {\n            _burnBidToken(id, rentCharged);\n        }\n\n        return (topBid.manager, topBid.payload);\n    }\n\n    /// @dev View version of _updateAmAmmWrite()\n    function _updateAmAmmView(PoolId id) internal view virtual returns (Bid memory topBid, Bid memory nextBid) {\n        uint48 currentBlockIdx = uint48(block.number - _deploymentBlockNumber);\n\n        topBid = _topBids[id];\n        nextBid = _nextBids[id];\n\n        // run state machine\n        {\n            bool stepHasUpdatedTopBid;\n            bool stepHasUpdatedNextBid;\n            while (true) {\n                (topBid, nextBid, stepHasUpdatedTopBid, stepHasUpdatedNextBid,,,) =\n                    _stateTransition(currentBlockIdx, id, topBid, nextBid);\n\n                if (!stepHasUpdatedTopBid && !stepHasUpdatedNextBid) {\n                    break;\n                }\n            }\n        }\n    }\n\n    /// @dev Returns the updated top and next bids after a single state transition\n    /// State diagram is as follows:\n    ///                                          after\n    ///                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500deposit \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    ///                 \u2502                       depletes                   \u2502\n    ///                 \u25bc                                                  \u2502\n    ///    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    ///    \u2502                        \u2502                         \u2502                        \u2502\n    ///    \u2502        State A         \u2502                         \u2502        State B         \u2502\n    ///    \u2502      Manager: nil      \u2502            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502      Manager: r0       \u2502\u25c0\u2500\u2510\n    ///    \u2502       Next: nil        \u2502            \u2502            \u2502       Next: nil        \u2502  \u2502\n    ///    \u2502                        \u2502            \u2502            \u2502                        \u2502  \u2502\n    ///    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2502            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n    ///                 \u2502                        \u2502                         \u2502              \u2502\n    ///                 \u2502                        \u2502                         \u2502              \u2502\n    ///                 \u2502                        \u2502                         \u2502              \u2502\n    ///                 \u2502                        \u2502                         \u2502              \u2502\n    ///              bid(r)                  after K                    bid(r)         after K\n    ///                 \u2502                     blocks                       \u2502           blocks\n    ///                 \u2502                        \u2502                         \u2502              \u2502\n    ///                 \u2502                        \u2502                         \u2502              \u2502\n    ///                 \u2502                        \u2502   after                 \u2502              \u2502\n    ///                 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500deposit \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    ///                 \u2502                        \u2502  depletes               \u2502              \u2502\n    ///                 \u25bc                        \u2502                         \u25bc              \u2502\n    ///    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n    ///    \u2502                        \u2502            \u2502            \u2502                        \u2502  \u2502\n    ///    \u2502        State C         \u2502            \u2502            \u2502        State D         \u2502  \u2502\n    /// \u250c\u2500\u25b6\u2502      Manager: nil      \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u250c\u2500\u25b6\u2502      Manager: r0       \u2502\u2500\u2500\u2518\n    /// \u2502  \u2502        Next: r         \u2502                      \u2502  \u2502        Next: r         \u2502\n    /// \u2502  \u2502                        \u2502                      \u2502  \u2502                        \u2502\n    /// \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                      \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    /// \u2502               \u2502                                  \u2502               \u2502\n    /// \u2502               \u2502                                  \u2502               \u2502\n    /// \u2514\u2500\u2500\u2500\u2500\u2500bid(r)\u2500\u2500\u2500\u2500\u2518                                  \u2514\u2500\u2500\u2500\u2500\u2500bid(r)\u2500\u2500\u2500\u2500\u2518\n    function _stateTransition(uint48 currentBlockIdx, PoolId id, Bid memory topBid, Bid memory nextBid)\n        internal\n        view\n        virtual\n        returns (\n            Bid memory,\n            Bid memory,\n            bool updatedTopBid,\n            bool updatedNextBid,\n            uint256 rentCharged,\n            address refundManager,\n            uint256 refundAmount\n        )\n    {\n        uint48 k = K(id);\n        if (nextBid.manager == address(0)) {\n            if (topBid.manager != address(0)) {\n                // State B\n                // charge rent from top bid\n                uint48 blocksPassed;\n                unchecked {\n                    // unchecked so that if blockIdx ever overflows, we simply wrap around\n                    // could be 0 if no update has occurred for type(uint48).max blocks\n                    // which is extremely unlikely\n                    blocksPassed = currentBlockIdx - topBid.blockIdx;\n                }\n                uint256 rentOwed = blocksPassed * topBid.rent;\n                if (rentOwed >= topBid.deposit) {\n                    // State B -> State A\n                    // the top bid's deposit has been depleted\n                    rentCharged = topBid.deposit;\n\n                    topBid = Bid(address(0), 0, 0, 0, 0);\n\n                    updatedTopBid = true;\n                } else if (rentOwed != 0) {\n                    // State B\n                    // charge rent from top bid\n                    rentCharged = rentOwed;\n\n                    topBid.deposit -= rentOwed.toUint128();\n                    topBid.blockIdx = currentBlockIdx;\n\n                    updatedTopBid = true;\n                }\n            }\n        } else {\n            if (topBid.manager == address(0)) {\n                // State C\n                // check if K blocks have passed since the next bid was submitted\n                // if so, promote next bid to top bid\n                uint48 nextBidStartBlockIdx;\n                unchecked {\n                    // unchecked so that if blockIdx ever overflows, we simply wrap around\n                    nextBidStartBlockIdx = nextBid.blockIdx + k;\n                }\n                if (currentBlockIdx >= nextBidStartBlockIdx) {\n                    // State C -> State B\n                    // promote next bid to top bid\n                    topBid = nextBid;\n                    topBid.blockIdx = nextBidStartBlockIdx;\n                    nextBid = Bid(address(0), 0, 0, 0, 0);\n\n                    updatedTopBid = true;\n                    updatedNextBid = true;\n                }\n            } else {\n                // State D\n                // we charge rent from the top bid only until K blocks after the next bid was submitted\n                // assuming the next bid's rent is greater than the top bid's rent + 10%, otherwise we don't care about\n                // the next bid\n                bool nextBidIsBetter = nextBid.rent > topBid.rent.mulWad(MIN_BID_MULTIPLIER(id));\n                uint48 blocksPassed;\n                unchecked {\n                    // unchecked so that if blockIdx ever overflows, we simply wrap around\n                    blocksPassed = nextBidIsBetter\n                        ? uint48(\n                            FixedPointMathLib.min(currentBlockIdx - topBid.blockIdx, nextBid.blockIdx + k - topBid.blockIdx)\n                        )\n                        : currentBlockIdx - topBid.blockIdx;\n                }\n                uint256 rentOwed = blocksPassed * topBid.rent;\n                if (rentOwed >= topBid.deposit) {\n                    // State D -> State C\n                    // top bid has insufficient deposit\n                    // clear the top bid and make sure the next bid starts >= the latest processed blockIdx\n                    rentCharged = topBid.deposit;\n\n                    topBid = Bid(address(0), 0, 0, 0, 0);\n                    unchecked {\n                        // unchecked so that if blockIdx ever underflows, we simply wrap around\n                        uint48 latestProcessedBlockIdx = nextBidIsBetter\n                            ? uint48(FixedPointMathLib.min(currentBlockIdx, nextBid.blockIdx + k))\n                            : currentBlockIdx;\n                        nextBid.blockIdx = uint48(FixedPointMathLib.max(nextBid.blockIdx, latestProcessedBlockIdx - k));\n                    }\n\n                    updatedTopBid = true;\n                    updatedNextBid = true;\n                } else {\n                    // State D\n                    // top bid has sufficient deposit\n                    // charge rent from top bid\n                    if (rentOwed != 0) {\n                        rentCharged = rentOwed;\n\n                        topBid.deposit -= rentOwed.toUint128();\n                        topBid.blockIdx = currentBlockIdx;\n\n                        updatedTopBid = true;\n                    }\n\n                    // check if K blocks have passed since the next bid was submitted\n                    // and that the next bid's rent is greater than the top bid's rent + 10%\n                    // if so, promote next bid to top bid\n                    uint48 nextBidStartBlockIdx;\n                    unchecked {\n                        // unchecked so that if blockIdx ever overflows, we simply wrap around\n                        nextBidStartBlockIdx = nextBid.blockIdx + k;\n                    }\n                    if (currentBlockIdx >= nextBidStartBlockIdx && nextBidIsBetter) {\n                        // State D -> State B\n                        // refund remaining deposit to top bid manager\n                        (refundManager, refundAmount) = (topBid.manager, topBid.deposit);\n\n                        // promote next bid to top bid\n                        topBid = nextBid;\n                        topBid.blockIdx = nextBidStartBlockIdx;\n                        nextBid = Bid(address(0), 0, 0, 0, 0);\n\n                        updatedTopBid = true;\n                        updatedNextBid = true;\n                    }\n                }\n            }\n        }\n\n        return (topBid, nextBid, updatedTopBid, updatedNextBid, rentCharged, refundManager, refundAmount);\n    }\n}\n"}, "src/base/Ownable.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IOwnable} from \"../interfaces/IOwnable.sol\";\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\n///\n/// @dev Note:\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\n///\n/// While the ownable portion follows\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\nabstract contract Ownable is IOwnable {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                           EVENTS                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev `keccak256(bytes(\"OwnershipTransferred(address,address)\"))`.\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverRequested(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverCanceled(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          STORAGE                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The owner slot is given by:\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\"_OWNER_SLOT_NOT\")))))`.\n    /// It is intentionally chosen to be a high value\n    /// to avoid collision with lower slots.\n    /// The choice of manual storage layout is to enable compatibility\n    /// with both regular and upgradeable contracts.\n    bytes32 internal constant _OWNER_SLOT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;\n\n    /// The ownership handover slot of `newOwner` is given by:\n    /// ```\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\n    ///     let handoverSlot := keccak256(0x00, 0x20)\n    /// ```\n    /// It stores the expiry timestamp of the two-step ownership handover.\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                     INTERNAL FUNCTIONS                     */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Initializes the owner directly without authorization guard.\n    /// This function must be called upon initialization,\n    /// regardless of whether the contract is upgradeable or not.\n    /// This is to enable generalization to both regular and upgradeable contracts,\n    /// and to save gas in case the initial owner is not the caller.\n    /// For performance reasons, this function will not check if there\n    /// is an existing owner.\n    function _initializeOwner(address newOwner) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean the upper 96 bits.\n            newOwner := shr(96, shl(96, newOwner))\n            // Store the new value.\n            sstore(_OWNER_SLOT, newOwner)\n            // Emit the {OwnershipTransferred} event.\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n        }\n    }\n\n    /// @dev Sets the owner directly without authorization guard.\n    function _setOwner(address newOwner) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ownerSlot := _OWNER_SLOT\n            // Clean the upper 96 bits.\n            newOwner := shr(96, shl(96, newOwner))\n            // Emit the {OwnershipTransferred} event.\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n            // Store the new value.\n            sstore(ownerSlot, newOwner)\n        }\n    }\n\n    /// @dev Throws if the sender is not the owner.\n    function _checkOwner() internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the caller is not the stored owner, revert.\n            if iszero(eq(caller(), sload(_OWNER_SLOT))) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\n    /// Override to return a different value if needed.\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\n        return 48 * 3600;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(shl(96, newOwner)) {\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _setOwner(newOwner);\n    }\n\n    /// @dev Allows the owner to renounce their ownership.\n    function renounceOwnership() public payable virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /// @dev Request a two-step ownership handover to the caller.\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\n    function requestOwnershipHandover() public payable virtual {\n        unchecked {\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Compute and set the handover slot to `expires`.\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\n                mstore(0x00, caller())\n                sstore(keccak256(0x0c, 0x20), expires)\n                // Emit the {OwnershipHandoverRequested} event.\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\n            }\n        }\n    }\n\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\n    function cancelOwnershipHandover() public payable virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x20), 0)\n            // Emit the {OwnershipHandoverCanceled} event.\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\n        }\n    }\n\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            let handoverSlot := keccak256(0x0c, 0x20)\n            // If the handover does not exist, or has expired.\n            if gt(timestamp(), sload(handoverSlot)) {\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\n                revert(0x1c, 0x04)\n            }\n            // Set the handover slot to 0.\n            sstore(handoverSlot, 0)\n        }\n        _setOwner(pendingOwner);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                   PUBLIC READ FUNCTIONS                    */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the owner of the contract.\n    function owner() public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_OWNER_SLOT)\n        }\n    }\n\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\n    function ownershipHandoverExpiresAt(address pendingOwner) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the handover slot.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            // Load the handover slot.\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         MODIFIERS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Marks a function as only callable by the owner.\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n}\n"}, "src/base/BaseHook.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\nimport {BeforeSwapDelta} from \"@uniswap/v4-core/src/types/BeforeSwapDelta.sol\";\n\nimport \"../interfaces/IBaseHook.sol\";\n\nabstract contract BaseHook is IBaseHook {\n    /// @notice The address of the pool manager\n    IPoolManager public immutable override poolManager;\n\n    constructor(IPoolManager _poolManager) {\n        poolManager = _poolManager;\n    }\n\n    /// @dev Only the pool manager may call this function\n    modifier poolManagerOnly() {\n        if (msg.sender != address(poolManager)) revert NotPoolManager();\n        _;\n    }\n\n    function afterInitialize(address, PoolKey calldata, uint160, int24) external virtual override returns (bytes4);\n\n    function beforeSwap(address, PoolKey calldata, IPoolManager.SwapParams calldata, bytes calldata)\n        external\n        virtual\n        override\n        returns (bytes4, BeforeSwapDelta, uint24);\n}\n"}, "src/base/ReentrancyGuard.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nabstract contract ReentrancyGuard {\n    error ReentrancyGuard__ReentrantCall();\n\n    /// @dev Equal to uint256(keccak256(\"STATUS\")) - 1\n    uint256 private constant STATUS_SLOT = 0x99d6ee9363d15a40a5ab48bebc5e3e7dd2c4e190c950f55fe724fad94b380d7e;\n    uint256 private constant NOT_ENTERED = 0;\n    uint256 private constant ENTERED = 1;\n\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() internal {\n        uint256 statusSlot = STATUS_SLOT;\n        uint256 status;\n        /// @solidity memory-safe-assembly\n        assembly {\n            status := tload(statusSlot)\n        }\n        if (status == ENTERED) revert ReentrancyGuard__ReentrantCall();\n\n        uint256 entered = ENTERED;\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(statusSlot, entered)\n        }\n    }\n\n    function _nonReentrantAfter() internal {\n        uint256 statusSlot = STATUS_SLOT;\n        uint256 notEntered = NOT_ENTERED;\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(statusSlot, notEntered)\n        }\n    }\n}\n"}, "src/lib/SwapMath.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {FullMath} from \"@uniswap/v4-core/src/libraries/FullMath.sol\";\n\nimport {SqrtPriceMath} from \"./SqrtPriceMath.sol\";\n\n/// @title Computes the result of a swap within ticks\n/// @notice Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.\nlibrary SwapMath {\n    /// @notice Computes the sqrt price target for the next swap step\n    /// @param zeroForOne The direction of the swap, true for currency0 to currency1, false for currency1 to currency0\n    /// @param sqrtPriceNextX96 The Q64.96 sqrt price for the next initialized tick\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value\n    /// after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @return sqrtPriceTargetX96 The price target for the next swap step\n    function getSqrtPriceTarget(bool zeroForOne, uint160 sqrtPriceNextX96, uint160 sqrtPriceLimitX96)\n        internal\n        pure\n        returns (uint160 sqrtPriceTargetX96)\n    {\n        assembly (\"memory-safe\") {\n            // a flag to toggle between sqrtPriceNextX96 and sqrtPriceLimitX96\n            // when zeroForOne == true, nextOrLimit reduces to sqrtPriceNextX96 >= sqrtPriceLimitX96\n            // sqrtPriceTargetX96 = max(sqrtPriceNextX96, sqrtPriceLimitX96)\n            // when zeroForOne == false, nextOrLimit reduces to sqrtPriceNextX96 < sqrtPriceLimitX96\n            // sqrtPriceTargetX96 = min(sqrtPriceNextX96, sqrtPriceLimitX96)\n            sqrtPriceNextX96 := and(sqrtPriceNextX96, 0xffffffffffffffffffffffffffffffffffffffff)\n            sqrtPriceLimitX96 := and(sqrtPriceLimitX96, 0xffffffffffffffffffffffffffffffffffffffff)\n            let nextOrLimit := xor(lt(sqrtPriceNextX96, sqrtPriceLimitX96), and(zeroForOne, 0x1))\n            let symDiff := xor(sqrtPriceNextX96, sqrtPriceLimitX96)\n            sqrtPriceTargetX96 := xor(sqrtPriceLimitX96, mul(symDiff, nextOrLimit))\n        }\n    }\n\n    /// @notice Computes the result of swapping some amount in, or amount out, given the parameters of the swap\n    /// @dev If the swap's amountSpecified is negative, the combined fee and input amount will never exceed the absolute value of the remaining amount.\n    /// @param sqrtPriceCurrentX96 The current sqrt price of the pool\n    /// @param sqrtPriceTargetX96 The price that cannot be exceeded, from which the direction of the swap is inferred\n    /// @param liquidity The usable liquidity\n    /// @param amountRemaining How much input or output amount is remaining to be swapped in/out\n    /// @return sqrtPriceNextX96 The price after swapping the amount in/out, not to exceed the price target\n    /// @return amountIn The amount to be swapped in, of either currency0 or currency1, based on the direction of the swap\n    /// @return amountOut The amount to be received, of either currency0 or currency1, based on the direction of the swap\n    function computeSwapStep(\n        uint160 sqrtPriceCurrentX96,\n        uint160 sqrtPriceTargetX96,\n        uint256 liquidity,\n        int256 amountRemaining\n    ) internal pure returns (uint160 sqrtPriceNextX96, uint256 amountIn, uint256 amountOut) {\n        unchecked {\n            bool zeroForOne = sqrtPriceCurrentX96 >= sqrtPriceTargetX96;\n            bool exactIn = amountRemaining < 0;\n\n            if (exactIn) {\n                uint256 amountRemainingAbs = uint256(-amountRemaining);\n                amountIn = zeroForOne\n                    ? SqrtPriceMath.getAmount0Delta(sqrtPriceTargetX96, sqrtPriceCurrentX96, liquidity, true)\n                    : SqrtPriceMath.getAmount1Delta(sqrtPriceCurrentX96, sqrtPriceTargetX96, liquidity, true);\n                if (amountRemainingAbs >= amountIn) {\n                    // `amountIn` is capped by the target price\n                    sqrtPriceNextX96 = sqrtPriceTargetX96;\n                } else {\n                    // exhaust the remaining amount\n                    amountIn = amountRemainingAbs;\n                    sqrtPriceNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(\n                        sqrtPriceCurrentX96, liquidity, amountRemainingAbs, zeroForOne\n                    );\n                }\n                amountOut = zeroForOne\n                    ? SqrtPriceMath.getAmount1Delta(sqrtPriceNextX96, sqrtPriceCurrentX96, liquidity, false)\n                    : SqrtPriceMath.getAmount0Delta(sqrtPriceCurrentX96, sqrtPriceNextX96, liquidity, false);\n            } else {\n                amountOut = zeroForOne\n                    ? SqrtPriceMath.getAmount1Delta(sqrtPriceTargetX96, sqrtPriceCurrentX96, liquidity, false)\n                    : SqrtPriceMath.getAmount0Delta(sqrtPriceCurrentX96, sqrtPriceTargetX96, liquidity, false);\n                if (uint256(amountRemaining) >= amountOut) {\n                    // `amountOut` is capped by the target price\n                    sqrtPriceNextX96 = sqrtPriceTargetX96;\n                } else {\n                    // cap the output amount to not exceed the remaining output amount\n                    amountOut = uint256(amountRemaining);\n                    sqrtPriceNextX96 =\n                        SqrtPriceMath.getNextSqrtPriceFromOutput(sqrtPriceCurrentX96, liquidity, amountOut, zeroForOne);\n                }\n                amountIn = zeroForOne\n                    ? SqrtPriceMath.getAmount0Delta(sqrtPriceNextX96, sqrtPriceCurrentX96, liquidity, true)\n                    : SqrtPriceMath.getAmount1Delta(sqrtPriceCurrentX96, sqrtPriceNextX96, liquidity, true);\n            }\n        }\n    }\n}\n"}, "src/lib/SqrtPriceMath.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {SafeCast} from \"@uniswap/v4-core/src/libraries/SafeCast.sol\";\n\nimport {FullMath} from \"@uniswap/v4-core/src/libraries/FullMath.sol\";\nimport {UnsafeMath} from \"@uniswap/v4-core/src/libraries/UnsafeMath.sol\";\nimport {FixedPoint96} from \"@uniswap/v4-core/src/libraries/FixedPoint96.sol\";\n\n/// @title Functions based on Q64.96 sqrt price and liquidity\n/// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas\nlibrary SqrtPriceMath {\n    using SafeCast for uint256;\n\n    error InvalidPriceOrLiquidity();\n    error InvalidPrice();\n    error NotEnoughLiquidity();\n    error PriceOverflow();\n\n    /// @notice Gets the next sqrt price given a delta of currency0\n    /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least\n    /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the\n    /// price less in order to not send too much output.\n    /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),\n    /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).\n    /// @param sqrtPX96 The starting price, i.e. before accounting for the currency0 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of currency0 to add or remove from virtual reserves\n    /// @param add Whether to add or remove the amount of currency0\n    /// @return The price after adding or removing amount, depending on add\n    function getNextSqrtPriceFromAmount0RoundingUp(uint160 sqrtPX96, uint256 liquidity, uint256 amount, bool add)\n        internal\n        pure\n        returns (uint160)\n    {\n        // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price\n        if (amount == 0) return sqrtPX96;\n        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n\n        if (add) {\n            unchecked {\n                uint256 product = amount * sqrtPX96;\n                if (product / amount == sqrtPX96) {\n                    uint256 denominator = numerator1 + product;\n                    if (denominator >= numerator1) {\n                        // always fits in 160 bits\n                        return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));\n                    }\n                }\n            }\n            // denominator is checked for overflow\n            return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96) + amount));\n        } else {\n            unchecked {\n                uint256 product = amount * sqrtPX96;\n                // if the product overflows, we know the denominator underflows\n                // in addition, we must check that the denominator does not underflow\n                // equivalent: if (product / amount != sqrtPX96 || numerator1 <= product) revert PriceOverflow();\n                assembly (\"memory-safe\") {\n                    if iszero(\n                        and(\n                            eq(div(product, amount), and(sqrtPX96, 0xffffffffffffffffffffffffffffffffffffffff)),\n                            gt(numerator1, product)\n                        )\n                    ) {\n                        mstore(0, 0xf5c787f1) // selector for PriceOverflow()\n                        revert(0x1c, 0x04)\n                    }\n                }\n                uint256 denominator = numerator1 - product;\n                return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();\n            }\n        }\n    }\n\n    /// @notice Gets the next sqrt price given a delta of currency1\n    /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least\n    /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the\n    /// price less in order to not send too much output.\n    /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the currency1 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of currency1 to add, or remove, from virtual reserves\n    /// @param add Whether to add, or remove, the amount of currency1\n    /// @return The price after adding or removing `amount`\n    function getNextSqrtPriceFromAmount1RoundingDown(uint160 sqrtPX96, uint256 liquidity, uint256 amount, bool add)\n        internal\n        pure\n        returns (uint160)\n    {\n        // if we're adding (subtracting), rounding down requires rounding the quotient down (up)\n        // in both cases, avoid a mulDiv for most inputs\n        if (add) {\n            uint256 quotient = (\n                amount <= type(uint160).max\n                    ? (amount << FixedPoint96.RESOLUTION) / liquidity\n                    : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)\n            );\n\n            return (uint256(sqrtPX96) + quotient).toUint160();\n        } else {\n            uint256 quotient = (\n                amount <= type(uint160).max\n                    ? UnsafeMath.divRoundingUp(amount << FixedPoint96.RESOLUTION, liquidity)\n                    : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity)\n            );\n\n            // equivalent: if (sqrtPX96 <= quotient) revert NotEnoughLiquidity();\n            assembly (\"memory-safe\") {\n                if iszero(gt(and(sqrtPX96, 0xffffffffffffffffffffffffffffffffffffffff), quotient)) {\n                    mstore(0, 0x4323a555) // selector for NotEnoughLiquidity()\n                    revert(0x1c, 0x04)\n                }\n            }\n            // always fits 160 bits\n            unchecked {\n                return uint160(sqrtPX96 - quotient);\n            }\n        }\n    }\n\n    /// @notice Gets the next sqrt price given an input amount of currency0 or currency1\n    /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount\n    /// @param liquidity The amount of usable liquidity\n    /// @param amountIn How much of currency0, or currency1, is being swapped in\n    /// @param zeroForOne Whether the amount in is currency0 or currency1\n    /// @return uint160 The price after adding the input amount to currency0 or currency1\n    function getNextSqrtPriceFromInput(uint160 sqrtPX96, uint256 liquidity, uint256 amountIn, bool zeroForOne)\n        internal\n        pure\n        returns (uint160)\n    {\n        // equivalent: if (sqrtPX96 == 0 || liquidity == 0) revert InvalidPriceOrLiquidity();\n        assembly (\"memory-safe\") {\n            if or(\n                iszero(and(sqrtPX96, 0xffffffffffffffffffffffffffffffffffffffff)),\n                iszero(and(liquidity, 0xffffffffffffffffffffffffffffffff))\n            ) {\n                mstore(0, 0x4f2461b8) // selector for InvalidPriceOrLiquidity()\n                revert(0x1c, 0x04)\n            }\n        }\n\n        // round to make sure that we don't pass the target price\n        return zeroForOne\n            ? getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)\n            : getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);\n    }\n\n    /// @notice Gets the next sqrt price given an output amount of currency0 or currency1\n    /// @dev Throws if price or liquidity are 0 or the next price is out of bounds\n    /// @param sqrtPX96 The starting price before accounting for the output amount\n    /// @param liquidity The amount of usable liquidity\n    /// @param amountOut How much of currency0, or currency1, is being swapped out\n    /// @param zeroForOne Whether the amount out is currency1 or currency0\n    /// @return uint160 The price after removing the output amount of currency0 or currency1\n    function getNextSqrtPriceFromOutput(uint160 sqrtPX96, uint256 liquidity, uint256 amountOut, bool zeroForOne)\n        internal\n        pure\n        returns (uint160)\n    {\n        // equivalent: if (sqrtPX96 == 0 || liquidity == 0) revert InvalidPriceOrLiquidity();\n        assembly (\"memory-safe\") {\n            if or(iszero(and(sqrtPX96, 0xffffffffffffffffffffffffffffffffffffffff)), iszero(liquidity)) {\n                mstore(0, 0x4f2461b8) // selector for InvalidPriceOrLiquidity()\n                revert(0x1c, 0x04)\n            }\n        }\n\n        // round to make sure that we pass the target price\n        return zeroForOne\n            ? getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)\n            : getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);\n    }\n\n    /// @notice Gets the amount0 delta between two prices\n    /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),\n    /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\n    /// @param sqrtPriceAX96 A sqrt price\n    /// @param sqrtPriceBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param roundUp Whether to round the amount up or down\n    /// @return uint256 Amount of currency0 required to cover a position of size liquidity between the two passed prices\n    function getAmount0Delta(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint256 liquidity, bool roundUp)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            if (sqrtPriceAX96 > sqrtPriceBX96) (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96);\n\n            // equivalent: if (sqrtPriceAX96 == 0) revert InvalidPrice();\n            assembly (\"memory-safe\") {\n                if iszero(and(sqrtPriceAX96, 0xffffffffffffffffffffffffffffffffffffffff)) {\n                    mstore(0, 0x00bfc921) // selector for InvalidPrice()\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n            uint256 numerator2 = sqrtPriceBX96 - sqrtPriceAX96;\n\n            return roundUp\n                ? UnsafeMath.divRoundingUp(FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtPriceBX96), sqrtPriceAX96)\n                : FullMath.mulDiv(numerator1, numerator2, sqrtPriceBX96) / sqrtPriceAX96;\n        }\n    }\n\n    /// @notice Equivalent to: `a >= b ? a - b : b - a`\n    function absDiff(uint160 a, uint160 b) internal pure returns (uint256 res) {\n        assembly (\"memory-safe\") {\n            let diff :=\n                sub(and(a, 0xffffffffffffffffffffffffffffffffffffffff), and(b, 0xffffffffffffffffffffffffffffffffffffffff))\n            // mask = 0 if a >= b else -1 (all 1s)\n            let mask := sar(255, diff)\n            // if a >= b, res = a - b = 0 ^ (a - b)\n            // if a < b, res = b - a = ~~(b - a) = ~(-(b - a) - 1) = ~(a - b - 1) = (-1) ^ (a - b - 1)\n            // either way, res = mask ^ (a - b + mask)\n            res := xor(mask, add(mask, diff))\n        }\n    }\n\n    /// @notice Gets the amount1 delta between two prices\n    /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))\n    /// @param sqrtPriceAX96 A sqrt price\n    /// @param sqrtPriceBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param roundUp Whether to round the amount up, or down\n    /// @return amount1 Amount of currency1 required to cover a position of size liquidity between the two passed prices\n    function getAmount1Delta(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint256 liquidity, bool roundUp)\n        internal\n        pure\n        returns (uint256 amount1)\n    {\n        uint256 numerator = absDiff(sqrtPriceAX96, sqrtPriceBX96);\n        uint256 denominator = FixedPoint96.Q96;\n        uint256 _liquidity = uint256(liquidity);\n\n        /**\n         * Equivalent to:\n         *   amount1 = roundUp\n         *       ? FullMath.mulDivRoundingUp(liquidity, sqrtPriceBX96 - sqrtPriceAX96, FixedPoint96.Q96)\n         *       : FullMath.mulDiv(liquidity, sqrtPriceBX96 - sqrtPriceAX96, FixedPoint96.Q96);\n         * Cannot overflow because `type(uint128).max * type(uint160).max >> 96 < (1 << 192)`.\n         */\n        amount1 = FullMath.mulDiv(_liquidity, numerator, denominator);\n        assembly (\"memory-safe\") {\n            amount1 := add(amount1, and(gt(mulmod(_liquidity, numerator, denominator), 0), roundUp))\n        }\n    }\n\n    /// @notice Helper that gets signed currency0 delta\n    /// @param sqrtPriceAX96 A sqrt price\n    /// @param sqrtPriceBX96 Another sqrt price\n    /// @param liquidity The change in liquidity for which to compute the amount0 delta\n    /// @return int256 Amount of currency0 corresponding to the passed liquidityDelta between the two prices\n    function getAmount0Delta(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, int128 liquidity)\n        internal\n        pure\n        returns (int256)\n    {\n        unchecked {\n            return liquidity < 0\n                ? getAmount0Delta(sqrtPriceAX96, sqrtPriceBX96, uint128(-liquidity), false).toInt256()\n                : -getAmount0Delta(sqrtPriceAX96, sqrtPriceBX96, uint128(liquidity), true).toInt256();\n        }\n    }\n\n    /// @notice Helper that gets signed currency1 delta\n    /// @param sqrtPriceAX96 A sqrt price\n    /// @param sqrtPriceBX96 Another sqrt price\n    /// @param liquidity The change in liquidity for which to compute the amount1 delta\n    /// @return int256 Amount of currency1 corresponding to the passed liquidityDelta between the two prices\n    function getAmount1Delta(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, int128 liquidity)\n        internal\n        pure\n        returns (int256)\n    {\n        unchecked {\n            return liquidity < 0\n                ? getAmount1Delta(sqrtPriceAX96, sqrtPriceBX96, uint128(-liquidity), false).toInt256()\n                : -getAmount1Delta(sqrtPriceAX96, sqrtPriceBX96, uint128(liquidity), true).toInt256();\n        }\n    }\n}\n"}, "lib/permit2/src/interfaces/IAllowanceTransfer.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IEIP712} from \"./IEIP712.sol\";\n\n/// @title AllowanceTransfer\n/// @notice Handles ERC20 token permissions through signature based allowance setting and ERC20 token transfers by checking allowed amounts\n/// @dev Requires user's token approval on the Permit2 contract\ninterface IAllowanceTransfer is IEIP712 {\n    /// @notice Thrown when an allowance on a token has expired.\n    /// @param deadline The timestamp at which the allowed amount is no longer valid\n    error AllowanceExpired(uint256 deadline);\n\n    /// @notice Thrown when an allowance on a token has been depleted.\n    /// @param amount The maximum amount allowed\n    error InsufficientAllowance(uint256 amount);\n\n    /// @notice Thrown when too many nonces are invalidated.\n    error ExcessiveInvalidation();\n\n    /// @notice Emits an event when the owner successfully invalidates an ordered nonce.\n    event NonceInvalidation(\n        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce\n    );\n\n    /// @notice Emits an event when the owner successfully sets permissions on a token for the spender.\n    event Approval(\n        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration\n    );\n\n    /// @notice Emits an event when the owner successfully sets permissions using a permit signature on a token for the spender.\n    event Permit(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 nonce\n    );\n\n    /// @notice Emits an event when the owner sets the allowance back to 0 with the lockdown function.\n    event Lockdown(address indexed owner, address token, address spender);\n\n    /// @notice The permit data for a token\n    struct PermitDetails {\n        // ERC20 token address\n        address token;\n        // the maximum amount allowed to spend\n        uint160 amount;\n        // timestamp at which a spender's token allowances become invalid\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n\n    /// @notice The permit message signed for a single token allowance\n    struct PermitSingle {\n        // the permit data for a single token alownce\n        PermitDetails details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n\n    /// @notice The permit message signed for multiple token allowances\n    struct PermitBatch {\n        // the permit data for multiple token allowances\n        PermitDetails[] details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n\n    /// @notice The saved permissions\n    /// @dev This info is saved per owner, per token, per spender and all signed over in the permit message\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\n    struct PackedAllowance {\n        // amount allowed\n        uint160 amount;\n        // permission expiry\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n\n    /// @notice A token spender pair.\n    struct TokenSpenderPair {\n        // the token the spender is approved\n        address token;\n        // the spender address\n        address spender;\n    }\n\n    /// @notice Details for a token transfer.\n    struct AllowanceTransferDetails {\n        // the owner of the token\n        address from;\n        // the recipient of the token\n        address to;\n        // the amount of the token\n        uint160 amount;\n        // the token to be transferred\n        address token;\n    }\n\n    /// @notice A mapping from owner address to token address to spender address to PackedAllowance struct, which contains details and conditions of the approval.\n    /// @notice The mapping is indexed in the above order see: allowance[ownerAddress][tokenAddress][spenderAddress]\n    /// @dev The packed slot holds the allowed amount, expiration at which the allowed amount is no longer valid, and current nonce thats updated on any signature based approvals.\n    function allowance(address user, address token, address spender)\n        external\n        view\n        returns (uint160 amount, uint48 expiration, uint48 nonce);\n\n    /// @notice Approves the spender to use up to amount of the specified token up until the expiration\n    /// @param token The token to approve\n    /// @param spender The spender address to approve\n    /// @param amount The approved amount of the token\n    /// @param expiration The timestamp at which the approval is no longer valid\n    /// @dev The packed allowance also holds a nonce, which will stay unchanged in approve\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n\n    /// @notice Permit a spender to a given amount of the owners token via the owner's EIP-712 signature\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\n    /// @param owner The owner of the tokens being approved\n    /// @param permitSingle Data signed over by the owner specifying the terms of approval\n    /// @param signature The owner's signature over the permit data\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n\n    /// @notice Permit a spender to the signed amounts of the owners tokens via the owner's EIP-712 signature\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\n    /// @param owner The owner of the tokens being approved\n    /// @param permitBatch Data signed over by the owner specifying the terms of approval\n    /// @param signature The owner's signature over the permit data\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n\n    /// @notice Transfer approved tokens from one address to another\n    /// @param from The address to transfer from\n    /// @param to The address of the recipient\n    /// @param amount The amount of the token to transfer\n    /// @param token The token address to transfer\n    /// @dev Requires the from address to have approved at least the desired amount\n    /// of tokens to msg.sender.\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n\n    /// @notice Transfer approved tokens in a batch\n    /// @param transferDetails Array of owners, recipients, amounts, and tokens for the transfers\n    /// @dev Requires the from addresses to have approved at least the desired amount\n    /// of tokens to msg.sender.\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n\n    /// @notice Enables performing a \"lockdown\" of the sender's Permit2 identity\n    /// by batch revoking approvals\n    /// @param approvals Array of approvals to revoke.\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\n\n    /// @notice Invalidate nonces for a given (token, spender) pair\n    /// @param token The token to invalidate nonces for\n    /// @param spender The spender to invalidate nonces for\n    /// @param newNonce The new nonce to set. Invalidates all nonces less than it.\n    /// @dev Can't invalidate more than 2**16 nonces per transaction.\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\n}\n"}, "src/interfaces/IERC20Unlocker.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\n/// @title IERC20Unlocker - Interface for an unlocker contract for `IERC20Lockable`.\n/// @notice An unlocker contract is able to unlock accounts that have been locked by a `IERC20Lockable` contract.\n/// The unlocker contract is expected to implement the `IERC20Unlocker` interface.\ninterface IERC20Unlocker {\n    /// @notice Called when an account calls `IERC20Lockable.lock()` and specifies this contract as the unlocker.\n    /// @param account The account that called `IERC20Lockable.lock()`.\n    /// @param balance The balance of the account after the lock.\n    /// @param data The data passed to `IERC20Lockable.lock()`.\n    function lockCallback(address account, uint256 balance, bytes calldata data) external;\n\n    /// @notice Called when a locked account with this contract as the unlocker receives tokens.\n    /// @param account The account that received tokens.\n    /// @param receiveAmount The amount of tokens received.\n    function lockedUserReceiveCallback(address account, uint256 receiveAmount) external;\n}\n"}, "lib/multicaller/src/LibMulticaller.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @title LibMulticaller\n * @author vectorized.eth\n * @notice Library to read the `msg.sender` of the multicaller with sender contract.\n *\n * @dev Note:\n * The functions in this library do NOT guard against reentrancy.\n * A single transaction can recurse through different Multicallers\n * (e.g. `MulticallerWithSender -> contract -> MulticallerWithSigner -> contract`).\n *\n * Think of these functions like `msg.sender`.\n *\n * If your contract `C` can handle reentrancy safely with plain old `msg.sender`\n * for any `A -> C -> B -> C`, you should be fine substituting `msg.sender` with these functions.\n */\nlibrary LibMulticaller {\n    /**\n     * @dev The address of the multicaller contract.\n     */\n    address internal constant MULTICALLER = 0x0000000000002Bdbf1Bf3279983603Ec279CC6dF;\n\n    /**\n     * @dev The address of the multicaller with sender contract.\n     */\n    address internal constant MULTICALLER_WITH_SENDER = 0x00000000002Fd5Aeb385D324B580FCa7c83823A0;\n\n    /**\n     * @dev The address of the multicaller with signer contract.\n     */\n    address internal constant MULTICALLER_WITH_SIGNER = 0x000000000000D9ECebf3C23529de49815Dac1c4c;\n\n    /**\n     * @dev Returns the caller of `aggregateWithSender` on `MULTICALLER_WITH_SENDER`.\n     */\n    function multicallerSender() internal view returns (address result) {\n        return at(MULTICALLER_WITH_SENDER);\n    }\n\n    /**\n     * @dev Returns the signer of `aggregateWithSigner` on `MULTICALLER_WITH_SIGNER`.\n     */\n    function multicallerSigner() internal view returns (address result) {\n        return at(MULTICALLER_WITH_SIGNER);\n    }\n\n    /**\n     * @dev Returns the caller of `aggregateWithSender` on `MULTICALLER_WITH_SENDER`,\n     *      if the current context's `msg.sender` is `MULTICALLER_WITH_SENDER`.\n     *      Otherwise, returns `msg.sender`.\n     */\n    function sender() internal view returns (address result) {\n        return resolve(MULTICALLER_WITH_SENDER);\n    }\n\n    /**\n     * @dev Returns the caller of `aggregateWithSigner` on `MULTICALLER_WITH_SIGNER`,\n     *      if the current context's `msg.sender` is `MULTICALLER_WITH_SIGNER`.\n     *      Otherwise, returns `msg.sender`.\n     */\n    function signer() internal view returns (address) {\n        return resolve(MULTICALLER_WITH_SIGNER);\n    }\n\n    /**\n     * @dev Returns the caller or signer at `a`.\n     * @param a The multicaller with sender / signer.\n     */\n    function at(address a) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x00)\n            if iszero(staticcall(gas(), a, codesize(), 0x00, 0x00, 0x20)) {\n                revert(codesize(), codesize()) // For better gas estimation.\n            }\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Returns the caller or signer at `a`, if the caller is `a`.\n     * @param a The multicaller with sender / signer.\n     */\n    function resolve(address a) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, caller())\n            if eq(caller(), a) {\n                if iszero(staticcall(gas(), a, codesize(), 0x00, 0x00, 0x20)) {\n                    revert(codesize(), codesize()) // For better gas estimation.\n                }\n            }\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Returns the caller of `aggregateWithSender` on `MULTICALLER_WITH_SENDER`,\n     *      if the current context's `msg.sender` is `MULTICALLER_WITH_SENDER`.\n     *      Returns the signer of `aggregateWithSigner` on `MULTICALLER_WITH_SIGNER`,\n     *      if the current context's `msg.sender` is `MULTICALLER_WITH_SIGNER`.\n     *      Otherwise, returns `msg.sender`.\n     */\n    function senderOrSigner() internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, caller())\n            let withSender := MULTICALLER_WITH_SENDER\n            if eq(caller(), withSender) {\n                if iszero(staticcall(gas(), withSender, codesize(), 0x00, 0x00, 0x20)) {\n                    revert(codesize(), codesize()) // For better gas estimation.\n                }\n            }\n            let withSigner := MULTICALLER_WITH_SIGNER\n            if eq(caller(), withSigner) {\n                if iszero(staticcall(gas(), withSigner, codesize(), 0x00, 0x00, 0x20)) {\n                    revert(codesize(), codesize()) // For better gas estimation.\n                }\n            }\n            result := mload(0x00)\n        }\n    }\n}\n"}}, "settings": {"remappings": ["@uniswap/v4-core/=lib/v4-core/", "solmate/src/=lib/solmate/src/", "solmate/utils/=lib/solmate/src/utils/", "@ensdomains/=lib/v4-core/node_modules/@ensdomains/", "@openzeppelin/=lib/v4-core/lib/openzeppelin-contracts/", "@openzeppelin/contracts/=lib/v4-core/lib/openzeppelin-contracts/contracts/", "biddog/=lib/biddog/src/", "clones-with-immutable-args/=lib/clones-with-immutable-args/src/", "create3-factory/=lib/create3-factory/", "ds-test/=lib/clones-with-immutable-args/lib/ds-test/src/", "erc4626-tests/=lib/v4-core/lib/openzeppelin-contracts/lib/erc4626-tests/", "flood-contracts/=lib/flood-contracts/", "forge-gas-snapshot/=lib/permit2/lib/forge-gas-snapshot/src/", "forge-std/=lib/forge-std/src/", "hardhat/=lib/v4-core/node_modules/hardhat/", "leb128-nooffset/=lib/flood-contracts/lib/leb128-nooffset/src/", "leb128/=lib/flood-contracts/lib/leb128-nooffset/src/", "multicaller/=lib/multicaller/src/", "openzeppelin-contracts/=lib/v4-core/lib/openzeppelin-contracts/", "permit2/=lib/permit2/", "solady/=lib/solady/src/", "v4-core/=lib/v4-core/src/"], "optimizer": {"enabled": true}, "metadata": {"useLiteralContent": false, "bytecodeHash": "ipfs", "appendCBOR": true}, "outputSelection": {"*": {"*": ["evm.legacyAssembly"]}}, "evmVersion": "cancun", "viaIR": false, "libraries": {}}}