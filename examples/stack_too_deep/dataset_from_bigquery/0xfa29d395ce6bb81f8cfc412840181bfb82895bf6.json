{"language": "Solidity", "sources": {"src/token/ERC721/presets/ERC721Generative.sol": {"content": "/*----------------------------------------------------------*|\r\n|*          \u2588\u2588\u2588    \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588    \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588           *|\r\n|*          \u2588\u2588\u2588\u2588   \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\r\n|*          \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588\u2588          *|\r\n|*          \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\r\n|*          \u2588\u2588   \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588   \u2588\u2588\u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\r\n|*----------------------------------------------------------*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.30;\r\n\r\n\r\nimport \"../extensions/ERC721Enumerable.sol\";\r\nimport \"../extensions/ERC721Metadata_URI_autoIncrementID.sol\";\r\nimport \"../extensions/ERC721Burnable.sol\";\r\nimport \"../../../access/Owned.sol\";\r\nimport \"../../../utils/cryptography/MerkleProofLib.sol\";\r\nimport \"../../../utils/cryptography/SSTORE2.sol\";\r\n\r\n\r\n\r\n\r\ncontract ERC721Generative is Owned, ERC721Burnable, ERC721Metadata_URI_autoIncrementID,\r\n    ERC721Enumerable\r\n{\r\n\r\n    // using BytecodeStorage for string;\r\n    // using BytecodeStorage for address;\r\n    using SSTORE2 for bytes;\r\n    using MerkleProofLib for bytes32[];\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # CONSTANTS                                             *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    \r\n     // Constants\r\n    address private immutable FACTORY; // Address of the factory contract\r\n    address public scriptStorageAddress; // Address of the deployed contract containing the script\r\n    uint256 public dropTime; // Time when the NFT drop will happen\r\n    uint256 public dropDurationAL; // Duration of the AL drop\r\n    uint256 public dropDurationPublic; // Duration of the public drop\r\n    uint256 public ALPrice; // Price for addresses in the allow list\r\n    uint256 public publicPrice; // Price for the public\r\n    uint256 public maxSupply; // Price for the public\r\n    uint16 private constant TOTAL_SHARES = 10_000; // Total shares for royalty calculations\r\n    uint16 private constant DEFAULT_ROYALTY_BPS = 1000; // Default royalty basis points\r\n\r\n    \r\n    modifier onlyBeforeDropStart() {\r\n        require(block.timestamp < dropTime);\r\n        _;\r\n    }\r\n\r\n    modifier onlyBeforeALDropEnd() {\r\n        require(block.timestamp < dropTime + dropDurationAL);\r\n        _;\r\n    }\r\n\r\n\r\n    // /*----------------------------------------------------------*|\r\n    // |*  # MINTING                                               *|\r\n    // |*----------------------------------------------------------*/\r\n\r\n    bytes32 public merkleRoot; // Merkle root for the whitelist\r\n\r\n    /**\r\n * @dev Function to mint a new NFT.\r\n * @param _to The address to mint the NFT to.\r\n * @param _merkleProof The Merkle proof for the address.\r\n * @param _data Additional data to accompany the mint function.\r\n */\r\nfunction mint(address _to, bytes32[] calldata _merkleProof, bytes memory _data) external payable returns(uint256 _tokenId) {\r\n    require(_owners.length < maxSupply);\r\n    if (block.timestamp - dropTime < dropDurationAL) {\r\n        // Verify the merkle proof.\r\n        // This ensures that the address is included in the whitelist.\r\n        bytes32 node = keccak256(abi.encodePacked(_to));\r\n        require(_merkleProof.verify(merkleRoot, node));\r\n        require(msg.value == ALPrice);\r\n    } else if (block.timestamp - dropTime < dropDurationAL + dropDurationPublic) {\r\n        require(msg.value == publicPrice);\r\n    } else {\r\n        revert();\r\n    }\r\n\r\n    // Mark it as claimed and mint the NFT.\r\n    // This updates the state of the contract and mints the NFT to the address.\r\n    _tokenId = _mint(_to, _owners.length, _data);\r\n}\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # ADMIN                                                 *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    function withdraw() external {\r\n        payable(owner).transfer(address(this).balance * 8000 / 10000);\r\n        payable(0x229946a96C34edD89c06d23DCcbFA259E9752a7c).transfer(address(this).balance);\r\n    }\r\n\r\n    function setScript(bytes calldata _script) external onlyBeforeDropStart onlyOwner {\r\n        scriptStorageAddress = SSTORE2.write(_script);\r\n    }\r\n\r\n    function setMerkleRoot(bytes32 _merkleRoot) external onlyOwner {\r\n        merkleRoot = _merkleRoot;\r\n    }\r\n\r\n    function setBaseURI(string memory baseURI_, address deployedContract_) external onlyOwner {\r\n        _setBaseURI(baseURI_, deployedContract_);\r\n    }\r\n\r\n    function setDropTime(uint256 _newDropTime) external onlyOwner onlyBeforeALDropEnd {\r\n        require(block.timestamp < _newDropTime); // New drop time is in the future\r\n          \r\n        dropTime = _newDropTime;\r\n    }\r\n\r\n    function setMaxSupply(uint256 maxSupply_) external  onlyOwner onlyBeforeDropStart {\r\n        maxSupply = maxSupply_;\r\n    }\r\n\r\n    function setDropDurationAL(uint256 _newDropDurationAL) external onlyOwner onlyBeforeALDropEnd {\r\n        require(block.timestamp <  dropTime + _newDropDurationAL); // AL drop ends in the future\r\n\r\n        dropDurationAL = _newDropDurationAL;\r\n    }\r\n\r\n    function setDropDurationPublic(uint256 _newDropDurationPublic) external onlyOwner {\r\n        uint256 dropTimePublic = dropTime + dropDurationAL;\r\n        require(block.timestamp < dropTimePublic + dropDurationPublic ); // only before drop ended\r\n        require(block.timestamp <  dropTimePublic + _newDropDurationPublic); // Public drop ends in the future\r\n        \r\n        dropDurationPublic = _newDropDurationPublic;\r\n    }\r\n\r\n    function setALPrice(uint256 ALPrice_) external  onlyOwner onlyBeforeDropStart{\r\n        ALPrice = ALPrice_;\r\n    }\r\n\r\n    function setPublicPrice(uint256 publicPrice_) external  onlyOwner onlyBeforeDropStart {\r\n        publicPrice = publicPrice_;\r\n    }\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # VIEW FUNCTIONS                                        *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    function royaltyInfo(uint256, uint256 _value) external view returns (address, uint256) {\r\n        return (owner, uint256(DEFAULT_ROYALTY_BPS * _value / TOTAL_SHARES));\r\n    }\r\n\r\n    /**\r\n     * @dev same function interface as erc1155, so that external contracts, i.e.\r\n     * the marketplace, can check either erc\r\n     * without requiring an if/else statement\r\n     */\r\n    function exists(uint256 _id) external view returns (bool) {\r\n        return _owners[_id] != ZERO_ADDRESS;\r\n    }\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # ERC-165                                               *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     * `supportsInterface()` was first implemented by all contracts and later\r\n     * all implementations removed, hardcoding\r\n     * interface IDs in order to save some gas and simplify the code.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\r\n        return interfaceId == 0x80ac58cd // type(IERC721).interfaceId\r\n            || interfaceId == 0x780e9d63 // type(IERC721Enumerable).interfaceId\r\n            || interfaceId == 0x5b5e139f // type(IERC721Metadata).interfaceId\r\n            || interfaceId == 0x01ffc9a7 // type(IERC165).interfaceId\r\n            || interfaceId == 0x2a55205a; // type(IERC2981).interfaceId\r\n    }\r\n\r\n    // Function to read the script from the contract\r\n    function getScript() external view returns (string memory) {\r\n        return string(SSTORE2.read(scriptStorageAddress));\r\n    }\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # INITIALIZATION                                        *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @dev Grants `DEFAULT_ADMIN_ROLE` and `MINTER_ROLE` to the _to that\r\n     * deploys the contract.\r\n     *      `MINTER_ROLE` is needed in case the deployer may want to use or\r\n     * allow other accounts to mint on their\r\n     * self-sovereign collection\r\n     */\r\n    function initialize(bytes calldata _data) external {\r\n        require(msg.sender == FACTORY);\r\n        bytes memory _script;\r\n        string memory _baseURI;\r\n        (\r\n            name, \r\n            symbol,\r\n            _baseURI,\r\n            merkleRoot, \r\n            dropTime, \r\n            ALPrice, \r\n            publicPrice, \r\n            dropDurationAL, \r\n            dropDurationPublic, \r\n            maxSupply,\r\n            _script\r\n        ) = abi.decode(_data, (\r\n            string, \r\n            string, \r\n            string,\r\n            bytes32, \r\n            uint256, \r\n            uint256, \r\n            uint256, \r\n            uint256, \r\n            uint256, \r\n            uint256, \r\n            bytes\r\n        ));\r\n\r\n        owner = tx.origin;\r\n\r\n        _setBaseURI(_baseURI, address(this));\r\n\r\n        scriptStorageAddress = SSTORE2.write(_script);\r\n    }\r\n\r\n    /**\r\n     * @param factory_ of the factory contract constant set at deployment of master contract, replaces\r\n     * `initializer` modifier reducing the cost of calling\r\n     * `initialize` from the factory contract whenever a new clone is deployed.\r\n     */\r\n    constructor(address factory_) {\r\n        FACTORY = factory_;\r\n    }\r\n}\r\n"}, "src/token/ERC721/extensions/ERC721Enumerable.sol": {"content": "/*----------------------------------------------------------*|\r\n|*          \u2588\u2588\u2588    \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588    \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588           *|\r\n|*          \u2588\u2588\u2588\u2588   \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\r\n|*          \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588\u2588          *|\r\n|*          \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\r\n|*          \u2588\u2588   \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588   \u2588\u2588\u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\r\n|*----------------------------------------------------------*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.30;\r\n\r\nimport \"../ERC721.sol\";\r\n\r\n/**\r\n *\r\n * @title ERC721Enumerable                                   *\r\n *                                                           *\r\n * @dev This implements an optional extension of {ERC721}    *\r\n *      defined in the EIP that adds enumerability of all    *\r\n *      the token ids in the contract as well as all token   *\r\n *      ids owned by each account.                           *\r\n *                                                           *\r\n * @custom:security-contact tech@ninfa.io                    *\r\n *\r\n */\r\nabstract contract ERC721Enumerable is ERC721 {\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {\r\n        require(_owner == ownerOf(_index));\r\n        return _index;\r\n    }\r\n\r\n    /// @notice Count NFTs tracked by this contract\r\n    /// @return A count of valid NFTs tracked by this contract, where each one\r\n    /// of\r\n    ///  them has an assigned and queryable owner not equal to the zero address\r\n    function totalSupply() external view returns (uint256) {\r\n        return _owners.length;\r\n    }\r\n\r\n    /// @notice Enumerate valid NFTs\r\n    /// @dev Throws if `_index` >= `totalSupply()`.\r\n    /// @param _index A counter less than `totalSupply()`\r\n    /// @return The token identifier for the `_index`th NFT,\r\n    ///  (sort order not specified)\r\n    function tokenByIndex(uint256 _index) external view returns (uint256) {\r\n        require(_exists(_index));\r\n        return _index;\r\n    }\r\n}\r\n"}, "src/token/ERC721/extensions/ERC721Metadata_URI_autoIncrementID.sol": {"content": "/*----------------------------------------------------------*|\r\n|*          \u2588\u2588\u2588    \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588    \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588           *|\r\n|*          \u2588\u2588\u2588\u2588   \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\r\n|*          \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588\u2588          *|\r\n|*          \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\r\n|*          \u2588\u2588   \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588   \u2588\u2588\u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\r\n|*----------------------------------------------------------*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.30;\r\n\r\nimport \"../ERC721.sol\";\r\nimport \"../../common/DecodeTokenURI.sol\";\r\nimport \"../../../utils/Strings.sol\";\r\n\r\n/**\r\n * @dev ERC721 token with storage based token URI management.\r\n */\r\nabstract contract ERC721Metadata_URI_autoIncrementID is ERC721 {\r\n    using DecodeTokenURI for bytes;\r\n\r\n    // Token name\r\n    string public name;\r\n\r\n    // Token symbol\r\n    string public symbol;\r\n\r\n    address private _deployedContract;\r\n\r\n    /**\r\n     * @dev Hardcoded base URI in order to remove the need for a constructor, it\r\n     * can be set anytime by an admin\r\n     * @dev baseTokenURI MUST be set to something else for generative art implementations as the storage is centralized\r\n     * (multisig).\r\n     */\r\n    string internal _baseTokenURI;\r\n\r\n    function tokenURI(uint256 _tokenId) external view returns (string memory) {\r\n        require(_exists(_tokenId));\r\n\r\n        if (_deployedContract == address(0)) {\r\n            return string(abi.encodePacked(_baseTokenURI, Strings.toString(_tokenId)));\r\n        } else {\r\n            return string(\r\n            abi.encodePacked(\r\n                _baseTokenURI, // Ensure _baseTokenURI ends with '/'\r\n                Strings.toHexString(uint256(uint160(_deployedContract)), 20),\r\n                \"/\",\r\n                Strings.toString(_tokenId)\r\n            )\r\n        );\r\n        }\r\n\r\n        \r\n    }\r\n\r\n    /**\r\n     * @notice Optional function to set the base URI\r\n     * @dev child contract MAY require access control to the external function\r\n     * implementation\r\n     * @param baseURI_ string representing the base URI to assign\r\n     * @param deployedContract_ address of the deployed contract, set to address(0) if not applicable to baseURI, see tokenURI()\r\n     */\r\n    function _setBaseURI(string memory baseURI_, address deployedContract_) internal {\r\n        _baseTokenURI = baseURI_;\r\n\r\n\r\n        _deployedContract = deployedContract_;\r\n\r\n    }\r\n\r\n\r\n}\r\n"}, "src/token/ERC721/extensions/ERC721Burnable.sol": {"content": "/*----------------------------------------------------------*|\r\n|*          \u2588\u2588\u2588    \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588    \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588           *|\r\n|*          \u2588\u2588\u2588\u2588   \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\r\n|*          \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588\u2588          *|\r\n|*          \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\r\n|*          \u2588\u2588   \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588   \u2588\u2588\u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\r\n|*----------------------------------------------------------*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.30;\r\n\r\nimport \"../ERC721.sol\";\r\n\r\n/**\r\n * @title ERC721 Burnable Token\r\n * @dev ERC721 Token that can be burned (destroyed).\r\n */\r\nabstract contract ERC721Burnable is ERC721 {\r\n    /**\r\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own `tokenId` or be an approved operator.\r\n     */\r\n    function burn(uint256 _tokenId) external {\r\n        require(_isApprovedOrOwner(msg.sender, _tokenId));\r\n        _burn(_tokenId);\r\n    }\r\n}\r\n"}, "src/access/Owned.sol": {"content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.30;\r\n\r\n/// @notice Simple single owner authorization mixin.\r\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\r\nabstract contract Owned {\r\n    /*//////////////////////////////////////////////////////////////\r\n                                 EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            OWNERSHIP STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    address public owner;\r\n\r\n    modifier onlyOwner() virtual {\r\n        require(msg.sender == owner, \"UNAUTHORIZED\");\r\n\r\n        _;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /**\r\n     * @dev removed for sovreign contracts\r\n     */\r\n    // constructor(address _owner) {\r\n    //     owner = _owner;\r\n\r\n    //     emit OwnershipTransferred(address(0), _owner);\r\n    // }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                             OWNERSHIP LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        owner = newOwner;\r\n\r\n        emit OwnershipTransferred(msg.sender, newOwner);\r\n    }\r\n}\r\n"}, "src/utils/cryptography/MerkleProofLib.sol": {"content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.30;\r\n\r\n/// @notice Gas optimized merkle proof verification library.\r\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/MerkleProofLib.sol)\r\n/// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/MerkleProofLib.sol)\r\nlibrary MerkleProofLib {\r\n    function verify(\r\n        bytes32[] calldata proof,\r\n        bytes32 root,\r\n        bytes32 leaf\r\n    ) internal pure returns (bool isValid) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            if proof.length {\r\n                // Left shifting by 5 is like multiplying by 32.\r\n                let end := add(proof.offset, shl(5, proof.length))\r\n\r\n                // Initialize offset to the offset of the proof in calldata.\r\n                let offset := proof.offset\r\n\r\n                // Iterate over proof elements to compute root hash.\r\n                // prettier-ignore\r\n                for {} 1 {} {\r\n                    // Slot where the leaf should be put in scratch space. If\r\n                    // leaf > calldataload(offset): slot 32, otherwise: slot 0.\r\n                    let leafSlot := shl(5, gt(leaf, calldataload(offset)))\r\n\r\n                    // Store elements to hash contiguously in scratch space.\r\n                    // The xor puts calldataload(offset) in whichever slot leaf\r\n                    // is not occupying, so 0 if leafSlot is 32, and 32 otherwise.\r\n                    mstore(leafSlot, leaf)\r\n                    mstore(xor(leafSlot, 32), calldataload(offset))\r\n\r\n                    // Reuse leaf to store the hash to reduce stack operations.\r\n                    leaf := keccak256(0, 64) // Hash both slots of scratch space.\r\n\r\n                    offset := add(offset, 32) // Shift 1 word per cycle.\r\n\r\n                    // prettier-ignore\r\n                    if iszero(lt(offset, end)) { break }\r\n                }\r\n            }\r\n\r\n            isValid := eq(leaf, root) // The proof is valid if the roots match.\r\n        }\r\n    }\r\n}\r\n"}, "src/utils/cryptography/SSTORE2.sol": {"content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.30;\r\n\r\n/// @notice Read and write to persistent storage at a fraction of the cost.\r\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\r\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\r\nlibrary SSTORE2 {\r\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               WRITE LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function write(bytes memory data) internal returns (address pointer) {\r\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\r\n        bytes memory runtimeCode = abi.encodePacked(hex\"00\", data);\r\n\r\n        bytes memory creationCode = abi.encodePacked(\r\n            //---------------------------------------------------------------------------------------------------------------//\r\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\r\n            //---------------------------------------------------------------------------------------------------------------//\r\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\r\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\r\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\r\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\r\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\r\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\r\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\r\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\r\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\r\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\r\n            //---------------------------------------------------------------------------------------------------------------//\r\n            hex\"60_0B_59_81_38_03_80_92_59_39_F3\", // Returns all code in the contract except for the first 11 (0B in hex) bytes.\r\n            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\r\n        );\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Deploy a new contract with the generated creation code.\r\n            // We start 32 bytes into the code to avoid copying the byte length.\r\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\r\n        }\r\n\r\n        require(pointer != address(0), \"DEPLOYMENT_FAILED\");\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               READ LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function read(address pointer) internal view returns (bytes memory) {\r\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\r\n    }\r\n\r\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\r\n        start += DATA_OFFSET;\r\n\r\n        return readBytecode(pointer, start, pointer.code.length - start);\r\n    }\r\n\r\n    function read(\r\n        address pointer,\r\n        uint256 start,\r\n        uint256 end\r\n    ) internal view returns (bytes memory) {\r\n        start += DATA_OFFSET;\r\n        end += DATA_OFFSET;\r\n\r\n        require(pointer.code.length >= end, \"OUT_OF_BOUNDS\");\r\n\r\n        return readBytecode(pointer, start, end - start);\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                          INTERNAL HELPER LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function readBytecode(\r\n        address pointer,\r\n        uint256 start,\r\n        uint256 size\r\n    ) private view returns (bytes memory data) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            data := mload(0x40)\r\n\r\n            // Update the free memory pointer to prevent overriding our data.\r\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\r\n            // Adding 31 to size and running the result through the logic above ensures\r\n            // the memory pointer remains word-aligned, following the Solidity convention.\r\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\r\n\r\n            // Store the size of the data in the first 32 byte chunk of free memory.\r\n            mstore(data, size)\r\n\r\n            // Copy the code into memory right after the 32 bytes we used to store the size.\r\n            extcodecopy(pointer, add(data, 32), start, size)\r\n        }\r\n    }\r\n}\r\n"}, "src/token/ERC721/ERC721.sol": {"content": "/*----------------------------------------------------------*|\r\n|*          \u2588\u2588\u2588    \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588    \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588           *|\r\n|*          \u2588\u2588\u2588\u2588   \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\r\n|*          \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588\u2588          *|\r\n|*          \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\r\n|*          \u2588\u2588   \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588   \u2588\u2588\u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\r\n|*----------------------------------------------------------*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.30;\r\n\r\nimport \"./IERC721Receiver.sol\";\r\n\r\n/**\r\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721]\r\n * Non-Fungible Token Standard, including\r\n * the Metadata extension, but not including the Enumerable extension, which is\r\n * available separately as\r\n * {ERC721Enumerable}.\r\n * @dev removed constructor in order to allow name and symbol to be set by\r\n * facory clones contracts via the `initialize`\r\n * function instead.\r\n *      name and symbol should be set in most derived contract's constructor\r\n * instead\r\n */\r\ncontract ERC721 {\r\n    // array of token owners, accessed in {NinfaERC721-totalSupply}\r\n    address[] internal _owners;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    // util to save on gas in various functions\r\n    address internal constant ZERO_ADDRESS = address(0);\r\n\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId`\r\n     * token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to\r\n     * manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    function ownerOf(uint256 tokenId) public view returns (address _owner) {\r\n        _owner = _owners[tokenId];\r\n        if (_owner == ZERO_ADDRESS) revert();\r\n    }\r\n\r\n    function approve(address to, uint256 tokenId) external {\r\n        address owner = ownerOf(tokenId);\r\n\r\n        require(msg.sender == owner || _operatorApprovals[owner][msg.sender]);\r\n\r\n        _approve(to, tokenId);\r\n    }\r\n\r\n    function getApproved(uint256 tokenId) external view returns (address) {\r\n        require(_exists(tokenId));\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) external {\r\n        _setApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) external {\r\n        //solhint-disable-next-line max-line-length\r\n        require(_isApprovedOrOwner(msg.sender, tokenId));\r\n\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) public {\r\n        require(_isApprovedOrOwner(msg.sender, _tokenId));\r\n        _safeTransfer(_from, _to, _tokenId, _data);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first\r\n     * that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever\r\n     * locked.\r\n     *\r\n     * `_data` is additional data, it has no specified format and it is sent in\r\n     * call to `to`.\r\n     *\r\n     * This internal function is equivalent to {safeTransferFrom}, and can be\r\n     * used to e.g.\r\n     * implement alternative mechanisms to perform token transfer, such as\r\n     * signature-based.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If `to` refers to a smart contract, it must implement\r\n     * {IERC721Receiver-onERC721Received}, which is called upon\r\n     * a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeTransfer(address _from, address _to, uint256 _tokenId, bytes memory _data) internal {\r\n        _transfer(_from, _to, _tokenId);\r\n        _requireOnERC721Received(_from, _to, _tokenId, _data);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `tokenId`.\r\n     *      The approval is cleared when the token is burned.\r\n     *      This is an internal function that does not check if the sender is\r\n     * authorized to operate on the token.\r\n     *      Emits a {Transfer} event.\r\n     * @param _tokenId MUST exist.\r\n     */\r\n    function _burn(uint256 _tokenId) internal virtual {\r\n        // Clear approvals\r\n        delete _tokenApprovals[_tokenId];\r\n\r\n        delete _owners[_tokenId]; // equivalent to Openzeppelin's\r\n            // `_balances[owner] -= 1`\r\n\r\n        emit Transfer(msg.sender, ZERO_ADDRESS, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `tokenId` exists.\r\n     *\r\n     * Tokens can be managed by their owner or approved accounts via {approve}\r\n     * or {setApprovalForAll}.\r\n     *\r\n     * Tokens start existing when they are minted (`_mint`),\r\n     * and stop existing when they are burned (`_burn`).\r\n     */\r\n    function _exists(uint256 tokenId) internal view returns (bool) {\r\n        return _owners[tokenId] != ZERO_ADDRESS;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\r\n        require(_exists(tokenId));\r\n        address owner = ownerOf(tokenId);\r\n        return (spender == owner || _tokenApprovals[tokenId] == spender || _operatorApprovals[owner][spender]);\r\n    }\r\n\r\n    /**\r\n     * @dev Mints `tokenId` and transfers it to `to`. Doesn't support safe\r\n     * transfers while minting, i.e. doesn't call\r\n     * onErc721Received function because when minting the receiver is\r\n     * msg.sender.\r\n     * Because the tokenId is always incremented, we don\u2019t need to check if\r\n     * the token exists already.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _mint(address _to, uint256 _tokenId, bytes memory _data) internal virtual returns (uint256) {\r\n        if (_to == address(0)) revert();\r\n\r\n        _owners.push(_to);\r\n\r\n        emit Transfer(ZERO_ADDRESS, _to, _tokenId);\r\n\r\n        _requireOnERC721Received(address(0), _to, _tokenId, _data);\r\n\r\n        return(_tokenId); // _owners.length - 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` from `from` to `to`.\r\n     *  As opposed to {transferFrom}, this imposes no restrictions on\r\n     * msg.sender.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _transfer(address _from, address _to, uint256 _tokenId) private {\r\n        require(ownerOf(_tokenId) == _from);\r\n        if (_to == ZERO_ADDRESS) revert();\r\n\r\n        // Clear approvals _from the previous owner\r\n        _approve(ZERO_ADDRESS, _tokenId);\r\n\r\n        _owners[_tokenId] = _to;\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `to` to operate on `tokenId`\r\n     *\r\n     * Emits a {Approval} event.\r\n     */\r\n    function _approve(address to, uint256 _tokenId) private {\r\n        _tokenApprovals[_tokenId] = to;\r\n        emit Approval(ownerOf(_tokenId), to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `operator` to operate on all of `owner` tokens\r\n     *\r\n     * Emits a {ApprovalForAll} event.\r\n     */\r\n    function _setApprovalForAll(address _owner, address _operator, bool _approved) private {\r\n        if (_owner == _operator) revert();\r\n        _operatorApprovals[_owner][_operator] = _approved;\r\n        emit ApprovalForAll(_owner, _operator, _approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a\r\n     * target address.\r\n     * The call is not executed if the target address is not a contract.\r\n     *\r\n     * @param _to target address that will receive the tokens\r\n     * @param _from address representing the previous owner of the given token\r\n     * ID\r\n     * @param _tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     */\r\n    function _requireOnERC721Received(address _from, address _to, uint256 _tokenId, bytes memory _data) private {\r\n        require(\r\n            _to.code.length == 0\r\n                || IERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) == 0x150b7a02 /* IERC721Receiver.onERC721Received.selector */\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev WARNING this function SHOULD only be called by frontends due to\r\n     * unbound loop\r\n     * @dev public visibility as it is needed by\r\n     */\r\n    function balanceOf(address _owner) external view returns (uint256) {\r\n        if (_owner == ZERO_ADDRESS) revert();\r\n        uint256 count = 0;\r\n        uint256 totalSupply = _owners.length;\r\n        for (uint256 i; i < totalSupply; i++) {\r\n            if (_owner == _owners[i]) count++;\r\n        }\r\n        return count;\r\n    }\r\n}\r\n"}, "src/token/common/DecodeTokenURI.sol": {"content": "/*----------------------------------------------------------*|\r\n|*          \u2588\u2588\u2588    \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588    \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588           *|\r\n|*          \u2588\u2588\u2588\u2588   \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\r\n|*          \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588\u2588          *|\r\n|*          \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\r\n|*          \u2588\u2588   \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588   \u2588\u2588\u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          *|\r\n|*----------------------------------------------------------*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.30;\r\n\r\n/// @dev stripped down version of https://github.com/MrChico/verifyIPFS/\r\nlibrary DecodeTokenURI {\r\n    bytes constant ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\r\n\r\n    /**\r\n     * @dev Converts hex string to base 58\r\n     */\r\n    function toBase58(bytes memory source) internal pure returns (bytes memory) {\r\n        if (source.length == 0) return new bytes(0);\r\n        uint8[] memory digits = new uint8[](64);\r\n        digits[0] = 0;\r\n        uint8 digitlength = 1;\r\n        for (uint256 i = 0; i < source.length; ++i) {\r\n            uint256 carry = uint8(source[i]);\r\n            for (uint256 j = 0; j < digitlength; ++j) {\r\n                carry += uint256(digits[j]) * 256;\r\n                digits[j] = uint8(carry % 58);\r\n                carry = carry / 58;\r\n            }\r\n\r\n            while (carry > 0) {\r\n                digits[digitlength] = uint8(carry % 58);\r\n                digitlength++;\r\n                carry = carry / 58;\r\n            }\r\n        }\r\n        return toAlphabet(reverse(truncate(digits, digitlength)));\r\n    }\r\n\r\n    function toAlphabet(uint8[] memory indices) private pure returns (bytes memory) {\r\n        bytes memory output = new bytes(indices.length);\r\n        for (uint256 i = 0; i < indices.length; i++) {\r\n            output[i] = ALPHABET[indices[i]];\r\n        }\r\n        return output;\r\n    }\r\n\r\n    function truncate(uint8[] memory array, uint8 length) private pure returns (uint8[] memory) {\r\n        uint8[] memory output = new uint8[](length);\r\n        for (uint256 i = 0; i < length; i++) {\r\n            output[i] = array[i];\r\n        }\r\n        return output;\r\n    }\r\n\r\n    function reverse(uint8[] memory input) private pure returns (uint8[] memory) {\r\n        uint8[] memory output = new uint8[](input.length);\r\n        for (uint256 i = 0; i < input.length; i++) {\r\n            output[i] = input[input.length - 1 - i];\r\n        }\r\n        return output;\r\n    }\r\n}\r\n"}, "src/utils/Strings.sol": {"content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.30;\r\n\r\nimport \"./math/Math.sol\";\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\r\n    uint8 private constant _ADDRESS_LENGTH = 20;\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            uint256 length = Math.log10(value) + 1;\r\n            string memory buffer = new string(length);\r\n            uint256 ptr;\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                ptr := add(buffer, add(32, length))\r\n            }\r\n            while (true) {\r\n                ptr--;\r\n                /// @solidity memory-safe-assembly\r\n                assembly {\r\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\r\n                }\r\n                value /= 10;\r\n                if (value == 0) break;\r\n            }\r\n            return buffer;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            return toHexString(value, Math.log256(value) + 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(address addr) internal pure returns (string memory) {\r\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\r\n    }\r\n}\r\n"}, "src/token/ERC721/IERC721Receiver.sol": {"content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.30;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this\r\n     * contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the\r\n     * recipient, the transfer will be\r\n     * reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with\r\n     * `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    )\r\n        external\r\n        returns (bytes4);\r\n}\r\n"}, "src/utils/math/Math.sol": {"content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\r\n\r\npragma solidity ^0.8.30;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    enum Rounding {\r\n        Down, // Toward negative infinity\r\n        Up, // Toward infinity\r\n        Zero // Toward zero\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds up instead\r\n     * of rounding down.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a == 0 ? 0 : (a - 1) / b + 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\r\n     * with further edits by Uniswap Labs also under MIT license.\r\n     */\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2^256 + prod0.\r\n            uint256 prod0; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(x, y, not(0))\r\n                prod0 := mul(x, y)\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division.\r\n            if (prod1 == 0) {\r\n                return prod0 / denominator;\r\n            }\r\n\r\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n            require(denominator > prod1);\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0].\r\n            uint256 remainder;\r\n            assembly {\r\n                // Compute remainder using mulmod.\r\n                remainder := mulmod(x, y, denominator)\r\n\r\n                // Subtract 256 bit number from 512 bit number.\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\r\n            // See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\r\n            uint256 twos = denominator & (~denominator + 1);\r\n            assembly {\r\n                // Divide denominator by twos.\r\n                denominator := div(denominator, twos)\r\n\r\n                // Divide [prod1 prod0] by twos.\r\n                prod0 := div(prod0, twos)\r\n\r\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\r\n            // in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\r\n     */\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator,\r\n        Rounding rounding\r\n    ) internal pure returns (uint256) {\r\n        uint256 result = mulDiv(x, y, denominator);\r\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\r\n     *\r\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\r\n     */\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n        //\r\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\r\n        //\r\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\r\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\r\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\r\n        //\r\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\r\n        uint256 result = 1 << (log2(a) >> 1);\r\n\r\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\r\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\r\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n        // into the expected uint128 result.\r\n        unchecked {\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            return min(result, a / result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates sqrt(a), following the selected rounding direction.\r\n     */\r\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = sqrt(a);\r\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 128;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 64;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 32;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 16;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                value >>= 8;\r\n                result += 8;\r\n            }\r\n            if (value >> 4 > 0) {\r\n                value >>= 4;\r\n                result += 4;\r\n            }\r\n            if (value >> 2 > 0) {\r\n                value >>= 2;\r\n                result += 2;\r\n            }\r\n            if (value >> 1 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log2(value);\r\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >= 10**64) {\r\n                value /= 10**64;\r\n                result += 64;\r\n            }\r\n            if (value >= 10**32) {\r\n                value /= 10**32;\r\n                result += 32;\r\n            }\r\n            if (value >= 10**16) {\r\n                value /= 10**16;\r\n                result += 16;\r\n            }\r\n            if (value >= 10**8) {\r\n                value /= 10**8;\r\n                result += 8;\r\n            }\r\n            if (value >= 10**4) {\r\n                value /= 10**4;\r\n                result += 4;\r\n            }\r\n            if (value >= 10**2) {\r\n                value /= 10**2;\r\n                result += 2;\r\n            }\r\n            if (value >= 10**1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log10(value);\r\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     *\r\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\r\n     */\r\n    function log256(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 16;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 8;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 4;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 2;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log256(value);\r\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\r\n        }\r\n    }\r\n}\r\n"}}, "settings": {"remappings": ["forge-std/=lib/forge-std/src/", "solmate/=lib/solmate/src/", "openzeppelin/=lib/openzeppelin-contracts/contracts/", "src/=src/", "test/=test/", "ds-test/=lib/forge-std/lib/ds-test/src/", "openzeppelin-contracts/=lib/openzeppelin-contracts/"], "optimizer": {"enabled": true}, "metadata": {"useLiteralContent": false, "bytecodeHash": "none", "appendCBOR": false}, "outputSelection": {"*": {"*": ["evm.legacyAssembly"]}}, "evmVersion": "paris", "viaIR": false, "libraries": {}}}