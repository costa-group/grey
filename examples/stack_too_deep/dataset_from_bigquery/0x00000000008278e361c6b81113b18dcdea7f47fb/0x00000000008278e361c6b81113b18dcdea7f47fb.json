{"language": "Solidity", "sources": {"contracts/LayerrBridge.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.30;\r\n\r\nimport {IERC20} from \"./interfaces/IERC20.sol\";\r\nimport {IV3SwapRouter} from \"./interfaces/IV3SwapRouter.sol\";\r\nimport {IStargateRouter} from \"./interfaces/IStargateRouter.sol\";\r\nimport {ILayerrBridge} from \"./interfaces/ILayerrBridge.sol\";\r\nimport {IWETH} from \"./interfaces/IWETH.sol\";\r\nimport {MintOrder} from \"./lib/MinterStructs.sol\";\r\nimport {ILayerrMinter} from \"./interfaces/ILayerrMinter.sol\";\r\n\r\n/**\r\n * @title LayerrBridge\r\n * @author 0xth0mas (Layerr)\r\n * @notice LayerrBridge is powered by Stargate Finance and LayerZero\r\n *         to allow crosschain minting of NFTs with the LayerrMinter\r\n *         contract and native-to-native bridging of tokens.\r\n */\r\ncontract LayerrBridge is ILayerrBridge {\r\n\r\n    /// @dev Layerr-owned account \r\n    address public owner = 0x0000000000799dfE79Ed462822EC68eF9a6199e6;\r\n    /// @dev LayerrMinter interface\r\n    ILayerrMinter public constant layerrMinter = ILayerrMinter(0x000000000000D58696577347F78259bD376F1BEC);\r\n    /// @dev Stargate router contract interface for cross-chain bridging\r\n    IStargateRouter public stargateRouter;\r\n    /// @dev Automatic market maker router interface for local token swaps\r\n    IV3SwapRouter public ammRouter;\r\n    /// @dev WETH9 contract\r\n    IWETH public weth;\r\n    /// @dev Stargate native token contract\r\n    IWETH public sgNative;\r\n\r\n    /// @dev Layerr transaction fee in BPS\r\n    uint256 private constant LAYERR_BPS = 25;\r\n    /// @dev Denominator for BPS calculations\r\n    uint256 private constant BPS_DENOMINATOR = 10_000;\r\n    /// @dev Stargate transaction type for gas estimation\r\n    uint8 private constant TYPE_SWAP_REMOTE = 1;\r\n\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) {\r\n            revert NotContractOwner();\r\n        }\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        _setInitialRouterAddresses();\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc ILayerrBridge\r\n     */\r\n    function remoteMintWithLocalNative(\r\n        uint16 dstChainId,\r\n        address bridgeToken,\r\n        uint16 srcPoolId,\r\n        uint16 dstPoolId,\r\n        uint256 gasProvided,\r\n        uint256 localSwapAmountOutMin,\r\n        uint256 remoteSwapAmountOutMin,\r\n        uint256 remoteGasUnits,\r\n        MintOrder[] calldata mintOrders,\r\n        bytes32 bridgeTrackingHash\r\n    ) external payable {\r\n        if(gasProvided == 0 || gasProvided > msg.value) revert InsufficientGas();\r\n        uint256 swapValueIn;\r\n        uint256 layerrFee;\r\n        unchecked {\r\n            swapValueIn = msg.value - gasProvided;\r\n            layerrFee = swapValueIn * LAYERR_BPS / BPS_DENOMINATOR;\r\n            swapValueIn -= layerrFee;\r\n        }\r\n\r\n        unchecked {\r\n            _transferNative(owner, layerrFee);\r\n        }\r\n\r\n        uint256 bridgeAmount;\r\n        if(bridgeToken == address(sgNative)) {\r\n            bridgeAmount = swapValueIn;\r\n            sgNative.deposit{value: swapValueIn}();\r\n        } else {\r\n            bridgeAmount = _swapNativeForTokens(bridgeToken, swapValueIn);\r\n        }\r\n        IERC20(bridgeToken).approve(address(stargateRouter), bridgeAmount);\r\n\r\n        // encode payload data to send to destination contract, which it will handle with sgReceive()\r\n        bytes memory data = abi.encode(remoteSwapAmountOutMin, mintOrders, msg.sender, bridgeTrackingHash);\r\n\r\n        // Stargate's Router.swap() function sends the tokens to the destination chain.\r\n        stargateRouter.swap{value:gasProvided}(\r\n            dstChainId,\r\n            srcPoolId,\r\n            dstPoolId,\r\n            payable(msg.sender),\r\n            bridgeAmount,\r\n            localSwapAmountOutMin,\r\n            IStargateRouter.lzTxObj(remoteGasUnits, 0, \"0x\"),\r\n            abi.encodePacked(address(this)),\r\n            data\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc ILayerrBridge\r\n     */\r\n    function swapNativeForNative(\r\n        uint16 dstChainId,\r\n        address bridgeToken,\r\n        uint16 srcPoolId,\r\n        uint16 dstPoolId,\r\n        uint256 gasProvided,\r\n        uint256 localSwapAmountOutMin,\r\n        uint256 remoteSwapAmountOutMin,\r\n        uint256 remoteGasUnits,\r\n        bytes32 bridgeTrackingHash\r\n    ) external payable {\r\n        if(gasProvided == 0 || gasProvided > msg.value) revert InsufficientGas();\r\n        uint256 swapValueIn;\r\n        uint256 layerrFee;\r\n        unchecked {\r\n            swapValueIn = msg.value - gasProvided;\r\n            layerrFee = swapValueIn * LAYERR_BPS / BPS_DENOMINATOR;\r\n            swapValueIn -= layerrFee;\r\n        }\r\n\r\n        unchecked {\r\n            _transferNative(owner, layerrFee);\r\n        }\r\n\r\n        uint256 bridgeAmount;\r\n        if(bridgeToken == address(sgNative)) {\r\n            bridgeAmount = swapValueIn;\r\n            sgNative.deposit{value: swapValueIn}();\r\n        } else {\r\n            bridgeAmount = _swapNativeForTokens(bridgeToken, swapValueIn);\r\n        }\r\n        IERC20(bridgeToken).approve(address(stargateRouter), bridgeAmount);\r\n\r\n        // encode payload data to send to destination contract, which it will handle with sgReceive()\r\n        bytes memory data = abi.encode(remoteSwapAmountOutMin, msg.sender, bridgeTrackingHash);\r\n\r\n        // Stargate's Router.swap() function sends the tokens to the destination chain.\r\n        stargateRouter.swap{value:gasProvided}(\r\n            dstChainId,\r\n            srcPoolId,\r\n            dstPoolId,\r\n            payable(msg.sender),\r\n            bridgeAmount,\r\n            localSwapAmountOutMin,\r\n            IStargateRouter.lzTxObj(remoteGasUnits, 0, \"0x\"),\r\n            abi.encodePacked(address(this)),\r\n            data\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc ILayerrBridge\r\n     */\r\n    function estimateMintAndBridgeGas(\r\n        uint16 dstChainId, \r\n        uint256 remoteSwapAmountOutMin, \r\n        uint256 remoteGasUnits, \r\n        MintOrder[] calldata mintOrders\r\n    ) external view returns(uint256) {\r\n        bytes memory data = abi.encode(remoteSwapAmountOutMin, mintOrders, msg.sender, keccak256(\"\"));\r\n\r\n        (uint256 gasAmount, ) = stargateRouter.quoteLayerZeroFee(\r\n            dstChainId, \r\n            TYPE_SWAP_REMOTE, \r\n            abi.encodePacked(address(this)), \r\n            data, \r\n            IStargateRouter.lzTxObj(remoteGasUnits, 0, \"0x\")\r\n        );\r\n        return gasAmount;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc ILayerrBridge\r\n     */\r\n    function estimateBridgeOnlyGas(\r\n        uint16 dstChainId, \r\n        uint256 remoteSwapAmountOutMin, \r\n        uint256 remoteGasUnits\r\n    ) external view returns(uint256) {\r\n        bytes memory data = abi.encode(remoteSwapAmountOutMin, msg.sender, keccak256(\"\"));\r\n\r\n        (uint256 gasAmount, ) = stargateRouter.quoteLayerZeroFee(\r\n            dstChainId, \r\n            TYPE_SWAP_REMOTE, \r\n            abi.encodePacked(address(this)), \r\n            data, \r\n            IStargateRouter.lzTxObj(remoteGasUnits, 0, \"0x\")\r\n        );\r\n        return gasAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Receive the tokens and payload from the Stargate Route\r\n     * @dev Swap/bridge-only transactions will have a 64-byte payload\r\n     *      Swap/bridge/mint transaction payloads will be greater than 64 bytes\r\n     */\r\n    function sgReceive(\r\n        uint16, \r\n        bytes memory, \r\n        uint256, \r\n        address tokenAddress, \r\n        uint256 amountFromStargate, \r\n        bytes memory payload\r\n    ) override external {\r\n        if(msg.sender != address(stargateRouter)) revert NotStargateRouter();\r\n\r\n        uint256 nativeBalanceStart = address(this).balance;\r\n\r\n        uint256 swapAmountOutMin;\r\n        MintOrder[] memory mintOrders;\r\n        address mintTo;\r\n        bool swapAndMint;\r\n        bytes32 bridgeTrackingHash;\r\n        if(payload.length == 96) {\r\n            (swapAmountOutMin, mintTo, bridgeTrackingHash) = abi.decode(payload, (uint256, address, bytes32));\r\n        } else {\r\n            (swapAmountOutMin, mintOrders, mintTo, bridgeTrackingHash) = abi.decode(payload, (uint256, MintOrder[], address, bytes32));\r\n            swapAndMint = true;\r\n        }\r\n\r\n        uint256 amountOut;\r\n        if(tokenAddress == address(sgNative)) {\r\n            //withdraw native token if balance > 0, amountOut = amountFromStargate\r\n            //future-proof if bridge is added to sgNative's noUnwrapTo\r\n            uint256 sgNativeBalance = sgNative.balanceOf(address(this));\r\n            if(sgNativeBalance > 0) {\r\n                try sgNative.withdraw(sgNativeBalance) { } catch { }\r\n            }\r\n            amountOut = amountFromStargate;\r\n            nativeBalanceStart = address(this).balance - amountFromStargate;\r\n        } else {\r\n            //non-native token swap through AMM\r\n            amountOut = _swapTokensForNative(tokenAddress, amountFromStargate, swapAmountOutMin) - nativeBalanceStart;\r\n        }\r\n        if(amountOut == 0) {\r\n            //swap failed, send tokens to minter, skip minting\r\n            try IERC20(tokenAddress).transfer(mintTo, amountFromStargate) {\r\n                emit RemoteSwapUnsuccessful(mintTo, tokenAddress, amountFromStargate, bridgeTrackingHash);\r\n            } catch {\r\n                emit RemoteSwapAndTransferUnsuccessful(mintTo, tokenAddress, amountFromStargate, bridgeTrackingHash);\r\n            }\r\n        } else {\r\n            //swap successful, attempt to mint if mintOrder provided, only supply value from swap\r\n            if(swapAndMint) {\r\n                try layerrMinter.mintBatchTo{value: amountOut}(mintTo, mintOrders, 0) {\r\n                    emit RemoteMintSuccessful(mintTo, bridgeTrackingHash);\r\n                } catch {\r\n                    emit RemoteMintUnsuccessful(mintTo, bridgeTrackingHash);\r\n                }   \r\n            }\r\n        }\r\n\r\n        //transfer remaining native tokens to minter\r\n        uint256 nativeBalanceRemaining = address(this).balance;\r\n        if(nativeBalanceRemaining > nativeBalanceStart) {\r\n            _transferNative(mintTo, (nativeBalanceRemaining - nativeBalanceStart));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc ILayerrBridge\r\n     */\r\n    function setRouterAddresses(\r\n        address _stargateRouter, \r\n        address _ammRouter, \r\n        address _sgNative\r\n    ) external onlyOwner {\r\n        //only allow update if address was not previously set by \r\n        //constructor or this function\r\n        if(address(stargateRouter) == address(0)) {\r\n            stargateRouter = IStargateRouter(_stargateRouter);\r\n        }\r\n        if(address(ammRouter) == address(0)) {\r\n            ammRouter = IV3SwapRouter(_ammRouter);\r\n        }\r\n        if(address(sgNative) == address(0)) {\r\n            sgNative = IWETH(_sgNative);\r\n        }\r\n        if(address(weth) == address(0)) {\r\n            weth = IWETH(ammRouter.WETH9());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Swaps `amountIn` of native token for `tokenAddress`\r\n     *      We do not check for minimum output here. Minimum output\r\n     *      is enforced through the Stargate swap.\r\n     * @param tokenAddress the address of the token to swap for\r\n     * @param amountIn the amount of native token to swap\r\n     */\r\n    function _swapNativeForTokens(\r\n        address tokenAddress,\r\n        uint256 amountIn\r\n    ) internal returns (uint256 amountOut) {\r\n        amountOut = ammRouter.exactInputSingle{value: amountIn}(\r\n            IV3SwapRouter.ExactInputSingleParams({\r\n                tokenIn: address(weth),\r\n                tokenOut: tokenAddress,\r\n                fee: 500,\r\n                recipient: address(this),\r\n                amountIn: amountIn,\r\n                amountOutMinimum: 0,\r\n                sqrtPriceLimitX96: 0\r\n            })\r\n        );\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Swaps contract's balance of `tokenAddress` for chain native\r\n     *      token. Enforces `amountOutMin` as minimum tokens to receive.\r\n     *      Native token is received from AMM as WETH and unwrapped.\r\n     * @param tokenAddress the address of the token to swap from\r\n     * @param amountFromStargate the amount of tokens received from Stargate\r\n     * @param amountOutMin the minimum amount of native tokens to receive\r\n     * @return amountOut new native account balance\r\n     */\r\n    function _swapTokensForNative(\r\n        address tokenAddress,\r\n        uint256 amountFromStargate,\r\n        uint256 amountOutMin\r\n    ) internal returns (uint256 amountOut) {\r\n        //prevent revert, contract will forward tokens if amountOut = 0\r\n        try IERC20(tokenAddress).approve(address(ammRouter), amountFromStargate) { } catch { } \r\n\r\n        try ammRouter.exactInputSingle(\r\n            IV3SwapRouter.ExactInputSingleParams({\r\n                tokenIn: tokenAddress,\r\n                tokenOut: address(weth),\r\n                fee: 500,\r\n                recipient: address(this),\r\n                amountIn: amountFromStargate,\r\n                amountOutMinimum: amountOutMin,\r\n                sqrtPriceLimitX96: 0\r\n            })\r\n        ) {\r\n            try weth.withdraw(weth.balanceOf(address(this))) { } catch { }\r\n        } catch { }\r\n        amountOut = address(this).balance;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers `amount` of native token to `to` address. Reverts if the transfer fails.\r\n     * @param to address to send native token to\r\n     * @param amount amount of native token to send\r\n     */\r\n    function _transferNative(address to, uint256 amount) internal {\r\n        (bool sent, ) = payable(to).call{value: amount}(\"\");\r\n        if (!sent) {\r\n            if(address(this).balance < amount) {\r\n                revert InsufficientBalance();\r\n            } else {\r\n                revert PaymentFailed();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev preset addresses for initial deployment of contracts via CREATE2\r\n     */\r\n    function _setInitialRouterAddresses() internal {\r\n        if(block.chainid == 1) { //Ethereum mainnet\r\n            stargateRouter = IStargateRouter(0x8731d54E9D02c286767d56ac03e8037C07e01e98);\r\n            ammRouter = IV3SwapRouter(0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45);\r\n            sgNative = IWETH(0x72E2F4830b9E45d52F80aC08CB2bEC0FeF72eD9c);\r\n        } else if(block.chainid == 56) { //BSC\r\n            stargateRouter = IStargateRouter(0x4a364f8c717cAAD9A442737Eb7b8A55cc6cf18D8);\r\n            ammRouter = IV3SwapRouter(0xB971eF87ede563556b2ED4b1C0b0019111Dd85d2);\r\n        } else if(block.chainid == 42161) { //Arbitrum\r\n            stargateRouter = IStargateRouter(0x53Bf833A5d6c4ddA888F69c22C88C9f356a41614);\r\n            ammRouter = IV3SwapRouter(0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45);\r\n            sgNative = IWETH(0x82CbeCF39bEe528B5476FE6d1550af59a9dB6Fc0);\r\n        } else if(block.chainid == 10) { //Optimism\r\n            stargateRouter = IStargateRouter(0xB0D502E938ed5f4df2E681fE6E419ff29631d62b);\r\n            ammRouter = IV3SwapRouter(0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45);\r\n            sgNative = IWETH(0xb69c8CBCD90A39D8D3d3ccf0a3E968511C3856A0);\r\n        } else if(block.chainid == 43114) { //Avalanche\r\n            stargateRouter = IStargateRouter(0x45A01E4e04F14f7A4a6702c74187c5F6222033cd);\r\n            ammRouter = IV3SwapRouter(0xbb00FF08d01D300023C629E8fFfFcb65A5a578cE);\r\n        } else if(block.chainid == 137) { //Polygon\r\n            stargateRouter = IStargateRouter(0x45A01E4e04F14f7A4a6702c74187c5F6222033cd);\r\n            ammRouter = IV3SwapRouter(0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45);\r\n        } else if(block.chainid == 8453) { //Base\r\n            stargateRouter = IStargateRouter(0x45f1A95A4D3f3836523F5c83673c797f4d4d263B);\r\n            ammRouter = IV3SwapRouter(0x2626664c2603336E57B271c5C0b26F421741e481);\r\n            sgNative = IWETH(0x224D8Fd7aB6AD4c6eb4611Ce56EF35Dec2277F03);\r\n        }\r\n        if(address(ammRouter) != address(0)) {\r\n            weth = IWETH(ammRouter.WETH9());\r\n        }\r\n    }\r\n    \r\n    receive() external payable {}\r\n    fallback() external payable {}\r\n}"}, "contracts/interfaces/ILayerrBridge.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.30;\r\n\r\nimport {IStargateReceiver} from \"./IStargateReceiver.sol\";\r\nimport {MintOrder} from \"../lib/MinterStructs.sol\";\r\n\r\n/**\r\n * @title ILayerrBridge\r\n * @author 0xth0mas (Layerr)\r\n * @notice ILayerrBridge interface defines functions, events and errors for the LayerrBridge\r\n */\r\ninterface ILayerrBridge is IStargateReceiver {\r\n\r\n    /// @dev thrown when an address that is not the contract owner attempts to update routers\r\n    error NotContractOwner();\r\n    /// @dev thrown when attempting to send more value than the contract holds\r\n    error InsufficientBalance();\r\n    /// @dev thrown when not enough gas is supplied for the bridge transaction\r\n    error InsufficientGas();\r\n    /// @dev thrown when there is an error sending payment\r\n    error PaymentFailed();\r\n    /// @dev thrown when an address that is not the Stargate Router calls sgReceive\r\n    error NotStargateRouter();\r\n\r\n    /// @dev emitted when a swap is unsuccessful on remote chain and tokens are forwarded to recipient\r\n    event RemoteSwapUnsuccessful(address indexed to, address tokenAddress, uint256 amount, bytes32 indexed remoteTxHash);\r\n    /// @dev emitted when a swap is unsuccessful on remote chain and tokens could not be forwarded\r\n    event RemoteSwapAndTransferUnsuccessful(address indexed to, address tokenAddress, uint256 amount, bytes32 indexed remoteTxHash);\r\n    /// @dev emitted when a mint is successful\r\n    event RemoteMintSuccessful(address indexed to, bytes32 indexed remoteTxHash);\r\n    /// @dev emitted when a mint was not successful\r\n    event RemoteMintUnsuccessful(address indexed to, bytes32 indexed remoteTxHash);\r\n\r\n    /**\r\n     * @notice Initiates a swap, bridge and mint transaction\r\n     * @dev Transaction will revert if we do not receive the localSwapAmountOutMin on local chain\r\n     *      Transaction will NOT revert if remote chain is below remoteSwapAmountOutMin but will not\r\n     *      swap the token on the remote chain and instead forward the token balance to the recipient.\r\n     * @param dstChainId destination chain ID from LayerZero/Stargate\r\n     * @param bridgeToken token address for the token that will be bridged\r\n     * @param srcPoolId source pool ID from LayerZero/Stargate\r\n     * @param dstPoolId destination pool ID from LayerZero/Stargate\r\n     * @param gasProvided amount of gas in wei to be sent to Stargate for LayerZero transaction\r\n     * @param localSwapAmountOutMin minimum amount of tokens to receive after all local swaps\r\n     * @param remoteSwapAmountOutMin minimum amount of tokens to receive on remote chain\r\n     * @param remoteGasUnits amount of gas units to pay for on the remote chain\r\n     * @param mintOrders the mint orders to be executed on the remote chain\r\n     * @param bridgeTrackingHash value supplied by dapp to track bridge transactions \r\n     */\r\n    function remoteMintWithLocalNative(\r\n        uint16 dstChainId,\r\n        address bridgeToken,\r\n        uint16 srcPoolId,\r\n        uint16 dstPoolId,\r\n        uint256 gasProvided,\r\n        uint256 localSwapAmountOutMin,\r\n        uint256 remoteSwapAmountOutMin,\r\n        uint256 remoteGasUnits,\r\n        MintOrder[] calldata mintOrders,\r\n        bytes32 bridgeTrackingHash\r\n    ) external payable;\r\n\r\n    /**\r\n     * @notice Initiates a swap and bridge transaction\r\n     * @dev Transaction will revert if we do not receive the localSwapAmountOutMin on local chain\r\n     *      Transaction will NOT revert if remote chain is below remoteSwapAmountOutMin but will not\r\n     *      swap the token on the remote chain and instead forward the token balance to the recipient.\r\n     * @param dstChainId destination chain ID from LayerZero/Stargate\r\n     * @param bridgeToken token address for the token that will be bridged\r\n     * @param srcPoolId source pool ID from LayerZero/Stargate\r\n     * @param dstPoolId destination pool ID from LayerZero/Stargate\r\n     * @param gasProvided amount of gas in wei to be sent to Stargate for LayerZero transaction\r\n     * @param localSwapAmountOutMin minimum amount of tokens to receive after all local swaps\r\n     * @param remoteSwapAmountOutMin minimum amount of tokens to receive on remote chain\r\n     * @param remoteGasUnits amount of gas units to pay for on the remote chain\r\n     * @param bridgeTrackingHash value supplied by dapp to track bridge transactions\r\n     */\r\n    function swapNativeForNative(\r\n        uint16 dstChainId,\r\n        address bridgeToken,\r\n        uint16 srcPoolId,\r\n        uint16 dstPoolId,\r\n        uint256 gasProvided,\r\n        uint256 localSwapAmountOutMin,\r\n        uint256 remoteSwapAmountOutMin,\r\n        uint256 remoteGasUnits,\r\n        bytes32 bridgeTrackingHash\r\n    ) external payable;\r\n\r\n    /**\r\n     * @notice Estimate the gas payment to LayerZero for the a swap/bridge/mint transaction\r\n     * @param dstChainId destination chain ID from LayerZero/Stargate\r\n     * @param remoteSwapAmountOutMin minimum amount of tokens to receive on remote chain\r\n     * @param remoteGasUnits amount of gas units to pay for on the remote chain\r\n     * @param mintOrders the mint orders to be executed on the remote chain\r\n     */\r\n    function estimateMintAndBridgeGas(\r\n        uint16 dstChainId, \r\n        uint256 remoteSwapAmountOutMin, \r\n        uint256 remoteGasUnits, \r\n        MintOrder[] calldata mintOrders\r\n    ) external view returns(uint256);\r\n\r\n    \r\n    /**\r\n     * @notice Estimate the gas payment to LayerZero for the a swap/bridge transaction\r\n     * @param dstChainId destination chain ID from LayerZero/Stargate\r\n     * @param remoteSwapAmountOutMin minimum amount of tokens to receive on remote chain\r\n     * @param remoteGasUnits amount of gas units to pay for on the remote chain\r\n     */\r\n    function estimateBridgeOnlyGas(\r\n        uint16 dstChainId, \r\n        uint256 remoteSwapAmountOutMin, \r\n        uint256 remoteGasUnits\r\n    ) external view returns(uint256);\r\n\r\n    /**\r\n     * @notice Sets the router and Stargate native token addresses \r\n     * @dev access restricted to contract owner\r\n     * @param _stargateRouter the local Stargate router contract for bridging\r\n     * @param _ammRouter the router contract to use for local token swaps\r\n     * @param _sgNative the Stargate native token contract\r\n     */\r\n    function setRouterAddresses(\r\n        address _stargateRouter,\r\n        address _ammRouter,\r\n        address _sgNative\r\n    ) external;\r\n}\r\n"}, "contracts/interfaces/ILayerrMinter.sol": {"content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.30;\r\n\r\nimport {MintOrder, MintParameters, MintToken, BurnToken, PaymentToken} from \"../lib/MinterStructs.sol\";\r\n\r\n/**\r\n * @title ILayerrMinter\r\n * @author 0xth0mas (Layerr)\r\n * @notice ILayerrMinter interface defines functions required in the LayerrMinter to be callable by token contracts\r\n */\r\ninterface ILayerrMinter {\r\n\r\n    /// @dev Event emitted when a mint order is fulfilled\r\n    event MintOrderFulfilled(\r\n        bytes32 indexed mintParametersDigest,\r\n        address indexed minter,\r\n        uint256 indexed quantity\r\n    );\r\n\r\n    /// @dev Event emitted when a token contract updates an allowed signer for EIP712 signatures\r\n    event ContractAllowedSignerUpdate(\r\n        address indexed _contract,\r\n        address indexed _signer,\r\n        bool indexed _allowed\r\n    );\r\n\r\n    /// @dev Event emitted when a token contract updates an allowed oracle signer for offchain authorization of a wallet to use a signature\r\n    event ContractOracleUpdated(\r\n        address indexed _contract,\r\n        address indexed _oracle,\r\n        bool indexed _allowed\r\n    );\r\n\r\n    /// @dev Event emitted when a signer updates their nonce with LayerrMinter. Updating a nonce invalidates all previously signed EIP712 signatures.\r\n    event SignerNonceIncremented(\r\n        address indexed _signer,\r\n        uint256 indexed _nonce\r\n    );\r\n\r\n    /// @dev Event emitted when a specific signature's validity is updated with the LayerrMinter contract.\r\n    event SignatureValidityUpdated(\r\n        address indexed _contract,\r\n        bool indexed invalid,\r\n        bytes32 mintParametersDigests\r\n    );\r\n\r\n    /// @dev Thrown when the amount of native tokens supplied in msg.value is insufficient for the mint order\r\n    error InsufficientPayment();\r\n\r\n    /// @dev Thrown when a payment fails to be forwarded to the intended recipient\r\n    error PaymentFailed();\r\n\r\n    /// @dev Thrown when a MintParameters payment token uses a token type value other than native or ERC20\r\n    error InvalidPaymentTokenType();\r\n\r\n    /// @dev Thrown when a MintParameters burn token uses a token type value other than ERC20, ERC721 or ERC1155\r\n    error InvalidBurnTokenType();\r\n\r\n    /// @dev Thrown when a MintParameters mint token uses a token type value other than ERC20, ERC721 or ERC1155\r\n    error InvalidMintTokenType();\r\n\r\n    /// @dev Thrown when a MintParameters burn token uses a burn type value other than contract burn or send to dead\r\n    error InvalidBurnType();\r\n\r\n    /// @dev Thrown when a MintParameters burn token requires a specific burn token id and the tokenId supplied does not match\r\n    error InvalidBurnTokenId();\r\n\r\n    /// @dev Thrown when a MintParameters burn token requires a specific ERC721 token and the burn amount is greater than 1\r\n    error CannotBurnMultipleERC721WithSameId();\r\n\r\n    /// @dev Thrown when attempting to mint with MintParameters that have a start time greater than the current block time\r\n    error MintHasNotStarted();\r\n\r\n    /// @dev Thrown when attempting to mint with MintParameters that have an end time less than the current block time\r\n    error MintHasEnded();\r\n\r\n    /// @dev Thrown when a MintParameters has a merkleroot set but the supplied merkle proof is invalid\r\n    error InvalidMerkleProof();\r\n\r\n    /// @dev Thrown when a MintOrder will cause a token's minted supply to exceed the defined maximum supply in MintParameters\r\n    error MintExceedsMaxSupply();\r\n\r\n    /// @dev Thrown when a MintOrder will cause a minter's minted amount to exceed the defined max per wallet in MintParameters\r\n    error MintExceedsMaxPerWallet();\r\n\r\n    /// @dev Thrown when a MintParameters mint token has a specific ERC721 token and the mint amount is greater than 1\r\n    error CannotMintMultipleERC721WithSameId();\r\n\r\n    /// @dev Thrown when the recovered signer for the MintParameters is not an allowed signer for the mint token\r\n    error NotAllowedSigner();\r\n\r\n    /// @dev Thrown when the recovered signer's nonce does not match the current nonce in LayerrMinter\r\n    error SignerNonceInvalid();\r\n\r\n    /// @dev Thrown when a signature has been marked as invalid for a mint token contract\r\n    error SignatureInvalid();\r\n\r\n    /// @dev Thrown when MintParameters requires an oracle signature and the recovered signer is not an allowed oracle for the contract\r\n    error InvalidOracleSignature();\r\n\r\n    /// @dev Thrown when MintParameters has a max signature use set and the MintOrder will exceed the maximum uses\r\n    error ExceedsMaxSignatureUsage();\r\n\r\n    /// @dev Thrown when attempting to increment nonce on behalf of another account and the signature is invalid\r\n    error InvalidSignatureToIncrementNonce();\r\n\r\n    /**\r\n     * @notice This function is called by token contracts to update allowed signers for minting\r\n     * @param _signer address of the EIP712 signer\r\n     * @param _allowed if the `_signer` is allowed to sign for minting\r\n     */\r\n    function setContractAllowedSigner(address _signer, bool _allowed) external;\r\n\r\n    /**\r\n     * @notice This function is called by token contracts to update allowed oracles for offchain authorizations\r\n     * @param _oracle address of the oracle\r\n     * @param _allowed if the `_oracle` is allowed to sign offchain authorizations\r\n     */\r\n    function setContractAllowedOracle(address _oracle, bool _allowed) external;\r\n\r\n    /**\r\n     * @notice This function is called by token contracts to update validity of signatures for the LayerrMinter contract\r\n     * @dev `invalid` should be true to invalidate signatures, the default state of `invalid` being false means \r\n     *      a signature is valid for a contract assuming all other conditions are met\r\n     * @param mintParametersDigests an array of message digests for MintParameters to update validity of\r\n     * @param invalid if the supplied digests will be marked as valid or invalid\r\n     */\r\n    function setSignatureValidity(\r\n        bytes32[] calldata mintParametersDigests,\r\n        bool invalid\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Increments the nonce for a signer to invalidate all previous signed MintParameters\r\n     */\r\n    function incrementSignerNonce() external;\r\n\r\n    /**\r\n     * @notice Increments the nonce on behalf of another account by validating a signature from that account\r\n     * @dev The signature is an eth personal sign message of the current signer nonce plus the chain id\r\n     *      ex. current nonce 0 on chain 5 would be a signature of \\x19Ethereum Signed Message:\\n15\r\n     *          current nonce 50 on chain 1 would be a signature of \\x19Ethereum Signed Message:\\n251\r\n     * @param signer account to increment nonce for\r\n     * @param signature signature proof that the request is coming from the account\r\n     */\r\n    function incrementNonceFor(address signer, bytes calldata signature) external;\r\n\r\n    /**\r\n     * @notice Validates and processes a single MintOrder, tokens are minted to msg.sender\r\n     * @param mintOrder struct containing the details of the mint order\r\n     */\r\n    function mint(\r\n        MintOrder calldata mintOrder\r\n    ) external payable;\r\n\r\n    /**\r\n     * @notice Validates and processes an array of MintOrders, tokens are minted to msg.sender\r\n     * @param mintOrders array of structs containing the details of the mint orders\r\n     */\r\n    function mintBatch(\r\n        MintOrder[] calldata mintOrders\r\n    ) external payable;\r\n\r\n    /**\r\n     * @notice Validates and processes a single MintOrder, tokens are minted to `mintToWallet`\r\n     * @param mintToWallet the address tokens will be minted to\r\n     * @param mintOrder struct containing the details of the mint order\r\n     * @param paymentContext Contextual information related to the payment process\r\n     *                     (Note: This parameter is required for integration with \r\n     *                     the payment processor and does not impact the behavior \r\n     *                     of the function)\r\n     */\r\n    function mintTo(\r\n        address mintToWallet,\r\n        MintOrder calldata mintOrder,\r\n        uint256 paymentContext\r\n    ) external payable;\r\n\r\n    /**\r\n     * @notice Validates and processes an array of MintOrders, tokens are minted to `mintToWallet`\r\n     * @param mintToWallet the address tokens will be minted to\r\n     * @param mintOrders array of structs containing the details of the mint orders\r\n     * @param paymentContext Contextual information related to the payment process\r\n     *                     (Note: This parameter is required for integration with \r\n     *                     the payment processor and does not impact the behavior \r\n     *                     of the function)\r\n     */\r\n    function mintBatchTo(\r\n        address mintToWallet,\r\n        MintOrder[] calldata mintOrders,\r\n        uint256 paymentContext\r\n    ) external payable;\r\n}"}, "contracts/interfaces/IStargateReceiver.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.30;\r\n\r\ninterface IStargateReceiver {\r\n    function sgReceive(\r\n        uint16 _srcChainId,              // the remote chainId sending the tokens\r\n        bytes memory _srcAddress,        // the remote Bridge address\r\n        uint256 _nonce,                  \r\n        address _token,                  // the token contract on the local chain\r\n        uint256 amountLD,                // the qty of local _token contract tokens  \r\n        bytes memory payload\r\n    ) external;\r\n}\r\n"}, "contracts/interfaces/IStargateRouter.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.30;\r\n\r\ninterface IStargateRouter {\r\n    struct lzTxObj {\r\n        uint256 dstGasForCall;\r\n        uint256 dstNativeAmount;\r\n        bytes dstNativeAddr;\r\n    }\r\n\r\n    function addLiquidity(\r\n        uint256 _poolId,\r\n        uint256 _amountLD,\r\n        address _to\r\n    ) external;\r\n\r\n    function swap(\r\n        uint16 _dstChainId,\r\n        uint256 _srcPoolId,\r\n        uint256 _dstPoolId,\r\n        address payable _refundAddress,\r\n        uint256 _amountLD,\r\n        uint256 _minAmountLD,\r\n        lzTxObj memory _lzTxParams,\r\n        bytes calldata _to,\r\n        bytes calldata _payload\r\n    ) external payable;\r\n\r\n    function redeemRemote(\r\n        uint16 _dstChainId,\r\n        uint256 _srcPoolId,\r\n        uint256 _dstPoolId,\r\n        address payable _refundAddress,\r\n        uint256 _amountLP,\r\n        uint256 _minAmountLD,\r\n        bytes calldata _to,\r\n        lzTxObj memory _lzTxParams\r\n    ) external payable;\r\n\r\n    function instantRedeemLocal(\r\n        uint16 _srcPoolId,\r\n        uint256 _amountLP,\r\n        address _to\r\n    ) external returns (uint256);\r\n\r\n    function redeemLocal(\r\n        uint16 _dstChainId,\r\n        uint256 _srcPoolId,\r\n        uint256 _dstPoolId,\r\n        address payable _refundAddress,\r\n        uint256 _amountLP,\r\n        bytes calldata _to,\r\n        lzTxObj memory _lzTxParams\r\n    ) external payable;\r\n\r\n    function sendCredits(\r\n        uint16 _dstChainId,\r\n        uint256 _srcPoolId,\r\n        uint256 _dstPoolId,\r\n        address payable _refundAddress\r\n    ) external payable;\r\n\r\n    function quoteLayerZeroFee(\r\n        uint16 _dstChainId,\r\n        uint8 _functionType,\r\n        bytes calldata _toAddress,\r\n        bytes calldata _transferAndCallPayload,\r\n        lzTxObj memory _lzTxParams\r\n    ) external view returns (uint256, uint256);\r\n}\r\n"}, "contracts/interfaces/IV3SwapRouter.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity ^0.8.30;\r\n\r\n/// @title Router token swapping functionality\r\n/// @notice Functions for swapping tokens via Uniswap V3\r\ninterface IV3SwapRouter {\r\n    struct ExactInputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n        uint160 sqrtPriceLimitX96;\r\n    }\r\n\r\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\r\n    /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\r\n    /// and swap the entire amount, enabling contracts to send tokens before calling this function.\r\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\r\n    /// @return amountOut The amount of the received token\r\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\r\n\r\n    struct ExactInputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n    }\r\n\r\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\r\n    /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\r\n    /// and swap the entire amount, enabling contracts to send tokens before calling this function.\r\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\r\n    /// @return amountOut The amount of the received token\r\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\r\n\r\n    struct ExactOutputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 amountOut;\r\n        uint256 amountInMaximum;\r\n        uint160 sqrtPriceLimitX96;\r\n    }\r\n\r\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\r\n    /// that may remain in the router after the swap.\r\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\r\n    /// @return amountIn The amount of the input token\r\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\r\n\r\n    struct ExactOutputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 amountOut;\r\n        uint256 amountInMaximum;\r\n    }\r\n\r\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\r\n    /// that may remain in the router after the swap.\r\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\r\n    /// @return amountIn The amount of the input token\r\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\r\n\r\n    /// @return Returns the address of WETH9\r\n    function WETH9() external view returns (address);\r\n}"}, "contracts/interfaces/IERC20.sol": {"content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.30;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n"}, "contracts/interfaces/IWETH.sol": {"content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.30;\r\n\r\nimport {IERC20} from './IERC20.sol';\r\n\r\ninterface IWETH is IERC20 {\r\n    function deposit() external payable;\r\n    function withdraw(uint amount) external;\r\n}"}, "contracts/lib/MinterStructs.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.30;\r\n\r\n/**\r\n * @dev EIP712 Domain for signature verification\r\n */\r\nstruct EIP712Domain {\r\n    string name;\r\n    string version;\r\n    uint256 chainId;\r\n    address verifyingContract;\r\n}\r\n\r\n/**\r\n * @dev MintOrders contain MintParameters as defined by a token creator\r\n *      along with proofs required to validate the MintParameters and \r\n *      parameters specific to the mint being performed.\r\n * \r\n *      `mintParameters` are the parameters signed by the token creator\r\n *      `quantity` is a multiplier for mintTokens, burnTokens and paymentTokens\r\n *          defined in mintParameters\r\n *      `mintParametersSignature` is the signature from the token creator\r\n *      `oracleSignature` is a signature of the hash of the mintParameters digest \r\n *          and msg.sender. The recovered signer must be an allowed oracle for \r\n *          the token contract if oracleSignatureRequired is true for mintParameters.\r\n *      `merkleProof` is the proof that is checked if merkleRoot is not bytes(0) in\r\n *          mintParameters\r\n *      `suppliedBurnTokenIds` is an array of tokenIds to be used when processing\r\n *          burnTokens. There must be one item in the array for each ERC1155 burnToken\r\n *          regardless of `quantity` and `quantity` items in the array for each ERC721\r\n *          burnToken.\r\n *      `referrer` is the address that will receive a portion of a paymentToken if\r\n *          not address(0) and paymentToken's referralBPS is greater than 0\r\n *      `vaultWallet` is used for allowlist mints if the msg.sender address it not on\r\n *          the allowlist but their delegate.cash vault wallet is.\r\n *      \r\n */\r\nstruct MintOrder {\r\n    MintParameters mintParameters;\r\n    uint256 quantity;\r\n    bytes mintParametersSignature;\r\n    bytes oracleSignature;\r\n    bytes32[] merkleProof;\r\n    uint256[] suppliedBurnTokenIds;\r\n    address referrer;\r\n    address vaultWallet;\r\n}\r\n\r\n/**\r\n * @dev MintParameters define the tokens to be minted and conditions that must be met\r\n *      for the mint to be successfully processed.\r\n * \r\n *      `mintTokens` is an array of tokens that will be minted\r\n *      `burnTokens` is an array of tokens required to be burned\r\n *      `paymentTokens` is an array of tokens required as payment\r\n *      `startTime` is the UTC timestamp of when the mint will start\r\n *      `endTime` is the UTC timestamp of when the mint will end\r\n *      `signatureMaxUses` limits the number of mints that can be performed with the\r\n *          specific mintParameters/signature\r\n *      `merkleRoot` is the root of the merkletree for allowlist minting\r\n *      `nonce` is the signer nonce that can be incremented on the LayerrMinter \r\n *          contract to invalidate all previous signatures\r\n *      `oracleSignatureRequired` if true requires a secondary signature to process the mint\r\n */\r\nstruct MintParameters {\r\n    MintToken[] mintTokens;\r\n    BurnToken[] burnTokens;\r\n    PaymentToken[] paymentTokens;\r\n    uint256 startTime;\r\n    uint256 endTime;\r\n    uint256 signatureMaxUses;\r\n    bytes32 merkleRoot;\r\n    uint256 nonce;\r\n    bool oracleSignatureRequired;\r\n}\r\n\r\n/**\r\n * @dev Defines the token that will be minted\r\n *      \r\n *      `contractAddress` address of contract to mint tokens from\r\n *      `specificTokenId` used for ERC721 - \r\n *          if true, mint is non-sequential ERC721\r\n *          if false, mint is sequential ERC721A\r\n *      `tokenType` is the type of token being minted defined in TokenTypes.sol\r\n *      `tokenId` the tokenId to mint if specificTokenId is true\r\n *      `mintAmount` is the quantity to be minted\r\n *      `maxSupply` is checked against the total minted amount at time of mint\r\n *          minting reverts if `mintAmount` * `quantity` will cause total minted to \r\n *          exceed `maxSupply`\r\n *      `maxMintPerWallet` is checked against the number minted for the wallet\r\n *          minting reverts if `mintAmount` * `quantity` will cause wallet minted to \r\n *          exceed `maxMintPerWallet`\r\n */\r\nstruct MintToken {\r\n    address contractAddress;\r\n    bool specificTokenId;\r\n    uint256 tokenType;\r\n    uint256 tokenId;\r\n    uint256 mintAmount;\r\n    uint256 maxSupply;\r\n    uint256 maxMintPerWallet;\r\n}\r\n\r\n/**\r\n * @dev Defines the token that will be burned\r\n *      \r\n *      `contractAddress` address of contract to burn tokens from\r\n *      `specificTokenId` specifies if the user has the option of choosing any token\r\n *          from the contract or if they must burn a specific token\r\n *      `tokenType` is the type of token being burned, defined in TokenTypes.sol\r\n *      `burnType` is the type of burn to perform, burn function call or transfer to \r\n *          dead address, defined in BurnType.sol\r\n *      `tokenId` the tokenId to burn if specificTokenId is true\r\n *      `burnAmount` is the quantity to be burned\r\n */\r\nstruct BurnToken {\r\n    address contractAddress;\r\n    bool specificTokenId;\r\n    uint256 tokenType;\r\n    uint256 burnType;\r\n    uint256 tokenId;\r\n    uint256 burnAmount;\r\n}\r\n\r\n/**\r\n * @dev Defines the token that will be used for payment\r\n *      \r\n *      `contractAddress` address of contract to for payment if ERC20\r\n *          if tokenType is native token then this should be set to 0x000...000\r\n *          to save calldata gas units\r\n *      `tokenType` is the type of token being used for payment, defined in TokenTypes.sol\r\n *      `payTo` the address that will receive the payment\r\n *      `paymentAmount` the amount for the payment in base units for the token\r\n *          ex. a native payment on Ethereum for 1 ETH would be specified in wei\r\n *          which would be 1**18 wei\r\n *      `referralBPS` is the percentage of the payment in BPS that will be sent to the \r\n *          `referrer` on the MintOrder if `referralBPS` is greater than 0 and `referrer`\r\n *          is not address(0)\r\n */\r\nstruct PaymentToken {\r\n    address contractAddress;\r\n    uint256 tokenType;\r\n    address payTo;\r\n    uint256 paymentAmount;\r\n    uint256 referralBPS;\r\n}\r\n"}}, "settings": {"optimizer": {"enabled": true}, "evmVersion": "paris", "viaIR": false, "outputSelection": {"*": {"*": ["evm.legacyAssembly"]}}}}