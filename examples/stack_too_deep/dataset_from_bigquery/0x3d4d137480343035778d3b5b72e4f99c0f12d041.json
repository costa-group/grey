{"language": "Solidity", "sources": {"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.30;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(account),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"}, "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"}, "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"}, "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"}, "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"}, "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.30;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"}, "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"}, "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.30;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"}, "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.30;\n\nimport \"./IERC165Upgradeable.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"}, "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"}, "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"}, "@openzeppelin/contracts-upgradeable/utils/math/SignedMathUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMathUpgradeable {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"}, "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.30;\n\nimport \"./math/MathUpgradeable.sol\";\nimport \"./math/SignedMathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"}, "@openzeppelin/contracts/interfaces/IERC1967.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"}, "@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (proxy/beacon/BeaconProxy.sol)\n\npragma solidity ^0.8.30;\n\nimport {IBeacon} from \"./IBeacon.sol\";\nimport {Proxy} from \"../Proxy.sol\";\nimport {ERC1967Utils} from \"../ERC1967/ERC1967Utils.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\n *\n * The beacon address can only be set once during construction, and cannot be changed afterwards. It is stored in an\n * immutable variable to avoid unnecessary storage reads, and also in the beacon storage slot specified by\n * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967] so that it can be accessed externally.\n *\n * CAUTION: Since the beacon address can never be changed, you must ensure that you either control the beacon, or trust\n * the beacon to not upgrade the implementation maliciously.\n *\n * IMPORTANT: Do not use the implementation logic to modify the beacon storage slot. Doing so would leave the proxy in\n * an inconsistent state where the beacon storage slot does not match the beacon address.\n */\ncontract BeaconProxy is Proxy {\n    // An immutable address for the beacon to avoid unnecessary SLOADs before each delegate call.\n    address private immutable _beacon;\n\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     * - If `data` is empty, `msg.value` must be zero.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        ERC1967Utils.upgradeBeaconToAndCall(beacon, data);\n        _beacon = beacon;\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Returns the beacon.\n     */\n    function _getBeacon() internal view virtual returns (address) {\n        return _beacon;\n    }\n}\n"}, "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {UpgradeableBeacon} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"}, "@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (proxy/ERC1967/ERC1967Utils.sol)\n\npragma solidity ^0.8.30;\n\nimport {IBeacon} from \"../beacon/IBeacon.sol\";\nimport {IERC1967} from \"../../interfaces/IERC1967.sol\";\nimport {Address} from \"../../utils/Address.sol\";\nimport {StorageSlot} from \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This library provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967] slots.\n */\nlibrary ERC1967Utils {\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the ERC-1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit IERC1967.Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by ERC-1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the ERC-1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit IERC1967.AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.beacon\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the ERC-1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit IERC1967.BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn't perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}\n"}, "@openzeppelin/contracts/proxy/Proxy.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback\n     * function and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n}\n"}, "@openzeppelin/contracts/utils/Address.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Address.sol)\n\npragma solidity ^0.8.30;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            _revert(returndata);\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"}, "@openzeppelin/contracts/utils/Errors.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"}, "@openzeppelin/contracts/utils/StorageSlot.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC-1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {SlotDerivation}.\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n}\n"}, "@prb/math/src/Common.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n// Common.sol\n//\n// Common mathematical functions used in both SD59x18 and UD60x18. Note that these global functions do not\n// always operate with SD59x18 and UD60x18 numbers.\n\n/*//////////////////////////////////////////////////////////////////////////\n                                CUSTOM ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Thrown when the resultant value in {mulDiv} overflows uint256.\nerror PRBMath_MulDiv_Overflow(uint256 x, uint256 y, uint256 denominator);\n\n/// @notice Thrown when the resultant value in {mulDiv18} overflows uint256.\nerror PRBMath_MulDiv18_Overflow(uint256 x, uint256 y);\n\n/// @notice Thrown when one of the inputs passed to {mulDivSigned} is `type(int256).min`.\nerror PRBMath_MulDivSigned_InputTooSmall();\n\n/// @notice Thrown when the resultant value in {mulDivSigned} overflows int256.\nerror PRBMath_MulDivSigned_Overflow(int256 x, int256 y);\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CONSTANTS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @dev The maximum value a uint128 number can have.\nuint128 constant MAX_UINT128 = type(uint128).max;\n\n/// @dev The maximum value a uint40 number can have.\nuint40 constant MAX_UINT40 = type(uint40).max;\n\n/// @dev The maximum value a uint64 number can have.\nuint64 constant MAX_UINT64 = type(uint64).max;\n\n/// @dev The unit number, which the decimal precision of the fixed-point types.\nuint256 constant UNIT = 1e18;\n\n/// @dev The unit number inverted mod 2^256.\nuint256 constant UNIT_INVERSE = 78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n/// @dev The the largest power of two that divides the decimal value of `UNIT`. The logarithm of this value is the least significant\n/// bit in the binary representation of `UNIT`.\nuint256 constant UNIT_LPOTD = 262144;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Calculates the binary exponent of x using the binary fraction method.\n/// @dev Has to use 192.64-bit fixed-point numbers. See https://ethereum.stackexchange.com/a/96594/24693.\n/// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\n/// @custom:smtchecker abstract-function-nondet\nfunction exp2(uint256 x) pure returns (uint256 result) {\n    unchecked {\n        // Start from 0.5 in the 192.64-bit fixed-point format.\n        result = 0x800000000000000000000000000000000000000000000000;\n\n        // The following logic multiplies the result by $\\sqrt{2^{-i}}$ when the bit at position i is 1. Key points:\n        //\n        // 1. Intermediate results will not overflow, as the starting point is 2^191 and all magic factors are under 2^65.\n        // 2. The rationale for organizing the if statements into groups of 8 is gas savings. If the result of performing\n        // a bitwise AND operation between x and any value in the array [0x80; 0x40; 0x20; 0x10; 0x08; 0x04; 0x02; 0x01] is 1,\n        // we know that `x & 0xFF` is also 1.\n        if (x & 0xFF00000000000000 > 0) {\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n        }\n\n        if (x & 0xFF000000000000 > 0) {\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n        }\n\n        if (x & 0xFF0000000000 > 0) {\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n        }\n\n        if (x & 0xFF00000000 > 0) {\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n        }\n\n        if (x & 0xFF000000 > 0) {\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n        }\n\n        if (x & 0xFF0000 > 0) {\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n        }\n\n        if (x & 0xFF00 > 0) {\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n        }\n\n        if (x & 0xFF > 0) {\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n        }\n\n        // In the code snippet below, two operations are executed simultaneously:\n        //\n        // 1. The result is multiplied by $(2^n + 1)$, where $2^n$ represents the integer part, and the additional 1\n        // accounts for the initial guess of 0.5. This is achieved by subtracting from 191 instead of 192.\n        // 2. The result is then converted to an unsigned 60.18-decimal fixed-point format.\n        //\n        // The underlying logic is based on the relationship $2^{191-ip} = 2^{ip} / 2^{191}$, where $ip$ denotes the,\n        // integer part, $2^n$.\n        result *= UNIT;\n        result >>= (191 - (x >> 64));\n    }\n}\n\n/// @notice Finds the zero-based index of the first 1 in the binary representation of x.\n///\n/// @dev See the note on \"msb\" in this Wikipedia article: https://en.wikipedia.org/wiki/Find_first_set\n///\n/// Each step in this implementation is equivalent to this high-level code:\n///\n/// ```solidity\n/// if (x >= 2 ** 128) {\n///     x >>= 128;\n///     result += 128;\n/// }\n/// ```\n///\n/// Where 128 is replaced with each respective power of two factor. See the full high-level implementation here:\n/// https://gist.github.com/PaulRBerg/f932f8693f2733e30c4d479e8e980948\n///\n/// The Yul instructions used below are:\n///\n/// - \"gt\" is \"greater than\"\n/// - \"or\" is the OR bitwise operator\n/// - \"shl\" is \"shift left\"\n/// - \"shr\" is \"shift right\"\n///\n/// @param x The uint256 number for which to find the index of the most significant bit.\n/// @return result The index of the most significant bit as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction msb(uint256 x) pure returns (uint256 result) {\n    // 2^128\n    assembly (\"memory-safe\") {\n        let factor := shl(7, gt(x, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^64\n    assembly (\"memory-safe\") {\n        let factor := shl(6, gt(x, 0xFFFFFFFFFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^32\n    assembly (\"memory-safe\") {\n        let factor := shl(5, gt(x, 0xFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^16\n    assembly (\"memory-safe\") {\n        let factor := shl(4, gt(x, 0xFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^8\n    assembly (\"memory-safe\") {\n        let factor := shl(3, gt(x, 0xFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^4\n    assembly (\"memory-safe\") {\n        let factor := shl(2, gt(x, 0xF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^2\n    assembly (\"memory-safe\") {\n        let factor := shl(1, gt(x, 0x3))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^1\n    // No need to shift x any more.\n    assembly (\"memory-safe\") {\n        let factor := gt(x, 0x1)\n        result := or(result, factor)\n    }\n}\n\n/// @notice Calculates x*y\u00f7denominator with 512-bit precision.\n///\n/// @dev Credits to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n///\n/// Notes:\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - The denominator must not be zero.\n/// - The result must fit in uint256.\n///\n/// @param x The multiplicand as a uint256.\n/// @param y The multiplier as a uint256.\n/// @param denominator The divisor as a uint256.\n/// @return result The result as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction mulDiv(uint256 x, uint256 y, uint256 denominator) pure returns (uint256 result) {\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n    // use the Chinese Remainder Theorem to reconstruct the 512-bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2^256 + prod0.\n    uint256 prod0; // Least significant 256 bits of the product\n    uint256 prod1; // Most significant 256 bits of the product\n    assembly (\"memory-safe\") {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    // Handle non-overflow cases, 256 by 256 division.\n    if (prod1 == 0) {\n        unchecked {\n            return prod0 / denominator;\n        }\n    }\n\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\n    if (prod1 >= denominator) {\n        revert PRBMath_MulDiv_Overflow(x, y, denominator);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n    // 512 by 256 division\n    ////////////////////////////////////////////////////////////////////////////\n\n    // Make division exact by subtracting the remainder from [prod1 prod0].\n    uint256 remainder;\n    assembly (\"memory-safe\") {\n        // Compute remainder using the mulmod Yul instruction.\n        remainder := mulmod(x, y, denominator)\n\n        // Subtract 256 bit number from 512-bit number.\n        prod1 := sub(prod1, gt(remainder, prod0))\n        prod0 := sub(prod0, remainder)\n    }\n\n    unchecked {\n        // Calculate the largest power of two divisor of the denominator using the unary operator ~. This operation cannot overflow\n        // because the denominator cannot be zero at this point in the function execution. The result is always >= 1.\n        // For more detail, see https://cs.stackexchange.com/q/138556/92363.\n        uint256 lpotdod = denominator & (~denominator + 1);\n        uint256 flippedLpotdod;\n\n        assembly (\"memory-safe\") {\n            // Factor powers of two out of denominator.\n            denominator := div(denominator, lpotdod)\n\n            // Divide [prod1 prod0] by lpotdod.\n            prod0 := div(prod0, lpotdod)\n\n            // Get the flipped value `2^256 / lpotdod`. If the `lpotdod` is zero, the flipped value is one.\n            // `sub(0, lpotdod)` produces the two's complement version of `lpotdod`, which is equivalent to flipping all the bits.\n            // However, `div` interprets this value as an unsigned value: https://ethereum.stackexchange.com/q/147168/24693\n            flippedLpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n        }\n\n        // Shift in bits from prod1 into prod0.\n        prod0 |= prod1 * flippedLpotdod;\n\n        // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n        // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n        // four bits. That is, denominator * inv = 1 mod 2^4.\n        uint256 inverse = (3 * denominator) ^ 2;\n\n        // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n        // in modular arithmetic, doubling the correct bits in each step.\n        inverse *= 2 - denominator * inverse; // inverse mod 2^8\n        inverse *= 2 - denominator * inverse; // inverse mod 2^16\n        inverse *= 2 - denominator * inverse; // inverse mod 2^32\n        inverse *= 2 - denominator * inverse; // inverse mod 2^64\n        inverse *= 2 - denominator * inverse; // inverse mod 2^128\n        inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n        // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n        // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n        // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inverse;\n    }\n}\n\n/// @notice Calculates x*y\u00f71e18 with 512-bit precision.\n///\n/// @dev A variant of {mulDiv} with constant folding, i.e. in which the denominator is hard coded to 1e18.\n///\n/// Notes:\n/// - The body is purposely left uncommented; to understand how this works, see the documentation in {mulDiv}.\n/// - The result is rounded toward zero.\n/// - We take as an axiom that the result cannot be `MAX_UINT256` when x and y solve the following system of equations:\n///\n/// $$\n/// \\begin{cases}\n///     x * y = MAX\\_UINT256 * UNIT \\\\\n///     (x * y) \\% UNIT \\geq \\frac{UNIT}{2}\n/// \\end{cases}\n/// $$\n///\n/// Requirements:\n/// - Refer to the requirements in {mulDiv}.\n/// - The result must fit in uint256.\n///\n/// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n/// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\n/// @custom:smtchecker abstract-function-nondet\nfunction mulDiv18(uint256 x, uint256 y) pure returns (uint256 result) {\n    uint256 prod0;\n    uint256 prod1;\n    assembly (\"memory-safe\") {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    if (prod1 == 0) {\n        unchecked {\n            return prod0 / UNIT;\n        }\n    }\n\n    if (prod1 >= UNIT) {\n        revert PRBMath_MulDiv18_Overflow(x, y);\n    }\n\n    uint256 remainder;\n    assembly (\"memory-safe\") {\n        remainder := mulmod(x, y, UNIT)\n        result :=\n            mul(\n                or(\n                    div(sub(prod0, remainder), UNIT_LPOTD),\n                    mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, UNIT_LPOTD), UNIT_LPOTD), 1))\n                ),\n                UNIT_INVERSE\n            )\n    }\n}\n\n/// @notice Calculates x*y\u00f7denominator with 512-bit precision.\n///\n/// @dev This is an extension of {mulDiv} for signed numbers, which works by computing the signs and the absolute values separately.\n///\n/// Notes:\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - Refer to the requirements in {mulDiv}.\n/// - None of the inputs can be `type(int256).min`.\n/// - The result must fit in int256.\n///\n/// @param x The multiplicand as an int256.\n/// @param y The multiplier as an int256.\n/// @param denominator The divisor as an int256.\n/// @return result The result as an int256.\n/// @custom:smtchecker abstract-function-nondet\nfunction mulDivSigned(int256 x, int256 y, int256 denominator) pure returns (int256 result) {\n    if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n        revert PRBMath_MulDivSigned_InputTooSmall();\n    }\n\n    // Get hold of the absolute values of x, y and the denominator.\n    uint256 xAbs;\n    uint256 yAbs;\n    uint256 dAbs;\n    unchecked {\n        xAbs = x < 0 ? uint256(-x) : uint256(x);\n        yAbs = y < 0 ? uint256(-y) : uint256(y);\n        dAbs = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n    }\n\n    // Compute the absolute value of x*y\u00f7denominator. The result must fit in int256.\n    uint256 resultAbs = mulDiv(xAbs, yAbs, dAbs);\n    if (resultAbs > uint256(type(int256).max)) {\n        revert PRBMath_MulDivSigned_Overflow(x, y);\n    }\n\n    // Get the signs of x, y and the denominator.\n    uint256 sx;\n    uint256 sy;\n    uint256 sd;\n    assembly (\"memory-safe\") {\n        // \"sgt\" is the \"signed greater than\" assembly instruction and \"sub(0,1)\" is -1 in two's complement.\n        sx := sgt(x, sub(0, 1))\n        sy := sgt(y, sub(0, 1))\n        sd := sgt(denominator, sub(0, 1))\n    }\n\n    // XOR over sx, sy and sd. What this does is to check whether there are 1 or 3 negative signs in the inputs.\n    // If there are, the result should be negative. Otherwise, it should be positive.\n    unchecked {\n        result = sx ^ sy ^ sd == 0 ? -int256(resultAbs) : int256(resultAbs);\n    }\n}\n\n/// @notice Calculates the square root of x using the Babylonian method.\n///\n/// @dev See https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n///\n/// Notes:\n/// - If x is not a perfect square, the result is rounded down.\n/// - Credits to OpenZeppelin for the explanations in comments below.\n///\n/// @param x The uint256 number for which to calculate the square root.\n/// @return result The result as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction sqrt(uint256 x) pure returns (uint256 result) {\n    if (x == 0) {\n        return 0;\n    }\n\n    // For our first guess, we calculate the biggest power of 2 which is smaller than the square root of x.\n    //\n    // We know that the \"msb\" (most significant bit) of x is a power of 2 such that we have:\n    //\n    // $$\n    // msb(x) <= x <= 2*msb(x)$\n    // $$\n    //\n    // We write $msb(x)$ as $2^k$, and we get:\n    //\n    // $$\n    // k = log_2(x)\n    // $$\n    //\n    // Thus, we can write the initial inequality as:\n    //\n    // $$\n    // 2^{log_2(x)} <= x <= 2*2^{log_2(x)+1} \\\\\n    // sqrt(2^k) <= sqrt(x) < sqrt(2^{k+1}) \\\\\n    // 2^{k/2} <= sqrt(x) < 2^{(k+1)/2} <= 2^{(k/2)+1}\n    // $$\n    //\n    // Consequently, $2^{log_2(x) /2} is a good first approximation of sqrt(x) with at least one correct bit.\n    uint256 xAux = uint256(x);\n    result = 1;\n    if (xAux >= 2 ** 128) {\n        xAux >>= 128;\n        result <<= 64;\n    }\n    if (xAux >= 2 ** 64) {\n        xAux >>= 64;\n        result <<= 32;\n    }\n    if (xAux >= 2 ** 32) {\n        xAux >>= 32;\n        result <<= 16;\n    }\n    if (xAux >= 2 ** 16) {\n        xAux >>= 16;\n        result <<= 8;\n    }\n    if (xAux >= 2 ** 8) {\n        xAux >>= 8;\n        result <<= 4;\n    }\n    if (xAux >= 2 ** 4) {\n        xAux >>= 4;\n        result <<= 2;\n    }\n    if (xAux >= 2 ** 2) {\n        result <<= 1;\n    }\n\n    // At this point, `result` is an estimation with at least one bit of precision. We know the true value has at\n    // most 128 bits, since it is the square root of a uint256. Newton's method converges quadratically (precision\n    // doubles at every iteration). We thus need at most 7 iteration to turn our partial result with one bit of\n    // precision into the expected uint128 result.\n    unchecked {\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n\n        // If x is not a perfect square, round the result toward zero.\n        uint256 roundedResult = x / result;\n        if (result >= roundedResult) {\n            result = roundedResult;\n        }\n    }\n}\n"}, "@prb/math/src/sd1x18/Casting.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"../Common.sol\" as Common;\nimport \"./Errors.sol\" as CastingErrors;\nimport { SD59x18 } from \"../sd59x18/ValueType.sol\";\nimport { UD60x18 } from \"../ud60x18/ValueType.sol\";\nimport { SD1x18 } from \"./ValueType.sol\";\n\n/// @notice Casts an SD1x18 number into SD59x18.\n/// @dev There is no overflow check because SD1x18 \u2286 SD59x18.\nfunction intoSD59x18(SD1x18 x) pure returns (SD59x18 result) {\n    result = SD59x18.wrap(int256(SD1x18.unwrap(x)));\n}\n\n/// @notice Casts an SD1x18 number into UD60x18.\n/// @dev Requirements:\n/// - x \u2265 0\nfunction intoUD60x18(SD1x18 x) pure returns (UD60x18 result) {\n    int64 xInt = SD1x18.unwrap(x);\n    if (xInt < 0) {\n        revert CastingErrors.PRBMath_SD1x18_ToUD60x18_Underflow(x);\n    }\n    result = UD60x18.wrap(uint64(xInt));\n}\n\n/// @notice Casts an SD1x18 number into uint128.\n/// @dev Requirements:\n/// - x \u2265 0\nfunction intoUint128(SD1x18 x) pure returns (uint128 result) {\n    int64 xInt = SD1x18.unwrap(x);\n    if (xInt < 0) {\n        revert CastingErrors.PRBMath_SD1x18_ToUint128_Underflow(x);\n    }\n    result = uint128(uint64(xInt));\n}\n\n/// @notice Casts an SD1x18 number into uint256.\n/// @dev Requirements:\n/// - x \u2265 0\nfunction intoUint256(SD1x18 x) pure returns (uint256 result) {\n    int64 xInt = SD1x18.unwrap(x);\n    if (xInt < 0) {\n        revert CastingErrors.PRBMath_SD1x18_ToUint256_Underflow(x);\n    }\n    result = uint256(uint64(xInt));\n}\n\n/// @notice Casts an SD1x18 number into uint40.\n/// @dev Requirements:\n/// - x \u2265 0\n/// - x \u2264 MAX_UINT40\nfunction intoUint40(SD1x18 x) pure returns (uint40 result) {\n    int64 xInt = SD1x18.unwrap(x);\n    if (xInt < 0) {\n        revert CastingErrors.PRBMath_SD1x18_ToUint40_Underflow(x);\n    }\n    if (xInt > int64(uint64(Common.MAX_UINT40))) {\n        revert CastingErrors.PRBMath_SD1x18_ToUint40_Overflow(x);\n    }\n    result = uint40(uint64(xInt));\n}\n\n/// @notice Alias for {wrap}.\nfunction sd1x18(int64 x) pure returns (SD1x18 result) {\n    result = SD1x18.wrap(x);\n}\n\n/// @notice Unwraps an SD1x18 number into int64.\nfunction unwrap(SD1x18 x) pure returns (int64 result) {\n    result = SD1x18.unwrap(x);\n}\n\n/// @notice Wraps an int64 number into SD1x18.\nfunction wrap(int64 x) pure returns (SD1x18 result) {\n    result = SD1x18.wrap(x);\n}\n"}, "@prb/math/src/sd1x18/Constants.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { SD1x18 } from \"./ValueType.sol\";\n\n/// @dev Euler's number as an SD1x18 number.\nSD1x18 constant E = SD1x18.wrap(2_718281828459045235);\n\n/// @dev The maximum value an SD1x18 number can have.\nint64 constant uMAX_SD1x18 = 9_223372036854775807;\nSD1x18 constant MAX_SD1x18 = SD1x18.wrap(uMAX_SD1x18);\n\n/// @dev The minimum value an SD1x18 number can have.\nint64 constant uMIN_SD1x18 = -9_223372036854775808;\nSD1x18 constant MIN_SD1x18 = SD1x18.wrap(uMIN_SD1x18);\n\n/// @dev PI as an SD1x18 number.\nSD1x18 constant PI = SD1x18.wrap(3_141592653589793238);\n\n/// @dev The unit number, which gives the decimal precision of SD1x18.\nSD1x18 constant UNIT = SD1x18.wrap(1e18);\nint64 constant uUNIT = 1e18;\n"}, "@prb/math/src/sd1x18/Errors.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { SD1x18 } from \"./ValueType.sol\";\n\n/// @notice Thrown when trying to cast an SD1x18 number that doesn't fit in UD60x18.\nerror PRBMath_SD1x18_ToUD60x18_Underflow(SD1x18 x);\n\n/// @notice Thrown when trying to cast an SD1x18 number that doesn't fit in uint128.\nerror PRBMath_SD1x18_ToUint128_Underflow(SD1x18 x);\n\n/// @notice Thrown when trying to cast an SD1x18 number that doesn't fit in uint256.\nerror PRBMath_SD1x18_ToUint256_Underflow(SD1x18 x);\n\n/// @notice Thrown when trying to cast an SD1x18 number that doesn't fit in uint40.\nerror PRBMath_SD1x18_ToUint40_Overflow(SD1x18 x);\n\n/// @notice Thrown when trying to cast an SD1x18 number that doesn't fit in uint40.\nerror PRBMath_SD1x18_ToUint40_Underflow(SD1x18 x);\n"}, "@prb/math/src/sd1x18/ValueType.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"./Casting.sol\" as Casting;\n\n/// @notice The signed 1.18-decimal fixed-point number representation, which can have up to 1 digit and up to 18\n/// decimals. The values of this are bound by the minimum and the maximum values permitted by the underlying Solidity\n/// type int64. This is useful when end users want to use int64 to save gas, e.g. with tight variable packing in contract\n/// storage.\ntype SD1x18 is int64;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CASTING\n//////////////////////////////////////////////////////////////////////////*/\n\nusing {\n    Casting.intoSD59x18,\n    Casting.intoUD60x18,\n    Casting.intoUint128,\n    Casting.intoUint256,\n    Casting.intoUint40,\n    Casting.unwrap\n} for SD1x18 global;\n"}, "@prb/math/src/sd21x18/Casting.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"../Common.sol\" as Common;\nimport \"./Errors.sol\" as CastingErrors;\nimport { SD59x18 } from \"../sd59x18/ValueType.sol\";\nimport { UD60x18 } from \"../ud60x18/ValueType.sol\";\nimport { SD21x18 } from \"./ValueType.sol\";\n\n/// @notice Casts an SD21x18 number into SD59x18.\n/// @dev There is no overflow check because SD21x18 \u2286 SD59x18.\nfunction intoSD59x18(SD21x18 x) pure returns (SD59x18 result) {\n    result = SD59x18.wrap(int256(SD21x18.unwrap(x)));\n}\n\n/// @notice Casts an SD21x18 number into UD60x18.\n/// @dev Requirements:\n/// - x \u2265 0\nfunction intoUD60x18(SD21x18 x) pure returns (UD60x18 result) {\n    int128 xInt = SD21x18.unwrap(x);\n    if (xInt < 0) {\n        revert CastingErrors.PRBMath_SD21x18_ToUD60x18_Underflow(x);\n    }\n    result = UD60x18.wrap(uint128(xInt));\n}\n\n/// @notice Casts an SD21x18 number into uint128.\n/// @dev Requirements:\n/// - x \u2265 0\nfunction intoUint128(SD21x18 x) pure returns (uint128 result) {\n    int128 xInt = SD21x18.unwrap(x);\n    if (xInt < 0) {\n        revert CastingErrors.PRBMath_SD21x18_ToUint128_Underflow(x);\n    }\n    result = uint128(xInt);\n}\n\n/// @notice Casts an SD21x18 number into uint256.\n/// @dev Requirements:\n/// - x \u2265 0\nfunction intoUint256(SD21x18 x) pure returns (uint256 result) {\n    int128 xInt = SD21x18.unwrap(x);\n    if (xInt < 0) {\n        revert CastingErrors.PRBMath_SD21x18_ToUint256_Underflow(x);\n    }\n    result = uint256(uint128(xInt));\n}\n\n/// @notice Casts an SD21x18 number into uint40.\n/// @dev Requirements:\n/// - x \u2265 0\n/// - x \u2264 MAX_UINT40\nfunction intoUint40(SD21x18 x) pure returns (uint40 result) {\n    int128 xInt = SD21x18.unwrap(x);\n    if (xInt < 0) {\n        revert CastingErrors.PRBMath_SD21x18_ToUint40_Underflow(x);\n    }\n    if (xInt > int128(uint128(Common.MAX_UINT40))) {\n        revert CastingErrors.PRBMath_SD21x18_ToUint40_Overflow(x);\n    }\n    result = uint40(uint128(xInt));\n}\n\n/// @notice Alias for {wrap}.\nfunction sd21x18(int128 x) pure returns (SD21x18 result) {\n    result = SD21x18.wrap(x);\n}\n\n/// @notice Unwraps an SD21x18 number into int128.\nfunction unwrap(SD21x18 x) pure returns (int128 result) {\n    result = SD21x18.unwrap(x);\n}\n\n/// @notice Wraps an int128 number into SD21x18.\nfunction wrap(int128 x) pure returns (SD21x18 result) {\n    result = SD21x18.wrap(x);\n}\n"}, "@prb/math/src/sd21x18/Constants.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { SD21x18 } from \"./ValueType.sol\";\n\n/// @dev Euler's number as an SD21x18 number.\nSD21x18 constant E = SD21x18.wrap(2_718281828459045235);\n\n/// @dev The maximum value an SD21x18 number can have.\nint128 constant uMAX_SD21x18 = 170141183460469231731_687303715884105727;\nSD21x18 constant MAX_SD21x18 = SD21x18.wrap(uMAX_SD21x18);\n\n/// @dev The minimum value an SD21x18 number can have.\nint128 constant uMIN_SD21x18 = -170141183460469231731_687303715884105728;\nSD21x18 constant MIN_SD21x18 = SD21x18.wrap(uMIN_SD21x18);\n\n/// @dev PI as an SD21x18 number.\nSD21x18 constant PI = SD21x18.wrap(3_141592653589793238);\n\n/// @dev The unit number, which gives the decimal precision of SD21x18.\nSD21x18 constant UNIT = SD21x18.wrap(1e18);\nint128 constant uUNIT = 1e18;\n"}, "@prb/math/src/sd21x18/Errors.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { SD21x18 } from \"./ValueType.sol\";\n\n/// @notice Thrown when trying to cast an SD21x18 number that doesn't fit in uint128.\nerror PRBMath_SD21x18_ToUint128_Underflow(SD21x18 x);\n\n/// @notice Thrown when trying to cast an SD21x18 number that doesn't fit in UD60x18.\nerror PRBMath_SD21x18_ToUD60x18_Underflow(SD21x18 x);\n\n/// @notice Thrown when trying to cast an SD21x18 number that doesn't fit in uint256.\nerror PRBMath_SD21x18_ToUint256_Underflow(SD21x18 x);\n\n/// @notice Thrown when trying to cast an SD21x18 number that doesn't fit in uint40.\nerror PRBMath_SD21x18_ToUint40_Overflow(SD21x18 x);\n\n/// @notice Thrown when trying to cast an SD21x18 number that doesn't fit in uint40.\nerror PRBMath_SD21x18_ToUint40_Underflow(SD21x18 x);\n"}, "@prb/math/src/sd21x18/ValueType.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"./Casting.sol\" as Casting;\n\n/// @notice The signed 21.18-decimal fixed-point number representation, which can have up to 21 digits and up to 18\n/// decimals. The values of this are bound by the minimum and the maximum values permitted by the underlying Solidity\n/// type int128. This is useful when end users want to use int128 to save gas, e.g. with tight variable packing in contract\n/// storage.\ntype SD21x18 is int128;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CASTING\n//////////////////////////////////////////////////////////////////////////*/\n\nusing {\n    Casting.intoSD59x18,\n    Casting.intoUD60x18,\n    Casting.intoUint128,\n    Casting.intoUint256,\n    Casting.intoUint40,\n    Casting.unwrap\n} for SD21x18 global;\n"}, "@prb/math/src/sd59x18/Casting.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"./Errors.sol\" as CastingErrors;\nimport { MAX_UINT128, MAX_UINT40 } from \"../Common.sol\";\nimport { uMAX_SD1x18, uMIN_SD1x18 } from \"../sd1x18/Constants.sol\";\nimport { SD1x18 } from \"../sd1x18/ValueType.sol\";\nimport { uMAX_SD21x18, uMIN_SD21x18 } from \"../sd21x18/Constants.sol\";\nimport { SD21x18 } from \"../sd21x18/ValueType.sol\";\nimport { uMAX_UD2x18 } from \"../ud2x18/Constants.sol\";\nimport { UD2x18 } from \"../ud2x18/ValueType.sol\";\nimport { uMAX_UD21x18 } from \"../ud21x18/Constants.sol\";\nimport { UD21x18 } from \"../ud21x18/ValueType.sol\";\nimport { UD60x18 } from \"../ud60x18/ValueType.sol\";\nimport { SD59x18 } from \"./ValueType.sol\";\n\n/// @notice Casts an SD59x18 number into int256.\n/// @dev This is basically a functional alias for {unwrap}.\nfunction intoInt256(SD59x18 x) pure returns (int256 result) {\n    result = SD59x18.unwrap(x);\n}\n\n/// @notice Casts an SD59x18 number into SD1x18.\n/// @dev Requirements:\n/// - x \u2265 uMIN_SD1x18\n/// - x \u2264 uMAX_SD1x18\nfunction intoSD1x18(SD59x18 x) pure returns (SD1x18 result) {\n    int256 xInt = SD59x18.unwrap(x);\n    if (xInt < uMIN_SD1x18) {\n        revert CastingErrors.PRBMath_SD59x18_IntoSD1x18_Underflow(x);\n    }\n    if (xInt > uMAX_SD1x18) {\n        revert CastingErrors.PRBMath_SD59x18_IntoSD1x18_Overflow(x);\n    }\n    result = SD1x18.wrap(int64(xInt));\n}\n\n/// @notice Casts an SD59x18 number into SD21x18.\n/// @dev Requirements:\n/// - x \u2265 uMIN_SD21x18\n/// - x \u2264 uMAX_SD21x18\nfunction intoSD21x18(SD59x18 x) pure returns (SD21x18 result) {\n    int256 xInt = SD59x18.unwrap(x);\n    if (xInt < uMIN_SD21x18) {\n        revert CastingErrors.PRBMath_SD59x18_IntoSD21x18_Underflow(x);\n    }\n    if (xInt > uMAX_SD21x18) {\n        revert CastingErrors.PRBMath_SD59x18_IntoSD21x18_Overflow(x);\n    }\n    result = SD21x18.wrap(int128(xInt));\n}\n\n/// @notice Casts an SD59x18 number into UD2x18.\n/// @dev Requirements:\n/// - x \u2265 0\n/// - x \u2264 uMAX_UD2x18\nfunction intoUD2x18(SD59x18 x) pure returns (UD2x18 result) {\n    int256 xInt = SD59x18.unwrap(x);\n    if (xInt < 0) {\n        revert CastingErrors.PRBMath_SD59x18_IntoUD2x18_Underflow(x);\n    }\n    if (xInt > int256(uint256(uMAX_UD2x18))) {\n        revert CastingErrors.PRBMath_SD59x18_IntoUD2x18_Overflow(x);\n    }\n    result = UD2x18.wrap(uint64(uint256(xInt)));\n}\n\n/// @notice Casts an SD59x18 number into UD21x18.\n/// @dev Requirements:\n/// - x \u2265 0\n/// - x \u2264 uMAX_UD21x18\nfunction intoUD21x18(SD59x18 x) pure returns (UD21x18 result) {\n    int256 xInt = SD59x18.unwrap(x);\n    if (xInt < 0) {\n        revert CastingErrors.PRBMath_SD59x18_IntoUD21x18_Underflow(x);\n    }\n    if (xInt > int256(uint256(uMAX_UD21x18))) {\n        revert CastingErrors.PRBMath_SD59x18_IntoUD21x18_Overflow(x);\n    }\n    result = UD21x18.wrap(uint128(uint256(xInt)));\n}\n\n/// @notice Casts an SD59x18 number into UD60x18.\n/// @dev Requirements:\n/// - x \u2265 0\nfunction intoUD60x18(SD59x18 x) pure returns (UD60x18 result) {\n    int256 xInt = SD59x18.unwrap(x);\n    if (xInt < 0) {\n        revert CastingErrors.PRBMath_SD59x18_IntoUD60x18_Underflow(x);\n    }\n    result = UD60x18.wrap(uint256(xInt));\n}\n\n/// @notice Casts an SD59x18 number into uint256.\n/// @dev Requirements:\n/// - x \u2265 0\nfunction intoUint256(SD59x18 x) pure returns (uint256 result) {\n    int256 xInt = SD59x18.unwrap(x);\n    if (xInt < 0) {\n        revert CastingErrors.PRBMath_SD59x18_IntoUint256_Underflow(x);\n    }\n    result = uint256(xInt);\n}\n\n/// @notice Casts an SD59x18 number into uint128.\n/// @dev Requirements:\n/// - x \u2265 0\n/// - x \u2264 uMAX_UINT128\nfunction intoUint128(SD59x18 x) pure returns (uint128 result) {\n    int256 xInt = SD59x18.unwrap(x);\n    if (xInt < 0) {\n        revert CastingErrors.PRBMath_SD59x18_IntoUint128_Underflow(x);\n    }\n    if (xInt > int256(uint256(MAX_UINT128))) {\n        revert CastingErrors.PRBMath_SD59x18_IntoUint128_Overflow(x);\n    }\n    result = uint128(uint256(xInt));\n}\n\n/// @notice Casts an SD59x18 number into uint40.\n/// @dev Requirements:\n/// - x \u2265 0\n/// - x \u2264 MAX_UINT40\nfunction intoUint40(SD59x18 x) pure returns (uint40 result) {\n    int256 xInt = SD59x18.unwrap(x);\n    if (xInt < 0) {\n        revert CastingErrors.PRBMath_SD59x18_IntoUint40_Underflow(x);\n    }\n    if (xInt > int256(uint256(MAX_UINT40))) {\n        revert CastingErrors.PRBMath_SD59x18_IntoUint40_Overflow(x);\n    }\n    result = uint40(uint256(xInt));\n}\n\n/// @notice Alias for {wrap}.\nfunction sd(int256 x) pure returns (SD59x18 result) {\n    result = SD59x18.wrap(x);\n}\n\n/// @notice Alias for {wrap}.\nfunction sd59x18(int256 x) pure returns (SD59x18 result) {\n    result = SD59x18.wrap(x);\n}\n\n/// @notice Unwraps an SD59x18 number into int256.\nfunction unwrap(SD59x18 x) pure returns (int256 result) {\n    result = SD59x18.unwrap(x);\n}\n\n/// @notice Wraps an int256 number into SD59x18.\nfunction wrap(int256 x) pure returns (SD59x18 result) {\n    result = SD59x18.wrap(x);\n}\n"}, "@prb/math/src/sd59x18/Constants.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { SD59x18 } from \"./ValueType.sol\";\n\n// NOTICE: the \"u\" prefix stands for \"unwrapped\".\n\n/// @dev Euler's number as an SD59x18 number.\nSD59x18 constant E = SD59x18.wrap(2_718281828459045235);\n\n/// @dev The maximum input permitted in {exp}.\nint256 constant uEXP_MAX_INPUT = 133_084258667509499440;\nSD59x18 constant EXP_MAX_INPUT = SD59x18.wrap(uEXP_MAX_INPUT);\n\n/// @dev Any value less than this returns 0 in {exp}.\nint256 constant uEXP_MIN_THRESHOLD = -41_446531673892822322;\nSD59x18 constant EXP_MIN_THRESHOLD = SD59x18.wrap(uEXP_MIN_THRESHOLD);\n\n/// @dev The maximum input permitted in {exp2}.\nint256 constant uEXP2_MAX_INPUT = 192e18 - 1;\nSD59x18 constant EXP2_MAX_INPUT = SD59x18.wrap(uEXP2_MAX_INPUT);\n\n/// @dev Any value less than this returns 0 in {exp2}.\nint256 constant uEXP2_MIN_THRESHOLD = -59_794705707972522261;\nSD59x18 constant EXP2_MIN_THRESHOLD = SD59x18.wrap(uEXP2_MIN_THRESHOLD);\n\n/// @dev Half the UNIT number.\nint256 constant uHALF_UNIT = 0.5e18;\nSD59x18 constant HALF_UNIT = SD59x18.wrap(uHALF_UNIT);\n\n/// @dev $log_2(10)$ as an SD59x18 number.\nint256 constant uLOG2_10 = 3_321928094887362347;\nSD59x18 constant LOG2_10 = SD59x18.wrap(uLOG2_10);\n\n/// @dev $log_2(e)$ as an SD59x18 number.\nint256 constant uLOG2_E = 1_442695040888963407;\nSD59x18 constant LOG2_E = SD59x18.wrap(uLOG2_E);\n\n/// @dev The maximum value an SD59x18 number can have.\nint256 constant uMAX_SD59x18 = 57896044618658097711785492504343953926634992332820282019728_792003956564819967;\nSD59x18 constant MAX_SD59x18 = SD59x18.wrap(uMAX_SD59x18);\n\n/// @dev The maximum whole value an SD59x18 number can have.\nint256 constant uMAX_WHOLE_SD59x18 = 57896044618658097711785492504343953926634992332820282019728_000000000000000000;\nSD59x18 constant MAX_WHOLE_SD59x18 = SD59x18.wrap(uMAX_WHOLE_SD59x18);\n\n/// @dev The minimum value an SD59x18 number can have.\nint256 constant uMIN_SD59x18 = -57896044618658097711785492504343953926634992332820282019728_792003956564819968;\nSD59x18 constant MIN_SD59x18 = SD59x18.wrap(uMIN_SD59x18);\n\n/// @dev The minimum whole value an SD59x18 number can have.\nint256 constant uMIN_WHOLE_SD59x18 = -57896044618658097711785492504343953926634992332820282019728_000000000000000000;\nSD59x18 constant MIN_WHOLE_SD59x18 = SD59x18.wrap(uMIN_WHOLE_SD59x18);\n\n/// @dev PI as an SD59x18 number.\nSD59x18 constant PI = SD59x18.wrap(3_141592653589793238);\n\n/// @dev The unit number, which gives the decimal precision of SD59x18.\nint256 constant uUNIT = 1e18;\nSD59x18 constant UNIT = SD59x18.wrap(1e18);\n\n/// @dev The unit number squared.\nint256 constant uUNIT_SQUARED = 1e36;\nSD59x18 constant UNIT_SQUARED = SD59x18.wrap(uUNIT_SQUARED);\n\n/// @dev Zero as an SD59x18 number.\nSD59x18 constant ZERO = SD59x18.wrap(0);\n"}, "@prb/math/src/sd59x18/Errors.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { SD59x18 } from \"./ValueType.sol\";\n\n/// @notice Thrown when taking the absolute value of `MIN_SD59x18`.\nerror PRBMath_SD59x18_Abs_MinSD59x18();\n\n/// @notice Thrown when ceiling a number overflows SD59x18.\nerror PRBMath_SD59x18_Ceil_Overflow(SD59x18 x);\n\n/// @notice Thrown when converting a basic integer to the fixed-point format overflows SD59x18.\nerror PRBMath_SD59x18_Convert_Overflow(int256 x);\n\n/// @notice Thrown when converting a basic integer to the fixed-point format underflows SD59x18.\nerror PRBMath_SD59x18_Convert_Underflow(int256 x);\n\n/// @notice Thrown when dividing two numbers and one of them is `MIN_SD59x18`.\nerror PRBMath_SD59x18_Div_InputTooSmall();\n\n/// @notice Thrown when dividing two numbers and one of the intermediary unsigned results overflows SD59x18.\nerror PRBMath_SD59x18_Div_Overflow(SD59x18 x, SD59x18 y);\n\n/// @notice Thrown when taking the natural exponent of a base greater than 133_084258667509499441.\nerror PRBMath_SD59x18_Exp_InputTooBig(SD59x18 x);\n\n/// @notice Thrown when taking the binary exponent of a base greater than 192e18.\nerror PRBMath_SD59x18_Exp2_InputTooBig(SD59x18 x);\n\n/// @notice Thrown when flooring a number underflows SD59x18.\nerror PRBMath_SD59x18_Floor_Underflow(SD59x18 x);\n\n/// @notice Thrown when taking the geometric mean of two numbers and their product is negative.\nerror PRBMath_SD59x18_Gm_NegativeProduct(SD59x18 x, SD59x18 y);\n\n/// @notice Thrown when taking the geometric mean of two numbers and multiplying them overflows SD59x18.\nerror PRBMath_SD59x18_Gm_Overflow(SD59x18 x, SD59x18 y);\n\n/// @notice Thrown when trying to cast an SD59x18 number that doesn't fit in SD1x18.\nerror PRBMath_SD59x18_IntoSD1x18_Overflow(SD59x18 x);\n\n/// @notice Thrown when trying to cast an SD59x18 number that doesn't fit in SD1x18.\nerror PRBMath_SD59x18_IntoSD1x18_Underflow(SD59x18 x);\n\n/// @notice Thrown when trying to cast an SD59x18 number that doesn't fit in SD21x18.\nerror PRBMath_SD59x18_IntoSD21x18_Overflow(SD59x18 x);\n\n/// @notice Thrown when trying to cast an SD59x18 number that doesn't fit in SD21x18.\nerror PRBMath_SD59x18_IntoSD21x18_Underflow(SD59x18 x);\n\n/// @notice Thrown when trying to cast an SD59x18 number that doesn't fit in UD2x18.\nerror PRBMath_SD59x18_IntoUD2x18_Overflow(SD59x18 x);\n\n/// @notice Thrown when trying to cast an SD59x18 number that doesn't fit in UD2x18.\nerror PRBMath_SD59x18_IntoUD2x18_Underflow(SD59x18 x);\n\n/// @notice Thrown when trying to cast an SD59x18 number that doesn't fit in UD21x18.\nerror PRBMath_SD59x18_IntoUD21x18_Overflow(SD59x18 x);\n\n/// @notice Thrown when trying to cast an SD59x18 number that doesn't fit in UD21x18.\nerror PRBMath_SD59x18_IntoUD21x18_Underflow(SD59x18 x);\n\n/// @notice Thrown when trying to cast an SD59x18 number that doesn't fit in UD60x18.\nerror PRBMath_SD59x18_IntoUD60x18_Underflow(SD59x18 x);\n\n/// @notice Thrown when trying to cast an SD59x18 number that doesn't fit in uint128.\nerror PRBMath_SD59x18_IntoUint128_Overflow(SD59x18 x);\n\n/// @notice Thrown when trying to cast an SD59x18 number that doesn't fit in uint128.\nerror PRBMath_SD59x18_IntoUint128_Underflow(SD59x18 x);\n\n/// @notice Thrown when trying to cast an SD59x18 number that doesn't fit in uint256.\nerror PRBMath_SD59x18_IntoUint256_Underflow(SD59x18 x);\n\n/// @notice Thrown when trying to cast an SD59x18 number that doesn't fit in uint40.\nerror PRBMath_SD59x18_IntoUint40_Overflow(SD59x18 x);\n\n/// @notice Thrown when trying to cast an SD59x18 number that doesn't fit in uint40.\nerror PRBMath_SD59x18_IntoUint40_Underflow(SD59x18 x);\n\n/// @notice Thrown when taking the logarithm of a number less than or equal to zero.\nerror PRBMath_SD59x18_Log_InputTooSmall(SD59x18 x);\n\n/// @notice Thrown when multiplying two numbers and one of the inputs is `MIN_SD59x18`.\nerror PRBMath_SD59x18_Mul_InputTooSmall();\n\n/// @notice Thrown when multiplying two numbers and the intermediary absolute result overflows SD59x18.\nerror PRBMath_SD59x18_Mul_Overflow(SD59x18 x, SD59x18 y);\n\n/// @notice Thrown when raising a number to a power and the intermediary absolute result overflows SD59x18.\nerror PRBMath_SD59x18_Powu_Overflow(SD59x18 x, uint256 y);\n\n/// @notice Thrown when taking the square root of a negative number.\nerror PRBMath_SD59x18_Sqrt_NegativeInput(SD59x18 x);\n\n/// @notice Thrown when the calculating the square root overflows SD59x18.\nerror PRBMath_SD59x18_Sqrt_Overflow(SD59x18 x);\n"}, "@prb/math/src/sd59x18/Helpers.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { wrap } from \"./Casting.sol\";\nimport { SD59x18 } from \"./ValueType.sol\";\n\n/// @notice Implements the checked addition operation (+) in the SD59x18 type.\nfunction add(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    return wrap(x.unwrap() + y.unwrap());\n}\n\n/// @notice Implements the AND (&) bitwise operation in the SD59x18 type.\nfunction and(SD59x18 x, int256 bits) pure returns (SD59x18 result) {\n    return wrap(x.unwrap() & bits);\n}\n\n/// @notice Implements the AND (&) bitwise operation in the SD59x18 type.\nfunction and2(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    return wrap(x.unwrap() & y.unwrap());\n}\n\n/// @notice Implements the equal (=) operation in the SD59x18 type.\nfunction eq(SD59x18 x, SD59x18 y) pure returns (bool result) {\n    result = x.unwrap() == y.unwrap();\n}\n\n/// @notice Implements the greater than operation (>) in the SD59x18 type.\nfunction gt(SD59x18 x, SD59x18 y) pure returns (bool result) {\n    result = x.unwrap() > y.unwrap();\n}\n\n/// @notice Implements the greater than or equal to operation (>=) in the SD59x18 type.\nfunction gte(SD59x18 x, SD59x18 y) pure returns (bool result) {\n    result = x.unwrap() >= y.unwrap();\n}\n\n/// @notice Implements a zero comparison check function in the SD59x18 type.\nfunction isZero(SD59x18 x) pure returns (bool result) {\n    result = x.unwrap() == 0;\n}\n\n/// @notice Implements the left shift operation (<<) in the SD59x18 type.\nfunction lshift(SD59x18 x, uint256 bits) pure returns (SD59x18 result) {\n    result = wrap(x.unwrap() << bits);\n}\n\n/// @notice Implements the lower than operation (<) in the SD59x18 type.\nfunction lt(SD59x18 x, SD59x18 y) pure returns (bool result) {\n    result = x.unwrap() < y.unwrap();\n}\n\n/// @notice Implements the lower than or equal to operation (<=) in the SD59x18 type.\nfunction lte(SD59x18 x, SD59x18 y) pure returns (bool result) {\n    result = x.unwrap() <= y.unwrap();\n}\n\n/// @notice Implements the unchecked modulo operation (%) in the SD59x18 type.\nfunction mod(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    result = wrap(x.unwrap() % y.unwrap());\n}\n\n/// @notice Implements the not equal operation (!=) in the SD59x18 type.\nfunction neq(SD59x18 x, SD59x18 y) pure returns (bool result) {\n    result = x.unwrap() != y.unwrap();\n}\n\n/// @notice Implements the NOT (~) bitwise operation in the SD59x18 type.\nfunction not(SD59x18 x) pure returns (SD59x18 result) {\n    result = wrap(~x.unwrap());\n}\n\n/// @notice Implements the OR (|) bitwise operation in the SD59x18 type.\nfunction or(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    result = wrap(x.unwrap() | y.unwrap());\n}\n\n/// @notice Implements the right shift operation (>>) in the SD59x18 type.\nfunction rshift(SD59x18 x, uint256 bits) pure returns (SD59x18 result) {\n    result = wrap(x.unwrap() >> bits);\n}\n\n/// @notice Implements the checked subtraction operation (-) in the SD59x18 type.\nfunction sub(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    result = wrap(x.unwrap() - y.unwrap());\n}\n\n/// @notice Implements the checked unary minus operation (-) in the SD59x18 type.\nfunction unary(SD59x18 x) pure returns (SD59x18 result) {\n    result = wrap(-x.unwrap());\n}\n\n/// @notice Implements the unchecked addition operation (+) in the SD59x18 type.\nfunction uncheckedAdd(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    unchecked {\n        result = wrap(x.unwrap() + y.unwrap());\n    }\n}\n\n/// @notice Implements the unchecked subtraction operation (-) in the SD59x18 type.\nfunction uncheckedSub(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    unchecked {\n        result = wrap(x.unwrap() - y.unwrap());\n    }\n}\n\n/// @notice Implements the unchecked unary minus operation (-) in the SD59x18 type.\nfunction uncheckedUnary(SD59x18 x) pure returns (SD59x18 result) {\n    unchecked {\n        result = wrap(-x.unwrap());\n    }\n}\n\n/// @notice Implements the XOR (^) bitwise operation in the SD59x18 type.\nfunction xor(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    result = wrap(x.unwrap() ^ y.unwrap());\n}\n"}, "@prb/math/src/sd59x18/Math.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"../Common.sol\" as Common;\nimport \"./Errors.sol\" as Errors;\nimport {\n    uEXP_MAX_INPUT,\n    uEXP2_MAX_INPUT,\n    uEXP_MIN_THRESHOLD,\n    uEXP2_MIN_THRESHOLD,\n    uHALF_UNIT,\n    uLOG2_10,\n    uLOG2_E,\n    uMAX_SD59x18,\n    uMAX_WHOLE_SD59x18,\n    uMIN_SD59x18,\n    uMIN_WHOLE_SD59x18,\n    UNIT,\n    uUNIT,\n    uUNIT_SQUARED,\n    ZERO\n} from \"./Constants.sol\";\nimport { wrap } from \"./Helpers.sol\";\nimport { SD59x18 } from \"./ValueType.sol\";\n\n/// @notice Calculates the absolute value of x.\n///\n/// @dev Requirements:\n/// - x > MIN_SD59x18.\n///\n/// @param x The SD59x18 number for which to calculate the absolute value.\n/// @return result The absolute value of x as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction abs(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    if (xInt == uMIN_SD59x18) {\n        revert Errors.PRBMath_SD59x18_Abs_MinSD59x18();\n    }\n    result = xInt < 0 ? wrap(-xInt) : x;\n}\n\n/// @notice Calculates the arithmetic average of x and y.\n///\n/// @dev Notes:\n/// - The result is rounded toward zero.\n///\n/// @param x The first operand as an SD59x18 number.\n/// @param y The second operand as an SD59x18 number.\n/// @return result The arithmetic average as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction avg(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    int256 yInt = y.unwrap();\n\n    unchecked {\n        // This operation is equivalent to `x / 2 +  y / 2`, and it can never overflow.\n        int256 sum = (xInt >> 1) + (yInt >> 1);\n\n        if (sum < 0) {\n            // If at least one of x and y is odd, add 1 to the result, because shifting negative numbers to the right\n            // rounds toward negative infinity. The right part is equivalent to `sum + (x % 2 == 1 || y % 2 == 1)`.\n            assembly (\"memory-safe\") {\n                result := add(sum, and(or(xInt, yInt), 1))\n            }\n        } else {\n            // Add 1 if both x and y are odd to account for the double 0.5 remainder truncated after shifting.\n            result = wrap(sum + (xInt & yInt & 1));\n        }\n    }\n}\n\n/// @notice Yields the smallest whole number greater than or equal to x.\n///\n/// @dev Optimized for fractional value inputs, because every whole value has (1e18 - 1) fractional counterparts.\n/// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n///\n/// Requirements:\n/// - x \u2264 MAX_WHOLE_SD59x18\n///\n/// @param x The SD59x18 number to ceil.\n/// @return result The smallest whole number greater than or equal to x, as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction ceil(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    if (xInt > uMAX_WHOLE_SD59x18) {\n        revert Errors.PRBMath_SD59x18_Ceil_Overflow(x);\n    }\n\n    int256 remainder = xInt % uUNIT;\n    if (remainder == 0) {\n        result = x;\n    } else {\n        unchecked {\n            // Solidity uses C fmod style, which returns a modulus with the same sign as x.\n            int256 resultInt = xInt - remainder;\n            if (xInt > 0) {\n                resultInt += uUNIT;\n            }\n            result = wrap(resultInt);\n        }\n    }\n}\n\n/// @notice Divides two SD59x18 numbers, returning a new SD59x18 number.\n///\n/// @dev This is an extension of {Common.mulDiv} for signed numbers, which works by computing the signs and the absolute\n/// values separately.\n///\n/// Notes:\n/// - Refer to the notes in {Common.mulDiv}.\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - Refer to the requirements in {Common.mulDiv}.\n/// - None of the inputs can be `MIN_SD59x18`.\n/// - The denominator must not be zero.\n/// - The result must fit in SD59x18.\n///\n/// @param x The numerator as an SD59x18 number.\n/// @param y The denominator as an SD59x18 number.\n/// @return result The quotient as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction div(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    int256 yInt = y.unwrap();\n    if (xInt == uMIN_SD59x18 || yInt == uMIN_SD59x18) {\n        revert Errors.PRBMath_SD59x18_Div_InputTooSmall();\n    }\n\n    // Get hold of the absolute values of x and y.\n    uint256 xAbs;\n    uint256 yAbs;\n    unchecked {\n        xAbs = xInt < 0 ? uint256(-xInt) : uint256(xInt);\n        yAbs = yInt < 0 ? uint256(-yInt) : uint256(yInt);\n    }\n\n    // Compute the absolute value (x*UNIT\u00f7y). The resulting value must fit in SD59x18.\n    uint256 resultAbs = Common.mulDiv(xAbs, uint256(uUNIT), yAbs);\n    if (resultAbs > uint256(uMAX_SD59x18)) {\n        revert Errors.PRBMath_SD59x18_Div_Overflow(x, y);\n    }\n\n    // Check if x and y have the same sign using two's complement representation. The left-most bit represents the sign (1 for\n    // negative, 0 for positive or zero).\n    bool sameSign = (xInt ^ yInt) > -1;\n\n    // If the inputs have the same sign, the result should be positive. Otherwise, it should be negative.\n    unchecked {\n        result = wrap(sameSign ? int256(resultAbs) : -int256(resultAbs));\n    }\n}\n\n/// @notice Calculates the natural exponent of x using the following formula:\n///\n/// $$\n/// e^x = 2^{x * log_2{e}}\n/// $$\n///\n/// @dev Notes:\n/// - Refer to the notes in {exp2}.\n///\n/// Requirements:\n/// - Refer to the requirements in {exp2}.\n/// - x < 133_084258667509499441.\n///\n/// @param x The exponent as an SD59x18 number.\n/// @return result The result as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction exp(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n\n    // Any input less than the threshold returns zero.\n    // This check also prevents an overflow for very small numbers.\n    if (xInt < uEXP_MIN_THRESHOLD) {\n        return ZERO;\n    }\n\n    // This check prevents values greater than 192e18 from being passed to {exp2}.\n    if (xInt > uEXP_MAX_INPUT) {\n        revert Errors.PRBMath_SD59x18_Exp_InputTooBig(x);\n    }\n\n    unchecked {\n        // Inline the fixed-point multiplication to save gas.\n        int256 doubleUnitProduct = xInt * uLOG2_E;\n        result = exp2(wrap(doubleUnitProduct / uUNIT));\n    }\n}\n\n/// @notice Calculates the binary exponent of x using the binary fraction method using the following formula:\n///\n/// $$\n/// 2^{-x} = \\frac{1}{2^x}\n/// $$\n///\n/// @dev See https://ethereum.stackexchange.com/q/79903/24693.\n///\n/// Notes:\n/// - If x < -59_794705707972522261, the result is zero.\n///\n/// Requirements:\n/// - x < 192e18.\n/// - The result must fit in SD59x18.\n///\n/// @param x The exponent as an SD59x18 number.\n/// @return result The result as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction exp2(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    if (xInt < 0) {\n        // The inverse of any number less than the threshold is truncated to zero.\n        if (xInt < uEXP2_MIN_THRESHOLD) {\n            return ZERO;\n        }\n\n        unchecked {\n            // Inline the fixed-point inversion to save gas.\n            result = wrap(uUNIT_SQUARED / exp2(wrap(-xInt)).unwrap());\n        }\n    } else {\n        // Numbers greater than or equal to 192e18 don't fit in the 192.64-bit format.\n        if (xInt > uEXP2_MAX_INPUT) {\n            revert Errors.PRBMath_SD59x18_Exp2_InputTooBig(x);\n        }\n\n        unchecked {\n            // Convert x to the 192.64-bit fixed-point format.\n            uint256 x_192x64 = uint256((xInt << 64) / uUNIT);\n\n            // It is safe to cast the result to int256 due to the checks above.\n            result = wrap(int256(Common.exp2(x_192x64)));\n        }\n    }\n}\n\n/// @notice Yields the greatest whole number less than or equal to x.\n///\n/// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional\n/// counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n///\n/// Requirements:\n/// - x \u2265 MIN_WHOLE_SD59x18\n///\n/// @param x The SD59x18 number to floor.\n/// @return result The greatest whole number less than or equal to x, as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction floor(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    if (xInt < uMIN_WHOLE_SD59x18) {\n        revert Errors.PRBMath_SD59x18_Floor_Underflow(x);\n    }\n\n    int256 remainder = xInt % uUNIT;\n    if (remainder == 0) {\n        result = x;\n    } else {\n        unchecked {\n            // Solidity uses C fmod style, which returns a modulus with the same sign as x.\n            int256 resultInt = xInt - remainder;\n            if (xInt < 0) {\n                resultInt -= uUNIT;\n            }\n            result = wrap(resultInt);\n        }\n    }\n}\n\n/// @notice Yields the excess beyond the floor of x for positive numbers and the part of the number to the right.\n/// of the radix point for negative numbers.\n/// @dev Based on the odd function definition. https://en.wikipedia.org/wiki/Fractional_part\n/// @param x The SD59x18 number to get the fractional part of.\n/// @return result The fractional part of x as an SD59x18 number.\nfunction frac(SD59x18 x) pure returns (SD59x18 result) {\n    result = wrap(x.unwrap() % uUNIT);\n}\n\n/// @notice Calculates the geometric mean of x and y, i.e. $\\sqrt{x * y}$.\n///\n/// @dev Notes:\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - x * y must fit in SD59x18.\n/// - x * y must not be negative, since complex numbers are not supported.\n///\n/// @param x The first operand as an SD59x18 number.\n/// @param y The second operand as an SD59x18 number.\n/// @return result The result as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction gm(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    int256 yInt = y.unwrap();\n    if (xInt == 0 || yInt == 0) {\n        return ZERO;\n    }\n\n    unchecked {\n        // Equivalent to `xy / x != y`. Checking for overflow this way is faster than letting Solidity do it.\n        int256 xyInt = xInt * yInt;\n        if (xyInt / xInt != yInt) {\n            revert Errors.PRBMath_SD59x18_Gm_Overflow(x, y);\n        }\n\n        // The product must not be negative, since complex numbers are not supported.\n        if (xyInt < 0) {\n            revert Errors.PRBMath_SD59x18_Gm_NegativeProduct(x, y);\n        }\n\n        // We don't need to multiply the result by `UNIT` here because the x*y product picked up a factor of `UNIT`\n        // during multiplication. See the comments in {Common.sqrt}.\n        uint256 resultUint = Common.sqrt(uint256(xyInt));\n        result = wrap(int256(resultUint));\n    }\n}\n\n/// @notice Calculates the inverse of x.\n///\n/// @dev Notes:\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - x must not be zero.\n///\n/// @param x The SD59x18 number for which to calculate the inverse.\n/// @return result The inverse as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction inv(SD59x18 x) pure returns (SD59x18 result) {\n    result = wrap(uUNIT_SQUARED / x.unwrap());\n}\n\n/// @notice Calculates the natural logarithm of x using the following formula:\n///\n/// $$\n/// ln{x} = log_2{x} / log_2{e}\n/// $$\n///\n/// @dev Notes:\n/// - Refer to the notes in {log2}.\n/// - The precision isn't sufficiently fine-grained to return exactly `UNIT` when the input is `E`.\n///\n/// Requirements:\n/// - Refer to the requirements in {log2}.\n///\n/// @param x The SD59x18 number for which to calculate the natural logarithm.\n/// @return result The natural logarithm as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction ln(SD59x18 x) pure returns (SD59x18 result) {\n    // Inline the fixed-point multiplication to save gas. This is overflow-safe because the maximum value that\n    // {log2} can return is ~195_205294292027477728.\n    result = wrap(log2(x).unwrap() * uUNIT / uLOG2_E);\n}\n\n/// @notice Calculates the common logarithm of x using the following formula:\n///\n/// $$\n/// log_{10}{x} = log_2{x} / log_2{10}\n/// $$\n///\n/// However, if x is an exact power of ten, a hard coded value is returned.\n///\n/// @dev Notes:\n/// - Refer to the notes in {log2}.\n///\n/// Requirements:\n/// - Refer to the requirements in {log2}.\n///\n/// @param x The SD59x18 number for which to calculate the common logarithm.\n/// @return result The common logarithm as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction log10(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    if (xInt < 0) {\n        revert Errors.PRBMath_SD59x18_Log_InputTooSmall(x);\n    }\n\n    // Note that the `mul` in this block is the standard multiplication operation, not {SD59x18.mul}.\n    // prettier-ignore\n    assembly (\"memory-safe\") {\n        switch x\n        case 1 { result := mul(uUNIT, sub(0, 18)) }\n        case 10 { result := mul(uUNIT, sub(1, 18)) }\n        case 100 { result := mul(uUNIT, sub(2, 18)) }\n        case 1000 { result := mul(uUNIT, sub(3, 18)) }\n        case 10000 { result := mul(uUNIT, sub(4, 18)) }\n        case 100000 { result := mul(uUNIT, sub(5, 18)) }\n        case 1000000 { result := mul(uUNIT, sub(6, 18)) }\n        case 10000000 { result := mul(uUNIT, sub(7, 18)) }\n        case 100000000 { result := mul(uUNIT, sub(8, 18)) }\n        case 1000000000 { result := mul(uUNIT, sub(9, 18)) }\n        case 10000000000 { result := mul(uUNIT, sub(10, 18)) }\n        case 100000000000 { result := mul(uUNIT, sub(11, 18)) }\n        case 1000000000000 { result := mul(uUNIT, sub(12, 18)) }\n        case 10000000000000 { result := mul(uUNIT, sub(13, 18)) }\n        case 100000000000000 { result := mul(uUNIT, sub(14, 18)) }\n        case 1000000000000000 { result := mul(uUNIT, sub(15, 18)) }\n        case 10000000000000000 { result := mul(uUNIT, sub(16, 18)) }\n        case 100000000000000000 { result := mul(uUNIT, sub(17, 18)) }\n        case 1000000000000000000 { result := 0 }\n        case 10000000000000000000 { result := uUNIT }\n        case 100000000000000000000 { result := mul(uUNIT, 2) }\n        case 1000000000000000000000 { result := mul(uUNIT, 3) }\n        case 10000000000000000000000 { result := mul(uUNIT, 4) }\n        case 100000000000000000000000 { result := mul(uUNIT, 5) }\n        case 1000000000000000000000000 { result := mul(uUNIT, 6) }\n        case 10000000000000000000000000 { result := mul(uUNIT, 7) }\n        case 100000000000000000000000000 { result := mul(uUNIT, 8) }\n        case 1000000000000000000000000000 { result := mul(uUNIT, 9) }\n        case 10000000000000000000000000000 { result := mul(uUNIT, 10) }\n        case 100000000000000000000000000000 { result := mul(uUNIT, 11) }\n        case 1000000000000000000000000000000 { result := mul(uUNIT, 12) }\n        case 10000000000000000000000000000000 { result := mul(uUNIT, 13) }\n        case 100000000000000000000000000000000 { result := mul(uUNIT, 14) }\n        case 1000000000000000000000000000000000 { result := mul(uUNIT, 15) }\n        case 10000000000000000000000000000000000 { result := mul(uUNIT, 16) }\n        case 100000000000000000000000000000000000 { result := mul(uUNIT, 17) }\n        case 1000000000000000000000000000000000000 { result := mul(uUNIT, 18) }\n        case 10000000000000000000000000000000000000 { result := mul(uUNIT, 19) }\n        case 100000000000000000000000000000000000000 { result := mul(uUNIT, 20) }\n        case 1000000000000000000000000000000000000000 { result := mul(uUNIT, 21) }\n        case 10000000000000000000000000000000000000000 { result := mul(uUNIT, 22) }\n        case 100000000000000000000000000000000000000000 { result := mul(uUNIT, 23) }\n        case 1000000000000000000000000000000000000000000 { result := mul(uUNIT, 24) }\n        case 10000000000000000000000000000000000000000000 { result := mul(uUNIT, 25) }\n        case 100000000000000000000000000000000000000000000 { result := mul(uUNIT, 26) }\n        case 1000000000000000000000000000000000000000000000 { result := mul(uUNIT, 27) }\n        case 10000000000000000000000000000000000000000000000 { result := mul(uUNIT, 28) }\n        case 100000000000000000000000000000000000000000000000 { result := mul(uUNIT, 29) }\n        case 1000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 30) }\n        case 10000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 31) }\n        case 100000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 32) }\n        case 1000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 33) }\n        case 10000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 34) }\n        case 100000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 35) }\n        case 1000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 36) }\n        case 10000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 37) }\n        case 100000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 38) }\n        case 1000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 39) }\n        case 10000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 40) }\n        case 100000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 41) }\n        case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 42) }\n        case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 43) }\n        case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 44) }\n        case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 45) }\n        case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 46) }\n        case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 47) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 48) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 49) }\n        case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 50) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 51) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 52) }\n        case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 53) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 54) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 55) }\n        case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 56) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 57) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 58) }\n        default { result := uMAX_SD59x18 }\n    }\n\n    if (result.unwrap() == uMAX_SD59x18) {\n        unchecked {\n            // Inline the fixed-point division to save gas.\n            result = wrap(log2(x).unwrap() * uUNIT / uLOG2_10);\n        }\n    }\n}\n\n/// @notice Calculates the binary logarithm of x using the iterative approximation algorithm:\n///\n/// $$\n/// log_2{x} = n + log_2{y}, \\text{ where } y = x*2^{-n}, \\ y \\in [1, 2)\n/// $$\n///\n/// For $0 \\leq x \\lt 1$, the input is inverted:\n///\n/// $$\n/// log_2{x} = -log_2{\\frac{1}{x}}\n/// $$\n///\n/// @dev See https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation.\n///\n/// Notes:\n/// - Due to the lossy precision of the iterative approximation, the results are not perfectly accurate to the last decimal.\n///\n/// Requirements:\n/// - x > 0\n///\n/// @param x The SD59x18 number for which to calculate the binary logarithm.\n/// @return result The binary logarithm as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction log2(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    if (xInt <= 0) {\n        revert Errors.PRBMath_SD59x18_Log_InputTooSmall(x);\n    }\n\n    unchecked {\n        int256 sign;\n        if (xInt >= uUNIT) {\n            sign = 1;\n        } else {\n            sign = -1;\n            // Inline the fixed-point inversion to save gas.\n            xInt = uUNIT_SQUARED / xInt;\n        }\n\n        // Calculate the integer part of the logarithm.\n        uint256 n = Common.msb(uint256(xInt / uUNIT));\n\n        // This is the integer part of the logarithm as an SD59x18 number. The operation can't overflow\n        // because n is at most 255, `UNIT` is 1e18, and the sign is either 1 or -1.\n        int256 resultInt = int256(n) * uUNIT;\n\n        // Calculate $y = x * 2^{-n}$.\n        int256 y = xInt >> n;\n\n        // If y is the unit number, the fractional part is zero.\n        if (y == uUNIT) {\n            return wrap(resultInt * sign);\n        }\n\n        // Calculate the fractional part via the iterative approximation.\n        // The `delta >>= 1` part is equivalent to `delta /= 2`, but shifting bits is more gas efficient.\n        int256 DOUBLE_UNIT = 2e18;\n        for (int256 delta = uHALF_UNIT; delta > 0; delta >>= 1) {\n            y = (y * y) / uUNIT;\n\n            // Is y^2 >= 2e18 and so in the range [2e18, 4e18)?\n            if (y >= DOUBLE_UNIT) {\n                // Add the 2^{-m} factor to the logarithm.\n                resultInt = resultInt + delta;\n\n                // Halve y, which corresponds to z/2 in the Wikipedia article.\n                y >>= 1;\n            }\n        }\n        resultInt *= sign;\n        result = wrap(resultInt);\n    }\n}\n\n/// @notice Multiplies two SD59x18 numbers together, returning a new SD59x18 number.\n///\n/// @dev Notes:\n/// - Refer to the notes in {Common.mulDiv18}.\n///\n/// Requirements:\n/// - Refer to the requirements in {Common.mulDiv18}.\n/// - None of the inputs can be `MIN_SD59x18`.\n/// - The result must fit in SD59x18.\n///\n/// @param x The multiplicand as an SD59x18 number.\n/// @param y The multiplier as an SD59x18 number.\n/// @return result The product as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction mul(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    int256 yInt = y.unwrap();\n    if (xInt == uMIN_SD59x18 || yInt == uMIN_SD59x18) {\n        revert Errors.PRBMath_SD59x18_Mul_InputTooSmall();\n    }\n\n    // Get hold of the absolute values of x and y.\n    uint256 xAbs;\n    uint256 yAbs;\n    unchecked {\n        xAbs = xInt < 0 ? uint256(-xInt) : uint256(xInt);\n        yAbs = yInt < 0 ? uint256(-yInt) : uint256(yInt);\n    }\n\n    // Compute the absolute value (x*y\u00f7UNIT). The resulting value must fit in SD59x18.\n    uint256 resultAbs = Common.mulDiv18(xAbs, yAbs);\n    if (resultAbs > uint256(uMAX_SD59x18)) {\n        revert Errors.PRBMath_SD59x18_Mul_Overflow(x, y);\n    }\n\n    // Check if x and y have the same sign using two's complement representation. The left-most bit represents the sign (1 for\n    // negative, 0 for positive or zero).\n    bool sameSign = (xInt ^ yInt) > -1;\n\n    // If the inputs have the same sign, the result should be positive. Otherwise, it should be negative.\n    unchecked {\n        result = wrap(sameSign ? int256(resultAbs) : -int256(resultAbs));\n    }\n}\n\n/// @notice Raises x to the power of y using the following formula:\n///\n/// $$\n/// x^y = 2^{log_2{x} * y}\n/// $$\n///\n/// @dev Notes:\n/// - Refer to the notes in {exp2}, {log2}, and {mul}.\n/// - Returns `UNIT` for 0^0.\n///\n/// Requirements:\n/// - Refer to the requirements in {exp2}, {log2}, and {mul}.\n///\n/// @param x The base as an SD59x18 number.\n/// @param y Exponent to raise x to, as an SD59x18 number\n/// @return result x raised to power y, as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction pow(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    int256 yInt = y.unwrap();\n\n    // If both x and y are zero, the result is `UNIT`. If just x is zero, the result is always zero.\n    if (xInt == 0) {\n        return yInt == 0 ? UNIT : ZERO;\n    }\n    // If x is `UNIT`, the result is always `UNIT`.\n    else if (xInt == uUNIT) {\n        return UNIT;\n    }\n\n    // If y is zero, the result is always `UNIT`.\n    if (yInt == 0) {\n        return UNIT;\n    }\n    // If y is `UNIT`, the result is always x.\n    else if (yInt == uUNIT) {\n        return x;\n    }\n\n    // Calculate the result using the formula.\n    result = exp2(mul(log2(x), y));\n}\n\n/// @notice Raises x (an SD59x18 number) to the power y (an unsigned basic integer) using the well-known\n/// algorithm \"exponentiation by squaring\".\n///\n/// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring.\n///\n/// Notes:\n/// - Refer to the notes in {Common.mulDiv18}.\n/// - Returns `UNIT` for 0^0.\n///\n/// Requirements:\n/// - Refer to the requirements in {abs} and {Common.mulDiv18}.\n/// - The result must fit in SD59x18.\n///\n/// @param x The base as an SD59x18 number.\n/// @param y The exponent as a uint256.\n/// @return result The result as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction powu(SD59x18 x, uint256 y) pure returns (SD59x18 result) {\n    uint256 xAbs = uint256(abs(x).unwrap());\n\n    // Calculate the first iteration of the loop in advance.\n    uint256 resultAbs = y & 1 > 0 ? xAbs : uint256(uUNIT);\n\n    // Equivalent to `for(y /= 2; y > 0; y /= 2)`.\n    uint256 yAux = y;\n    for (yAux >>= 1; yAux > 0; yAux >>= 1) {\n        xAbs = Common.mulDiv18(xAbs, xAbs);\n\n        // Equivalent to `y % 2 == 1`.\n        if (yAux & 1 > 0) {\n            resultAbs = Common.mulDiv18(resultAbs, xAbs);\n        }\n    }\n\n    // The result must fit in SD59x18.\n    if (resultAbs > uint256(uMAX_SD59x18)) {\n        revert Errors.PRBMath_SD59x18_Powu_Overflow(x, y);\n    }\n\n    unchecked {\n        // Is the base negative and the exponent odd? If yes, the result should be negative.\n        int256 resultInt = int256(resultAbs);\n        bool isNegative = x.unwrap() < 0 && y & 1 == 1;\n        if (isNegative) {\n            resultInt = -resultInt;\n        }\n        result = wrap(resultInt);\n    }\n}\n\n/// @notice Calculates the square root of x using the Babylonian method.\n///\n/// @dev See https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n///\n/// Notes:\n/// - Only the positive root is returned.\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - x \u2265 0, since complex numbers are not supported.\n/// - x \u2264 MAX_SD59x18 / UNIT\n///\n/// @param x The SD59x18 number for which to calculate the square root.\n/// @return result The result as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction sqrt(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    if (xInt < 0) {\n        revert Errors.PRBMath_SD59x18_Sqrt_NegativeInput(x);\n    }\n    if (xInt > uMAX_SD59x18 / uUNIT) {\n        revert Errors.PRBMath_SD59x18_Sqrt_Overflow(x);\n    }\n\n    unchecked {\n        // Multiply x by `UNIT` to account for the factor of `UNIT` picked up when multiplying two SD59x18 numbers.\n        // In this case, the two numbers are both the square root.\n        uint256 resultUint = Common.sqrt(uint256(xInt * uUNIT));\n        result = wrap(int256(resultUint));\n    }\n}\n"}, "@prb/math/src/sd59x18/ValueType.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"./Casting.sol\" as Casting;\nimport \"./Helpers.sol\" as Helpers;\nimport \"./Math.sol\" as Math;\n\n/// @notice The signed 59.18-decimal fixed-point number representation, which can have up to 59 digits and up to 18\n/// decimals. The values of this are bound by the minimum and the maximum values permitted by the underlying Solidity\n/// type int256.\ntype SD59x18 is int256;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CASTING\n//////////////////////////////////////////////////////////////////////////*/\n\nusing {\n    Casting.intoInt256,\n    Casting.intoSD1x18,\n    Casting.intoSD21x18,\n    Casting.intoUD2x18,\n    Casting.intoUD21x18,\n    Casting.intoUD60x18,\n    Casting.intoUint256,\n    Casting.intoUint128,\n    Casting.intoUint40,\n    Casting.unwrap\n} for SD59x18 global;\n\n/*//////////////////////////////////////////////////////////////////////////\n                            MATHEMATICAL FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\nusing {\n    Math.abs,\n    Math.avg,\n    Math.ceil,\n    Math.div,\n    Math.exp,\n    Math.exp2,\n    Math.floor,\n    Math.frac,\n    Math.gm,\n    Math.inv,\n    Math.log10,\n    Math.log2,\n    Math.ln,\n    Math.mul,\n    Math.pow,\n    Math.powu,\n    Math.sqrt\n} for SD59x18 global;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                HELPER FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\nusing {\n    Helpers.add,\n    Helpers.and,\n    Helpers.eq,\n    Helpers.gt,\n    Helpers.gte,\n    Helpers.isZero,\n    Helpers.lshift,\n    Helpers.lt,\n    Helpers.lte,\n    Helpers.mod,\n    Helpers.neq,\n    Helpers.not,\n    Helpers.or,\n    Helpers.rshift,\n    Helpers.sub,\n    Helpers.uncheckedAdd,\n    Helpers.uncheckedSub,\n    Helpers.uncheckedUnary,\n    Helpers.xor\n} for SD59x18 global;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    OPERATORS\n//////////////////////////////////////////////////////////////////////////*/\n\n// The global \"using for\" directive makes it possible to use these operators on the SD59x18 type.\nusing {\n    Helpers.add as +,\n    Helpers.and2 as &,\n    Math.div as /,\n    Helpers.eq as ==,\n    Helpers.gt as >,\n    Helpers.gte as >=,\n    Helpers.lt as <,\n    Helpers.lte as <=,\n    Helpers.mod as %,\n    Math.mul as *,\n    Helpers.neq as !=,\n    Helpers.not as ~,\n    Helpers.or as |,\n    Helpers.sub as -,\n    Helpers.unary as -,\n    Helpers.xor as ^\n} for SD59x18 global;\n"}, "@prb/math/src/ud21x18/Casting.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"../Common.sol\" as Common;\nimport \"./Errors.sol\" as Errors;\nimport { SD59x18 } from \"../sd59x18/ValueType.sol\";\nimport { UD60x18 } from \"../ud60x18/ValueType.sol\";\nimport { UD21x18 } from \"./ValueType.sol\";\n\n/// @notice Casts a UD21x18 number into SD59x18.\n/// @dev There is no overflow check because UD21x18 \u2286 SD59x18.\nfunction intoSD59x18(UD21x18 x) pure returns (SD59x18 result) {\n    result = SD59x18.wrap(int256(uint256(UD21x18.unwrap(x))));\n}\n\n/// @notice Casts a UD21x18 number into UD60x18.\n/// @dev There is no overflow check because UD21x18 \u2286 UD60x18.\nfunction intoUD60x18(UD21x18 x) pure returns (UD60x18 result) {\n    result = UD60x18.wrap(UD21x18.unwrap(x));\n}\n\n/// @notice Casts a UD21x18 number into uint128.\n/// @dev This is basically an alias for {unwrap}.\nfunction intoUint128(UD21x18 x) pure returns (uint128 result) {\n    result = UD21x18.unwrap(x);\n}\n\n/// @notice Casts a UD21x18 number into uint256.\n/// @dev There is no overflow check because UD21x18 \u2286 uint256.\nfunction intoUint256(UD21x18 x) pure returns (uint256 result) {\n    result = uint256(UD21x18.unwrap(x));\n}\n\n/// @notice Casts a UD21x18 number into uint40.\n/// @dev Requirements:\n/// - x \u2264 MAX_UINT40\nfunction intoUint40(UD21x18 x) pure returns (uint40 result) {\n    uint128 xUint = UD21x18.unwrap(x);\n    if (xUint > uint128(Common.MAX_UINT40)) {\n        revert Errors.PRBMath_UD21x18_IntoUint40_Overflow(x);\n    }\n    result = uint40(xUint);\n}\n\n/// @notice Alias for {wrap}.\nfunction ud21x18(uint128 x) pure returns (UD21x18 result) {\n    result = UD21x18.wrap(x);\n}\n\n/// @notice Unwrap a UD21x18 number into uint128.\nfunction unwrap(UD21x18 x) pure returns (uint128 result) {\n    result = UD21x18.unwrap(x);\n}\n\n/// @notice Wraps a uint128 number into UD21x18.\nfunction wrap(uint128 x) pure returns (UD21x18 result) {\n    result = UD21x18.wrap(x);\n}\n"}, "@prb/math/src/ud21x18/Constants.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { UD21x18 } from \"./ValueType.sol\";\n\n/// @dev Euler's number as a UD21x18 number.\nUD21x18 constant E = UD21x18.wrap(2_718281828459045235);\n\n/// @dev The maximum value a UD21x18 number can have.\nuint128 constant uMAX_UD21x18 = 340282366920938463463_374607431768211455;\nUD21x18 constant MAX_UD21x18 = UD21x18.wrap(uMAX_UD21x18);\n\n/// @dev PI as a UD21x18 number.\nUD21x18 constant PI = UD21x18.wrap(3_141592653589793238);\n\n/// @dev The unit number, which gives the decimal precision of UD21x18.\nuint256 constant uUNIT = 1e18;\nUD21x18 constant UNIT = UD21x18.wrap(1e18);\n"}, "@prb/math/src/ud21x18/Errors.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { UD21x18 } from \"./ValueType.sol\";\n\n/// @notice Thrown when trying to cast a UD21x18 number that doesn't fit in uint40.\nerror PRBMath_UD21x18_IntoUint40_Overflow(UD21x18 x);\n"}, "@prb/math/src/ud21x18/ValueType.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"./Casting.sol\" as Casting;\n\n/// @notice The unsigned 21.18-decimal fixed-point number representation, which can have up to 21 digits and up to 18\n/// decimals. The values of this are bound by the minimum and the maximum values permitted by the underlying Solidity\n/// type uint128. This is useful when end users want to use uint128 to save gas, e.g. with tight variable packing in contract\n/// storage.\ntype UD21x18 is uint128;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CASTING\n//////////////////////////////////////////////////////////////////////////*/\n\nusing {\n    Casting.intoSD59x18,\n    Casting.intoUD60x18,\n    Casting.intoUint128,\n    Casting.intoUint256,\n    Casting.intoUint40,\n    Casting.unwrap\n} for UD21x18 global;\n"}, "@prb/math/src/ud2x18/Casting.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"../Common.sol\" as Common;\nimport \"./Errors.sol\" as Errors;\nimport { SD59x18 } from \"../sd59x18/ValueType.sol\";\nimport { UD60x18 } from \"../ud60x18/ValueType.sol\";\nimport { UD2x18 } from \"./ValueType.sol\";\n\n/// @notice Casts a UD2x18 number into SD59x18.\n/// @dev There is no overflow check because UD2x18 \u2286 SD59x18.\nfunction intoSD59x18(UD2x18 x) pure returns (SD59x18 result) {\n    result = SD59x18.wrap(int256(uint256(UD2x18.unwrap(x))));\n}\n\n/// @notice Casts a UD2x18 number into UD60x18.\n/// @dev There is no overflow check because UD2x18 \u2286 UD60x18.\nfunction intoUD60x18(UD2x18 x) pure returns (UD60x18 result) {\n    result = UD60x18.wrap(UD2x18.unwrap(x));\n}\n\n/// @notice Casts a UD2x18 number into uint128.\n/// @dev There is no overflow check because UD2x18 \u2286 uint128.\nfunction intoUint128(UD2x18 x) pure returns (uint128 result) {\n    result = uint128(UD2x18.unwrap(x));\n}\n\n/// @notice Casts a UD2x18 number into uint256.\n/// @dev There is no overflow check because UD2x18 \u2286 uint256.\nfunction intoUint256(UD2x18 x) pure returns (uint256 result) {\n    result = uint256(UD2x18.unwrap(x));\n}\n\n/// @notice Casts a UD2x18 number into uint40.\n/// @dev Requirements:\n/// - x \u2264 MAX_UINT40\nfunction intoUint40(UD2x18 x) pure returns (uint40 result) {\n    uint64 xUint = UD2x18.unwrap(x);\n    if (xUint > uint64(Common.MAX_UINT40)) {\n        revert Errors.PRBMath_UD2x18_IntoUint40_Overflow(x);\n    }\n    result = uint40(xUint);\n}\n\n/// @notice Alias for {wrap}.\nfunction ud2x18(uint64 x) pure returns (UD2x18 result) {\n    result = UD2x18.wrap(x);\n}\n\n/// @notice Unwrap a UD2x18 number into uint64.\nfunction unwrap(UD2x18 x) pure returns (uint64 result) {\n    result = UD2x18.unwrap(x);\n}\n\n/// @notice Wraps a uint64 number into UD2x18.\nfunction wrap(uint64 x) pure returns (UD2x18 result) {\n    result = UD2x18.wrap(x);\n}\n"}, "@prb/math/src/ud2x18/Constants.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { UD2x18 } from \"./ValueType.sol\";\n\n/// @dev Euler's number as a UD2x18 number.\nUD2x18 constant E = UD2x18.wrap(2_718281828459045235);\n\n/// @dev The maximum value a UD2x18 number can have.\nuint64 constant uMAX_UD2x18 = 18_446744073709551615;\nUD2x18 constant MAX_UD2x18 = UD2x18.wrap(uMAX_UD2x18);\n\n/// @dev PI as a UD2x18 number.\nUD2x18 constant PI = UD2x18.wrap(3_141592653589793238);\n\n/// @dev The unit number, which gives the decimal precision of UD2x18.\nUD2x18 constant UNIT = UD2x18.wrap(1e18);\nuint64 constant uUNIT = 1e18;\n"}, "@prb/math/src/ud2x18/Errors.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { UD2x18 } from \"./ValueType.sol\";\n\n/// @notice Thrown when trying to cast a UD2x18 number that doesn't fit in uint40.\nerror PRBMath_UD2x18_IntoUint40_Overflow(UD2x18 x);\n"}, "@prb/math/src/ud2x18/ValueType.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"./Casting.sol\" as Casting;\n\n/// @notice The unsigned 2.18-decimal fixed-point number representation, which can have up to 2 digits and up to 18\n/// decimals. The values of this are bound by the minimum and the maximum values permitted by the underlying Solidity\n/// type uint64. This is useful when end users want to use uint64 to save gas, e.g. with tight variable packing in contract\n/// storage.\ntype UD2x18 is uint64;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CASTING\n//////////////////////////////////////////////////////////////////////////*/\n\nusing {\n    Casting.intoSD59x18,\n    Casting.intoUD60x18,\n    Casting.intoUint128,\n    Casting.intoUint256,\n    Casting.intoUint40,\n    Casting.unwrap\n} for UD2x18 global;\n"}, "@prb/math/src/UD60x18.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/*\n\n\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557  \u2588\u2588\u2557\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\n\u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u255a\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\n\u2588\u2588\u2551     \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u255a\u2550\u255d \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551  \u2588\u2588\u2551\n\u255a\u2550\u255d     \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d     \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u255d  \u255a\u2550\u255d\n\n\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557  \u2588\u2588\u2557 \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557\n\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u2588\u2588\u2554\u2550\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2557\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\n\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2554\u255d \u255a\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\n\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u2588\u2588\u2554\u2588\u2588\u2557  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\n\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2554\u255d \u2588\u2588\u2557 \u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\n \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u255d\n\n*/\n\nimport \"./ud60x18/Casting.sol\";\nimport \"./ud60x18/Constants.sol\";\nimport \"./ud60x18/Conversions.sol\";\nimport \"./ud60x18/Errors.sol\";\nimport \"./ud60x18/Helpers.sol\";\nimport \"./ud60x18/Math.sol\";\nimport \"./ud60x18/ValueType.sol\";\n"}, "@prb/math/src/ud60x18/Casting.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"./Errors.sol\" as CastingErrors;\nimport { MAX_UINT128, MAX_UINT40 } from \"../Common.sol\";\nimport { uMAX_SD1x18 } from \"../sd1x18/Constants.sol\";\nimport { SD1x18 } from \"../sd1x18/ValueType.sol\";\nimport { uMAX_SD21x18 } from \"../sd21x18/Constants.sol\";\nimport { SD21x18 } from \"../sd21x18/ValueType.sol\";\nimport { uMAX_SD59x18 } from \"../sd59x18/Constants.sol\";\nimport { SD59x18 } from \"../sd59x18/ValueType.sol\";\nimport { uMAX_UD2x18 } from \"../ud2x18/Constants.sol\";\nimport { uMAX_UD21x18 } from \"../ud21x18/Constants.sol\";\nimport { UD2x18 } from \"../ud2x18/ValueType.sol\";\nimport { UD21x18 } from \"../ud21x18/ValueType.sol\";\nimport { UD60x18 } from \"./ValueType.sol\";\n\n/// @notice Casts a UD60x18 number into SD1x18.\n/// @dev Requirements:\n/// - x \u2264 uMAX_SD1x18\nfunction intoSD1x18(UD60x18 x) pure returns (SD1x18 result) {\n    uint256 xUint = UD60x18.unwrap(x);\n    if (xUint > uint256(int256(uMAX_SD1x18))) {\n        revert CastingErrors.PRBMath_UD60x18_IntoSD1x18_Overflow(x);\n    }\n    result = SD1x18.wrap(int64(uint64(xUint)));\n}\n\n/// @notice Casts a UD60x18 number into SD21x18.\n/// @dev Requirements:\n/// - x \u2264 uMAX_SD21x18\nfunction intoSD21x18(UD60x18 x) pure returns (SD21x18 result) {\n    uint256 xUint = UD60x18.unwrap(x);\n    if (xUint > uint256(int256(uMAX_SD21x18))) {\n        revert CastingErrors.PRBMath_UD60x18_IntoSD21x18_Overflow(x);\n    }\n    result = SD21x18.wrap(int128(uint128(xUint)));\n}\n\n/// @notice Casts a UD60x18 number into UD2x18.\n/// @dev Requirements:\n/// - x \u2264 uMAX_UD2x18\nfunction intoUD2x18(UD60x18 x) pure returns (UD2x18 result) {\n    uint256 xUint = UD60x18.unwrap(x);\n    if (xUint > uMAX_UD2x18) {\n        revert CastingErrors.PRBMath_UD60x18_IntoUD2x18_Overflow(x);\n    }\n    result = UD2x18.wrap(uint64(xUint));\n}\n\n/// @notice Casts a UD60x18 number into UD21x18.\n/// @dev Requirements:\n/// - x \u2264 uMAX_UD21x18\nfunction intoUD21x18(UD60x18 x) pure returns (UD21x18 result) {\n    uint256 xUint = UD60x18.unwrap(x);\n    if (xUint > uMAX_UD21x18) {\n        revert CastingErrors.PRBMath_UD60x18_IntoUD21x18_Overflow(x);\n    }\n    result = UD21x18.wrap(uint128(xUint));\n}\n\n/// @notice Casts a UD60x18 number into SD59x18.\n/// @dev Requirements:\n/// - x \u2264 uMAX_SD59x18\nfunction intoSD59x18(UD60x18 x) pure returns (SD59x18 result) {\n    uint256 xUint = UD60x18.unwrap(x);\n    if (xUint > uint256(uMAX_SD59x18)) {\n        revert CastingErrors.PRBMath_UD60x18_IntoSD59x18_Overflow(x);\n    }\n    result = SD59x18.wrap(int256(xUint));\n}\n\n/// @notice Casts a UD60x18 number into uint128.\n/// @dev This is basically an alias for {unwrap}.\nfunction intoUint256(UD60x18 x) pure returns (uint256 result) {\n    result = UD60x18.unwrap(x);\n}\n\n/// @notice Casts a UD60x18 number into uint128.\n/// @dev Requirements:\n/// - x \u2264 MAX_UINT128\nfunction intoUint128(UD60x18 x) pure returns (uint128 result) {\n    uint256 xUint = UD60x18.unwrap(x);\n    if (xUint > MAX_UINT128) {\n        revert CastingErrors.PRBMath_UD60x18_IntoUint128_Overflow(x);\n    }\n    result = uint128(xUint);\n}\n\n/// @notice Casts a UD60x18 number into uint40.\n/// @dev Requirements:\n/// - x \u2264 MAX_UINT40\nfunction intoUint40(UD60x18 x) pure returns (uint40 result) {\n    uint256 xUint = UD60x18.unwrap(x);\n    if (xUint > MAX_UINT40) {\n        revert CastingErrors.PRBMath_UD60x18_IntoUint40_Overflow(x);\n    }\n    result = uint40(xUint);\n}\n\n/// @notice Alias for {wrap}.\nfunction ud(uint256 x) pure returns (UD60x18 result) {\n    result = UD60x18.wrap(x);\n}\n\n/// @notice Alias for {wrap}.\nfunction ud60x18(uint256 x) pure returns (UD60x18 result) {\n    result = UD60x18.wrap(x);\n}\n\n/// @notice Unwraps a UD60x18 number into uint256.\nfunction unwrap(UD60x18 x) pure returns (uint256 result) {\n    result = UD60x18.unwrap(x);\n}\n\n/// @notice Wraps a uint256 number into the UD60x18 value type.\nfunction wrap(uint256 x) pure returns (UD60x18 result) {\n    result = UD60x18.wrap(x);\n}\n"}, "@prb/math/src/ud60x18/Constants.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { UD60x18 } from \"./ValueType.sol\";\n\n// NOTICE: the \"u\" prefix stands for \"unwrapped\".\n\n/// @dev Euler's number as a UD60x18 number.\nUD60x18 constant E = UD60x18.wrap(2_718281828459045235);\n\n/// @dev The maximum input permitted in {exp}.\nuint256 constant uEXP_MAX_INPUT = 133_084258667509499440;\nUD60x18 constant EXP_MAX_INPUT = UD60x18.wrap(uEXP_MAX_INPUT);\n\n/// @dev The maximum input permitted in {exp2}.\nuint256 constant uEXP2_MAX_INPUT = 192e18 - 1;\nUD60x18 constant EXP2_MAX_INPUT = UD60x18.wrap(uEXP2_MAX_INPUT);\n\n/// @dev Half the UNIT number.\nuint256 constant uHALF_UNIT = 0.5e18;\nUD60x18 constant HALF_UNIT = UD60x18.wrap(uHALF_UNIT);\n\n/// @dev $log_2(10)$ as a UD60x18 number.\nuint256 constant uLOG2_10 = 3_321928094887362347;\nUD60x18 constant LOG2_10 = UD60x18.wrap(uLOG2_10);\n\n/// @dev $log_2(e)$ as a UD60x18 number.\nuint256 constant uLOG2_E = 1_442695040888963407;\nUD60x18 constant LOG2_E = UD60x18.wrap(uLOG2_E);\n\n/// @dev The maximum value a UD60x18 number can have.\nuint256 constant uMAX_UD60x18 = 115792089237316195423570985008687907853269984665640564039457_584007913129639935;\nUD60x18 constant MAX_UD60x18 = UD60x18.wrap(uMAX_UD60x18);\n\n/// @dev The maximum whole value a UD60x18 number can have.\nuint256 constant uMAX_WHOLE_UD60x18 = 115792089237316195423570985008687907853269984665640564039457_000000000000000000;\nUD60x18 constant MAX_WHOLE_UD60x18 = UD60x18.wrap(uMAX_WHOLE_UD60x18);\n\n/// @dev PI as a UD60x18 number.\nUD60x18 constant PI = UD60x18.wrap(3_141592653589793238);\n\n/// @dev The unit number, which gives the decimal precision of UD60x18.\nuint256 constant uUNIT = 1e18;\nUD60x18 constant UNIT = UD60x18.wrap(uUNIT);\n\n/// @dev The unit number squared.\nuint256 constant uUNIT_SQUARED = 1e36;\nUD60x18 constant UNIT_SQUARED = UD60x18.wrap(uUNIT_SQUARED);\n\n/// @dev Zero as a UD60x18 number.\nUD60x18 constant ZERO = UD60x18.wrap(0);\n"}, "@prb/math/src/ud60x18/Conversions.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { uMAX_UD60x18, uUNIT } from \"./Constants.sol\";\nimport { PRBMath_UD60x18_Convert_Overflow } from \"./Errors.sol\";\nimport { UD60x18 } from \"./ValueType.sol\";\n\n/// @notice Converts a UD60x18 number to a simple integer by dividing it by `UNIT`.\n/// @dev The result is rounded toward zero.\n/// @param x The UD60x18 number to convert.\n/// @return result The same number in basic integer form.\nfunction convert(UD60x18 x) pure returns (uint256 result) {\n    result = UD60x18.unwrap(x) / uUNIT;\n}\n\n/// @notice Converts a simple integer to UD60x18 by multiplying it by `UNIT`.\n///\n/// @dev Requirements:\n/// - x \u2264 MAX_UD60x18 / UNIT\n///\n/// @param x The basic integer to convert.\n/// @return result The same number converted to UD60x18.\nfunction convert(uint256 x) pure returns (UD60x18 result) {\n    if (x > uMAX_UD60x18 / uUNIT) {\n        revert PRBMath_UD60x18_Convert_Overflow(x);\n    }\n    unchecked {\n        result = UD60x18.wrap(x * uUNIT);\n    }\n}\n"}, "@prb/math/src/ud60x18/Errors.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { UD60x18 } from \"./ValueType.sol\";\n\n/// @notice Thrown when ceiling a number overflows UD60x18.\nerror PRBMath_UD60x18_Ceil_Overflow(UD60x18 x);\n\n/// @notice Thrown when converting a basic integer to the fixed-point format overflows UD60x18.\nerror PRBMath_UD60x18_Convert_Overflow(uint256 x);\n\n/// @notice Thrown when taking the natural exponent of a base greater than 133_084258667509499441.\nerror PRBMath_UD60x18_Exp_InputTooBig(UD60x18 x);\n\n/// @notice Thrown when taking the binary exponent of a base greater than 192e18.\nerror PRBMath_UD60x18_Exp2_InputTooBig(UD60x18 x);\n\n/// @notice Thrown when taking the geometric mean of two numbers and multiplying them overflows UD60x18.\nerror PRBMath_UD60x18_Gm_Overflow(UD60x18 x, UD60x18 y);\n\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in SD1x18.\nerror PRBMath_UD60x18_IntoSD1x18_Overflow(UD60x18 x);\n\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in SD21x18.\nerror PRBMath_UD60x18_IntoSD21x18_Overflow(UD60x18 x);\n\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in SD59x18.\nerror PRBMath_UD60x18_IntoSD59x18_Overflow(UD60x18 x);\n\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in UD2x18.\nerror PRBMath_UD60x18_IntoUD2x18_Overflow(UD60x18 x);\n\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in UD21x18.\nerror PRBMath_UD60x18_IntoUD21x18_Overflow(UD60x18 x);\n\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in uint128.\nerror PRBMath_UD60x18_IntoUint128_Overflow(UD60x18 x);\n\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in uint40.\nerror PRBMath_UD60x18_IntoUint40_Overflow(UD60x18 x);\n\n/// @notice Thrown when taking the logarithm of a number less than UNIT.\nerror PRBMath_UD60x18_Log_InputTooSmall(UD60x18 x);\n\n/// @notice Thrown when calculating the square root overflows UD60x18.\nerror PRBMath_UD60x18_Sqrt_Overflow(UD60x18 x);\n"}, "@prb/math/src/ud60x18/Helpers.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { wrap } from \"./Casting.sol\";\nimport { UD60x18 } from \"./ValueType.sol\";\n\n/// @notice Implements the checked addition operation (+) in the UD60x18 type.\nfunction add(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    result = wrap(x.unwrap() + y.unwrap());\n}\n\n/// @notice Implements the AND (&) bitwise operation in the UD60x18 type.\nfunction and(UD60x18 x, uint256 bits) pure returns (UD60x18 result) {\n    result = wrap(x.unwrap() & bits);\n}\n\n/// @notice Implements the AND (&) bitwise operation in the UD60x18 type.\nfunction and2(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    result = wrap(x.unwrap() & y.unwrap());\n}\n\n/// @notice Implements the equal operation (==) in the UD60x18 type.\nfunction eq(UD60x18 x, UD60x18 y) pure returns (bool result) {\n    result = x.unwrap() == y.unwrap();\n}\n\n/// @notice Implements the greater than operation (>) in the UD60x18 type.\nfunction gt(UD60x18 x, UD60x18 y) pure returns (bool result) {\n    result = x.unwrap() > y.unwrap();\n}\n\n/// @notice Implements the greater than or equal to operation (>=) in the UD60x18 type.\nfunction gte(UD60x18 x, UD60x18 y) pure returns (bool result) {\n    result = x.unwrap() >= y.unwrap();\n}\n\n/// @notice Implements a zero comparison check function in the UD60x18 type.\nfunction isZero(UD60x18 x) pure returns (bool result) {\n    // This wouldn't work if x could be negative.\n    result = x.unwrap() == 0;\n}\n\n/// @notice Implements the left shift operation (<<) in the UD60x18 type.\nfunction lshift(UD60x18 x, uint256 bits) pure returns (UD60x18 result) {\n    result = wrap(x.unwrap() << bits);\n}\n\n/// @notice Implements the lower than operation (<) in the UD60x18 type.\nfunction lt(UD60x18 x, UD60x18 y) pure returns (bool result) {\n    result = x.unwrap() < y.unwrap();\n}\n\n/// @notice Implements the lower than or equal to operation (<=) in the UD60x18 type.\nfunction lte(UD60x18 x, UD60x18 y) pure returns (bool result) {\n    result = x.unwrap() <= y.unwrap();\n}\n\n/// @notice Implements the checked modulo operation (%) in the UD60x18 type.\nfunction mod(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    result = wrap(x.unwrap() % y.unwrap());\n}\n\n/// @notice Implements the not equal operation (!=) in the UD60x18 type.\nfunction neq(UD60x18 x, UD60x18 y) pure returns (bool result) {\n    result = x.unwrap() != y.unwrap();\n}\n\n/// @notice Implements the NOT (~) bitwise operation in the UD60x18 type.\nfunction not(UD60x18 x) pure returns (UD60x18 result) {\n    result = wrap(~x.unwrap());\n}\n\n/// @notice Implements the OR (|) bitwise operation in the UD60x18 type.\nfunction or(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    result = wrap(x.unwrap() | y.unwrap());\n}\n\n/// @notice Implements the right shift operation (>>) in the UD60x18 type.\nfunction rshift(UD60x18 x, uint256 bits) pure returns (UD60x18 result) {\n    result = wrap(x.unwrap() >> bits);\n}\n\n/// @notice Implements the checked subtraction operation (-) in the UD60x18 type.\nfunction sub(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    result = wrap(x.unwrap() - y.unwrap());\n}\n\n/// @notice Implements the unchecked addition operation (+) in the UD60x18 type.\nfunction uncheckedAdd(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    unchecked {\n        result = wrap(x.unwrap() + y.unwrap());\n    }\n}\n\n/// @notice Implements the unchecked subtraction operation (-) in the UD60x18 type.\nfunction uncheckedSub(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    unchecked {\n        result = wrap(x.unwrap() - y.unwrap());\n    }\n}\n\n/// @notice Implements the XOR (^) bitwise operation in the UD60x18 type.\nfunction xor(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    result = wrap(x.unwrap() ^ y.unwrap());\n}\n"}, "@prb/math/src/ud60x18/Math.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"../Common.sol\" as Common;\nimport \"./Errors.sol\" as Errors;\nimport { wrap } from \"./Casting.sol\";\nimport {\n    uEXP_MAX_INPUT,\n    uEXP2_MAX_INPUT,\n    uHALF_UNIT,\n    uLOG2_10,\n    uLOG2_E,\n    uMAX_UD60x18,\n    uMAX_WHOLE_UD60x18,\n    UNIT,\n    uUNIT,\n    uUNIT_SQUARED,\n    ZERO\n} from \"./Constants.sol\";\nimport { UD60x18 } from \"./ValueType.sol\";\n\n/*//////////////////////////////////////////////////////////////////////////\n                            MATHEMATICAL FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Calculates the arithmetic average of x and y using the following formula:\n///\n/// $$\n/// avg(x, y) = (x & y) + ((xUint ^ yUint) / 2)\n/// $$\n///\n/// In English, this is what this formula does:\n///\n/// 1. AND x and y.\n/// 2. Calculate half of XOR x and y.\n/// 3. Add the two results together.\n///\n/// This technique is known as SWAR, which stands for \"SIMD within a register\". You can read more about it here:\n/// https://devblogs.microsoft.com/oldnewthing/20220207-00/?p=106223\n///\n/// @dev Notes:\n/// - The result is rounded toward zero.\n///\n/// @param x The first operand as a UD60x18 number.\n/// @param y The second operand as a UD60x18 number.\n/// @return result The arithmetic average as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction avg(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    uint256 xUint = x.unwrap();\n    uint256 yUint = y.unwrap();\n    unchecked {\n        result = wrap((xUint & yUint) + ((xUint ^ yUint) >> 1));\n    }\n}\n\n/// @notice Yields the smallest whole number greater than or equal to x.\n///\n/// @dev This is optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional\n/// counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n///\n/// Requirements:\n/// - x \u2264 MAX_WHOLE_UD60x18\n///\n/// @param x The UD60x18 number to ceil.\n/// @return result The smallest whole number greater than or equal to x, as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction ceil(UD60x18 x) pure returns (UD60x18 result) {\n    uint256 xUint = x.unwrap();\n    if (xUint > uMAX_WHOLE_UD60x18) {\n        revert Errors.PRBMath_UD60x18_Ceil_Overflow(x);\n    }\n\n    assembly (\"memory-safe\") {\n        // Equivalent to `x % UNIT`.\n        let remainder := mod(x, uUNIT)\n\n        // Equivalent to `UNIT - remainder`.\n        let delta := sub(uUNIT, remainder)\n\n        // Equivalent to `x + remainder > 0 ? delta : 0`.\n        result := add(x, mul(delta, gt(remainder, 0)))\n    }\n}\n\n/// @notice Divides two UD60x18 numbers, returning a new UD60x18 number.\n///\n/// @dev Uses {Common.mulDiv} to enable overflow-safe multiplication and division.\n///\n/// Notes:\n/// - Refer to the notes in {Common.mulDiv}.\n///\n/// Requirements:\n/// - Refer to the requirements in {Common.mulDiv}.\n///\n/// @param x The numerator as a UD60x18 number.\n/// @param y The denominator as a UD60x18 number.\n/// @return result The quotient as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction div(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    result = wrap(Common.mulDiv(x.unwrap(), uUNIT, y.unwrap()));\n}\n\n/// @notice Calculates the natural exponent of x using the following formula:\n///\n/// $$\n/// e^x = 2^{x * log_2{e}}\n/// $$\n///\n/// @dev Requirements:\n/// - x \u2264 133_084258667509499440\n///\n/// @param x The exponent as a UD60x18 number.\n/// @return result The result as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction exp(UD60x18 x) pure returns (UD60x18 result) {\n    uint256 xUint = x.unwrap();\n\n    // This check prevents values greater than 192e18 from being passed to {exp2}.\n    if (xUint > uEXP_MAX_INPUT) {\n        revert Errors.PRBMath_UD60x18_Exp_InputTooBig(x);\n    }\n\n    unchecked {\n        // Inline the fixed-point multiplication to save gas.\n        uint256 doubleUnitProduct = xUint * uLOG2_E;\n        result = exp2(wrap(doubleUnitProduct / uUNIT));\n    }\n}\n\n/// @notice Calculates the binary exponent of x using the binary fraction method.\n///\n/// @dev See https://ethereum.stackexchange.com/q/79903/24693\n///\n/// Requirements:\n/// - x < 192e18\n/// - The result must fit in UD60x18.\n///\n/// @param x The exponent as a UD60x18 number.\n/// @return result The result as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction exp2(UD60x18 x) pure returns (UD60x18 result) {\n    uint256 xUint = x.unwrap();\n\n    // Numbers greater than or equal to 192e18 don't fit in the 192.64-bit format.\n    if (xUint > uEXP2_MAX_INPUT) {\n        revert Errors.PRBMath_UD60x18_Exp2_InputTooBig(x);\n    }\n\n    // Convert x to the 192.64-bit fixed-point format.\n    uint256 x_192x64 = (xUint << 64) / uUNIT;\n\n    // Pass x to the {Common.exp2} function, which uses the 192.64-bit fixed-point number representation.\n    result = wrap(Common.exp2(x_192x64));\n}\n\n/// @notice Yields the greatest whole number less than or equal to x.\n/// @dev Optimized for fractional value inputs, because every whole value has (1e18 - 1) fractional counterparts.\n/// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n/// @param x The UD60x18 number to floor.\n/// @return result The greatest whole number less than or equal to x, as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction floor(UD60x18 x) pure returns (UD60x18 result) {\n    assembly (\"memory-safe\") {\n        // Equivalent to `x % UNIT`.\n        let remainder := mod(x, uUNIT)\n\n        // Equivalent to `x - remainder > 0 ? remainder : 0)`.\n        result := sub(x, mul(remainder, gt(remainder, 0)))\n    }\n}\n\n/// @notice Yields the excess beyond the floor of x using the odd function definition.\n/// @dev See https://en.wikipedia.org/wiki/Fractional_part.\n/// @param x The UD60x18 number to get the fractional part of.\n/// @return result The fractional part of x as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction frac(UD60x18 x) pure returns (UD60x18 result) {\n    assembly (\"memory-safe\") {\n        result := mod(x, uUNIT)\n    }\n}\n\n/// @notice Calculates the geometric mean of x and y, i.e. $\\sqrt{x * y}$, rounding down.\n///\n/// @dev Requirements:\n/// - x * y must fit in UD60x18.\n///\n/// @param x The first operand as a UD60x18 number.\n/// @param y The second operand as a UD60x18 number.\n/// @return result The result as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction gm(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    uint256 xUint = x.unwrap();\n    uint256 yUint = y.unwrap();\n    if (xUint == 0 || yUint == 0) {\n        return ZERO;\n    }\n\n    unchecked {\n        // Checking for overflow this way is faster than letting Solidity do it.\n        uint256 xyUint = xUint * yUint;\n        if (xyUint / xUint != yUint) {\n            revert Errors.PRBMath_UD60x18_Gm_Overflow(x, y);\n        }\n\n        // We don't need to multiply the result by `UNIT` here because the x*y product picked up a factor of `UNIT`\n        // during multiplication. See the comments in {Common.sqrt}.\n        result = wrap(Common.sqrt(xyUint));\n    }\n}\n\n/// @notice Calculates the inverse of x.\n///\n/// @dev Notes:\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - x must not be zero.\n///\n/// @param x The UD60x18 number for which to calculate the inverse.\n/// @return result The inverse as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction inv(UD60x18 x) pure returns (UD60x18 result) {\n    unchecked {\n        result = wrap(uUNIT_SQUARED / x.unwrap());\n    }\n}\n\n/// @notice Calculates the natural logarithm of x using the following formula:\n///\n/// $$\n/// ln{x} = log_2{x} / log_2{e}\n/// $$\n///\n/// @dev Notes:\n/// - Refer to the notes in {log2}.\n/// - The precision isn't sufficiently fine-grained to return exactly `UNIT` when the input is `E`.\n///\n/// Requirements:\n/// - Refer to the requirements in {log2}.\n///\n/// @param x The UD60x18 number for which to calculate the natural logarithm.\n/// @return result The natural logarithm as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction ln(UD60x18 x) pure returns (UD60x18 result) {\n    unchecked {\n        // Inline the fixed-point multiplication to save gas. This is overflow-safe because the maximum value that\n        // {log2} can return is ~196_205294292027477728.\n        result = wrap(log2(x).unwrap() * uUNIT / uLOG2_E);\n    }\n}\n\n/// @notice Calculates the common logarithm of x using the following formula:\n///\n/// $$\n/// log_{10}{x} = log_2{x} / log_2{10}\n/// $$\n///\n/// However, if x is an exact power of ten, a hard coded value is returned.\n///\n/// @dev Notes:\n/// - Refer to the notes in {log2}.\n///\n/// Requirements:\n/// - Refer to the requirements in {log2}.\n///\n/// @param x The UD60x18 number for which to calculate the common logarithm.\n/// @return result The common logarithm as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction log10(UD60x18 x) pure returns (UD60x18 result) {\n    uint256 xUint = x.unwrap();\n    if (xUint < uUNIT) {\n        revert Errors.PRBMath_UD60x18_Log_InputTooSmall(x);\n    }\n\n    // Note that the `mul` in this assembly block is the standard multiplication operation, not {UD60x18.mul}.\n    // prettier-ignore\n    assembly (\"memory-safe\") {\n        switch x\n        case 1 { result := mul(uUNIT, sub(0, 18)) }\n        case 10 { result := mul(uUNIT, sub(1, 18)) }\n        case 100 { result := mul(uUNIT, sub(2, 18)) }\n        case 1000 { result := mul(uUNIT, sub(3, 18)) }\n        case 10000 { result := mul(uUNIT, sub(4, 18)) }\n        case 100000 { result := mul(uUNIT, sub(5, 18)) }\n        case 1000000 { result := mul(uUNIT, sub(6, 18)) }\n        case 10000000 { result := mul(uUNIT, sub(7, 18)) }\n        case 100000000 { result := mul(uUNIT, sub(8, 18)) }\n        case 1000000000 { result := mul(uUNIT, sub(9, 18)) }\n        case 10000000000 { result := mul(uUNIT, sub(10, 18)) }\n        case 100000000000 { result := mul(uUNIT, sub(11, 18)) }\n        case 1000000000000 { result := mul(uUNIT, sub(12, 18)) }\n        case 10000000000000 { result := mul(uUNIT, sub(13, 18)) }\n        case 100000000000000 { result := mul(uUNIT, sub(14, 18)) }\n        case 1000000000000000 { result := mul(uUNIT, sub(15, 18)) }\n        case 10000000000000000 { result := mul(uUNIT, sub(16, 18)) }\n        case 100000000000000000 { result := mul(uUNIT, sub(17, 18)) }\n        case 1000000000000000000 { result := 0 }\n        case 10000000000000000000 { result := uUNIT }\n        case 100000000000000000000 { result := mul(uUNIT, 2) }\n        case 1000000000000000000000 { result := mul(uUNIT, 3) }\n        case 10000000000000000000000 { result := mul(uUNIT, 4) }\n        case 100000000000000000000000 { result := mul(uUNIT, 5) }\n        case 1000000000000000000000000 { result := mul(uUNIT, 6) }\n        case 10000000000000000000000000 { result := mul(uUNIT, 7) }\n        case 100000000000000000000000000 { result := mul(uUNIT, 8) }\n        case 1000000000000000000000000000 { result := mul(uUNIT, 9) }\n        case 10000000000000000000000000000 { result := mul(uUNIT, 10) }\n        case 100000000000000000000000000000 { result := mul(uUNIT, 11) }\n        case 1000000000000000000000000000000 { result := mul(uUNIT, 12) }\n        case 10000000000000000000000000000000 { result := mul(uUNIT, 13) }\n        case 100000000000000000000000000000000 { result := mul(uUNIT, 14) }\n        case 1000000000000000000000000000000000 { result := mul(uUNIT, 15) }\n        case 10000000000000000000000000000000000 { result := mul(uUNIT, 16) }\n        case 100000000000000000000000000000000000 { result := mul(uUNIT, 17) }\n        case 1000000000000000000000000000000000000 { result := mul(uUNIT, 18) }\n        case 10000000000000000000000000000000000000 { result := mul(uUNIT, 19) }\n        case 100000000000000000000000000000000000000 { result := mul(uUNIT, 20) }\n        case 1000000000000000000000000000000000000000 { result := mul(uUNIT, 21) }\n        case 10000000000000000000000000000000000000000 { result := mul(uUNIT, 22) }\n        case 100000000000000000000000000000000000000000 { result := mul(uUNIT, 23) }\n        case 1000000000000000000000000000000000000000000 { result := mul(uUNIT, 24) }\n        case 10000000000000000000000000000000000000000000 { result := mul(uUNIT, 25) }\n        case 100000000000000000000000000000000000000000000 { result := mul(uUNIT, 26) }\n        case 1000000000000000000000000000000000000000000000 { result := mul(uUNIT, 27) }\n        case 10000000000000000000000000000000000000000000000 { result := mul(uUNIT, 28) }\n        case 100000000000000000000000000000000000000000000000 { result := mul(uUNIT, 29) }\n        case 1000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 30) }\n        case 10000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 31) }\n        case 100000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 32) }\n        case 1000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 33) }\n        case 10000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 34) }\n        case 100000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 35) }\n        case 1000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 36) }\n        case 10000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 37) }\n        case 100000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 38) }\n        case 1000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 39) }\n        case 10000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 40) }\n        case 100000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 41) }\n        case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 42) }\n        case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 43) }\n        case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 44) }\n        case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 45) }\n        case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 46) }\n        case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 47) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 48) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 49) }\n        case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 50) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 51) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 52) }\n        case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 53) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 54) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 55) }\n        case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 56) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 57) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 58) }\n        case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 59) }\n        default { result := uMAX_UD60x18 }\n    }\n\n    if (result.unwrap() == uMAX_UD60x18) {\n        unchecked {\n            // Inline the fixed-point division to save gas.\n            result = wrap(log2(x).unwrap() * uUNIT / uLOG2_10);\n        }\n    }\n}\n\n/// @notice Calculates the binary logarithm of x using the iterative approximation algorithm:\n///\n/// $$\n/// log_2{x} = n + log_2{y}, \\text{ where } y = x*2^{-n}, \\ y \\in [1, 2)\n/// $$\n///\n/// For $0 \\leq x \\lt 1$, the input is inverted:\n///\n/// $$\n/// log_2{x} = -log_2{\\frac{1}{x}}\n/// $$\n///\n/// @dev See https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\n///\n/// Notes:\n/// - Due to the lossy precision of the iterative approximation, the results are not perfectly accurate to the last decimal.\n///\n/// Requirements:\n/// - x \u2265 UNIT\n///\n/// @param x The UD60x18 number for which to calculate the binary logarithm.\n/// @return result The binary logarithm as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction log2(UD60x18 x) pure returns (UD60x18 result) {\n    uint256 xUint = x.unwrap();\n\n    if (xUint < uUNIT) {\n        revert Errors.PRBMath_UD60x18_Log_InputTooSmall(x);\n    }\n\n    unchecked {\n        // Calculate the integer part of the logarithm.\n        uint256 n = Common.msb(xUint / uUNIT);\n\n        // This is the integer part of the logarithm as a UD60x18 number. The operation can't overflow because n\n        // n is at most 255 and UNIT is 1e18.\n        uint256 resultUint = n * uUNIT;\n\n        // Calculate $y = x * 2^{-n}$.\n        uint256 y = xUint >> n;\n\n        // If y is the unit number, the fractional part is zero.\n        if (y == uUNIT) {\n            return wrap(resultUint);\n        }\n\n        // Calculate the fractional part via the iterative approximation.\n        // The `delta >>= 1` part is equivalent to `delta /= 2`, but shifting bits is more gas efficient.\n        uint256 DOUBLE_UNIT = 2e18;\n        for (uint256 delta = uHALF_UNIT; delta > 0; delta >>= 1) {\n            y = (y * y) / uUNIT;\n\n            // Is y^2 >= 2e18 and so in the range [2e18, 4e18)?\n            if (y >= DOUBLE_UNIT) {\n                // Add the 2^{-m} factor to the logarithm.\n                resultUint += delta;\n\n                // Halve y, which corresponds to z/2 in the Wikipedia article.\n                y >>= 1;\n            }\n        }\n        result = wrap(resultUint);\n    }\n}\n\n/// @notice Multiplies two UD60x18 numbers together, returning a new UD60x18 number.\n///\n/// @dev Uses {Common.mulDiv} to enable overflow-safe multiplication and division.\n///\n/// Notes:\n/// - Refer to the notes in {Common.mulDiv}.\n///\n/// Requirements:\n/// - Refer to the requirements in {Common.mulDiv}.\n///\n/// @dev See the documentation in {Common.mulDiv18}.\n/// @param x The multiplicand as a UD60x18 number.\n/// @param y The multiplier as a UD60x18 number.\n/// @return result The product as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction mul(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    result = wrap(Common.mulDiv18(x.unwrap(), y.unwrap()));\n}\n\n/// @notice Raises x to the power of y.\n///\n/// For $1 \\leq x \\leq \\infty$, the following standard formula is used:\n///\n/// $$\n/// x^y = 2^{log_2{x} * y}\n/// $$\n///\n/// For $0 \\leq x \\lt 1$, since the unsigned {log2} is undefined, an equivalent formula is used:\n///\n/// $$\n/// i = \\frac{1}{x}\n/// w = 2^{log_2{i} * y}\n/// x^y = \\frac{1}{w}\n/// $$\n///\n/// @dev Notes:\n/// - Refer to the notes in {log2} and {mul}.\n/// - Returns `UNIT` for 0^0.\n/// - It may not perform well with very small values of x. Consider using SD59x18 as an alternative.\n///\n/// Requirements:\n/// - Refer to the requirements in {exp2}, {log2}, and {mul}.\n///\n/// @param x The base as a UD60x18 number.\n/// @param y The exponent as a UD60x18 number.\n/// @return result The result as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction pow(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    uint256 xUint = x.unwrap();\n    uint256 yUint = y.unwrap();\n\n    // If both x and y are zero, the result is `UNIT`. If just x is zero, the result is always zero.\n    if (xUint == 0) {\n        return yUint == 0 ? UNIT : ZERO;\n    }\n    // If x is `UNIT`, the result is always `UNIT`.\n    else if (xUint == uUNIT) {\n        return UNIT;\n    }\n\n    // If y is zero, the result is always `UNIT`.\n    if (yUint == 0) {\n        return UNIT;\n    }\n    // If y is `UNIT`, the result is always x.\n    else if (yUint == uUNIT) {\n        return x;\n    }\n\n    // If x is > UNIT, use the standard formula.\n    if (xUint > uUNIT) {\n        result = exp2(mul(log2(x), y));\n    }\n    // Conversely, if x < UNIT, use the equivalent formula.\n    else {\n        UD60x18 i = wrap(uUNIT_SQUARED / xUint);\n        UD60x18 w = exp2(mul(log2(i), y));\n        result = wrap(uUNIT_SQUARED / w.unwrap());\n    }\n}\n\n/// @notice Raises x (a UD60x18 number) to the power y (an unsigned basic integer) using the well-known\n/// algorithm \"exponentiation by squaring\".\n///\n/// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring.\n///\n/// Notes:\n/// - Refer to the notes in {Common.mulDiv18}.\n/// - Returns `UNIT` for 0^0.\n///\n/// Requirements:\n/// - The result must fit in UD60x18.\n///\n/// @param x The base as a UD60x18 number.\n/// @param y The exponent as a uint256.\n/// @return result The result as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction powu(UD60x18 x, uint256 y) pure returns (UD60x18 result) {\n    // Calculate the first iteration of the loop in advance.\n    uint256 xUint = x.unwrap();\n    uint256 resultUint = y & 1 > 0 ? xUint : uUNIT;\n\n    // Equivalent to `for(y /= 2; y > 0; y /= 2)`.\n    for (y >>= 1; y > 0; y >>= 1) {\n        xUint = Common.mulDiv18(xUint, xUint);\n\n        // Equivalent to `y % 2 == 1`.\n        if (y & 1 > 0) {\n            resultUint = Common.mulDiv18(resultUint, xUint);\n        }\n    }\n    result = wrap(resultUint);\n}\n\n/// @notice Calculates the square root of x using the Babylonian method.\n///\n/// @dev See https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n///\n/// Notes:\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - x \u2264 MAX_UD60x18 / UNIT\n///\n/// @param x The UD60x18 number for which to calculate the square root.\n/// @return result The result as a UD60x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction sqrt(UD60x18 x) pure returns (UD60x18 result) {\n    uint256 xUint = x.unwrap();\n\n    unchecked {\n        if (xUint > uMAX_UD60x18 / uUNIT) {\n            revert Errors.PRBMath_UD60x18_Sqrt_Overflow(x);\n        }\n        // Multiply x by `UNIT` to account for the factor of `UNIT` picked up when multiplying two UD60x18 numbers.\n        // In this case, the two numbers are both the square root.\n        result = wrap(Common.sqrt(xUint * uUNIT));\n    }\n}\n"}, "@prb/math/src/ud60x18/ValueType.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"./Casting.sol\" as Casting;\nimport \"./Helpers.sol\" as Helpers;\nimport \"./Math.sol\" as Math;\n\n/// @notice The unsigned 60.18-decimal fixed-point number representation, which can have up to 60 digits and up to 18\n/// decimals. The values of this are bound by the minimum and the maximum values permitted by the Solidity type uint256.\n/// @dev The value type is defined here so it can be imported in all other files.\ntype UD60x18 is uint256;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CASTING\n//////////////////////////////////////////////////////////////////////////*/\n\nusing {\n    Casting.intoSD1x18,\n    Casting.intoSD21x18,\n    Casting.intoSD59x18,\n    Casting.intoUD2x18,\n    Casting.intoUD21x18,\n    Casting.intoUint128,\n    Casting.intoUint256,\n    Casting.intoUint40,\n    Casting.unwrap\n} for UD60x18 global;\n\n/*//////////////////////////////////////////////////////////////////////////\n                            MATHEMATICAL FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\n// The global \"using for\" directive makes the functions in this library callable on the UD60x18 type.\nusing {\n    Math.avg,\n    Math.ceil,\n    Math.div,\n    Math.exp,\n    Math.exp2,\n    Math.floor,\n    Math.frac,\n    Math.gm,\n    Math.inv,\n    Math.ln,\n    Math.log10,\n    Math.log2,\n    Math.mul,\n    Math.pow,\n    Math.powu,\n    Math.sqrt\n} for UD60x18 global;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                HELPER FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\n// The global \"using for\" directive makes the functions in this library callable on the UD60x18 type.\nusing {\n    Helpers.add,\n    Helpers.and,\n    Helpers.eq,\n    Helpers.gt,\n    Helpers.gte,\n    Helpers.isZero,\n    Helpers.lshift,\n    Helpers.lt,\n    Helpers.lte,\n    Helpers.mod,\n    Helpers.neq,\n    Helpers.not,\n    Helpers.or,\n    Helpers.rshift,\n    Helpers.sub,\n    Helpers.uncheckedAdd,\n    Helpers.uncheckedSub,\n    Helpers.xor\n} for UD60x18 global;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    OPERATORS\n//////////////////////////////////////////////////////////////////////////*/\n\n// The global \"using for\" directive makes it possible to use these operators on the UD60x18 type.\nusing {\n    Helpers.add as +,\n    Helpers.and2 as &,\n    Math.div as /,\n    Helpers.eq as ==,\n    Helpers.gt as >,\n    Helpers.gte as >=,\n    Helpers.lt as <,\n    Helpers.lte as <=,\n    Helpers.or as |,\n    Helpers.mod as %,\n    Math.mul as *,\n    Helpers.neq as !=,\n    Helpers.not as ~,\n    Helpers.sub as -,\n    Helpers.xor as ^\n} for UD60x18 global;\n"}, "contracts/Factory.sol": {"content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.30;\r\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\r\nimport {UD60x18, powu, unwrap} from \"@prb/math/src/UD60x18.sol\";\r\nimport \"./interfaces/IFactory.sol\";\r\nimport \"./interfaces/IBSKT.sol\";\r\nimport \"./interfaces/IBSKTPair.sol\";\r\nimport \"./interfaces/IUniswap.sol\";\r\nimport \"./interfaces/IERC20.sol\";\r\nimport \"./interfaces/IWETH.sol\";\r\nimport \"./interfaces/IBSKTUtils.sol\";\r\n\r\n/// @title Factory Contract for Basket Token Standard\r\n/// @notice Handles the creation and management of Basket Token Standard contracts\r\n/// @dev Uses BeaconProxy pattern to deploy BSKT and BSKTPair contracts\r\n/// @dev Manages implementations, whitelisted contracts, and parameters for the Alvara ecosystem\r\ncontract Factory is Initializable, AccessControlUpgradeable, ReentrancyGuardUpgradeable, PausableUpgradeable, IFactory {\r\n\r\n    // ===============================================\r\n    // Type Declarations\r\n    // ===============================================\r\n    \r\n    /// @notice Structure to store platform fee configuration parameters\r\n    /// @dev Used to manage various fees collected by the protocol\r\n    struct PlatformFeeConfig {\r\n        /// @notice Fee percentage applied when creating a new BSKT (in PERCENT_PRECISION)\r\n        uint16 bsktCreationFee; \r\n        /// @notice Fee percentage applied on user contributions (in PERCENT_PRECISION)\r\n        uint16 contributionFee; \r\n        /// @notice Fee percentage applied on withdrawals (in PERCENT_PRECISION)\r\n        uint16 withdrawalFee; \r\n        /// @notice Address that receives all collected fees\r\n        address feeCollector;  \r\n    }\r\n\r\n    // ===============================================\r\n    // Roles\r\n    // ===============================================\r\n\r\n    /// @notice Role for protocol administrators with full control\r\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\r\n    /// @notice Role for managing platform fees and related configurations\r\n    bytes32 public constant FEE_MANAGER_ROLE = keccak256(\"FEE_MANAGER_ROLE\");\r\n    /// @notice Role for updating collection and contract URIs\r\n    bytes32 public constant URI_MANAGER_ROLE = keccak256(\"URI_MANAGER_ROLE\");\r\n    /// @notice Role for whitelisting and managing external contracts\r\n    bytes32 public constant WHITELIST_MANAGER_ROLE = keccak256(\"WHITELIST_MANAGER_ROLE\");\r\n    /// @notice Role for managing upgrades and implementation addresses\r\n    bytes32 public constant UPGRADER_ROLE = keccak256(\"UPGRADER_ROLE\");\r\n\r\n    // ===============================================\r\n    // Constants\r\n    // ===============================================\r\n    \r\n    /// @notice Precision value for percentage calculations (100% = 10000)\r\n    /// @dev Used for representing weights and percentages throughout the protocol\r\n    uint256 public constant PERCENT_PRECISION = 10000;\r\n\r\n    /// @notice Default platform fee in 0.5%\r\n    uint16 public constant DEFAULT_FEE = 50; \r\n\r\n    // ===============================================\r\n    // State Variables\r\n    // ===============================================\r\n\r\n    /// @notice The minimum LP tokens required for withdrawal (can be updated by admin)\r\n    uint256 private _minLpWithdrawal;\r\n\r\n    /// @notice The address of the ALVA token\r\n    /// @dev Required in all baskets with a minimum percentage\r\n    address public alva;\r\n\r\n    /// @notice The address of the Uniswap Router\r\n    /// @dev Used for swapping tokens during basket operations\r\n    address public router;\r\n\r\n    /// @notice The address of the Wrapped ETH token\r\n    /// @dev Used for ETH operations and as a common denominator for swaps\r\n    address public weth;\r\n\r\n    /// @notice The implementation address for BSKT contracts\r\n    /// @dev Used as a blueprint for creating new BSKT proxies\r\n    address public bsktImplementation;\r\n\r\n    /// @notice The implementation address for BSKTPair contracts\r\n    /// @dev Used as a blueprint for creating new BSKTPair proxies\r\n    address public bsktPairImplementation;\r\n\r\n    /// @notice The address that receives royalties\r\n    /// @dev Target for royalty payments from NFT marketplaces\r\n    address public royaltyReceiver;\r\n\r\n    /// @notice The percentage of royalties to be paid (basis points)\r\n    /// @dev Expressed in basis points (e.g., 2000 = 20%)\r\n    uint256 public royaltyPercentage;\r\n    \r\n    /// @notice The minimum percentage of ALVA required in a basket\r\n    /// @dev Ensures every basket includes ALVA token with a minimum weight\r\n    uint16 public minPercentALVA;\r\n\r\n    /// @notice The minimum amount of ETH required to create a BSKT\r\n    /// @dev Sets a floor for initial liquidity to ensure meaningful baskets\r\n    uint256 public minBSKTCreationAmount;\r\n\r\n    /// @notice The monthly management fee rate\r\n    uint256 public monthlyFeeRate;\r\n\r\n    /// @notice The URI for collection metadata\r\n    /// @dev Used by NFT marketplaces to display collection information\r\n    string public collectionUri;\r\n\r\n    /// @notice Array of all BSKT contracts created\r\n    /// @dev Keeps track of all baskets for enumeration\r\n    address[] public bsktList;\r\n    \r\n    /// @notice Mapping of whitelisted contracts that can interact with BSKT\r\n    /// @dev Security feature to limit interactions to trusted contracts\r\n    mapping(address => bool) public whitelistedContracts;\r\n\r\n    /// @notice Current platform fee configuration\r\n    /// @dev Stores all fee percentages and the fee collector address\r\n    PlatformFeeConfig private platformFeeConfig;\r\n\r\n    /// @notice The BSKTUtils contract address\r\n    /// @dev Used for utility functions\r\n    address public bsktUtils;\r\n\r\n\r\n    // ===============================================\r\n    // Events\r\n    // ===============================================\r\n\r\n    /// @notice Emitted when a new BSKT contract is created\r\n    /// @param name Name of the basket token\r\n    /// @param symbol Symbol of the basket token\r\n    /// @param bskt Address of the created BSKT contract\r\n    /// @param bsktPair Address of the created BSKTPair contract\r\n    /// @param creator Address of the creator\r\n    /// @param amount Amount of ETH used to create the basket\r\n    /// @param _id Unique identifier for the basket\r\n    /// @param description Description of the basket\r\n    event BSKTCreated(\r\n        string name,\r\n        string symbol,\r\n        address bskt,\r\n        address bsktPair,\r\n        address indexed creator,\r\n        uint256 amount,\r\n        string _id,\r\n        string description,\r\n        uint256 feeAmount\r\n    );\r\n\r\n    /// @notice Emitted when the ALVA token address is updated\r\n    /// @param alva New ALVA token address\r\n    event AlvaUpdated(address alva);\r\n\r\n    /// @notice Emitted when the minimum ALVA percentage is updated\r\n    /// @param percent New minimum percentage\r\n    event MinAlvaPercentageUpdated(uint256 percent);\r\n\r\n    /// @notice Emitted when the BSKT implementation address is updated\r\n    /// @param bsktImplementation New implementation address\r\n    event BSKTImplementationUpdated(address indexed bsktImplementation);\r\n\r\n    /// @notice Emitted when the BSKTPair implementation address is updated\r\n    /// @param bsktPairImplementation New implementation address\r\n    event BSKTPairImplementationUpdated(address indexed bsktPairImplementation);\r\n\r\n\r\n    /// @notice Emitted when the collection URI is updated\r\n    /// @param newURI New collection URI\r\n    event CollectionURIUpdated(string newURI);\r\n\r\n    /// @notice Emitted when the royalty percentage is updated\r\n    /// @param newRoyaltyPercentage New royalty percentage\r\n    event RoyaltyUpdated(uint256 newRoyaltyPercentage);\r\n\r\n    /// @notice Emitted when the royalty receiver is updated\r\n    /// @param newRoyaltyReceiver New royalty receiver address\r\n    event RoyaltyReceiverUpdated(address indexed newRoyaltyReceiver);\r\n\r\n    /// @notice Emitted when the platform fees are updated\r\n    /// @param bsktCreationFee New BSKT creation fee in PERCENT_PRECISION\r\n    /// @param contributionFee New contribution fee in PERCENT_PRECISION\r\n    /// @param withdrawalFee New withdrawal fee in PERCENT_PRECISION\r\n    event PlatformFeesUpdated(\r\n        uint16 bsktCreationFee, \r\n        uint16 contributionFee, \r\n        uint16 withdrawalFee        \r\n        );\r\n    \r\n    /// @notice Emitted when the platform fee collector address is updated\r\n    /// @param newFeeCollector The updated address receiving platform fees\r\n    event FeeCollectorUpdated(address indexed newFeeCollector);\r\n\r\n    /// @notice Emitted when the BSKT creation fee is deducted from user contribution\r\n    /// @param feeAmount The deducted fee amount in wei\r\n    /// @param feePercent The applied fee percentage in 10000 precision\r\n    /// @param feeCollector The address that received the deducted fee\r\n    event BSKTCreationFeeDeducted(uint256 feeAmount, uint256 feePercent, address indexed feeCollector);\r\n\r\n    /// @notice Emitted when the minimum BSKT creation amount is updated\r\n    /// @param caller Caller who has updated the minimum creation amount\r\n    /// @param amount is the new amount required to create a bskt\r\n    event MinBSKTCreationAmountUpdated(address indexed caller, uint256 amount);\r\n\r\n    /// @notice Emitted when a contract is whitelisted\r\n    /// @param contractAddress Address of the contract that is whitelisted\r\n    event ContractWhitelisted(address indexed contractAddress);\r\n\r\n    /// @notice Emitted when a contract is removed from the whitelist\r\n    /// @param contractAddress Address of the contract that is removed from the whitelisted\r\n    event ContractRemovedFromWhitelist(address indexed contractAddress);\r\n\r\n    /// @notice Emitted when the minimum LP withdrawal amount is updated\r\n    event MinLpWithdrawalUpdated(uint256 newMinLpWithdrawal);\r\n\r\n    /// @notice Emitted when the BSKTUtils contract is updated\r\n    event BSKTUtilsUpdated(address indexed bsktUtils);\r\n\r\n    // ===============================================\r\n    // Errors\r\n    // ===============================================\r\n\r\n    /// @notice Error thrown when an invalid token address is provided\r\n    error InvalidAddress();\r\n\r\n    /// @notice Error thrown when an invalid amount is provided\r\n    error InvalidAmount();\r\n\r\n    /// @notice Error thrown when an invalid buffer value is specified\r\n    /// @param provided The provided buffer value\r\n    /// @param minAllowed The minimum allowed buffer\r\n    /// @param maxAllowed The maximum allowed buffer\r\n    error InvalidBuffer(uint256 provided, uint256 minAllowed, uint256 maxAllowed);\r\n    \r\n    /// @notice Error thrown when string parameters are empty\r\n    /// @param paramName Name of the invalid parameter\r\n    error EmptyStringParameter(string paramName);\r\n\r\n    /// @notice Error thrown when a transfer fails\r\n    error TransferFailed();\r\n\r\n    /// @notice Error thrown when total ETH swapped exceeds the value sent\r\n    error ExcessiveSwapAmount();\r\n\r\n    /// @notice Error thrown when an invalid contract address is provided for whitelisting\r\n    /// @param provided The provided address\r\n    /// @param alreadyWhitelisted Whether the address is already whitelisted\r\n    error InvalidWhitelistAddress(address provided, bool alreadyWhitelisted);\r\n\r\n    /// @notice Error thrown when an invalid royalty percentage is provided\r\n    /// @param value The provided value\r\n    /// @param minAllowed The minimum allowed value    \r\n    /// @param maxAllowed The maximum allowed value\r\n    error InvalidRoyaltyPercentage(uint256 value, uint256 minAllowed, uint256 maxAllowed);\r\n\r\n    /// @notice Error thrown when the new royalty percentage is the same as the\r\n    /// currently set value. No update is needed in this case.\r\n    error DuplicateRoyaltyValue();\r\n\r\n    /// @notice Error thrown when an invalid ALVA percentage is provided\r\n    /// @param value The provided value\r\n    /// @param minAllowed The minimum allowed value\r\n    /// @param maxAllowed The maximum allowed value\r\n    error InvalidAlvaPercentage(uint256 value, uint256 minAllowed, uint256 maxAllowed);\r\n    \r\n    /// @notice Error thrown when the BSKT creation amount is below the minimum\r\n    /// @param provided The provided amount\r\n    /// @param minAllowed The minimum allowed amount\r\n    error InsufficientBSKTCreationAmount(uint256 provided, uint256 minAllowed);\r\n\r\n    /// @notice Thrown when a provided fee value or its resulting deduction exceeds valid limits\r\n    error InvalidFee();\r\n\r\n    /// @notice Thrown when the signature is invalid\r\n    error InvalidSignature();\r\n\r\n    /// @notice Thrown when the provided length of tokens or weights are invalid\r\n    error InvalidTokensAndWeights();\r\n\r\n    /// @notice Thrown when swap output is less than minimum required amount\r\n    /// @param tokenOut The output token address that failed the minimum check\r\n    /// @param amountIn The input token amount used for the swap\r\n    /// @param actualAmountOut The actual output token amount received from swap\r\n    /// @param minAmountOut The minimum output token amount required\r\n    /// @param tokenIndex The index of the output token in the basket\r\n    error InsufficientSwapOutput(\r\n        address tokenOut,\r\n        uint256 amountIn,\r\n        uint256 actualAmountOut,\r\n        uint256 minAmountOut,\r\n        uint256 tokenIndex\r\n    );\r\n\r\n    // ===============================================\r\n    // Initialization\r\n    // ===============================================\r\n\r\n    /// @notice As Factory is a proxy contract, therefore need to restrict implementation to call initialize method \r\n    /// @dev Constructor will disable initializers.\r\n    constructor() {\r\n        _disableInitializers(); // Locks the implementation\r\n    }\r\n\r\n    /// @notice Initializes the Factory contract with required addresses and parameters\r\n    /// @dev Sets up the core protocol configuration\r\n    /// @param _alva Address of the ALVA token\r\n    /// @param _minPercentALVA Minimum percentage of ALVA required in a basket\r\n    /// @param _bsktImplementation Implementation address for BSKT contracts\r\n    /// @param _bsktPairImplementation Implementation address for BSKTPair contracts\r\n    /// @param _monthlyFeeRate Management fee\r\n    /// @param _royaltyReceiver Address that receives royalties\r\n    /// @param _collectionUri URI for collection metadata\r\n    /// @param _feeCollector Fee collector address to collect platform fee    \r\n    /// @param _defaultMarketplace Address of the default marketplace\r\n    /// @param _routerAddress Address of the Uniswap router\r\n    /// @param _wethAddress Address of the Wrapped ETH token\r\n    /// @param _minBSKTCreationAmount Minimum BSKT creation amount\r\n    function initialize(\r\n        address _alva,\r\n        uint16 _minPercentALVA,\r\n        address _bsktImplementation,\r\n        address _bsktPairImplementation,\r\n        uint256 _monthlyFeeRate,\r\n        address _royaltyReceiver,\r\n        string calldata _collectionUri,\r\n        address _feeCollector,\r\n        address _defaultMarketplace,\r\n        address _routerAddress,\r\n        address _wethAddress,\r\n        uint256 _minBSKTCreationAmount\r\n    ) external initializer {\r\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\r\n        __ReentrancyGuard_init();\r\n        __Pausable_init();\r\n\r\n        if (\r\n            _alva == address(0) ||\r\n            _bsktImplementation == address(0) ||\r\n            _bsktPairImplementation == address(0) ||\r\n            _routerAddress == address(0) ||\r\n            _wethAddress == address(0) ||\r\n            _royaltyReceiver == address(0) ||\r\n            _feeCollector == address(0) ||\r\n            _defaultMarketplace == address(0) \r\n        ) {\r\n            revert InvalidAddress();\r\n        }\r\n\r\n        if (_minPercentALVA < 100 || _minPercentALVA > 5000) {\r\n            revert InvalidAlvaPercentage(_minPercentALVA, 100, 5000);\r\n        }\r\n\r\n        if (bytes(_collectionUri).length == 0) {\r\n            revert EmptyStringParameter(\"collectionUri\");\r\n        }\r\n\r\n        alva = _alva;\r\n        royaltyReceiver = _royaltyReceiver;\r\n        bsktImplementation = _bsktImplementation;\r\n        bsktPairImplementation = _bsktPairImplementation;\r\n        minPercentALVA = _minPercentALVA;\r\n        monthlyFeeRate = _monthlyFeeRate;\r\n        collectionUri = _collectionUri;\r\n        // Set default values for the fees\r\n        platformFeeConfig = PlatformFeeConfig({\r\n            bsktCreationFee: DEFAULT_FEE,\r\n            contributionFee: DEFAULT_FEE,\r\n            withdrawalFee: DEFAULT_FEE,\r\n            feeCollector: _feeCollector\r\n        });\r\n        royaltyPercentage = 200;\r\n        router = _routerAddress;\r\n        weth = _wethAddress;\r\n        whitelistedContracts[_defaultMarketplace] = true;\r\n        minBSKTCreationAmount = _minBSKTCreationAmount;\r\n        _minLpWithdrawal = 1e11; // Set default minimum LP amount as 1e11\r\n    }\r\n\r\n    // ===============================================\r\n    // External Functions\r\n    // ===============================================\r\n\r\n    /// @notice Returns the minimum LP withdrawal amount\r\n    function minLpWithdrawal() external view returns (uint256) {\r\n        return _minLpWithdrawal;\r\n    }\r\n\r\n    /// @notice Allows the owner to update the minimum LP withdrawal amount\r\n    /// @param newMin New minimum LP withdrawal amount\r\n    function setMinLpWithdrawal(uint256 newMin) external onlyRole(ADMIN_ROLE) {\r\n        _minLpWithdrawal = newMin;\r\n        emit MinLpWithdrawalUpdated(newMin);\r\n    }\r\n\r\n    /// @notice Creates a new Basket Token Standard contract with the specified parameters\r\n    /// @dev Deploys a BSKT and BSKTPair contract, swaps ETH for tokens, and mints liquidity\r\n    /// @dev Uses BeaconProxy pattern to create new instances from implementations\r\n    /// @param _name Name of the basket token\r\n    /// @param _symbol Symbol of the basket token\r\n    /// @param _tokens Array of token addresses in the basket\r\n    /// @param _weights Array of weights for each token\r\n    /// @param _tokenURI URI for the basket token\r\n    /// @param _minAmountsOut Minimum amounts expected for each token after swaps\r\n    /// @param _id Unique identifier for the basket\r\n    /// @param _description Description of the basket\r\n    function createBSKT(\r\n        string calldata _name,\r\n        string calldata _symbol,\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _weights,\r\n        string calldata _tokenURI,\r\n        uint256[] calldata _minAmountsOut,\r\n        bytes calldata _signature,\r\n        string calldata _id,\r\n        string calldata _description,\r\n        uint256 _deadline\r\n    ) external payable whenNotPaused nonReentrant {\r\n        if (msg.value < minBSKTCreationAmount) revert InsufficientBSKTCreationAmount(msg.value, minBSKTCreationAmount);\r\n\r\n        if (bytes(_name).length == 0) revert EmptyStringParameter(\"name\");\r\n        if (bytes(_symbol).length == 0) revert EmptyStringParameter(\"symbol\");\r\n        if (bytes(_tokenURI).length == 0)\r\n            revert EmptyStringParameter(\"tokenURI\");\r\n        if (bytes(_id).length == 0) revert EmptyStringParameter(\"id\");\r\n        if (_tokens.length != _weights.length || _tokens.length == 0 || _tokens.length != _minAmountsOut.length) revert InvalidTokensAndWeights();\r\n        \r\n        // Check if the bsktCreationFee is greater than 0 and deduct it\r\n        uint256 creationFeeAmount = 0;\r\n        if (platformFeeConfig.bsktCreationFee > 0) {\r\n            creationFeeAmount = (msg.value * platformFeeConfig.bsktCreationFee) / PERCENT_PRECISION;\r\n            // Ensure the deducted fee is valid\r\n            if (creationFeeAmount > msg.value) revert InvalidFee();\r\n            (bool success, ) = payable(platformFeeConfig.feeCollector).call{ value: creationFeeAmount }(\"\");\r\n            \r\n            require(success, \"Failed to deduct BSKT Creation Fee\");\r\n            \r\n            // Emit BSKT creation fee deduction event\r\n            emit BSKTCreationFeeDeducted(creationFeeAmount, platformFeeConfig.bsktCreationFee, platformFeeConfig.feeCollector); \r\n        }\r\n\r\n        uint256 amountAfterFee = msg.value - creationFeeAmount;\r\n\r\n        (address _bskt, address _bsktPair) = _initializeBSKTWithPair(\r\n            _name,\r\n            _symbol,\r\n            _tokens,\r\n            _weights,\r\n            _tokenURI,\r\n            _id,\r\n            _description\r\n        );\r\n        if (!IBSKTUtils(bsktUtils).verifySignature(_deadline, _tokens, _weights, _minAmountsOut, _signature)) revert InvalidSignature();\r\n\r\n        uint256 totalETHswapped = 0;\r\n        uint256 tokensLength = _tokens.length;\r\n        uint256[] memory amounts = new uint256[](tokensLength);\r\n\r\n        for (uint256 i = 0; i < tokensLength; ) {\r\n            uint256 _amountInMin;\r\n            \r\n            // For the last token, use remaining amount to avoid dust\r\n            if (i == tokensLength - 1) {\r\n                _amountInMin = amountAfterFee - totalETHswapped;\r\n            } else {\r\n                _amountInMin = (amountAfterFee * _weights[i]) / PERCENT_PRECISION;\r\n            }\r\n\r\n            uint256 balance = IERC20(_tokens[i]).balanceOf(_bsktPair);\r\n            \r\n            // Check if the token is WETH\r\n            if (_tokens[i] == weth) {\r\n                // If token is WETH, directly deposit ETH as WETH and transfer to the pair\r\n                // This avoids the need for a swap path from WETH to WETH\r\n                IWETH(weth).deposit{value: _amountInMin}();                \r\n                // Transfer WETH to the pair\r\n                IERC20(weth).transfer(_bsktPair, _amountInMin);\r\n            } else {\r\n                // For other tokens, swap ETH for tokens\r\n                address[] memory path = new address[](2);\r\n                path[0] = weth;\r\n                path[1] = _tokens[i];\r\n                \r\n                IUniswapV2Router(router)\r\n                    .swapExactETHForTokensSupportingFeeOnTransferTokens{\r\n                    value: _amountInMin\r\n                }(_minAmountsOut[i], path, _bsktPair, _deadline);\r\n            }\r\n            totalETHswapped += _amountInMin;\r\n\r\n            amounts[i] = IERC20(_tokens[i]).balanceOf(_bsktPair) - balance;\r\n\r\n            // Validate that received amount is greater than tha minimum acceptable amount\r\n            if (amounts[i] < _minAmountsOut[i]) {\r\n                revert InsufficientSwapOutput(\r\n                    _tokens[i],     // tokenOut (target token)\r\n                    _amountInMin,   // amountIn (ETH amount)\r\n                    amounts[i],     // actualAmountOut\r\n                    _minAmountsOut[i], // minAmountOut\r\n                    i               // tokenIndex\r\n                );\r\n            }\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        bsktList.push(_bskt);\r\n        IBSKTPair(_bsktPair).mint(msg.sender, amounts);\r\n        OwnableUpgradeable(_bsktPair).transferOwnership(_bskt);\r\n\r\n        // Return back the remaining ETH \r\n        if (totalETHswapped > amountAfterFee) {\r\n            revert ExcessiveSwapAmount();\r\n        } else if (totalETHswapped < amountAfterFee) {\r\n            (bool success, ) = payable(msg.sender).call{\r\n                value: amountAfterFee - totalETHswapped\r\n            }(\"\");\r\n            if (!success) revert TransferFailed();\r\n        }\r\n\r\n        emit BSKTCreated(\r\n            _name,\r\n            _symbol,\r\n            _bskt,\r\n            _bsktPair,\r\n            msg.sender,\r\n            amountAfterFee,\r\n            _id,\r\n            _description,\r\n            creationFeeAmount\r\n        );\r\n    }\r\n\r\n    /// @notice Updates the BSKT implementation address\r\n    /// @dev Used when upgrading the BSKT contract logic\r\n    /// @param _bsktImplementation New implementation address\r\n    function updateBSKTImplementation(\r\n        address _bsktImplementation\r\n    ) external onlyRole(UPGRADER_ROLE) {\r\n        if (_bsktImplementation == address(0) || !AddressUpgradeable.isContract(_bsktImplementation))\r\n            revert InvalidAddress();\r\n        bsktImplementation = _bsktImplementation;\r\n\r\n        emit BSKTImplementationUpdated(_bsktImplementation);\r\n    }\r\n\r\n    /// @notice Updates the BSKTPair implementation address\r\n    /// @dev Used when upgrading the BSKTPair contract logic\r\n    /// @param _bsktPairImplementation New implementation address\r\n    function updateBSKTPairImplementation(\r\n        address _bsktPairImplementation\r\n    ) external onlyRole(UPGRADER_ROLE) {\r\n        if (\r\n            _bsktPairImplementation == address(0) || !AddressUpgradeable.isContract(_bsktPairImplementation)) \r\n                revert InvalidAddress();\r\n        bsktPairImplementation = _bsktPairImplementation;\r\n\r\n        emit BSKTPairImplementationUpdated(_bsktPairImplementation);\r\n    }\r\n\r\n    /// @notice Updates the ALVA token address\r\n    /// @dev Used when the primary ALVA token contract changes\r\n    /// @param _alva New ALVA token address\r\n    function updateAlva(address _alva) external onlyRole(UPGRADER_ROLE) {\r\n        if (_alva == address(0) || !AddressUpgradeable.isContract(_alva)) \r\n            revert InvalidAddress();\r\n        alva = _alva;\r\n\r\n        emit AlvaUpdated(_alva);\r\n    }\r\n\r\n    /// @notice Updates the BSKTUtils contract address\r\n    /// @param _bsktUtils The new BSKTUtils contract address\r\n    /// @dev Reverts if the new address is zero or not a contract\r\n    function setBSKTUtils(address _bsktUtils) external onlyRole(UPGRADER_ROLE) {\r\n        bsktUtils = _bsktUtils;\r\n        emit BSKTUtilsUpdated(_bsktUtils);\r\n    }\r\n\r\n    /// @notice Updates the minimum percentage of ALVA required in a basket\r\n    /// @dev Controls the minimum ALVA token allocation in all baskets\r\n    /// @param _minPercentALVA New minimum percentage\r\n    function updateMinPercentALVA(uint16 _minPercentALVA) external onlyRole(ADMIN_ROLE) {\r\n        if (_minPercentALVA < 100 || _minPercentALVA > 5000) {\r\n            revert InvalidAlvaPercentage(_minPercentALVA, 100, 5000);\r\n        }\r\n        minPercentALVA = _minPercentALVA;\r\n\r\n        emit MinAlvaPercentageUpdated(_minPercentALVA);\r\n    }\r\n\r\n    /// @notice Updates the collection URI\r\n    /// @dev Sets the collection metadata URI for NFT marketplaces\r\n    /// @param _collectionURI New collection URI\r\n    function updateCollectionURI(string calldata _collectionURI) external onlyRole(URI_MANAGER_ROLE) {\r\n        if (bytes(_collectionURI).length == 0) revert EmptyStringParameter(\"URI\");\r\n        collectionUri = _collectionURI;\r\n\r\n        emit CollectionURIUpdated(_collectionURI);\r\n    }\r\n\r\n    /// @notice Updates the royalty percentage\r\n    /// @dev Sets the percentage of sales that go to the royalty receiver\r\n    /// @param _royaltyPercentage New royalty percentage (in basis points)\r\n    function updateRoyaltyPercentage(\r\n        uint256 _royaltyPercentage\r\n    ) external onlyRole(FEE_MANAGER_ROLE) {\r\n        if (_royaltyPercentage == 0 || _royaltyPercentage > 300) {\r\n            revert InvalidRoyaltyPercentage(_royaltyPercentage, 1, 300);\r\n        }\r\n\r\n        if (_royaltyPercentage == royaltyPercentage) {\r\n            revert DuplicateRoyaltyValue();\r\n        }\r\n\r\n        royaltyPercentage = _royaltyPercentage;\r\n\r\n        emit RoyaltyUpdated(_royaltyPercentage);\r\n    }\r\n\r\n    /// @notice Updates the royalty receiver address\r\n    /// @dev Sets the address that receives royalties from NFT sales\r\n    /// @param _royaltyReceiver  New royalty receiver address\r\n    function updateRoyaltyReceiver(\r\n        address _royaltyReceiver \r\n    ) external onlyRole(FEE_MANAGER_ROLE) {\r\n        if (_royaltyReceiver == address(0) || _royaltyReceiver == royaltyReceiver) revert InvalidAddress();\r\n        royaltyReceiver = _royaltyReceiver;\r\n\r\n        emit RoyaltyReceiverUpdated(_royaltyReceiver);\r\n    }\r\n\r\n    /// @notice Updates the minimum BSKT creation amount\r\n    /// @dev Sets a new minimum amount for BSKT creation\r\n    /// @param _minBSKTCreationAmount New minimum BSKT creation amount (must be greater than zero)\r\n    function updateMinBSKTCreationAmount(\r\n        uint256 _minBSKTCreationAmount\r\n    ) external onlyRole(ADMIN_ROLE) {\r\n        if (_minBSKTCreationAmount == 0 || _minBSKTCreationAmount == minBSKTCreationAmount) revert InvalidAmount();\r\n        minBSKTCreationAmount = _minBSKTCreationAmount;\r\n        emit MinBSKTCreationAmountUpdated(msg.sender, _minBSKTCreationAmount);\r\n    }\r\n\r\n    /// @notice Adds a contract to the whitelist\r\n    /// @dev Allows the specified contract to interact with basket tokens\r\n    /// @param contractAddr Address of the contract to whitelist\r\n    function addWhitelistedContract(address contractAddr) external onlyRole(WHITELIST_MANAGER_ROLE) {\r\n        if (\r\n            contractAddr == address(0) || \r\n            whitelistedContracts[contractAddr] || \r\n            !AddressUpgradeable.isContract(contractAddr)\r\n        ) {\r\n                revert InvalidWhitelistAddress(\r\n                contractAddr,\r\n                whitelistedContracts[contractAddr]\r\n            );\r\n        }\r\n        whitelistedContracts[contractAddr] = true;\r\n        emit ContractWhitelisted(contractAddr);\r\n    }\r\n\r\n    /// @notice Dewhitelist the contract address\r\n    /// @dev Revokes permission for the contract to interact with basket tokens\r\n    /// @param contractAddr Address of the contract be dewhitelisted\r\n    function dewhitelistContract(\r\n        address contractAddr\r\n    ) external onlyRole(WHITELIST_MANAGER_ROLE) {\r\n        if (!whitelistedContracts[contractAddr]) {\r\n            revert InvalidWhitelistAddress(\r\n                contractAddr,\r\n                whitelistedContracts[contractAddr]\r\n            );\r\n        }\r\n        whitelistedContracts[contractAddr] = false;\r\n        emit ContractRemovedFromWhitelist(contractAddr);\r\n    }\r\n\r\n    /// @notice Updates the platform fee configuration for BSKT creation, contribution, and withdrawal\r\n    /// @param _bsktCreationFee The new fee percentage for BSKT creation (in 10000 precision)\r\n    /// @param _contributionFee The new fee percentage for contributing ETH (in 10000 precision)\r\n    /// @param _withdrawalFee The new fee percentage for withdrawals (in 10000 precision)\r\n    /// @dev Reverts if any fee exceeds the precision limit\r\n    function setPlatformFeeConfig(\r\n        uint16 _bsktCreationFee,\r\n        uint16 _contributionFee,\r\n        uint16 _withdrawalFee\r\n    ) external onlyRole(FEE_MANAGER_ROLE) {\r\n        // Validate that the fee values are within the correct range (0 - 0.5%)\r\n        if (_bsktCreationFee > DEFAULT_FEE || _contributionFee > DEFAULT_FEE || _withdrawalFee > DEFAULT_FEE)  revert InvalidFee();\r\n        \r\n        // Update the platform fee configuration\r\n        platformFeeConfig = PlatformFeeConfig({\r\n            bsktCreationFee: _bsktCreationFee,\r\n            contributionFee: _contributionFee,\r\n            withdrawalFee: _withdrawalFee,\r\n            feeCollector: platformFeeConfig.feeCollector // keep feeCollector unchanged\r\n        });\r\n\r\n        // Emit event for fee update\r\n        emit PlatformFeesUpdated(_bsktCreationFee, _contributionFee, _withdrawalFee);\r\n    }\r\n\r\n    /// @notice Updates the fee collector address used to collect platform fees\r\n    /// @param _feeCollector The new address to receive the platform fees\r\n    /// @dev Reverts if the new address is zero or the same as the current one\r\n    function setFeeCollector(address _feeCollector) external onlyRole(FEE_MANAGER_ROLE) {\r\n        // Validate the feeCollector address\r\n        if (_feeCollector == address(0) || _feeCollector == platformFeeConfig.feeCollector) revert InvalidAddress();\r\n\r\n        // Update the fee collector address\r\n        platformFeeConfig.feeCollector = _feeCollector;\r\n\r\n        // Emit event for fee collector update\r\n        emit FeeCollectorUpdated(_feeCollector);\r\n    }\r\n\r\n    /// @notice Pauses the contract\r\n    /// @dev Only callable by the user with ADMIN_ROLE\r\n    function pause() external onlyRole(ADMIN_ROLE) {\r\n        _pause();\r\n    }\r\n\r\n    /// @notice Unpauses the contract\r\n    /// @dev Only callable by the user with ADMIN_ROLE\r\n    function unpause() external onlyRole(ADMIN_ROLE) {\r\n        _unpause();\r\n    }\r\n\r\n    /// @notice Gets the total number of BSKT contracts created\r\n    /// @dev Useful for enumeration and statistics\r\n    /// @return Total number of BSKT contracts in the system\r\n    function totalBSKT() external view returns (uint) {\r\n        return bsktList.length;\r\n    }\r\n\r\n    /// @notice Gets a BSKT contract at a specific index\r\n    /// @dev Enables enumeration of all baskets in the system\r\n    /// @param index Index in the bsktList array\r\n    /// @return Address of the BSKT contract\r\n    function getBSKTAtIndex(uint256 index) external view returns (address) {\r\n        require(index < bsktList.length, \"Index out of bounds\");\r\n        return bsktList[index];\r\n    }\r\n\r\n    /// @notice Calculates the management fee based on LP supply and timeframe\r\n    /// @dev Uses compound interest formula with PRBMath for precise calculations\r\n    /// @dev Formula: LP_fee = LP_supply * (1 - (1 - fee_rate)^months) / (1 - (1 - (1 - fee_rate)^months))\r\n    /// @param months Number of months to calculate fee for\r\n    /// @param lpSupply Total supply of LP tokens in the basket\r\n    /// @return Amount of LP tokens to be claimed as management fee\r\n    function calMgmtFee(uint256 months, uint256 lpSupply) external view returns (uint256) {\r\n\r\n        // Compute (1 - FeeRate)\r\n        uint256 oneMinusFeeRate = 1e18 - monthlyFeeRate;\r\n\r\n        // Compute (1 - FeeRate) ^ months using PRBMath's pow\r\n        uint256 powerValue = unwrap(powu(UD60x18.wrap(oneMinusFeeRate), months));\r\n\r\n        // Compute numerator: (1 - powerValue) * LP_Supply\r\n        uint256 numerator = (1e18 - powerValue) * lpSupply;\r\n\r\n        // Final result: FeeAmount = numerator / powerValue\r\n        uint256 lpFeeAmount  = numerator / powerValue;\r\n\r\n        return lpFeeAmount;\r\n    }\r\n\r\n    /// @notice Returns the contract URI for metadata\r\n    /// @dev Used by NFT marketplaces to display collection information\r\n    /// @return The collection URI string\r\n    function getContractURI() external view returns (string memory) {\r\n        return collectionUri;\r\n    }\r\n\r\n    \r\n    /// @notice Returns true if the contract is paused, and false otherwise.\r\n    function paused() public view override(PausableUpgradeable, IFactory) returns (bool) {\r\n        return super.paused();\r\n    }\r\n\r\n    /// @notice Checks if a contract is whitelisted\r\n    /// @dev Used by BSKT contracts to verify if interaction is permitted\r\n    /// @param contractAddr Address of the contract to check\r\n    /// @return True if the contract is whitelisted, false otherwise\r\n    function isWhitelistedContract(\r\n        address contractAddr\r\n    ) external view returns (bool) {\r\n        return whitelistedContracts[contractAddr];\r\n    }\r\n\r\n    /// @notice Retrieves the current platform fee configuration\r\n    /// @dev Returns all fee percentages and the fee collector address\r\n    /// @return bsktCreationFee Fee percentage for BSKT creation\r\n    /// @return contributionFee Fee percentage for contributions\r\n    /// @return withdrawalFee Fee percentage for withdrawals\r\n    /// @return feeCollector Address that receives all collected fees\r\n    function getPlatformFeeConfig() external view returns (uint16, uint16, uint16, address)\r\n    {\r\n        return (\r\n            platformFeeConfig.bsktCreationFee,\r\n            platformFeeConfig.contributionFee,\r\n            platformFeeConfig.withdrawalFee,\r\n            platformFeeConfig.feeCollector\r\n        );\r\n    }\r\n\r\n\r\n    // ===============================================\r\n    // Internal Functions\r\n    // ===============================================\r\n\r\n    /// @notice Initializes a new BSKT contract with its associated BSKTPair\r\n    /// @dev Creates both contracts using BeaconProxy pattern and links them together\r\n    /// @param _name Name of the basket token\r\n    /// @param _symbol Symbol of the basket token\r\n    /// @param _tokens Array of token addresses in the basket\r\n    /// @param _weights Array of weights for each token\r\n    /// @param _tokenURI URI for the basket token metadata\r\n    /// @param _id Unique identifier for the basket\r\n    /// @param _description Human-readable description of the basket\r\n    /// @return _bskt Address of the created BSKT contract\r\n    /// @return _bsktPair Address of the created BSKTPair contract\r\n    function _initializeBSKTWithPair(\r\n        string calldata _name,\r\n        string calldata _symbol,\r\n        address[] memory _tokens,\r\n        uint256[] calldata _weights,\r\n        string calldata _tokenURI,\r\n        string calldata _id,\r\n        string memory _description\r\n    ) internal returns (address _bskt, address _bsktPair) {\r\n        BeaconProxy bsktPair = new BeaconProxy(\r\n            bsktPairImplementation,\r\n            abi.encodeWithSelector(\r\n                IBSKTPair.initialize.selector,\r\n                address(this),\r\n                _symbol,\r\n                _tokens\r\n            )\r\n        );\r\n\r\n        _bsktPair = address(bsktPair);\r\n\r\n        BeaconProxy bskt = new BeaconProxy(\r\n            bsktImplementation,\r\n            abi.encodeWithSelector(\r\n                IBSKT.initialize.selector,\r\n                _name,\r\n                _symbol,\r\n                msg.sender,\r\n                address(this),\r\n                _tokens,\r\n                _weights,\r\n                _bsktPair,\r\n                _tokenURI,\r\n                _id,\r\n                _description\r\n            )\r\n        );\r\n\r\n        _bskt = address(bskt);\r\n    }\r\n\r\n    // ===============================================\r\n    // Public View/Pure Functions\r\n    // ===============================================\r\n\r\n    /// @notice Gets the expected output amount for a swap\r\n    /// @dev Wrapper for Uniswap router's getAmountsOut function\r\n    /// @param _amount Input amount\r\n    /// @param _path Path for the swap\r\n    /// @return Expected output amount\r\n    function getAmountsOut(\r\n        uint256 _amount,\r\n        address[] memory _path\r\n    ) public view returns (uint) {\r\n        // Check if path contains identical addresses\r\n        if (_path.length == 2 && _path[0] == _path[1]) {\r\n            // If the path is from a token to itself, return the amount directly\r\n            return _amount;\r\n        }\r\n        return IUniswapV2Router(router).getAmountsOut(_amount, _path)[_path.length - 1];\r\n    }\r\n\r\n    /// @notice Creates a path array for token swaps\r\n    /// @dev Helper function for Uniswap router interactions\r\n    /// @param _tokenA First token in the path\r\n    /// @param _tokenB Second token in the path\r\n    /// @return Path array containing both token addresses\r\n    function getPath(\r\n        address _tokenA,\r\n        address _tokenB\r\n    ) public pure returns (address[] memory) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = _tokenA;\r\n        path[1] = _tokenB;\r\n\r\n        return path;\r\n    }\r\n\r\n}\r\n"}, "contracts/interfaces/IBSKT.sol": {"content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.30;\r\n\r\ninterface IBSKT {\r\n    function initialize(\r\n        string calldata _name,\r\n        string calldata _symbol,\r\n        address _owner,\r\n        address _factoryAddress,\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _weights,\r\n        address _bsktPair,\r\n        string calldata _tokenURI,\r\n        string calldata _id,\r\n        string calldata _description\r\n    ) external;\r\n\r\n    function contribute(uint256[] calldata minAmountsOut, bytes calldata signature, uint256 _deadline) external payable;\r\n    function withdraw(uint256 _liquidity) external;\r\n    function withdrawETH(uint256 _liquidity, uint256[] calldata _minAmountsOutFee, bytes calldata _signatureFee, uint256[] calldata _minAmountsOut, bytes calldata _signature, uint256 _deadline) external;\r\n    function rebalance(address[] calldata _newTokens, uint256[] calldata _newWeights, uint256[] calldata _minAmountsOutnewPrev, bytes calldata _signaturenewPrev, uint256[] calldata _minAmountsOutnew, bytes calldata _signaturenew, uint256 _deadline) external;\r\n    function emergencyStable(address[] calldata _newTokens, uint256[] calldata _newWeights, uint256[] calldata _minAmountsOutnewPrev, bytes calldata _signaturenewPrev, uint256[] calldata _minAmountsOutnew, bytes calldata _signaturenew, uint256 _deadline) external;\r\n    function claimFee(uint256 amount, uint256[] calldata _minAmountsOut, bytes calldata _signature, uint256 _deadline, bool withdrawIndividualTokens, bool withdrawFullAmount) external;\r\n    function getTokenDetails(uint256 _index) external view returns (address token, uint256 weight);\r\n    function getTokenDetails() external view returns (address[] memory tokens, uint256[] memory weights);\r\n    function totalTokens() external view returns (uint256 tokenLength);\r\n    function getTokenValueByWETH() external view returns (uint256 value);\r\n    function contractURI() external view returns (string memory);\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n    function royaltyInfo(uint256, uint256) external view returns (address receiver, uint256 royaltyAmount);\r\n    function getOwner() external view returns (address owner);\r\n}"}, "contracts/interfaces/IBSKTPair.sol": {"content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.30;\r\n\r\ninterface IBSKTPair {\r\n    function initialize(address factoryAddress, string memory name, address[] calldata tokens) external;\r\n\r\n    function mint(address _to, uint256[] calldata amounts) external returns (uint256 liquidity);\r\n\r\n    function burn(address _to) external returns (uint256[] memory amounts);\r\n\r\n    function transferTokensToOwner() external returns (uint256[] memory amounts);\r\n\r\n    function updateTokens(address[] calldata _tokens, uint256[] calldata _tokensReserve) external;\r\n\r\n    function setReentrancyGuardStatus(bool _state) external;\r\n\r\n    function updateCollectedFee(uint256 _amount) external;\r\n\r\n    function distMgmtFee() external;\r\n\r\n    function collectedFee() external view returns (uint256 collectedFee);\r\n\r\n    function getTokenAddress(uint256 _index) external view returns (address);\r\n\r\n    function getTokenReserve(uint256 _index) external view returns (uint256);\r\n\r\n    function getTokenList() external view returns (address[] memory);\r\n\r\n    function getTokensReserve() external view returns (uint256[] memory);\r\n\r\n    function getTotalMgmtFee() external view returns (uint);\r\n\r\n    function calculateShareETH(uint256 _amountLP) external view returns (uint256 amountETH);\r\n\r\n    function calculateShareTokens(uint256 _amountLP) external view returns (uint256[] memory amountTokens);\r\n\r\n    function getTokenAndUserBal(address _user) external view returns (uint256[] memory, uint256, uint256);\r\n}\r\n"}, "contracts/interfaces/IBSKTUtils.sol": {"content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.30;\r\n\r\ninterface IBSKTUtils {\r\n    function initialize(\r\n        address _signer\r\n    ) external;\r\n\r\n    function verifySignature(\r\n        uint256 deadline,\r\n        address[] calldata tokens,\r\n        uint256[] calldata weights,\r\n        uint256[] calldata amount,\r\n        bytes calldata signature\r\n    ) external view returns (bool);\r\n}"}, "contracts/interfaces/IERC20.sol": {"content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.30;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function burn(uint256 amount) external; \r\n\r\n    function burnTokens(address account, uint256 amount) external;\r\n\r\n    function burnFrom(address account, uint256 amount) external;\r\n\r\n    function mint(address account, uint256 amount) external;\r\n}\r\n"}, "contracts/interfaces/IFactory.sol": {"content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.30;\r\n\r\ninterface IFactory {\r\n    // --- View Functions ---\r\n    function alva() external view returns (address);\r\n    function minPercentALVA() external view returns (uint16);\r\n    function minLpWithdrawal() external view returns (uint256);\r\n    function bsktImplementation() external view returns (address);\r\n    function bsktPairImplementation() external view returns (address);\r\n    function royaltyReceiver() external view returns (address);\r\n    function royaltyPercentage() external view returns (uint256);\r\n    function router() external view returns (address);\r\n    function weth() external view returns (address);\r\n    function minBSKTCreationAmount() external view returns (uint256);\r\n    function monthlyFeeRate() external view returns (uint256);\r\n    function collectionUri() external view returns (string memory);\r\n    function totalBSKT() external view returns (uint);\r\n    function getBSKTAtIndex(uint256 index) external view returns (address);\r\n    function getPlatformFeeConfig() external view returns (uint16, uint16, uint16, address);\r\n    function getContractURI() external view returns (string memory);\r\n    function paused() external view returns (bool);\r\n    function isWhitelistedContract(address contractAddr) external view returns (bool);\r\n    function calMgmtFee(uint256 months, uint256 lpSupply) external view returns (uint256);\r\n    function getAmountsOut(uint256 _amount, address[] memory _path) external view returns (uint);\r\n    function getPath(address _tokenA, address _tokenB) external pure returns (address[] memory);\r\n    function bsktUtils() external view returns (address);\r\n\r\n    // --- Mutative Functions ---\r\n    function initialize(\r\n        address _alva,\r\n        uint16 _minPercentALVA,\r\n        address _bsktImplementation,\r\n        address _bsktPairImplementation,\r\n        uint256 _monthlyFeeRate,\r\n        address _royaltyReceiver,\r\n        string calldata _collectionUri,\r\n        address _feeCollector,\r\n        address _defaultMarketplace,\r\n        address _routerAddress,\r\n        address _wethAddress,\r\n        uint256 _minBSKTCreationAmount\r\n    ) external;\r\n\r\n    function setMinLpWithdrawal(uint256 newMin) external;\r\n    function createBSKT(\r\n        string calldata _name,\r\n        string calldata _symbol,\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _weights,\r\n        string calldata _tokenURI,\r\n        uint256[] calldata _minAmountsOut,\r\n        bytes calldata _signature,\r\n        string calldata _id,\r\n        string calldata _description,\r\n        uint256 _deadline\r\n    ) external payable;\r\n    function updateBSKTImplementation(address _bsktImplementation) external;\r\n    function updateBSKTPairImplementation(address _bsktPairImplementation) external;\r\n    function updateAlva(address _alva) external;\r\n    function updateMinPercentALVA(uint16 _minPercentALVA) external;\r\n    function updateCollectionURI(string calldata _collectionURI) external;\r\n    function updateRoyaltyPercentage(uint256 _royaltyPercentage) external;\r\n    function updateRoyaltyReceiver(address _royaltyReceiver) external;\r\n    function updateMinBSKTCreationAmount(uint256 _minBSKTCreationAmount) external;\r\n    function addWhitelistedContract(address contractAddr) external;\r\n    function dewhitelistContract(address contractAddr) external;\r\n    function setPlatformFeeConfig(uint16 _bsktCreationFee, uint16 _contributionFee, uint16 _withdrawalFee) external;\r\n    function setFeeCollector(address _feeCollector) external;\r\n    function pause() external;\r\n    function unpause() external;\r\n}"}, "contracts/interfaces/IUniswap.sol": {"content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.30;\r\n\r\ninterface IUniswapV2Router {\r\n    function getAmountsOut(uint amountIn, address[] memory path)\r\n        external\r\n        view\r\n        returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    function getPair(address tokenA, address tokenB)\r\n        external\r\n        view\r\n        returns (address pair);\r\n}\r\n"}, "contracts/interfaces/IWETH.sol": {"content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.30;\r\n\r\ninterface IWETH {\r\n    // Events\r\n    event Deposit(address indexed dst, uint256 wad);\r\n    event Withdrawal(address indexed src, uint256 wad);\r\n    \r\n    // Functions\r\n    function deposit() external payable;\r\n    \r\n    // No-argument withdraw function (withdraws all)\r\n    function withdraw() external;\r\n    \r\n    // Withdraw with specific amount\r\n    function withdraw(uint wad) external;\r\n    \r\n    function mint(address to, uint256 amount) external;\r\n    \r\n    function burn(address from, uint256 amount) external;\r\n    \r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    \r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n    \r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n    \r\n    // Additional ERC20 functions\r\n    function balanceOf(address account) external view returns (uint256);\r\n    \r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n"}}, "settings": {"optimizer": {"enabled": true}, "viaIR": false, "evmVersion": "paris", "outputSelection": {"*": {"*": ["evm.legacyAssembly"]}}, "metadata": {"useLiteralContent": true}}}