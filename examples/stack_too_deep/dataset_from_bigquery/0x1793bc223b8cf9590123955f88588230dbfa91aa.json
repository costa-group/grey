{"language": "Solidity", "sources": {"@1inch/solidity-utils/contracts/interfaces/IDaiLikePermit.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\n/**\n * @title IDaiLikePermit\n * @dev Interface for Dai-like permit function allowing token spending via signatures.\n */\ninterface IDaiLikePermit {\n    /**\n     * @notice Approves spending of tokens via off-chain signatures.\n     * @param holder Token holder's address.\n     * @param spender Spender's address.\n     * @param nonce Current nonce of the holder.\n     * @param expiry Time when the permit expires.\n     * @param allowed True to allow, false to disallow spending.\n     * @param v, r, s Signature components.\n     */\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"}, "@1inch/solidity-utils/contracts/interfaces/IERC7597Permit.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\n/**\n * @title IERC7597Permit\n * @dev A new extension for ERC-2612 permit, which has already been added to USDC v2.2.\n */\ninterface IERC7597Permit {\n    /**\n     * @notice Update allowance with a signed permit.\n     * @dev Signature bytes can be used for both EOA wallets and contract wallets.\n     * @param owner Token owner's address (Authorizer).\n     * @param spender Spender's address.\n     * @param value Amount of allowance.\n     * @param deadline The time at which the signature expires (unixtime).\n     * @param signature Unstructured bytes signature signed by an EOA wallet or a contract wallet.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        bytes memory signature\n    ) external;\n}\n"}, "@1inch/solidity-utils/contracts/interfaces/IPermit2.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\n/**\n * @title IPermit2\n * @dev Interface for a flexible permit system that extends ERC20 tokens to support permits in tokens lacking native permit functionality.\n */\ninterface IPermit2 {\n    /**\n     * @dev Struct for holding permit details.\n     * @param token ERC20 token address for which the permit is issued.\n     * @param amount The maximum amount allowed to spend.\n     * @param expiration Timestamp until which the permit is valid.\n     * @param nonce An incrementing value for each signature, unique per owner, token, and spender.\n     */\n    struct PermitDetails {\n        address token;\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n\n    /**\n     * @dev Struct for a single token allowance permit.\n     * @param details Permit details including token, amount, expiration, and nonce.\n     * @param spender Address authorized to spend the tokens.\n     * @param sigDeadline Deadline for the permit signature, ensuring timeliness of the permit.\n     */\n    struct PermitSingle {\n        PermitDetails details;\n        address spender;\n        uint256 sigDeadline;\n    }\n\n    /**\n     * @dev Struct for packed allowance data to optimize storage.\n     * @param amount Amount allowed.\n     * @param expiration Permission expiry timestamp.\n     * @param nonce Unique incrementing value for tracking allowances.\n     */\n    struct PackedAllowance {\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n\n    /**\n     * @notice Executes a token transfer from one address to another.\n     * @param user The token owner's address.\n     * @param spender The address authorized to spend the tokens.\n     * @param amount The amount of tokens to transfer.\n     * @param token The address of the token being transferred.\n     */\n    function transferFrom(address user, address spender, uint160 amount, address token) external;\n\n    /**\n     * @notice Issues a permit for spending tokens via a signed authorization.\n     * @param owner The token owner's address.\n     * @param permitSingle Struct containing the permit details.\n     * @param signature The signature proving the owner authorized the permit.\n     */\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n\n    /**\n     * @notice Retrieves the allowance details between a token owner and spender.\n     * @param user The token owner's address.\n     * @param token The token address.\n     * @param spender The spender's address.\n     * @return The packed allowance details.\n     */\n    function allowance(address user, address token, address spender) external view returns (PackedAllowance memory);\n\n    /**\n     * @notice Approves the spender to use up to amount of the specified token up until the expiration\n     * @param token The token to approve\n     * @param spender The spender address to approve\n     * @param amount The approved amount of the token\n     * @param expiration The timestamp at which the approval is no longer valid\n     * @dev The packed allowance also holds a nonce, which will stay unchanged in approve\n     * @dev Setting amount to type(uint160).max sets an unlimited approval\n     */\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n}\n"}, "@1inch/solidity-utils/contracts/interfaces/IWETH.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title IWETH\n * @dev Interface for wrapper as WETH-like token.\n */\ninterface IWETH is IERC20 {\n    /**\n     * @notice Emitted when Ether is deposited to get wrapper tokens.\n     */\n    event Deposit(address indexed dst, uint256 wad);\n\n    /**\n     * @notice Emitted when wrapper tokens is withdrawn as Ether.\n     */\n    event Withdrawal(address indexed src, uint256 wad);\n\n    /**\n     * @notice Deposit Ether to get wrapper tokens.\n     */\n    function deposit() external payable;\n\n    /**\n     * @notice Withdraw wrapped tokens as Ether.\n     * @param amount Amount of wrapped tokens to withdraw.\n     */\n    function withdraw(uint256 amount) external;\n}\n"}, "@1inch/solidity-utils/contracts/libraries/RevertReasonForwarder.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\n/**\n * @title RevertReasonForwarder\n * @notice Provides utilities for forwarding and retrieving revert reasons from failed external calls.\n */\nlibrary RevertReasonForwarder {\n    /**\n     * @dev Forwards the revert reason from the latest external call.\n     * This method allows propagating the revert reason of a failed external call to the caller.\n     */\n    function reRevert() internal pure {\n        // bubble up revert reason from latest external call\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n            returndatacopy(ptr, 0, returndatasize())\n            revert(ptr, returndatasize())\n        }\n    }\n\n    /**\n     * @dev Retrieves the revert reason from the latest external call.\n     * This method enables capturing the revert reason of a failed external call for inspection or processing.\n     * @return reason The latest external call revert reason.\n     */\n    function reReason() internal pure returns (bytes memory reason) {\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            reason := mload(0x40)\n            let length := returndatasize()\n            mstore(reason, length)\n            returndatacopy(add(reason, 0x20), 0, length)\n            mstore(0x40, add(reason, add(0x20, length)))\n        }\n    }\n}\n"}, "@1inch/solidity-utils/contracts/libraries/SafeERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport \"../interfaces/IDaiLikePermit.sol\";\nimport \"../interfaces/IPermit2.sol\";\nimport \"../interfaces/IERC7597Permit.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../libraries/RevertReasonForwarder.sol\";\n\n/**\n * @title Implements efficient safe methods for ERC20 interface.\n * @notice Compared to the standard ERC20, this implementation offers several enhancements:\n * 1. more gas-efficient, providing significant savings in transaction costs.\n * 2. support for different permit implementations\n * 3. forceApprove functionality\n * 4. support for WETH deposit and withdraw\n */\nlibrary SafeERC20 {\n    error SafeTransferFailed();\n    error SafeTransferFromFailed();\n    error ForceApproveFailed();\n    error SafeIncreaseAllowanceFailed();\n    error SafeDecreaseAllowanceFailed();\n    error SafePermitBadLength();\n    error Permit2TransferAmountTooHigh();\n\n    // Uniswap Permit2 address\n    address private constant _PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n    bytes4 private constant _PERMIT_LENGTH_ERROR = 0x68275857;  // SafePermitBadLength.selector\n    uint256 private constant _RAW_CALL_GAS_LIMIT = 5000;\n\n    /**\n     * @notice Fetches the balance of a specific ERC20 token held by an account.\n     * Consumes less gas then regular `ERC20.balanceOf`.\n     * @dev Note that the implementation does not perform dirty bits cleaning, so it is the\n     * responsibility of the caller to make sure that the higher 96 bits of the `account` parameter are clean.\n     * @param token The IERC20 token contract for which the balance will be fetched.\n     * @param account The address of the account whose token balance will be fetched.\n     * @return tokenBalance The balance of the specified ERC20 token held by the account.\n     */\n    function safeBalanceOf(\n        IERC20 token,\n        address account\n    ) internal view returns(uint256 tokenBalance) {\n        bytes4 selector = IERC20.balanceOf.selector;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            mstore(0x00, selector)\n            mstore(0x04, account)\n            let success := staticcall(gas(), token, 0x00, 0x24, 0x00, 0x20)\n            tokenBalance := mload(0)\n\n            if or(iszero(success), lt(returndatasize(), 0x20)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens from one address to another.\n     * @dev If permit2 is true, uses the Permit2 standard; otherwise uses the standard ERC20 transferFrom.\n     * Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `from` and `to` parameters are clean.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param amount The amount of tokens to transfer.\n     * @param permit2 If true, uses the Permit2 standard for the transfer; otherwise uses the standard ERC20 transferFrom.\n     */\n    function safeTransferFromUniversal(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        bool permit2\n    ) internal {\n        if (permit2) {\n            safeTransferFromPermit2(token, from, to, amount);\n        } else {\n            safeTransferFrom(token, from, to, amount);\n        }\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens from one address to another using the ERC20 standard.\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `from` and `to` parameters are clean.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param amount The amount of tokens to transfer.\n     */\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bytes4 selector = token.transferFrom.selector;\n        bool success;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), from)\n            mstore(add(data, 0x24), to)\n            mstore(add(data, 0x44), amount)\n            success := call(gas(), token, 0, data, 100, 0x0, 0x20)\n            if success {\n                switch returndatasize()\n                case 0 {\n                    success := gt(extcodesize(token), 0)\n                }\n                default {\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\n                }\n            }\n        }\n        if (!success) revert SafeTransferFromFailed();\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens from one address to another using the Permit2 standard.\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `from` and `to` parameters are clean.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param amount The amount of tokens to transfer.\n     */\n    function safeTransferFromPermit2(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (amount > type(uint160).max) revert Permit2TransferAmountTooHigh();\n        bytes4 selector = IPermit2.transferFrom.selector;\n        bool success;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), from)\n            mstore(add(data, 0x24), to)\n            mstore(add(data, 0x44), amount)\n            mstore(add(data, 0x64), token)\n            success := call(gas(), _PERMIT2, 0, data, 0x84, 0x0, 0x0)\n            if success {\n                success := gt(extcodesize(_PERMIT2), 0)\n            }\n        }\n        if (!success) revert SafeTransferFromFailed();\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens to another address.\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `to` parameter are clean.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param value The amount of tokens to transfer.\n     */\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        if (!_makeCall(token, token.transfer.selector, to, value)) {\n            revert SafeTransferFailed();\n        }\n    }\n\n    /**\n     * @notice Attempts to approve a spender to spend a certain amount of tokens.\n     * @dev If `approve(from, to, amount)` fails, it tries to set the allowance to zero, and retries the `approve` call.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `spender` parameter are clean.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n    function forceApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        if (!_makeCall(token, token.approve.selector, spender, value)) {\n            if (\n                !_makeCall(token, token.approve.selector, spender, 0) ||\n                !_makeCall(token, token.approve.selector, spender, value)\n            ) {\n                revert ForceApproveFailed();\n            }\n        }\n    }\n\n    /**\n     * @notice Safely increases the allowance of a spender.\n     * @dev Increases with safe math check. Checks if the increased allowance will overflow, if yes, then it reverts the transaction.\n     * Then uses `forceApprove` to increase the allowance.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `spender` parameter are clean.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to increase the allowance by.\n     */\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 allowance = token.allowance(address(this), spender);\n        if (value > type(uint256).max - allowance) revert SafeIncreaseAllowanceFailed();\n        forceApprove(token, spender, allowance + value);\n    }\n\n    /**\n     * @notice Safely decreases the allowance of a spender.\n     * @dev Decreases with safe math check. Checks if the decreased allowance will underflow, if yes, then it reverts the transaction.\n     * Then uses `forceApprove` to increase the allowance.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `spender` parameter are clean.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to decrease the allowance by.\n     */\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 allowance = token.allowance(address(this), spender);\n        if (value > allowance) revert SafeDecreaseAllowanceFailed();\n        forceApprove(token, spender, allowance - value);\n    }\n\n    /**\n     * @notice Attempts to execute the `permit` function on the provided token with the sender and contract as parameters.\n     * Permit type is determined automatically based on permit calldata (IERC20Permit, IDaiLikePermit, and IPermit2).\n     * @dev Wraps `tryPermit` function and forwards revert reason if permit fails.\n     * @param token The IERC20 token to execute the permit function on.\n     * @param permit The permit data to be used in the function call.\n     */\n    function safePermit(IERC20 token, bytes calldata permit) internal {\n        if (!tryPermit(token, msg.sender, address(this), permit)) RevertReasonForwarder.reRevert();\n    }\n\n    /**\n     * @notice Attempts to execute the `permit` function on the provided token with custom owner and spender parameters.\n     * Permit type is determined automatically based on permit calldata (IERC20Permit, IDaiLikePermit, and IPermit2).\n     * @dev Wraps `tryPermit` function and forwards revert reason if permit fails.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `owner` and `spender` parameters are clean.\n     * @param token The IERC20 token to execute the permit function on.\n     * @param owner The owner of the tokens for which the permit is made.\n     * @param spender The spender allowed to spend the tokens by the permit.\n     * @param permit The permit data to be used in the function call.\n     */\n    function safePermit(IERC20 token, address owner, address spender, bytes calldata permit) internal {\n        if (!tryPermit(token, owner, spender, permit)) RevertReasonForwarder.reRevert();\n    }\n\n    /**\n     * @notice Attempts to execute the `permit` function on the provided token with the sender and contract as parameters.\n     * @dev Invokes `tryPermit` with sender as owner and contract as spender.\n     * @param token The IERC20 token to execute the permit function on.\n     * @param permit The permit data to be used in the function call.\n     * @return success Returns true if the permit function was successfully executed, false otherwise.\n     */\n    function tryPermit(IERC20 token, bytes calldata permit) internal returns(bool success) {\n        return tryPermit(token, msg.sender, address(this), permit);\n    }\n\n    /**\n     * @notice The function attempts to call the permit function on a given ERC20 token.\n     * @dev The function is designed to support a variety of permit functions, namely: IERC20Permit, IDaiLikePermit, IERC7597Permit and IPermit2.\n     * It accommodates both Compact and Full formats of these permit types.\n     * Please note, it is expected that the `expiration` parameter for the compact Permit2 and the `deadline` parameter\n     * for the compact Permit are to be incremented by one before invoking this function. This approach is motivated by\n     * gas efficiency considerations; as the unlimited expiration period is likely to be the most common scenario, and\n     * zeros are cheaper to pass in terms of gas cost. Thus, callers should increment the expiration or deadline by one\n     * before invocation for optimized performance.\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\n     * the caller to make sure that the higher 96 bits of the `owner` and `spender` parameters are clean.\n     * @param token The address of the ERC20 token on which to call the permit function.\n     * @param owner The owner of the tokens. This address should have signed the off-chain permit.\n     * @param spender The address which will be approved for transfer of tokens.\n     * @param permit The off-chain permit data, containing different fields depending on the type of permit function.\n     * @return success A boolean indicating whether the permit call was successful.\n     */\n    function tryPermit(IERC20 token, address owner, address spender, bytes calldata permit) internal returns(bool success) {\n        // load function selectors for different permit standards\n        bytes4 permitSelector = IERC20Permit.permit.selector;\n        bytes4 daiPermitSelector = IDaiLikePermit.permit.selector;\n        bytes4 permit2Selector = IPermit2.permit.selector;\n        bytes4 erc7597PermitSelector = IERC7597Permit.permit.selector;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            // Switch case for different permit lengths, indicating different permit standards\n            switch permit.length\n            // Compact IERC20Permit\n            case 100 {\n                mstore(ptr, permitSelector)     // store selector\n                mstore(add(ptr, 0x04), owner)   // store owner\n                mstore(add(ptr, 0x24), spender) // store spender\n\n                // Compact IERC20Permit.permit(uint256 value, uint32 deadline, uint256 r, uint256 vs)\n                {  // stack too deep\n                    let deadline := shr(224, calldataload(add(permit.offset, 0x20))) // loads permit.offset 0x20..0x23\n                    let vs := calldataload(add(permit.offset, 0x44))                 // loads permit.offset 0x44..0x63\n\n                    calldatacopy(add(ptr, 0x44), permit.offset, 0x20)            // store value     = copy permit.offset 0x00..0x19\n                    mstore(add(ptr, 0x64), sub(deadline, 1))                     // store deadline  = deadline - 1\n                    mstore(add(ptr, 0x84), add(27, shr(255, vs)))                // store v         = most significant bit of vs + 27 (27 or 28)\n                    calldatacopy(add(ptr, 0xa4), add(permit.offset, 0x24), 0x20) // store r         = copy permit.offset 0x24..0x43\n                    mstore(add(ptr, 0xc4), shr(1, shl(1, vs)))                   // store s         = vs without most significant bit\n                }\n                // IERC20Permit.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\n            }\n            // Compact IDaiLikePermit\n            case 72 {\n                mstore(ptr, daiPermitSelector)  // store selector\n                mstore(add(ptr, 0x04), owner)   // store owner\n                mstore(add(ptr, 0x24), spender) // store spender\n\n                // Compact IDaiLikePermit.permit(uint32 nonce, uint32 expiry, uint256 r, uint256 vs)\n                {  // stack too deep\n                    let expiry := shr(224, calldataload(add(permit.offset, 0x04))) // loads permit.offset 0x04..0x07\n                    let vs := calldataload(add(permit.offset, 0x28))               // loads permit.offset 0x28..0x47\n\n                    mstore(add(ptr, 0x44), shr(224, calldataload(permit.offset))) // store nonce   = copy permit.offset 0x00..0x03\n                    mstore(add(ptr, 0x64), sub(expiry, 1))                        // store expiry  = expiry - 1\n                    mstore(add(ptr, 0x84), true)                                  // store allowed = true\n                    mstore(add(ptr, 0xa4), add(27, shr(255, vs)))                 // store v       = most significant bit of vs + 27 (27 or 28)\n                    calldatacopy(add(ptr, 0xc4), add(permit.offset, 0x08), 0x20)  // store r       = copy permit.offset 0x08..0x27\n                    mstore(add(ptr, 0xe4), shr(1, shl(1, vs)))                    // store s       = vs without most significant bit\n                }\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\n            }\n            // IERC20Permit\n            case 224 {\n                mstore(ptr, permitSelector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\n                // IERC20Permit.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\n            }\n            // IDaiLikePermit\n            case 256 {\n                mstore(ptr, daiPermitSelector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\n            }\n            // Compact IPermit2\n            case 96 {\n                // Compact IPermit2.permit(uint160 amount, uint32 expiration, uint32 nonce, uint32 sigDeadline, uint256 r, uint256 vs)\n                mstore(ptr, permit2Selector)  // store selector\n                mstore(add(ptr, 0x04), owner) // store owner\n                mstore(add(ptr, 0x24), token) // store token\n\n                calldatacopy(add(ptr, 0x50), permit.offset, 0x14)             // store amount = copy permit.offset 0x00..0x13\n                // and(0xffffffffffff, ...) - conversion to uint48\n                mstore(add(ptr, 0x64), and(0xffffffffffff, sub(shr(224, calldataload(add(permit.offset, 0x14))), 1))) // store expiration = ((permit.offset 0x14..0x17 - 1) & 0xffffffffffff)\n                mstore(add(ptr, 0x84), shr(224, calldataload(add(permit.offset, 0x18)))) // store nonce = copy permit.offset 0x18..0x1b\n                mstore(add(ptr, 0xa4), spender)                               // store spender\n                // and(0xffffffffffff, ...) - conversion to uint48\n                mstore(add(ptr, 0xc4), and(0xffffffffffff, sub(shr(224, calldataload(add(permit.offset, 0x1c))), 1))) // store sigDeadline = ((permit.offset 0x1c..0x1f - 1) & 0xffffffffffff)\n                mstore(add(ptr, 0xe4), 0x100)                                 // store offset = 256\n                mstore(add(ptr, 0x104), 0x40)                                 // store length = 64\n                calldatacopy(add(ptr, 0x124), add(permit.offset, 0x20), 0x20) // store r      = copy permit.offset 0x20..0x3f\n                calldatacopy(add(ptr, 0x144), add(permit.offset, 0x40), 0x20) // store vs     = copy permit.offset 0x40..0x5f\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\n                success := call(gas(), _PERMIT2, 0, ptr, 0x164, 0, 0)\n            }\n            // IPermit2\n            case 352 {\n                mstore(ptr, permit2Selector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\n                success := call(gas(), _PERMIT2, 0, ptr, 0x164, 0, 0)\n            }\n            // Dynamic length\n            default {\n                mstore(ptr, erc7597PermitSelector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\n                // IERC7597Permit.permit(address owner, address spender, uint256 value, uint256 deadline, bytes memory signature)\n                success := call(gas(), token, 0, ptr, add(permit.length, 4), 0, 0)\n            }\n        }\n    }\n\n    /**\n     * @dev Executes a low level call to a token contract, making it resistant to reversion and erroneous boolean returns.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param selector The function signature that is to be called on the token contract.\n     * @param to The address to which the token amount will be transferred.\n     * @param amount The token amount to be transferred.\n     * @return success A boolean indicating if the call was successful. Returns 'true' on success and 'false' on failure.\n     * In case of success but no returned data, validates that the contract code exists.\n     * In case of returned data, ensures that it's a boolean `true`.\n     */\n    function _makeCall(\n        IERC20 token,\n        bytes4 selector,\n        address to,\n        uint256 amount\n    ) private returns (bool success) {\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), to)\n            mstore(add(data, 0x24), amount)\n            success := call(gas(), token, 0, data, 0x44, 0x0, 0x20)\n            if success {\n                switch returndatasize()\n                case 0 {\n                    success := gt(extcodesize(token), 0)\n                }\n                default {\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Safely deposits a specified amount of Ether into the IWETH contract. Consumes less gas then regular `IWETH.deposit`.\n     * @param weth The IWETH token contract.\n     * @param amount The amount of Ether to deposit into the IWETH contract.\n     */\n    function safeDeposit(IWETH weth, uint256 amount) internal {\n        if (amount > 0) {\n            bytes4 selector = IWETH.deposit.selector;\n            assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n                mstore(0, selector)\n                if iszero(call(gas(), weth, amount, 0, 4, 0, 0)) {\n                    let ptr := mload(0x40)\n                    returndatacopy(ptr, 0, returndatasize())\n                    revert(ptr, returndatasize())\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Safely withdraws a specified amount of wrapped Ether from the IWETH contract. Consumes less gas then regular `IWETH.withdraw`.\n     * @dev Uses inline assembly to interact with the IWETH contract.\n     * @param weth The IWETH token contract.\n     * @param amount The amount of wrapped Ether to withdraw from the IWETH contract.\n     */\n    function safeWithdraw(IWETH weth, uint256 amount) internal {\n        bytes4 selector = IWETH.withdraw.selector;\n        assembly (\"memory-safe\") {  // solhint-disable-line no-inline-assembly\n            mstore(0, selector)\n            mstore(4, amount)\n            if iszero(call(gas(), weth, 0, 0, 0x24, 0, 0)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice Safely withdraws a specified amount of wrapped Ether from the IWETH contract to a specified recipient.\n     * Consumes less gas then regular `IWETH.withdraw`.\n     * @param weth The IWETH token contract.\n     * @param amount The amount of wrapped Ether to withdraw from the IWETH contract.\n     * @param to The recipient of the withdrawn Ether.\n     */\n    function safeWithdrawTo(IWETH weth, uint256 amount, address to) internal {\n        safeWithdraw(weth, amount);\n        if (to != address(this)) {\n            assembly (\"memory-safe\") {  // solhint-disable-line no-inline-assembly\n                if iszero(call(_RAW_CALL_GAS_LIMIT, to, amount, 0, 0, 0, 0)) {\n                    let ptr := mload(0x40)\n                    returndatacopy(ptr, 0, returndatasize())\n                    revert(ptr, returndatasize())\n                }\n            }\n        }\n    }\n}\n"}, "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"}, "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.30;\n\nimport {IERC1822Proxiable} from \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\";\nimport {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport {Initializable} from \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822Proxiable {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `\"5.0.0\"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}\n"}, "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"}, "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.30;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`\u2019s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"}, "@openzeppelin/contracts/interfaces/IERC5267.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.30;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"}, "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {UpgradeableBeacon} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"}, "@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Utils.sol)\n\npragma solidity ^0.8.30;\n\nimport {IBeacon} from \"../beacon/IBeacon.sol\";\nimport {Address} from \"../../utils/Address.sol\";\nimport {StorageSlot} from \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n */\nlibrary ERC1967Utils {\n    // We re-declare ERC-1967 events here because they can't be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.beacon\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn't perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}\n"}, "@openzeppelin/contracts/token/ERC20/ERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"}, "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.30;\n\nimport {IERC20Permit} from \"./IERC20Permit.sol\";\nimport {ERC20} from \"../ERC20.sol\";\nimport {ECDSA} from \"../../../utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"../../../utils/cryptography/EIP712.sol\";\nimport {Nonces} from \"../../../utils/Nonces.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712, Nonces {\n    bytes32 private constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Permit deadline has expired.\n     */\n    error ERC2612ExpiredSignature(uint256 deadline);\n\n    /**\n     * @dev Mismatched signature.\n     */\n    error ERC2612InvalidSigner(address signer, address owner);\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > deadline) {\n            revert ERC2612ExpiredSignature(deadline);\n        }\n\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        if (signer != owner) {\n            revert ERC2612InvalidSigner(signer, owner);\n        }\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function nonces(address owner) public view virtual override(IERC20Permit, Nonces) returns (uint256) {\n        return super.nonces(owner);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n"}, "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"}, "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"}, "@openzeppelin/contracts/token/ERC20/IERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"}, "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"}, "@openzeppelin/contracts/utils/Address.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"}, "@openzeppelin/contracts/utils/Context.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"}, "@openzeppelin/contracts/utils/Create2.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Create2.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Not enough balance for performing a CREATE2 deploy.\n     */\n    error Create2InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev There's no code to deploy.\n     */\n    error Create2EmptyBytecode();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error Create2FailedDeployment();\n\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\n        if (address(this).balance < amount) {\n            revert Create2InsufficientBalance(address(this).balance, amount);\n        }\n        if (bytecode.length == 0) {\n            revert Create2EmptyBytecode();\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        if (addr == address(0)) {\n            revert Create2FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   | \u2193 ptr ...  \u2193 ptr + 0x0B (start) ...  \u2193 ptr + 0x20 ...  \u2193 ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |            \u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191 |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := keccak256(start, 85)\n        }\n    }\n}\n"}, "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"}, "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.30;\n\nimport {MessageHashUtils} from \"./MessageHashUtils.sol\";\nimport {ShortStrings, ShortString} from \"../ShortStrings.sol\";\nimport {IERC5267} from \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _name which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Name() internal view returns (string memory) {\n        return _name.toStringWithFallback(_nameFallback);\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _version which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Version() internal view returns (string memory) {\n        return _version.toStringWithFallback(_versionFallback);\n    }\n}\n"}, "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.30;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"}, "@openzeppelin/contracts/utils/math/Math.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"}, "@openzeppelin/contracts/utils/math/SafeCast.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n"}, "@openzeppelin/contracts/utils/math/SignedMath.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"}, "@openzeppelin/contracts/utils/Nonces.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\npragma solidity ^0.8.30;\n\n/**\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\n */\nabstract contract Nonces {\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    mapping(address account => uint256) private _nonces;\n\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return _nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}\n"}, "@openzeppelin/contracts/utils/ShortStrings.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.30;\n\nimport {StorageSlot} from \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\n     * {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"}, "@openzeppelin/contracts/utils/StorageSlot.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"}, "@openzeppelin/contracts/utils/Strings.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.30;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"}, "contracts/core/ConfigurableUpgradeable.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport \"../governance/GovernableUpgradeable.sol\";\nimport \"../libraries/ReentrancyGuard.sol\";\nimport \"../libraries/ConfigurableUtil.sol\";\n\nabstract contract ConfigurableUpgradeable is IConfigurable, GovernableUpgradeable, ReentrancyGuard {\n    using ConfigurableUtil for mapping(IERC20 market => MarketConfig);\n\n    /// @custom:storage-location erc7201:Purecash.storage.ConfigurableUpgradeable\n    struct ConfigurableStorage {\n        mapping(IERC20 market => MarketConfig) marketConfigs;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"Purecash.storage.ConfigurableUpgradeable\")) - 1))\n    // & ~bytes32(uint256(0xff))\n    bytes32 private constant CONFIGURABLE_UPGRADEABLE_STORAGE =\n        0x2e53c93cfb85b377c33c5881ea2e8ae1c7fa4b789e2a859438dc71474e045100;\n\n    function __Configurable_init(address _initialGov) internal onlyInitializing {\n        __Governable_init(_initialGov);\n        __Configurable_init_unchained();\n    }\n\n    function __Configurable_init_unchained() internal onlyInitializing {}\n\n    /// @inheritdoc IConfigurable\n    function isEnabledMarket(IERC20 _market) external view override returns (bool) {\n        return _isEnabledMarket(_market);\n    }\n\n    /// @inheritdoc IConfigurable\n    function marketConfigs(IERC20 _market) external view override returns (MarketConfig memory) {\n        return _configurableStorage().marketConfigs[_market];\n    }\n\n    /// @inheritdoc IConfigurable\n    function enableMarket(IERC20 _market, string calldata _tokenSymbol, MarketConfig calldata _cfg) external override {\n        _onlyGov();\n        _configurableStorage().marketConfigs.enableMarket(_market, _cfg);\n\n        afterMarketEnabled(_market, _tokenSymbol);\n    }\n\n    /// @inheritdoc IConfigurable\n    function updateMarketConfig(IERC20 _market, MarketConfig calldata _newCfg) public override {\n        _onlyGov();\n        _configurableStorage().marketConfigs.updateMarketConfig(_market, _newCfg);\n    }\n\n    function afterMarketEnabled(IERC20 _market, string calldata _tokenSymbol) internal virtual {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function _onlyEnabled(IERC20 _market) internal view {\n        if (_configurableStorage().marketConfigs[_market].liquidityCap == 0) revert MarketNotEnabled(_market);\n    }\n\n    function _isEnabledMarket(IERC20 _market) internal view returns (bool) {\n        return _configurableStorage().marketConfigs[_market].liquidityCap != 0;\n    }\n\n    function _configurableStorage() internal pure returns (ConfigurableStorage storage $) {\n        // prettier-ignore\n        assembly { $.slot := CONFIGURABLE_UPGRADEABLE_STORAGE }\n    }\n}\n"}, "contracts/core/FeeDistributorUpgradeable.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport \"../libraries/Constants.sol\";\nimport \"../governance/GovernableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\ncontract FeeDistributorUpgradeable is GovernableUpgradeable {\n    using SafeCast for *;\n\n    struct FeeDistribution {\n        uint128 protocolFee;\n        uint128 ecosystemFee;\n        uint128 developmentFund;\n    }\n\n    /// @notice The rate at which fees are distributed to the protocol,\n    /// denominated in thousandths of a bip (i.e. 1e-7)\n    uint24 public protocolFeeRate;\n    /// @notice The rate at which fees are distributed to the ecosystem,\n    /// denominated in thousandths of a bip (i.e. 1e-7)\n    uint24 public ecosystemFeeRate;\n    mapping(IERC20 market => FeeDistribution) public feeDistributions;\n\n    event FeeRateUpdated(uint24 newProtocolFeeRate, uint24 newEcosystemFeeRate);\n    event FeeDeposited(IERC20 indexed token, uint128 protocolFee, uint128 ecosystemFee, uint128 developmentFund);\n    event ProtocolFeeWithdrawal(IERC20 indexed token, address indexed receiver, uint128 amount);\n    event EcosystemFeeWithdrawal(IERC20 indexed token, address indexed receiver, uint128 amount);\n    event DevelopmentFundWithdrawal(IERC20 indexed token, address indexed receiver, uint128 amount);\n\n    error InvalidFeeRate(uint24 protocolFeeRate, uint24 ecosystemFeeRate);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _initialGov, uint24 _protocolFeeRate, uint24 _ecosystemFeeRate) public initializer {\n        GovernableUpgradeable.__Governable_init(_initialGov);\n        _updateFeeRate(_protocolFeeRate, _ecosystemFeeRate);\n    }\n\n    function updateFeeRate(uint24 _protocolFeeRate, uint24 _ecosystemFeeRate) external onlyGov {\n        _updateFeeRate(_protocolFeeRate, _ecosystemFeeRate);\n    }\n\n    function deposit(IERC20 _token) external {\n        uint256 balance = _token.balanceOf(address(this));\n        FeeDistribution storage feeDistribution = feeDistributions[_token];\n        uint128 delta = (balance -\n            feeDistribution.protocolFee -\n            feeDistribution.developmentFund -\n            feeDistribution.ecosystemFee).toUint128();\n        unchecked {\n            uint128 protocolFeeDelta = uint128((uint256(delta) * protocolFeeRate) / Constants.BASIS_POINTS_DIVISOR);\n            uint128 ecosystemFeeDelta = uint128((uint256(delta) * ecosystemFeeRate) / Constants.BASIS_POINTS_DIVISOR);\n            uint128 developmentFundDelta = delta - protocolFeeDelta - ecosystemFeeDelta;\n\n            // overflow is desired\n            feeDistribution.protocolFee += protocolFeeDelta;\n            feeDistribution.ecosystemFee += ecosystemFeeDelta;\n            feeDistribution.developmentFund += developmentFundDelta;\n\n            emit FeeDeposited(_token, protocolFeeDelta, ecosystemFeeDelta, developmentFundDelta);\n        }\n    }\n\n    function withdrawProtocolFee(IERC20 _token, address _receiver, uint128 _amount) external onlyGov {\n        feeDistributions[_token].protocolFee -= _amount;\n        _token.transfer(_receiver, _amount);\n        emit ProtocolFeeWithdrawal(_token, _receiver, _amount);\n    }\n\n    function withdrawEcosystemFee(IERC20 _token, address _receiver, uint128 _amount) external onlyGov {\n        feeDistributions[_token].ecosystemFee -= _amount;\n        _token.transfer(_receiver, _amount);\n        emit EcosystemFeeWithdrawal(_token, _receiver, _amount);\n    }\n\n    function withdrawDevelopmentFund(IERC20 _token, address _receiver, uint128 _amount) external onlyGov {\n        feeDistributions[_token].developmentFund -= _amount;\n        _token.transfer(_receiver, _amount);\n        emit DevelopmentFundWithdrawal(_token, _receiver, _amount);\n    }\n\n    function _updateFeeRate(uint24 _protocolFeeRate, uint24 _ecosystemFeeRate) internal {\n        unchecked {\n            require(\n                uint32(_protocolFeeRate) + _ecosystemFeeRate <= Constants.BASIS_POINTS_DIVISOR,\n                InvalidFeeRate(_protocolFeeRate, _ecosystemFeeRate)\n            );\n        }\n        protocolFeeRate = _protocolFeeRate;\n        ecosystemFeeRate = _ecosystemFeeRate;\n        emit FeeRateUpdated(_protocolFeeRate, _ecosystemFeeRate);\n    }\n\n    /// @inheritdoc UUPSUpgradeable\n    function _authorizeUpgrade(address newImplementation) internal virtual override onlyGov {}\n}\n"}, "contracts/core/interfaces/IConfigurable.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Configurable Interface\n/// @notice This interface defines the functions for manage market configurations\ninterface IConfigurable {\n    struct MarketConfig {\n        /// @notice The liquidation fee rate for per trader position,\n        /// denominated in thousandths of a bip (i.e. 1e-7)\n        uint24 liquidationFeeRatePerPosition;\n        /// @notice The maximum size rate for per position, denominated in thousandths of a bip (i.e. 1e-7)\n        uint24 maxSizeRatePerPosition;\n        /// @notice If the balance rate after increasing a long position is greater than this parameter,\n        /// then the trading fee rate will be changed to the floating fee rate,\n        /// denominated in thousandths of a bip (i.e. 1e-7)\n        uint24 openPositionThreshold;\n        /// @notice The trading fee rate for increase or decrease positions,\n        /// denominated in thousandths of a bip (i.e. 1e-7)\n        uint24 tradingFeeRate;\n        /// @notice The maximum leverage for per trader position, for example, 100 means the maximum leverage\n        /// is 100 times\n        uint8 maxLeveragePerPosition;\n        /// @notice The market token decimals\n        uint8 decimals;\n        /// @notice A system variable to calculate the `spread`\n        uint120 liquidityScale;\n        /// @notice The protocol fee rate as a percentage of trading fee,\n        /// denominated in thousandths of a bip (i.e. 1e-7)\n        uint24 protocolFeeRate;\n        /// @notice The maximum floating fee rate for increasing long position,\n        /// denominated in thousandths of a bip (i.e. 1e-7)\n        uint24 maxFeeRate;\n        /// @notice A system variable to calculate the `spreadFactor`, in seconds\n        uint24 riskFreeTime;\n        /// @notice The minimum entry margin required for per trader position\n        uint64 minMarginPerPosition;\n        /// @notice If balance rate is less than minMintingRate, the minting is disabled,\n        /// denominated in thousandths of a bip (i.e. 1e-7)\n        uint24 minMintingRate;\n        /// @notice If balance rate is greater than maxBurningRate, the burning is disabled,\n        /// denominated in thousandths of a bip (i.e. 1e-7)\n        uint24 maxBurningRate;\n        /// @notice The liquidation execution fee for LP and trader positions\n        uint64 liquidationExecutionFee;\n        /// @notice Whether the liquidity buffer module is enabled when decreasing position\n        bool liquidityBufferModuleEnabled;\n        /// @notice The trading fee rate for liquidity, denominated in thousandths of a bip (i.e. 1e-7)\n        uint24 liquidityTradingFeeRate;\n        /// @notice If the total supply of the stable coin reach stableCoinSupplyCap, the minting is disabled.\n        uint64 stableCoinSupplyCap;\n        /// @notice The capacity of the liquidity\n        uint120 liquidityCap;\n        /// @notice The maximum short position size rate, denominated in thousandths of a bip (i.e. 1e-7)\n        uint32 maxShortSizeRate;\n    }\n\n    /// @notice Emitted when the market is enabled\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param cfg The new market configuration\n    event MarketConfigEnabled(IERC20 indexed market, MarketConfig cfg);\n\n    /// @notice Emitted when a market configuration is changed\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param cfg The new market configuration\n    event MarketConfigChanged(IERC20 indexed market, MarketConfig cfg);\n\n    /// @notice Market is already enabled\n    error MarketAlreadyEnabled(IERC20 market);\n    /// @notice Market is not enabled\n    error MarketNotEnabled(IERC20 market);\n    /// @notice Invalid maximum leverage for trader positions\n    error InvalidMaxLeveragePerPosition(uint8 maxLeveragePerPosition);\n    /// @notice Invalid liquidation fee rate for trader positions\n    error InvalidLiquidationFeeRatePerPosition(uint24 liquidationFeeRatePerPosition);\n    /// @notice Invalid max size per rate for per position\n    error InvalidMaxSizeRatePerPosition(uint24 maxSizeRatePerPosition);\n    /// @notice Invalid liquidity capacity\n    error InvalidLiquidityCap(uint120 liquidityCap);\n    /// @notice Invalid trading fee rate\n    error InvalidTradingFeeRate(uint24 tradingFeeRate);\n    /// @notice Invalid protocol fee rate\n    error InvalidProtocolFeeRate(uint24 protocolFeeRate);\n    /// @notice Invalid min minting rate\n    error InvalidMinMintingRate(uint24 minMintingRate);\n    /// @notice Invalid max burning rate\n    error InvalidMaxBurningRate(uint24 maxBurnningRate);\n    /// @notice Invalid open position threshold\n    error InvalidOpenPositionThreshold(uint24 openPositionThreshold);\n    /// @notice Invalid max fee rate\n    error InvalidMaxFeeRate(uint24 maxFeeRate);\n    /// @notice The risk free time is zero, which is not allowed\n    error ZeroRiskFreeTime();\n    /// @notice The liquidity scale is zero, which is not allowed\n    error ZeroLiquidityScale();\n    /// @notice Invalid stable coin supply capacity\n    error InvalidStableCoinSupplyCap(uint256 stablecoinSupplyCap);\n    /// @notice Invalid decimals\n    error InvalidDecimals(uint8 decimals);\n    /// @notice Invalid liquidity trading fee rate\n    error InvalidLiquidityTradingFeeRate(uint24 liquidityTradingFeeRate);\n\n    /// @notice Checks if a market is enabled\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @return True if the market is enabled, false otherwise\n    function isEnabledMarket(IERC20 market) external view returns (bool);\n\n    /// @notice Get the information of market configuration\n    /// @param market The target market contract address, such as the contract address of WETH\n    function marketConfigs(IERC20 market) external view returns (MarketConfig memory);\n\n    /// @notice Enable the market\n    /// @dev The call will fail if caller is not the governor or the market is already enabled\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param tokenSymbol The symbol of the LP token\n    /// @param cfg The market configuration\n    function enableMarket(IERC20 market, string calldata tokenSymbol, MarketConfig calldata cfg) external;\n\n    /// @notice Update a market configuration\n    /// @dev The call will fail if caller is not the governor or the market is not enabled\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param newCfg The new market configuration\n    function updateMarketConfig(IERC20 market, MarketConfig calldata newCfg) external;\n}\n"}, "contracts/core/interfaces/ILPToken.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ILPToken is IERC20 {\n    function mint(address to, uint256 amount) external;\n\n    function burn(uint256 amount) external;\n}\n"}, "contracts/core/interfaces/IMarketErrors.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\ninterface IMarketErrors {\n    /// @notice Failed to transfer ETH\n    error FailedTransferETH();\n    /// @notice Invalid caller\n    error InvalidCaller(address requiredCaller);\n    /// @notice Insufficient size to decrease\n    error InsufficientSizeToDecrease(uint128 requiredSize, uint128 size);\n    /// @notice Insufficient margin\n    error InsufficientMargin();\n    /// @notice Position not found\n    error PositionNotFound(address requiredAccount);\n    /// @notice Size exceeds max size per position\n    error SizeExceedsMaxSizePerPosition(uint256 requiredSize, uint256 maxSizePerPosition);\n    /// @notice Size exceeds max size\n    error SizeExceedsMaxSize(uint256 requiredSize, uint256 maxSize);\n    /// @notice Insufficient liquidity to decrease\n    error InsufficientLiquidityToDecrease(uint256 liquidity, uint128 requiredLiquidity);\n    /// @notice Liquidity Cap exceeded\n    error LiquidityCapExceeded(uint128 liquidityBefore, uint96 liquidityDelta, uint120 liquidityCap);\n    /// @notice Balance Rate Cap exceeded\n    error BalanceRateCapExceeded();\n    /// @notice Error thrown when min minting size cap is not met\n    error MinMintingSizeCapNotMet(uint128 netSize, uint128 sizeDelta, uint128 minMintingSizeCap);\n    /// @notice Error thrown when max short size cap is exceeded\n    error MaxShortSizeExceeded(uint128 sizeAfter, uint256 maxShortSize);\n    /// @notice Error thrown when max burning size cap is exceeded\n    error MaxBurningSizeCapExceeded(uint128 netSize, uint128 sizeDelta, uint256 maxBurningSizeCap);\n    /// @notice Insufficient balance\n    error InsufficientBalance(uint256 balance, uint256 requiredAmount);\n    /// @notice Leverage is too high\n    error LeverageTooHigh(uint256 margin, uint128 size, uint8 maxLeverage);\n    /// @notice Position margin rate is too low\n    error MarginRateTooLow(int256 margin, uint256 maintenanceMargin);\n    /// @notice Position margin rate is too high\n    error MarginRateTooHigh(int256 margin, uint256 maintenanceMargin);\n    error InvalidAmount(uint128 requiredAmount, uint128 pusdBalance);\n    error InvalidSize();\n    /// @notice Stable Coin Supply Cap exceeded\n    error StableCoinSupplyCapExceeded(uint256 supplyCap, uint256 totalSupply, uint256 amountDelta);\n    /// @notice Error thrown when the pay amount is less than the required amount\n    error TooLittlePayAmount(uint128 requiredAmount, uint128 payAmount);\n    /// @notice Error thrown when the pay amount is not equal to the required amount\n    error UnexpectedPayAmount(uint128 requiredAmount, uint128 payAmount);\n    error NegativeReceiveAmount(int256 receiveAmount);\n}\n"}, "contracts/core/interfaces/IMarketLiquidity.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\nimport \"./ILPToken.sol\";\n\n/// @notice Interface for managing liquidity of the protocol\ninterface IMarketLiquidity {\n    /// @notice Emitted when the global liquidity is increased by trading fee\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param liquidityFee The increased liquidity fee\n    event GlobalLiquidityIncreasedByTradingFee(IERC20 indexed market, uint96 liquidityFee);\n\n    /// @notice Emitted when the global liquidity is increased by LP trading fee\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param liquidityFee The increased liquidity fee\n    event GlobalLiquidityIncreasedByLPTradingFee(IERC20 indexed market, uint96 liquidityFee);\n\n    /// @notice Emitted when the global liquidity is settled\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param sizeDelta The change in the global liquidity\n    /// @param realizedPnL The realized PnL of the global liquidity\n    /// @param entryPriceAfter The entry price after the settlement\n    event GlobalLiquiditySettled(IERC20 indexed market, int256 sizeDelta, int256 realizedPnL, uint64 entryPriceAfter);\n\n    /// @notice Emitted when a new LP Token is deployed\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param token The LP Token contract address\n    event LPTokenDeployed(IERC20 indexed market, ILPToken indexed token);\n\n    /// @notice Emitted when the LP Token is minted\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param account The owner of the LP Token\n    /// @param receiver The address to receive the minted LP Token\n    /// @param liquidity The liquidity provided by the LP\n    /// @param tokenValue The LP Token to be minted\n    /// @param tradingFee The trading fee of the LP\n    event LPTMinted(\n        IERC20 indexed market,\n        address indexed account,\n        address indexed receiver,\n        uint96 liquidity,\n        uint64 tokenValue,\n        uint96 tradingFee\n    );\n\n    /// @notice Emitted when the LP Token is burned\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param account The owner of the LP Token\n    /// @param receiver The address to receive the margin\n    /// @param liquidity The liquidity to be returned to the LP\n    /// @param tokenValue The LP Token to be burned\n    /// @param tradingFee The trading fee of the LP\n    event LPTBurned(\n        IERC20 indexed market,\n        address indexed account,\n        address indexed receiver,\n        uint96 liquidity,\n        uint64 tokenValue,\n        uint96 tradingFee\n    );\n\n    /// @notice Emitted when the global liquidity PnL is revised\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param settledPrice The price when the PnL is settled\n    /// @param scaledUSDPnL The settled scaled USD PnL. For saving gas, this value is scaled up\n    /// by 10^(market decimals + price decimals - usd decimals)\n    /// @param revisedTokenPnL The revised token PnL\n    event GlobalLiquidityPnLRevised(\n        IERC20 indexed market,\n        uint64 settledPrice,\n        int256 scaledUSDPnL,\n        int256 revisedTokenPnL\n    );\n\n    /// @notice Mint the LP Token\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param account The address to mint the liquidity. The parameter is only used for emitting event\n    /// @param receiver The address to receive the minted LP Token\n    /// @return tokenValue The LP Token to be minted\n    function mintLPT(IERC20 market, address account, address receiver) external returns (uint64 tokenValue);\n\n    /// @notice Burn the LP Token\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param account The address to burn the liquidity. The parameter is only used for emitting event\n    /// @param receiver The address to receive the returned liquidity\n    /// @return liquidity The liquidity to be returned to the LP\n    function burnLPT(IERC20 market, address account, address receiver) external returns (uint96 liquidity);\n}\n"}, "contracts/core/interfaces/IMarketManager.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\nimport \"./IPSM.sol\";\nimport \"./IConfigurable.sol\";\nimport \"./IMarketErrors.sol\";\nimport \"./IPUSDManager.sol\";\nimport \"./IMarketPosition.sol\";\nimport \"./IMarketLiquidity.sol\";\nimport \"../../oracle/interfaces/IPriceFeed.sol\";\nimport \"../../plugins/interfaces/IPluginManager.sol\";\nimport \"../../oracle/interfaces/IPriceFeed.sol\";\n\ninterface IMarketManager is\n    IMarketErrors,\n    IMarketPosition,\n    IMarketLiquidity,\n    IPUSDManager,\n    IConfigurable,\n    IPluginManager,\n    IPriceFeed,\n    IPSM\n{\n    struct LiquidityBufferModule {\n        /// @notice The debt of the liquidity buffer module\n        uint128 pusdDebt;\n        /// @notice The token payback of the liquidity buffer module\n        uint128 tokenPayback;\n    }\n\n    struct PackedState {\n        /// @notice The spread factor used to calculate spread\n        int256 spreadFactorX96;\n        /// @notice Last trading timestamp in seconds since Unix epoch\n        uint64 lastTradingTimestamp;\n        /// @notice The sum of long position sizes\n        uint128 longSize;\n        /// @notice The entry price of the net position\n        uint64 lpEntryPrice;\n        /// @notice The total liquidity of all LPs\n        uint128 lpLiquidity;\n        /// @notice The size of the net position held by all LPs\n        uint128 lpNetSize;\n    }\n\n    struct State {\n        /// @notice The packed state of the market\n        PackedState packedState;\n        /// @notice The value is used to track the global PUSD position\n        GlobalPUSDPosition globalPUSDPosition;\n        /// @notice Mapping of account to long position\n        mapping(address account => Position) longPositions;\n        /// @notice The value is used to track the liquidity buffer module status\n        LiquidityBufferModule liquidityBufferModule;\n        /// @notice The value is used to track the remaining protocol fee of the market\n        uint128 protocolFee;\n        /// @notice The value is used to track the token balance of the market\n        uint128 tokenBalance;\n        /// @notice The margin of the global stability fund\n        uint256 globalStabilityFund;\n        /// @notice The accumulated scaled USD PnL. For saving gas, this value is scaled up\n        /// by 10^(market decimals + price decimals - usd decimals)\n        int184 accumulateScaledUSDPnL;\n        /// @notice The previous settled price\n        uint64 previousSettledPrice;\n    }\n\n    /// @notice Emitted when the protocol fee is increased by trading fee\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param amount The increased protocol fee\n    event ProtocolFeeIncreased(IERC20 indexed market, uint96 amount);\n\n    /// @notice Emitted when the protocol fee is increased by LP trading fee\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param amount The increased protocol fee\n    event ProtocolFeeIncreasedByLPTradingFee(IERC20 indexed market, uint96 amount);\n\n    /// @notice Emitted when the protocol fee is collected\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param amount The collected protocol fee\n    event ProtocolFeeCollected(IERC20 indexed market, uint128 amount);\n\n    /// @notice Emitted when the stability fund is used by `Gov`\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param receiver The address that receives the stability fund\n    /// @param stabilityFundDelta The amount of stability fund used\n    event GlobalStabilityFundGovUsed(IERC20 indexed market, address indexed receiver, uint128 stabilityFundDelta);\n\n    /// @notice Emitted when the liquidity of the stability fund is increased by liquidation\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param liquidationFee The amount of the liquidation fee that is added to the stability fund.\n    event GlobalStabilityFundIncreasedByLiquidation(IERC20 indexed market, uint96 liquidationFee);\n\n    /// @notice Emitted when the liquidity of the stability fund is increased by spread\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param spread The spread incurred by the position\n    event GlobalStabilityFundIncreasedBySpread(IERC20 indexed market, uint96 spread);\n\n    /// @notice Emitted when the liquidity buffer module debt is increased\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param account The address for debt repayment\n    /// @param pusdDebtDelta The increase in the debt of the LBM module\n    /// @param tokenPaybackDelta The increase in the token payback of the LBM module\n    event LiquidityBufferModuleDebtIncreased(\n        IERC20 market,\n        address account,\n        uint128 pusdDebtDelta,\n        uint128 tokenPaybackDelta\n    );\n\n    /// @notice Emitted when the liquidity buffer module debt is repaid\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param account The address for debt repayment\n    /// @param pusdDebtDelta The decrease in the debt of the LBM module\n    /// @param tokenPaybackDelta The decrease in the token payback of the LBM module\n    event LiquidityBufferModuleDebtRepaid(\n        IERC20 market,\n        address account,\n        uint128 pusdDebtDelta,\n        uint128 tokenPaybackDelta\n    );\n\n    /// @notice Emitted when the spread factor is changed\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param spreadFactorAfterX96 The spread factor after the trade, as a Q160.96\n    event SpreadFactorChanged(IERC20 market, int256 spreadFactorAfterX96);\n\n    /// @notice Get the packed state of the given market\n    /// @param market The target market contract address, such as the contract address of WETH\n    function packedStates(IERC20 market) external view returns (PackedState memory);\n\n    /// @notice Get the remaining protocol fee of the given market\n    /// @param market The target market contract address, such as the contract address of WETH\n    function protocolFees(IERC20 market) external view returns (uint128);\n\n    /// @notice Get the token balance of the given market\n    /// @param market The target market contract address, such as the contract address of WETH\n    function tokenBalances(IERC20 market) external view returns (uint128);\n\n    /// @notice Collect the protocol fee of the given market\n    /// @dev This function can be called without authorization\n    /// @param market The target market contract address, such as the contract address of WETH\n    function collectProtocolFee(IERC20 market) external;\n\n    /// @notice Get the information of global stability fund\n    /// @param market The target market contract address, such as the contract address of WETH\n    function globalStabilityFunds(IERC20 market) external view returns (uint256);\n\n    /// @notice Get the accumulated scaled USD PnL and the previous settled price of the given market\n    /// @param market The target market contract address, such as the contract address of WETH\n    function reviseLiquidityPnLStates(\n        IERC20 market\n    ) external view returns (int184 accumulateScaledUSDPnL, uint64 previousSettledPrice);\n\n    /// @notice `Gov` uses the stability fund\n    /// @dev The call will fail if the caller is not the `Gov` or the stability fund is insufficient\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param receiver The address to receive the stability fund\n    /// @param stabilityFundDelta The amount of stability fund to be used\n    function govUseStabilityFund(IERC20 market, address receiver, uint128 stabilityFundDelta) external;\n\n    /// @notice Repay the liquidity buffer debt of the given market\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param account The address for debt repayment\n    /// @param receiver The address to receive the payback token\n    /// @return receiveAmount The amount of payback token received\n    function repayLiquidityBufferDebt(\n        IERC20 market,\n        address account,\n        address receiver\n    ) external returns (uint128 receiveAmount);\n\n    /// @notice Get the liquidity buffer module of the given market\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @return liquidityBufferModule The liquidity buffer module data\n    function liquidityBufferModules(\n        IERC20 market\n    ) external view returns (LiquidityBufferModule memory liquidityBufferModule);\n}\n"}, "contracts/core/interfaces/IMarketPosition.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\nimport {Side} from \"../../types/Side.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @notice Interface for managing market positions.\n/// @dev The market position is the core component of the protocol, which stores the information of\n/// all trader's positions.\ninterface IMarketPosition {\n    struct Position {\n        /// @notice The margin of the position\n        uint96 margin;\n        /// @notice The size of the position\n        uint96 size;\n        /// @notice The entry price of the position\n        uint64 entryPrice;\n    }\n\n    /// @notice Emitted when the position is increased\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param account The owner of the position\n    /// @param marginDelta The increased margin\n    /// @param marginAfter The adjusted margin\n    /// @param sizeDelta The increased size\n    /// @param indexPrice The index price at which the position is increased.\n    /// If only adding margin, it will be 0\n    /// @param entryPriceAfter The adjusted entry price of the position\n    /// @param tradingFee The trading fee paid by the position\n    /// @param spread The spread incurred by the position\n    event PositionIncreased(\n        IERC20 indexed market,\n        address indexed account,\n        uint96 marginDelta,\n        uint96 marginAfter,\n        uint96 sizeDelta,\n        uint64 indexPrice,\n        uint64 entryPriceAfter,\n        uint96 tradingFee,\n        uint96 spread\n    );\n\n    /// @notice Emitted when the position is decreased\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param account The owner of the position\n    /// @param marginDelta The decreased margin\n    /// @param marginAfter The adjusted margin\n    /// @param sizeDelta The decreased size\n    /// @param indexPrice The index price at which the position is decreased\n    /// @param realizedPnL The realized PnL\n    /// @param tradingFee The trading fee paid by the position\n    /// @param spread The spread incurred by the position\n    /// @param receiver The address that receives the margin\n    event PositionDecreased(\n        IERC20 indexed market,\n        address indexed account,\n        uint96 marginDelta,\n        uint96 marginAfter,\n        uint96 sizeDelta,\n        uint64 indexPrice,\n        int256 realizedPnL,\n        uint96 tradingFee,\n        uint96 spread,\n        address receiver\n    );\n\n    /// @notice Emitted when a position is liquidated\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param liquidator The address that executes the liquidation of the position\n    /// @param account The owner of the position\n    /// @param sizeDelta The liquidated size\n    /// @param indexPrice The index price at which the position is liquidated\n    /// @param liquidationPrice The liquidation price of the position\n    /// @param tradingFee The trading fee paid by the position\n    /// @param liquidationFee The liquidation fee paid by the position\n    /// @param liquidationExecutionFee The liquidation execution fee paid by the position\n    /// @param feeReceiver The address that receives the liquidation execution fee\n    event PositionLiquidated(\n        IERC20 indexed market,\n        address indexed liquidator,\n        address indexed account,\n        uint96 sizeDelta,\n        uint64 indexPrice,\n        uint64 liquidationPrice,\n        uint96 tradingFee,\n        uint96 liquidationFee,\n        uint64 liquidationExecutionFee,\n        address feeReceiver\n    );\n\n    /// @notice Get the information of a long position\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param account The owner of the position\n    function longPositions(IERC20 market, address account) external view returns (Position memory);\n\n    /// @notice Increase the margin or size of a position\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param account The owner of the position\n    /// @param sizeDelta The increase in size, which can be 0\n    /// @return spread The spread incurred by the position\n    function increasePosition(IERC20 market, address account, uint96 sizeDelta) external returns (uint96 spread);\n\n    /// @notice Decrease the margin or size of a position\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param account The owner of the position\n    /// @param marginDelta The decrease in margin, which can be 0. If the position size becomes zero after\n    /// the decrease, the marginDelta will be ignored, and all remaining margin will be returned\n    /// @param sizeDelta The decrease in size, which can be 0\n    /// @param receiver The address to receive the margin\n    /// @return spread The spread incurred by the position\n    /// @return actualMarginDelta The actual decrease in margin\n    function decreasePosition(\n        IERC20 market,\n        address account,\n        uint96 marginDelta,\n        uint96 sizeDelta,\n        address receiver\n    ) external returns (uint96 spread, uint96 actualMarginDelta);\n\n    /// @notice Liquidate a position\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param account The owner of the position\n    /// @param feeReceiver The address that receives the liquidation execution fee\n    function liquidatePosition(IERC20 market, address account, address feeReceiver) external;\n}\n"}, "contracts/core/interfaces/IPSM.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @notice Peg Stability Module interface\ninterface IPSM {\n    struct CollateralState {\n        uint120 cap;\n        uint8 decimals;\n        uint128 balance;\n    }\n\n    /// @notice Emitted when the collateral cap is updated\n    event PSMCollateralUpdated(IERC20 collateral, uint120 cap);\n\n    /// @notice Emit when PUSD is minted through the PSM module\n    /// @param collateral The collateral token\n    /// @param receiver Address to receive PUSD\n    /// @param payAmount The amount of collateral paid\n    /// @param receiveAmount The amount of PUSD minted\n    event PSMMinted(IERC20 indexed collateral, address indexed receiver, uint96 payAmount, uint64 receiveAmount);\n\n    /// @notice Emitted when PUSD is burned through the PSM module\n    /// @param collateral The collateral token\n    /// @param receiver Address to receive collateral\n    /// @param payAmount The amount of PUSD burned\n    /// @param receiveAmount The amount of collateral received\n    event PSMBurned(IERC20 indexed collateral, address indexed receiver, uint64 payAmount, uint96 receiveAmount);\n\n    /// @notice Invalid collateral token\n    error InvalidCollateral();\n\n    /// @notice Invalid collateral decimals\n    error InvalidCollateralDecimals(uint8 decimals);\n\n    /// @notice The PSM balance is insufficient\n    error InsufficientPSMBalance(uint96 receiveAmount, uint128 balance);\n\n    /// @notice Get the collateral state\n    function psmCollateralStates(IERC20 collateral) external view returns (CollateralState memory);\n\n    /// @notice Update the collateral cap\n    /// @param collateral The collateral token\n    /// @param cap The new cap\n    function updatePSMCollateralCap(IERC20 collateral, uint120 cap) external;\n\n    /// @notice Mint PUSD\n    /// @param collateral The collateral token\n    /// @param receiver Address to receive PUSD\n    /// @return receiveAmount The amount of PUSD minted\n    function psmMintPUSD(IERC20 collateral, address receiver) external returns (uint64 receiveAmount);\n\n    /// @notice Burn PUSD\n    /// @param collateral The collateral token\n    /// @param receiver Address to receive collateral\n    /// @return receiveAmount The amount of collateral received\n    function psmBurnPUSD(IERC20 collateral, address receiver) external returns (uint96 receiveAmount);\n}\n"}, "contracts/core/interfaces/IPUSD.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IPUSD is IERC20 {\n    function mint(address to, uint256 value) external;\n\n    function burn(uint256 value) external;\n}\n"}, "contracts/core/interfaces/IPUSDManager.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\nimport \"./IPUSD.sol\";\nimport \"./IPUSDManagerCallback.sol\";\n\n/// @notice Interface for managing the minting and burning of PUSD.\ninterface IPUSDManager {\n    struct GlobalPUSDPosition {\n        /// @notice The total PUSD supply of the current market\n        uint64 totalSupply;\n        /// @notice The size of the position\n        uint128 size;\n        /// @notice The entry price of the position\n        uint64 entryPrice;\n    }\n\n    /// @notice Emitted when PUSD is deployed\n    event PUSDDeployed(IPUSD indexed pusd);\n\n    /// @notice Emitted when the PUSD position is increased\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param receiver Address to receive PUSD\n    /// @param sizeDelta The size of the position to increase\n    /// @param indexPrice The index price at which the position is increased\n    /// @param entryPriceAfter The adjusted entry price of the position\n    /// @param payAmount The amount of token to pay\n    /// @param receiveAmount The amount of PUSD to mint\n    /// @param tradingFee The amount of trading fee to pay\n    /// @param spread The spread incurred by the position\n    event PUSDPositionIncreased(\n        IERC20 indexed market,\n        address indexed receiver,\n        uint96 sizeDelta,\n        uint64 indexPrice,\n        uint64 entryPriceAfter,\n        uint96 payAmount,\n        uint64 receiveAmount,\n        uint96 tradingFee,\n        uint96 spread\n    );\n\n    /// @notice Emitted when the PUSD position is decreased\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param receiver Address to receive token\n    /// @param sizeDelta The size of the position to decrease\n    /// @param indexPrice The index price at which the position is decreased\n    /// @param payAmount The amount of PUSD to burn\n    /// @param receiveAmount The amount of token to receive\n    /// @param realizedPnL The realized profit and loss of the position\n    /// @param tradingFee The amount of trading fee to pay\n    /// @param spread The spread incurred by the position\n    event PUSDPositionDecreased(\n        IERC20 indexed market,\n        address indexed receiver,\n        uint96 sizeDelta,\n        uint64 indexPrice,\n        uint64 payAmount,\n        uint96 receiveAmount,\n        int256 realizedPnL,\n        uint96 tradingFee,\n        uint96 spread\n    );\n\n    /// @notice Get the global PUSD position of the given market\n    /// @param market The target market contract address, such as the contract address of WETH\n    function globalPUSDPositions(IERC20 market) external view returns (GlobalPUSDPosition memory);\n\n    /// @notice Mint PUSD\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param amount When `exactIn` is true, it is the amount of token to pay,\n    /// otherwise, it is the amount of PUSD to mint\n    /// @param callback Address to callback after minting\n    /// @param data Any data to be passed to the callback\n    /// @param receiver Address to receive PUSD\n    /// @return payAmount The amount of token to pay\n    /// @return receiveAmount The amount of PUSD to receive\n    function mintPUSD(\n        IERC20 market,\n        bool exactIn,\n        uint96 amount,\n        IPUSDManagerCallback callback,\n        bytes calldata data,\n        address receiver\n    ) external returns (uint96 payAmount, uint64 receiveAmount);\n\n    /// @notice Burn PUSD\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param amount When `exactIn` is true, it is the amount of PUSD to burn,\n    /// otherwise, it is the amount of token to receive\n    /// @param callback Address to callback after burning\n    /// @param data Any data to be passed to the callback\n    /// @param receiver Address to receive token\n    /// @return payAmount The amount of PUSD to pay\n    /// @return receiveAmount The amount of token to receive\n    function burnPUSD(\n        IERC20 market,\n        bool exactIn,\n        uint96 amount,\n        IPUSDManagerCallback callback,\n        bytes calldata data,\n        address receiver\n    ) external returns (uint64 payAmount, uint96 receiveAmount);\n}\n"}, "contracts/core/interfaces/IPUSDManagerCallback.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Callback for IPUSDManager.mint and IPUSDManager.burn\ninterface IPUSDManagerCallback {\n    /// @notice Called after executing a mint or burn operation\n    /// @dev In this implementation, you are required to pay the amount of `payAmount` to the caller.\n    /// @dev In this implementation, you MUST check that the caller is IPUSDManager.\n    /// @param payToken The token to pay\n    /// @param payAmount The amount of token to pay\n    /// @param receiveAmount The amount of token to receive\n    /// @param data The data passed to the original `mint` or `burn` function\n    function PUSDManagerCallback(IERC20 payToken, uint96 payAmount, uint96 receiveAmount, bytes calldata data) external;\n}\n"}, "contracts/core/LPToken.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport \"../libraries/Constants.sol\";\nimport \"./interfaces/ILPToken.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\n\ncontract LPToken is ILPToken, ERC20Permit {\n    address public immutable marketManager;\n\n    IERC20 public market;\n    string private _symbol;\n\n    error Forbidden();\n    error AlreadyInitialized();\n\n    modifier onlyMarketManager() {\n        if (marketManager != _msgSender()) revert Forbidden();\n        _;\n    }\n\n    constructor() ERC20(\"Pure.cash LP\", \"\") ERC20Permit(\"Pure.cash LP\") {\n        marketManager = _msgSender();\n    }\n\n    function initialize(IERC20 market_, string calldata symbol_) external onlyMarketManager {\n        require(market == IERC20(address(0)), AlreadyInitialized());\n        market = market_;\n        _symbol = symbol_;\n    }\n\n    /// @inheritdoc ERC20\n    function decimals() public pure virtual override returns (uint8) {\n        return Constants.DECIMALS_6;\n    }\n\n    /// @inheritdoc ERC20\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function mint(address _to, uint256 _amount) external onlyMarketManager {\n        _mint(_to, _amount);\n    }\n\n    function burn(uint256 _amount) external onlyMarketManager {\n        _burn(msg.sender, _amount);\n    }\n}\n"}, "contracts/core/MarketManagerStatesUpgradeable.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport \"./ConfigurableUpgradeable.sol\";\nimport \"./FeeDistributorUpgradeable.sol\";\nimport \"../libraries/MarketUtil.sol\";\nimport \"../libraries/PUSDManagerUtil.sol\";\nimport \"../plugins/PluginManagerUpgradeable.sol\";\n\nabstract contract MarketManagerStatesUpgradeable is IMarketManager, ConfigurableUpgradeable, PluginManagerUpgradeable {\n    using SafeCast for *;\n\n    /// @custom:storage-location erc7201:Purecash.storage.MarketManagerStatesUpgradeable\n    struct MarketManagerStatesStorage {\n        mapping(IERC20 market => State) marketStates;\n        FeeDistributorUpgradeable feeDistributor;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"Purecash.storage.MarketManagerStatesUpgradeable\")) - 1))\n    // & ~bytes32(uint256(0xff))\n    bytes32 private constant MARKET_MANAGER_STATES_UPGRADEABLE_STORAGE =\n        0x251c369f4ebdedc72c1498dbeb9b538f609b170856998c6e34e4ab95eaf53300;\n\n    function __MarketManagerStates_init(\n        address _initialGov,\n        FeeDistributorUpgradeable _feeDistributor\n    ) internal onlyInitializing {\n        __Configurable_init(_initialGov);\n        __MarketManagerStates_init_unchained(_feeDistributor);\n    }\n\n    function __MarketManagerStates_init_unchained(FeeDistributorUpgradeable _feeDistributor) internal onlyInitializing {\n        MarketManagerStatesStorage storage $ = _statesStorage();\n        $.feeDistributor = _feeDistributor;\n    }\n\n    /// @inheritdoc IMarketManager\n    function packedStates(IERC20 _market) external view override returns (PackedState memory) {\n        return _statesStorage().marketStates[_market].packedState;\n    }\n\n    /// @inheritdoc IMarketManager\n    function protocolFees(IERC20 _market) external view override returns (uint128) {\n        return _statesStorage().marketStates[_market].protocolFee;\n    }\n\n    /// @inheritdoc IMarketManager\n    function tokenBalances(IERC20 _market) external view override returns (uint128) {\n        return _statesStorage().marketStates[_market].tokenBalance;\n    }\n\n    /// @inheritdoc IMarketManager\n    function liquidityBufferModules(IERC20 _market) external view override returns (LiquidityBufferModule memory) {\n        return _statesStorage().marketStates[_market].liquidityBufferModule;\n    }\n\n    /// @inheritdoc IPUSDManager\n    function globalPUSDPositions(IERC20 _market) external view returns (GlobalPUSDPosition memory) {\n        return _statesStorage().marketStates[_market].globalPUSDPosition;\n    }\n\n    /// @inheritdoc IMarketPosition\n    function longPositions(IERC20 _market, address _account) external view override returns (Position memory) {\n        return _statesStorage().marketStates[_market].longPositions[_account];\n    }\n\n    /// @inheritdoc IMarketManager\n    function globalStabilityFunds(IERC20 _market) external view override returns (uint256) {\n        return _statesStorage().marketStates[_market].globalStabilityFund;\n    }\n\n    /// @inheritdoc IMarketManager\n    function reviseLiquidityPnLStates(\n        IERC20 _market\n    ) external view override returns (int184 accumulateScaledUSDPnL, uint64 previousSettledPrice) {\n        IMarketManager.State storage state = _statesStorage().marketStates[_market];\n        return (state.accumulateScaledUSDPnL, state.previousSettledPrice);\n    }\n\n    function pusd() external view returns (address) {\n        return PUSDManagerUtil.computePUSDAddress();\n    }\n\n    function _statesStorage() internal pure returns (MarketManagerStatesStorage storage $) {\n        // prettier-ignore\n        assembly { $.slot := MARKET_MANAGER_STATES_UPGRADEABLE_STORAGE }\n    }\n}\n"}, "contracts/core/MarketManagerUpgradeable.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport \"./PSMUpgradeable.sol\";\nimport \"../libraries/LiquidityUtil.sol\";\nimport \"../plugins/PluginManagerUpgradeable.sol\";\nimport \"../oracle/PriceFeedUpgradeable.sol\";\n\n/// @custom:oz-upgrades-unsafe-allow external-library-linking\ncontract MarketManagerUpgradeable is PSMUpgradeable, PriceFeedUpgradeable {\n    using SafeCast for *;\n    using SafeERC20 for IERC20;\n    using MarketUtil for State;\n    using PositionUtil for State;\n    using PUSDManagerUtil for State;\n    using LiquidityUtil for State;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _initialGov,\n        FeeDistributorUpgradeable _feeDistributor,\n        bool _ignoreReferencePriceFeedError\n    ) public initializer {\n        PUSD pusd = PUSDManagerUtil.deployPUSD();\n        emit IPUSDManager.PUSDDeployed(pusd);\n\n        PSMUpgradeable.__PSM_init(_initialGov, _feeDistributor);\n        PriceFeedUpgradeable.__PriceFeed_init_unchained(_ignoreReferencePriceFeedError);\n    }\n\n    /// @inheritdoc IMarketLiquidity\n    function mintLPT(\n        IERC20 _market,\n        address _account,\n        address _receiver\n    ) external override nonReentrant returns (uint64 tokenValue) {\n        _onlyPlugin();\n\n        MarketManagerStatesStorage storage $ = _statesStorage();\n        State storage state = $.marketStates[_market];\n\n        uint128 balanceAfter = _market.balanceOf(address(this)).toUint128();\n        uint96 liquidity = (balanceAfter - state.tokenBalance).toUint96();\n        state.tokenBalance = balanceAfter;\n\n        tokenValue = state.mintLPT(\n            _configurableStorage().marketConfigs[_market],\n            LiquidityUtil.MintParam({\n                market: _market,\n                account: _account,\n                receiver: _receiver,\n                liquidity: liquidity,\n                indexPrice: _getMaxPrice(_market)\n            })\n        );\n    }\n\n    /// @inheritdoc IMarketLiquidity\n    function burnLPT(\n        IERC20 _market,\n        address _account,\n        address _receiver\n    ) external override nonReentrant returns (uint96 liquidity) {\n        _onlyPlugin();\n\n        MarketManagerStatesStorage storage $ = _statesStorage();\n        State storage state = $.marketStates[_market];\n\n        liquidity = state.burnLPT(\n            _configurableStorage().marketConfigs[_market],\n            LiquidityUtil.BurnParam({\n                market: _market,\n                account: _account,\n                receiver: _receiver,\n                tokenValue: ILPToken(LiquidityUtil.computeLPTokenAddress(_market)).balanceOf(address(this)).toUint64(),\n                indexPrice: _getMaxPrice(_market)\n            })\n        );\n\n        state.tokenBalance -= liquidity;\n        _market.safeTransfer(_receiver, liquidity);\n    }\n\n    /// @inheritdoc IMarketManager\n    function govUseStabilityFund(\n        IERC20 _market,\n        address _receiver,\n        uint128 _stabilityFundDelta\n    ) external override nonReentrant {\n        _onlyGov();\n\n        State storage state = _statesStorage().marketStates[_market];\n\n        state.govUseStabilityFund(_market, _stabilityFundDelta, _receiver);\n\n        state.tokenBalance -= _stabilityFundDelta;\n        _market.safeTransfer(_receiver, _stabilityFundDelta);\n    }\n\n    /// @inheritdoc IMarketPosition\n    function increasePosition(\n        IERC20 _market,\n        address _account,\n        uint96 _sizeDelta\n    ) external override nonReentrant returns (uint96 spread) {\n        _onlyPlugin();\n\n        MarketManagerStatesStorage storage $ = _statesStorage();\n        State storage state = $.marketStates[_market];\n\n        uint128 balanceAfter = _market.balanceOf(address(this)).toUint128();\n        uint96 marginDelta = (balanceAfter - state.tokenBalance).toUint96();\n        state.tokenBalance = balanceAfter;\n\n        (uint64 minIndexPrice, uint64 maxIndexPrice) = _getPrice(_market);\n        spread = state.increasePosition(\n            _configurableStorage().marketConfigs[_market],\n            PositionUtil.IncreasePositionParam({\n                market: _market,\n                account: _account,\n                marginDelta: marginDelta,\n                sizeDelta: _sizeDelta,\n                minIndexPrice: minIndexPrice,\n                maxIndexPrice: maxIndexPrice\n            })\n        );\n    }\n\n    /// @inheritdoc IMarketPosition\n    function decreasePosition(\n        IERC20 _market,\n        address _account,\n        uint96 _marginDelta,\n        uint96 _sizeDelta,\n        address _receiver\n    ) external override nonReentrant returns (uint96 spread, uint96 actualMarginDelta) {\n        _onlyPlugin();\n\n        MarketManagerStatesStorage storage $ = _statesStorage();\n        State storage state = $.marketStates[_market];\n\n        (uint64 minIndexPrice, uint64 maxIndexPrice) = _getPrice(_market);\n        (spread, actualMarginDelta) = state.decreasePosition(\n            _configurableStorage().marketConfigs[_market],\n            PositionUtil.DecreasePositionParam({\n                market: _market,\n                account: _account,\n                marginDelta: _marginDelta,\n                sizeDelta: _sizeDelta,\n                minIndexPrice: minIndexPrice,\n                maxIndexPrice: maxIndexPrice,\n                receiver: _receiver\n            })\n        );\n        state.tokenBalance -= actualMarginDelta;\n        _market.safeTransfer(_receiver, actualMarginDelta);\n    }\n\n    /// @inheritdoc IMarketPosition\n    function liquidatePosition(IERC20 _market, address _account, address _feeReceiver) external override nonReentrant {\n        _onlyPlugin();\n\n        MarketManagerStatesStorage storage $ = _statesStorage();\n        State storage state = $.marketStates[_market];\n\n        uint64 executionFee;\n        (uint64 minIndexPrice, uint64 maxIndexPrice) = _getPrice(_market);\n        executionFee = state.liquidatePosition(\n            _configurableStorage().marketConfigs[_market],\n            PositionUtil.LiquidatePositionParam({\n                market: _market,\n                account: _account,\n                minIndexPrice: minIndexPrice,\n                maxIndexPrice: maxIndexPrice,\n                feeReceiver: _feeReceiver\n            })\n        );\n\n        state.tokenBalance -= executionFee;\n        _market.safeTransfer(_feeReceiver, executionFee);\n    }\n\n    /// @inheritdoc IPUSDManager\n    function mintPUSD(\n        IERC20 _market,\n        bool _exactIn,\n        uint96 _amount,\n        IPUSDManagerCallback _callback,\n        bytes calldata _data,\n        address _receiver\n    ) external override nonReentrant returns (uint96 payAmount, uint64 receiveAmount) {\n        _onlyPlugin();\n\n        MarketManagerStatesStorage storage $ = _statesStorage();\n        State storage state = $.marketStates[_market];\n\n        (payAmount, receiveAmount) = state.mint(\n            _configurableStorage().marketConfigs[_market],\n            PUSDManagerUtil.MintParam({\n                market: _market,\n                exactIn: _exactIn,\n                amount: _amount,\n                callback: _callback,\n                indexPrice: _getMinPrice(_market),\n                receiver: _receiver\n            }),\n            _data\n        );\n    }\n\n    /// @inheritdoc IPUSDManager\n    function burnPUSD(\n        IERC20 _market,\n        bool _exactIn,\n        uint96 _amount,\n        IPUSDManagerCallback _callback,\n        bytes calldata _data,\n        address _receiver\n    ) external override nonReentrant returns (uint64 payAmount, uint96 receiveAmount) {\n        _onlyPlugin();\n\n        MarketManagerStatesStorage storage $ = _statesStorage();\n        State storage state = $.marketStates[_market];\n\n        (payAmount, receiveAmount) = state.burn(\n            _configurableStorage().marketConfigs[_market],\n            PUSDManagerUtil.BurnParam({\n                market: _market,\n                exactIn: _exactIn,\n                amount: _amount,\n                callback: _callback,\n                indexPrice: _getMaxPrice(_market),\n                receiver: _receiver\n            }),\n            _data\n        );\n    }\n\n    /// @inheritdoc IMarketManager\n    function collectProtocolFee(IERC20 _market) external override nonReentrant {\n        MarketManagerStatesStorage storage $ = _statesStorage();\n        State storage state = $.marketStates[_market];\n\n        uint128 protocolFee_ = state.protocolFee;\n        state.protocolFee = 0;\n        state.tokenBalance -= protocolFee_;\n\n        FeeDistributorUpgradeable feeDistributor_ = $.feeDistributor;\n        _market.safeTransfer(address(feeDistributor_), protocolFee_);\n        feeDistributor_.deposit(_market);\n\n        emit ProtocolFeeCollected(_market, protocolFee_);\n    }\n\n    /// @inheritdoc IMarketManager\n    function repayLiquidityBufferDebt(\n        IERC20 _market,\n        address _account,\n        address _receiver\n    ) external override nonReentrant returns (uint128 receiveAmount) {\n        _onlyPlugin();\n\n        MarketManagerStatesStorage storage $ = _statesStorage();\n        State storage state = $.marketStates[_market];\n\n        return state.repayLiquidityBufferDebt(_market, _account, _receiver);\n    }\n\n    /// @inheritdoc ConfigurableUpgradeable\n    function afterMarketEnabled(IERC20 _market, string calldata _tokenSymbol) internal override {\n        ILPToken token = LiquidityUtil.deployLPToken(_market, _tokenSymbol);\n        emit IMarketLiquidity.LPTokenDeployed(_market, token);\n    }\n\n    /// @inheritdoc UUPSUpgradeable\n    function _authorizeUpgrade(address newImplementation) internal virtual override onlyGov {}\n}\n"}, "contracts/core/PSMUpgradeable.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport \"./MarketManagerStatesUpgradeable.sol\";\nimport \"../libraries/PUSDManagerUtil.sol\";\n\nabstract contract PSMUpgradeable is MarketManagerStatesUpgradeable {\n    using PUSDManagerUtil for CollateralState;\n\n    /// @custom:storage-location erc7201:Purecash.storage.PSMUpgradeable\n    struct PSMStorage {\n        mapping(IERC20 collateral => CollateralState) collaterals;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"Purecash.storage.PSMUpgradeable\")) - 1))\n    // & ~bytes32(uint256(0xff))\n    bytes32 private constant PSM_UPGRADEABLE_STORAGE =\n        0x9f37cc75d7cdaa7a198c13b92cf96b51104a2ab8d71dd4736b100ec4a2373c00;\n\n    function __PSM_init(address _initialGov, FeeDistributorUpgradeable _feeDistributor) internal onlyInitializing {\n        MarketManagerStatesUpgradeable.__MarketManagerStates_init(_initialGov, _feeDistributor);\n    }\n\n    /// @inheritdoc IPSM\n    function psmCollateralStates(IERC20 _collateral) external view override returns (CollateralState memory state) {\n        state = _psmStorage().collaterals[_collateral];\n    }\n\n    /// @inheritdoc IPSM\n    function updatePSMCollateralCap(IERC20 _collateral, uint120 _cap) external override {\n        _onlyGov();\n\n        _psmStorage().collaterals[_collateral].updatePSMCollateralCap(_collateral, _cap);\n    }\n\n    /// @inheritdoc IPSM\n    function psmMintPUSD(\n        IERC20 _collateral,\n        address _receiver\n    ) external override nonReentrantToken(_collateral) returns (uint64 receiveAmount) {\n        _onlyPlugin();\n\n        receiveAmount = _psmStorage().collaterals[_collateral].psmMint(_collateral, _receiver);\n    }\n\n    /// @inheritdoc IPSM\n    function psmBurnPUSD(\n        IERC20 _collateral,\n        address _receiver\n    ) external override nonReentrantToken(_collateral) returns (uint96 receiveAmount) {\n        _onlyPlugin();\n\n        receiveAmount = _psmStorage().collaterals[_collateral].psmBurn(_collateral, _receiver);\n    }\n\n    function _psmStorage() internal pure returns (PSMStorage storage $) {\n        // prettier-ignore\n        assembly { $.slot := PSM_UPGRADEABLE_STORAGE }\n    }\n}\n"}, "contracts/core/PUSD.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport \"./interfaces/IPUSD.sol\";\nimport \"../libraries/Constants.sol\";\nimport \"../governance/Governable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\n\ncontract PUSD is ERC20, ERC20Permit, IPUSD {\n    address public immutable marketManager;\n\n    constructor() ERC20(\"Pure USD\", \"PUSD\") ERC20Permit(\"Pure USD\") {\n        marketManager = msg.sender;\n    }\n\n    /// @inheritdoc ERC20\n    function decimals() public view virtual override returns (uint8) {\n        return Constants.DECIMALS_6;\n    }\n\n    /// @inheritdoc IPUSD\n    function mint(address _to, uint256 _value) external override {\n        require(msg.sender == marketManager, Governable.Forbidden());\n\n        _mint(_to, _value);\n    }\n\n    /// @inheritdoc IPUSD\n    function burn(uint256 _value) external override {\n        require(msg.sender == marketManager, Governable.Forbidden());\n\n        _burn(msg.sender, _value);\n    }\n}\n"}, "contracts/governance/Governable.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\ncontract Governable {\n    address private _gov;\n    address private _pendingGov;\n\n    event ChangeGovStarted(address indexed previousGov, address indexed newGov);\n    event GovChanged(address indexed previousGov, address indexed newGov);\n\n    error Forbidden();\n\n    modifier onlyGov() {\n        _onlyGov();\n        _;\n    }\n\n    constructor(address _initialGov) {\n        _changeGov(_initialGov);\n    }\n\n    function gov() public view virtual returns (address) {\n        return _gov;\n    }\n\n    function pendingGov() public view virtual returns (address) {\n        return _pendingGov;\n    }\n\n    function changeGov(address _newGov) public virtual onlyGov {\n        _pendingGov = _newGov;\n        emit ChangeGovStarted(_gov, _newGov);\n    }\n\n    function acceptGov() public virtual {\n        if (msg.sender != _pendingGov) revert Forbidden();\n\n        delete _pendingGov;\n        _changeGov(msg.sender);\n    }\n\n    function _changeGov(address _newGov) internal virtual {\n        address previousGov = _gov;\n        _gov = _newGov;\n        emit GovChanged(previousGov, _newGov);\n    }\n\n    function _onlyGov() internal view {\n        if (msg.sender != _gov) revert Forbidden();\n    }\n}\n"}, "contracts/governance/GovernableUpgradeable.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nabstract contract GovernableUpgradeable is UUPSUpgradeable {\n    /// @custom:storage-location erc7201:Purecash.storage.GovernableUpgradeable\n    struct GovStorage {\n        address gov;\n        address pendingGov;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"Purecash.storage.GovernableUpgradeable\")) - 1))\n    // & ~bytes32(uint256(0xff))\n    bytes32 private constant GOVERNABLE_UPGRADEABLE_STORAGE =\n        0x71907d27e7f56436d282b33232af729b796faa4dde12f80868ee08b9116c5200;\n\n    event ChangeGovStarted(address indexed previousGov, address indexed newGov);\n    event GovChanged(address indexed previousGov, address indexed newGov);\n\n    error Forbidden();\n\n    modifier onlyGov() {\n        _onlyGov();\n        _;\n    }\n\n    function __Governable_init(address _initialGov) internal onlyInitializing {\n        UUPSUpgradeable.__UUPSUpgradeable_init();\n        __Governable_init_unchained(_initialGov);\n    }\n\n    function __Governable_init_unchained(address _initialGov) internal onlyInitializing {\n        _changeGov(_initialGov);\n    }\n\n    function gov() public view virtual returns (address) {\n        return _governableStorage().gov;\n    }\n\n    function pendingGov() public view virtual returns (address) {\n        return _governableStorage().pendingGov;\n    }\n\n    function changeGov(address _newGov) public virtual onlyGov {\n        GovStorage storage $ = _governableStorage();\n        $.pendingGov = _newGov;\n        emit ChangeGovStarted($.gov, _newGov);\n    }\n\n    function acceptGov() public virtual {\n        GovStorage storage $ = _governableStorage();\n        if (msg.sender != $.pendingGov) revert Forbidden();\n\n        delete $.pendingGov;\n        _changeGov(msg.sender);\n    }\n\n    function _changeGov(address _newGov) internal virtual {\n        GovStorage storage $ = _governableStorage();\n        address previousGov = $.gov;\n        $.gov = _newGov;\n        emit GovChanged(previousGov, _newGov);\n    }\n\n    function _onlyGov() internal view {\n        if (msg.sender != _governableStorage().gov) revert Forbidden();\n    }\n\n    function _governableStorage() private pure returns (GovStorage storage $) {\n        // prettier-ignore\n        assembly { $.slot := GOVERNABLE_UPGRADEABLE_STORAGE }\n    }\n}\n"}, "contracts/libraries/ConfigurableUtil.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport \"./Constants.sol\";\nimport \"../core/interfaces/IConfigurable.sol\";\n\nlibrary ConfigurableUtil {\n    function enableMarket(\n        mapping(IERC20 => IConfigurable.MarketConfig) storage _self,\n        IERC20 _market,\n        IConfigurable.MarketConfig calldata _cfg\n    ) public {\n        if (_self[_market].liquidityCap > 0) revert IConfigurable.MarketAlreadyEnabled(_market);\n\n        _validateConfig(_cfg);\n\n        _self[_market] = _cfg;\n\n        emit IConfigurable.MarketConfigEnabled(_market, _cfg);\n    }\n\n    function updateMarketConfig(\n        mapping(IERC20 => IConfigurable.MarketConfig) storage _self,\n        IERC20 _market,\n        IConfigurable.MarketConfig calldata _newCfg\n    ) public {\n        if (_self[_market].liquidityCap == 0) revert IConfigurable.MarketNotEnabled(_market);\n\n        _validateConfig(_newCfg);\n\n        _self[_market] = _newCfg;\n\n        emit IConfigurable.MarketConfigChanged(_market, _newCfg);\n    }\n\n    function _validateConfig(IConfigurable.MarketConfig calldata _newCfg) private pure {\n        if (_newCfg.maxLeveragePerPosition == 0)\n            revert IConfigurable.InvalidMaxLeveragePerPosition(_newCfg.maxLeveragePerPosition);\n\n        if (_newCfg.liquidationFeeRatePerPosition > Constants.BASIS_POINTS_DIVISOR)\n            revert IConfigurable.InvalidLiquidationFeeRatePerPosition(_newCfg.liquidationFeeRatePerPosition);\n\n        if (_newCfg.maxSizeRatePerPosition == 0 || _newCfg.maxSizeRatePerPosition > Constants.BASIS_POINTS_DIVISOR)\n            revert IConfigurable.InvalidMaxSizeRatePerPosition(_newCfg.maxSizeRatePerPosition);\n\n        if (_newCfg.openPositionThreshold > Constants.BASIS_POINTS_DIVISOR)\n            revert IConfigurable.InvalidOpenPositionThreshold(_newCfg.openPositionThreshold);\n\n        if (_newCfg.liquidityCap == 0) revert IConfigurable.InvalidLiquidityCap(_newCfg.liquidityCap);\n\n        if (_newCfg.decimals == 0 || _newCfg.decimals > 18) revert IConfigurable.InvalidDecimals(_newCfg.decimals);\n\n        if (_newCfg.tradingFeeRate > Constants.BASIS_POINTS_DIVISOR)\n            revert IConfigurable.InvalidTradingFeeRate(_newCfg.tradingFeeRate);\n\n        if (_newCfg.protocolFeeRate > Constants.BASIS_POINTS_DIVISOR)\n            revert IConfigurable.InvalidProtocolFeeRate(_newCfg.protocolFeeRate);\n\n        if (_newCfg.maxFeeRate > Constants.BASIS_POINTS_DIVISOR)\n            revert IConfigurable.InvalidMaxFeeRate(_newCfg.maxFeeRate);\n\n        unchecked {\n            if (uint64(_newCfg.maxFeeRate) + _newCfg.tradingFeeRate > Constants.BASIS_POINTS_DIVISOR)\n                revert IConfigurable.InvalidMaxFeeRate(_newCfg.maxFeeRate);\n        }\n\n        if (_newCfg.minMintingRate > Constants.BASIS_POINTS_DIVISOR)\n            revert IConfigurable.InvalidMinMintingRate(_newCfg.minMintingRate);\n\n        if (_newCfg.maxBurningRate > Constants.BASIS_POINTS_DIVISOR)\n            revert IConfigurable.InvalidMaxBurningRate(_newCfg.maxBurningRate);\n\n        if (_newCfg.riskFreeTime == 0) revert IConfigurable.ZeroRiskFreeTime();\n\n        if (_newCfg.liquidityScale == 0) revert IConfigurable.ZeroLiquidityScale();\n\n        if (_newCfg.stableCoinSupplyCap == 0)\n            revert IConfigurable.InvalidStableCoinSupplyCap(_newCfg.stableCoinSupplyCap);\n\n        if (_newCfg.liquidityTradingFeeRate > Constants.BASIS_POINTS_DIVISOR)\n            revert IConfigurable.InvalidLiquidityTradingFeeRate(_newCfg.liquidityTradingFeeRate);\n    }\n}\n"}, "contracts/libraries/Constants.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nlibrary Constants {\n    uint24 internal constant BASIS_POINTS_DIVISOR = 10_000_000;\n\n    uint8 internal constant DECIMALS_6 = 6;\n    uint8 internal constant PRICE_DECIMALS = 10;\n    uint64 internal constant PRICE_1 = uint64(10 ** PRICE_DECIMALS);\n\n    uint256 internal constant Q64 = 1 << 64;\n    uint256 internal constant Q96 = 1 << 96;\n    uint256 internal constant Q72 = 1 << 72;\n}\n"}, "contracts/libraries/LiquidityReader.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport \"../misc/interfaces/IReader.sol\";\nimport \"../core/MarketManagerUpgradeable.sol\";\n\nlibrary LiquidityReader {\n    using SafeCast for *;\n\n    function calcLPTPrice(\n        IReader.ReaderState storage _readerState,\n        IERC20 _market,\n        uint64 _indexPrice\n    ) public returns (uint256 totalSupply_, uint128 liquidity, uint64 price) {\n        IMarketManager marketManager = _readerState.marketManager;\n        if (!marketManager.isEnabledMarket(_market)) revert IConfigurable.MarketNotEnabled(_market);\n\n        totalSupply_ = ILPToken(LiquidityUtil.computeLPTokenAddress(_market, address(marketManager))).totalSupply();\n        if (totalSupply_ == 0) return (0, 0, Constants.PRICE_1);\n\n        IReader.MockState storage mockState = _readerState.mockState;\n        IMarketManager.State storage state = mockState.state;\n        state.packedState = marketManager.packedStates(_market);\n        mockState.marketConfig = marketManager.marketConfigs(_market);\n        IConfigurable.MarketConfig storage marketConfig = mockState.marketConfig;\n\n        IMarketManager.PackedState storage packedState = state.packedState;\n        liquidity = packedState.lpLiquidity;\n        int256 pnl = PositionUtil.calcUnrealizedPnL(\n            SHORT,\n            packedState.lpNetSize,\n            packedState.lpEntryPrice,\n            _indexPrice\n        );\n        unchecked {\n            uint256 liquidityWithPnL = (pnl + int256(uint256(liquidity))).toUint256().toUint128();\n            if (marketConfig.decimals >= Constants.DECIMALS_6) {\n                price = Math\n                    .mulDiv(\n                        liquidityWithPnL,\n                        _indexPrice,\n                        totalSupply_ * (10 ** (marketConfig.decimals - Constants.DECIMALS_6))\n                    )\n                    .toUint64();\n            } else {\n                price = Math\n                    .mulDiv(\n                        liquidityWithPnL * (10 ** (Constants.DECIMALS_6 - marketConfig.decimals)),\n                        _indexPrice,\n                        totalSupply_\n                    )\n                    .toUint64();\n            }\n        }\n\n        delete _readerState.mockState;\n    }\n\n    function quoteBurnPUSDToMintLPT(\n        IReader.ReaderState storage _readerState,\n        IERC20 _market,\n        uint96 _amountIn,\n        uint64 _indexPrice\n    ) public returns (uint96 burnPUSDReceiveAmount, uint64 mintLPTTokenValue) {\n        IMarketManager marketManager = _readerState.marketManager;\n        if (!marketManager.isEnabledMarket(_market)) revert IConfigurable.MarketNotEnabled(_market);\n\n        IReader.MockState storage mockState = _readerState.mockState;\n        IMarketManager.State storage state = mockState.state;\n        mockState.marketConfig = marketManager.marketConfigs(_market);\n        IConfigurable.MarketConfig storage marketConfig = mockState.marketConfig;\n\n        IMarketManager.PackedState memory packedState = marketManager.packedStates(_market);\n        state.packedState = packedState;\n        IPUSDManager.GlobalPUSDPosition memory pusdPosition = marketManager.globalPUSDPositions(_market);\n        state.globalPUSDPosition = pusdPosition;\n        state.tokenBalance = marketManager.tokenBalances(_market);\n        (state.accumulateScaledUSDPnL, state.previousSettledPrice) = marketManager.reviseLiquidityPnLStates(_market);\n\n        PUSD pusd = PUSDManagerUtil.deployPUSD();\n        pusd.mint(address(this), pusdPosition.totalSupply - _amountIn); // for mock\n\n        (, burnPUSDReceiveAmount) = PUSDManagerUtil.burn(\n            state,\n            marketConfig,\n            PUSDManagerUtil.BurnParam({\n                market: IERC20(address(this)), // for mock\n                exactIn: true,\n                amount: _amountIn,\n                callback: IPUSDManagerCallback(address(this)), // for mock\n                indexPrice: _indexPrice,\n                receiver: address(this)\n            }),\n            bytes(\"\")\n        );\n\n        uint256 totalSupply = ILPToken(LiquidityUtil.computeLPTokenAddress(_market, address(marketManager)))\n            .totalSupply();\n        LPToken token = LiquidityUtil.deployLPToken(IERC20(address(this)), \"Mock\");\n        token.mint(address(this), totalSupply); // for mock\n\n        mintLPTTokenValue = LiquidityUtil.mintLPT(\n            state,\n            marketConfig,\n            LiquidityUtil.MintParam({\n                market: IERC20(address(this)), // for mock\n                account: address(this),\n                receiver: address(this),\n                liquidity: burnPUSDReceiveAmount,\n                indexPrice: _indexPrice\n            })\n        );\n\n        delete _readerState.mockState;\n    }\n\n    function quoteBurnLPTToMintPUSD(\n        IReader.ReaderState storage _readerState,\n        IERC20 _market,\n        uint64 _amountIn,\n        uint64 _indexPrice\n    ) public returns (uint96 burnLPTReceiveAmount, uint64 mintPUSDTokenValue) {\n        IMarketManager marketManager = _readerState.marketManager;\n        if (!marketManager.isEnabledMarket(_market)) revert IConfigurable.MarketNotEnabled(_market);\n\n        IReader.MockState storage mockState = _readerState.mockState;\n        IMarketManager.State storage state = mockState.state;\n        mockState.marketConfig = marketManager.marketConfigs(_market);\n        IConfigurable.MarketConfig storage marketConfig = mockState.marketConfig;\n\n        state.packedState = marketManager.packedStates(_market);\n        IPUSDManager.GlobalPUSDPosition memory pusdPosition = marketManager.globalPUSDPositions(_market);\n        state.globalPUSDPosition = marketManager.globalPUSDPositions(_market);\n        state.tokenBalance = marketManager.tokenBalances(_market);\n        (state.accumulateScaledUSDPnL, state.previousSettledPrice) = marketManager.reviseLiquidityPnLStates(_market);\n\n        uint256 totalSupply = ILPToken(LiquidityUtil.computeLPTokenAddress(_market, address(marketManager)))\n            .totalSupply();\n        LPToken token = LiquidityUtil.deployLPToken(IERC20(address(this)), \"Mock\");\n        token.mint(address(this), totalSupply); // for mock\n\n        burnLPTReceiveAmount = LiquidityUtil.burnLPT(\n            state,\n            marketConfig,\n            LiquidityUtil.BurnParam({\n                market: IERC20(address(this)), // for mock\n                account: address(this),\n                receiver: address(this),\n                tokenValue: _amountIn,\n                indexPrice: _indexPrice\n            })\n        );\n        delete mockState.totalSupply; // reset totalSupply\n\n        PUSD pusd = PUSDManagerUtil.deployPUSD();\n        pusd.mint(address(this), pusdPosition.totalSupply); // for mock\n        (, mintPUSDTokenValue) = PUSDManagerUtil.mint(\n            state,\n            marketConfig,\n            PUSDManagerUtil.MintParam({\n                market: IERC20(address(this)), // for mock\n                exactIn: true,\n                amount: burnLPTReceiveAmount,\n                callback: IPUSDManagerCallback(address(this)), // for mock\n                indexPrice: _indexPrice,\n                receiver: address(this)\n            }),\n            msg.data // for mock\n        );\n\n        delete _readerState.mockState;\n    }\n}\n"}, "contracts/libraries/LiquidityUtil.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport \"../core/LPToken.sol\";\nimport \"./MarketUtil.sol\";\nimport \"./PositionUtil.sol\";\nimport {SHORT} from \"../types/Side.sol\";\nimport {M as Math} from \"./Math.sol\";\nimport \"./UnsafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\n\n/// @notice Utility library for managing liquidity\nlibrary LiquidityUtil {\n    using SafeCast for *;\n    using UnsafeMath for *;\n\n    bytes32 internal constant LP_TOKEN_INIT_CODE_HASH =\n        0xf7ee18f8779e8a47b9fee2bf37816783fe8615833733cf03cc48cd8fc3e3128b;\n\n    struct MintParam {\n        IERC20 market;\n        address account;\n        address receiver;\n        uint96 liquidity;\n        uint64 indexPrice;\n    }\n\n    struct BurnParam {\n        IERC20 market;\n        address account;\n        address receiver;\n        uint64 tokenValue;\n        uint64 indexPrice;\n    }\n\n    function deployLPToken(IERC20 _market, string calldata _tokenSymbol) public returns (LPToken token) {\n        token = new LPToken{salt: bytes32(uint256(uint160(address(_market))))}();\n        token.initialize(_market, _tokenSymbol);\n    }\n\n    function computeLPTokenAddress(IERC20 _market) internal view returns (address) {\n        return computeLPTokenAddress(_market, address(this));\n    }\n\n    function computeLPTokenAddress(IERC20 _market, address _deployer) internal pure returns (address) {\n        return Create2.computeAddress(bytes32(uint256(uint160(address(_market)))), LP_TOKEN_INIT_CODE_HASH, _deployer);\n    }\n\n    function mintLPT(\n        IMarketManager.State storage _state,\n        IConfigurable.MarketConfig storage _cfg,\n        MintParam memory _param\n    ) public returns (uint64 tokenValue) {\n        unchecked {\n            uint256 tradingFee = Math.ceilDiv(\n                uint256(_param.liquidity) * _cfg.liquidityTradingFeeRate,\n                Constants.BASIS_POINTS_DIVISOR\n            );\n            IMarketManager.PackedState storage packedState = _state.packedState;\n            uint128 liquidityBefore = packedState.lpLiquidity;\n            uint24 protocolFeeRate = liquidityBefore == 0 ? Constants.BASIS_POINTS_DIVISOR : _cfg.protocolFeeRate;\n            uint96 protocolFee = uint96((tradingFee * protocolFeeRate) / Constants.BASIS_POINTS_DIVISOR);\n            uint96 liquidityFee = uint96(tradingFee - protocolFee);\n\n            uint96 liquidity = uint96(_param.liquidity - tradingFee);\n            uint256 liquidityAfter = uint256(liquidityBefore) + liquidity;\n            if (liquidityAfter > _cfg.liquidityCap)\n                revert IMarketErrors.LiquidityCapExceeded(liquidityBefore, _param.liquidity, _cfg.liquidityCap);\n\n            // If the cap is exceeded due to the trading fee, the excess part is added to the protocol fee\n            uint256 liquidityAfterWithFee = liquidityAfter + liquidityFee;\n            if (liquidityAfterWithFee > _cfg.liquidityCap) {\n                liquidityFee = uint96(_cfg.liquidityCap - liquidityAfter);\n                protocolFee = uint96(tradingFee - liquidityFee);\n                liquidityAfter = _cfg.liquidityCap;\n            } else {\n                liquidityAfter = liquidityAfterWithFee;\n            }\n\n            _state.protocolFee += protocolFee; // overflow is desired\n            emit IMarketManager.ProtocolFeeIncreasedByLPTradingFee(_param.market, protocolFee);\n\n            packedState.lpLiquidity = uint128(liquidityAfter);\n\n            ILPToken token = ILPToken(computeLPTokenAddress(_param.market));\n            uint256 totalSupply = token.totalSupply();\n            if (totalSupply == 0) {\n                tokenValue = PositionUtil.calcDecimals6TokenValue(\n                    liquidity,\n                    _param.indexPrice,\n                    _cfg.decimals,\n                    Math.Rounding.Down\n                );\n            } else {\n                int256 pnl = PositionUtil.calcUnrealizedPnL(\n                    SHORT,\n                    packedState.lpNetSize,\n                    packedState.lpEntryPrice,\n                    _param.indexPrice\n                );\n                tokenValue = Math\n                    .mulDiv(liquidity, totalSupply, (pnl + int256(uint256(liquidityBefore) + liquidityFee)).toUint256())\n                    .toUint64();\n            }\n\n            // mint LPT\n            token.mint(_param.receiver, tokenValue);\n\n            emit IMarketLiquidity.GlobalLiquidityIncreasedByLPTradingFee(_param.market, liquidityFee);\n            emit IMarketLiquidity.LPTMinted(\n                _param.market,\n                _param.account,\n                _param.receiver,\n                liquidity,\n                tokenValue,\n                uint96(tradingFee)\n            );\n        }\n    }\n\n    function burnLPT(\n        IMarketManager.State storage _state,\n        IConfigurable.MarketConfig storage _cfg,\n        BurnParam memory _param\n    ) public returns (uint96 liquidity) {\n        IMarketManager.PackedState storage packedState = _state.packedState;\n        (uint128 liquidityBefore, uint128 netSize) = (packedState.lpLiquidity, packedState.lpNetSize);\n        int256 pnl = PositionUtil.calcUnrealizedPnL(SHORT, netSize, packedState.lpEntryPrice, _param.indexPrice);\n        ILPToken token = ILPToken(computeLPTokenAddress(_param.market));\n        unchecked {\n            uint256 totalSupplyBefore = token.totalSupply();\n            uint96 liquidityWithFee = Math\n                .mulDiv((pnl + int256(uint256(liquidityBefore))).toUint256(), _param.tokenValue, totalSupplyBefore)\n                .toUint96();\n            uint256 tradingFee = Math.ceilDiv(\n                uint256(liquidityWithFee) * _cfg.liquidityTradingFeeRate,\n                Constants.BASIS_POINTS_DIVISOR\n            );\n\n            uint24 protocolFeeRate = totalSupplyBefore == _param.tokenValue\n                ? Constants.BASIS_POINTS_DIVISOR\n                : _cfg.protocolFeeRate;\n            uint96 protocolFee = uint96((tradingFee * protocolFeeRate) / Constants.BASIS_POINTS_DIVISOR);\n            _state.protocolFee += protocolFee; // overflow is desired\n            emit IMarketManager.ProtocolFeeIncreasedByLPTradingFee(_param.market, protocolFee);\n\n            uint96 liquidityFee = uint96(tradingFee - protocolFee);\n            // netSize <= liquidityBefore - liquidityWithFee + liquidityFee\n            if (uint256(netSize) + liquidityWithFee > uint256(liquidityBefore) + liquidityFee)\n                revert IMarketErrors.BalanceRateCapExceeded();\n            uint128 liquidityAfter = liquidityBefore + liquidityFee - liquidityWithFee;\n            packedState.lpLiquidity = liquidityAfter;\n            liquidity = liquidityWithFee - uint96(tradingFee);\n\n            // burn LPT\n            token.burn(_param.tokenValue);\n\n            emit IMarketLiquidity.GlobalLiquidityIncreasedByLPTradingFee(_param.market, liquidityFee);\n            emit IMarketLiquidity.LPTBurned(\n                _param.market,\n                _param.account,\n                _param.receiver,\n                liquidity,\n                _param.tokenValue,\n                uint96(tradingFee)\n            );\n        }\n    }\n\n    function settlePosition(\n        IMarketManager.State storage _state,\n        IERC20 _market,\n        Side _side,\n        uint64 _indexPrice,\n        uint96 _sizeDelta\n    ) internal {\n        IMarketManager.PackedState storage packedState = _state.packedState;\n        (uint128 netSize, uint64 entryPrice) = (packedState.lpNetSize, packedState.lpEntryPrice);\n        unchecked {\n            if (_side.isLong()) {\n                uint64 entryPriceAfter = PositionUtil.calcNextEntryPrice(\n                    SHORT,\n                    netSize,\n                    entryPrice,\n                    _sizeDelta,\n                    _indexPrice\n                );\n                packedState.lpNetSize = netSize + _sizeDelta;\n                packedState.lpEntryPrice = entryPriceAfter;\n                emit IMarketLiquidity.GlobalLiquiditySettled(_market, int256(uint256(_sizeDelta)), 0, entryPriceAfter);\n            } else {\n                (int184 tokenPnL, int184 scaledUSDPnL) = PositionUtil.calcUnrealizedPnL2(\n                    SHORT,\n                    _sizeDelta,\n                    entryPrice,\n                    _indexPrice\n                );\n                packedState.lpLiquidity = (int256(uint256(packedState.lpLiquidity)) + tokenPnL).toUint256().toUint128();\n                packedState.lpNetSize = netSize - _sizeDelta;\n\n                emit IMarketLiquidity.GlobalLiquiditySettled(\n                    _market,\n                    -int256(uint256(_sizeDelta)),\n                    tokenPnL,\n                    entryPrice\n                );\n\n                reviseLiquidityPnL(_state, _market, _indexPrice, scaledUSDPnL);\n            }\n        }\n    }\n\n    function reviseLiquidityPnL(\n        IMarketManager.State storage _state,\n        IERC20 _market,\n        uint64 _indexPrice,\n        int184 _scaledUSDPnL\n    ) internal returns (int256 revisedTokenPnL) {\n        int184 accumulateScaledUSDPnL = _state.accumulateScaledUSDPnL;\n        uint64 previousSettledPrice = _state.previousSettledPrice;\n        if (previousSettledPrice > 0) {\n            unchecked {\n                int256 priceDiff = int256(uint256(previousSettledPrice)) - int256(uint256(_indexPrice));\n                priceDiff *= accumulateScaledUSDPnL;\n                revisedTokenPnL = priceDiff >= 0\n                    ? priceDiff / int256(uint256(_indexPrice) * previousSettledPrice)\n                    : -int256(Math.ceilDiv(uint256(-priceDiff), uint256(_indexPrice) * previousSettledPrice));\n            }\n            _state.packedState.lpLiquidity = (int256(uint256(_state.packedState.lpLiquidity)) + revisedTokenPnL)\n                .toUint256()\n                .toUint128();\n        }\n        _state.previousSettledPrice = _indexPrice;\n        _state.accumulateScaledUSDPnL = accumulateScaledUSDPnL + _scaledUSDPnL;\n\n        emit IMarketLiquidity.GlobalLiquidityPnLRevised(_market, _indexPrice, _scaledUSDPnL, revisedTokenPnL);\n    }\n}\n"}, "contracts/libraries/MarketUtil.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport \"./Constants.sol\";\nimport \"../core/interfaces/IMarketManager.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {SafeERC20 as OneInchSafeERC20} from \"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\";\n\n/// @notice Utility library for market manager\nlibrary MarketUtil {\n    using SafeCast for *;\n\n    /// @notice Transfer ETH from the contract to the receiver\n    /// @param _receiver The address of the receiver\n    /// @param _amount The amount of ETH to transfer\n    /// @param _executionGasLimit The gas limit for the transfer\n    function transferOutETH(address payable _receiver, uint256 _amount, uint256 _executionGasLimit) internal {\n        if (_amount == 0) return;\n\n        if (address(this).balance < _amount) revert IMarketErrors.InsufficientBalance(address(this).balance, _amount);\n\n        (bool success, ) = _receiver.call{value: _amount, gas: _executionGasLimit}(\"\");\n        if (!success) revert IMarketErrors.FailedTransferETH();\n    }\n\n    /// @notice Check if the account is a deployed contract\n    /// @param _account The address of the account\n    /// @return true if the account is a deployed contract, false otherwise\n    function isDeployedContract(address _account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        // prettier-ignore\n        assembly { size := extcodesize(_account) }\n        return size > 0;\n    }\n\n    /// @notice `Gov` uses the stability fund\n    /// @param _state The state of the market\n    /// @param _market The target market contract address, such as the contract address of WETH\n    /// @param _stabilityFundDelta The amount of stability fund to be used\n    /// @param _receiver The address to receive the stability fund\n    function govUseStabilityFund(\n        IMarketManager.State storage _state,\n        IERC20 _market,\n        uint128 _stabilityFundDelta,\n        address _receiver\n    ) public {\n        _state.globalStabilityFund -= _stabilityFundDelta;\n        emit IMarketManager.GlobalStabilityFundGovUsed(_market, _receiver, _stabilityFundDelta);\n    }\n\n    /// @notice Validate the leverage of a position\n    /// @param _margin The margin of the position\n    /// @param _size The size of the position\n    /// @param _maxLeverage The maximum acceptable leverage of the position\n    function validateLeverage(uint128 _margin, uint128 _size, uint8 _maxLeverage) internal pure {\n        unchecked {\n            if (uint256(_margin) * _maxLeverage < _size)\n                revert IMarketErrors.LeverageTooHigh(_margin, _size, _maxLeverage);\n        }\n    }\n\n    function safePermit(IERC20 _token, address _spender, bytes calldata _data) internal {\n        if (_data.length == 0) return;\n        OneInchSafeERC20.safePermit(_token, msg.sender, _spender, _data);\n    }\n}\n"}, "contracts/libraries/Math.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Math as _math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/// @title Math library\n/// @dev Derived from OpenZeppelin's Math library. To avoid conflicts with OpenZeppelin's Math,\n/// it has been renamed to `M` here. Import it using the following statement:\n///      import {M as Math} from \"path/to/Math.sol\";\nlibrary M {\n    enum Rounding {\n        Up,\n        Down\n    }\n\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /// @notice Calculate `a / b` with rounding up\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Guarantee the same behavior as in a regular Solidity division\n        if (b == 0) return a / b;\n\n        // prettier-ignore\n        unchecked { return a == 0 ? 0 : (a - 1) / b + 1; }\n    }\n\n    /// @notice Calculate `x * y / denominator` with rounding down\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256) {\n        return _math.mulDiv(x, y, denominator);\n    }\n\n    /// @notice Calculate `x * y / denominator` with rounding up\n    function mulDivUp(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256) {\n        return _math.mulDiv(x, y, denominator, _math.Rounding.Ceil);\n    }\n\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return _math.mulDiv(x, y, denominator, rounding == Rounding.Up ? _math.Rounding.Ceil : _math.Rounding.Floor);\n    }\n\n    /// @notice Calculate `x * y / denominator` with rounding down and up\n    /// @return result Result with rounding down\n    /// @return resultUp Result with rounding up\n    function mulDiv2(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result, uint256 resultUp) {\n        result = _math.mulDiv(x, y, denominator);\n        resultUp = result;\n        if (mulmod(x, y, denominator) > 0) resultUp += 1;\n    }\n}\n"}, "contracts/libraries/PositionReader.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport \"../misc/interfaces/IReader.sol\";\nimport \"../core/MarketManagerUpgradeable.sol\";\n\nlibrary PositionReader {\n    using SafeCast for *;\n    using UnsafeMath for *;\n\n    /// @dev This struct is introduced to solve the stack too deep error during contract compilation\n    struct DecreasePositionRes {\n        uint96 decreasePositionReceiveAmount;\n        uint96 marginAfter;\n    }\n\n    function quoteBurnPUSDToIncreasePosition(\n        IReader.ReaderState storage _readerState,\n        IERC20 _market,\n        address _account,\n        uint64 _amountIn,\n        uint64 _indexPrice,\n        uint32 _leverage\n    ) public returns (uint96 burnPUSDReceiveAmount, uint96 size, IMarketPosition.Position memory position) {\n        IMarketManager marketManager = _readerState.marketManager;\n        if (!marketManager.isEnabledMarket(_market)) revert IConfigurable.MarketNotEnabled(_market);\n\n        IReader.MockState storage mockState = _readerState.mockState;\n        IMarketManager.State storage state = mockState.state;\n        mockState.marketConfig = marketManager.marketConfigs(_market);\n        IConfigurable.MarketConfig storage marketConfig = mockState.marketConfig;\n\n        state.packedState = marketManager.packedStates(_market);\n        IPUSDManager.GlobalPUSDPosition memory pusdPosition = marketManager.globalPUSDPositions(_market);\n        state.globalPUSDPosition = pusdPosition;\n        state.tokenBalance = marketManager.tokenBalances(_market);\n        (state.accumulateScaledUSDPnL, state.previousSettledPrice) = marketManager.reviseLiquidityPnLStates(_market);\n\n        PUSD pusd = PUSDManagerUtil.deployPUSD();\n        pusd.mint(address(this), pusdPosition.totalSupply - _amountIn); // for mock\n        (, burnPUSDReceiveAmount) = PUSDManagerUtil.burn(\n            state,\n            marketConfig,\n            PUSDManagerUtil.BurnParam({\n                market: IERC20(address(this)), // for mock\n                exactIn: true,\n                amount: _amountIn,\n                callback: IPUSDManagerCallback(address(this)), // for mock\n                indexPrice: _indexPrice,\n                receiver: address(this)\n            }),\n            bytes(\"\")\n        );\n\n        mapping(address => IMarketPosition.Position) storage positions = state.longPositions;\n        positions[address(this)] = marketManager.longPositions(_market, _account); // for mock\n\n        IMarketManager.PackedState storage packedState = state.packedState;\n        uint96 leverageSize = _mulLeverage(burnPUSDReceiveAmount, _leverage);\n        uint96 spread = PositionUtil.refreshSpreadFactor(\n            packedState,\n            marketConfig,\n            IERC20(address(this)), // for mock\n            leverageSize,\n            LONG\n        );\n\n        uint32 tradingFeeRate = PositionUtil.calcTradingFeeRate(\n            marketConfig,\n            packedState.lpLiquidity,\n            packedState.lpNetSize + leverageSize\n        );\n        uint96 tradingFee;\n        unchecked {\n            tradingFee = Math\n                .ceilDiv(uint256(leverageSize) * tradingFeeRate, Constants.BASIS_POINTS_DIVISOR)\n                .toUint96();\n            uint256 feeAmount = uint256(tradingFee) + spread;\n            if (burnPUSDReceiveAmount <= feeAmount) revert IMarketErrors.InsufficientMargin();\n            size = _mulLeverage(burnPUSDReceiveAmount - uint96(feeAmount), _leverage);\n        }\n\n        PositionUtil.increasePosition(\n            state,\n            marketConfig,\n            PositionUtil.IncreasePositionParam({\n                market: IERC20(address(this)), // for mock\n                account: address(this),\n                sizeDelta: size,\n                marginDelta: burnPUSDReceiveAmount,\n                minIndexPrice: _indexPrice,\n                maxIndexPrice: _indexPrice\n            })\n        );\n\n        position = positions[address(this)];\n\n        delete positions[address(this)];\n        delete _readerState.mockState;\n    }\n\n    function quoteDecreasePositionToMintPUSD(\n        IReader.ReaderState storage _readerState,\n        IERC20 _market,\n        address _account,\n        uint96 _size,\n        uint64 _indexPrice\n    ) public returns (uint96 decreasePositionReceiveAmount, uint64 mintPUSDTokenValue, uint96 marginAfter) {\n        IMarketManager marketManager = _readerState.marketManager;\n        if (!marketManager.isEnabledMarket(_market)) revert IConfigurable.MarketNotEnabled(_market);\n\n        IReader.MockState storage mockState = _readerState.mockState;\n        IMarketManager.State storage state = mockState.state;\n        mockState.marketConfig = marketManager.marketConfigs(_market);\n        IConfigurable.MarketConfig storage marketConfig = mockState.marketConfig;\n        state.packedState = marketManager.packedStates(_market);\n        IPUSDManager.GlobalPUSDPosition memory pusdPosition = marketManager.globalPUSDPositions(_market);\n        state.globalPUSDPosition = pusdPosition;\n        state.tokenBalance = marketManager.tokenBalances(_market);\n        (state.accumulateScaledUSDPnL, state.previousSettledPrice) = marketManager.reviseLiquidityPnLStates(_market);\n\n        // settle position\n        IMarketPosition.Position memory position = marketManager.longPositions(_market, _account);\n        if (position.size == 0) revert IMarketErrors.PositionNotFound(_account);\n\n        if (position.size < _size) revert IMarketErrors.InsufficientSizeToDecrease(position.size, _size);\n\n        mapping(address => IMarketPosition.Position) storage positions = state.longPositions;\n        positions[address(this)] = position; // for mock\n\n        DecreasePositionRes memory res = _decreasePosition(_readerState, position, _size, _indexPrice);\n\n        PUSD pusd = PUSDManagerUtil.deployPUSD();\n        pusd.mint(address(this), pusdPosition.totalSupply); // for mock\n        if (res.decreasePositionReceiveAmount > 0) {\n            (, mintPUSDTokenValue) = PUSDManagerUtil.mint(\n                state,\n                marketConfig,\n                PUSDManagerUtil.MintParam({\n                    market: IERC20(address(this)), // for mock\n                    exactIn: true,\n                    amount: res.decreasePositionReceiveAmount,\n                    callback: IPUSDManagerCallback(address(this)), // for mock\n                    indexPrice: _indexPrice,\n                    receiver: address(this)\n                }),\n                msg.data // for mock\n            );\n        }\n\n        (decreasePositionReceiveAmount, marginAfter) = (res.decreasePositionReceiveAmount, res.marginAfter);\n\n        delete positions[address(this)];\n        delete _readerState.mockState;\n    }\n\n    function quoteIncreasePositionBySize(\n        IReader.ReaderState storage _readerState,\n        IERC20 _market,\n        address _account,\n        uint96 _size,\n        uint32 _leverage,\n        uint64 _indexPrice\n    ) public returns (uint96 payAmount, uint96 marginAfter, uint96 spread, uint96 tradingFee, uint64 liquidationPrice) {\n        IMarketManager marketManager = _readerState.marketManager;\n        if (!marketManager.isEnabledMarket(_market)) revert IConfigurable.MarketNotEnabled(_market);\n\n        IReader.MockState storage mockState = _readerState.mockState;\n        IMarketManager.State storage state = mockState.state;\n        mockState.marketConfig = marketManager.marketConfigs(_market);\n        IConfigurable.MarketConfig storage marketConfig = mockState.marketConfig;\n\n        state.packedState = marketManager.packedStates(_market);\n        IMarketManager.PackedState storage packedState = state.packedState;\n\n        IMarketPosition.Position memory position = marketManager.longPositions(_market, _account);\n        (uint256 sizeAfter, uint128 lpNetSizeAfter) = PositionUtil.validateIncreaseSize(\n            marketConfig,\n            packedState,\n            position.size,\n            _size\n        );\n\n        spread = PositionUtil.refreshSpreadFactor(\n            packedState,\n            marketConfig,\n            IERC20(address(this)), // for mock\n            _size,\n            LONG\n        );\n\n        uint32 tradingFeeRate = PositionUtil.calcTradingFeeRate(marketConfig, packedState.lpLiquidity, lpNetSizeAfter);\n        unchecked {\n            tradingFee = Math.ceilDiv(uint256(_size) * tradingFeeRate, Constants.BASIS_POINTS_DIVISOR).toUint96();\n        }\n\n        uint256 fees = uint256(tradingFee) + spread;\n        payAmount = (Math.mulDivUp(_size, Constants.BASIS_POINTS_DIVISOR, _leverage) + fees).toUint96();\n        if (position.size == 0 && payAmount < marketConfig.minMarginPerPosition)\n            payAmount = marketConfig.minMarginPerPosition;\n        marginAfter = (uint256(position.margin) + payAmount - fees).toUint96();\n\n        unchecked {\n            uint64 maxLeverage = marketConfig.maxLeveragePerPosition;\n            if (uint256(marginAfter) * maxLeverage < sizeAfter) {\n                uint256 minMargin = Math.ceilDiv(sizeAfter, maxLeverage);\n                payAmount = (minMargin + fees - position.margin).toUint96();\n                marginAfter = uint96(minMargin);\n            }\n        }\n\n        uint64 entryPriceAfter = PositionUtil.calcNextEntryPrice(\n            LONG,\n            position.size,\n            position.entryPrice,\n            _size,\n            _indexPrice\n        );\n\n        position.margin = marginAfter;\n        position.size = uint96(sizeAfter);\n        position.entryPrice = entryPriceAfter;\n\n        // calculate the liquidation price\n        liquidationPrice = PositionUtil.calcLiquidationPrice(\n            position,\n            marketConfig.liquidationFeeRatePerPosition,\n            marketConfig.tradingFeeRate,\n            marketConfig.liquidationExecutionFee\n        );\n\n        delete _readerState.mockState;\n    }\n\n    function _decreasePosition(\n        IReader.ReaderState storage _readerState,\n        IMarketPosition.Position memory _position,\n        uint96 _size,\n        uint64 _indexPrice\n    ) internal returns (DecreasePositionRes memory res) {\n        PositionUtil.DecreasePositionParam memory decreasePosition = PositionUtil.DecreasePositionParam({\n            market: IERC20(address(this)), // for mock\n            account: address(this),\n            marginDelta: 0,\n            sizeDelta: _size,\n            minIndexPrice: _indexPrice,\n            maxIndexPrice: _indexPrice,\n            receiver: address(this)\n        });\n\n        IMarketManager.State storage state = _readerState.mockState.state;\n        IConfigurable.MarketConfig storage marketConfig = _readerState.mockState.marketConfig;\n        if (_position.size == _size) {\n            (, res.decreasePositionReceiveAmount) = PositionUtil.decreasePosition(\n                state,\n                marketConfig,\n                decreasePosition\n            );\n        } else {\n            uint96 spread = PositionUtil.refreshSpreadFactor(\n                state.packedState,\n                marketConfig,\n                IERC20(address(this)), // for mock\n                _size,\n                SHORT\n            );\n            uint96 tradingFee = PositionUtil.calcTradingFee(\n                PositionUtil.DistributeFeeParam({\n                    market: IERC20(address(this)),\n                    size: _size,\n                    entryPrice: _indexPrice,\n                    indexPrice: _indexPrice,\n                    rounding: Math.Rounding.Up,\n                    tradingFeeRate: marketConfig.tradingFeeRate,\n                    protocolFeeRate: 0\n                })\n            );\n            int256 realizedPnL = PositionUtil.calcUnrealizedPnL(LONG, _size, _position.entryPrice, _indexPrice);\n            // calculate the margin required for the remaining position\n            unchecked {\n                int256 marginDelta = int256((uint256(_position.margin) * _size) / _position.size);\n                int256 pnl = realizedPnL - int256(uint256(tradingFee) + spread);\n                if (marginDelta < -pnl) revert IMarketErrors.InsufficientMargin();\n                res.decreasePositionReceiveAmount = uint256(marginDelta + pnl).toUint96();\n                res.marginAfter = _position.margin - uint256(marginDelta).toUint96();\n            }\n\n            decreasePosition.marginDelta = res.decreasePositionReceiveAmount;\n            PositionUtil.decreasePosition(state, marketConfig, decreasePosition);\n        }\n    }\n\n    function _mulLeverage(uint96 _amount, uint32 _leverage) private pure returns (uint96 size) {\n        return Math.mulDiv(_amount, _leverage, Constants.BASIS_POINTS_DIVISOR).toUint96();\n    }\n}\n"}, "contracts/libraries/PositionUtil.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport \"./MarketUtil.sol\";\nimport \"./LiquidityUtil.sol\";\nimport \"./SpreadUtil.sol\";\nimport \"./UnsafeMath.sol\";\nimport {LONG, SHORT} from \"../types/Side.sol\";\nimport \"../core/interfaces/IPUSD.sol\";\nimport \"./PUSDManagerUtil.sol\";\n\n/// @notice Utility library for trader positions\nlibrary PositionUtil {\n    using SafeCast for *;\n    using UnsafeMath for *;\n\n    struct IncreasePositionParam {\n        IERC20 market;\n        address account;\n        uint96 marginDelta;\n        uint96 sizeDelta;\n        uint64 minIndexPrice;\n        uint64 maxIndexPrice;\n    }\n\n    struct DecreasePositionParam {\n        IERC20 market;\n        address account;\n        uint96 marginDelta;\n        uint96 sizeDelta;\n        uint64 minIndexPrice;\n        uint64 maxIndexPrice;\n        address receiver;\n    }\n\n    struct LiquidatePositionParam {\n        IERC20 market;\n        address account;\n        uint64 minIndexPrice;\n        uint64 maxIndexPrice;\n        address feeReceiver;\n    }\n\n    struct MaintainMarginRateParam {\n        int256 margin;\n        uint96 size;\n        uint64 entryPrice;\n        uint64 decreaseIndexPrice;\n        bool liquidatablePosition;\n    }\n\n    struct DistributeFeeParam {\n        IERC20 market;\n        uint96 size;\n        uint64 entryPrice;\n        uint64 indexPrice;\n        Math.Rounding rounding;\n        uint24 tradingFeeRate;\n        uint24 protocolFeeRate;\n    }\n\n    function increasePosition(\n        IMarketManager.State storage _state,\n        IConfigurable.MarketConfig storage _cfg,\n        IncreasePositionParam memory _param\n    ) internal returns (uint96 spread) {\n        IMarketManager.Position storage position = _state.longPositions[_param.account];\n        IMarketManager.Position memory positionCache = position;\n        if (positionCache.size == 0) {\n            if (_param.sizeDelta == 0) revert IMarketErrors.PositionNotFound(_param.account);\n\n            if (_param.marginDelta < _cfg.minMarginPerPosition) revert IMarketErrors.InsufficientMargin();\n        }\n\n        uint96 tradingFee;\n        uint96 sizeAfter = positionCache.size;\n        IMarketManager.PackedState storage packedState = _state.packedState;\n        if (_param.sizeDelta > 0) {\n            spread = refreshSpreadFactor(packedState, _cfg, _param.market, _param.sizeDelta, LONG);\n            distributeSpread(_state, _param.market, spread);\n\n            uint128 lpNetSizeAfter;\n            (sizeAfter, lpNetSizeAfter) = validateIncreaseSize(_cfg, packedState, positionCache.size, _param.sizeDelta);\n            packedState.longSize += _param.sizeDelta;\n\n            // settle liquidity\n            LiquidityUtil.settlePosition(_state, _param.market, LONG, _param.maxIndexPrice, _param.sizeDelta);\n\n            tradingFee = distributeTradingFee(\n                _state,\n                DistributeFeeParam({\n                    market: _param.market,\n                    size: _param.sizeDelta,\n                    entryPrice: _param.maxIndexPrice,\n                    indexPrice: _param.maxIndexPrice,\n                    rounding: Math.Rounding.Up,\n                    tradingFeeRate: calcTradingFeeRate(_cfg, packedState.lpLiquidity, lpNetSizeAfter),\n                    protocolFeeRate: _cfg.protocolFeeRate\n                })\n            );\n        }\n\n        int256 marginAfter;\n        unchecked {\n            marginAfter = int256(uint256(positionCache.margin) + _param.marginDelta);\n            marginAfter -= int256(uint256(tradingFee) + spread);\n        }\n\n        uint64 entryPriceAfter = calcNextEntryPrice(\n            LONG,\n            positionCache.size,\n            positionCache.entryPrice,\n            _param.sizeDelta,\n            _param.maxIndexPrice\n        );\n\n        _validatePositionLiquidateMaintainMarginRate(\n            _cfg,\n            MaintainMarginRateParam({\n                margin: marginAfter,\n                size: sizeAfter,\n                entryPrice: entryPriceAfter,\n                decreaseIndexPrice: _param.minIndexPrice,\n                liquidatablePosition: false\n            })\n        );\n        uint96 marginAfterU96 = uint256(marginAfter).toUint96();\n\n        if (_param.sizeDelta > 0) MarketUtil.validateLeverage(marginAfterU96, sizeAfter, _cfg.maxLeveragePerPosition);\n\n        position.margin = marginAfterU96;\n        if (_param.sizeDelta > 0) {\n            position.size = sizeAfter;\n            position.entryPrice = entryPriceAfter;\n        }\n        emit IMarketPosition.PositionIncreased(\n            _param.market,\n            _param.account,\n            _param.marginDelta,\n            marginAfterU96,\n            _param.sizeDelta,\n            _param.maxIndexPrice,\n            entryPriceAfter,\n            tradingFee,\n            spread\n        );\n    }\n\n    function decreasePosition(\n        IMarketManager.State storage _state,\n        IConfigurable.MarketConfig storage _cfg,\n        DecreasePositionParam memory _param\n    ) public returns (uint96 spread, uint96 adjustedMarginDelta) {\n        IMarketManager.Position memory positionCache = _state.longPositions[_param.account];\n        if (positionCache.size == 0) revert IMarketErrors.PositionNotFound(_param.account);\n\n        uint96 tradingFee;\n        uint96 sizeAfter = positionCache.size;\n        int256 realizedPnL;\n        IMarketManager.PackedState storage packedState = _state.packedState;\n        if (_param.sizeDelta > 0) {\n            if (positionCache.size < _param.sizeDelta)\n                revert IMarketErrors.InsufficientSizeToDecrease(_param.sizeDelta, positionCache.size);\n\n            spread = refreshSpreadFactor(packedState, _cfg, _param.market, _param.sizeDelta, SHORT);\n            distributeSpread(_state, _param.market, spread);\n\n            uint128 lpNetSize = packedState.lpNetSize;\n            if (lpNetSize < _param.sizeDelta) {\n                if (!_cfg.liquidityBufferModuleEnabled)\n                    revert IMarketErrors.InsufficientSizeToDecrease(_param.sizeDelta, lpNetSize);\n\n                PUSDManagerUtil.liquidityBufferModuleBurn(\n                    _state,\n                    _cfg,\n                    PUSDManagerUtil.LiquidityBufferModuleBurnParam({\n                        market: _param.market,\n                        account: _param.account,\n                        sizeDelta: uint96(_param.sizeDelta.subU128(lpNetSize)),\n                        indexPrice: _param.maxIndexPrice\n                    })\n                );\n            }\n\n            // never underflow because of the validation above\n            unchecked {\n                sizeAfter -= _param.sizeDelta;\n                packedState.longSize -= _param.sizeDelta;\n            }\n\n            // If the position size becomes zero after the decrease, the marginDelta will be ignored\n            if (sizeAfter == 0) _param.marginDelta = 0;\n\n            // settle liquidity\n            LiquidityUtil.settlePosition(_state, _param.market, SHORT, _param.minIndexPrice, _param.sizeDelta);\n\n            tradingFee = distributeTradingFee(\n                _state,\n                DistributeFeeParam({\n                    market: _param.market,\n                    size: _param.sizeDelta,\n                    entryPrice: positionCache.entryPrice,\n                    indexPrice: _param.minIndexPrice,\n                    rounding: Math.Rounding.Up,\n                    tradingFeeRate: _cfg.tradingFeeRate,\n                    protocolFeeRate: _cfg.protocolFeeRate\n                })\n            );\n\n            int184 scaledUSDPnL;\n            (realizedPnL, scaledUSDPnL) = calcUnrealizedPnL2(\n                LONG,\n                _param.sizeDelta,\n                positionCache.entryPrice,\n                _param.minIndexPrice\n            );\n            LiquidityUtil.reviseLiquidityPnL(_state, _param.market, _param.minIndexPrice, scaledUSDPnL);\n        }\n\n        int256 marginAfter = int256(uint256(positionCache.margin));\n        unchecked {\n            marginAfter += realizedPnL - int256(uint256(tradingFee) + _param.marginDelta + spread);\n            if (marginAfter < 0) revert IMarketErrors.InsufficientMargin();\n        }\n\n        uint96 marginAfterU96 = uint256(marginAfter).toUint96();\n        if (sizeAfter > 0) {\n            _validatePositionLiquidateMaintainMarginRate(\n                _cfg,\n                MaintainMarginRateParam({\n                    margin: marginAfter,\n                    size: sizeAfter,\n                    entryPrice: positionCache.entryPrice,\n                    decreaseIndexPrice: _param.minIndexPrice,\n                    liquidatablePosition: false\n                })\n            );\n            if (_param.marginDelta > 0)\n                MarketUtil.validateLeverage(marginAfterU96, sizeAfter, _cfg.maxLeveragePerPosition);\n\n            // Update position\n            IMarketManager.Position storage position = _state.longPositions[_param.account];\n            position.margin = marginAfterU96;\n            if (_param.sizeDelta > 0) position.size = sizeAfter;\n        } else {\n            // Return all remaining margin if the position position size becomes zero after the decrease\n            _param.marginDelta = marginAfterU96;\n            marginAfterU96 = 0;\n\n            // Delete position\n            delete _state.longPositions[_param.account];\n        }\n\n        adjustedMarginDelta = _param.marginDelta;\n\n        emit IMarketPosition.PositionDecreased(\n            _param.market,\n            _param.account,\n            adjustedMarginDelta,\n            marginAfterU96,\n            _param.sizeDelta,\n            _param.minIndexPrice,\n            realizedPnL,\n            tradingFee,\n            spread,\n            _param.receiver\n        );\n    }\n\n    function liquidatePosition(\n        IMarketManager.State storage _state,\n        IConfigurable.MarketConfig storage _cfg,\n        LiquidatePositionParam memory _param\n    ) public returns (uint64 liquidationExecutionFee) {\n        IMarketManager.Position memory positionCache = _state.longPositions[_param.account];\n        if (positionCache.size == 0) revert IMarketErrors.PositionNotFound(_param.account);\n\n        _validatePositionLiquidateMaintainMarginRate(\n            _cfg,\n            MaintainMarginRateParam({\n                margin: int256(uint256(positionCache.margin)),\n                size: positionCache.size,\n                entryPrice: positionCache.entryPrice,\n                decreaseIndexPrice: _param.minIndexPrice,\n                liquidatablePosition: true\n            })\n        );\n\n        liquidationExecutionFee = liquidatePosition(_state, _cfg, positionCache, _param);\n    }\n\n    function liquidatePosition(\n        IMarketManager.State storage _state,\n        IConfigurable.MarketConfig storage _cfg,\n        IMarketManager.Position memory _positionCache,\n        LiquidatePositionParam memory _param\n    ) internal returns (uint64 liquidationExecutionFee) {\n        liquidationExecutionFee = _cfg.liquidationExecutionFee;\n        uint24 liquidationFeeRate = _cfg.liquidationFeeRatePerPosition;\n\n        uint64 liquidationPrice = calcLiquidationPrice(\n            _positionCache,\n            liquidationFeeRate,\n            _cfg.tradingFeeRate,\n            liquidationExecutionFee\n        );\n\n        IMarketManager.PackedState storage packedState = _state.packedState;\n        uint128 lpNetSize = packedState.lpNetSize;\n        if (lpNetSize < _positionCache.size)\n            PUSDManagerUtil.liquidityBufferModuleBurn(\n                _state,\n                _cfg,\n                PUSDManagerUtil.LiquidityBufferModuleBurnParam({\n                    market: _param.market,\n                    account: _param.account,\n                    sizeDelta: uint96(_positionCache.size.subU128(lpNetSize)),\n                    indexPrice: liquidationPrice\n                })\n            );\n\n        // settle liquidity\n        LiquidityUtil.settlePosition(_state, _param.market, SHORT, liquidationPrice, _positionCache.size);\n        // revise liquidity PnL\n        (, int184 scaledUSDPnL) = calcUnrealizedPnL2(\n            LONG,\n            _positionCache.size,\n            _positionCache.entryPrice,\n            liquidationPrice\n        );\n        LiquidityUtil.reviseLiquidityPnL(_state, _param.market, liquidationPrice, scaledUSDPnL);\n\n        uint96 liquidationFee = calcLiquidationFee(\n            _positionCache.size,\n            _positionCache.entryPrice,\n            liquidationPrice,\n            liquidationFeeRate\n        );\n        distributeLiquidationFee(_state, _param.market, liquidationFee);\n\n        uint96 tradingFee = distributeTradingFee(\n            _state,\n            DistributeFeeParam({\n                market: _param.market,\n                size: _positionCache.size,\n                entryPrice: _positionCache.entryPrice,\n                indexPrice: liquidationPrice,\n                rounding: Math.Rounding.Down,\n                tradingFeeRate: _cfg.tradingFeeRate,\n                protocolFeeRate: _cfg.protocolFeeRate\n            })\n        );\n\n        packedState.longSize = packedState.longSize.subU128(_positionCache.size);\n\n        delete _state.longPositions[_param.account];\n\n        emit IMarketPosition.PositionLiquidated(\n            _param.market,\n            msg.sender,\n            _param.account,\n            _positionCache.size,\n            _param.minIndexPrice,\n            liquidationPrice,\n            tradingFee,\n            liquidationFee,\n            liquidationExecutionFee,\n            _param.feeReceiver\n        );\n    }\n\n    /// @notice Calculate the liquidation fee of a position\n    /// @param _size The size of the position\n    /// @param _entryPrice The entry price of the position\n    /// @param _indexPrice The index price\n    /// @param _liquidationFeeRate The liquidation fee rate for trader positions,\n    /// denominated in thousandths of a bip (i.e. 1e-7)\n    /// @return liquidationFee The liquidation fee of the position\n    function calcLiquidationFee(\n        uint96 _size,\n        uint64 _entryPrice,\n        uint64 _indexPrice,\n        uint24 _liquidationFeeRate\n    ) internal pure returns (uint96 liquidationFee) {\n        // liquidationFee = size * entryPrice * liquidationFeeRate / indexPrice\n        unchecked {\n            uint256 denominator = uint256(_indexPrice) * Constants.BASIS_POINTS_DIVISOR;\n            liquidationFee = ((uint256(_size) * _liquidationFeeRate * _entryPrice) / denominator).toUint96();\n        }\n    }\n\n    /// @notice Calculate the maintenance margin\n    /// @dev maintenanceMargin = size * entryPrice * liquidationFeeRate / indexPrice\n    ///                          + size * entryPrice * tradingFeeRate / indexPrice\n    ///                          + liquidationExecutionFee\n    ///                        = size * entryPrice * (liquidationFeeRate + tradingFeeRate) / indexPrice\n    ///                          + liquidationExecutionFee\n    /// @param _size The size of the position\n    /// @param _entryPrice The entry price of the position\n    /// @param _indexPrice The index price\n    /// @param _liquidationFeeRate The liquidation fee rate for trader positions,\n    /// denominated in thousandths of a bip (i.e. 1e-7)\n    /// @param _tradingFeeRate The trading fee rate for trader increase or decrease positions,\n    /// denominated in thousandths of a bip (i.e. 1e-7)\n    /// @param _liquidationExecutionFee The liquidation execution fee paid by the position\n    /// @return maintenanceMargin The maintenance margin\n    function calcMaintenanceMargin(\n        uint96 _size,\n        uint64 _entryPrice,\n        uint64 _indexPrice,\n        uint24 _liquidationFeeRate,\n        uint24 _tradingFeeRate,\n        uint64 _liquidationExecutionFee\n    ) internal pure returns (uint256 maintenanceMargin) {\n        unchecked {\n            uint256 numerator = uint256(_size) * _entryPrice * (uint64(_liquidationFeeRate) + _tradingFeeRate);\n            maintenanceMargin = Math.ceilDiv(numerator, uint256(_indexPrice) * Constants.BASIS_POINTS_DIVISOR);\n            maintenanceMargin += _liquidationExecutionFee;\n        }\n    }\n\n    function refreshSpreadFactor(\n        IMarketManager.PackedState storage _packedState,\n        IConfigurable.MarketConfig storage _cfg,\n        IERC20 _market,\n        uint96 _sizeDelta,\n        Side _side\n    ) internal returns (uint96 spread) {\n        int256 spreadFactorAfterX96;\n        (spread, spreadFactorAfterX96) = SpreadUtil.calcSpread(\n            _cfg,\n            SpreadUtil.CalcSpreadParam({\n                side: _side,\n                sizeDelta: _sizeDelta,\n                spreadFactorBeforeX96: _packedState.spreadFactorX96,\n                lastTradingTimestamp: _packedState.lastTradingTimestamp\n            })\n        );\n        _packedState.spreadFactorX96 = spreadFactorAfterX96;\n        _packedState.lastTradingTimestamp = uint64(block.timestamp); // overflow is desired\n\n        emit IMarketManager.SpreadFactorChanged(_market, spreadFactorAfterX96);\n    }\n\n    function distributeTradingFee(\n        IMarketManager.State storage _state,\n        DistributeFeeParam memory _param\n    ) internal returns (uint96 tradingFee) {\n        tradingFee = calcTradingFee(_param);\n\n        uint96 liquidityFee;\n        unchecked {\n            uint96 protocolFee = uint96(\n                (uint256(tradingFee) * _param.protocolFeeRate) / Constants.BASIS_POINTS_DIVISOR\n            );\n            _state.protocolFee += protocolFee; // overflow is desired\n            emit IMarketManager.ProtocolFeeIncreased(_param.market, protocolFee);\n\n            liquidityFee = tradingFee - protocolFee;\n        }\n\n        _state.packedState.lpLiquidity += liquidityFee;\n        emit IMarketLiquidity.GlobalLiquidityIncreasedByTradingFee(_param.market, liquidityFee);\n    }\n\n    function calcTradingFee(DistributeFeeParam memory _param) internal pure returns (uint96 tradingFee) {\n        unchecked {\n            uint256 denominator = uint256(_param.indexPrice) * Constants.BASIS_POINTS_DIVISOR;\n            uint256 numerator = uint256(_param.size) * _param.tradingFeeRate * _param.entryPrice;\n            tradingFee = _param.rounding == Math.Rounding.Up\n                ? Math.ceilDiv(numerator, denominator).toUint96()\n                : (numerator / denominator).toUint96();\n        }\n    }\n\n    function distributeSpread(IMarketManager.State storage _state, IERC20 _market, uint96 _spread) internal {\n        if (_spread > 0) {\n            unchecked {\n                _state.globalStabilityFund += _spread; // overflow is desired\n                emit IMarketManager.GlobalStabilityFundIncreasedBySpread(_market, _spread);\n            }\n        }\n    }\n\n    function distributeLiquidationFee(\n        IMarketManager.State storage _state,\n        IERC20 _market,\n        uint96 _liquidationFee\n    ) internal {\n        unchecked {\n            _state.globalStabilityFund += _liquidationFee; // overflow is desired\n            emit IMarketManager.GlobalStabilityFundIncreasedByLiquidation(_market, _liquidationFee);\n        }\n    }\n\n    /// @notice Calculate the next entry price of a position\n    /// @param _side The side of the position (Long or Short)\n    /// @param _sizeBefore The size of the position before the trade\n    /// @param _entryPriceBefore The entry price of the position before the trade\n    /// @param _sizeDelta The size of the trade\n    /// @param _indexPrice The index price at which the position is changed\n    /// @return nextEntryPrice The entry price of the position after the trade\n    function calcNextEntryPrice(\n        Side _side,\n        uint128 _sizeBefore,\n        uint64 _entryPriceBefore,\n        uint128 _sizeDelta,\n        uint64 _indexPrice\n    ) internal pure returns (uint64 nextEntryPrice) {\n        if (_sizeBefore == 0) nextEntryPrice = _indexPrice;\n        else if (_sizeDelta == 0) nextEntryPrice = _entryPriceBefore;\n        else {\n            unchecked {\n                uint256 liquidityAfter = uint256(_sizeBefore) * _entryPriceBefore;\n                liquidityAfter += uint256(_sizeDelta) * _indexPrice;\n                uint256 sizeAfter = uint256(_sizeBefore) + _sizeDelta;\n                nextEntryPrice = uint64(\n                    _side.isLong() ? Math.ceilDiv(liquidityAfter, sizeAfter) : liquidityAfter / sizeAfter\n                );\n            }\n        }\n    }\n\n    /// @notice Calculate the quantity of tokens with 6 decimal precision that can be exchanged\n    /// at the index price using the market token amount\n    /// @param _marketTokenAmount The amount of market tokens\n    /// @param _indexPrice The index price\n    /// @param _marketDecimals The decimal places of the market token\n    /// @param _rounding The rounding mode\n    /// @return value The quantity of tokens represented with 6 decimal precision\n    function calcDecimals6TokenValue(\n        uint96 _marketTokenAmount,\n        uint64 _indexPrice,\n        uint8 _marketDecimals,\n        Math.Rounding _rounding\n    ) internal pure returns (uint64 value) {\n        unchecked {\n            uint256 denominator = 10 ** (Constants.PRICE_DECIMALS - Constants.DECIMALS_6 + _marketDecimals);\n            value = _rounding == Math.Rounding.Up\n                ? Math.ceilDiv(uint256(_marketTokenAmount) * _indexPrice, denominator).toUint64()\n                : ((uint256(_marketTokenAmount) * _indexPrice) / denominator).toUint64();\n        }\n    }\n\n    /// @notice Calculate the quantity of market tokens that can be exchanged at the index price\n    /// using the tokens with 6 decimal precision\n    /// @param _decimals6TokenAmount The amount of tokens represented with 6 decimal precision\n    /// @param _indexPrice The index price\n    /// @param _marketDecimals The decimal places of the market token\n    /// @return value The quantity of market tokens\n    function calcMarketTokenValue(\n        uint96 _decimals6TokenAmount,\n        uint64 _indexPrice,\n        uint8 _marketDecimals\n    ) internal pure returns (uint96 value) {\n        unchecked {\n            uint256 numerator = uint256(_decimals6TokenAmount) *\n                10 ** (Constants.PRICE_DECIMALS - Constants.DECIMALS_6 + _marketDecimals);\n            value = (numerator / _indexPrice).toUint96();\n        }\n    }\n\n    /// @notice Calculate the unrealized PnL of a position based on entry price\n    /// @param _side The side of the position (Long or Short)\n    /// @param _size The size of the position\n    /// @param _entryPrice The entry price of the position\n    /// @param _price The trade price or index price, caller should ensure that the price is not zero\n    /// @return unrealizedPnL The unrealized PnL of the position, positive value means profit,\n    /// negative value means loss\n    function calcUnrealizedPnL(\n        Side _side,\n        uint128 _size,\n        uint64 _entryPrice,\n        uint64 _price\n    ) internal pure returns (int256 unrealizedPnL) {\n        unchecked {\n            if (_side.isLong()) {\n                if (_entryPrice > _price)\n                    unrealizedPnL = -int256(Math.ceilDiv(uint256(_size) * (_entryPrice - _price), _price));\n                else unrealizedPnL = int256((uint256(_size) * (_price - _entryPrice)) / _price);\n            } else {\n                if (_entryPrice < _price)\n                    unrealizedPnL = -int256(Math.ceilDiv(uint256(_size) * (_price - _entryPrice), _price));\n                else unrealizedPnL = int256((uint256(_size) * (_entryPrice - _price)) / _price);\n            }\n        }\n    }\n\n    /// @notice Calculate the unrealized PnL of a position based on entry price\n    /// @param _side The side of the position (long or short)\n    /// @param _size The size of the position\n    /// @param _entryPrice The entry price of the position\n    /// @param _price The current price of the position\n    /// @return tokenPnL The unrealized PnL in token\n    /// @return scaledUSDPnL The unrealized PnL in USD. For saving gas, this value is scaled up\n    /// by 10^(market decimals + price decimals - usd decimals)\n    function calcUnrealizedPnL2(\n        Side _side,\n        uint96 _size,\n        uint64 _entryPrice,\n        uint64 _price\n    ) internal pure returns (int184 tokenPnL, int184 scaledUSDPnL) {\n        unchecked {\n            if (_side.isLong()) {\n                if (_entryPrice > _price) {\n                    scaledUSDPnL = -int184(uint184(_size) * (_entryPrice - _price));\n                    tokenPnL = -int184(uint184(Math.ceilDiv(uint184(-scaledUSDPnL), _price)));\n                } else {\n                    scaledUSDPnL = int184(uint184(_size) * (_price - _entryPrice));\n                    tokenPnL = scaledUSDPnL / int184(uint184(_price));\n                }\n            } else {\n                if (_entryPrice < _price) {\n                    scaledUSDPnL = -int184(uint184(_size) * (_price - _entryPrice));\n                    tokenPnL = -int184(uint184(Math.ceilDiv(uint184(-scaledUSDPnL), _price)));\n                } else {\n                    scaledUSDPnL = int184(uint184(_size) * (_entryPrice - _price));\n                    tokenPnL = scaledUSDPnL / int184(uint184(_price));\n                }\n            }\n        }\n    }\n\n    /// @notice Calculate the liquidation price\n    /// @dev Given the liquidation condition as:\n    /// For long position: margin - size * (entryPrice - liquidationPrice) / liquidationPrice\n    ///                     = entryPrice * size * liquidationFeeRate / liquidationPrice\n    ///                         + entryPrice * size * tradingFeeRate / liquidationPrice + liquidationExecutionFee\n    /// We can get:\n    /// Long position liquidation price:\n    ///     liquidationPrice\n    ///       = size * entryPrice * (liquidationFeeRate + tradingFeeRate + 1)\n    ///       / [margin + size - liquidationExecutionFee]\n    /// @param _position The cache of position\n    /// @param _liquidationFeeRate The liquidation fee rate for trader positions,\n    /// denominated in thousandths of a bip (i.e. 1e-7)\n    /// @param _tradingFeeRate The trading fee rate for trader increase or decrease positions,\n    /// denominated in thousandths of a bip (i.e. 1e-7)\n    /// @param _liquidationExecutionFee The liquidation execution fee paid by the position\n    /// @return liquidationPrice The liquidation price of the position\n    function calcLiquidationPrice(\n        IMarketManager.Position memory _position,\n        uint24 _liquidationFeeRate,\n        uint24 _tradingFeeRate,\n        uint64 _liquidationExecutionFee\n    ) internal pure returns (uint64 liquidationPrice) {\n        unchecked {\n            int256 denominator = int256(uint256(_position.margin) + _position.size) -\n                int256(uint256(_liquidationExecutionFee));\n            assert(denominator > 0);\n            denominator *= int256(uint256(Constants.BASIS_POINTS_DIVISOR));\n\n            uint256 numerator = uint256(_position.size) * _position.entryPrice;\n            numerator *= uint64(_liquidationFeeRate) + _tradingFeeRate + Constants.BASIS_POINTS_DIVISOR;\n            liquidationPrice = (numerator / uint256(denominator)).toUint64();\n        }\n    }\n\n    function calcTradingFeeRate(\n        IConfigurable.MarketConfig storage _cfg,\n        uint128 _lpLiquidity,\n        uint128 _lpNetSizeAfter\n    ) internal view returns (uint24 tradingFeeRate) {\n        unchecked {\n            uint256 floatingTradingFeeSize = (uint256(_lpLiquidity) * _cfg.openPositionThreshold) /\n                Constants.BASIS_POINTS_DIVISOR;\n            if (_lpNetSizeAfter > floatingTradingFeeSize) {\n                uint256 floatingTradingFeeRate = (_cfg.maxFeeRate * (_lpNetSizeAfter - floatingTradingFeeSize)) /\n                    (_lpLiquidity - floatingTradingFeeSize);\n                return uint24(floatingTradingFeeRate) + _cfg.tradingFeeRate;\n            } else {\n                return _cfg.tradingFeeRate;\n            }\n        }\n    }\n\n    /// @notice Validate the increase position size\n    /// @param _sizeBefore The size of the position before the trade\n    /// @param _sizeDelta The size of the trade\n    /// @return sizeAfter The size of the position after the trade\n    /// @return lpNetSizeAfter The net size of the LP after the trade\n    function validateIncreaseSize(\n        IConfigurable.MarketConfig storage _cfg,\n        IMarketManager.PackedState storage _packedState,\n        uint96 _sizeBefore,\n        uint96 _sizeDelta\n    ) internal view returns (uint96 sizeAfter, uint128 lpNetSizeAfter) {\n        unchecked {\n            (uint128 lpNetSize, uint128 lpLiquidity) = (_packedState.lpNetSize, _packedState.lpLiquidity);\n            uint256 lpNetSizeAfter_ = uint256(lpNetSize) + _sizeDelta;\n            if (lpNetSizeAfter_ > lpLiquidity) revert IMarketErrors.SizeExceedsMaxSize(lpNetSizeAfter_, lpLiquidity);\n\n            lpNetSizeAfter = uint128(lpNetSizeAfter_);\n\n            sizeAfter = (uint256(_sizeBefore) + _sizeDelta).toUint96();\n            uint256 maxSizePerPosition = (uint256(_cfg.liquidityCap) * _cfg.maxSizeRatePerPosition) /\n                Constants.BASIS_POINTS_DIVISOR;\n            if (sizeAfter > maxSizePerPosition)\n                revert IMarketErrors.SizeExceedsMaxSizePerPosition(sizeAfter, maxSizePerPosition);\n        }\n    }\n\n    /// @notice Validate the position has not reached the liquidation margin rate\n    function _validatePositionLiquidateMaintainMarginRate(\n        IConfigurable.MarketConfig storage _cfg,\n        MaintainMarginRateParam memory _param\n    ) private view {\n        uint256 maintenanceMargin = calcMaintenanceMargin(\n            _param.size,\n            _param.entryPrice,\n            _param.decreaseIndexPrice,\n            _cfg.liquidationFeeRatePerPosition,\n            _cfg.tradingFeeRate,\n            _cfg.liquidationExecutionFee\n        );\n        int256 unrealizedPnL = calcUnrealizedPnL(LONG, _param.size, _param.entryPrice, _param.decreaseIndexPrice);\n        unchecked {\n            if (unrealizedPnL < 0) maintenanceMargin += uint256(-unrealizedPnL);\n        }\n\n        if (!_param.liquidatablePosition) {\n            if (_param.margin <= 0 || maintenanceMargin >= uint256(_param.margin))\n                revert IMarketErrors.MarginRateTooHigh(_param.margin, maintenanceMargin);\n        } else {\n            if (_param.margin > 0 && maintenanceMargin < uint256(_param.margin))\n                revert IMarketErrors.MarginRateTooLow(_param.margin, maintenanceMargin);\n        }\n    }\n}\n"}, "contracts/libraries/PriceFeedUtil.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport \"./Constants.sol\";\nimport \"./UnsafeMath.sol\";\nimport \"../oracle/interfaces/IPriceFeed.sol\";\nimport \"../oracle/interfaces/IChainLinkAggregator.sol\";\nimport \"solady/src/utils/FixedPointMathLib.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nlibrary PriceFeedUtil {\n    using SafeCast for *;\n    using UnsafeMath for *;\n    using FixedPointMathLib for *;\n\n    /// @dev value difference precision\n    uint256 public constant DELTA_PRECISION = 1000 * 1000;\n\n    function getReferencePrice(\n        IPriceFeed.PriceFeedConfig memory _cfg,\n        uint8 _priceDecimals\n    ) internal view returns (uint64 latestRefPrice) {\n        (, int256 refPrice, , uint256 timestamp, ) = _cfg.refPriceFeed.latestRoundData();\n        if (refPrice <= 0) revert IPriceFeed.InvalidReferencePrice(refPrice);\n\n        if (_cfg.refHeartbeatDuration != 0) {\n            uint256 timeDiff = block.timestamp.dist(timestamp);\n            if (timeDiff > _cfg.refHeartbeatDuration) revert IPriceFeed.ReferencePriceTimeout(timeDiff);\n        }\n\n        latestRefPrice = (\n            _cfg.refPriceDecimals >= _priceDecimals\n                ? uint256(refPrice).divU256(10 ** _cfg.refPriceDecimals.dist(_priceDecimals))\n                : uint256(refPrice) * (10 ** _cfg.refPriceDecimals.dist(_priceDecimals))\n        ).toUint64();\n    }\n\n    function calcMinAndMaxPrice(\n        uint64 _price,\n        uint64 _refPrice,\n        uint24 _maxDeviationRatio,\n        bool _reachMaxDeltaDiff\n    ) internal pure returns (uint64 minPrice, uint64 maxPrice) {\n        (minPrice, maxPrice) = (_price, _price);\n        if (_reachMaxDeltaDiff || calcDiffBasisPoints(_price, _refPrice) > _maxDeviationRatio) {\n            if (_price > _refPrice) minPrice = _refPrice;\n            else maxPrice = _refPrice;\n        }\n    }\n\n    function calcDiffBasisPoints(uint64 _price, uint64 _basisPrice) internal pure returns (uint64) {\n        // prettier-ignore\n        unchecked { return uint64((_price.dist(_basisPrice) * DELTA_PRECISION) / _basisPrice); }\n    }\n\n    function calcNewPriceDataItem(\n        IPriceFeed.PriceDataItem memory _item,\n        uint64 _price,\n        uint64 _refPrice,\n        uint48 _maxCumulativeDeltaDiffs,\n        uint32 _cumulativeRoundDuration\n    ) internal view returns (bool reachMaxDeltaDiff) {\n        uint32 currentRound;\n        // prettier-ignore\n        unchecked { currentRound = uint32(block.timestamp / _cumulativeRoundDuration); }\n        if (currentRound != _item.prevRound) {\n            _item.cumulativePriceDelta = 0;\n            _item.cumulativeRefPriceDelta = 0;\n            _item.prevRefPrice = _refPrice;\n            _item.prevPrice = _price;\n            _item.prevRound = currentRound;\n            return false;\n        }\n        uint64 cumulativeRefPriceDelta = calcDiffBasisPoints(_refPrice, _item.prevRefPrice);\n        uint64 cumulativePriceDelta = calcDiffBasisPoints(_price, _item.prevPrice);\n\n        _item.cumulativeRefPriceDelta = _item.cumulativeRefPriceDelta + cumulativeRefPriceDelta;\n        _item.cumulativePriceDelta = _item.cumulativePriceDelta + cumulativePriceDelta;\n        unchecked {\n            if (\n                _item.cumulativePriceDelta > _item.cumulativeRefPriceDelta &&\n                _item.cumulativePriceDelta - _item.cumulativeRefPriceDelta > _maxCumulativeDeltaDiffs\n            ) reachMaxDeltaDiff = true;\n\n            _item.prevRefPrice = _refPrice;\n            _item.prevPrice = _price;\n            _item.prevRound = currentRound;\n            return reachMaxDeltaDiff;\n        }\n    }\n}\n"}, "contracts/libraries/PUSDManagerUtil.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport \"./SpreadUtil.sol\";\nimport \"./PositionUtil.sol\";\nimport \"./LiquidityUtil.sol\";\nimport \"./UnsafeMath.sol\";\nimport \"./SpreadUtil.sol\";\nimport \"../core/PUSD.sol\";\nimport \"../core/interfaces/IMarketManager.sol\";\nimport {LONG, SHORT} from \"../types/Side.sol\";\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nlibrary PUSDManagerUtil {\n    using SafeCast for *;\n    using SafeERC20 for IERC20;\n    using UnsafeMath for *;\n\n    bytes32 internal constant PUSD_SALT = keccak256(\"Pure USD\");\n    bytes32 internal constant PUSD_INIT_CODE_HASH = 0x833a3129a7c49096ba2bc346ab64e2bbec674f4181bf8e6dedfa83aea7fb0fec;\n\n    struct MintParam {\n        IERC20 market;\n        bool exactIn;\n        uint96 amount;\n        IPUSDManagerCallback callback;\n        uint64 indexPrice;\n        address receiver;\n    }\n\n    struct BurnParam {\n        IERC20 market;\n        bool exactIn;\n        uint96 amount;\n        IPUSDManagerCallback callback;\n        uint64 indexPrice;\n        address receiver;\n    }\n\n    struct LiquidityBufferModuleBurnParam {\n        IERC20 market;\n        address account;\n        uint96 sizeDelta;\n        uint64 indexPrice;\n    }\n\n    struct CalcBurnPUSDInputAmountParam {\n        uint256 spreadX96;\n        uint64 entryPrice;\n        uint64 indexPrice;\n        uint24 tradingFeeRate;\n        uint96 outputAmount;\n    }\n\n    function deployPUSD() public returns (PUSD pusd) {\n        pusd = new PUSD{salt: PUSD_SALT}();\n    }\n\n    function computePUSDAddress() internal view returns (address) {\n        return computePUSDAddress(address(this));\n    }\n\n    function computePUSDAddress(address _deployer) internal pure returns (address) {\n        return Create2.computeAddress(PUSD_SALT, PUSD_INIT_CODE_HASH, _deployer);\n    }\n\n    function mint(\n        IMarketManager.State storage _state,\n        IConfigurable.MarketConfig storage _cfg,\n        MintParam memory _param,\n        bytes calldata _data\n    ) internal returns (uint96 payAmount, uint64 receiveAmount) {\n        IMarketManager.PackedState storage packedState = _state.packedState;\n        (int256 spreadFactorAfterX96, uint256 spreadX96) = SpreadUtil.refreshSpread(\n            _cfg,\n            SpreadUtil.CalcSpreadParam({\n                side: SHORT,\n                sizeDelta: 0,\n                spreadFactorBeforeX96: packedState.spreadFactorX96,\n                lastTradingTimestamp: packedState.lastTradingTimestamp\n            })\n        );\n        uint96 sizeDelta;\n        if (_param.exactIn) {\n            // size = amount / (1 + spread + tradingFeeRate)\n            unchecked {\n                uint256 numeratorX96 = (uint256(_param.amount) << 96) * Constants.BASIS_POINTS_DIVISOR;\n                uint256 denominatorX96 = (uint256(Constants.BASIS_POINTS_DIVISOR) + _cfg.tradingFeeRate) << 96;\n                denominatorX96 += spreadX96 * Constants.BASIS_POINTS_DIVISOR;\n                sizeDelta = (numeratorX96 / denominatorX96).toUint96();\n            }\n            payAmount = _param.amount;\n            receiveAmount = PositionUtil.calcDecimals6TokenValue(\n                sizeDelta,\n                _param.indexPrice,\n                _cfg.decimals,\n                Math.Rounding.Down\n            );\n        } else {\n            receiveAmount = _param.amount.toUint64();\n            sizeDelta = PositionUtil.calcMarketTokenValue(_param.amount, _param.indexPrice, _cfg.decimals);\n        }\n        if (sizeDelta == 0) revert IMarketErrors.InvalidSize();\n\n        IPUSDManager.GlobalPUSDPosition storage position = _state.globalPUSDPosition;\n        uint64 totalSupplyAfter = _validateStableCoinSupplyCap(\n            _cfg.stableCoinSupplyCap,\n            position.totalSupply,\n            receiveAmount\n        );\n\n        (uint128 lpNetSize, uint128 lpLiquidity) = (packedState.lpNetSize, packedState.lpLiquidity);\n        if (sizeDelta > lpNetSize) revert IMarketErrors.InsufficientSizeToDecrease(sizeDelta, lpNetSize);\n\n        uint128 sizeBefore = position.size;\n        uint128 sizeAfter;\n        unchecked {\n            // Because the short position is always less than or equal to the long position,\n            // there will be no overflow here.\n            sizeAfter = sizeBefore + sizeDelta;\n            uint256 maxShortSize = (uint256(_cfg.maxShortSizeRate) * lpLiquidity) / Constants.BASIS_POINTS_DIVISOR;\n            if (sizeAfter > maxShortSize) revert IMarketErrors.MaxShortSizeExceeded(sizeAfter, maxShortSize);\n\n            uint256 minMintingSizeCap = (uint256(_cfg.minMintingRate) * lpLiquidity) / Constants.BASIS_POINTS_DIVISOR;\n            if (lpNetSize - sizeDelta < minMintingSizeCap)\n                revert IMarketErrors.MinMintingSizeCapNotMet(lpNetSize, sizeDelta, uint128(minMintingSizeCap));\n        }\n\n        // settle liquidity\n        LiquidityUtil.settlePosition(_state, _param.market, SHORT, _param.indexPrice, sizeDelta);\n\n        uint96 tradingFee = PositionUtil.distributeTradingFee(\n            _state,\n            PositionUtil.DistributeFeeParam({\n                market: _param.market,\n                size: sizeDelta,\n                entryPrice: _param.indexPrice,\n                indexPrice: _param.indexPrice,\n                rounding: Math.Rounding.Down,\n                tradingFeeRate: _cfg.tradingFeeRate,\n                protocolFeeRate: _cfg.protocolFeeRate\n            })\n        );\n\n        uint96 spread = _param.exactIn\n            ? _param.amount.subU96(sizeDelta).subU96(tradingFee)\n            : SpreadUtil.calcSpreadAmount(spreadX96, sizeDelta, Math.Rounding.Up);\n        PositionUtil.distributeSpread(_state, _param.market, spread);\n\n        if (!_param.exactIn) payAmount = sizeDelta + tradingFee + spread;\n\n        // mint PUSD\n        IPUSD(computePUSDAddress()).mint(_param.receiver, receiveAmount);\n        // execute callback\n        uint256 balanceBefore = _param.market.balanceOf(address(this));\n        _param.callback.PUSDManagerCallback(_param.market, payAmount, receiveAmount, _data);\n        uint96 actualPayAmount = (_param.market.balanceOf(address(this)) - balanceBefore).toUint96();\n        if (actualPayAmount < payAmount) revert IMarketErrors.TooLittlePayAmount(actualPayAmount, payAmount);\n        payAmount = actualPayAmount;\n        _state.tokenBalance += payAmount;\n\n        uint64 entryPriceAfter = PositionUtil.calcNextEntryPrice(\n            SHORT,\n            sizeBefore,\n            position.entryPrice,\n            sizeDelta,\n            _param.indexPrice\n        );\n\n        position.totalSupply = totalSupplyAfter;\n        position.size = sizeAfter;\n        position.entryPrice = entryPriceAfter;\n\n        spreadFactorAfterX96 = SpreadUtil.calcSpreadFactorAfterX96(spreadFactorAfterX96, SHORT, sizeDelta);\n        _refreshSpreadFactor(packedState, _param.market, spreadFactorAfterX96);\n\n        emit IPUSDManager.PUSDPositionIncreased(\n            _param.market,\n            _param.receiver,\n            sizeDelta,\n            _param.indexPrice,\n            entryPriceAfter,\n            payAmount,\n            receiveAmount,\n            tradingFee,\n            spread\n        );\n    }\n\n    function burn(\n        IMarketManager.State storage _state,\n        IConfigurable.MarketConfig storage _cfg,\n        BurnParam memory _param,\n        bytes calldata _data\n    ) public returns (uint64 payAmount, uint96 receiveAmount) {\n        IMarketManager.PackedState storage packedState = _state.packedState;\n        (int256 spreadFactorAfterX96, uint256 spreadX96) = SpreadUtil.refreshSpread(\n            _cfg,\n            SpreadUtil.CalcSpreadParam({\n                side: LONG,\n                sizeDelta: 0,\n                spreadFactorBeforeX96: packedState.spreadFactorX96,\n                lastTradingTimestamp: packedState.lastTradingTimestamp\n            })\n        );\n\n        IPUSDManager.GlobalPUSDPosition storage position = _state.globalPUSDPosition;\n        IPUSDManager.GlobalPUSDPosition memory positionCache = position;\n        uint96 sizeDelta;\n        if (_param.exactIn) {\n            if (_param.amount == 0 || _param.amount > positionCache.totalSupply)\n                revert IMarketErrors.InvalidAmount(positionCache.totalSupply, _param.amount);\n\n            unchecked {\n                sizeDelta = ((uint256(_param.amount) * positionCache.size) / positionCache.totalSupply).toUint96();\n            }\n            payAmount = uint64(_param.amount);\n        } else {\n            sizeDelta = calcBurnPUSDSizeDelta(\n                CalcBurnPUSDInputAmountParam({\n                    spreadX96: spreadX96,\n                    entryPrice: positionCache.entryPrice,\n                    indexPrice: _param.indexPrice,\n                    tradingFeeRate: _cfg.tradingFeeRate,\n                    outputAmount: _param.amount\n                })\n            );\n            if (sizeDelta > positionCache.size)\n                revert IMarketErrors.InsufficientSizeToDecrease(sizeDelta, positionCache.size);\n\n            receiveAmount = _param.amount;\n        }\n\n        validateDecreaseSize(packedState, _cfg.maxBurningRate, sizeDelta);\n\n        // settle liquidity\n        LiquidityUtil.settlePosition(_state, _param.market, LONG, _param.indexPrice, sizeDelta);\n\n        uint96 tradingFee = PositionUtil.distributeTradingFee(\n            _state,\n            PositionUtil.DistributeFeeParam({\n                market: _param.market,\n                size: sizeDelta,\n                entryPrice: positionCache.entryPrice,\n                indexPrice: _param.indexPrice,\n                rounding: Math.Rounding.Down,\n                tradingFeeRate: _cfg.tradingFeeRate,\n                protocolFeeRate: _cfg.protocolFeeRate\n            })\n        );\n\n        uint96 spread = SpreadUtil.calcSpreadAmount(spreadX96, sizeDelta, Math.Rounding.Down);\n        PositionUtil.distributeSpread(_state, _param.market, spread);\n\n        (int256 tokenPnL, int184 scaledUSDPnL) = PositionUtil.calcUnrealizedPnL2(\n            SHORT,\n            sizeDelta,\n            positionCache.entryPrice,\n            _param.indexPrice\n        );\n        LiquidityUtil.reviseLiquidityPnL(_state, _param.market, _param.indexPrice, scaledUSDPnL);\n\n        if (_param.exactIn) {\n            unchecked {\n                int256 receiveAmountInt = int256(uint256(sizeDelta)) + tokenPnL;\n                receiveAmountInt -= int256(uint256(tradingFee) + spread);\n                if (receiveAmountInt < 0) revert IMarketErrors.NegativeReceiveAmount(receiveAmountInt);\n                receiveAmount = uint256(receiveAmountInt).toUint96();\n            }\n        } else {\n            // the amount of PUSD to burn\n            payAmount = PositionUtil.calcDecimals6TokenValue(\n                sizeDelta,\n                _param.indexPrice,\n                _cfg.decimals,\n                Math.Rounding.Up\n            );\n            if (payAmount > positionCache.totalSupply)\n                revert IMarketErrors.InvalidAmount(positionCache.totalSupply, payAmount);\n        }\n\n        // First pay the market token\n        _state.tokenBalance -= receiveAmount;\n        _param.market.safeTransfer(_param.receiver, receiveAmount);\n\n        // Then execute the callback\n        IPUSD usd = IPUSD(computePUSDAddress());\n        uint256 balanceBefore = usd.balanceOf(address(this));\n        _param.callback.PUSDManagerCallback(usd, payAmount, receiveAmount, _data);\n        uint96 actualPayAmount = (usd.balanceOf(address(this)) - balanceBefore).toUint96();\n        if (actualPayAmount != payAmount) revert IMarketErrors.UnexpectedPayAmount(payAmount, actualPayAmount);\n        usd.burn(payAmount);\n\n        // never underflow because of the validation above\n        unchecked {\n            position.size = positionCache.size - sizeDelta;\n            position.totalSupply = positionCache.totalSupply - payAmount;\n        }\n\n        spreadFactorAfterX96 = SpreadUtil.calcSpreadFactorAfterX96(spreadFactorAfterX96, LONG, sizeDelta);\n        _refreshSpreadFactor(packedState, _param.market, spreadFactorAfterX96);\n\n        emit IPUSDManager.PUSDPositionDecreased(\n            _param.market,\n            _param.receiver,\n            sizeDelta,\n            _param.indexPrice,\n            payAmount,\n            receiveAmount,\n            tokenPnL,\n            tradingFee,\n            spread\n        );\n    }\n\n    function liquidityBufferModuleBurn(\n        IMarketManager.State storage _state,\n        IConfigurable.MarketConfig storage _cfg,\n        LiquidityBufferModuleBurnParam memory _param\n    ) internal {\n        // settle liquidity\n        LiquidityUtil.settlePosition(_state, _param.market, LONG, _param.indexPrice, _param.sizeDelta);\n\n        IPUSDManager.GlobalPUSDPosition storage position = _state.globalPUSDPosition;\n        IPUSDManager.GlobalPUSDPosition memory positionCache = position;\n        uint96 tradingFee = PositionUtil.distributeTradingFee(\n            _state,\n            PositionUtil.DistributeFeeParam({\n                market: _param.market,\n                size: _param.sizeDelta,\n                entryPrice: positionCache.entryPrice,\n                indexPrice: _param.indexPrice,\n                rounding: Math.Rounding.Down,\n                tradingFeeRate: _cfg.tradingFeeRate,\n                protocolFeeRate: _cfg.protocolFeeRate\n            })\n        );\n\n        (int256 realizedPnL, int184 scaledUSDPnL) = PositionUtil.calcUnrealizedPnL2(\n            SHORT,\n            _param.sizeDelta,\n            positionCache.entryPrice,\n            _param.indexPrice\n        );\n        LiquidityUtil.reviseLiquidityPnL(_state, _param.market, _param.indexPrice, scaledUSDPnL);\n\n        uint96 receiveAmount;\n        uint64 pusdDebtDelta;\n        unchecked {\n            int256 receiveAmountInt = int256(uint256(_param.sizeDelta)) - int256(uint256(tradingFee)) + realizedPnL;\n            if (receiveAmountInt < 0) revert IMarketErrors.NegativeReceiveAmount(receiveAmountInt);\n            receiveAmount = uint256(receiveAmountInt).toUint96();\n\n            pusdDebtDelta = uint64(\n                Math.ceilDiv(uint256(_param.sizeDelta) * positionCache.totalSupply, positionCache.size)\n            );\n\n            position.size = positionCache.size - _param.sizeDelta;\n            position.totalSupply = positionCache.totalSupply - pusdDebtDelta;\n        }\n\n        emit IPUSDManager.PUSDPositionDecreased(\n            _param.market,\n            address(this),\n            _param.sizeDelta,\n            _param.indexPrice,\n            pusdDebtDelta,\n            receiveAmount,\n            realizedPnL,\n            tradingFee,\n            0\n        );\n\n        IMarketManager.LiquidityBufferModule storage module = _state.liquidityBufferModule;\n        module.pusdDebt += pusdDebtDelta;\n        module.tokenPayback += receiveAmount;\n        emit IMarketManager.LiquidityBufferModuleDebtIncreased(\n            _param.market,\n            _param.account,\n            pusdDebtDelta,\n            receiveAmount\n        );\n    }\n\n    function repayLiquidityBufferDebt(\n        IMarketManager.State storage _state,\n        IERC20 _market,\n        address _account,\n        address _receiver\n    ) public returns (uint128 receiveAmount) {\n        IMarketManager.LiquidityBufferModule storage module = _state.liquidityBufferModule;\n        IMarketManager.LiquidityBufferModule memory moduleCache = module;\n\n        IPUSD usd = IPUSD(computePUSDAddress());\n        uint128 amount = usd.balanceOf(address(this)).toUint128();\n\n        // if paid too much, only repay the debt.\n        if (amount > moduleCache.pusdDebt) amount = moduleCache.pusdDebt;\n\n        // avoid reentrancy attack\n        // prettier-ignore\n        unchecked { module.pusdDebt = moduleCache.pusdDebt - amount; }\n\n        usd.burn(amount);\n\n        unchecked {\n            receiveAmount = uint128((uint256(moduleCache.tokenPayback) * amount) / moduleCache.pusdDebt);\n            module.tokenPayback = moduleCache.tokenPayback - receiveAmount;\n        }\n\n        _state.tokenBalance -= receiveAmount;\n        _market.safeTransfer(_receiver, receiveAmount);\n        emit IMarketManager.LiquidityBufferModuleDebtRepaid(_market, _account, amount, receiveAmount);\n    }\n\n    function updatePSMCollateralCap(IPSM.CollateralState storage _state, IERC20 _collateral, uint120 _cap) public {\n        address usd = computePUSDAddress();\n        require(usd != address(0) && usd != address(_collateral), IPSM.InvalidCollateral());\n\n        if (_state.decimals == 0) {\n            uint8 decimals = IERC20Metadata(address(_collateral)).decimals();\n            require(decimals <= 18, IPSM.InvalidCollateralDecimals(decimals));\n            _state.decimals = decimals;\n        }\n        _state.cap = _cap;\n        emit IPSM.PSMCollateralUpdated(_collateral, _cap);\n    }\n\n    function psmMint(\n        IPSM.CollateralState storage _state,\n        IERC20 _collateral,\n        address _receiver\n    ) public returns (uint64 receiveAmount) {\n        uint128 balanceAfter = _collateral.balanceOf(address(this)).toUint128();\n        if (balanceAfter > _state.cap) balanceAfter = _state.cap;\n\n        uint96 payAmount = (balanceAfter - _state.balance).toUint96();\n        _state.balance = balanceAfter;\n\n        receiveAmount = PositionUtil.calcDecimals6TokenValue(\n            payAmount,\n            Constants.PRICE_1,\n            _state.decimals,\n            Math.Rounding.Down\n        );\n        IPUSD(computePUSDAddress()).mint(_receiver, receiveAmount);\n\n        emit IPSM.PSMMinted(_collateral, _receiver, payAmount, receiveAmount);\n    }\n\n    function psmBurn(\n        IPSM.CollateralState storage _state,\n        IERC20 _collateral,\n        address _receiver\n    ) public returns (uint96 receiveAmount) {\n        IPUSD usd = IPUSD(computePUSDAddress());\n        uint64 payAmount = usd.balanceOf(address(this)).toUint64();\n        usd.burn(payAmount);\n\n        receiveAmount = PositionUtil.calcMarketTokenValue(payAmount, Constants.PRICE_1, _state.decimals);\n\n        if (_state.balance < receiveAmount) revert IPSM.InsufficientPSMBalance(receiveAmount, _state.balance);\n        // prettier-ignore\n        unchecked { _state.balance -= receiveAmount; }\n\n        _collateral.safeTransfer(_receiver, receiveAmount);\n\n        emit IPSM.PSMBurned(_collateral, _receiver, payAmount, receiveAmount);\n    }\n\n    /// @notice Calculate the size delta of burning PUSD when output amount is specified\n    function calcBurnPUSDSizeDelta(\n        CalcBurnPUSDInputAmountParam memory _param\n    ) internal pure returns (uint96 sizeDelta) {\n        uint256 minuendX96;\n        unchecked {\n            uint256 numeratorX96 = uint256(Constants.BASIS_POINTS_DIVISOR - _param.tradingFeeRate) << 96;\n            numeratorX96 *= _param.entryPrice;\n            minuendX96 = numeratorX96 / (uint256(_param.indexPrice) * Constants.BASIS_POINTS_DIVISOR);\n        }\n\n        uint256 denominatorX96 = minuendX96 - _param.spreadX96;\n        sizeDelta = Math.ceilDiv(uint256(_param.outputAmount) << 96, denominatorX96).toUint96();\n    }\n\n    function validateDecreaseSize(\n        IMarketManager.PackedState storage _packedState,\n        uint24 _maxBurningRate,\n        uint128 _sizeDelta\n    ) internal view {\n        unchecked {\n            (uint128 lpNetSize, uint128 lpLiquidity) = (_packedState.lpNetSize, _packedState.lpLiquidity);\n            require(_sizeDelta > 0, IMarketErrors.InvalidSize());\n            uint256 netSizeAfter = uint256(lpNetSize) + _sizeDelta;\n            uint256 maxBurningSizeCap = (uint256(lpLiquidity) * _maxBurningRate) / Constants.BASIS_POINTS_DIVISOR;\n            require(\n                netSizeAfter <= maxBurningSizeCap,\n                IMarketErrors.MaxBurningSizeCapExceeded(lpNetSize, _sizeDelta, maxBurningSizeCap)\n            );\n        }\n    }\n\n    function _refreshSpreadFactor(\n        IMarketManager.PackedState storage _state,\n        IERC20 _market,\n        int256 _spreadFactorAfterX96\n    ) private {\n        _state.spreadFactorX96 = _spreadFactorAfterX96;\n        _state.lastTradingTimestamp = uint64(block.timestamp); // overflow is desired\n        emit IMarketManager.SpreadFactorChanged(_market, _spreadFactorAfterX96);\n    }\n\n    function _validateStableCoinSupplyCap(\n        uint64 _stableCoinSupplyCap,\n        uint64 _totalSupply,\n        uint64 _amountDelta\n    ) private pure returns (uint64 totalSupplyAfter) {\n        unchecked {\n            uint256 totalSupplyAfter_ = uint256(_totalSupply) + _amountDelta;\n            if (totalSupplyAfter_ > _stableCoinSupplyCap)\n                revert IMarketErrors.StableCoinSupplyCapExceeded(_stableCoinSupplyCap, _totalSupply, _amountDelta);\n            totalSupplyAfter = uint64(totalSupplyAfter_); // there will be no overflow here\n        }\n    }\n}\n"}, "contracts/libraries/ReentrancyGuard.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nabstract contract ReentrancyGuard {\n    bytes32 private constant STORAGE_SLOT = keccak256(\"solidity_reentrancy_guard.storage.slot\");\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    modifier nonReentrant() {\n        _nonReentrantBefore(STORAGE_SLOT);\n        _;\n        _nonReentrantAfter(STORAGE_SLOT);\n    }\n\n    modifier nonReentrantToken(IERC20 _token) {\n        bytes32 slot = bytes32(uint256(uint160(address(_token))));\n        _nonReentrantBefore(slot);\n        _;\n        _nonReentrantAfter(slot);\n    }\n\n    function _nonReentrantBefore(bytes32 _slot) private {\n        uint256 state;\n        // prettier-ignore\n        assembly { state := tload(_slot) }\n        require(state == 0, ReentrancyGuardReentrantCall());\n        // prettier-ignore\n        assembly { tstore(_slot, 1) }\n    }\n\n    function _nonReentrantAfter(bytes32 _slot) private {\n        // prettier-ignore\n        assembly { tstore(_slot, 0) }\n    }\n}\n"}, "contracts/libraries/SpreadUtil.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport \"./Constants.sol\";\nimport \"../core/interfaces/IMarketManager.sol\";\nimport {M as Math} from \"../libraries/Math.sol\";\nimport \"solady/src/utils/FixedPointMathLib.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nlibrary SpreadUtil {\n    using SafeCast for *;\n    using FixedPointMathLib for *;\n\n    struct CalcSpreadParam {\n        Side side;\n        uint96 sizeDelta;\n        int256 spreadFactorBeforeX96;\n        uint64 lastTradingTimestamp;\n    }\n\n    /// @notice Calculate the trade spread when operating on positions or mint/burn PUSD\n    /// @param _cfg The market configuration\n    /// @return spreadAmount The amount of trade spread\n    /// @return spreadFactorAfterX96 The spread factor after the trade, as a Q160.96\n    function calcSpread(\n        IConfigurable.MarketConfig storage _cfg,\n        CalcSpreadParam memory _param\n    ) internal view returns (uint96 spreadAmount, int256 spreadFactorAfterX96) {\n        uint256 spreadX96;\n        (spreadFactorAfterX96, spreadX96) = refreshSpread(_cfg, _param);\n\n        spreadAmount = calcSpreadAmount(spreadX96, _param.sizeDelta, Math.Rounding.Up);\n\n        spreadFactorAfterX96 = calcSpreadFactorAfterX96(spreadFactorAfterX96, _param.side, _param.sizeDelta);\n    }\n\n    function calcSpreadAmount(\n        uint256 _spreadX96,\n        uint96 _sizeDelta,\n        Math.Rounding _rounding\n    ) internal pure returns (uint96 spreadAmount) {\n        spreadAmount = Math.mulDiv(_spreadX96, _sizeDelta, Constants.Q96, _rounding).toUint96();\n    }\n\n    function calcSpreadFactorAfterX96(\n        int256 _spreadFactorBeforeX96,\n        Side _side,\n        uint96 _sizeDelta\n    ) internal pure returns (int256 spreadFactorAfterX96) {\n        unchecked {\n            int256 sizeDeltaX96 = int256(uint256(_sizeDelta) << 96);\n            spreadFactorAfterX96 = _side.isLong()\n                ? _spreadFactorBeforeX96 + sizeDeltaX96\n                : _spreadFactorBeforeX96 - sizeDeltaX96;\n        }\n    }\n\n    /// @notice Refresh the spread factor since last trading and calculate the spread\n    function refreshSpread(\n        IConfigurable.MarketConfig storage _cfg,\n        CalcSpreadParam memory _param\n    ) internal view returns (int256 spreadFactorAfterX96, uint256 spreadX96) {\n        unchecked {\n            uint256 riskFreeTime = _cfg.riskFreeTime;\n            uint256 timeInterval = block.timestamp - _param.lastTradingTimestamp;\n            if (timeInterval >= riskFreeTime || _param.spreadFactorBeforeX96 == 0) return (0, 0);\n\n            // Due to `Math.Rounding.Up`, if `spreadFactorBeforeX96Abs` > `0`, then `spreadFactorAfterX96Abs` > `0`\n            uint256 spreadFactorAfterX96Abs = Math.ceilDiv(\n                _param.spreadFactorBeforeX96.abs() * (riskFreeTime - timeInterval),\n                riskFreeTime\n            );\n\n            spreadFactorAfterX96 = _param.spreadFactorBeforeX96 > 0\n                ? int256(spreadFactorAfterX96Abs)\n                : -int256(spreadFactorAfterX96Abs);\n\n            spreadX96 = (_param.side.isLong() && spreadFactorAfterX96 > 0) ||\n                (_param.side.isShort() && spreadFactorAfterX96 < 0)\n                ? 0\n                : Math.ceilDiv(spreadFactorAfterX96Abs, _cfg.liquidityScale);\n        }\n    }\n}\n"}, "contracts/libraries/UnsafeMath.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nlibrary UnsafeMath {\n    /// @notice Calculate `a + b` without overflow check\n    function addU256(uint256 a, uint256 b) internal pure returns (uint256) {\n        // prettier-ignore\n        unchecked { return a + b; }\n    }\n\n    /// @notice Calculate `a + b` without overflow check\n    function addU128(uint128 a, uint128 b) internal pure returns (uint128) {\n        // prettier-ignore\n        unchecked { return a + b; }\n    }\n\n    /// @notice Calculate `a - b` without underflow check\n    function subU256(uint256 a, uint256 b) internal pure returns (uint256) {\n        // prettier-ignore\n        unchecked { return a - b; }\n    }\n\n    /// @notice Calculate `a - b` without underflow check\n    function subU128(uint128 a, uint128 b) internal pure returns (uint128) {\n        // prettier-ignore\n        unchecked { return a - b; }\n    }\n\n    /// @notice Calculate `a - b` without underflow check\n    function subU96(uint96 a, uint96 b) internal pure returns (uint96) {\n        // prettier-ignore\n        unchecked { return a - b; }\n    }\n\n    /// @notice Calculate `a * b` without overflow check\n    function mulU256(uint256 a, uint256 b) internal pure returns (uint256) {\n        // prettier-ignore\n        unchecked { return a * b; }\n    }\n\n    /// @notice Calculate `a / b` without overflow check\n    function divU256(uint256 a, uint256 b) internal pure returns (uint256) {\n        // prettier-ignore\n        unchecked { return a / b; }\n    }\n}\n"}, "contracts/misc/interfaces/IReader.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\nimport \"../../core/interfaces/IMarketManager.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IReader {\n    struct ReaderState {\n        IMarketManager marketManager;\n        MockState mockState;\n    }\n\n    struct MockState {\n        IMarketManager.State state;\n        IConfigurable.MarketConfig marketConfig;\n        uint256 totalSupply;\n    }\n\n    /// @notice Calculate the price of the LP Token\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param indexPrice The index price of the market\n    /// @return totalSupply The total supply of the LP Token\n    /// @return liquidity The liquidity of the LP Token\n    /// @return price The price of the LP Token\n    function calcLPTPrice(\n        IERC20 market,\n        uint64 indexPrice\n    ) external returns (uint256 totalSupply, uint128 liquidity, uint64 price);\n\n    /// @notice Calculates the amount when user minting PUSD\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param amount When `exactIn` is true, it is the amount of token to pay,\n    /// otherwise, it is the amount of PUSD to mint\n    /// @param indexPrice The index price of the market\n    /// @return payAmount The amount of market tokens to pay\n    /// @return receiveAmount The amount of PUSD to receive\n    function quoteMintPUSD(\n        IERC20 market,\n        bool exactIn,\n        uint96 amount,\n        uint64 indexPrice\n    ) external returns (uint96 payAmount, uint64 receiveAmount);\n\n    /// @notice Calculates the amount when user burning PUSD\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param amount When `exactIn` is true, it is the amount of PUSD to burn,\n    /// otherwise, it is the amount of token to receive\n    /// @param indexPrice The index price of the market\n    /// @return payAmount The amount of PUSD to pay\n    /// @return receiveAmount The amount of market tokens to receive\n    function quoteBurnPUSD(\n        IERC20 market,\n        bool exactIn,\n        uint96 amount,\n        uint64 indexPrice\n    ) external returns (uint64 payAmount, uint96 receiveAmount);\n\n    /// @notice Calculates the amount of LPT tokens that can be minted by burning a given amount of PUSD\n    /// @dev Uses the provided index price to determine the conversion rates\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param amountIn The amount of PUSD to be burned\n    /// @param indexPrice The index price of the market\n    /// @return burnPUSDReceiveAmount The amount of market tokens received after burning the provided PUSD\n    /// @return mintLPTTokenValue The amount of LPT tokens minted using `burnPUSDReceiveAmount`\n    function quoteBurnPUSDToMintLPT(\n        IERC20 market,\n        uint96 amountIn,\n        uint64 indexPrice\n    ) external returns (uint96 burnPUSDReceiveAmount, uint64 mintLPTTokenValue);\n\n    /// @notice Calculates the amount of PUSD tokens minted when burning a given amount of LPT tokens\n    /// @dev Uses the provided index price to determine the conversion rates\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param amountIn The amount of LPT tokens to be burned\n    /// @param indexPrice The index price of the market\n    /// @return burnLPTReceiveAmount The amount of market tokens received after burning the provided LPT tokens\n    /// @return mintPUSDTokenValue The amount of PUSD tokens minted using `burnLPTReceiveAmount`\n    function quoteBurnLPTToMintPUSD(\n        IERC20 market,\n        uint64 amountIn,\n        uint64 indexPrice\n    ) external returns (uint96 burnLPTReceiveAmount, uint64 mintPUSDTokenValue);\n\n    /// @notice Calculates the results of burning PUSD to increase a position in a given market\n    /// @dev Uses the provided index price and leverage to determine the conversion rates\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param account The owner of the position\n    /// @param amountIn The amount of PUSD to be burned\n    /// @param indexPrice The index price of the market\n    /// @param leverage The leverage to be applied for this position increase operation,\n    /// denominated in thousandths of a bip (i.e. 1e-7)\n    /// @return burnPUSDReceiveAmount The amount of market tokens received after burning the provided PUSD\n    /// @return size The position size to increase\n    /// @return position The updated position after the operation\n    function quoteBurnPUSDToIncreasePosition(\n        IERC20 market,\n        address account,\n        uint64 amountIn,\n        uint64 indexPrice,\n        uint32 leverage\n    ) external returns (uint96 burnPUSDReceiveAmount, uint96 size, IMarketPosition.Position memory position);\n\n    /// @notice Calculates the results of decreasing a position to mint PUSD tokens in a given market\n    /// @dev Uses the provided index price to determine the conversion rates and position changes\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param account The owner of the position\n    /// @param size The size of the position to be decreased\n    /// @param indexPrice The index price of the market\n    /// @return decreasePositionReceiveAmount The amount of market tokens received after decreasing the position\n    /// @return mintPUSDTokenValue The amount of PUSD tokens minted using `decreasePositionReceiveAmount`\n    /// @return marginAfter The margin remaining in the position after the operation\n    function quoteDecreasePositionToMintPUSD(\n        IERC20 market,\n        address account,\n        uint96 size,\n        uint64 indexPrice\n    ) external returns (uint96 decreasePositionReceiveAmount, uint64 mintPUSDTokenValue, uint96 marginAfter);\n\n    /// @notice Calculate the market tokens required to pay based on the increase position size\n    /// @dev Uses the provided index price and leverage to determine the conversion rates\n    /// @param market The target market contract address, such as the contract address of WETH\n    /// @param account The owner of the position\n    /// @param size The size of the position to be increased\n    /// @param leverage The leverage to be applied for this position increase operation,\n    /// denominated in thousandths of a bip (i.e. 1e-7)\n    /// @param indexPrice The index price of the market\n    /// @return payAmount The amount of market tokens to pay\n    /// @return marginAfter The adjusted margin\n    /// @return spread The spread incurred by the position\n    /// @return tradingFee The trading fee paid by the position\n    /// @return liquidationPrice The liquidation price after increasing position\n    function quoteIncreasePositionBySize(\n        IERC20 market,\n        address account,\n        uint96 size,\n        uint32 leverage,\n        uint64 indexPrice\n    )\n        external\n        returns (uint96 payAmount, uint96 marginAfter, uint96 spread, uint96 tradingFee, uint64 liquidationPrice);\n\n    /// @notice Calculate min and max price if passed a specific price value\n    /// @param marketPrices Array of market addresses and prices to update for\n    /// @return minPrices The minimum price for each market\n    /// @return maxPrices The maximum price for each market\n    function calcPrices(\n        PackedValue[] calldata marketPrices\n    ) external view returns (uint64[] memory minPrices, uint64[] memory maxPrices);\n}\n"}, "contracts/misc/Reader.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\nimport \"./interfaces/IReader.sol\";\nimport \"../libraries/PositionReader.sol\";\nimport \"../libraries/LiquidityReader.sol\";\nimport \"../libraries/PriceFeedUtil.sol\";\n\ncontract Reader is IReader {\n    using SafeCast for *;\n    using UnsafeMath for *;\n\n    ReaderState readerState;\n\n    constructor(MarketManagerUpgradeable _marketManager) {\n        readerState.marketManager = _marketManager;\n    }\n\n    /// @inheritdoc IReader\n    function calcLPTPrice(\n        IERC20 _market,\n        uint64 _indexPrice\n    ) public override returns (uint256 totalSupply_, uint128 liquidity, uint64 price) {\n        return LiquidityReader.calcLPTPrice(readerState, _market, _indexPrice);\n    }\n\n    /// @inheritdoc IReader\n    function quoteMintPUSD(\n        IERC20 _market,\n        bool _exactIn,\n        uint96 _amount,\n        uint64 _indexPrice\n    ) public override returns (uint96 payAmount, uint64 receiveAmount) {\n        IMarketManager marketManager = readerState.marketManager;\n        if (!marketManager.isEnabledMarket(_market)) revert IConfigurable.MarketNotEnabled(_market);\n\n        MockState storage mockState = readerState.mockState;\n        IMarketManager.State storage state = mockState.state;\n        mockState.marketConfig = marketManager.marketConfigs(_market);\n        IConfigurable.MarketConfig storage marketConfig = mockState.marketConfig;\n\n        state.packedState = marketManager.packedStates(_market);\n        IPUSDManager.GlobalPUSDPosition memory pusdPosition = marketManager.globalPUSDPositions(_market);\n        state.globalPUSDPosition = pusdPosition;\n        state.tokenBalance = marketManager.tokenBalances(_market);\n\n        PUSD pusd = PUSDManagerUtil.deployPUSD();\n        pusd.mint(address(this), pusdPosition.totalSupply); // for mock\n        (payAmount, receiveAmount) = PUSDManagerUtil.mint(\n            state,\n            marketConfig,\n            PUSDManagerUtil.MintParam({\n                market: IERC20(address(this)), // for mock\n                exactIn: _exactIn,\n                amount: _amount,\n                callback: IPUSDManagerCallback(address(this)), // for mock\n                indexPrice: _indexPrice,\n                receiver: address(this)\n            }),\n            msg.data // for mock\n        );\n\n        delete readerState.mockState;\n    }\n\n    /// @inheritdoc IReader\n    function quoteBurnPUSD(\n        IERC20 _market,\n        bool _exactIn,\n        uint96 _amount,\n        uint64 _indexPrice\n    ) public override returns (uint64 payAmount, uint96 receiveAmount) {\n        IMarketManager marketManager = readerState.marketManager;\n        if (!marketManager.isEnabledMarket(_market)) revert IConfigurable.MarketNotEnabled(_market);\n\n        MockState storage mockState = readerState.mockState;\n        IMarketManager.State storage state = mockState.state;\n        mockState.marketConfig = marketManager.marketConfigs(_market);\n        IConfigurable.MarketConfig storage marketConfig = mockState.marketConfig;\n\n        state.packedState = marketManager.packedStates(_market);\n        IPUSDManager.GlobalPUSDPosition memory pusdPosition = marketManager.globalPUSDPositions(_market);\n        state.globalPUSDPosition = pusdPosition;\n        state.tokenBalance = marketManager.tokenBalances(_market);\n\n        PUSD pusd = PUSDManagerUtil.deployPUSD(); // for mock\n        pusd.mint(address(this), pusdPosition.totalSupply);\n        (payAmount, receiveAmount) = PUSDManagerUtil.burn(\n            state,\n            marketConfig,\n            PUSDManagerUtil.BurnParam({\n                market: IERC20(address(this)), // for mock\n                exactIn: _exactIn,\n                amount: _amount,\n                callback: IPUSDManagerCallback(address(this)), // for mock\n                indexPrice: _indexPrice,\n                receiver: address(this)\n            }),\n            bytes(\"\")\n        );\n\n        delete readerState.mockState;\n    }\n\n    /// @inheritdoc IReader\n    function quoteBurnPUSDToMintLPT(\n        IERC20 _market,\n        uint96 _amountIn,\n        uint64 _indexPrice\n    ) public override returns (uint96 burnPUSDReceiveAmount, uint64 mintLPTTokenValue) {\n        return LiquidityReader.quoteBurnPUSDToMintLPT(readerState, _market, _amountIn, _indexPrice);\n    }\n\n    /// @inheritdoc IReader\n    function quoteBurnLPTToMintPUSD(\n        IERC20 _market,\n        uint64 _amountIn,\n        uint64 _indexPrice\n    ) public override returns (uint96 burnLPTReceiveAmount, uint64 mintPUSDTokenValue) {\n        return LiquidityReader.quoteBurnLPTToMintPUSD(readerState, _market, _amountIn, _indexPrice);\n    }\n\n    /// @inheritdoc IReader\n    function quoteBurnPUSDToIncreasePosition(\n        IERC20 _market,\n        address _account,\n        uint64 _amountIn,\n        uint64 _indexPrice,\n        uint32 _leverage\n    ) public override returns (uint96 burnPUSDReceiveAmount, uint96 size, IMarketPosition.Position memory position) {\n        return\n            PositionReader.quoteBurnPUSDToIncreasePosition(\n                readerState,\n                _market,\n                _account,\n                _amountIn,\n                _indexPrice,\n                _leverage\n            );\n    }\n\n    /// @inheritdoc IReader\n    function quoteDecreasePositionToMintPUSD(\n        IERC20 _market,\n        address _account,\n        uint96 _size,\n        uint64 _indexPrice\n    ) public override returns (uint96 decreasePositionReceiveAmount, uint64 mintPUSDTokenValue, uint96 marginAfter) {\n        return PositionReader.quoteDecreasePositionToMintPUSD(readerState, _market, _account, _size, _indexPrice);\n    }\n\n    /// @inheritdoc IReader\n    function quoteIncreasePositionBySize(\n        IERC20 _market,\n        address _account,\n        uint96 _size,\n        uint32 _leverage,\n        uint64 _indexPrice\n    )\n        public\n        override\n        returns (uint96 payAmount, uint96 marginAfter, uint96 spread, uint96 tradingFee, uint64 liquidationPrice)\n    {\n        return\n            PositionReader.quoteIncreasePositionBySize(readerState, _market, _account, _size, _leverage, _indexPrice);\n    }\n\n    function longPositions(address _account) external view returns (IMarketPosition.Position memory) {\n        return readerState.mockState.state.longPositions[_account];\n    }\n\n    /// @inheritdoc IReader\n    function calcPrices(\n        PackedValue[] calldata _marketPrices\n    ) external view override returns (uint64[] memory minPrices, uint64[] memory maxPrices) {\n        (uint24 maxDeviationRatio, uint32 cumulativeRoundDuration, , bool ignoreReferencePriceFeedError) = readerState\n            .marketManager\n            .globalPriceFeedConfig();\n\n        uint256 pricesLength = _marketPrices.length;\n        minPrices = new uint64[](pricesLength);\n        maxPrices = new uint64[](pricesLength);\n        for (uint256 i; i < pricesLength; ++i) {\n            IERC20 market = IERC20(_marketPrices[i].unpackAddress(0));\n            uint64 price = _marketPrices[i].unpackUint64(160);\n            IPriceFeed.PriceFeedConfig memory cfg = readerState.marketManager.marketPriceFeedConfigs(market);\n            if (address(cfg.refPriceFeed) == address(0)) {\n                if (!ignoreReferencePriceFeedError) revert IPriceFeed.ReferencePriceFeedNotSet();\n                minPrices[i] = price.toUint64();\n                maxPrices[i] = price.toUint64();\n                continue;\n            }\n\n            uint64 latestRefPrice = PriceFeedUtil.getReferencePrice(cfg, Constants.PRICE_DECIMALS);\n\n            IPriceFeed.PricePack memory pack = readerState.marketManager.marketPricePacks(market);\n            IPriceFeed.PriceDataItem memory dataItem = IPriceFeed.PriceDataItem({\n                prevRound: pack.prevRound,\n                prevRefPrice: pack.prevRefPrice,\n                cumulativeRefPriceDelta: pack.cumulativePriceDelta,\n                prevPrice: pack.prevPrice,\n                cumulativePriceDelta: pack.cumulativePriceDelta\n            });\n            bool reachMaxDeltaDiff = PriceFeedUtil.calcNewPriceDataItem(\n                dataItem,\n                price,\n                latestRefPrice,\n                cfg.maxCumulativeDeltaDiff,\n                cumulativeRoundDuration\n            );\n\n            (uint256 minPrice, uint256 maxPrice) = PriceFeedUtil.calcMinAndMaxPrice(\n                price,\n                latestRefPrice,\n                maxDeviationRatio,\n                reachMaxDeltaDiff\n            );\n            (minPrices[i], maxPrices[i]) = (minPrice.toUint64(), maxPrice.toUint64());\n        }\n        return (minPrices, maxPrices);\n    }\n\n    // The following methods are mock methods for calculation\n\n    function PUSDManagerCallback(IERC20 _token, uint96 _payAmount, uint96, bytes calldata) external {\n        require(msg.sender == address(this));\n        readerState.mockState.totalSupply = _payAmount;\n\n        if (address(_token) == PUSDManagerUtil.computePUSDAddress())\n            PUSD(address(_token)).mint(address(this), _payAmount);\n    }\n\n    function transfer(address, uint256) external view returns (bool) {\n        require(msg.sender == address(this));\n        return true;\n    }\n\n    function balanceOf(address) external view returns (uint256) {\n        return readerState.mockState.totalSupply;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return readerState.mockState.totalSupply;\n    }\n}\n"}, "contracts/oracle/interfaces/IChainLinkAggregator.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\ninterface IChainLinkAggregator {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(\n        uint80 _roundId\n    )\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n    function latestRoundData()\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"}, "contracts/oracle/interfaces/IPriceFeed.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\nimport \"./IChainLinkAggregator.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../../types/PackedValue.sol\";\n\ninterface IPriceFeed {\n    struct PriceFeedConfig {\n        /// @notice ChainLink contract address for corresponding market\n        IChainLinkAggregator refPriceFeed;\n        /// @notice Expected update interval of chain link price feed\n        uint32 refHeartbeatDuration;\n        /// @notice Maximum cumulative change ratio difference between prices and ChainLink price\n        /// within a period of time.\n        uint48 maxCumulativeDeltaDiff;\n        /// @notice Decimals of ChainLink price\n        uint8 refPriceDecimals;\n    }\n\n    struct PriceDataItem {\n        /// @notice previous round id\n        uint32 prevRound;\n        /// @notice previous ChainLink price\n        uint64 prevRefPrice;\n        /// @notice cumulative value of the ChainLink price change ratio in a round\n        uint64 cumulativeRefPriceDelta;\n        /// @notice previous market price\n        uint64 prevPrice;\n        /// @notice cumulative value of the market price change ratio in a round\n        uint64 cumulativePriceDelta;\n    }\n\n    struct PricePack {\n        /// @notice The timestamp when updater uploads the price\n        uint32 updateTimestamp;\n        /// @notice Calculated maximum price\n        uint64 maxPrice;\n        /// @notice Calculated minimum price\n        uint64 minPrice;\n        /// @notice previous round id\n        uint32 prevRound;\n        /// @notice previous ChainLink price\n        uint64 prevRefPrice;\n        /// @notice cumulative value of the ChainLink price change ratio in a round\n        uint64 cumulativeRefPriceDelta;\n        /// @notice previous market price\n        uint64 prevPrice;\n        /// @notice cumulative value of the market price change ratio in a round\n        uint64 cumulativePriceDelta;\n    }\n\n    /// @notice Emitted when market price updated\n    /// @param market Market address\n    /// @param price The price passed in by updater\n    /// @param maxPrice Calculated maximum price\n    /// @param minPrice Calculated minimum price\n    event PriceUpdated(IERC20 indexed market, uint64 price, uint64 minPrice, uint64 maxPrice);\n\n    /// @notice Emitted when maxCumulativeDeltaDiff exceeded\n    /// @param market Market address\n    /// @param price The price passed in by updater\n    /// @param refPrice The price provided by ChainLink\n    /// @param cumulativeDelta The cumulative value of the price change ratio\n    /// @param cumulativeRefDelta The cumulative value of the ChainLink price change ratio\n    event MaxCumulativeDeltaDiffExceeded(\n        IERC20 indexed market,\n        uint64 price,\n        uint64 refPrice,\n        uint64 cumulativeDelta,\n        uint64 cumulativeRefDelta\n    );\n\n    /// @notice Price not be initialized\n    error NotInitialized();\n\n    /// @notice Reference price feed not set\n    error ReferencePriceFeedNotSet();\n\n    /// @notice Invalid reference price\n    /// @param referencePrice Reference price\n    error InvalidReferencePrice(int256 referencePrice);\n\n    /// @notice Reference price timeout\n    /// @param elapsed The time elapsed since the last price update.\n    error ReferencePriceTimeout(uint256 elapsed);\n\n    /// @notice Invalid update timestamp\n    /// @param timestamp Update timestamp\n    error InvalidUpdateTimestamp(uint32 timestamp);\n\n    /// @notice Update market price feed config\n    /// @param market Market address\n    /// @param priceFeed ChainLink price feed\n    /// @param refHeartBeatDuration Expected update interval of chain link price feed\n    /// @param maxCumulativeDeltaDiff Maximum cumulative change ratio difference between prices and ChainLink price\n    function updateMarketPriceFeedConfig(\n        IERC20 market,\n        IChainLinkAggregator priceFeed,\n        uint32 refHeartBeatDuration,\n        uint48 maxCumulativeDeltaDiff\n    ) external;\n\n    /// @notice Get market price feed config\n    /// @param market Market address\n    /// @return config The price feed config\n    function marketPriceFeedConfigs(IERC20 market) external view returns (PriceFeedConfig memory config);\n\n    /// @notice update global price feed config\n    /// @param maxDeviationRatio Maximum deviation ratio between ChainLink price and market price\n    /// @param cumulativeRoundDuration The duration of the round for the cumulative value of the price change ratio\n    /// @param updateTxTimeout The maximum time allowed for the transaction to update the price\n    /// @param ignoreReferencePriceFeedError Whether to ignore the error of the reference price feed not settled\n    function updateGlobalPriceFeedConfig(\n        uint24 maxDeviationRatio,\n        uint32 cumulativeRoundDuration,\n        uint32 updateTxTimeout,\n        bool ignoreReferencePriceFeedError\n    ) external;\n\n    /// @notice Get global price feed config\n    /// @return maxDeviationRatio Maximum deviation ratio between ChainLink price and market price\n    /// @return cumulativeRoundDuration The duration of the round for the cumulative value of the price change ratio\n    /// @return updateTxTimeout The maximum time allowed for the transaction to update the price\n    /// @return ignoreReferencePriceFeedError Whether to ignore the error of the reference price feed not settled\n    function globalPriceFeedConfig()\n        external\n        view\n        returns (\n            uint24 maxDeviationRatio,\n            uint32 cumulativeRoundDuration,\n            uint32 updateTxTimeout,\n            bool ignoreReferencePriceFeedError\n        );\n\n    /// @notice Update updater\n    /// @param account The account to set\n    function updateUpdater(address account) external;\n\n    /// @notice Get market price\n    /// @param market Market address\n    /// @return minPrice Minimum price\n    /// @return maxPrice Maximum price\n    function getPrice(IERC20 market) external view returns (uint64 minPrice, uint64 maxPrice);\n\n    /// @notice Check if the account is updater\n    /// @param account The account to check\n    /// @return active True if the account is updater\n    function isUpdater(address account) external view returns (bool active);\n\n    /// @notice Update market price\n    /// @param packedValue The packed values of the order index and require success flag: bit 0-159 represent\n    /// market address, bit 160-223 represent the price and bit 223-255 represent the update timestamp\n    function updatePrice(PackedValue packedValue) external;\n\n    /// @notice Get market price data packed data\n    /// @param market Market address\n    /// @return pack The price packed data\n    function marketPricePacks(IERC20 market) external view returns (PricePack memory pack);\n}\n"}, "contracts/oracle/PriceFeedUpgradeable.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport \"./interfaces/IPriceFeed.sol\";\nimport \"../libraries/PriceFeedUtil.sol\";\nimport \"../governance/GovernableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nabstract contract PriceFeedUpgradeable is IPriceFeed, GovernableUpgradeable {\n    using SafeCast for *;\n\n    /// @custom:storage-location erc7201:Purecash.storage.PriceFeedUpgradeable\n    struct PriceFeedStorage {\n        /// @dev Ignore if reference price feed is not settled.\n        bool ignoreReferencePriceFeedError;\n        /// @dev Maximum deviation ratio between price and ChainLink price.\n        uint24 maxDeviationRatio;\n        /// @dev Period for calculating cumulative deviation ratio.\n        uint32 cumulativeRoundDuration;\n        /// @dev The timeout for price update transactions.\n        uint32 updateTxTimeout;\n        /// @dev The price updater address\n        address updater;\n        /// @dev Market price config\n        mapping(IERC20 market => PriceFeedConfig) priceFeedConfigs;\n        /// @dev Latest price\n        mapping(IERC20 market => PricePack) latestPrices;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"Purecash.storage.PriceFeedUpgradeable\")) - 1))\n    // & ~bytes32(uint256(0xff))\n    bytes32 private constant PRICE_FEED_UPGRADEABLE_STORAGE =\n        0x58a0c8f0f88cec20fbd92b7b52b0d2d1fcf9b126fb78d3cc170d4a02c5be0900;\n\n    function __PriceFeed_init(bool _ignoreReferencePriceFeedError, address _initialGov) internal onlyInitializing {\n        __PriceFeed_init_unchained(_ignoreReferencePriceFeedError);\n        __Governable_init(_initialGov);\n    }\n\n    function __PriceFeed_init_unchained(bool _ignoreReferencePriceFeedError) internal onlyInitializing {\n        PriceFeedStorage storage $ = _priceFeedStorage();\n        ($.maxDeviationRatio, $.cumulativeRoundDuration, $.updateTxTimeout) = (100e3, 1 minutes, 1 minutes);\n        $.ignoreReferencePriceFeedError = _ignoreReferencePriceFeedError;\n    }\n\n    /// @inheritdoc IPriceFeed\n    function updatePrice(PackedValue _packedValue) external override {\n        PriceFeedStorage storage $ = _priceFeedStorage();\n        if (msg.sender != $.updater) revert Forbidden();\n        IERC20 _market = IERC20(_packedValue.unpackAddress(0));\n        uint64 price = _packedValue.unpackUint64(160);\n        uint32 timestamp = _packedValue.unpackUint32(224);\n        PricePack storage pack = $.latestPrices[_market];\n        if (!_updateMarketLastUpdated(pack, timestamp, $.updateTxTimeout)) return;\n        PriceFeedConfig memory cfg = $.priceFeedConfigs[_market];\n        if (address(cfg.refPriceFeed) == address(0)) {\n            if (!$.ignoreReferencePriceFeedError) revert ReferencePriceFeedNotSet();\n            pack.minPrice = price;\n            pack.maxPrice = price;\n            emit PriceUpdated(_market, price, price, price);\n            return;\n        }\n\n        uint64 latestRefPrice = PriceFeedUtil.getReferencePrice(cfg, Constants.PRICE_DECIMALS);\n        PriceDataItem memory dataItem = PriceDataItem({\n            prevRound: pack.prevRound,\n            prevRefPrice: pack.prevRefPrice,\n            cumulativeRefPriceDelta: pack.cumulativeRefPriceDelta,\n            prevPrice: pack.prevPrice,\n            cumulativePriceDelta: pack.cumulativePriceDelta\n        });\n        bool reachMaxDeltaDiff = PriceFeedUtil.calcNewPriceDataItem(\n            dataItem,\n            price,\n            latestRefPrice,\n            cfg.maxCumulativeDeltaDiff,\n            $.cumulativeRoundDuration\n        );\n        pack.prevRound = dataItem.prevRound;\n        pack.prevRefPrice = dataItem.prevRefPrice;\n        pack.cumulativeRefPriceDelta = dataItem.cumulativeRefPriceDelta;\n        pack.prevPrice = dataItem.prevPrice;\n        pack.cumulativePriceDelta = dataItem.cumulativePriceDelta;\n\n        if (reachMaxDeltaDiff)\n            emit MaxCumulativeDeltaDiffExceeded(\n                _market,\n                price,\n                latestRefPrice,\n                dataItem.cumulativePriceDelta,\n                dataItem.cumulativeRefPriceDelta\n            );\n        (uint64 minPrice, uint64 maxPrice) = PriceFeedUtil.calcMinAndMaxPrice(\n            price,\n            latestRefPrice,\n            $.maxDeviationRatio,\n            reachMaxDeltaDiff\n        );\n        pack.minPrice = minPrice;\n        pack.maxPrice = maxPrice;\n        emit PriceUpdated(_market, price, minPrice, maxPrice);\n    }\n\n    /// @inheritdoc IPriceFeed\n    function getPrice(IERC20 _market) external view override returns (uint64 minPrice, uint64 maxPrice) {\n        (minPrice, maxPrice) = _getPrice(_market);\n    }\n\n    /// @inheritdoc IPriceFeed\n    function updateUpdater(address _account) external override onlyGov {\n        _priceFeedStorage().updater = _account;\n    }\n\n    /// @inheritdoc IPriceFeed\n    function isUpdater(address _account) external view override returns (bool active) {\n        return _priceFeedStorage().updater == _account;\n    }\n\n    /// @inheritdoc IPriceFeed\n    function updateGlobalPriceFeedConfig(\n        uint24 _maxDeviationRatio,\n        uint32 _cumulativeRoundDuration,\n        uint32 _updateTxTimeout,\n        bool _ignoreReferencePriceFeedError\n    ) external override onlyGov {\n        PriceFeedStorage storage $ = _priceFeedStorage();\n        ($.maxDeviationRatio, $.cumulativeRoundDuration, $.updateTxTimeout, $.ignoreReferencePriceFeedError) = (\n            _maxDeviationRatio,\n            _cumulativeRoundDuration,\n            _updateTxTimeout,\n            _ignoreReferencePriceFeedError\n        );\n    }\n\n    /// @inheritdoc IPriceFeed\n    function globalPriceFeedConfig()\n        external\n        view\n        override\n        returns (\n            uint24 maxDeviationRatio,\n            uint32 cumulativeRoundDuration,\n            uint32 updateTxTimeout,\n            bool ignoreReferencePriceFeedError\n        )\n    {\n        PriceFeedStorage storage $ = _priceFeedStorage();\n        return ($.maxDeviationRatio, $.cumulativeRoundDuration, $.updateTxTimeout, $.ignoreReferencePriceFeedError);\n    }\n\n    /// @inheritdoc IPriceFeed\n    function updateMarketPriceFeedConfig(\n        IERC20 _market,\n        IChainLinkAggregator _priceFeed,\n        uint32 _refHeartBeatDuration,\n        uint48 _maxCumulativeDeltaDiff\n    ) external override onlyGov {\n        uint8 refPriceDecimals;\n        if (address(_priceFeed) != address(0x0)) refPriceDecimals = _priceFeed.decimals();\n        _priceFeedStorage().priceFeedConfigs[_market] = PriceFeedConfig({\n            refPriceFeed: _priceFeed,\n            refHeartbeatDuration: _refHeartBeatDuration,\n            maxCumulativeDeltaDiff: _maxCumulativeDeltaDiff,\n            refPriceDecimals: refPriceDecimals\n        });\n    }\n\n    /// @inheritdoc IPriceFeed\n    function marketPriceFeedConfigs(IERC20 _market) external view override returns (PriceFeedConfig memory config) {\n        config = _priceFeedStorage().priceFeedConfigs[_market];\n    }\n\n    /// @inheritdoc IPriceFeed\n    function marketPricePacks(IERC20 _market) external view override returns (PricePack memory pack) {\n        pack = _priceFeedStorage().latestPrices[_market];\n        return pack;\n    }\n\n    function _getPrice(IERC20 _market) internal view returns (uint64 minPrice, uint64 maxPrice) {\n        PricePack storage price = _priceFeedStorage().latestPrices[_market];\n        (minPrice, maxPrice) = (price.minPrice, price.maxPrice);\n        if (minPrice | maxPrice == 0) revert NotInitialized();\n    }\n\n    function _getMinPrice(IERC20 _market) internal view returns (uint64 minPrice) {\n        minPrice = _priceFeedStorage().latestPrices[_market].minPrice;\n        if (minPrice == 0) revert NotInitialized();\n    }\n\n    function _getMaxPrice(IERC20 _market) internal view returns (uint64 maxPrice) {\n        maxPrice = _priceFeedStorage().latestPrices[_market].maxPrice;\n        if (maxPrice == 0) revert NotInitialized();\n    }\n\n    function _updateMarketLastUpdated(\n        PricePack storage _latestPrice,\n        uint32 _timestamp,\n        uint32 _updateTxTimeout\n    ) internal returns (bool) {\n        // Execution delay may cause the update time to be out of order.\n        if (_timestamp <= _latestPrice.updateTimestamp) return false;\n\n        // timeout and revert\n        if (_timestamp >= block.timestamp + _updateTxTimeout) revert InvalidUpdateTimestamp(_timestamp);\n\n        _latestPrice.updateTimestamp = _timestamp;\n        return true;\n    }\n\n    function _priceFeedStorage() internal pure returns (PriceFeedStorage storage $) {\n        // prettier-ignore\n        assembly { $.slot := PRICE_FEED_UPGRADEABLE_STORAGE }\n    }\n}\n"}, "contracts/plugins/interfaces/IPluginManager.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Plugin Manager Interface\n/// @notice The interface defines the functions to manage plugins\ninterface IPluginManager {\n    /// @notice Emitted when a plugin is updated\n    /// @param plugin The plugin to update\n    /// @param active Whether active after the update\n    event PluginUpdated(address indexed plugin, bool active);\n\n    /// @notice Error thrown when the plugin is inactive\n    error PluginInactive(address plugin);\n\n    /// @notice Update plugin\n    /// @param plugin The plugin to update\n    /// @param active Whether active after the update\n    function updatePlugin(address plugin, bool active) external;\n\n    /// @notice Checks if a plugin is registered\n    /// @param plugin The plugin to check\n    /// @return True if the plugin is registered, false otherwise\n    function activePlugins(address plugin) external view returns (bool);\n\n    /// @notice Transfers `amount` of `token` from `from` to `to`\n    /// @param token The address of the ERC20 token\n    /// @param from The address to transfer the tokens from\n    /// @param to The address to transfer the tokens to\n    /// @param amount The amount of tokens to transfer\n    function pluginTransfer(IERC20 token, address from, address to, uint256 amount) external;\n}\n"}, "contracts/plugins/PluginManagerUpgradeable.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport \"../governance/GovernableUpgradeable.sol\";\nimport \"./interfaces/IPluginManager.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nabstract contract PluginManagerUpgradeable is IPluginManager, GovernableUpgradeable {\n    /// @custom:storage-location erc7201:Purecash.storage.PluginManagerUpgradeable\n    struct PluginManagerStorage {\n        mapping(address plugin => bool) activePlugins;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"Purecash.storage.PluginManagerUpgradeable\")) - 1))\n    // & ~bytes32(uint256(0xff))\n    bytes32 private constant PLUGIN_MANAGER_UPGRADEABLE_STORAGE =\n        0xbb40e86f68fafb11efed99ac959fcf9a51deeafbf5b56a45f87ae418cc6eb300;\n\n    function __PluginManager_init(address _initialGov) internal onlyInitializing {\n        __PluginManager_init_unchained();\n        __Governable_init(_initialGov);\n    }\n\n    function __PluginManager_init_unchained() internal onlyInitializing {}\n\n    /// @inheritdoc IPluginManager\n    function updatePlugin(address _plugin, bool _active) external override onlyGov {\n        PluginManagerStorage storage $ = _pluginManagerStorage();\n\n        $.activePlugins[_plugin] = _active;\n\n        emit PluginUpdated(_plugin, _active);\n    }\n\n    /// @inheritdoc IPluginManager\n    function activePlugins(address _plugin) public view override returns (bool active) {\n        active = _pluginManagerStorage().activePlugins[_plugin];\n    }\n\n    /// @inheritdoc IPluginManager\n    function pluginTransfer(IERC20 _token, address _from, address _to, uint256 _amount) external override {\n        _onlyPlugin();\n        SafeERC20.safeTransferFrom(_token, _from, _to, _amount);\n    }\n\n    function _onlyPlugin() internal view {\n        require(_pluginManagerStorage().activePlugins[msg.sender], PluginInactive(msg.sender));\n    }\n\n    function _pluginManagerStorage() internal pure returns (PluginManagerStorage storage $) {\n        // prettier-ignore\n        assembly { $.slot := PLUGIN_MANAGER_UPGRADEABLE_STORAGE }\n    }\n}\n"}, "contracts/types/PackedValue.sol": {"content": "// This file was procedurally generated from scripts/generate/PackedValue.template.js, DO NOT MODIFY MANUALLY\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\ntype PackedValue is uint256;\n\nusing {\n    packAddress,\n    unpackAddress,\n    packBool,\n    unpackBool,\n    packUint8,\n    unpackUint8,\n    packUint16,\n    unpackUint16,\n    packUint24,\n    unpackUint24,\n    packUint32,\n    unpackUint32,\n    packUint40,\n    unpackUint40,\n    packUint48,\n    unpackUint48,\n    packUint56,\n    unpackUint56,\n    packUint64,\n    unpackUint64,\n    packUint72,\n    unpackUint72,\n    packUint80,\n    unpackUint80,\n    packUint88,\n    unpackUint88,\n    packUint96,\n    unpackUint96,\n    packUint104,\n    unpackUint104,\n    packUint112,\n    unpackUint112,\n    packUint120,\n    unpackUint120,\n    packUint128,\n    unpackUint128,\n    packUint136,\n    unpackUint136,\n    packUint144,\n    unpackUint144,\n    packUint152,\n    unpackUint152,\n    packUint160,\n    unpackUint160,\n    packUint168,\n    unpackUint168,\n    packUint176,\n    unpackUint176,\n    packUint184,\n    unpackUint184,\n    packUint192,\n    unpackUint192,\n    packUint200,\n    unpackUint200,\n    packUint208,\n    unpackUint208,\n    packUint216,\n    unpackUint216,\n    packUint224,\n    unpackUint224,\n    packUint232,\n    unpackUint232,\n    packUint240,\n    unpackUint240,\n    packUint248,\n    unpackUint248\n} for PackedValue global;\n\nfunction packUint8(PackedValue self, uint8 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint8(PackedValue self, uint8 position) pure returns (uint8) {\n    return uint8((PackedValue.unwrap(self) >> position) & 0xff);\n}\n\nfunction packUint16(PackedValue self, uint16 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint16(PackedValue self, uint8 position) pure returns (uint16) {\n    return uint16((PackedValue.unwrap(self) >> position) & 0xffff);\n}\n\nfunction packUint24(PackedValue self, uint24 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint24(PackedValue self, uint8 position) pure returns (uint24) {\n    return uint24((PackedValue.unwrap(self) >> position) & 0xffffff);\n}\n\nfunction packUint32(PackedValue self, uint32 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint32(PackedValue self, uint8 position) pure returns (uint32) {\n    return uint32((PackedValue.unwrap(self) >> position) & 0xffffffff);\n}\n\nfunction packUint40(PackedValue self, uint40 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint40(PackedValue self, uint8 position) pure returns (uint40) {\n    return uint40((PackedValue.unwrap(self) >> position) & 0xffffffffff);\n}\n\nfunction packUint48(PackedValue self, uint48 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint48(PackedValue self, uint8 position) pure returns (uint48) {\n    return uint48((PackedValue.unwrap(self) >> position) & 0xffffffffffff);\n}\n\nfunction packUint56(PackedValue self, uint56 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint56(PackedValue self, uint8 position) pure returns (uint56) {\n    return uint56((PackedValue.unwrap(self) >> position) & 0xffffffffffffff);\n}\n\nfunction packUint64(PackedValue self, uint64 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint64(PackedValue self, uint8 position) pure returns (uint64) {\n    return uint64((PackedValue.unwrap(self) >> position) & 0xffffffffffffffff);\n}\n\nfunction packUint72(PackedValue self, uint72 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint72(PackedValue self, uint8 position) pure returns (uint72) {\n    return uint72((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffff);\n}\n\nfunction packUint80(PackedValue self, uint80 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint80(PackedValue self, uint8 position) pure returns (uint80) {\n    return uint80((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffff);\n}\n\nfunction packUint88(PackedValue self, uint88 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint88(PackedValue self, uint8 position) pure returns (uint88) {\n    return uint88((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffff);\n}\n\nfunction packUint96(PackedValue self, uint96 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint96(PackedValue self, uint8 position) pure returns (uint96) {\n    return uint96((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffff);\n}\n\nfunction packUint104(PackedValue self, uint104 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint104(PackedValue self, uint8 position) pure returns (uint104) {\n    return uint104((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffff);\n}\n\nfunction packUint112(PackedValue self, uint112 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint112(PackedValue self, uint8 position) pure returns (uint112) {\n    return uint112((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffff);\n}\n\nfunction packUint120(PackedValue self, uint120 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint120(PackedValue self, uint8 position) pure returns (uint120) {\n    return uint120((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffff);\n}\n\nfunction packUint128(PackedValue self, uint128 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint128(PackedValue self, uint8 position) pure returns (uint128) {\n    return uint128((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffffff);\n}\n\nfunction packUint136(PackedValue self, uint136 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint136(PackedValue self, uint8 position) pure returns (uint136) {\n    return uint136((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffffffff);\n}\n\nfunction packUint144(PackedValue self, uint144 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint144(PackedValue self, uint8 position) pure returns (uint144) {\n    return uint144((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffffffffff);\n}\n\nfunction packUint152(PackedValue self, uint152 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint152(PackedValue self, uint8 position) pure returns (uint152) {\n    return uint152((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffffffffffff);\n}\n\nfunction packUint160(PackedValue self, uint160 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint160(PackedValue self, uint8 position) pure returns (uint160) {\n    return uint160((PackedValue.unwrap(self) >> position) & 0x00ffffffffffffffffffffffffffffffffffffffff);\n}\n\nfunction packUint168(PackedValue self, uint168 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint168(PackedValue self, uint8 position) pure returns (uint168) {\n    return uint168((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffffffffffffffff);\n}\n\nfunction packUint176(PackedValue self, uint176 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint176(PackedValue self, uint8 position) pure returns (uint176) {\n    return uint176((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffffffffffffffffff);\n}\n\nfunction packUint184(PackedValue self, uint184 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint184(PackedValue self, uint8 position) pure returns (uint184) {\n    return uint184((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffffffffffffffffffff);\n}\n\nfunction packUint192(PackedValue self, uint192 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint192(PackedValue self, uint8 position) pure returns (uint192) {\n    return uint192((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffffffffffffffffffffff);\n}\n\nfunction packUint200(PackedValue self, uint200 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint200(PackedValue self, uint8 position) pure returns (uint200) {\n    return uint200((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffffffffffffffffffffffff);\n}\n\nfunction packUint208(PackedValue self, uint208 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint208(PackedValue self, uint8 position) pure returns (uint208) {\n    return uint208((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffffffffffffffffffffffffff);\n}\n\nfunction packUint216(PackedValue self, uint216 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint216(PackedValue self, uint8 position) pure returns (uint216) {\n    return uint216((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n}\n\nfunction packUint224(PackedValue self, uint224 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint224(PackedValue self, uint8 position) pure returns (uint224) {\n    return uint224((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n}\n\nfunction packUint232(PackedValue self, uint232 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint232(PackedValue self, uint8 position) pure returns (uint232) {\n    return\n        uint232((PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n}\n\nfunction packUint240(PackedValue self, uint240 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint240(PackedValue self, uint8 position) pure returns (uint240) {\n    return\n        uint240(\n            (PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n        );\n}\n\nfunction packUint248(PackedValue self, uint248 value, uint8 position) pure returns (PackedValue) {\n    return PackedValue.wrap(PackedValue.unwrap(self) | (uint256(value) << position));\n}\n\nfunction unpackUint248(PackedValue self, uint8 position) pure returns (uint248) {\n    return\n        uint248(\n            (PackedValue.unwrap(self) >> position) & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n        );\n}\n\nfunction packBool(PackedValue self, bool value, uint8 position) pure returns (PackedValue) {\n    return packUint8(self, value ? 1 : 0, position);\n}\n\nfunction unpackBool(PackedValue self, uint8 position) pure returns (bool) {\n    return ((PackedValue.unwrap(self) >> position) & 0x1) == 1;\n}\n\nfunction packAddress(PackedValue self, address value, uint8 position) pure returns (PackedValue) {\n    return packUint160(self, uint160(value), position);\n}\n\nfunction unpackAddress(PackedValue self, uint8 position) pure returns (address) {\n    return address(unpackUint160(self, position));\n}\n"}, "contracts/types/Side.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\nSide constant LONG = Side.wrap(1);\nSide constant SHORT = Side.wrap(2);\n\ntype Side is uint8;\n\nerror InvalidSide(Side side);\n\nusing {requireValid, isLong, isShort, flip, eq as ==} for Side global;\n\nfunction requireValid(Side self) pure {\n    if (!isLong(self) && !isShort(self)) revert InvalidSide(self);\n}\n\nfunction isLong(Side self) pure returns (bool) {\n    return Side.unwrap(self) == Side.unwrap(LONG);\n}\n\nfunction isShort(Side self) pure returns (bool) {\n    return Side.unwrap(self) == Side.unwrap(SHORT);\n}\n\nfunction eq(Side self, Side other) pure returns (bool) {\n    return Side.unwrap(self) == Side.unwrap(other);\n}\n\nfunction flip(Side self) pure returns (Side) {\n    return isLong(self) ? SHORT : LONG;\n}\n"}, "solady/src/utils/FixedPointMathLib.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error ExpOverflow();\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error FactorialOverflow();\n\n    /// @dev The operation failed, due to an overflow.\n    error RPowOverflow();\n\n    /// @dev The mantissa is too big to fit.\n    error MantissaOverflow();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error MulWadFailed();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error SMulWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error DivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error SDivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error MulDivFailed();\n\n    /// @dev The division failed, as the denominator is zero.\n    error DivFailed();\n\n    /// @dev The full precision multiply-divide operation failed, either due\n    /// to the result being larger than 256 bits, or a division by a zero.\n    error FullMulDivFailed();\n\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\n    error LnWadUndefined();\n\n    /// @dev The input outside the acceptable domain.\n    error OutOfDomain();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         CONSTANTS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The scalar of ETH and most ERC20s.\n    uint256 internal constant WAD = 1e18;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if mul(y, gt(x, div(not(0), y))) {\n                mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function sMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require((x == 0 || z / x == y) && !(x == -1 && y == type(int256).min))`.\n            if iszero(gt(or(iszero(x), eq(sdiv(z, x), y)), lt(not(x), eq(y, shl(255, 1))))) {\n                mstore(0x00, 0xedcd4dd4) // `SMulWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawMulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawSMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if mul(y, gt(x, div(not(0), y))) {\n                mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up, but without overflow checks.\n    function rawMulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function sDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, WAD)\n            // Equivalent to `require(y != 0 && ((x * WAD) / WAD == x))`.\n            if iszero(and(iszero(iszero(y)), eq(sdiv(z, WAD), x))) {\n                mstore(0x00, 0x5c43740d) // `SDivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawDivWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawSDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up, but without overflow and divide by zero checks.\n    function rawDivWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `x` to the power of `y`.\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\n    /// Note: This function is an approximation.\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Using `ln(x)` means `x` must be greater than 0.\n        return expWad((lnWad(x) * y) / int256(WAD));\n    }\n\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2\u03c0.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is less than 0.5 we return zero.\n            // This happens when `x <= (log(1e-18) * 1e18) ~ -4.15e19`.\n            if (x <= -41446531673892822313) return r;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // When the result is greater than `(2**255 - 1) / 1e18` we can not represent it as\n                // an int. This happens when `x >= floor(log((2**255 - 1) / 1e18) * 1e18) \u2248 135`.\n                if iszero(slt(x, 135305999368893231589)) {\n                    mstore(0x00, 0xa37bfec9) // `ExpOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            // `x` is now in the range `(-42, 136) * 1e18`. Convert to `(-42, 136) * 2**96`\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5 ** 18;\n\n            // Reduce range of x to (-\u00bd ln 2, \u00bd ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // `k` is in the range `[-61, 195]`.\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // `p` is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already `2**96` too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range `(0.09, 0.25) * 2**96`.\n\n            // We now need to multiply r by:\n            // - The scale factor `s \u2248 6.031367120`.\n            // - The `2**k` factor from the range reduction.\n            // - The `1e18 / 2**96` factor for base conversion.\n            // We do this all at once, with an intermediate result in `2**213`\n            // basis, so the final right shift is always by a positive amount.\n            r = int256(\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\n            );\n        }\n    }\n\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2\u03c0.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We want to convert `x` from `10**18` fixed point to `2**96` fixed point.\n            // We do this by multiplying by `2**96 / 10**18`. But since\n            // `ln(x * C) = ln(x) + ln(C)`, we can simply do nothing here\n            // and add `ln(2**96 / 10**18)` at the end.\n\n            // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // We place the check here for more optimal stack operations.\n            if iszero(sgt(x, 0)) {\n                mstore(0x00, 0x1615e638) // `LnWadUndefined()`.\n                revert(0x1c, 0x04)\n            }\n            // forgefmt: disable-next-item\n            r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            x := shr(159, shl(r, x))\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // `p` is made monic, we will multiply by a scale factor later.\n            // forgefmt: disable-next-item\n            let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.\n                sar(96, mul(add(43456485725739037958740375743393,\n                sar(96, mul(add(24828157081833163892658089445524,\n                sar(96, mul(add(3273285459638523848632254066296,\n                    x), x))), x))), x)), 11111509109440967052023855526967)\n            p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)\n            p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)\n            p := sub(mul(p, x), shl(96, 795164235651350426258249787498))\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n\n            // `q` is monic by convention.\n            let q := add(5573035233440673466300451813936, x)\n            q := add(71694874799317883764090561454958, sar(96, mul(x, q)))\n            q := add(283447036172924575727196451306956, sar(96, mul(x, q)))\n            q := add(401686690394027663651624208769553, sar(96, mul(x, q)))\n            q := add(204048457590392012362485061816622, sar(96, mul(x, q)))\n            q := add(31853899698501571402653359427138, sar(96, mul(x, q)))\n            q := add(909429971244387300277376558375, sar(96, mul(x, q)))\n\n            // `p / q` is in the range `(0, 0.125) * 2**96`.\n\n            // Finalization, we need to:\n            // - Multiply by the scale factor `s = 5.549\u2026`.\n            // - Add `ln(2**96 / 10**18)`.\n            // - Add `k * ln(2)`.\n            // - Multiply by `10**18 / 2**96 = 5**18 >> 78`.\n\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already `2**96` too large.\n            p := sdiv(p, q)\n            // Multiply by the scaling factor: `s * 5**18 * 2**96`, base is now `5**18 * 2**192`.\n            p := mul(1677202110996718588342820967067443963516166, p)\n            // Add `ln(2) * k * 5**18 * 2**192`.\n            // forgefmt: disable-next-item\n            p := add(mul(16597577552685614221487285958193947469193820559219878177908093499208371, sub(159, r)), p)\n            // Add `ln(2**96 / 10**18) * 5**18 * 2**192`.\n            p := add(600920179829731861736702779321621459595472258049074101567377883020018308, p)\n            // Base conversion: mul `2**18 / 2**192`.\n            r := sar(174, p)\n        }\n    }\n\n    /// @dev Returns `W_0(x)`, denominated in `WAD`.\n    /// See: https://en.wikipedia.org/wiki/Lambert_W_function\n    /// a.k.a. Product log function. This is an approximation of the principal branch.\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lambertW0Wad(int256 x) internal pure returns (int256 w) {\n        // forgefmt: disable-next-item\n        unchecked {\n            if ((w = x) <= -367879441171442322) revert OutOfDomain(); // `x` less than `-1/e`.\n            int256 wad = int256(WAD);\n            int256 p = x;\n            uint256 c; // Whether we need to avoid catastrophic cancellation.\n            uint256 i = 4; // Number of iterations.\n            if (w <= 0x1ffffffffffff) {\n                if (-0x4000000000000 <= w) {\n                    i = 1; // Inputs near zero only take one step to converge.\n                } else if (w <= -0x3ffffffffffffff) {\n                    i = 32; // Inputs near `-1/e` take very long to converge.\n                }\n            } else if (uint256(w >> 63) == uint256(0)) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // Inline log2 for more performance, since the range is small.\n                    let v := shr(49, w)\n                    let l := shl(3, lt(0xff, v))\n                    l := add(or(l, byte(and(0x1f, shr(shr(l, v), 0x8421084210842108cc6318c6db6d54be)),\n                        0x0706060506020504060203020504030106050205030304010505030400000000)), 49)\n                    w := sdiv(shl(l, 7), byte(sub(l, 31), 0x0303030303030303040506080c13))\n                    c := gt(l, 60)\n                    i := add(2, add(gt(l, 53), c))\n                }\n            } else {\n                int256 ll = lnWad(w = lnWad(w));\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // `w = ln(x) - ln(ln(x)) + b * ln(ln(x)) / ln(x)`.\n                    w := add(sdiv(mul(ll, 1023715080943847266), w), sub(w, ll))\n                    i := add(3, iszero(shr(68, x)))\n                    c := iszero(shr(143, x))\n                }\n                if (c == uint256(0)) {\n                    do { // If `x` is big, use Newton's so that intermediate values won't overflow.\n                        int256 e = expWad(w);\n                        /// @solidity memory-safe-assembly\n                        assembly {\n                            let t := mul(w, div(e, wad))\n                            w := sub(w, sdiv(sub(t, x), div(add(e, t), wad)))\n                        }\n                        if (p <= w) break;\n                        p = w;\n                    } while (--i != uint256(0));\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        w := sub(w, sgt(w, 2))\n                    }\n                    return w;\n                }\n            }\n            do { // Otherwise, use Halley's for faster convergence.\n                int256 e = expWad(w);\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let t := add(w, wad)\n                    let s := sub(mul(w, e), mul(x, wad))\n                    w := sub(w, sdiv(mul(s, wad), sub(mul(e, t), sdiv(mul(add(t, wad), s), add(t, t)))))\n                }\n                if (p <= w) break;\n                p = w;\n            } while (--i != c);\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sub(w, sgt(w, 2))\n            }\n            // For certain ranges of `x`, we'll use the quadratic-rate recursive formula of\n            // R. Iacono and J.P. Boyd for the last iteration, to avoid catastrophic cancellation.\n            if (c == uint256(0)) return w;\n            int256 t = w | 1;\n            /// @solidity memory-safe-assembly\n            assembly {\n                x := sdiv(mul(x, wad), t)\n            }\n            x = (t * (wad + lnWad(x)));\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sdiv(x, add(wad, t))\n            }\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                  GENERAL NUMBER UTILITIES                  */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Remco Bloemen under MIT license: https://2\u03c0.com/21/muldiv\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // 512-bit multiply `[p1 p0] = x * y`.\n            // Compute the product mod `2**256` and mod `2**256 - 1`\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that `product = p1 * 2**256 + p0`.\n\n            // Temporarily use `result` as `p0` to save gas.\n            result := mul(x, y) // Lower 256 bits of `x * y`.\n            for {} 1 {} {\n                // If overflows.\n                if iszero(mul(or(iszero(x), eq(div(result, x), y)), d)) {\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(result, lt(mm, result))) // Upper 256 bits of `x * y`.\n\n                    /*------------------- 512 by 256 division --------------------*/\n\n                    // Make division exact by subtracting the remainder from `[p1 p0]`.\n                    let r := mulmod(x, y, d) // Compute remainder using mulmod.\n                    let t := and(d, sub(0, d)) // The least significant bit of `d`. `t >= 1`.\n                    // Make sure the result is less than `2**256`. Also prevents `d == 0`.\n                    // Placing the check here seems to give more optimal stack operations.\n                    if iszero(gt(d, p1)) {\n                        mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    d := div(d, t) // Divide `d` by `t`, which is a power of two.\n                    // Invert `d mod 2**256`\n                    // Now that `d` is an odd number, it has an inverse\n                    // modulo `2**256` such that `d * inv = 1 mod 2**256`.\n                    // Compute the inverse by starting with a seed that is correct\n                    // correct for four bits. That is, `d * inv = 1 mod 2**4`.\n                    let inv := xor(2, mul(3, d))\n                    // Now use Newton-Raphson iteration to improve the precision.\n                    // Thanks to Hensel's lifting lemma, this also works in modular\n                    // arithmetic, doubling the correct bits in each step.\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\n                    result :=\n                        mul(\n                            // Divide [p1 p0] by the factors of two.\n                            // Shift in bits from `p1` into `p0`. For this we need\n                            // to flip `t` such that it is `2**256 / t`.\n                            or(\n                                mul(sub(p1, gt(r, result)), add(div(sub(0, t), t), 1)),\n                                div(sub(result, r), t)\n                            ),\n                            mul(sub(2, mul(d, inv)), inv) // inverse mod 2**256\n                        )\n                    break\n                }\n                result := div(result, d)\n                break\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Behavior is undefined if `d` is zero or the final result cannot fit in 256 bits.\n    /// Performs the full 512 bit calculation regardless.\n    function fullMulDivUnchecked(uint256 x, uint256 y, uint256 d)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mul(x, y)\n            let mm := mulmod(x, y, not(0))\n            let p1 := sub(mm, add(result, lt(mm, result)))\n            let t := and(d, sub(0, d))\n            let r := mulmod(x, y, d)\n            d := div(d, t)\n            let inv := xor(2, mul(3, d))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            result :=\n                mul(\n                    or(mul(sub(p1, gt(r, result)), add(div(sub(0, t), t), 1)), div(sub(result, r), t)),\n                    mul(sub(2, mul(d, inv)), inv)\n                )\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Uniswap-v3-core under MIT license:\n    /// https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/FullMath.sol\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\n        result = fullMulDiv(x, y, d);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mulmod(x, y, d) {\n                result := add(result, 1)\n                if iszero(result) {\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Returns `floor(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(z, d)\n        }\n    }\n\n    /// @dev Returns `ceil(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(z, d))), div(z, d))\n        }\n    }\n\n    /// @dev Returns `ceil(x / d)`.\n    /// Reverts if `d` is zero.\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(d) {\n                mstore(0x00, 0x65244e4e) // `DivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\n        }\n    }\n\n    /// @dev Returns `max(0, x - y)`.\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, uint256 x, uint256 y) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Exponentiate `x` to `y` by squaring, denominated in base `b`.\n    /// Reverts if the computation overflows.\n    function rpow(uint256 x, uint256 y, uint256 b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(b, iszero(y)) // `0 ** 0 = 1`. Otherwise, `0 ** n = 0`.\n            if x {\n                z := xor(b, mul(xor(b, x), and(y, 1))) // `z = isEven(y) ? scale : x`\n                let half := shr(1, b) // Divide `b` by 2.\n                // Divide `y` by 2 every iteration.\n                for { y := shr(1, y) } y { y := shr(1, y) } {\n                    let xx := mul(x, x) // Store x squared.\n                    let xxRound := add(xx, half) // Round to the nearest number.\n                    // Revert if `xx + half` overflowed, or if `x ** 2` overflows.\n                    if or(lt(xxRound, xx), shr(128, x)) {\n                        mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                        revert(0x1c, 0x04)\n                    }\n                    x := div(xxRound, b) // Set `x` to scaled `xxRound`.\n                    // If `y` is odd:\n                    if and(y, 1) {\n                        let zx := mul(z, x) // Compute `z * x`.\n                        let zxRound := add(zx, half) // Round to the nearest number.\n                        // If `z * x` overflowed or `zx + half` overflowed:\n                        if or(xor(div(zx, x), z), lt(zxRound, zx)) {\n                            // Revert if `x` is non-zero.\n                            if x {\n                                mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                                revert(0x1c, 0x04)\n                            }\n                        }\n                        z := div(zxRound, b) // Return properly scaled `zxRound`.\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns the square root of `x`, rounded down.\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // Let `y = x / 2**r`. We check `y >= 2**(k + 8)`\n            // but shift right by `k` bits to ensure that if `x >= 256`, then `y >= 256`.\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\n            z := shl(shr(1, r), z)\n\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\n\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\n\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\n\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\n            // Then we can estimate `sqrt(y)` using\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\n\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If `x+1` is a perfect square, the Babylonian method cycles between\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, rounded down.\n    /// Credit to bout3fiddy and pcaversaccio under AGPLv3 license:\n    /// https://github.com/pcaversaccio/snekmate/blob/main/src/utils/Math.vy\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // Makeshift lookup table to nudge the approximate log2 result.\n            z := div(shl(div(r, 3), shl(lt(0xf, shr(r, x)), 0xf)), xor(7, mod(r, 3)))\n            // Newton-Raphson's.\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            // Round down.\n            z := sub(z, lt(div(x, mul(z, z)), z))\n        }\n    }\n\n    /// @dev Returns the square root of `x`, denominated in `WAD`, rounded down.\n    function sqrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 18) return sqrt(x * 10 ** 18);\n            z = (1 + sqrt(x)) * 10 ** 9;\n            z = (fullMulDivUnchecked(x, 10 ** 18, z) + z) >> 1;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sub(z, gt(999999999999999999, sub(mulmod(z, z, x), 1))) // Round down.\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, denominated in `WAD`, rounded down.\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 36) return cbrt(x * 10 ** 36);\n            z = (1 + cbrt(x)) * 10 ** 12;\n            z = (fullMulDivUnchecked(x, 10 ** 36, z * z) + z + z) / 3;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let p := x\n            for {} 1 {} {\n                if iszero(shr(229, p)) {\n                    if iszero(shr(199, p)) {\n                        p := mul(p, 100000000000000000) // 10 ** 17.\n                        break\n                    }\n                    p := mul(p, 100000000) // 10 ** 8.\n                    break\n                }\n                if iszero(shr(249, p)) { p := mul(p, 100) }\n                break\n            }\n            let t := mulmod(mul(z, z), z, p)\n            z := sub(z, gt(lt(t, shr(1, p)), iszero(t))) // Round down.\n        }\n    }\n\n    /// @dev Returns the factorial of `x`.\n    function factorial(uint256 x) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if iszero(lt(x, 58)) {\n                mstore(0x00, 0xaba0f2a2) // `FactorialOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            for {} x { x := sub(x, 1) } { result := mul(result, x) }\n        }\n    }\n\n    /// @dev Returns the log2 of `x`.\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\n    /// Returns 0 if `x` is zero.\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020504060203020504030106050205030304010505030400000000))\n        }\n    }\n\n    /// @dev Returns the log2 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\n        r = log2(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(r, 1), x))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log10(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, 100000000000000000000000000000000000000)) {\n                x := div(x, 100000000000000000000000000000000000000)\n                r := 38\n            }\n            if iszero(lt(x, 100000000000000000000)) {\n                x := div(x, 100000000000000000000)\n                r := add(r, 20)\n            }\n            if iszero(lt(x, 10000000000)) {\n                x := div(x, 10000000000)\n                r := add(r, 10)\n            }\n            if iszero(lt(x, 100000)) {\n                x := div(x, 100000)\n                r := add(r, 5)\n            }\n            r := add(r, add(gt(x, 9), add(gt(x, 99), add(gt(x, 999), gt(x, 9999)))))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log10Up(uint256 x) internal pure returns (uint256 r) {\n        r = log10(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(exp(10, r), x))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(shr(3, r), lt(0xff, shr(r, x)))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log256Up(uint256 x) internal pure returns (uint256 r) {\n        r = log256(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(shl(3, r), 1), x))\n        }\n    }\n\n    /// @dev Returns the scientific notation format `mantissa * 10 ** exponent` of `x`.\n    /// Useful for compressing prices (e.g. using 25 bit mantissa and 7 bit exponent).\n    function sci(uint256 x) internal pure returns (uint256 mantissa, uint256 exponent) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mantissa := x\n            if mantissa {\n                if iszero(mod(mantissa, 1000000000000000000000000000000000)) {\n                    mantissa := div(mantissa, 1000000000000000000000000000000000)\n                    exponent := 33\n                }\n                if iszero(mod(mantissa, 10000000000000000000)) {\n                    mantissa := div(mantissa, 10000000000000000000)\n                    exponent := add(exponent, 19)\n                }\n                if iszero(mod(mantissa, 1000000000000)) {\n                    mantissa := div(mantissa, 1000000000000)\n                    exponent := add(exponent, 12)\n                }\n                if iszero(mod(mantissa, 1000000)) {\n                    mantissa := div(mantissa, 1000000)\n                    exponent := add(exponent, 6)\n                }\n                if iszero(mod(mantissa, 10000)) {\n                    mantissa := div(mantissa, 10000)\n                    exponent := add(exponent, 4)\n                }\n                if iszero(mod(mantissa, 100)) {\n                    mantissa := div(mantissa, 100)\n                    exponent := add(exponent, 2)\n                }\n                if iszero(mod(mantissa, 10)) {\n                    mantissa := div(mantissa, 10)\n                    exponent := add(exponent, 1)\n                }\n            }\n        }\n    }\n\n    /// @dev Convenience function for packing `x` into a smaller number using `sci`.\n    /// The `mantissa` will be in bits [7..255] (the upper 249 bits).\n    /// The `exponent` will be in bits [0..6] (the lower 7 bits).\n    /// Use `SafeCastLib` to safely ensure that the `packed` number is small\n    /// enough to fit in the desired unsigned integer type:\n    /// ```\n    ///     uint32 packed = SafeCastLib.toUint32(FixedPointMathLib.packSci(777 ether));\n    /// ```\n    function packSci(uint256 x) internal pure returns (uint256 packed) {\n        (x, packed) = sci(x); // Reuse for `mantissa` and `exponent`.\n        /// @solidity memory-safe-assembly\n        assembly {\n            if shr(249, x) {\n                mstore(0x00, 0xce30380c) // `MantissaOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            packed := or(shl(7, x), packed)\n        }\n    }\n\n    /// @dev Convenience function for unpacking a packed number from `packSci`.\n    function unpackSci(uint256 packed) internal pure returns (uint256 unpacked) {\n        unchecked {\n            unpacked = (packed >> 7) * 10 ** (packed & 0x7f);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards zero.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = (x & y) + ((x ^ y) >> 1);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards negative infinity.\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @dev Returns the absolute value of `x`.\n    function abs(int256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(sar(255, x), add(sar(255, x), x))\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(mul(xor(sub(y, x), sub(x, y)), gt(x, y)), sub(y, x))\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(mul(xor(sub(y, x), sub(x, y)), sgt(x, y)), sub(y, x))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), lt(y, x)))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), slt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), gt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), gt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), lt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), sgt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), slt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns greatest common divisor of `x` and `y`.\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { z := x } y {} {\n                let t := y\n                y := mod(z, y)\n                z := t\n            }\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`,\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(uint256 a, uint256 b, uint256 t, uint256 begin, uint256 end)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (begin > end) {\n            t = ~t;\n            begin = ~begin;\n            end = ~end;\n        }\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        unchecked {\n            if (b >= a) return a + fullMulDiv(b - a, t - begin, end - begin);\n            return a - fullMulDiv(a - b, t - begin, end - begin);\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`.\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(int256 a, int256 b, int256 t, int256 begin, int256 end)\n        internal\n        pure\n        returns (int256)\n    {\n        if (begin > end) {\n            t = int256(~uint256(t));\n            begin = int256(~uint256(begin));\n            end = int256(~uint256(end));\n        }\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        // forgefmt: disable-next-item\n        unchecked {\n            if (b >= a) return int256(uint256(a) + fullMulDiv(uint256(b) - uint256(a),\n                uint256(t) - uint256(begin), uint256(end) - uint256(begin)));\n            return int256(uint256(a) - fullMulDiv(uint256(a) - uint256(b),\n                uint256(t) - uint256(begin), uint256(end) - uint256(begin)));\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                   RAW NUMBER OPERATIONS                    */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(x, y)\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mod(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := smod(x, y)\n        }\n    }\n\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := addmod(x, y, d)\n        }\n    }\n\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mulmod(x, y, d)\n        }\n    }\n}\n"}}, "settings": {"evmVersion": "cancun", "viaIR": false, "optimizer": {"enabled": true}, "metadata": {"useLiteralContent": false, "bytecodeHash": "none", "appendCBOR": true}, "outputSelection": {"*": {"*": ["evm.legacyAssembly"]}}, "libraries": {"contracts/libraries/LiquidityReader.sol": {"LiquidityReader": "0x4adfef995a35592841ff095c778f00b47500aa42"}, "contracts/libraries/PUSDManagerUtil.sol": {"PUSDManagerUtil": "0xcff371e7e8f03ba98be27694a7346f647fda64db"}, "contracts/libraries/PositionReader.sol": {"PositionReader": "0x9093f95184b4d2d0fd39bb40450cfa1c0b22ad99"}}}}