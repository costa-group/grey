{"language": "Solidity", "sources": {"@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"}, "@openzeppelin/contracts/utils/Strings.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"}, "src/bridge/IBridge.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.30;\n\nimport \"./IOwnable.sol\";\n\ninterface IBridge {\n    /// @dev This is an instruction to offchain readers to inform them where to look\n    ///      for sequencer inbox batch data. This is not the type of data (eg. das, brotli encoded, or blob versioned hash)\n    ///      and this enum is not used in the state transition function, rather it informs an offchain\n    ///      reader where to find the data so that they can supply it to the replay binary\n    enum BatchDataLocation {\n        /// @notice The data can be found in the transaction call data\n        TxInput,\n        /// @notice The data can be found in an event emitted during the transaction\n        SeparateBatchEvent,\n        /// @notice This batch contains no data\n        NoData,\n        /// @notice The data can be found in the 4844 data blobs on this transaction\n        Blob\n    }\n\n    struct TimeBounds {\n        uint64 minTimestamp;\n        uint64 maxTimestamp;\n        uint64 minBlockNumber;\n        uint64 maxBlockNumber;\n    }\n\n    event MessageDelivered(\n        uint256 indexed messageIndex,\n        bytes32 indexed beforeInboxAcc,\n        address inbox,\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash,\n        uint256 baseFeeL1,\n        uint64 timestamp\n    );\n\n    event DepositMessageDelivered(address indexed sender);\n\n    event BridgeCallTriggered(\n        address indexed outbox,\n        address indexed to,\n        uint256 value,\n        bytes data\n    );\n\n    event InboxToggle(address indexed inbox, bool enabled);\n\n    event OutboxToggle(address indexed outbox, bool enabled);\n\n    event SequencerInboxUpdated(address newSequencerInbox);\n\n    event RollupUpdated(address rollup);\n\n    function allowedDelayedInboxList(uint256) external returns (address);\n\n    function allowedOutboxList(uint256) external returns (address);\n\n    /// @dev Accumulator for delayed inbox messages; tail represents hash of the current state; each element represents the inclusion of a new message.\n    function delayedInboxAccs(uint256) external view returns (bytes32);\n\n    /// @dev Accumulator for sequencer inbox messages; tail represents hash of the current state; each element represents the inclusion of a new message.\n    function sequencerInboxAccs(uint256) external view returns (bytes32);\n\n    function rollup() external view returns (IOwnable);\n\n    function sequencerInbox() external view returns (address);\n\n    function activeOutbox() external view returns (address);\n\n    function allowedDelayedInboxes(address inbox) external view returns (bool);\n\n    function allowedOutboxes(address outbox) external view returns (bool);\n\n    function sequencerReportedSubMessageCount() external view returns (uint256);\n\n    function executeCall(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bool success, bytes memory returnData);\n\n    function delayedMessageCount() external view returns (uint256);\n\n    function sequencerMessageCount() external view returns (uint256);\n\n    // ---------- onlySequencerInbox functions ----------\n\n    function enqueueSequencerMessage(\n        bytes32 dataHash,\n        uint256 afterDelayedMessagesRead,\n        uint256 prevMessageCount,\n        uint256 newMessageCount\n    )\n        external\n        returns (\n            uint256 seqMessageIndex,\n            bytes32 beforeAcc,\n            bytes32 delayedAcc,\n            bytes32 acc\n        );\n\n    /**\n     * @dev Allows the sequencer inbox to submit a delayed message of the batchPostingReport type\n     *      This is done through a separate function entrypoint instead of allowing the sequencer inbox\n     *      to call `enqueueDelayedMessage` to avoid the gas overhead of an extra SLOAD in either\n     *      every delayed inbox or every sequencer inbox call.\n     */\n    function submitBatchSpendingReport(address batchPoster, bytes32 dataHash)\n        external\n        returns (uint256 msgNum);\n\n    // ---------- onlyRollupOrOwner functions ----------\n\n    function setSequencerInbox(address _sequencerInbox) external;\n\n    function setDelayedInbox(address inbox, bool enabled) external;\n\n    function setOutbox(address inbox, bool enabled) external;\n\n    function updateRollupAddress(IOwnable _rollup) external;\n}\n"}, "src/bridge/IDelayedMessageProvider.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.30;\n\ninterface IDelayedMessageProvider {\n    /// @dev event emitted when a inbox message is added to the Bridge's delayed accumulator\n    event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\n\n    /// @dev event emitted when a inbox message is added to the Bridge's delayed accumulator\n    /// same as InboxMessageDelivered but the batch data is available in tx.input\n    event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\n}\n"}, "src/bridge/IOwnable.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.30;\n\ninterface IOwnable {\n    function owner() external view returns (address);\n}\n"}, "src/bridge/ISequencerInbox.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.30;\npragma experimental ABIEncoderV2;\n\nimport \"../libraries/IGasRefunder.sol\";\nimport \"./IDelayedMessageProvider.sol\";\nimport \"./IBridge.sol\";\n\ninterface ISequencerInbox is IDelayedMessageProvider {\n    struct MaxTimeVariation {\n        uint256 delayBlocks;\n        uint256 futureBlocks;\n        uint256 delaySeconds;\n        uint256 futureSeconds;\n    }\n\n    event SequencerBatchDelivered(\n        uint256 indexed batchSequenceNumber,\n        bytes32 indexed beforeAcc,\n        bytes32 indexed afterAcc,\n        bytes32 delayedAcc,\n        uint256 afterDelayedMessagesRead,\n        IBridge.TimeBounds timeBounds,\n        IBridge.BatchDataLocation dataLocation\n    );\n\n    event OwnerFunctionCalled(uint256 indexed id);\n\n    /// @dev a separate event that emits batch data when this isn't easily accessible in the tx.input\n    event SequencerBatchData(uint256 indexed batchSequenceNumber, bytes data);\n\n    /// @dev a valid keyset was added\n    event SetValidKeyset(bytes32 indexed keysetHash, bytes keysetBytes);\n\n    /// @dev a keyset was invalidated\n    event InvalidateKeyset(bytes32 indexed keysetHash);\n\n    function totalDelayedMessagesRead() external view returns (uint256);\n\n    function bridge() external view returns (IBridge);\n\n    /// @dev The size of the batch header\n    // solhint-disable-next-line func-name-mixedcase\n    function HEADER_LENGTH() external view returns (uint256);\n\n    /// @dev If the first batch data byte after the header has this bit set,\n    ///      the sequencer inbox has authenticated the data. Currently only used for 4844 blob support.\n    ///      See: https://github.com/OffchainLabs/nitro/blob/69de0603abf6f900a4128cab7933df60cad54ded/arbstate/das_reader.go\n    // solhint-disable-next-line func-name-mixedcase\n    function DATA_AUTHENTICATED_FLAG() external view returns (bytes1);\n\n    /// @dev If the first data byte after the header has this bit set,\n    ///      then the batch data is to be found in 4844 data blobs\n    ///      See: https://github.com/OffchainLabs/nitro/blob/69de0603abf6f900a4128cab7933df60cad54ded/arbstate/das_reader.go\n    // solhint-disable-next-line func-name-mixedcase\n    function DATA_BLOB_HEADER_FLAG() external view returns (bytes1);\n\n    /// @dev If the first data byte after the header has this bit set,\n    ///      then the batch data is a das message\n    ///      See: https://github.com/OffchainLabs/nitro/blob/69de0603abf6f900a4128cab7933df60cad54ded/arbstate/das_reader.go\n    // solhint-disable-next-line func-name-mixedcase\n    function DAS_MESSAGE_HEADER_FLAG() external view returns (bytes1);\n\n    /// @dev If the first data byte after the header has this bit set,\n    ///      then the batch data is a celestia message\n    ///      See: https://github.com/celestiaorg/nitro/blob/blobstream-v2.2.2/arbstate/das_reader.go\n    // solhint-disable-next-line func-name-mixedcase\n    function CELESTIA_MESSAGE_HEADER_FLAG() external view returns (bytes1);\n\n    /// @dev If the first data byte after the header has this bit set,\n    ///      then the batch data is a das message that employs a merklesization strategy\n    ///      See: https://github.com/OffchainLabs/nitro/blob/69de0603abf6f900a4128cab7933df60cad54ded/arbstate/das_reader.go\n    // solhint-disable-next-line func-name-mixedcase\n    function TREE_DAS_MESSAGE_HEADER_FLAG() external view returns (bytes1);\n\n    /// @dev If the first data byte after the header has this bit set,\n    ///      then the batch data has been brotli compressed\n    ///      See: https://github.com/OffchainLabs/nitro/blob/69de0603abf6f900a4128cab7933df60cad54ded/arbstate/das_reader.go\n    // solhint-disable-next-line func-name-mixedcase\n    function BROTLI_MESSAGE_HEADER_FLAG() external view returns (bytes1);\n\n    /// @dev If the first data byte after the header has this bit set,\n    ///      then the batch data uses a zero heavy encoding\n    ///      See: https://github.com/OffchainLabs/nitro/blob/69de0603abf6f900a4128cab7933df60cad54ded/arbstate/das_reader.go\n    // solhint-disable-next-line func-name-mixedcase\n    function ZERO_HEAVY_MESSAGE_HEADER_FLAG() external view returns (bytes1);\n\n    function rollup() external view returns (IOwnable);\n\n    function isBatchPoster(address) external view returns (bool);\n\n    function isSequencer(address) external view returns (bool);\n\n    function maxDataSize() external view returns (uint256);\n\n    /// @notice The batch poster manager has the ability to change the batch poster addresses\n    ///         This enables the batch poster to do key rotation\n    function batchPosterManager() external view returns (address);\n\n    struct DasKeySetInfo {\n        bool isValidKeyset;\n        uint64 creationBlock;\n    }\n\n    /// @dev returns 4 uint256 to be compatible with older version\n    function maxTimeVariation()\n        external\n        view\n        returns (\n            uint256 delayBlocks,\n            uint256 futureBlocks,\n            uint256 delaySeconds,\n            uint256 futureSeconds\n        );\n\n    function dasKeySetInfo(bytes32) external view returns (bool, uint64);\n\n    /// @notice Remove force inclusion delay after a L1 chainId fork\n    function removeDelayAfterFork() external;\n\n    /// @notice Force messages from the delayed inbox to be included in the chain\n    ///         Callable by any address, but message can only be force-included after maxTimeVariation.delayBlocks and\n    ///         maxTimeVariation.delaySeconds has elapsed. As part of normal behaviour the sequencer will include these\n    ///         messages so it's only necessary to call this if the sequencer is down, or not including any delayed messages.\n    /// @param _totalDelayedMessagesRead The total number of messages to read up to\n    /// @param kind The kind of the last message to be included\n    /// @param l1BlockAndTime The l1 block and the l1 timestamp of the last message to be included\n    /// @param baseFeeL1 The l1 gas price of the last message to be included\n    /// @param sender The sender of the last message to be included\n    /// @param messageDataHash The messageDataHash of the last message to be included\n    function forceInclusion(\n        uint256 _totalDelayedMessagesRead,\n        uint8 kind,\n        uint64[2] calldata l1BlockAndTime,\n        uint256 baseFeeL1,\n        address sender,\n        bytes32 messageDataHash\n    ) external;\n\n    function inboxAccs(uint256 index) external view returns (bytes32);\n\n    function batchCount() external view returns (uint256);\n\n    function isValidKeysetHash(bytes32 ksHash) external view returns (bool);\n\n    /// @notice the creation block is intended to still be available after a keyset is deleted\n    function getKeysetCreationBlock(bytes32 ksHash) external view returns (uint256);\n\n    // ---------- BatchPoster functions ----------\n\n    function addSequencerL2BatchFromOrigin(\n        uint256 sequenceNumber,\n        bytes calldata data,\n        uint256 afterDelayedMessagesRead,\n        IGasRefunder gasRefunder\n    ) external;\n\n    function addSequencerL2BatchFromOrigin(\n        uint256 sequenceNumber,\n        bytes calldata data,\n        uint256 afterDelayedMessagesRead,\n        IGasRefunder gasRefunder,\n        uint256 prevMessageCount,\n        uint256 newMessageCount\n    ) external;\n\n    function addSequencerL2Batch(\n        uint256 sequenceNumber,\n        bytes calldata data,\n        uint256 afterDelayedMessagesRead,\n        IGasRefunder gasRefunder,\n        uint256 prevMessageCount,\n        uint256 newMessageCount\n    ) external;\n\n    function addSequencerL2BatchFromBlobs(\n        uint256 sequenceNumber,\n        uint256 afterDelayedMessagesRead,\n        IGasRefunder gasRefunder,\n        uint256 prevMessageCount,\n        uint256 newMessageCount\n    ) external;\n\n    // ---------- onlyRollupOrOwner functions ----------\n\n    /**\n     * @notice Set max delay for sequencer inbox\n     * @param maxTimeVariation_ the maximum time variation parameters\n     */\n    function setMaxTimeVariation(MaxTimeVariation memory maxTimeVariation_) external;\n\n    /**\n     * @notice Updates whether an address is authorized to be a batch poster at the sequencer inbox\n     * @param addr the address\n     * @param isBatchPoster_ if the specified address should be authorized as a batch poster\n     */\n    function setIsBatchPoster(address addr, bool isBatchPoster_) external;\n\n    /**\n     * @notice Makes Data Availability Service keyset valid\n     * @param keysetBytes bytes of the serialized keyset\n     */\n    function setValidKeyset(bytes calldata keysetBytes) external;\n\n    /**\n     * @notice Invalidates a Data Availability Service keyset\n     * @param ksHash hash of the keyset\n     */\n    function invalidateKeysetHash(bytes32 ksHash) external;\n\n    /**\n     * @notice Updates whether an address is authorized to be a sequencer.\n     * @dev The IsSequencer information is used only off-chain by the nitro node to validate sequencer feed signer.\n     * @param addr the address\n     * @param isSequencer_ if the specified address should be authorized as a sequencer\n     */\n    function setIsSequencer(address addr, bool isSequencer_) external;\n\n    /**\n     * @notice Updates the batch poster manager, the address which has the ability to rotate batch poster keys\n     * @param newBatchPosterManager The new batch poster manager to be set\n     */\n    function setBatchPosterManager(address newBatchPosterManager) external;\n\n    /// @notice Allows the rollup owner to sync the rollup address\n    function updateRollupAddress() external;\n\n    // ---------- initializer ----------\n\n    function initialize(IBridge bridge_, MaxTimeVariation calldata maxTimeVariation_) external;\n}\n"}, "src/bridge/Messages.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nlibrary Messages {\n    function messageHash(\n        uint8 kind,\n        address sender,\n        uint64 blockNumber,\n        uint64 timestamp,\n        uint256 inboxSeqNum,\n        uint256 baseFeeL1,\n        bytes32 messageDataHash\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    kind,\n                    sender,\n                    blockNumber,\n                    timestamp,\n                    inboxSeqNum,\n                    baseFeeL1,\n                    messageDataHash\n                )\n            );\n    }\n\n    function accumulateInboxMessage(bytes32 prevAcc, bytes32 message)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(prevAcc, message));\n    }\n}\n"}, "src/celestia/BlobstreamVerifier.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\nimport {IBlobstreamX} from \"./IBlobstreamX.sol\";\n\nimport \"./DAVerifier.sol\";\nimport \"./lib/Constants.sol\";\nimport \"./lib/DataRootTuple.sol\";\nimport \"./lib/tree/binary/BinaryMerkleProof.sol\";\nimport \"./lib/tree/binary/BinaryMerkleTree.sol\";\nimport \"./lib/tree/namespace/NamespaceMerkleTree.sol\";\nimport \"./lib/tree/Types.sol\";\n\n/**\n * @dev Go struct representation of batch data for a Celestia DA orbit chain\n *\n * @param BlockHeight The height of the block containing the blob.\n * @param Start The starting index of the blob within the block.\n * @param SharesLength The length of the shares in the blob.\n * @param DataRoot A 32-byte hash representing the root of the data.\n * @param TxCommitment A 32-byte hash representing the commitment to transactions.\n */\n// struct BlobPointer {\n//     uint64 BlockHeight;\n//     uint64 Start;\n//     uint64 SharesLength;\n//     bytes32 DataRoot;\n//     bytes32 TxCommitment;\n// }\n\n/// @title CelestiaBatchVerifier: Utility library to verify Nitro batches against Blobstream\n/// @dev The CelestiaBatchVerifier verifies batch data against Blobstream and returns either:\n/// - IN_BLOBSTREAM, meaning that the batch was found in Blobstream.\n/// - COUNTERFACTUAL_COMMITMENT, meaning that the commitment's Celestia block height has been\n/// proven in Blobstream not to contain the commitment\n/// - UNDECIDED meaning that the block height has not been proven yet in Blobstream\n/// If the proof data is invalid, it reverts\nlibrary CelestiaBatchVerifier {\n    /// @dev The heights in the batch data and proof do not match\n    error MismatchedHeights();\n\n    /// @dev The attestation and or row root proof was invalid\n    error InvalidProof();\n\n    /// @title Result\n    /// @notice Enumerates the possible outcomes for data verification processes.\n    /// @dev Provides a standardized way to represent the verification status of data.\n    enum Result {\n        /// @dev Indicates the data has been verified to exist within Blobstream.\n        IN_BLOBSTREAM,\n        /// @dev Represents a situation where the batch data has been proven to be incorrect. Or BlobstreamX was frozen\n        COUNTERFACTUAL_COMMITMENT,\n        /// @dev The height for the batch data has not been committed to by Blobstream yet.\n        UNDECIDED\n    }\n\n    /**\n     * @notice Given some batch data with the structre of `BlobPointer`, verifyBatch validates:\n     * 1. The Celestia Height for the batch data is in blobsream.\n     * 2. The user supplied proof's data root exists in Blobstream.\n     * 2. The the data root from the batch data and the valid user supplied proof match, and the\n     *    span of shares for the batch data is available (i.e the start + length of a blob does not\n     *    go outside the bounds of the origianal celestia data square for the given height)\n     *\n     * Rationale:\n     * Validators possess the preimages for the data root and row roots, making it necessary only to verify\n     * the existence and the length (span) of the index and blob length.\n     * This ensures the data published by the batch poster is available.\n     */\n    function verifyBatch(address _blobstream, bytes calldata _data) internal view returns (Result) {\n        IBlobstreamX blobstreamX = IBlobstreamX(_blobstream);\n\n        uint64 height = uint64(bytes8(_data[0:8]));\n\n        // If the height is to far into the future (1000 blocks), return COUNTERFACTUAL_COMMITMENT\n        // because the batch poster is trying to stall\n        if (height > (blobstreamX.latestBlock() + 1000)) return Result.COUNTERFACTUAL_COMMITMENT;\n\n        // Otherwise return undecided, as the commitment still needs to be relayed to Blobstream\n        if (height > blobstreamX.latestBlock()) return Result.UNDECIDED;\n\n        (\n            ,\n            NamespaceNode memory namespaceNode,\n            BinaryMerkleProof memory proof,\n            AttestationProof memory attestationProof\n        ) = abi.decode(_data[88:], (address, NamespaceNode, BinaryMerkleProof, AttestationProof));\n\n        (\n            bool valid,\n            uint256 proofHeight,\n            bytes32 proofDataRoot,\n            BinaryMerkleProof memory rowProof\n        ) = verifyProof(_blobstream, namespaceNode, proof, attestationProof);\n\n        // revert, because for a given height that has been confirmed to exist in Blobstream,\n        // there has to be a valid proof\n        // if (!valid) revert InvalidProof();\n        if (!valid) revert(\"INVALID_PROOF\");\n        // check height against the one in the batch data, if they do not match,\n        // revert, because the user supplied proof does not verify against\n        // the batch's celestia height.\n        // if (height != proofHeight) revert MismatchedHeights();\n        if (height != proofHeight) revert(\"MismatchedHeights\");\n\n        // check the data root in the proof against the one in the batch data.\n        // if they do not match, its a counterfactual commitment, because\n        // 1. the user supplied proof proves the height was relayed to Blobstream\n        //    (we know the height is valid because it's less than or equal to the latest block)\n        // 2. the data root from the batch data does not exist at the height the batch poster claimed\n        //    to have posted to.\n        // NOTE: a celestia batch has the data root (32 bytes) at index 56\n        if (bytes32(_data[56:88]) != proofDataRoot) return Result.COUNTERFACTUAL_COMMITMENT;\n\n        // Calculate size of the Original Data Square (ODS)\n        (uint256 squareSize, ) = DAVerifier.computeSquareSizeFromRowProof(rowProof);\n\n        if (squareSize == 0) return Result.COUNTERFACTUAL_COMMITMENT;\n        // Check that the start + length posted by the batch poster is not out of bounds\n        // otherwise return counterfactual commitment\n        // NOTE: a celestia batch has the start (8 bytes) and length (8 bytes) at index 8 - 24\n        // we also substract 1 to account for the shares length including the start share\n        // thus letting us correctly calculate the end index\n        if (\n            (uint64(bytes8(_data[8:16])) + uint64(bytes8(_data[16:24])) - 1) >=\n            squareSize * squareSize\n        ) return Result.COUNTERFACTUAL_COMMITMENT;\n\n        // At this point, there has been:\n        // 1. A succesfull proof that shows the height and data root the batch poster included\n        //    in the batch data exist in Blobstream.\n        // 2. A proof that the sequence the batch poster included in the batch data is inside\n        //    of the data square (remember, any valid row root proof can show this is true)\n        // 3. No deadlocks or incorrect counter factual commitments have been made, since:\n        //    - If the height in the batch is less than the latest height in blobstrea,\n        //      a valid attestation + row proof must exist for it\n        //    - we have shown that the batch poster did not lie about the data root and height,\n        //      nor about the span being in the bounds of the square. Thus, validators have\n        //      access to the data through the preimage oracle\n        return Result.IN_BLOBSTREAM;\n    }\n\n    function verifyProof(\n        address _blobstream,\n        NamespaceNode memory _rowRoot,\n        BinaryMerkleProof memory _rowProof,\n        AttestationProof memory _attestationProof\n    )\n        public\n        view\n        returns (\n            bool isValid,\n            uint256 proofHeight,\n            bytes32 proofDataRoot,\n            BinaryMerkleProof memory rowProof\n        )\n    {\n        (bool valid, DAVerifier.ErrorCodes errorCode) = DAVerifier.verifyRowRootToDataRootTupleRoot(\n            IDAOracle(_blobstream),\n            _rowRoot,\n            _rowProof,\n            _attestationProof\n        );\n\n        return (valid, _attestationProof.tuple.height, _attestationProof.tuple.dataRoot, _rowProof);\n    }\n}\n"}, "src/celestia/DAVerifier.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\nimport \"./lib/Constants.sol\";\nimport \"./lib/DataRootTuple.sol\";\nimport \"./lib/IDAOracle.sol\";\nimport \"./lib/tree/binary/BinaryMerkleProof.sol\";\nimport \"./lib/tree/binary/BinaryMerkleTree.sol\";\nimport \"./lib/tree/namespace/NamespaceMerkleTree.sol\";\nimport \"./lib/tree/Types.sol\";\n\n/// @notice Contains the necessary parameters to prove that some shares, which were posted to\n/// the Celestia network, were committed to by the Blobstream smart contract.\nstruct SharesProof {\n    // The shares that were committed to.\n    bytes[] data;\n    // The shares proof to the row roots. If the shares span multiple rows, we will have multiple nmt proofs.\n    NamespaceMerkleMultiproof[] shareProofs;\n    // The namespace of the shares.\n    Namespace namespace;\n    // The rows where the shares belong. If the shares span multiple rows, we will have multiple rows.\n    NamespaceNode[] rowRoots;\n    // The proofs of the rowRoots to the data root.\n    BinaryMerkleProof[] rowProofs;\n    // The proof of the data root tuple to the data root tuple root that was posted to the Blobstream contract.\n    AttestationProof attestationProof;\n}\n\n/// @notice Contains the necessary parameters needed to verify that a data root tuple\n/// was committed to, by the Blobstream smart contract, at some specif nonce.\nstruct AttestationProof {\n    // the attestation nonce that commits to the data root tuple.\n    uint256 tupleRootNonce;\n    // the data root tuple that was committed to.\n    DataRootTuple tuple;\n    // the binary merkle proof of the tuple to the commitment.\n    BinaryMerkleProof proof;\n}\n\n/// @title DAVerifier: Celestia -> EVM, Data Availability verifier.\n/// @dev The DAVerifier verifies that some shares, which were posted on Celestia, were committed to\n/// by the Blobstream smart contract.\nlibrary DAVerifier {\n    /////////////////\n    // Error codes //\n    /////////////////\n\n    enum ErrorCodes {\n        NoError,\n        /// @notice The shares to the rows proof is invalid.\n        InvalidSharesToRowsProof,\n        /// @notice The rows to the data root proof is invalid.\n        InvalidRowsToDataRootProof,\n        /// @notice The row to the data root proof is invalid.\n        InvalidRowToDataRootProof,\n        /// @notice The data root tuple to the data root tuple roof proof is invalid.\n        InvalidDataRootTupleToDataRootTupleRootProof,\n        /// @notice The number of share proofs isn't equal to the number of rows roots.\n        UnequalShareProofsAndRowRootsNumber,\n        /// @notice The number of rows proofs isn't equal to the number of rows roots.\n        UnequalRowProofsAndRowRootsNumber,\n        /// @notice The verifier data length isn't equal to the number of shares in the shares proofs.\n        UnequalDataLengthAndNumberOfSharesProofs,\n        /// @notice The number of leaves in the binary merkle proof is not divisible by 4.\n        InvalidNumberOfLeavesInProof,\n        /// @notice The provided range is invalid.\n        InvalidRange,\n        /// @notice The provided range is out of bounds.\n        OutOfBoundsRange\n    }\n\n    ///////////////\n    // Functions //\n    ///////////////\n\n    /// @notice Verifies that the shares, which were posted to Celestia, were committed to by the Blobstream smart contract.\n    /// @param _bridge The Blobstream smart contract instance.\n    /// @param _sharesProof The proof of the shares to the data root tuple root.\n    /// @return `true` if the proof is valid, `false` otherwise.\n    /// @return an error code if the proof is invalid, ErrorCodes.NoError otherwise.\n    function verifySharesToDataRootTupleRoot(\n        IDAOracle _bridge,\n        SharesProof memory _sharesProof\n    ) internal view returns (bool, ErrorCodes) {\n        // checking that the data root was committed to by the Blobstream smart contract.\n        (bool success, ErrorCodes errorCode) = verifyMultiRowRootsToDataRootTupleRoot(\n            _bridge,\n            _sharesProof.rowRoots,\n            _sharesProof.rowProofs,\n            _sharesProof.attestationProof\n        );\n        if (!success) {\n            return (false, errorCode);\n        }\n\n        (bool valid, ErrorCodes error) = verifySharesToDataRootTupleRootProof(\n            _sharesProof.data,\n            _sharesProof.shareProofs,\n            _sharesProof.namespace,\n            _sharesProof.rowRoots,\n            _sharesProof.rowProofs,\n            _sharesProof.attestationProof.tuple.dataRoot\n        );\n\n        return (valid, error);\n    }\n\n    /// @notice Verifies the shares to data root tuple root proof.\n    /// NOTE: This doesn't authenticate the proof to Blobstream. It only verifies if the proof is valid.\n    /// @param _data The data that needs to proven.\n    /// @param _shareProofs The share to the row roots proof.\n    /// @param _namespace The namespace of the shares.\n    /// @param _rowRoots The row roots where the shares belong.\n    /// @param _rowProofs The proofs of the rowRoots to the data root.\n    /// @param _root The data root of the block that contains the shares.\n    /// @return `true` if the proof is valid, `false` otherwise.\n    /// @return an error code if the proof is invalid, ErrorCodes.NoError otherwise.\n    function verifySharesToDataRootTupleRootProof(\n        bytes[] memory _data,\n        NamespaceMerkleMultiproof[] memory _shareProofs,\n        Namespace memory _namespace,\n        NamespaceNode[] memory _rowRoots,\n        BinaryMerkleProof[] memory _rowProofs,\n        bytes32 _root\n    ) internal pure returns (bool, ErrorCodes) {\n        // verifying the row root to data root tuple root proof.\n        (bool success, ErrorCodes errorCode) = verifyMultiRowRootsToDataRootTupleRootProof(\n            _rowRoots,\n            _rowProofs,\n            _root\n        );\n        if (!success) {\n            return (false, errorCode);\n        }\n\n        // checking that the shares were committed to by the rows roots.\n        if (_shareProofs.length != _rowRoots.length) {\n            return (false, ErrorCodes.UnequalShareProofsAndRowRootsNumber);\n        }\n\n        uint256 numberOfSharesInProofs = 0;\n        for (uint256 i = 0; i < _shareProofs.length; i++) {\n            numberOfSharesInProofs += _shareProofs[i].endKey - _shareProofs[i].beginKey;\n        }\n\n        if (_data.length != numberOfSharesInProofs) {\n            return (false, ErrorCodes.UnequalDataLengthAndNumberOfSharesProofs);\n        }\n\n        uint256 cursor = 0;\n        for (uint256 i = 0; i < _shareProofs.length; i++) {\n            uint256 sharesUsed = _shareProofs[i].endKey - _shareProofs[i].beginKey;\n            (bytes[] memory s, ErrorCodes err) = slice(_data, cursor, cursor + sharesUsed);\n            if (err != ErrorCodes.NoError) {\n                return (false, err);\n            }\n            if (!NamespaceMerkleTree.verifyMulti(_rowRoots[i], _shareProofs[i], _namespace, s)) {\n                return (false, ErrorCodes.InvalidSharesToRowsProof);\n            }\n            cursor += sharesUsed;\n        }\n\n        return (true, ErrorCodes.NoError);\n    }\n\n    /// @notice Verifies that a row/column root, from a Celestia block, was committed to by the Blobstream smart contract.\n    /// @param _bridge The Blobstream smart contract instance.\n    /// @param _rowRoot The row/column root to be proven.\n    /// @param _rowProof The proof of the row/column root to the data root.\n    /// @return `true` if the proof is valid, `false` otherwise.\n    /// @return an error code if the proof is invalid, ErrorCodes.NoError otherwise.\n    function verifyRowRootToDataRootTupleRoot(\n        IDAOracle _bridge,\n        NamespaceNode memory _rowRoot,\n        BinaryMerkleProof memory _rowProof,\n        AttestationProof memory _attestationProof\n    ) internal view returns (bool, ErrorCodes) {\n        // checking that the data root was committed to by the Blobstream smart contract\n        if (\n            !_bridge.verifyAttestation(\n                _attestationProof.tupleRootNonce,\n                _attestationProof.tuple,\n                _attestationProof.proof\n            )\n        ) {\n            return (false, ErrorCodes.InvalidDataRootTupleToDataRootTupleRootProof);\n        }\n\n        (bool valid, ErrorCodes error) = verifyRowRootToDataRootTupleRootProof(\n            _rowRoot,\n            _rowProof,\n            _attestationProof.tuple.dataRoot\n        );\n\n        return (valid, error);\n    }\n\n    /// @notice Verifies that a row/column root proof, from a Celestia block, to the data root tuple root.\n    /// NOTE: This doesn't authenticate the proof to Blobstream. It only verifies if the proof is valid.\n    /// @param _rowRoot The row/column root to be proven.\n    /// @param _rowProof The proof of the row/column root to the data root.\n    /// @param _root The data root of the block that contains the row.\n    /// @return `true` if the proof is valid, `false` otherwise.\n    /// @return an error code if the proof is invalid, ErrorCodes.NoError otherwise.\n    function verifyRowRootToDataRootTupleRootProof(\n        NamespaceNode memory _rowRoot,\n        BinaryMerkleProof memory _rowProof,\n        bytes32 _root\n    ) internal pure returns (bool, ErrorCodes) {\n        bytes memory rowRoot = abi.encodePacked(\n            _rowRoot.min.toBytes(),\n            _rowRoot.max.toBytes(),\n            _rowRoot.digest\n        );\n        (bool valid, ) = BinaryMerkleTree.verify(_root, _rowProof, rowRoot);\n        if (!valid) {\n            return (false, ErrorCodes.InvalidRowToDataRootProof);\n        }\n\n        return (true, ErrorCodes.NoError);\n    }\n\n    /// @notice Verifies that a set of rows/columns, from a Celestia block, were committed to by the Blobstream smart contract.\n    /// @param _bridge The Blobstream smart contract instance.\n    /// @param _rowRoots The set of row/column roots to be proved.\n    /// @param _rowProofs The set of proofs of the _rowRoots in the same order.\n    /// @return `true` if the proof is valid, `false` otherwise.\n    /// @return an error code if the proof is invalid, ErrorCodes.NoError otherwise.\n    function verifyMultiRowRootsToDataRootTupleRoot(\n        IDAOracle _bridge,\n        NamespaceNode[] memory _rowRoots,\n        BinaryMerkleProof[] memory _rowProofs,\n        AttestationProof memory _attestationProof\n    ) internal view returns (bool, ErrorCodes) {\n        // checking that the data root was committed to by the Blobstream smart contract\n        if (\n            !_bridge.verifyAttestation(\n                _attestationProof.tupleRootNonce,\n                _attestationProof.tuple,\n                _attestationProof.proof\n            )\n        ) {\n            return (false, ErrorCodes.InvalidDataRootTupleToDataRootTupleRootProof);\n        }\n\n        // checking that the rows roots commit to the data root.\n        (bool valid, ErrorCodes error) = verifyMultiRowRootsToDataRootTupleRootProof(\n            _rowRoots,\n            _rowProofs,\n            _attestationProof.tuple.dataRoot\n        );\n\n        return (valid, error);\n    }\n\n    /// @notice Verifies the proof a set of rows/columns, from a Celestia block, to their corresponding data root.\n    /// NOTE: This doesn't authenticate the proof to Blobstream. It only verifies if the proof is valid.\n    /// @param _rowRoots The set of row/column roots to be proved.\n    /// @param _rowProofs The set of proofs of the _rowRoots in the same order.\n    /// @param _root The data root of the block that contains the rows.\n    /// @return `true` if the proof is valid, `false` otherwise.\n    /// @return an error code if the proof is invalid, ErrorCodes.NoError otherwise.\n    function verifyMultiRowRootsToDataRootTupleRootProof(\n        NamespaceNode[] memory _rowRoots,\n        BinaryMerkleProof[] memory _rowProofs,\n        bytes32 _root\n    ) internal pure returns (bool, ErrorCodes) {\n        // checking that the rows roots commit to the data root.\n        if (_rowProofs.length != _rowRoots.length) {\n            return (false, ErrorCodes.UnequalRowProofsAndRowRootsNumber);\n        }\n\n        for (uint256 i = 0; i < _rowProofs.length; i++) {\n            bytes memory rowRoot = abi.encodePacked(\n                _rowRoots[i].min.toBytes(),\n                _rowRoots[i].max.toBytes(),\n                _rowRoots[i].digest\n            );\n            (bool valid, ) = BinaryMerkleTree.verify(_root, _rowProofs[i], rowRoot);\n            if (!valid) {\n                return (false, ErrorCodes.InvalidRowsToDataRootProof);\n            }\n        }\n\n        return (true, ErrorCodes.NoError);\n    }\n\n    /// @notice computes the Celestia block square size from a row/column root to data root binary merkle proof.\n    /// Note: the provided proof is not authenticated to the Blobstream smart contract. It is the user's responsibility\n    /// to verify that the proof is valid and was successfully committed to using\n    //  the `DAVerifier.verifyRowRootToDataRootTupleRoot()` method\n    /// Note: the minimum square size is 1. Thus, we don't expect the proof to have number of leaves equal to 0.\n    /// @param _proof The proof of the row/column root to the data root.\n    /// @return The square size of the corresponding block.\n    /// @return an error code if the _proof is invalid, Errors.NoError otherwise.\n    function computeSquareSizeFromRowProof(\n        BinaryMerkleProof memory _proof\n    ) internal pure returns (uint256, ErrorCodes) {\n        if (_proof.numLeaves % 4 != 0) {\n            return (0, ErrorCodes.InvalidNumberOfLeavesInProof);\n        }\n        // we divide the number of leaves of the proof by 4 because the rows/columns tree is constructed\n        // from the extended block row roots and column roots.\n        return (_proof.numLeaves / 4, ErrorCodes.NoError);\n    }\n\n    /// @notice computes the Celestia block square size from a shares to row/column root proof.\n    /// Note: the provided proof is not authenticated to the Blobstream smart contract. It is the user's responsibility\n    /// to verify that the proof is valid and that the shares were successfully committed to using\n    /// the `DAVerifier.verifySharesToDataRootTupleRoot()` method.\n    /// Note: the minimum square size is 1. Thus, we don't expect the proof not to contain any side node.\n    /// @param _proof The proof of the shares to the row/column root.\n    /// @return The square size of the corresponding block.\n    function computeSquareSizeFromShareProof(\n        NamespaceMerkleMultiproof memory _proof\n    ) internal pure returns (uint256) {\n        uint256 extendedSquareRowSize = 2 ** _proof.sideNodes.length;\n        // we divide the extended square row size by 2 because the square size is the\n        // the size of the row of the original square size.\n        return extendedSquareRowSize / 2;\n    }\n\n    /// @notice creates a slice of bytes from the data slice of bytes containing the elements\n    /// that correspond to the provided range.\n    /// It selects a half-open range which includes the begin element, but excludes the end one.\n    /// @param _data The slice that we want to select data from.\n    /// @param _begin The beginning of the range (inclusive).\n    /// @param _end The ending of the range (exclusive).\n    /// @return _ the sliced data.\n    function slice(\n        bytes[] memory _data,\n        uint256 _begin,\n        uint256 _end\n    ) internal pure returns (bytes[] memory, ErrorCodes) {\n        if (_begin > _end) {\n            return (_data, ErrorCodes.InvalidRange);\n        }\n        if (_begin > _data.length || _end > _data.length) {\n            return (_data, ErrorCodes.OutOfBoundsRange);\n        }\n        bytes[] memory out = new bytes[](_end - _begin);\n        for (uint256 i = _begin; i < _end; i++) {\n            out[i - _begin] = _data[i];\n        }\n        return (out, ErrorCodes.NoError);\n    }\n}\n"}, "src/celestia/IBlobstreamX.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"./lib/DataRootTuple.sol\";\nimport \"./lib/tree/binary/BinaryMerkleProof.sol\";\ninterface IBlobstreamX {\n    /// @notice Contract is frozen.\n    error ContractFrozen();\n\n    /// @notice Data commitment stored for the block range [startBlock, endBlock) with proof nonce.\n    /// @param proofNonce The nonce of the proof.\n    /// @param startBlock The start block of the block range.\n    /// @param endBlock The end block of the block range.\n    /// @param dataCommitment The data commitment for the block range.\n    event DataCommitmentStored(\n        uint256 proofNonce,\n        uint64 indexed startBlock,\n        uint64 indexed endBlock,\n        bytes32 indexed dataCommitment\n    );\n\n    /// @dev Latest height published to the BlobstreamX contract.\n    function latestBlock() external view returns (uint64);\n\n    /// @dev Nonce for proof events. Must be incremented sequentially.\n    function state_proofNonce() external view returns (uint256);\n\n    /// @dev Is the BlobstreamX contract forzen or not.\n    function frozen() external view returns (bool);\n\n    /// @dev fetches data commitment from BlobstreamX state.\n    function state_dataCommitments(uint256) external view returns (bytes32);\n\n    /// @notice Verify a Data Availability attestation.\n    /// @param _tupleRootNonce Nonce of the tuple root to prove against.\n    /// @param _tuple Data root tuple to prove inclusion of.\n    /// @param _proof Binary Merkle tree proof that `tuple` is in the root at `_tupleRootNonce`.\n    /// @return `true` is proof is valid, `false` otherwise.\n    function verifyAttestation(\n        uint256 _tupleRootNonce,\n        DataRootTuple memory _tuple,\n        BinaryMerkleProof memory _proof\n    ) external view returns (bool);\n}\n"}, "src/celestia/lib/Constants.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\n/// @dev bytes32 encoding of the string \"checkpoint\"\nbytes32 constant VALIDATOR_SET_HASH_DOMAIN_SEPARATOR = 0x636865636b706f696e7400000000000000000000000000000000000000000000;\n\n/// @dev bytes32 encoding of the string \"transactionBatch\"\nbytes32 constant DATA_ROOT_TUPLE_ROOT_DOMAIN_SEPARATOR = 0x7472616e73616374696f6e426174636800000000000000000000000000000000;\n"}, "src/celestia/lib/DataRootTuple.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\n/// @notice A tuple of data root with metadata. Each data root is associated\n///  with a Celestia block height.\n/// @dev `availableDataRoot` in\n///  https://github.com/celestiaorg/celestia-specs/blob/master/src/specs/data_structures.md#header\nstruct DataRootTuple {\n    // Celestia block height the data root was included in.\n    // Genesis block is height = 0.\n    // First queryable block is height = 1.\n    uint256 height;\n    // Data root.\n    bytes32 dataRoot;\n}\n"}, "src/celestia/lib/IDAOracle.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\nimport \"./DataRootTuple.sol\";\nimport \"./tree/binary/BinaryMerkleProof.sol\";\n\n/// @notice Data Availability Oracle interface.\ninterface IDAOracle {\n    /// @notice Verify a Data Availability attestation.\n    /// @param _tupleRootNonce Nonce of the tuple root to prove against.\n    /// @param _tuple Data root tuple to prove inclusion of.\n    /// @param _proof Binary Merkle tree proof that `tuple` is in the root at `_tupleRootNonce`.\n    /// @return `true` is proof is valid, `false` otherwise.\n    function verifyAttestation(\n        uint256 _tupleRootNonce,\n        DataRootTuple memory _tuple,\n        BinaryMerkleProof memory _proof\n    ) external view returns (bool);\n}\n"}, "src/celestia/lib/tree/binary/BinaryMerkleProof.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\n/// @notice Merkle Tree Proof structure.\nstruct BinaryMerkleProof {\n    // List of side nodes to verify and calculate tree.\n    bytes32[] sideNodes;\n    // The key of the leaf to verify.\n    uint256 key;\n    // The number of leaves in the tree\n    uint256 numLeaves;\n}\n"}, "src/celestia/lib/tree/binary/BinaryMerkleTree.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\nimport \"../Constants.sol\";\nimport \"../Utils.sol\";\nimport \"./TreeHasher.sol\";\nimport \"./BinaryMerkleProof.sol\";\n\n/// @title Binary Merkle Tree.\nlibrary BinaryMerkleTree {\n    /////////////////\n    // Error codes //\n    /////////////////\n\n    enum ErrorCodes {\n        NoError,\n        /// @notice The provided side nodes count is invalid for the proof.\n        InvalidNumberOfSideNodes,\n        /// @notice The provided proof key is not part of the tree.\n        KeyNotInTree,\n        /// @notice Invalid number of leaves in proof.\n        InvalidNumberOfLeavesInProof,\n        /// @notice The proof contains unexpected side nodes.\n        UnexpectedInnerHashes,\n        /// @notice The proof verification expected at least one inner hash.\n        ExpectedAtLeastOneInnerHash\n    }\n\n    ///////////////\n    // Functions //\n    ///////////////\n\n    /// @notice Verify if element exists in Merkle tree, given data, proof, and root.\n    /// @param root The root of the tree in which verify the given leaf.\n    /// @param proof Binary Merkle proof for the leaf.\n    /// @param data The data of the leaf to verify.\n    /// @return `true` is proof is valid, `false` otherwise.\n    /// @dev proof.numLeaves is necessary to determine height of subtree containing the data to prove.\n    function verify(\n        bytes32 root,\n        BinaryMerkleProof memory proof,\n        bytes memory data\n    ) internal pure returns (bool, ErrorCodes) {\n        // Check proof is correct length for the key it is proving\n        if (proof.numLeaves <= 1) {\n            if (proof.sideNodes.length != 0) {\n                return (false, ErrorCodes.InvalidNumberOfSideNodes);\n            }\n        } else if (\n            proof.sideNodes.length !=\n            pathLengthFromKey(proof.key, proof.numLeaves)\n        ) {\n            return (false, ErrorCodes.InvalidNumberOfSideNodes);\n        }\n\n        // Check key is in tree\n        if (proof.key >= proof.numLeaves) {\n            return (false, ErrorCodes.KeyNotInTree);\n        }\n\n        // A sibling at height 1 is created by getting the hash of the data to prove.\n        bytes32 digest = leafDigest(data);\n\n        // Null proof is only valid if numLeaves = 1\n        // If so, just verify hash(data) is root\n        if (proof.sideNodes.length == 0) {\n            if (proof.numLeaves == 1) {\n                return (root == digest, ErrorCodes.NoError);\n            } else {\n                return (false, ErrorCodes.NoError);\n            }\n        }\n\n        (bytes32 computedHash, ErrorCodes error) = computeRootHash(\n            proof.key,\n            proof.numLeaves,\n            digest,\n            proof.sideNodes\n        );\n\n        if (error != ErrorCodes.NoError) {\n            return (false, error);\n        }\n\n        return (computedHash == root, ErrorCodes.NoError);\n    }\n\n    /// @notice Use the leafHash and innerHashes to get the root merkle hash.\n    /// If the length of the innerHashes slice isn't exactly correct, the result is nil.\n    /// Recursive impl.\n    function computeRootHash(\n        uint256 key,\n        uint256 numLeaves,\n        bytes32 leafHash,\n        bytes32[] memory sideNodes\n    ) private pure returns (bytes32, ErrorCodes) {\n        if (numLeaves == 0) {\n            return (leafHash, ErrorCodes.InvalidNumberOfLeavesInProof);\n        }\n        if (numLeaves == 1) {\n            if (sideNodes.length != 0) {\n                return (leafHash, ErrorCodes.UnexpectedInnerHashes);\n            }\n            return (leafHash, ErrorCodes.NoError);\n        }\n        if (sideNodes.length == 0) {\n            return (leafHash, ErrorCodes.ExpectedAtLeastOneInnerHash);\n        }\n        uint256 numLeft = _getSplitPoint(numLeaves);\n        bytes32[] memory sideNodesLeft = slice(\n            sideNodes,\n            0,\n            sideNodes.length - 1\n        );\n        ErrorCodes error;\n        if (key < numLeft) {\n            bytes32 leftHash;\n            (leftHash, error) = computeRootHash(\n                key,\n                numLeft,\n                leafHash,\n                sideNodesLeft\n            );\n            if (error != ErrorCodes.NoError) {\n                return (leafHash, error);\n            }\n            return (\n                nodeDigest(leftHash, sideNodes[sideNodes.length - 1]),\n                ErrorCodes.NoError\n            );\n        }\n        bytes32 rightHash;\n        (rightHash, error) = computeRootHash(\n            key - numLeft,\n            numLeaves - numLeft,\n            leafHash,\n            sideNodesLeft\n        );\n        if (error != ErrorCodes.NoError) {\n            return (leafHash, error);\n        }\n        return (\n            nodeDigest(sideNodes[sideNodes.length - 1], rightHash),\n            ErrorCodes.NoError\n        );\n    }\n\n    /// @notice creates a slice of bytes32 from the data slice of bytes32 containing the elements\n    /// that correspond to the provided range.\n    /// It selects a half-open range which includes the begin element, but excludes the end one.\n    /// @param _data The slice that we want to select data from.\n    /// @param _begin The beginning of the range (inclusive).\n    /// @param _end The ending of the range (exclusive).\n    /// @return _ the sliced data.\n    function slice(\n        bytes32[] memory _data,\n        uint256 _begin,\n        uint256 _end\n    ) internal pure returns (bytes32[] memory) {\n        if (_begin > _end) {\n            revert(\"Invalid range: _begin is greater than _end\");\n        }\n        if (_begin > _data.length || _end > _data.length) {\n            revert(\"Invalid range: _begin or _end are out of bounds\");\n        }\n        bytes32[] memory out = new bytes32[](_end - _begin);\n        for (uint256 i = _begin; i < _end; i++) {\n            out[i - _begin] = _data[i];\n        }\n        return out;\n    }\n}\n"}, "src/celestia/lib/tree/binary/TreeHasher.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\nimport \"../Constants.sol\";\n\n/// @notice Calculate the digest of a node.\n/// @param left The left child.\n/// @param right The right child.\n/// @return digest The node digest.\n/// @dev More details in https://github.com/celestiaorg/celestia-specs/blob/master/src/specs/data_structures.md#binary-merkle-tree\n// solhint-disable-next-line func-visibility\nfunction nodeDigest(bytes32 left, bytes32 right) pure returns (bytes32 digest) {\n    digest = sha256(abi.encodePacked(Constants.NODE_PREFIX, left, right));\n}\n\n/// @notice Calculate the digest of a leaf.\n/// @param data The data of the leaf.\n/// @return digest The leaf digest.\n/// @dev More details in https://github.com/celestiaorg/celestia-specs/blob/master/src/specs/data_structures.md#binary-merkle-tree\n// solhint-disable-next-line func-visibility\nfunction leafDigest(bytes memory data) pure returns (bytes32 digest) {\n    digest = sha256(abi.encodePacked(Constants.LEAF_PREFIX, data));\n}\n"}, "src/celestia/lib/tree/Constants.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\nimport \"./Types.sol\";\n\nlibrary Constants {\n    ///////////////\n    // Constants //\n    ///////////////\n\n    /// @dev Maximum tree height\n    uint256 internal constant MAX_HEIGHT = 256;\n\n    /// @dev The prefixes of leaves and nodes\n    bytes1 internal constant LEAF_PREFIX = 0x00;\n    bytes1 internal constant NODE_PREFIX = 0x01;\n}\n\n/// @dev Parity share namespace.\n/// utility function to provide the parity share namespace as a Namespace struct.\nfunction PARITY_SHARE_NAMESPACE() pure returns (Namespace memory) {\n    return\n        Namespace(\n            0xFF,\n            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n        );\n}\n"}, "src/celestia/lib/tree/namespace/NamespaceMerkleMultiproof.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\nimport \"./NamespaceNode.sol\";\n\n/// @notice Namespace Merkle Tree Multiproof structure. Proves multiple leaves.\nstruct NamespaceMerkleMultiproof {\n    // The beginning key of the leaves to verify.\n    uint256 beginKey;\n    // The ending key of the leaves to verify.\n    uint256 endKey;\n    // List of side nodes to verify and calculate tree.\n    NamespaceNode[] sideNodes;\n}\n"}, "src/celestia/lib/tree/namespace/NamespaceMerkleProof.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\nimport \"./NamespaceNode.sol\";\n\n/// @notice Namespace Merkle Tree Proof structure.\nstruct NamespaceMerkleProof {\n    // List of side nodes to verify and calculate tree.\n    NamespaceNode[] sideNodes;\n    // The key of the leaf to verify.\n    uint256 key;\n    // The number of leaves in the tree\n    uint256 numLeaves;\n}\n"}, "src/celestia/lib/tree/namespace/NamespaceMerkleTree.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\nimport \"../Constants.sol\";\nimport \"../Types.sol\";\nimport \"../Utils.sol\";\nimport \"./NamespaceMerkleProof.sol\";\nimport \"./NamespaceMerkleMultiproof.sol\";\nimport \"./NamespaceNode.sol\";\nimport \"./TreeHasher.sol\";\n\n/// @title Namespace Merkle Tree.\nlibrary NamespaceMerkleTree {\n    /// @notice Verify if element exists in Merkle tree, given data, proof, and root.\n    /// @param root The root of the tree in which the given leaf is verified.\n    /// @param proof Namespace Merkle proof for the leaf.\n    /// @param namespace Namespace of the leaf.\n    /// @param data The data of the leaf to verify.\n    /// @return `true` if the proof is valid, `false` otherwise.\n    /// @dev proof.numLeaves is necessary to determine height of subtree containing the data to prove.\n    function verify(\n        NamespaceNode memory root,\n        NamespaceMerkleProof memory proof,\n        Namespace memory namespace,\n        bytes memory data\n    ) internal pure returns (bool) {\n        // A sibling at height 1 is created by getting the leafDigest of the original data.\n        NamespaceNode memory node = leafDigest(namespace, data);\n\n        // Since we're verifying a leaf, height parameter is 1.\n        return verifyInner(root, proof, node, 1);\n    }\n\n    /// @notice Verify if inner node exists in Merkle tree, given node, proof, and root.\n    /// @param root The root of the tree in which the given leaf is verified.\n    /// @param proof Namespace Merkle proof for the leaf.\n    /// proof.key is any key in the subtree rooted at the inner node.\n    /// @param node The inner node to verify.\n    /// @param startingHeight Starting height of the proof.\n    /// @return `true` if the proof is valid, `false` otherwise.\n    /// @dev proof.numLeaves is necessary to determine height of subtree containing the data to prove.\n    function verifyInner(\n        NamespaceNode memory root,\n        NamespaceMerkleProof memory proof,\n        NamespaceNode memory node,\n        uint256 startingHeight\n    ) internal pure returns (bool) {\n        // Check starting height is at least 1\n        if (startingHeight < 1) {\n            return false;\n        }\n        uint256 heightOffset = startingHeight - 1;\n\n        // Check proof is correct length for the key it is proving\n        if (proof.numLeaves <= 1) {\n            if (proof.sideNodes.length != 0) {\n                return false;\n            }\n        } else if (\n            proof.sideNodes.length + heightOffset !=\n            pathLengthFromKey(proof.key, proof.numLeaves)\n        ) {\n            return false;\n        }\n\n        // Check key is in tree\n        if (proof.key >= proof.numLeaves) {\n            return false;\n        }\n        // Handle case where proof is empty: i.e, only one leaf exists, so verify hash(data) is root\n        if (proof.sideNodes.length == 0) {\n            if (proof.numLeaves == 1) {\n                return namespaceNodeEquals(root, node);\n            } else {\n                return false;\n            }\n        }\n\n        // The case where inner node is actually the root of a tree with more than one node is not relevant\n        // to our use case, since the only case where an inner node is the root of the tree is when the tree\n        // has only one inner node. So, there is no need to handle that case.\n\n        uint256 height = startingHeight;\n        uint256 stableEnd = proof.key;\n\n        // While the current subtree (of height 'height') is complete, determine\n        // the position of the next sibling using the complete subtree algorithm.\n        // 'stableEnd' tells us the ending index of the last full subtree. It gets\n        // initialized to 'key' because the first full subtree was the\n        // subtree of height 1, created above (and had an ending index of\n        // 'key').\n\n        while (true) {\n            // Determine if the subtree is complete. This is accomplished by\n            // rounding down the key to the nearest 1 << 'height', adding 1\n            // << 'height', and comparing the result to the number of leaves in the\n            // Merkle tree.\n\n            uint256 subTreeStartIndex = (proof.key / (1 << height)) *\n                (1 << height);\n            uint256 subTreeEndIndex = subTreeStartIndex + (1 << height) - 1;\n\n            // If the Merkle tree does not have a leaf at index\n            // 'subTreeEndIndex', then the subtree of the current height is not\n            // a complete subtree.\n            if (subTreeEndIndex >= proof.numLeaves) {\n                break;\n            }\n            stableEnd = subTreeEndIndex;\n\n            // Determine if the key is in the first or the second half of\n            // the subtree.\n            if (proof.sideNodes.length + heightOffset <= height - 1) {\n                return false;\n            }\n            if (proof.key - subTreeStartIndex < (1 << (height - 1))) {\n                node = nodeDigest(\n                    node,\n                    proof.sideNodes[height - heightOffset - 1]\n                );\n            } else {\n                node = nodeDigest(\n                    proof.sideNodes[height - heightOffset - 1],\n                    node\n                );\n            }\n\n            height += 1;\n        }\n\n        // Determine if the next hash belongs to an orphan that was elevated. This\n        // is the case IFF 'stableEnd' (the last index of the largest full subtree)\n        // is equal to the number of leaves in the Merkle tree.\n        if (stableEnd != proof.numLeaves - 1) {\n            if (proof.sideNodes.length <= height - heightOffset - 1) {\n                return false;\n            }\n            node = nodeDigest(node, proof.sideNodes[height - heightOffset - 1]);\n            height += 1;\n        }\n        // All remaining elements in the proof set will belong to a left sibling.\n        while (height - heightOffset - 1 < proof.sideNodes.length) {\n            node = nodeDigest(proof.sideNodes[height - heightOffset - 1], node);\n            height += 1;\n        }\n\n        return namespaceNodeEquals(root, node);\n    }\n\n    /// @notice Verify if contiguous elements exists in Merkle tree, given leaves, mutliproof, and root.\n    /// @param root The root of the tree in which the given leaves are verified.\n    /// @param proof Namespace Merkle multiproof for the leaves.\n    /// @param namespace Namespace of the leaves. All leaves must have the same namespace.\n    /// @param data The leaves to verify. Note: leaf data must be the _entire_ share (including namespace prefixing).\n    /// @return `true` if the proof is valid, `false` otherwise.\n    function verifyMulti(\n        NamespaceNode memory root,\n        NamespaceMerkleMultiproof memory proof,\n        Namespace memory namespace,\n        bytes[] memory data\n    ) internal pure returns (bool) {\n        // Hash all the leaves to get leaf nodes.\n        NamespaceNode[] memory nodes = new NamespaceNode[](data.length);\n        for (uint256 i = 0; i < data.length; ++i) {\n            nodes[i] = leafDigest(namespace, data[i]);\n        }\n\n        // Verify inclusion of leaf nodes.\n        return verifyMultiHashes(root, proof, nodes);\n    }\n\n    /// @notice Verify if contiguous leaf hashes exists in Merkle tree, given leaf nodes, multiproof, and root.\n    /// @param root The root of the tree in which the given leaf nodes are verified.\n    /// @param proof Namespace Merkle multiproof for the leaves.\n    /// @param leafNodes The leaf nodes to verify.\n    /// @return `true` if the proof is valid, `false` otherwise.\n    function verifyMultiHashes(\n        NamespaceNode memory root,\n        NamespaceMerkleMultiproof memory proof,\n        NamespaceNode[] memory leafNodes\n    ) internal pure returns (bool) {\n        uint256 leafIndex = 0;\n        NamespaceNode[] memory leftSubtrees = new NamespaceNode[](\n            proof.sideNodes.length\n        );\n\n        for (\n            uint256 i = 0;\n            leafIndex != proof.beginKey && i < proof.sideNodes.length;\n            ++i\n        ) {\n            uint256 subtreeSize = _nextSubtreeSize(leafIndex, proof.beginKey);\n            leftSubtrees[i] = proof.sideNodes[i];\n            leafIndex += subtreeSize;\n        }\n\n        // estimate the leaf size of the subtree containing the proof range\n        uint256 proofRangeSubtreeEstimate = _getSplitPoint(proof.endKey) * 2;\n        if (proofRangeSubtreeEstimate < 1) {\n            proofRangeSubtreeEstimate = 1;\n        }\n\n        (NamespaceNode memory rootHash, uint256 proofHead, , ) = _computeRoot(\n            proof,\n            leafNodes,\n            0,\n            proofRangeSubtreeEstimate,\n            0,\n            0\n        );\n        for (uint256 i = proofHead; i < proof.sideNodes.length; ++i) {\n            rootHash = nodeDigest(rootHash, proof.sideNodes[i]);\n        }\n\n        return namespaceNodeEquals(rootHash, root);\n    }\n\n    /// @notice Returns the size of the subtree adjacent to `begin` that does\n    /// not overlap `end`.\n    /// @param begin Begin index, inclusive.\n    /// @param end End index, exclusive.\n    function _nextSubtreeSize(\n        uint256 begin,\n        uint256 end\n    ) private pure returns (uint256) {\n        uint256 ideal = _bitsTrailingZeroes(begin);\n        uint256 max = _bitsLen(end - begin) - 1;\n        if (ideal > max) {\n            return 1 << max;\n        }\n        return 1 << ideal;\n    }\n\n    /// @notice Returns the number of trailing zero bits in `x`; the result is\n    /// 256 for `x` == 0.\n    /// @param x Number.\n    function _bitsTrailingZeroes(uint256 x) private pure returns (uint256) {\n        uint256 mask = 1;\n        uint256 count = 0;\n\n        while (x != 0 && mask & x == 0) {\n            count++;\n            x >>= 1;\n        }\n\n        return count;\n    }\n\n    /// @notice Computes the NMT root recursively.\n    /// @param proof Namespace Merkle multiproof for the leaves.\n    /// @param leafNodes Leaf nodes for which inclusion is proven.\n    /// @param begin Begin index, inclusive.\n    /// @param end End index, exclusive.\n    /// @param headProof Internal detail: head of proof sidenodes array. Used for recursion. Set to `0` on first call.\n    /// @param headLeaves Internal detail: head of leaves array. Used for recursion. Set to `0` on first call.\n    /// @return _ Subtree root.\n    /// @return _ New proof sidenodes array head. Used for recursion.\n    /// @return _ New leaves array head. Used for recursion.\n    /// @return _ If the subtree root is \"nil.\"\n    function _computeRoot(\n        NamespaceMerkleMultiproof memory proof,\n        NamespaceNode[] memory leafNodes,\n        uint256 begin,\n        uint256 end,\n        uint256 headProof,\n        uint256 headLeaves\n    ) private pure returns (NamespaceNode memory, uint256, uint256, bool) {\n        // reached a leaf\n        if (end - begin == 1) {\n            // if current range overlaps with proof range, pop and return a leaf\n            if (proof.beginKey <= begin && begin < proof.endKey) {\n                // Note: second return value is guaranteed to be `false` by\n                // construction.\n                return\n                    _popLeavesIfNonEmpty(\n                        leafNodes,\n                        headLeaves,\n                        leafNodes.length,\n                        headProof\n                    );\n            }\n\n            // if current range does not overlap with proof range,\n            // pop and return a proof node (leaf) if present,\n            // else return nil because leaf doesn't exist\n            return\n                _popProofIfNonEmpty(\n                    proof.sideNodes,\n                    headProof,\n                    end,\n                    headLeaves\n                );\n        }\n\n        // if current range does not overlap with proof range,\n        // pop and return a proof node if present,\n        // else return nil because subtree doesn't exist\n        if (end <= proof.beginKey || begin >= proof.endKey) {\n            return\n                _popProofIfNonEmpty(\n                    proof.sideNodes,\n                    headProof,\n                    end,\n                    headLeaves\n                );\n        }\n\n        // Recursively get left and right subtree\n        uint256 k = _getSplitPoint(end - begin);\n        (\n            NamespaceNode memory left,\n            uint256 newHeadProofLeft,\n            uint256 newHeadLeavesLeft,\n\n        ) = _computeRoot(\n                proof,\n                leafNodes,\n                begin,\n                begin + k,\n                headProof,\n                headLeaves\n            );\n        (\n            NamespaceNode memory right,\n            uint256 newHeadProof,\n            uint256 newHeadLeaves,\n            bool rightIsNil\n        ) = _computeRoot(\n                proof,\n                leafNodes,\n                begin + k,\n                end,\n                newHeadProofLeft,\n                newHeadLeavesLeft\n            );\n\n        // only right leaf/subtree can be non-existent\n        if (rightIsNil == true) {\n            return (left, newHeadProof, newHeadLeaves, false);\n        }\n        NamespaceNode memory hash = nodeDigest(left, right);\n        return (hash, newHeadProof, newHeadLeaves, false);\n    }\n\n    /// @notice Pop from the leaf nodes array slice if it's not empty.\n    /// @param nodes Entire leaf nodes array.\n    /// @param headLeaves Head of leaf nodes array slice.\n    /// @param end End of leaf nodes array slice.\n    /// @param headProof Used only to return for recursion.\n    /// @return _ Popped node.\n    /// @return _ Head of proof sidenodes array slice (unchanged).\n    /// @return _ New head of leaf nodes array slice.\n    /// @return _ If the popped node is \"nil.\"\n    function _popLeavesIfNonEmpty(\n        NamespaceNode[] memory nodes,\n        uint256 headLeaves,\n        uint256 end,\n        uint256 headProof\n    ) private pure returns (NamespaceNode memory, uint256, uint256, bool) {\n        (\n            NamespaceNode memory node,\n            uint256 newHead,\n            bool isNil\n        ) = _popIfNonEmpty(nodes, headLeaves, end);\n        return (node, headProof, newHead, isNil);\n    }\n\n    /// @notice Pop from the proof sidenodes array slice if it's not empty.\n    /// @param nodes Entire proof sidenodes array.\n    /// @param headLeaves Head of proof sidenodes array slice.\n    /// @param end End of proof sidenodes array slice.\n    /// @param headProof Used only to return for recursion.\n    /// @return _ Popped node.\n    /// @return _ New head of proof sidenodes array slice.\n    /// @return _ Head of proof sidenodes array slice (unchanged).\n    /// @return _ If the popped node is \"nil.\"\n    function _popProofIfNonEmpty(\n        NamespaceNode[] memory nodes,\n        uint256 headProof,\n        uint256 end,\n        uint256 headLeaves\n    ) private pure returns (NamespaceNode memory, uint256, uint256, bool) {\n        (\n            NamespaceNode memory node,\n            uint256 newHead,\n            bool isNil\n        ) = _popIfNonEmpty(nodes, headProof, end);\n        return (node, newHead, headLeaves, isNil);\n    }\n\n    /// @notice Pop from an array slice if it's not empty.\n    /// @param nodes Entire array.\n    /// @param head Head of array slice.\n    /// @param end End of array slice.\n    /// @return _ Popped node.\n    /// @return _ New head of array slice.\n    /// @return _ If the popped node is \"nil.\"\n    function _popIfNonEmpty(\n        NamespaceNode[] memory nodes,\n        uint256 head,\n        uint256 end\n    ) private pure returns (NamespaceNode memory, uint256, bool) {\n        if (nodes.length == 0 || head >= nodes.length || head >= end) {\n            NamespaceNode memory node;\n            return (node, head, true);\n        }\n        return (nodes[head], head + 1, false);\n    }\n}\n"}, "src/celestia/lib/tree/namespace/NamespaceNode.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\nimport \"../Types.sol\";\n\n/// @notice Namespace Merkle Tree node.\nstruct NamespaceNode {\n    // Minimum namespace.\n    Namespace min;\n    // Maximum namespace.\n    Namespace max;\n    // Node value.\n    bytes32 digest;\n}\n\n/// @notice Compares two `NamespaceNode`s.\n/// @param first First node.\n/// @param second Second node.\n/// @return `true` is equal, `false otherwise.\n// solhint-disable-next-line func-visibility\nfunction namespaceNodeEquals(\n    NamespaceNode memory first,\n    NamespaceNode memory second\n) pure returns (bool) {\n    return\n        first.min.equalTo(second.min) &&\n        first.max.equalTo(second.max) &&\n        (first.digest == second.digest);\n}\n"}, "src/celestia/lib/tree/namespace/TreeHasher.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\nimport \"../Constants.sol\";\nimport \"../Types.sol\";\nimport \"./NamespaceNode.sol\";\n\n/// @notice Get the minimum namespace.\n// solhint-disable-next-line func-visibility\nfunction namespaceMin(\n    Namespace memory l,\n    Namespace memory r\n) pure returns (Namespace memory) {\n    if (l.lessThan(r)) {\n        return l;\n    } else {\n        return r;\n    }\n}\n\n/// @notice Get the maximum namespace.\n// solhint-disable-next-line func-visibility\nfunction namespaceMax(\n    Namespace memory l,\n    Namespace memory r\n) pure returns (Namespace memory) {\n    if (l.greaterThan(r)) {\n        return l;\n    } else {\n        return r;\n    }\n}\n\n/// @notice Hash a leaf node.\n/// @param namespace Namespace of the leaf.\n/// @param data Raw data of the leaf.\n/// @dev More details in https://github.com/celestiaorg/celestia-specs/blob/master/src/specs/data_structures.md#namespace-merkle-tree\n// solhint-disable-next-line func-visibility\nfunction leafDigest(\n    Namespace memory namespace,\n    bytes memory data\n) pure returns (NamespaceNode memory) {\n    bytes32 digest = sha256(\n        abi.encodePacked(Constants.LEAF_PREFIX, namespace.toBytes(), data)\n    );\n    NamespaceNode memory node = NamespaceNode(namespace, namespace, digest);\n    return node;\n}\n\n/// @notice Hash an internal node.\n/// @param l Left child.\n/// @param r Right child.\n/// @dev More details in https://github.com/celestiaorg/celestia-specs/blob/master/src/specs/data_structures.md#namespace-merkle-tree\n// solhint-disable-next-line func-visibility\nfunction nodeDigest(\n    NamespaceNode memory l,\n    NamespaceNode memory r\n) pure returns (NamespaceNode memory) {\n    Namespace memory min = namespaceMin(l.min, r.min);\n    Namespace memory max;\n    if (l.min.equalTo(PARITY_SHARE_NAMESPACE())) {\n        max = PARITY_SHARE_NAMESPACE();\n    } else if (r.min.equalTo(PARITY_SHARE_NAMESPACE())) {\n        max = l.max;\n    } else {\n        max = namespaceMax(l.max, r.max);\n    }\n\n    bytes32 digest = sha256(\n        abi.encodePacked(\n            Constants.NODE_PREFIX,\n            l.min.toBytes(),\n            l.max.toBytes(),\n            l.digest,\n            r.min.toBytes(),\n            r.max.toBytes(),\n            r.digest\n        )\n    );\n\n    NamespaceNode memory node = NamespaceNode(min, max, digest);\n    return node;\n}\n"}, "src/celestia/lib/tree/Types.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\n/// @notice A representation of the Celestia-app namespace ID and its version.\n/// See: https://celestiaorg.github.io/celestia-app/specs/namespace.html\nstruct Namespace {\n    // The namespace version.\n    bytes1 version;\n    // The namespace ID.\n    bytes28 id;\n}\n\nusing {equalTo, lessThan, greaterThan, toBytes} for Namespace global;\n\nfunction equalTo(Namespace memory l, Namespace memory r) pure returns (bool) {\n    return l.toBytes() == r.toBytes();\n}\n\nfunction lessThan(Namespace memory l, Namespace memory r) pure returns (bool) {\n    return l.toBytes() < r.toBytes();\n}\n\nfunction greaterThan(\n    Namespace memory l,\n    Namespace memory r\n) pure returns (bool) {\n    return l.toBytes() > r.toBytes();\n}\n\nfunction toBytes(Namespace memory n) pure returns (bytes29) {\n    return bytes29(abi.encodePacked(n.version, n.id));\n}\n\nfunction toNamespace(bytes29 n) pure returns (Namespace memory) {\n    bytes memory id = new bytes(28);\n    for (uint256 i = 1; i < 29; i++) {\n        id[i - 1] = n[i];\n    }\n    return Namespace(n[0], bytes28(id));\n}\n"}, "src/celestia/lib/tree/Utils.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\nimport \"./Constants.sol\";\n\n/// @notice Calculate the starting bit of the path to a leaf\n/// @param numLeaves : The total number of leaves in the tree\n/// @return startingBit : The starting bit of the path\n// solhint-disable-next-line func-visibility\nfunction getStartingBit(uint256 numLeaves) pure returns (uint256 startingBit) {\n    // Determine height of the left subtree. This is the maximum path length, so all paths start at this offset from the right-most bit\n    startingBit = 0;\n    while ((1 << startingBit) < numLeaves) {\n        startingBit += 1;\n    }\n    return Constants.MAX_HEIGHT - startingBit;\n}\n\n/// @notice Calculate the length of the path to a leaf\n/// @param key: The key of the leaf\n/// @param numLeaves: The total number of leaves in the tree\n/// @return pathLength : The length of the path to the leaf\n// solhint-disable-next-line func-visibility\nfunction pathLengthFromKey(\n    uint256 key,\n    uint256 numLeaves\n) pure returns (uint256 pathLength) {\n    if (numLeaves <= 1) {\n        // if the number of leaves of the tree is 1 or 0, the path always is 0.\n        return 0;\n    }\n    // Get the height of the left subtree. This is equal to the offset of the starting bit of the path\n    pathLength = Constants.MAX_HEIGHT - getStartingBit(numLeaves);\n\n    // Determine the number of leaves in the left subtree\n    uint256 numLeavesLeftSubTree = (1 << (pathLength - 1));\n\n    // If leaf is in left subtree, path length is full height of left subtree\n    if (key <= numLeavesLeftSubTree - 1) {\n        return pathLength;\n    }\n    // If left sub tree has only one leaf but key is not there, path has one additional step\n    else if (numLeavesLeftSubTree == 1) {\n        return 1;\n    }\n    // Otherwise, add 1 to height and recurse into right subtree\n    else {\n        return\n            1 +\n            pathLengthFromKey(\n                key - numLeavesLeftSubTree,\n                numLeaves - numLeavesLeftSubTree\n            );\n    }\n}\n\n/// @notice Returns the minimum number of bits required to represent `x`; the\n/// result is 0 for `x` == 0.\n/// @param x Number.\nfunction _bitsLen(uint256 x) pure returns (uint256) {\n    uint256 count = 0;\n\n    while (x != 0) {\n        count++;\n        x >>= 1;\n    }\n\n    return count;\n}\n\n/// @notice Returns the largest power of 2 less than `x`.\n/// @param x Number.\nfunction _getSplitPoint(uint256 x) pure returns (uint256) {\n    // Note: since `x` is always an unsigned int * 2, the only way for this\n    // to be violated is if the input == 0. Since the input is the end\n    // index exclusive, an input of 0 is guaranteed to be invalid (it would\n    // be a proof of inclusion of nothing, which is vacuous).\n    require(x >= 1);\n\n    uint256 bitLen = _bitsLen(x);\n    uint256 k = 1 << (bitLen - 1);\n    if (k == x) {\n        k >>= 1;\n    }\n    return k;\n}\n"}, "src/libraries/IGasRefunder.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.30;\n\ninterface IGasRefunder {\n    function onGasSpent(\n        address payable spender,\n        uint256 gasUsed,\n        uint256 calldataSize\n    ) external returns (bool success);\n}\n"}, "src/osp/IOneStepProver.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../state/Machine.sol\";\nimport \"../state/Module.sol\";\nimport \"../state/Instructions.sol\";\nimport \"../state/GlobalState.sol\";\nimport \"../bridge/ISequencerInbox.sol\";\nimport \"../bridge/IBridge.sol\";\n\nstruct ExecutionContext {\n    uint256 maxInboxMessagesRead;\n    IBridge bridge;\n}\n\nabstract contract IOneStepProver {\n    function executeOneStep(\n        ExecutionContext memory execCtx,\n        Machine calldata mach,\n        Module calldata mod,\n        Instruction calldata instruction,\n        bytes calldata proof\n    ) external view virtual returns (Machine memory result, Module memory resultMod);\n}\n"}, "src/osp/OneStepProverHostIo.sol": {"content": "// Copyright 2021-2024, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../state/Value.sol\";\nimport \"../state/Machine.sol\";\nimport \"../state/MerkleProof.sol\";\nimport \"../state/MultiStack.sol\";\nimport \"../state/Deserialize.sol\";\nimport \"../state/ModuleMemory.sol\";\nimport \"../osp/IOneStepProver.sol\";\nimport \"../bridge/Messages.sol\";\nimport \"../bridge/IBridge.sol\";\nimport {IBlobstreamX} from \"../celestia/IBlobstreamX.sol\";\n\nimport \"../celestia/BlobstreamVerifier.sol\";\n\ncontract OneStepProverHostIo is IOneStepProver {\n    using GlobalStateLib for GlobalState;\n    using MachineLib for Machine;\n    using MerkleProofLib for MerkleProof;\n    using ModuleMemoryLib for ModuleMemory;\n    using MultiStackLib for MultiStack;\n    using ValueLib for Value;\n    using ValueStackLib for ValueStack;\n    using StackFrameLib for StackFrameWindow;\n    using CelestiaBatchVerifier for address;\n\n    uint256 private constant LEAF_SIZE = 32;\n    uint256 private constant INBOX_NUM = 2;\n    uint64 private constant INBOX_HEADER_LEN = 40;\n    uint64 private constant DELAYED_HEADER_LEN = 112 + 1;\n\n    // Header Bytes\n    bytes1 public constant CELESTIA_MESSAGE_HEADER_FLAG = 0x63;\n\n    // https://docs.celestia.org/how-to-guides/blobstream\n    //Arb sepolia\n    //Base sepolia\n    //address public constant BLOBSTREAM = 0xc3e209eb245Fd59c8586777b499d6A665DF3ABD2;\n\n    //Base\n    //Arb\n    //address public constant BLOBSTREAM = 0xA83ca7775Bc2889825BcDeDfFa5b758cf69e8794;\n    \n    //Sepolia \n    //address public constant BLOBSTREAM = 0xF0c6429ebAB2e7DC6e05DaFB61128bE21f13cb1e;\n\n\n    //Mainnet\n    address public constant BLOBSTREAM = 0x7Cf3876F681Dbb6EdA8f6FfC45D66B996Df08fAe;\n\n    function setLeafByte(bytes32 oldLeaf, uint256 idx, uint8 val) internal pure returns (bytes32) {\n        require(idx < LEAF_SIZE, \"BAD_SET_LEAF_BYTE_IDX\");\n        // Take into account that we are casting the leaf to a big-endian integer\n        uint256 leafShift = (LEAF_SIZE - 1 - idx) * 8;\n        uint256 newLeaf = uint256(oldLeaf);\n        newLeaf &= ~(0xFF << leafShift);\n        newLeaf |= uint256(val) << leafShift;\n        return bytes32(newLeaf);\n    }\n\n    function executeGetOrSetBytes32(\n        Machine memory mach,\n        Module memory mod,\n        GlobalState memory state,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) internal pure {\n        uint256 ptr = mach.valueStack.pop().assumeI32();\n        uint32 idx = mach.valueStack.pop().assumeI32();\n\n        if (idx >= GlobalStateLib.BYTES32_VALS_NUM) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        if (!mod.moduleMemory.isValidLeaf(ptr)) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n\n        uint256 leafIdx = ptr / LEAF_SIZE;\n        uint256 proofOffset = 0;\n        bytes32 startLeafContents;\n        MerkleProof memory merkleProof;\n        (startLeafContents, proofOffset, merkleProof) = mod.moduleMemory.proveLeaf(\n            leafIdx,\n            proof,\n            proofOffset\n        );\n\n        if (inst.opcode == Instructions.GET_GLOBAL_STATE_BYTES32) {\n            mod.moduleMemory.merkleRoot = merkleProof.computeRootFromMemory(\n                leafIdx,\n                state.bytes32Vals[idx]\n            );\n        } else if (inst.opcode == Instructions.SET_GLOBAL_STATE_BYTES32) {\n            state.bytes32Vals[idx] = startLeafContents;\n        } else {\n            revert(\"BAD_GLOBAL_STATE_OPCODE\");\n        }\n    }\n\n    function executeGetU64(Machine memory mach, GlobalState memory state) internal pure {\n        uint32 idx = mach.valueStack.pop().assumeI32();\n\n        if (idx >= GlobalStateLib.U64_VALS_NUM) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n\n        mach.valueStack.push(ValueLib.newI64(state.u64Vals[idx]));\n    }\n\n    function executeSetU64(Machine memory mach, GlobalState memory state) internal pure {\n        uint64 val = mach.valueStack.pop().assumeI64();\n        uint32 idx = mach.valueStack.pop().assumeI32();\n\n        if (idx >= GlobalStateLib.U64_VALS_NUM) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        state.u64Vals[idx] = val;\n    }\n\n    uint256 internal constant BLS_MODULUS =\n        52435875175126190479447740508185965837690552500527637822603658699938581184513;\n    uint256 internal constant PRIMITIVE_ROOT_OF_UNITY =\n        10238227357739495823651030575849232062558860180284477541189508159991286009131;\n\n    // Computes b**e % m\n    // Really pure but the Solidity compiler sees the staticcall and requires view\n    function modExp256(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        bytes memory modExpInput = abi.encode(32, 32, 32, b, e, m);\n        (bool modexpSuccess, bytes memory modExpOutput) = address(0x05).staticcall(modExpInput);\n        require(modexpSuccess, \"MODEXP_FAILED\");\n        require(modExpOutput.length == 32, \"MODEXP_WRONG_LENGTH\");\n        return uint256(bytes32(modExpOutput));\n    }\n\n    function executeReadPreImage(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) internal view {\n        uint256 preimageOffset = mach.valueStack.pop().assumeI32();\n        uint256 ptr = mach.valueStack.pop().assumeI32();\n        if (preimageOffset % 32 != 0 || ptr + 32 > mod.moduleMemory.size || ptr % LEAF_SIZE != 0) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n\n        uint256 leafIdx = ptr / LEAF_SIZE;\n        uint256 proofOffset = 0;\n        bytes32 leafContents;\n        MerkleProof memory merkleProof;\n        (leafContents, proofOffset, merkleProof) = mod.moduleMemory.proveLeaf(\n            leafIdx,\n            proof,\n            proofOffset\n        );\n\n        bytes memory extracted;\n        uint8 proofType = uint8(proof[proofOffset]);\n        proofOffset++;\n        // These values must be kept in sync with `arbitrator/arbutil/src/types.rs`\n        // and `arbutil/preimage_type.go` (both in the nitro repo).\n        if (inst.argumentData == 0) {\n            // The machine is asking for a keccak256 preimage\n\n            if (proofType == 0) {\n                bytes calldata preimage = proof[proofOffset:];\n                require(keccak256(preimage) == leafContents, \"BAD_PREIMAGE\");\n\n                uint256 preimageEnd = preimageOffset + 32;\n                if (preimageEnd > preimage.length) {\n                    preimageEnd = preimage.length;\n                }\n                extracted = preimage[preimageOffset:preimageEnd];\n            } else {\n                // TODO: support proving via an authenticated contract\n                revert(\"UNKNOWN_PREIMAGE_PROOF\");\n            }\n        } else if (inst.argumentData == 1) {\n            // The machine is asking for a sha2-256 preimage\n\n            require(proofType == 0, \"UNKNOWN_PREIMAGE_PROOF\");\n            bytes calldata preimage = proof[proofOffset:];\n            require(sha256(preimage) == leafContents, \"BAD_PREIMAGE\");\n\n            uint256 preimageEnd = preimageOffset + 32;\n            if (preimageEnd > preimage.length) {\n                preimageEnd = preimage.length;\n            }\n            extracted = preimage[preimageOffset:preimageEnd];\n        } else if (inst.argumentData == 2) {\n            // The machine is asking for an Ethereum versioned hash preimage\n\n            require(proofType == 0, \"UNKNOWN_PREIMAGE_PROOF\");\n\n            // kzgProof should be a valid input to the EIP-4844 point evaluation precompile at address 0x0A.\n            // It should prove the preimageOffset/32'th word of the machine's requested KZG commitment.\n            bytes calldata kzgProof = proof[proofOffset:];\n\n            require(bytes32(kzgProof[:32]) == leafContents, \"KZG_PROOF_WRONG_HASH\");\n\n            uint256 fieldElementsPerBlob;\n            uint256 blsModulus;\n            {\n                (bool success, bytes memory kzgParams) = address(0x0A).staticcall(kzgProof);\n                require(success, \"INVALID_KZG_PROOF\");\n                require(kzgParams.length > 0, \"KZG_PRECOMPILE_MISSING\");\n                (fieldElementsPerBlob, blsModulus) = abi.decode(kzgParams, (uint256, uint256));\n            }\n\n            // With a hardcoded PRIMITIVE_ROOT_OF_UNITY, we can only support this BLS modulus.\n            // It may be worth in the future supporting arbitrary BLS moduli, but we would likely need to\n            // validate a user-supplied root of unity.\n            require(blsModulus == BLS_MODULUS, \"UNKNOWN_BLS_MODULUS\");\n\n            // If preimageOffset is greater than or equal to the blob size, leave extracted empty and call it here.\n            if (preimageOffset < fieldElementsPerBlob * 32) {\n                // We need to compute what point the polynomial should be evaluated at to get the right part of the preimage.\n                // KZG commitments use a bit reversal permutation to order the roots of unity.\n                // To account for that, we reverse the bit order of the index.\n                uint256 bitReversedIndex = 0;\n                // preimageOffset was required to be 32 byte aligned above\n                uint256 tmp = preimageOffset / 32;\n                for (uint256 i = 1; i < fieldElementsPerBlob; i <<= 1) {\n                    bitReversedIndex <<= 1;\n                    if (tmp & 1 == 1) {\n                        bitReversedIndex |= 1;\n                    }\n                    tmp >>= 1;\n                }\n\n                // First, we get the root of unity of order 2**fieldElementsPerBlob.\n                // We start with a root of unity of order 2**32 and then raise it to\n                // the power of (2**32)/fieldElementsPerBlob to get root of unity we need.\n                uint256 rootOfUnityPower = (1 << 32) / fieldElementsPerBlob;\n                // Then, we raise the root of unity to the power of bitReversedIndex,\n                // to retrieve this word of the KZG commitment.\n                rootOfUnityPower *= bitReversedIndex;\n                // z is the point the polynomial is evaluated at to retrieve this word of data\n                uint256 z = modExp256(PRIMITIVE_ROOT_OF_UNITY, rootOfUnityPower, blsModulus);\n                require(bytes32(kzgProof[32:64]) == bytes32(z), \"KZG_PROOF_WRONG_Z\");\n\n                extracted = kzgProof[64:96];\n            }\n        } else {\n            revert(\"UNKNOWN_PREIMAGE_TYPE\");\n        }\n\n        for (uint256 i = 0; i < extracted.length; i++) {\n            leafContents = setLeafByte(leafContents, i, uint8(extracted[i]));\n        }\n\n        mod.moduleMemory.merkleRoot = merkleProof.computeRootFromMemory(leafIdx, leafContents);\n\n        mach.valueStack.push(ValueLib.newI32(uint32(extracted.length)));\n    }\n\n    function validateSequencerInbox(\n        ExecutionContext calldata execCtx,\n        uint64 msgIndex,\n        bytes calldata message\n    ) internal view returns (bool) {\n        // need to check where exactly does proof offset usually land, see how we can get get rid of the length delimiter\n        // also review delayed message inbox issue Ottersect reported.\n        require(message.length >= INBOX_HEADER_LEN, \"BAD_SEQINBOX_PROOF\");\n\n        uint64 afterDelayedMsg;\n        (afterDelayedMsg, ) = Deserialize.u64(message, 32);\n        bytes32 messageHash = keccak256(message);\n        bytes32 beforeAcc;\n        bytes32 delayedAcc;\n\n        if (msgIndex > 0) {\n            beforeAcc = execCtx.bridge.sequencerInboxAccs(msgIndex - 1);\n        }\n        if (afterDelayedMsg > 0) {\n            delayedAcc = execCtx.bridge.delayedInboxAccs(afterDelayedMsg - 1);\n        }\n        bytes32 acc = keccak256(abi.encodePacked(beforeAcc, messageHash, delayedAcc));\n        require(acc == execCtx.bridge.sequencerInboxAccs(msgIndex), \"BAD_SEQINBOX_MESSAGE\");\n        return true;\n    }\n\n    function validateDelayedInbox(\n        ExecutionContext calldata execCtx,\n        uint64 msgIndex,\n        bytes calldata message\n    ) internal view returns (bool) {\n        require(message.length >= DELAYED_HEADER_LEN, \"BAD_DELAYED_PROOF\");\n\n        bytes32 beforeAcc;\n\n        if (msgIndex > 0) {\n            beforeAcc = execCtx.bridge.delayedInboxAccs(msgIndex - 1);\n        }\n\n        bytes32 messageDataHash = keccak256(message[DELAYED_HEADER_LEN:]);\n        bytes1 kind = message[0];\n        uint256 sender;\n        (sender, ) = Deserialize.u256(message, 1);\n\n        bytes32 messageHash = keccak256(\n            abi.encodePacked(kind, uint160(sender), message[33:DELAYED_HEADER_LEN], messageDataHash)\n        );\n        bytes32 acc = Messages.accumulateInboxMessage(beforeAcc, messageHash);\n\n        require(acc == execCtx.bridge.delayedInboxAccs(msgIndex), \"BAD_DELAYED_MESSAGE\");\n        return true;\n    }\n\n    function validateDaProof(bytes calldata proof, uint256 offset) internal view returns (uint256) {\n        // NOTE: the offset points to 40 bytes after the proof offset, which should point to a\n        // batch header flag for a sequencer inbox message\n        uint256 proofEnd;\n\n        if (proof[0] & CELESTIA_MESSAGE_HEADER_FLAG != 0) {\n            CelestiaBatchVerifier.Result result = CelestiaBatchVerifier.verifyBatch(\n                BLOBSTREAM,\n                proof[1:]\n            );\n\n            if (result == CelestiaBatchVerifier.Result.UNDECIDED) revert(\"BLOBSTREAM_UNDECIDED\");\n\n            // if its a counterfactual commitment, we replace the batch data with an empty batch\n            if (result == CelestiaBatchVerifier.Result.COUNTERFACTUAL_COMMITMENT) {\n                // this would slice the array into an empty batch\n                proofEnd = offset;\n            }\n\n            if (result == CelestiaBatchVerifier.Result.IN_BLOBSTREAM) {\n                // remove Celestia DA proof from proof\n                // add 88 for the 88 bytes in a celestia batch\n                // (the offset at this point already includes the batch header)\n                proofEnd = offset + 89;\n            }\n        }\n\n        return proofEnd;\n    }\n\n    function executeReadInboxMessage(\n        ExecutionContext calldata execCtx,\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) internal view {\n        uint256 messageOffset = mach.valueStack.pop().assumeI32();\n        uint256 ptr = mach.valueStack.pop().assumeI32();\n        uint256 msgIndex = mach.valueStack.pop().assumeI64();\n        if (\n            inst.argumentData == Instructions.INBOX_INDEX_SEQUENCER &&\n            msgIndex >= execCtx.maxInboxMessagesRead\n        ) {\n            mach.status = MachineStatus.TOO_FAR;\n            return;\n        }\n\n        if (ptr + 32 > mod.moduleMemory.size || ptr % LEAF_SIZE != 0) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n\n        uint256 leafIdx = ptr / LEAF_SIZE;\n        uint256 proofOffset = 0;\n        bytes32 leafContents;\n        MerkleProof memory merkleProof;\n        (leafContents, proofOffset, merkleProof) = mod.moduleMemory.proveLeaf(\n            leafIdx,\n            proof,\n            proofOffset\n        );\n        {\n            // TODO: support proving via an authenticated contract\n            require(proof[proofOffset] == 0, \"UNKNOWN_INBOX_PROOF\");\n            proofOffset++;\n\n            uint256 proofEnd = proof.length;\n\n            function(ExecutionContext calldata, uint64, bytes calldata)\n                internal\n                view\n                returns (bool) inboxValidate;\n\n            bool success;\n            if (inst.argumentData == Instructions.INBOX_INDEX_SEQUENCER) {\n                inboxValidate = validateSequencerInbox;\n                if (proof[proofOffset + 40] & CELESTIA_MESSAGE_HEADER_FLAG != 0) {\n                    proofEnd = validateDaProof(proof[proofOffset + 40:], proofOffset + 40);\n                }\n            } else if (inst.argumentData == Instructions.INBOX_INDEX_DELAYED) {\n                inboxValidate = validateDelayedInbox;\n            } else {\n                mach.status = MachineStatus.ERRORED;\n                return;\n            }\n            success = inboxValidate(execCtx, uint64(msgIndex), proof[proofOffset:proofEnd]);\n            if (!success) {\n                mach.status = MachineStatus.ERRORED;\n                return;\n            }\n        }\n\n        require(proof.length >= proofOffset, \"BAD_MESSAGE_PROOF\");\n        uint256 messageLength = proof.length - proofOffset;\n\n        uint32 i = 0;\n        for (; i < 32 && messageOffset + i < messageLength; i++) {\n            leafContents = setLeafByte(\n                leafContents,\n                i,\n                uint8(proof[proofOffset + messageOffset + i])\n            );\n        }\n\n        mod.moduleMemory.merkleRoot = merkleProof.computeRootFromMemory(leafIdx, leafContents);\n        mach.valueStack.push(ValueLib.newI32(i));\n    }\n\n    function executeHaltAndSetFinished(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory,\n        Instruction calldata,\n        bytes calldata\n    ) internal pure {\n        mach.status = MachineStatus.FINISHED;\n    }\n\n    function isPowerOfTwo(uint256 value) internal pure returns (bool) {\n        return value != 0 && (value & (value - 1) == 0);\n    }\n\n    function proveLastLeaf(\n        Machine memory mach,\n        uint256 offset,\n        bytes calldata proof\n    )\n        internal\n        pure\n        returns (uint256 leaf, MerkleProof memory leafProof, MerkleProof memory zeroProof)\n    {\n        string memory prefix = \"Module merkle tree:\";\n        bytes32 root = mach.modulesRoot;\n\n        {\n            Module memory leafModule;\n            uint32 leaf32;\n            (leafModule, offset) = Deserialize.module(proof, offset);\n            (leaf32, offset) = Deserialize.u32(proof, offset);\n            (leafProof, offset) = Deserialize.merkleProof(proof, offset);\n            leaf = uint256(leaf32);\n\n            bytes32 compRoot = leafProof.computeRootFromModule(leaf, leafModule);\n            require(compRoot == root, \"WRONG_ROOT_FOR_LEAF\");\n        }\n\n        // if tree is unbalanced, check that the next leaf is 0\n        bool balanced = isPowerOfTwo(leaf + 1);\n        if (balanced) {\n            require(1 << leafProof.counterparts.length == leaf + 1, \"WRONG_LEAF\");\n        } else {\n            (zeroProof, offset) = Deserialize.merkleProof(proof, offset);\n            bytes32 compRoot = zeroProof.computeRootUnsafe(leaf + 1, 0, prefix);\n            require(compRoot == root, \"WRONG_ROOT_FOR_ZERO\");\n        }\n\n        return (leaf, leafProof, zeroProof);\n    }\n\n    function executeLinkModule(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata,\n        bytes calldata proof\n    ) internal pure {\n        string memory prefix = \"Module merkle tree:\";\n        bytes32 root = mach.modulesRoot;\n\n        uint256 pointer = mach.valueStack.pop().assumeI32();\n        if (!mod.moduleMemory.isValidLeaf(pointer)) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        (bytes32 userMod, uint256 offset, ) = mod.moduleMemory.proveLeaf(\n            pointer / LEAF_SIZE,\n            proof,\n            0\n        );\n\n        (uint256 leaf, , MerkleProof memory zeroProof) = proveLastLeaf(mach, offset, proof);\n\n        bool balanced = isPowerOfTwo(leaf + 1);\n        if (balanced) {\n            mach.modulesRoot = MerkleProofLib.growToNewRoot(root, leaf + 1, userMod, 0, prefix);\n        } else {\n            mach.modulesRoot = zeroProof.computeRootUnsafe(leaf + 1, userMod, prefix);\n        }\n\n        mach.valueStack.push(ValueLib.newI32(uint32(leaf + 1)));\n    }\n\n    function executeUnlinkModule(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory,\n        Instruction calldata,\n        bytes calldata proof\n    ) internal pure {\n        string memory prefix = \"Module merkle tree:\";\n\n        (uint256 leaf, MerkleProof memory leafProof, ) = proveLastLeaf(mach, 0, proof);\n\n        bool shrink = isPowerOfTwo(leaf);\n        if (shrink) {\n            mach.modulesRoot = leafProof.counterparts[leafProof.counterparts.length - 1];\n        } else {\n            mach.modulesRoot = leafProof.computeRootUnsafe(leaf, 0, prefix);\n        }\n    }\n\n    function executeGlobalStateAccess(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) internal pure {\n        uint16 opcode = inst.opcode;\n\n        GlobalState memory state;\n        uint256 proofOffset = 0;\n        (state, proofOffset) = Deserialize.globalState(proof, proofOffset);\n        require(state.hash() == mach.globalStateHash, \"BAD_GLOBAL_STATE\");\n\n        if (\n            opcode == Instructions.GET_GLOBAL_STATE_BYTES32 ||\n            opcode == Instructions.SET_GLOBAL_STATE_BYTES32\n        ) {\n            executeGetOrSetBytes32(mach, mod, state, inst, proof[proofOffset:]);\n        } else if (opcode == Instructions.GET_GLOBAL_STATE_U64) {\n            executeGetU64(mach, state);\n        } else if (opcode == Instructions.SET_GLOBAL_STATE_U64) {\n            executeSetU64(mach, state);\n        } else {\n            revert(\"INVALID_GLOBALSTATE_OPCODE\");\n        }\n\n        mach.globalStateHash = state.hash();\n    }\n\n    function executeNewCoThread(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory,\n        Instruction calldata,\n        bytes calldata\n    ) internal pure {\n        if (mach.recoveryPc != MachineLib.NO_RECOVERY_PC) {\n            // cannot create new cothread from inside cothread\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        mach.frameMultiStack.pushNew();\n        mach.valueMultiStack.pushNew();\n    }\n\n    function provePopCothread(MultiStack memory multi, bytes calldata proof) internal pure {\n        uint256 proofOffset = 0;\n        bytes32 newInactiveCoThread;\n        bytes32 newRemaining;\n        (newInactiveCoThread, proofOffset) = Deserialize.b32(proof, proofOffset);\n        (newRemaining, proofOffset) = Deserialize.b32(proof, proofOffset);\n        if (newInactiveCoThread == MultiStackLib.NO_STACK_HASH) {\n            require(newRemaining == bytes32(0), \"WRONG_COTHREAD_EMPTY\");\n            require(multi.remainingHash == bytes32(0), \"WRONG_COTHREAD_EMPTY\");\n        } else {\n            require(\n                keccak256(abi.encodePacked(\"cothread:\", newInactiveCoThread, newRemaining)) ==\n                    multi.remainingHash,\n                \"WRONG_COTHREAD_POP\"\n            );\n        }\n        multi.remainingHash = newRemaining;\n        multi.inactiveStackHash = newInactiveCoThread;\n    }\n\n    function executePopCoThread(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory,\n        Instruction calldata,\n        bytes calldata proof\n    ) internal pure {\n        if (mach.recoveryPc != MachineLib.NO_RECOVERY_PC) {\n            // cannot pop cothread from inside cothread\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        if (mach.frameMultiStack.inactiveStackHash == MultiStackLib.NO_STACK_HASH) {\n            // cannot pop cothread if there isn't one\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        provePopCothread(mach.valueMultiStack, proof);\n        provePopCothread(mach.frameMultiStack, proof[64:]);\n    }\n\n    function executeSwitchCoThread(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory,\n        Instruction calldata inst,\n        bytes calldata\n    ) internal pure {\n        if (mach.frameMultiStack.inactiveStackHash == MultiStackLib.NO_STACK_HASH) {\n            // cannot switch cothread if there isn't one\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        if (inst.argumentData == 0) {\n            if (mach.recoveryPc == MachineLib.NO_RECOVERY_PC) {\n                // switching to main thread, from main thread\n                mach.status = MachineStatus.ERRORED;\n                return;\n            }\n            mach.recoveryPc = MachineLib.NO_RECOVERY_PC;\n        } else {\n            if (mach.recoveryPc != MachineLib.NO_RECOVERY_PC) {\n                // switching from cothread to cothread\n                mach.status = MachineStatus.ERRORED;\n                return;\n            }\n            mach.setRecoveryFromPc(uint32(inst.argumentData));\n        }\n        mach.switchCoThreadStacks();\n    }\n\n    function executeOneStep(\n        ExecutionContext calldata execCtx,\n        Machine calldata startMach,\n        Module calldata startMod,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) external view override returns (Machine memory mach, Module memory mod) {\n        mach = startMach;\n        mod = startMod;\n\n        uint16 opcode = inst.opcode;\n\n        function(\n            ExecutionContext calldata,\n            Machine memory,\n            Module memory,\n            Instruction calldata,\n            bytes calldata\n        ) internal view impl;\n\n        if (\n            opcode >= Instructions.GET_GLOBAL_STATE_BYTES32 &&\n            opcode <= Instructions.SET_GLOBAL_STATE_U64\n        ) {\n            impl = executeGlobalStateAccess;\n        } else if (opcode == Instructions.READ_PRE_IMAGE) {\n            impl = executeReadPreImage;\n        } else if (opcode == Instructions.READ_INBOX_MESSAGE) {\n            impl = executeReadInboxMessage;\n        } else if (opcode == Instructions.HALT_AND_SET_FINISHED) {\n            impl = executeHaltAndSetFinished;\n        } else if (opcode == Instructions.LINK_MODULE) {\n            impl = executeLinkModule;\n        } else if (opcode == Instructions.UNLINK_MODULE) {\n            impl = executeUnlinkModule;\n        } else if (opcode == Instructions.NEW_COTHREAD) {\n            impl = executeNewCoThread;\n        } else if (opcode == Instructions.POP_COTHREAD) {\n            impl = executePopCoThread;\n        } else if (opcode == Instructions.SWITCH_COTHREAD) {\n            impl = executeSwitchCoThread;\n        } else {\n            revert(\"INVALID_MEMORY_OPCODE\");\n        }\n\n        impl(execCtx, mach, mod, inst, proof);\n    }\n}\n"}, "src/state/Deserialize.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./Value.sol\";\nimport \"./ValueStack.sol\";\nimport \"./Machine.sol\";\nimport \"./MultiStack.sol\";\nimport \"./Instructions.sol\";\nimport \"./StackFrame.sol\";\nimport \"./MerkleProof.sol\";\nimport \"./ModuleMemoryCompact.sol\";\nimport \"./Module.sol\";\nimport \"./GlobalState.sol\";\n\nlibrary Deserialize {\n    function u8(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (uint8 ret, uint256 offset)\n    {\n        offset = startOffset;\n        ret = uint8(proof[offset]);\n        offset++;\n    }\n\n    function u16(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (uint16 ret, uint256 offset)\n    {\n        offset = startOffset;\n        for (uint256 i = 0; i < 16 / 8; i++) {\n            ret <<= 8;\n            ret |= uint8(proof[offset]);\n            offset++;\n        }\n    }\n\n    function u32(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (uint32 ret, uint256 offset)\n    {\n        offset = startOffset;\n        for (uint256 i = 0; i < 32 / 8; i++) {\n            ret <<= 8;\n            ret |= uint8(proof[offset]);\n            offset++;\n        }\n    }\n\n    function u64(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (uint64 ret, uint256 offset)\n    {\n        offset = startOffset;\n        for (uint256 i = 0; i < 64 / 8; i++) {\n            ret <<= 8;\n            ret |= uint8(proof[offset]);\n            offset++;\n        }\n    }\n\n    function u256(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (uint256 ret, uint256 offset)\n    {\n        offset = startOffset;\n        for (uint256 i = 0; i < 256 / 8; i++) {\n            ret <<= 8;\n            ret |= uint8(proof[offset]);\n            offset++;\n        }\n    }\n\n    function b32(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (bytes32 ret, uint256 offset)\n    {\n        offset = startOffset;\n        uint256 retInt;\n        (retInt, offset) = u256(proof, offset);\n        ret = bytes32(retInt);\n    }\n\n    function boolean(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (bool ret, uint256 offset)\n    {\n        offset = startOffset;\n        ret = uint8(proof[offset]) != 0;\n        offset++;\n    }\n\n    function value(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (Value memory val, uint256 offset)\n    {\n        offset = startOffset;\n        uint8 typeInt = uint8(proof[offset]);\n        offset++;\n        require(typeInt <= uint8(ValueLib.maxValueType()), \"BAD_VALUE_TYPE\");\n        uint256 contents;\n        (contents, offset) = u256(proof, offset);\n        val = Value({valueType: ValueType(typeInt), contents: contents});\n    }\n\n    function valueStack(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (ValueStack memory stack, uint256 offset)\n    {\n        offset = startOffset;\n        bytes32 remainingHash;\n        (remainingHash, offset) = b32(proof, offset);\n        uint256 provedLength;\n        (provedLength, offset) = u256(proof, offset);\n        Value[] memory proved = new Value[](provedLength);\n        for (uint256 i = 0; i < proved.length; i++) {\n            (proved[i], offset) = value(proof, offset);\n        }\n        stack = ValueStack({proved: ValueArray(proved), remainingHash: remainingHash});\n    }\n\n    function multiStack(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (MultiStack memory multistack, uint256 offset)\n    {\n        offset = startOffset;\n        bytes32 inactiveStackHash;\n        (inactiveStackHash, offset) = b32(proof, offset);\n        bytes32 remainingHash;\n        (remainingHash, offset) = b32(proof, offset);\n        multistack = MultiStack({\n            inactiveStackHash: inactiveStackHash,\n            remainingHash: remainingHash\n        });\n    }\n\n    function instructions(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (Instruction[] memory code, uint256 offset)\n    {\n        offset = startOffset;\n        uint8 count;\n        (count, offset) = u8(proof, offset);\n        code = new Instruction[](count);\n\n        for (uint256 i = 0; i < uint256(count); i++) {\n            uint16 opcode;\n            uint256 data;\n            (opcode, offset) = u16(proof, offset);\n            (data, offset) = u256(proof, offset);\n            code[i] = Instruction({opcode: opcode, argumentData: data});\n        }\n    }\n\n    function stackFrame(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (StackFrame memory window, uint256 offset)\n    {\n        offset = startOffset;\n        Value memory returnPc;\n        bytes32 localsMerkleRoot;\n        uint32 callerModule;\n        uint32 callerModuleInternals;\n        (returnPc, offset) = value(proof, offset);\n        (localsMerkleRoot, offset) = b32(proof, offset);\n        (callerModule, offset) = u32(proof, offset);\n        (callerModuleInternals, offset) = u32(proof, offset);\n        window = StackFrame({\n            returnPc: returnPc,\n            localsMerkleRoot: localsMerkleRoot,\n            callerModule: callerModule,\n            callerModuleInternals: callerModuleInternals\n        });\n    }\n\n    function stackFrameWindow(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (StackFrameWindow memory window, uint256 offset)\n    {\n        offset = startOffset;\n        bytes32 remainingHash;\n        (remainingHash, offset) = b32(proof, offset);\n        StackFrame[] memory proved;\n        if (proof[offset] != 0) {\n            offset++;\n            proved = new StackFrame[](1);\n            (proved[0], offset) = stackFrame(proof, offset);\n        } else {\n            offset++;\n            proved = new StackFrame[](0);\n        }\n        window = StackFrameWindow({proved: proved, remainingHash: remainingHash});\n    }\n\n    function moduleMemory(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (ModuleMemory memory mem, uint256 offset)\n    {\n        offset = startOffset;\n        uint64 size;\n        uint64 maxSize;\n        bytes32 root;\n        (size, offset) = u64(proof, offset);\n        (maxSize, offset) = u64(proof, offset);\n        (root, offset) = b32(proof, offset);\n        mem = ModuleMemory({size: size, maxSize: maxSize, merkleRoot: root});\n    }\n\n    function module(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (Module memory mod, uint256 offset)\n    {\n        offset = startOffset;\n        bytes32 globalsMerkleRoot;\n        ModuleMemory memory mem;\n        bytes32 tablesMerkleRoot;\n        bytes32 functionsMerkleRoot;\n        bytes32 extraHash;\n        uint32 internalsOffset;\n        (globalsMerkleRoot, offset) = b32(proof, offset);\n        (mem, offset) = moduleMemory(proof, offset);\n        (tablesMerkleRoot, offset) = b32(proof, offset);\n        (functionsMerkleRoot, offset) = b32(proof, offset);\n        (extraHash, offset) = b32(proof, offset);\n        (internalsOffset, offset) = u32(proof, offset);\n        mod = Module({\n            globalsMerkleRoot: globalsMerkleRoot,\n            moduleMemory: mem,\n            tablesMerkleRoot: tablesMerkleRoot,\n            functionsMerkleRoot: functionsMerkleRoot,\n            extraHash: extraHash,\n            internalsOffset: internalsOffset\n        });\n    }\n\n    function globalState(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (GlobalState memory state, uint256 offset)\n    {\n        offset = startOffset;\n\n        // using constant ints for array size requires newer solidity\n        bytes32[2] memory bytes32Vals;\n        uint64[2] memory u64Vals;\n\n        for (uint8 i = 0; i < GlobalStateLib.BYTES32_VALS_NUM; i++) {\n            (bytes32Vals[i], offset) = b32(proof, offset);\n        }\n        for (uint8 i = 0; i < GlobalStateLib.U64_VALS_NUM; i++) {\n            (u64Vals[i], offset) = u64(proof, offset);\n        }\n        state = GlobalState({bytes32Vals: bytes32Vals, u64Vals: u64Vals});\n    }\n\n    function machine(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (Machine memory mach, uint256 offset)\n    {\n        offset = startOffset;\n        {\n            MachineStatus status;\n            {\n                uint8 statusU8;\n                (statusU8, offset) = u8(proof, offset);\n                if (statusU8 == 0) {\n                    status = MachineStatus.RUNNING;\n                } else if (statusU8 == 1) {\n                    status = MachineStatus.FINISHED;\n                } else if (statusU8 == 2) {\n                    status = MachineStatus.ERRORED;\n                } else if (statusU8 == 3) {\n                    status = MachineStatus.TOO_FAR;\n                } else {\n                    revert(\"UNKNOWN_MACH_STATUS\");\n                }\n            }\n            ValueStack memory values;\n            ValueStack memory internalStack;\n            MultiStack memory valuesMulti;\n            StackFrameWindow memory frameStack;\n            MultiStack memory framesMulti;\n            (values, offset) = valueStack(proof, offset);\n            (valuesMulti, offset) = multiStack(proof, offset);\n            (internalStack, offset) = valueStack(proof, offset);\n            (frameStack, offset) = stackFrameWindow(proof, offset);\n            (framesMulti, offset) = multiStack(proof, offset);\n            mach = Machine({\n                status: status,\n                valueStack: values,\n                valueMultiStack: valuesMulti,\n                internalStack: internalStack,\n                frameStack: frameStack,\n                frameMultiStack: framesMulti,\n                globalStateHash: bytes32(0), // filled later\n                moduleIdx: 0, // filled later\n                functionIdx: 0, // filled later\n                functionPc: 0, // filled later\n                recoveryPc: bytes32(0), // filled later\n                modulesRoot: bytes32(0) // filled later\n            });\n        }\n        (mach.globalStateHash, offset) = b32(proof, offset);\n        (mach.moduleIdx, offset) = u32(proof, offset);\n        (mach.functionIdx, offset) = u32(proof, offset);\n        (mach.functionPc, offset) = u32(proof, offset);\n        (mach.recoveryPc, offset) = b32(proof, offset);\n        (mach.modulesRoot, offset) = b32(proof, offset);\n    }\n\n    function merkleProof(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (MerkleProof memory merkle, uint256 offset)\n    {\n        offset = startOffset;\n        uint8 length;\n        (length, offset) = u8(proof, offset);\n        bytes32[] memory counterparts = new bytes32[](length);\n        for (uint8 i = 0; i < length; i++) {\n            (counterparts[i], offset) = b32(proof, offset);\n        }\n        merkle = MerkleProof(counterparts);\n    }\n}\n"}, "src/state/GlobalState.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nstruct GlobalState {\n    bytes32[2] bytes32Vals;\n    uint64[2] u64Vals;\n}\n\nlibrary GlobalStateLib {\n    uint16 internal constant BYTES32_VALS_NUM = 2;\n    uint16 internal constant U64_VALS_NUM = 2;\n\n    function hash(GlobalState memory state) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    \"Global state:\",\n                    state.bytes32Vals[0],\n                    state.bytes32Vals[1],\n                    state.u64Vals[0],\n                    state.u64Vals[1]\n                )\n            );\n    }\n\n    function getBlockHash(GlobalState memory state) internal pure returns (bytes32) {\n        return state.bytes32Vals[0];\n    }\n\n    function getSendRoot(GlobalState memory state) internal pure returns (bytes32) {\n        return state.bytes32Vals[1];\n    }\n\n    function getInboxPosition(GlobalState memory state) internal pure returns (uint64) {\n        return state.u64Vals[0];\n    }\n\n    function getPositionInMessage(GlobalState memory state) internal pure returns (uint64) {\n        return state.u64Vals[1];\n    }\n\n    function isEmpty(GlobalState calldata state) internal pure returns (bool) {\n        return (state.bytes32Vals[0] == bytes32(0) &&\n            state.bytes32Vals[1] == bytes32(0) &&\n            state.u64Vals[0] == 0 &&\n            state.u64Vals[1] == 0);\n    }\n}\n"}, "src/state/Instructions.sol": {"content": "// Copyright 2021-2023, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nstruct Instruction {\n    uint16 opcode;\n    uint256 argumentData;\n}\n\nlibrary Instructions {\n    uint16 internal constant UNREACHABLE = 0x00;\n    uint16 internal constant NOP = 0x01;\n    uint16 internal constant RETURN = 0x0F;\n    uint16 internal constant CALL = 0x10;\n    uint16 internal constant CALL_INDIRECT = 0x11;\n    uint16 internal constant LOCAL_GET = 0x20;\n    uint16 internal constant LOCAL_SET = 0x21;\n    uint16 internal constant GLOBAL_GET = 0x23;\n    uint16 internal constant GLOBAL_SET = 0x24;\n\n    uint16 internal constant I32_LOAD = 0x28;\n    uint16 internal constant I64_LOAD = 0x29;\n    uint16 internal constant F32_LOAD = 0x2A;\n    uint16 internal constant F64_LOAD = 0x2B;\n    uint16 internal constant I32_LOAD8_S = 0x2C;\n    uint16 internal constant I32_LOAD8_U = 0x2D;\n    uint16 internal constant I32_LOAD16_S = 0x2E;\n    uint16 internal constant I32_LOAD16_U = 0x2F;\n    uint16 internal constant I64_LOAD8_S = 0x30;\n    uint16 internal constant I64_LOAD8_U = 0x31;\n    uint16 internal constant I64_LOAD16_S = 0x32;\n    uint16 internal constant I64_LOAD16_U = 0x33;\n    uint16 internal constant I64_LOAD32_S = 0x34;\n    uint16 internal constant I64_LOAD32_U = 0x35;\n\n    uint16 internal constant I32_STORE = 0x36;\n    uint16 internal constant I64_STORE = 0x37;\n    uint16 internal constant F32_STORE = 0x38;\n    uint16 internal constant F64_STORE = 0x39;\n    uint16 internal constant I32_STORE8 = 0x3A;\n    uint16 internal constant I32_STORE16 = 0x3B;\n    uint16 internal constant I64_STORE8 = 0x3C;\n    uint16 internal constant I64_STORE16 = 0x3D;\n    uint16 internal constant I64_STORE32 = 0x3E;\n\n    uint16 internal constant MEMORY_SIZE = 0x3F;\n    uint16 internal constant MEMORY_GROW = 0x40;\n\n    uint16 internal constant DROP = 0x1A;\n    uint16 internal constant SELECT = 0x1B;\n    uint16 internal constant I32_CONST = 0x41;\n    uint16 internal constant I64_CONST = 0x42;\n    uint16 internal constant F32_CONST = 0x43;\n    uint16 internal constant F64_CONST = 0x44;\n    uint16 internal constant I32_EQZ = 0x45;\n    uint16 internal constant I32_RELOP_BASE = 0x46;\n    uint16 internal constant IRELOP_EQ = 0;\n    uint16 internal constant IRELOP_NE = 1;\n    uint16 internal constant IRELOP_LT_S = 2;\n    uint16 internal constant IRELOP_LT_U = 3;\n    uint16 internal constant IRELOP_GT_S = 4;\n    uint16 internal constant IRELOP_GT_U = 5;\n    uint16 internal constant IRELOP_LE_S = 6;\n    uint16 internal constant IRELOP_LE_U = 7;\n    uint16 internal constant IRELOP_GE_S = 8;\n    uint16 internal constant IRELOP_GE_U = 9;\n    uint16 internal constant IRELOP_LAST = IRELOP_GE_U;\n\n    uint16 internal constant I64_EQZ = 0x50;\n    uint16 internal constant I64_RELOP_BASE = 0x51;\n\n    uint16 internal constant I32_UNOP_BASE = 0x67;\n    uint16 internal constant IUNOP_CLZ = 0;\n    uint16 internal constant IUNOP_CTZ = 1;\n    uint16 internal constant IUNOP_POPCNT = 2;\n    uint16 internal constant IUNOP_LAST = IUNOP_POPCNT;\n\n    uint16 internal constant I32_ADD = 0x6A;\n    uint16 internal constant I32_SUB = 0x6B;\n    uint16 internal constant I32_MUL = 0x6C;\n    uint16 internal constant I32_DIV_S = 0x6D;\n    uint16 internal constant I32_DIV_U = 0x6E;\n    uint16 internal constant I32_REM_S = 0x6F;\n    uint16 internal constant I32_REM_U = 0x70;\n    uint16 internal constant I32_AND = 0x71;\n    uint16 internal constant I32_OR = 0x72;\n    uint16 internal constant I32_XOR = 0x73;\n    uint16 internal constant I32_SHL = 0x74;\n    uint16 internal constant I32_SHR_S = 0x75;\n    uint16 internal constant I32_SHR_U = 0x76;\n    uint16 internal constant I32_ROTL = 0x77;\n    uint16 internal constant I32_ROTR = 0x78;\n\n    uint16 internal constant I64_UNOP_BASE = 0x79;\n\n    uint16 internal constant I64_ADD = 0x7C;\n    uint16 internal constant I64_SUB = 0x7D;\n    uint16 internal constant I64_MUL = 0x7E;\n    uint16 internal constant I64_DIV_S = 0x7F;\n    uint16 internal constant I64_DIV_U = 0x80;\n    uint16 internal constant I64_REM_S = 0x81;\n    uint16 internal constant I64_REM_U = 0x82;\n    uint16 internal constant I64_AND = 0x83;\n    uint16 internal constant I64_OR = 0x84;\n    uint16 internal constant I64_XOR = 0x85;\n    uint16 internal constant I64_SHL = 0x86;\n    uint16 internal constant I64_SHR_S = 0x87;\n    uint16 internal constant I64_SHR_U = 0x88;\n    uint16 internal constant I64_ROTL = 0x89;\n    uint16 internal constant I64_ROTR = 0x8A;\n\n    uint16 internal constant I32_WRAP_I64 = 0xA7;\n    uint16 internal constant I64_EXTEND_I32_S = 0xAC;\n    uint16 internal constant I64_EXTEND_I32_U = 0xAD;\n\n    uint16 internal constant I32_REINTERPRET_F32 = 0xBC;\n    uint16 internal constant I64_REINTERPRET_F64 = 0xBD;\n    uint16 internal constant F32_REINTERPRET_I32 = 0xBE;\n    uint16 internal constant F64_REINTERPRET_I64 = 0xBF;\n\n    uint16 internal constant I32_EXTEND_8S = 0xC0;\n    uint16 internal constant I32_EXTEND_16S = 0xC1;\n    uint16 internal constant I64_EXTEND_8S = 0xC2;\n    uint16 internal constant I64_EXTEND_16S = 0xC3;\n    uint16 internal constant I64_EXTEND_32S = 0xC4;\n\n    uint16 internal constant INIT_FRAME = 0x8002;\n    uint16 internal constant ARBITRARY_JUMP = 0x8003;\n    uint16 internal constant ARBITRARY_JUMP_IF = 0x8004;\n    uint16 internal constant MOVE_FROM_STACK_TO_INTERNAL = 0x8005;\n    uint16 internal constant MOVE_FROM_INTERNAL_TO_STACK = 0x8006;\n    uint16 internal constant DUP = 0x8008;\n    uint16 internal constant CROSS_MODULE_CALL = 0x8009;\n    uint16 internal constant CALLER_MODULE_INTERNAL_CALL = 0x800A;\n    uint16 internal constant CROSS_MODULE_FORWARD = 0x800B;\n    uint16 internal constant CROSS_MODULE_INTERNAL_CALL = 0x800C;\n\n    uint16 internal constant GET_GLOBAL_STATE_BYTES32 = 0x8010;\n    uint16 internal constant SET_GLOBAL_STATE_BYTES32 = 0x8011;\n    uint16 internal constant GET_GLOBAL_STATE_U64 = 0x8012;\n    uint16 internal constant SET_GLOBAL_STATE_U64 = 0x8013;\n\n    uint16 internal constant READ_PRE_IMAGE = 0x8020;\n    uint16 internal constant READ_INBOX_MESSAGE = 0x8021;\n    uint16 internal constant HALT_AND_SET_FINISHED = 0x8022;\n    uint16 internal constant LINK_MODULE = 0x8023;\n    uint16 internal constant UNLINK_MODULE = 0x8024;\n\n    uint16 internal constant NEW_COTHREAD = 0x8030;\n    uint16 internal constant POP_COTHREAD = 0x8031;\n    uint16 internal constant SWITCH_COTHREAD = 0x8032;\n\n    uint256 internal constant INBOX_INDEX_SEQUENCER = 0;\n    uint256 internal constant INBOX_INDEX_DELAYED = 1;\n\n    function hash(Instruction[] memory code) internal pure returns (bytes32) {\n        // To avoid quadratic expense, we declare a `bytes` early and populate its contents.\n        bytes memory data = new bytes(13 + 1 + 34 * code.length);\n        assembly {\n            // Represents the string \"Instructions:\", which we place after the length word.\n            mstore(\n                add(data, 32),\n                0x496e737472756374696f6e733a00000000000000000000000000000000000000\n            )\n        }\n\n        // write the instruction count\n        uint256 offset = 13;\n        data[offset] = bytes1(uint8(code.length));\n        offset++;\n\n        // write each instruction\n        for (uint256 i = 0; i < code.length; i++) {\n            Instruction memory inst = code[i];\n            data[offset] = bytes1(uint8(inst.opcode >> 8));\n            data[offset + 1] = bytes1(uint8(inst.opcode));\n            offset += 2;\n            uint256 argumentData = inst.argumentData;\n            assembly {\n                mstore(add(add(data, 32), offset), argumentData)\n            }\n            offset += 32;\n        }\n        return keccak256(data);\n    }\n}\n"}, "src/state/Machine.sol": {"content": "// Copyright 2021-2023, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./ValueStack.sol\";\nimport \"./Instructions.sol\";\nimport \"./MultiStack.sol\";\nimport \"./StackFrame.sol\";\n\nenum MachineStatus {\n    RUNNING,\n    FINISHED,\n    ERRORED,\n    TOO_FAR\n}\n\nstruct Machine {\n    MachineStatus status;\n    ValueStack valueStack;\n    MultiStack valueMultiStack;\n    ValueStack internalStack;\n    StackFrameWindow frameStack;\n    MultiStack frameMultiStack;\n    bytes32 globalStateHash;\n    uint32 moduleIdx;\n    uint32 functionIdx;\n    uint32 functionPc;\n    bytes32 recoveryPc;\n    bytes32 modulesRoot;\n}\n\nlibrary MachineLib {\n    using StackFrameLib for StackFrameWindow;\n    using ValueStackLib for ValueStack;\n    using MultiStackLib for MultiStack;\n\n    bytes32 internal constant NO_RECOVERY_PC = ~bytes32(0);\n\n    function hash(Machine memory mach) internal pure returns (bytes32) {\n        // Warning: the non-running hashes are replicated in Challenge\n        if (mach.status == MachineStatus.RUNNING) {\n            bytes32 valueMultiHash = mach.valueMultiStack.hash(\n                mach.valueStack.hash(),\n                mach.recoveryPc != NO_RECOVERY_PC\n            );\n            bytes32 frameMultiHash = mach.frameMultiStack.hash(\n                mach.frameStack.hash(),\n                mach.recoveryPc != NO_RECOVERY_PC\n            );\n            bytes memory preimage = abi.encodePacked(\n                \"Machine running:\",\n                valueMultiHash,\n                mach.internalStack.hash(),\n                frameMultiHash,\n                mach.globalStateHash,\n                mach.moduleIdx,\n                mach.functionIdx,\n                mach.functionPc,\n                mach.recoveryPc,\n                mach.modulesRoot\n            );\n            return keccak256(preimage);\n        } else if (mach.status == MachineStatus.FINISHED) {\n            return keccak256(abi.encodePacked(\"Machine finished:\", mach.globalStateHash));\n        } else if (mach.status == MachineStatus.ERRORED) {\n            return keccak256(abi.encodePacked(\"Machine errored:\"));\n        } else if (mach.status == MachineStatus.TOO_FAR) {\n            return keccak256(abi.encodePacked(\"Machine too far:\"));\n        } else {\n            revert(\"BAD_MACH_STATUS\");\n        }\n    }\n\n    function switchCoThreadStacks(Machine memory mach) internal pure {\n        bytes32 newActiveValue = mach.valueMultiStack.inactiveStackHash;\n        bytes32 newActiveFrame = mach.frameMultiStack.inactiveStackHash;\n        if (\n            newActiveFrame == MultiStackLib.NO_STACK_HASH ||\n            newActiveValue == MultiStackLib.NO_STACK_HASH\n        ) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        mach.frameMultiStack.inactiveStackHash = mach.frameStack.hash();\n        mach.valueMultiStack.inactiveStackHash = mach.valueStack.hash();\n        mach.frameStack.overwrite(newActiveFrame);\n        mach.valueStack.overwrite(newActiveValue);\n    }\n\n    function setPcFromData(Machine memory mach, uint256 data) internal pure returns (bool) {\n        if (data >> 96 != 0) {\n            return false;\n        }\n\n        mach.functionPc = uint32(data);\n        mach.functionIdx = uint32(data >> 32);\n        mach.moduleIdx = uint32(data >> 64);\n        return true;\n    }\n\n    function setPcFromRecovery(Machine memory mach) internal pure returns (bool) {\n        if (!setPcFromData(mach, uint256(mach.recoveryPc))) {\n            return false;\n        }\n        mach.recoveryPc = NO_RECOVERY_PC;\n        return true;\n    }\n\n    function setRecoveryFromPc(Machine memory mach, uint32 offset) internal pure returns (bool) {\n        if (mach.recoveryPc != NO_RECOVERY_PC) {\n            return false;\n        }\n\n        uint256 result;\n        result = uint256(mach.moduleIdx) << 64;\n        result = result | (uint256(mach.functionIdx) << 32);\n        result = result | uint256(mach.functionPc + offset - 1);\n        mach.recoveryPc = bytes32(result);\n        return true;\n    }\n\n    function setPc(Machine memory mach, Value memory pc) internal pure {\n        if (pc.valueType == ValueType.REF_NULL) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        if (pc.valueType != ValueType.INTERNAL_REF) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        if (!setPcFromData(mach, pc.contents)) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n    }\n}\n"}, "src/state/MerkleProof.sol": {"content": "// Copyright 2021-2023, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./Value.sol\";\nimport \"./Instructions.sol\";\nimport \"./Module.sol\";\n\nstruct MerkleProof {\n    bytes32[] counterparts;\n}\n\nlibrary MerkleProofLib {\n    using ModuleLib for Module;\n    using ValueLib for Value;\n\n    function computeRootFromValue(\n        MerkleProof memory proof,\n        uint256 index,\n        Value memory leaf\n    ) internal pure returns (bytes32) {\n        return computeRootUnsafe(proof, index, leaf.hash(), \"Value merkle tree:\");\n    }\n\n    function computeRootFromInstructions(\n        MerkleProof memory proof,\n        uint256 index,\n        Instruction[] memory code\n    ) internal pure returns (bytes32) {\n        return computeRootUnsafe(proof, index, Instructions.hash(code), \"Instruction merkle tree:\");\n    }\n\n    function computeRootFromFunction(\n        MerkleProof memory proof,\n        uint256 index,\n        bytes32 codeRoot\n    ) internal pure returns (bytes32) {\n        bytes32 h = keccak256(abi.encodePacked(\"Function:\", codeRoot));\n        return computeRootUnsafe(proof, index, h, \"Function merkle tree:\");\n    }\n\n    function computeRootFromMemory(\n        MerkleProof memory proof,\n        uint256 index,\n        bytes32 contents\n    ) internal pure returns (bytes32) {\n        bytes32 h = keccak256(abi.encodePacked(\"Memory leaf:\", contents));\n        return computeRootUnsafe(proof, index, h, \"Memory merkle tree:\");\n    }\n\n    function computeRootFromElement(\n        MerkleProof memory proof,\n        uint256 index,\n        bytes32 funcTypeHash,\n        Value memory val\n    ) internal pure returns (bytes32) {\n        bytes32 h = keccak256(abi.encodePacked(\"Table element:\", funcTypeHash, val.hash()));\n        return computeRootUnsafe(proof, index, h, \"Table element merkle tree:\");\n    }\n\n    function computeRootFromTable(\n        MerkleProof memory proof,\n        uint256 index,\n        uint8 tableType,\n        uint64 tableSize,\n        bytes32 elementsRoot\n    ) internal pure returns (bytes32) {\n        bytes32 h = keccak256(abi.encodePacked(\"Table:\", tableType, tableSize, elementsRoot));\n        return computeRootUnsafe(proof, index, h, \"Table merkle tree:\");\n    }\n\n    function computeRootFromModule(\n        MerkleProof memory proof,\n        uint256 index,\n        Module memory mod\n    ) internal pure returns (bytes32) {\n        return computeRootUnsafe(proof, index, mod.hash(), \"Module merkle tree:\");\n    }\n\n    // WARNING: leafHash must be computed in such a way that it cannot be a non-leaf hash.\n    function computeRootUnsafe(\n        MerkleProof memory proof,\n        uint256 index,\n        bytes32 leafHash,\n        string memory prefix\n    ) internal pure returns (bytes32 h) {\n        h = leafHash;\n        for (uint256 layer = 0; layer < proof.counterparts.length; layer++) {\n            if (index & 1 == 0) {\n                h = keccak256(abi.encodePacked(prefix, h, proof.counterparts[layer]));\n            } else {\n                h = keccak256(abi.encodePacked(prefix, proof.counterparts[layer], h));\n            }\n            index >>= 1;\n        }\n        require(index == 0, \"PROOF_TOO_SHORT\");\n    }\n\n    function growToNewRoot(\n        bytes32 root,\n        uint256 leaf,\n        bytes32 hash,\n        bytes32 zero,\n        string memory prefix\n    ) internal pure returns (bytes32) {\n        bytes32 h = hash;\n        uint256 node = leaf;\n        while (node > 1) {\n            h = keccak256(abi.encodePacked(prefix, h, zero));\n            zero = keccak256(abi.encodePacked(prefix, zero, zero));\n            node >>= 1;\n        }\n        return keccak256(abi.encodePacked(prefix, root, h));\n    }\n}\n"}, "src/state/Module.sol": {"content": "// Copyright 2021-2023, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./ModuleMemoryCompact.sol\";\n\nstruct Module {\n    bytes32 globalsMerkleRoot;\n    ModuleMemory moduleMemory;\n    bytes32 tablesMerkleRoot;\n    bytes32 functionsMerkleRoot;\n    bytes32 extraHash;\n    uint32 internalsOffset;\n}\n\nlibrary ModuleLib {\n    using ModuleMemoryCompactLib for ModuleMemory;\n\n    function hash(Module memory mod) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    \"Module:\",\n                    mod.globalsMerkleRoot,\n                    mod.moduleMemory.hash(),\n                    mod.tablesMerkleRoot,\n                    mod.functionsMerkleRoot,\n                    mod.extraHash,\n                    mod.internalsOffset\n                )\n            );\n    }\n}\n"}, "src/state/ModuleMemory.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./MerkleProof.sol\";\nimport \"./Deserialize.sol\";\nimport \"./ModuleMemoryCompact.sol\";\n\nlibrary ModuleMemoryLib {\n    using MerkleProofLib for MerkleProof;\n\n    uint256 private constant LEAF_SIZE = 32;\n\n    function hash(ModuleMemory memory mem) internal pure returns (bytes32) {\n        return ModuleMemoryCompactLib.hash(mem);\n    }\n\n    function proveLeaf(\n        ModuleMemory memory mem,\n        uint256 leafIdx,\n        bytes calldata proof,\n        uint256 startOffset\n    )\n        internal\n        pure\n        returns (\n            bytes32 contents,\n            uint256 offset,\n            MerkleProof memory merkle\n        )\n    {\n        offset = startOffset;\n        (contents, offset) = Deserialize.b32(proof, offset);\n        (merkle, offset) = Deserialize.merkleProof(proof, offset);\n        bytes32 recomputedRoot = merkle.computeRootFromMemory(leafIdx, contents);\n        require(recomputedRoot == mem.merkleRoot, \"WRONG_MEM_ROOT\");\n    }\n\n    function isValidLeaf(ModuleMemory memory mem, uint256 pointer) internal pure returns (bool) {\n        return pointer + 32 <= mem.size && pointer % LEAF_SIZE == 0;\n    }\n\n    function pullLeafByte(bytes32 leaf, uint256 idx) internal pure returns (uint8) {\n        require(idx < LEAF_SIZE, \"BAD_PULL_LEAF_BYTE_IDX\");\n        // Take into account that we are casting the leaf to a big-endian integer\n        uint256 leafShift = (LEAF_SIZE - 1 - idx) * 8;\n        return uint8(uint256(leaf) >> leafShift);\n    }\n\n    // loads a big-endian value from memory\n    function load(\n        ModuleMemory memory mem,\n        uint256 start,\n        uint256 width,\n        bytes calldata proof,\n        uint256 proofOffset\n    )\n        internal\n        pure\n        returns (\n            bool err,\n            uint256 value,\n            uint256 offset\n        )\n    {\n        if (start + width > mem.size) {\n            return (true, 0, proofOffset);\n        }\n\n        uint256 lastProvedLeafIdx = ~uint256(0);\n        bytes32 lastProvedLeafContents;\n        uint256 readValue;\n        for (uint256 i = 0; i < width; i++) {\n            uint256 idx = start + i;\n            uint256 leafIdx = idx / LEAF_SIZE;\n            if (leafIdx != lastProvedLeafIdx) {\n                (lastProvedLeafContents, proofOffset, ) = proveLeaf(\n                    mem,\n                    leafIdx,\n                    proof,\n                    proofOffset\n                );\n                lastProvedLeafIdx = leafIdx;\n            }\n            uint256 indexWithinLeaf = idx % LEAF_SIZE;\n            readValue |= uint256(pullLeafByte(lastProvedLeafContents, indexWithinLeaf)) << (i * 8);\n        }\n        return (false, readValue, proofOffset);\n    }\n}\n"}, "src/state/ModuleMemoryCompact.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nstruct ModuleMemory {\n    uint64 size;\n    uint64 maxSize;\n    bytes32 merkleRoot;\n}\n\nlibrary ModuleMemoryCompactLib {\n    function hash(ModuleMemory memory mem) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"Memory:\", mem.size, mem.maxSize, mem.merkleRoot));\n    }\n}\n"}, "src/state/MultiStack.sol": {"content": "// Copyright 2021-2024, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nstruct MultiStack {\n    bytes32 inactiveStackHash; // NO_STACK_HASH if no stack, 0 if empty stack\n    bytes32 remainingHash; // 0 if less than 2 cothreads exist\n}\n\nlibrary MultiStackLib {\n    bytes32 internal constant NO_STACK_HASH = ~bytes32(0);\n\n    function hash(\n        MultiStack memory multi,\n        bytes32 activeStackHash,\n        bool cothread\n    ) internal pure returns (bytes32) {\n        require(activeStackHash != NO_STACK_HASH, \"MULTISTACK_NOSTACK_ACTIVE\");\n        if (cothread) {\n            require(multi.inactiveStackHash != NO_STACK_HASH, \"MULTISTACK_NOSTACK_MAIN\");\n            return\n                keccak256(\n                    abi.encodePacked(\n                        \"multistack:\",\n                        multi.inactiveStackHash,\n                        activeStackHash,\n                        multi.remainingHash\n                    )\n                );\n        } else {\n            return\n                keccak256(\n                    abi.encodePacked(\n                        \"multistack:\",\n                        activeStackHash,\n                        multi.inactiveStackHash,\n                        multi.remainingHash\n                    )\n                );\n        }\n    }\n\n    function setEmpty(MultiStack memory multi) internal pure {\n        multi.inactiveStackHash = NO_STACK_HASH;\n        multi.remainingHash = 0;\n    }\n\n    function pushNew(MultiStack memory multi) internal pure {\n        if (multi.inactiveStackHash != NO_STACK_HASH) {\n            multi.remainingHash = keccak256(\n                abi.encodePacked(\"cothread:\", multi.inactiveStackHash, multi.remainingHash)\n            );\n        }\n        multi.inactiveStackHash = 0;\n    }\n}\n"}, "src/state/StackFrame.sol": {"content": "// Copyright 2021-2023, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./Value.sol\";\n\nstruct StackFrame {\n    Value returnPc;\n    bytes32 localsMerkleRoot;\n    uint32 callerModule;\n    uint32 callerModuleInternals;\n}\n\nstruct StackFrameWindow {\n    StackFrame[] proved;\n    bytes32 remainingHash;\n}\n\nlibrary StackFrameLib {\n    using ValueLib for Value;\n\n    function hash(StackFrame memory frame) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    \"Stack frame:\",\n                    frame.returnPc.hash(),\n                    frame.localsMerkleRoot,\n                    frame.callerModule,\n                    frame.callerModuleInternals\n                )\n            );\n    }\n\n    function hash(StackFrameWindow memory window) internal pure returns (bytes32 h) {\n        h = window.remainingHash;\n        for (uint256 i = 0; i < window.proved.length; i++) {\n            h = keccak256(abi.encodePacked(\"Stack frame stack:\", hash(window.proved[i]), h));\n        }\n    }\n\n    function peek(StackFrameWindow memory window) internal pure returns (StackFrame memory) {\n        require(window.proved.length == 1, \"BAD_WINDOW_LENGTH\");\n        return window.proved[0];\n    }\n\n    function pop(StackFrameWindow memory window) internal pure returns (StackFrame memory frame) {\n        require(window.proved.length == 1, \"BAD_WINDOW_LENGTH\");\n        frame = window.proved[0];\n        window.proved = new StackFrame[](0);\n    }\n\n    function push(StackFrameWindow memory window, StackFrame memory frame) internal pure {\n        StackFrame[] memory newProved = new StackFrame[](window.proved.length + 1);\n        for (uint256 i = 0; i < window.proved.length; i++) {\n            newProved[i] = window.proved[i];\n        }\n        newProved[window.proved.length] = frame;\n        window.proved = newProved;\n    }\n\n    function overwrite(StackFrameWindow memory window, bytes32 root) internal pure {\n        window.remainingHash = root;\n        delete window.proved;\n    }\n}\n"}, "src/state/Value.sol": {"content": "// Copyright 2021-2023, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nenum ValueType {\n    I32,\n    I64,\n    F32,\n    F64,\n    REF_NULL,\n    FUNC_REF,\n    INTERNAL_REF\n}\n\nstruct Value {\n    ValueType valueType;\n    uint256 contents;\n}\n\nlibrary ValueLib {\n    function hash(Value memory val) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"Value:\", val.valueType, val.contents));\n    }\n\n    function maxValueType() internal pure returns (ValueType) {\n        return ValueType.INTERNAL_REF;\n    }\n\n    function assumeI32(Value memory val) internal pure returns (uint32) {\n        uint256 uintval = uint256(val.contents);\n        require(val.valueType == ValueType.I32, \"NOT_I32\");\n        require(uintval < (1 << 32), \"BAD_I32\");\n        return uint32(uintval);\n    }\n\n    function assumeI64(Value memory val) internal pure returns (uint64) {\n        uint256 uintval = uint256(val.contents);\n        require(val.valueType == ValueType.I64, \"NOT_I64\");\n        require(uintval < (1 << 64), \"BAD_I64\");\n        return uint64(uintval);\n    }\n\n    function newRefNull() internal pure returns (Value memory) {\n        return Value({valueType: ValueType.REF_NULL, contents: 0});\n    }\n\n    function newI32(uint32 x) internal pure returns (Value memory) {\n        return Value({valueType: ValueType.I32, contents: uint256(x)});\n    }\n\n    function newI64(uint64 x) internal pure returns (Value memory) {\n        return Value({valueType: ValueType.I64, contents: uint256(x)});\n    }\n\n    function newBoolean(bool x) internal pure returns (Value memory) {\n        if (x) {\n            return newI32(uint32(1));\n        } else {\n            return newI32(uint32(0));\n        }\n    }\n\n    function newPc(\n        uint32 funcPc,\n        uint32 func,\n        uint32 module\n    ) internal pure returns (Value memory) {\n        uint256 data = 0;\n        data |= funcPc;\n        data |= uint256(func) << 32;\n        data |= uint256(module) << 64;\n        return Value({valueType: ValueType.INTERNAL_REF, contents: data});\n    }\n}\n"}, "src/state/ValueArray.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./Value.sol\";\n\nstruct ValueArray {\n    Value[] inner;\n}\n\nlibrary ValueArrayLib {\n    function get(ValueArray memory arr, uint256 index) internal pure returns (Value memory) {\n        return arr.inner[index];\n    }\n\n    function set(\n        ValueArray memory arr,\n        uint256 index,\n        Value memory val\n    ) internal pure {\n        arr.inner[index] = val;\n    }\n\n    function length(ValueArray memory arr) internal pure returns (uint256) {\n        return arr.inner.length;\n    }\n\n    function push(ValueArray memory arr, Value memory val) internal pure {\n        Value[] memory newInner = new Value[](arr.inner.length + 1);\n        for (uint256 i = 0; i < arr.inner.length; i++) {\n            newInner[i] = arr.inner[i];\n        }\n        newInner[arr.inner.length] = val;\n        arr.inner = newInner;\n    }\n\n    function pop(ValueArray memory arr) internal pure returns (Value memory popped) {\n        popped = arr.inner[arr.inner.length - 1];\n        Value[] memory newInner = new Value[](arr.inner.length - 1);\n        for (uint256 i = 0; i < newInner.length; i++) {\n            newInner[i] = arr.inner[i];\n        }\n        arr.inner = newInner;\n    }\n}\n"}, "src/state/ValueStack.sol": {"content": "// Copyright 2021-2023, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./Value.sol\";\nimport \"./ValueArray.sol\";\n\nstruct ValueStack {\n    ValueArray proved;\n    bytes32 remainingHash;\n}\n\nlibrary ValueStackLib {\n    using ValueLib for Value;\n    using ValueArrayLib for ValueArray;\n\n    function hash(ValueStack memory stack) internal pure returns (bytes32 h) {\n        h = stack.remainingHash;\n        uint256 len = stack.proved.length();\n        for (uint256 i = 0; i < len; i++) {\n            h = keccak256(abi.encodePacked(\"Value stack:\", stack.proved.get(i).hash(), h));\n        }\n    }\n\n    function peek(ValueStack memory stack) internal pure returns (Value memory) {\n        uint256 len = stack.proved.length();\n        return stack.proved.get(len - 1);\n    }\n\n    function pop(ValueStack memory stack) internal pure returns (Value memory) {\n        return stack.proved.pop();\n    }\n\n    function push(ValueStack memory stack, Value memory val) internal pure {\n        return stack.proved.push(val);\n    }\n\n    function overwrite(ValueStack memory stack, bytes32 root) internal pure {\n        stack.remainingHash = root;\n        delete stack.proved;\n    }\n}\n"}}, "settings": {"optimizer": {"enabled": true}, "viaIR": false, "outputSelection": {"*": {"*": ["evm.legacyAssembly"]}}, "metadata": {"useLiteralContent": true}, "libraries": {}}}