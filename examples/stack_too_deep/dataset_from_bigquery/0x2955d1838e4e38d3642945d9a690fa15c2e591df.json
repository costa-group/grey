{"language": "Solidity", "settings": {"viaIR": false, "optimizer": {"enabled": true}, "outputSelection": {"*": {"*": ["evm.legacyAssembly"]}}}, "sources": {"corenft/NFTMarketWrap.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\nenum FeeMethod { ProtocolFee, SplitFee }\n\nenum HowToCall { Call, DelegateCall }\n\nenum Side { Buy, Sell }\n\nenum SaleKind { FixedPrice, DutchAuction }\n\n/* An ECDSA signature. */ \nstruct Sig {\n    /* v parameter */\n    uint8 v;\n    /* r parameter */\n    bytes32 r;\n    /* s parameter */\n    bytes32 s;\n}\n\nstruct ArgBytes {\n        \n    bytes calldataBeta1;\n        \n    bytes replacementPattern1;\n            \n    bytes staticExtradata1;\n\n    bytes calldataBeta2;\n        \n    bytes replacementPattern2;\n            \n    bytes staticExtradata2;\n}\n\nstruct Order {\n    /* Exchange address, intended as a versioning mechanism. */\n    address exchange;\n    /* Order maker address. */\n    address maker;\n    /* Order taker address, if specified. */\n    address taker;\n    /* Maker relayer fee of the order, unused for taker order. */\n    uint makerRelayerFee;\n    /* Taker relayer fee of the order, or maximum taker fee for a taker order. */\n    uint takerRelayerFee;\n    /* Maker protocol fee of the order, unused for taker order. */\n    uint makerProtocolFee;\n    /* Taker protocol fee of the order, or maximum taker fee for a taker order. */\n    uint takerProtocolFee;\n    /* Order fee recipient or zero address for taker order. */\n    address feeRecipient;\n    /* Fee method (protocol token or split fee). */\n    FeeMethod feeMethod;\n    /* Side (buy/sell). */\n    Side side;\n    /* Kind of sale. */\n    SaleKind saleKind;\n    /* Target. */\n    address target;\n    /* HowToCall. */\n    HowToCall howToCall;\n    /* Calldata. */\n    bytes calldataBeta;\n    /* Calldata replacement pattern, or an empty byte array for no replacement. */\n    bytes replacementPattern;\n    /* Static call target, zero-address for no static call. */\n    address staticTarget;\n    /* Static call extra data. */\n    bytes staticExtradata;\n    /* Token used to pay for the order, or the zero-address as a sentinel value for Ether. */\n    address paymentToken;\n    /* Base price of the order (in paymentTokens). */\n    uint basePrice;\n    /* Auction extra parameter - minimum bid increment for English auctions, starting/ending price difference. */\n    uint extra;\n    /* Listing timestamp. */\n    uint listingTime;\n    /* Expiration timestamp - 0 for no expiry. */\n    uint expirationTime;\n    /* Order salt, used to prevent duplicate hashes. */\n    uint salt;\n}\n\ninterface Exchange {    \n\n     function atomicMatch_(\n        address[15] calldata addrs,\n        uint[18] calldata uints,\n        uint8[8] calldata feeMethodsSidesKindsHowToCalls,\n        bytes calldata calldataBuy,\n        bytes calldata calldataSell,\n        bytes calldata replacementPatternBuy,\n        bytes calldata replacementPatternSell,\n        bytes calldata staticExtradataBuy,\n        bytes calldata staticExtradataSell,\n        uint8[2] calldata vs,\n        bytes32[5] calldata rssMetadata\n    )\n        external\n        payable;       \n}\n\ncontract NFTMarketWrap {\n    \n    Exchange public exchange;\n\n    constructor(Exchange _exchange) {\n        exchange = _exchange;\n    }\n\n    function _getAddrs(Order calldata buy, Order calldata sell, address _sender) internal pure returns (address[15] memory) {\n        address[15] memory _addrs = [\n            buy.exchange,\n            buy.maker,\n            buy.taker,\n            buy.feeRecipient,\n            buy.target,\n            buy.staticTarget,\n            buy.paymentToken,\n            sell.exchange,\n            sell.maker,\n            sell.taker,\n            sell.feeRecipient,\n            sell.target,\n            sell.staticTarget,\n            sell.paymentToken,\n            _sender\n        ];\n\n        return _addrs;\n    }\n    function _getUint(Order calldata buy, Order calldata sell ) internal pure returns (uint[18] memory) {\n        uint[18] memory _uints = [\n            buy.makerRelayerFee,\n            buy.takerRelayerFee,\n            buy.makerProtocolFee,\n            buy.takerProtocolFee,\n            buy.basePrice,\n            buy.extra,\n            buy.listingTime,\n            buy.expirationTime,\n            buy.salt,\n\n            sell.makerRelayerFee,\n            sell.takerRelayerFee,\n            sell.makerProtocolFee,\n            sell.takerProtocolFee,\n            sell.basePrice,\n            sell.extra,\n            sell.listingTime,\n            sell.expirationTime,\n            sell.salt\n        ];\n\n        return _uints;\n    }\n    function _getEnum(Order calldata buy, Order calldata sell ) internal pure returns (uint8[8] memory) {\n        uint8[8] memory _enum = [\n            uint8(buy.feeMethod),\n            uint8(buy.side),\n            uint8(buy.saleKind),\n            uint8(buy.howToCall),\n\n            uint8(sell.feeMethod),\n            uint8(sell.side),\n            uint8(sell.saleKind),\n            uint8(sell.howToCall)\n        ];\n\n        return _enum;\n    }\n    function _getVS(Sig calldata buySig, Sig calldata sellSig ) internal pure returns (uint8[2] memory) {\n        uint8[2] memory _vs = [\n            buySig.v,\n            sellSig.v\n        ];\n        return _vs;\n    }\n    function _getMetadata(Sig calldata buySig, Sig calldata sellSig, bytes32 metadata) internal pure returns (bytes32[5] memory) {\n        bytes32[5] memory _rssMetadata = [\n            buySig.r,\n            buySig.s,\n            sellSig.r,\n            sellSig.s,\n            metadata\n        ];\n        return _rssMetadata;\n    }\n    function _getBytes(Order calldata buy, Order calldata sell ) internal pure returns (ArgBytes memory) {\n        ArgBytes memory arg = ArgBytes(\n            buy.calldataBeta,\n            buy.replacementPattern,\n            buy.staticExtradata,\n            sell.calldataBeta,\n            sell.replacementPattern,\n            sell.staticExtradata\n        );\n        return arg;\n    }\n\n    function atomicMatchWrap (\n        Order[] calldata buys,\n        Sig[] calldata buySigs,\n        Order[] calldata sells,\n        Sig[] calldata sellSigs,\n        bytes32 rssMetadata,\n        uint256[] calldata values\n    )\n        public\n        payable\n    {\n        uint256 totalSells = sells.length;\n        \n        require(totalSells == buys.length, \"sells count and buys count must be equal\");\n        require(totalSells == values.length, \"sells count and values count must be equal\");\n\n        require(totalSells > 1, \"pls call exchange contract directly.\");\n        \n        uint256 totalValue = 0;\n        for( uint256 j = 0; j < totalSells; j++ ) {\n            totalValue += values[j];\n        }\n\n        require(msg.value == totalValue, \"msg.value count and totalValue must be equal\");\n        \n        for ( uint256 i = 0; i < totalSells; i++ ) {\n\n            ArgBytes memory arg = _getBytes(buys[i], sells[i]);\n\n            exchange.atomicMatch_{value: values[i]} (\n                _getAddrs(buys[i], sells[i], msg.sender),\n                _getUint(buys[i], sells[i]),\n                _getEnum(buys[i], sells[i]),\n                arg.calldataBeta1,\n                arg.calldataBeta2,\n                arg.replacementPattern1,\n                arg.replacementPattern2,\n                arg.staticExtradata1,\n                arg.staticExtradata2,\n                _getVS(buySigs[i], sellSigs[i]),\n                _getMetadata(buySigs[i], sellSigs[i], rssMetadata)\n            ); \n        }\n    }\n\n    \n}"}}}