{"language": "Solidity", "sources": {"src/Core.sol": {"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.30;\n\nimport {CallPoints, addressToCallPoints} from \"./types/callPoints.sol\";\nimport {PoolKey} from \"./types/poolKey.sol\";\nimport {PositionKey, Bounds} from \"./types/positionKey.sol\";\nimport {FeesPerLiquidity, feesPerLiquidityFromAmounts} from \"./types/feesPerLiquidity.sol\";\nimport {isPriceIncreasing, SqrtRatioLimitWrongDirection, SwapResult, swapResult} from \"./math/swap.sol\";\nimport {Position} from \"./types/position.sol\";\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {tickToSqrtRatio, sqrtRatioToTick} from \"./math/ticks.sol\";\nimport {Bitmap} from \"./math/bitmap.sol\";\nimport {\n    shouldCallBeforeInitializePool,\n    shouldCallAfterInitializePool,\n    shouldCallBeforeUpdatePosition,\n    shouldCallAfterUpdatePosition,\n    shouldCallBeforeSwap,\n    shouldCallAfterSwap,\n    shouldCallBeforeCollectFees,\n    shouldCallAfterCollectFees\n} from \"./types/callPoints.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {ExposedStorage} from \"./base/ExposedStorage.sol\";\nimport {liquidityDeltaToAmountDelta, addLiquidityDelta, subLiquidityDelta} from \"./math/liquidity.sol\";\nimport {computeFee} from \"./math/fee.sol\";\nimport {findNextInitializedTick, findPrevInitializedTick, flipTick} from \"./math/tickBitmap.sol\";\nimport {ICore, UpdatePositionParameters, IExtension} from \"./interfaces/ICore.sol\";\nimport {FlashAccountant} from \"./base/FlashAccountant.sol\";\nimport {EfficientHashLib} from \"solady/utils/EfficientHashLib.sol\";\nimport {\n    MIN_TICK,\n    MAX_TICK,\n    NATIVE_TOKEN_ADDRESS,\n    FULL_RANGE_ONLY_TICK_SPACING,\n    MAX_TICK_SPACING\n} from \"./math/constants.sol\";\nimport {MIN_SQRT_RATIO, MAX_SQRT_RATIO, SqrtRatio} from \"./types/sqrtRatio.sol\";\n\n/// @title Ekubo Protocol\n/// @author Moody Salem <moody@ekubo.org>\n/// @notice Singleton holding all the tokens and containing all the possible operations in Ekubo Protocol\ncontract Core is ICore, FlashAccountant, Ownable, ExposedStorage {\n    using {findNextInitializedTick, findPrevInitializedTick, flipTick} for mapping(uint256 word => Bitmap bitmap);\n\n    struct TickInfo {\n        int128 liquidityDelta;\n        uint128 liquidityNet;\n    }\n\n    struct PoolState {\n        SqrtRatio sqrtRatio;\n        int32 tick;\n        uint128 liquidity;\n    }\n\n    mapping(address extension => bool isRegistered) private isExtensionRegistered;\n    mapping(address token => uint256 amountCollected) private protocolFeesCollected;\n\n    mapping(bytes32 poolId => PoolState) private poolState;\n    mapping(bytes32 poolId => FeesPerLiquidity feesPerLiquidity) private poolFeesPerLiquidity;\n    mapping(bytes32 poolId => mapping(bytes32 positionId => Position position)) private poolPositions;\n    mapping(bytes32 poolId => mapping(int32 tick => TickInfo tickInfo)) private poolTicks;\n    mapping(bytes32 poolId => mapping(int32 tick => FeesPerLiquidity feesPerLiquidityOutside)) private\n        poolTickFeesPerLiquidityOutside;\n    mapping(bytes32 poolId => mapping(uint256 word => Bitmap bitmap)) private poolInitializedTickBitmaps;\n\n    mapping(bytes32 key => uint256) private savedBalances;\n\n    constructor(address owner) {\n        _initializeOwner(owner);\n    }\n\n    function withdrawProtocolFees(address recipient, address token, uint256 amount) external onlyOwner {\n        protocolFeesCollected[token] -= amount;\n        if (token == NATIVE_TOKEN_ADDRESS) {\n            SafeTransferLib.safeTransferETH(recipient, amount);\n        } else {\n            SafeTransferLib.safeTransfer(token, recipient, amount);\n        }\n        emit ProtocolFeesWithdrawn(recipient, token, amount);\n    }\n\n    // Extensions must call this function to become registered. The call points are validated against the caller address\n    function registerExtension(CallPoints memory expectedCallPoints) external {\n        CallPoints memory computed = addressToCallPoints(msg.sender);\n        if (!computed.eq(expectedCallPoints) || !computed.isValid()) revert FailedRegisterInvalidCallPoints();\n        if (isExtensionRegistered[msg.sender]) revert ExtensionAlreadyRegistered();\n        isExtensionRegistered[msg.sender] = true;\n        emit ExtensionRegistered(msg.sender);\n    }\n\n    function initializePool(PoolKey memory poolKey, int32 tick) external returns (SqrtRatio sqrtRatio) {\n        poolKey.validatePoolKey();\n\n        address extension = poolKey.extension();\n        if (extension != address(0)) {\n            if (!isExtensionRegistered[extension]) {\n                revert ExtensionNotRegistered();\n            }\n\n            if (shouldCallBeforeInitializePool(extension) && extension != msg.sender) {\n                IExtension(extension).beforeInitializePool(msg.sender, poolKey, tick);\n            }\n        }\n\n        bytes32 poolId = poolKey.toPoolId();\n        PoolState memory price = poolState[poolId];\n        if (SqrtRatio.unwrap(price.sqrtRatio) != 0) revert PoolAlreadyInitialized();\n\n        sqrtRatio = tickToSqrtRatio(tick);\n        poolState[poolId] = PoolState({sqrtRatio: sqrtRatio, tick: tick, liquidity: 0});\n\n        emit PoolInitialized(poolId, poolKey, tick, sqrtRatio);\n\n        if (shouldCallAfterInitializePool(extension) && extension != msg.sender) {\n            IExtension(extension).afterInitializePool(msg.sender, poolKey, tick, sqrtRatio);\n        }\n    }\n\n    function prevInitializedTick(bytes32 poolId, int32 fromTick, uint32 tickSpacing, uint256 skipAhead)\n        external\n        view\n        returns (int32 tick, bool isInitialized)\n    {\n        (tick, isInitialized) =\n            poolInitializedTickBitmaps[poolId].findPrevInitializedTick(fromTick, tickSpacing, skipAhead);\n    }\n\n    function nextInitializedTick(bytes32 poolId, int32 fromTick, uint32 tickSpacing, uint256 skipAhead)\n        external\n        view\n        returns (int32 tick, bool isInitialized)\n    {\n        (tick, isInitialized) =\n            poolInitializedTickBitmaps[poolId].findNextInitializedTick(fromTick, tickSpacing, skipAhead);\n    }\n\n    function load(address token0, address token1, bytes32 salt, uint128 amount0, uint128 amount1) public {\n        // note we do not check sort order because for save it must be sorted,\n        //  so balances will always be zero if token0 and token1 are not sorted\n        //  and this method will throw InsufficientSavedBalance for non-zero amount\n        (uint256 id,) = _getLocker();\n\n        bytes32 key = EfficientHashLib.hash(\n            bytes32(uint256(uint160(msg.sender))),\n            bytes32(uint256(uint160(token0))),\n            bytes32(uint256(uint160(token1))),\n            salt\n        );\n\n        unchecked {\n            uint256 packedBalance = savedBalances[key];\n            uint128 balance0 = uint128(packedBalance >> 128);\n            uint128 balance1 = uint128(packedBalance);\n            if (balance0 < amount0 || balance1 < amount1) {\n                revert InsufficientSavedBalance();\n            }\n\n            // unchecked is ok because we reverted if either balance < amount\n            savedBalances[key] = (uint256(balance0 - amount0) << 128) + uint256(balance1 - amount1);\n\n            _accountDebt(id, token0, -int256(uint256(amount0)));\n            _accountDebt(id, token1, -int256(uint256(amount1)));\n        }\n    }\n\n    function save(address owner, address token0, address token1, bytes32 salt, uint128 amount0, uint128 amount1)\n        public\n        payable\n    {\n        if (token0 >= token1) revert SavedBalanceTokensNotSorted();\n\n        (uint256 id,) = _requireLocker();\n\n        bytes32 key = EfficientHashLib.hash(\n            bytes32(uint256(uint160(owner))), bytes32(uint256(uint160(token0))), bytes32(uint256(uint160(token1))), salt\n        );\n\n        uint256 packedBalances = savedBalances[key];\n\n        uint128 balance0 = uint128(packedBalances >> 128);\n        uint128 balance1 = uint128(packedBalances);\n\n        // we are using checked math here to protect the uint128 additions from overflowing\n        savedBalances[key] = (uint256(balance0 + amount0) << 128) + uint256(balance1 + amount1);\n\n        _maybeAccountDebtToken0(id, token0, int256(uint256(amount0)));\n        _accountDebt(id, token1, int256(uint256(amount1)));\n    }\n\n    // Returns the pool fees per liquidity inside the given bounds.\n    function _getPoolFeesPerLiquidityInside(bytes32 poolId, Bounds memory bounds, uint32 tickSpacing)\n        internal\n        view\n        returns (FeesPerLiquidity memory)\n    {\n        if (tickSpacing == FULL_RANGE_ONLY_TICK_SPACING) return poolFeesPerLiquidity[poolId];\n\n        int32 tick = poolState[poolId].tick;\n        mapping(int32 => FeesPerLiquidity) storage poolIdEntry = poolTickFeesPerLiquidityOutside[poolId];\n        FeesPerLiquidity memory lower = poolIdEntry[bounds.lower];\n        FeesPerLiquidity memory upper = poolIdEntry[bounds.upper];\n\n        if (tick < bounds.lower) {\n            return lower.sub(upper);\n        } else if (tick < bounds.upper) {\n            FeesPerLiquidity memory fees = poolFeesPerLiquidity[poolId];\n\n            return fees.sub(lower).sub(upper);\n        } else {\n            return upper.sub(lower);\n        }\n    }\n\n    function getPoolFeesPerLiquidityInside(PoolKey memory poolKey, Bounds memory bounds)\n        external\n        view\n        returns (FeesPerLiquidity memory)\n    {\n        return _getPoolFeesPerLiquidityInside(poolKey.toPoolId(), bounds, poolKey.tickSpacing());\n    }\n\n    // Accumulates tokens to fees of a pool. Only callable by the extension of the specified pool\n    // key, i.e. the current locker _must_ be the extension.\n    // The extension must call this function within a lock callback.\n    function accumulateAsFees(PoolKey memory poolKey, uint128 amount0, uint128 amount1) external payable {\n        (uint256 id, address locker) = _requireLocker();\n        require(locker == poolKey.extension());\n\n        bytes32 poolId = poolKey.toPoolId();\n\n        // Note we do not check pool is initialized. If the extension calls this for a pool that does not exist,\n        //  the fees are simply burned since liquidity is 0.\n\n        assembly (\"memory-safe\") {\n            if or(amount0, amount1) {\n                mstore(0, poolId)\n                mstore(32, 2)\n                let liquidity := shr(128, sload(keccak256(0, 64)))\n\n                if liquidity {\n                    mstore(32, 3)\n                    let slot0 := keccak256(0, 64)\n\n                    if amount0 {\n                        let v := div(shl(128, amount0), liquidity)\n                        sstore(slot0, add(sload(slot0), v))\n                    }\n                    if amount1 {\n                        let slot1 := add(slot0, 1)\n                        let v := div(shl(128, amount1), liquidity)\n                        sstore(slot1, add(sload(slot1), v))\n                    }\n                }\n            }\n        }\n\n        // whether the fees are actually accounted to any position, the caller owes the debt\n        _maybeAccountDebtToken0(id, poolKey.token0, int256(uint256(amount0)));\n        _accountDebt(id, poolKey.token1, int256(uint256(amount1)));\n\n        emit FeesAccumulated(poolId, amount0, amount1);\n    }\n\n    function _updateTick(bytes32 poolId, int32 tick, uint32 tickSpacing, int128 liquidityDelta, bool isUpper) private {\n        TickInfo storage tickInfo = poolTicks[poolId][tick];\n\n        uint128 liquidityNetNext = addLiquidityDelta(tickInfo.liquidityNet, liquidityDelta);\n        // this is checked math\n        int128 liquidityDeltaNext =\n            isUpper ? tickInfo.liquidityDelta - liquidityDelta : tickInfo.liquidityDelta + liquidityDelta;\n\n        if ((tickInfo.liquidityNet == 0) != (liquidityNetNext == 0)) {\n            flipTick(poolInitializedTickBitmaps[poolId], tick, tickSpacing);\n        }\n\n        tickInfo.liquidityDelta = liquidityDeltaNext;\n        tickInfo.liquidityNet = liquidityNetNext;\n    }\n\n    function _maybeAccountDebtToken0(uint256 id, address token0, int256 debtChange) private {\n        if (msg.value == 0) {\n            _accountDebt(id, token0, debtChange);\n        } else {\n            if (msg.value > type(uint128).max) revert PaymentOverflow();\n\n            if (token0 == NATIVE_TOKEN_ADDRESS) {\n                unchecked {\n                    _accountDebt(id, NATIVE_TOKEN_ADDRESS, debtChange - int256(msg.value));\n                }\n            } else {\n                unchecked {\n                    _accountDebt(id, token0, debtChange);\n                    _accountDebt(id, NATIVE_TOKEN_ADDRESS, -int256(msg.value));\n                }\n            }\n        }\n    }\n\n    function updatePosition(PoolKey memory poolKey, UpdatePositionParameters memory params)\n        external\n        payable\n        returns (int128 delta0, int128 delta1)\n    {\n        (uint256 id, address locker) = _requireLocker();\n\n        address extension = poolKey.extension();\n        if (shouldCallBeforeUpdatePosition(extension) && locker != extension) {\n            IExtension(extension).beforeUpdatePosition(locker, poolKey, params);\n        }\n\n        params.bounds.validateBounds(poolKey.tickSpacing());\n\n        if (params.liquidityDelta != 0) {\n            bytes32 poolId = poolKey.toPoolId();\n            PoolState memory price = poolState[poolId];\n            if (SqrtRatio.unwrap(price.sqrtRatio) == 0) revert PoolNotInitialized();\n\n            (SqrtRatio sqrtRatioLower, SqrtRatio sqrtRatioUpper) =\n                (tickToSqrtRatio(params.bounds.lower), tickToSqrtRatio(params.bounds.upper));\n\n            (delta0, delta1) =\n                liquidityDeltaToAmountDelta(price.sqrtRatio, params.liquidityDelta, sqrtRatioLower, sqrtRatioUpper);\n\n            PositionKey memory positionKey = PositionKey({salt: params.salt, owner: locker, bounds: params.bounds});\n\n            if (params.liquidityDelta < 0) {\n                if (poolKey.fee() != 0) {\n                    unchecked {\n                        // uint128(-delta0) is ok in unchecked block\n                        uint128 protocolFees0 = computeFee(uint128(-delta0), poolKey.fee());\n                        uint128 protocolFees1 = computeFee(uint128(-delta1), poolKey.fee());\n\n                        if (protocolFees0 > 0) {\n                            // this will never overflow for a well behaved token since protocol fees are stored as uint256\n                            protocolFeesCollected[poolKey.token0] += protocolFees0;\n\n                            // magnitude of protocolFees0 is at most equal to -delta0, so after addition delta0 will maximally reach 0 and no overflow/underflow check is needed\n                            // in addition, casting is safe because computed fee is never g.t. the input amount, which is an int128\n                            delta0 += int128(protocolFees0);\n                        }\n\n                        // same reasoning applies for the unchecked safety here\n                        if (protocolFees1 > 0) {\n                            protocolFeesCollected[poolKey.token1] += protocolFees1;\n                            delta1 += int128(protocolFees1);\n                        }\n                    }\n                }\n            }\n\n            bytes32 positionId = positionKey.toPositionId();\n            Position storage position = poolPositions[poolId][positionId];\n\n            FeesPerLiquidity memory feesPerLiquidityInside =\n                _getPoolFeesPerLiquidityInside(poolId, params.bounds, poolKey.tickSpacing());\n\n            (uint128 fees0, uint128 fees1) = position.fees(feesPerLiquidityInside);\n\n            uint128 liquidityNext = addLiquidityDelta(position.liquidity, params.liquidityDelta);\n\n            if (liquidityNext != 0) {\n                position.liquidity = liquidityNext;\n                position.feesPerLiquidityInsideLast =\n                    feesPerLiquidityInside.sub(feesPerLiquidityFromAmounts(fees0, fees1, liquidityNext));\n            } else {\n                if (fees0 != 0 || fees1 != 0) revert MustCollectFeesBeforeWithdrawingAllLiquidity();\n                position.liquidity = 0;\n                position.feesPerLiquidityInsideLast = FeesPerLiquidity(0, 0);\n            }\n\n            if (!poolKey.isFullRange()) {\n                _updateTick(poolId, params.bounds.lower, poolKey.tickSpacing(), params.liquidityDelta, false);\n                _updateTick(poolId, params.bounds.upper, poolKey.tickSpacing(), params.liquidityDelta, true);\n\n                if (price.tick >= params.bounds.lower && price.tick < params.bounds.upper) {\n                    poolState[poolId].liquidity = addLiquidityDelta(poolState[poolId].liquidity, params.liquidityDelta);\n                }\n            } else {\n                poolState[poolId].liquidity = addLiquidityDelta(poolState[poolId].liquidity, params.liquidityDelta);\n            }\n\n            _maybeAccountDebtToken0(id, poolKey.token0, delta0);\n            _accountDebt(id, poolKey.token1, delta1);\n\n            emit PositionUpdated(locker, poolId, params, delta0, delta1);\n        }\n\n        if (shouldCallAfterUpdatePosition(extension) && locker != extension) {\n            IExtension(extension).afterUpdatePosition(locker, poolKey, params, delta0, delta1);\n        }\n    }\n\n    function collectFees(PoolKey memory poolKey, bytes32 salt, Bounds memory bounds)\n        external\n        returns (uint128 amount0, uint128 amount1)\n    {\n        (uint256 id, address locker) = _requireLocker();\n\n        address extension = poolKey.extension();\n        if (shouldCallBeforeCollectFees(extension) && locker != extension) {\n            IExtension(extension).beforeCollectFees(locker, poolKey, salt, bounds);\n        }\n\n        bytes32 poolId = poolKey.toPoolId();\n        PositionKey memory positionKey = PositionKey({salt: salt, owner: locker, bounds: bounds});\n        bytes32 positionId = positionKey.toPositionId();\n        Position memory position = poolPositions[poolId][positionId];\n\n        FeesPerLiquidity memory feesPerLiquidityInside =\n            _getPoolFeesPerLiquidityInside(poolId, bounds, poolKey.tickSpacing());\n\n        (amount0, amount1) = position.fees(feesPerLiquidityInside);\n\n        poolPositions[poolId][positionId] =\n            Position({liquidity: position.liquidity, feesPerLiquidityInsideLast: feesPerLiquidityInside});\n\n        _accountDebt(id, poolKey.token0, -int256(uint256(amount0)));\n        _accountDebt(id, poolKey.token1, -int256(uint256(amount1)));\n\n        emit PositionFeesCollected(poolId, positionKey, amount0, amount1);\n\n        if (shouldCallAfterCollectFees(extension) && locker != extension) {\n            IExtension(extension).afterCollectFees(locker, poolKey, salt, bounds, amount0, amount1);\n        }\n    }\n\n    function swap_611415377(\n        PoolKey memory poolKey,\n        int128 amount,\n        bool isToken1,\n        SqrtRatio sqrtRatioLimit,\n        uint256 skipAhead\n    ) external payable returns (int128 delta0, int128 delta1) {\n        if (!sqrtRatioLimit.isValid()) revert InvalidSqrtRatioLimit();\n\n        (uint256 id, address locker) = _requireLocker();\n\n        address extension = poolKey.extension();\n        if (shouldCallBeforeSwap(extension) && locker != extension) {\n            IExtension(extension).beforeSwap(locker, poolKey, amount, isToken1, sqrtRatioLimit, skipAhead);\n        }\n\n        bytes32 poolId = poolKey.toPoolId();\n        SqrtRatio sqrtRatio;\n        int32 tick;\n        uint128 liquidity;\n        {\n            PoolState storage state = poolState[poolId];\n            (sqrtRatio, tick, liquidity) = (state.sqrtRatio, state.tick, state.liquidity);\n        }\n\n        if (sqrtRatio.isZero()) revert PoolNotInitialized();\n\n        // 0 swap amount is no-op\n        if (amount != 0) {\n            bool increasing = isPriceIncreasing(amount, isToken1);\n            if (increasing) {\n                if (sqrtRatioLimit < sqrtRatio) revert SqrtRatioLimitWrongDirection();\n            } else {\n                if (sqrtRatioLimit > sqrtRatio) revert SqrtRatioLimitWrongDirection();\n            }\n\n            int128 amountRemaining = amount;\n\n            uint128 calculatedAmount = 0;\n\n            // the slot where inputTokenFeesPerLiquidity is stored, reused later\n            bytes32 inputTokenFeesPerLiquiditySlot;\n\n            // fees per liquidity only for the input token\n            uint256 inputTokenFeesPerLiquidity;\n\n            // this loads only the input token fees per liquidity\n            if (poolKey.mustLoadFees()) {\n                assembly (\"memory-safe\") {\n                    mstore(0, poolId)\n                    mstore(32, 3)\n                    inputTokenFeesPerLiquiditySlot := add(keccak256(0, 64), increasing)\n                    inputTokenFeesPerLiquidity := sload(inputTokenFeesPerLiquiditySlot)\n                }\n            }\n\n            while (amountRemaining != 0 && sqrtRatio != sqrtRatioLimit) {\n                int32 nextTick;\n                bool isInitialized;\n                SqrtRatio nextTickSqrtRatio;\n                SwapResult memory result;\n\n                if (poolKey.tickSpacing() != FULL_RANGE_ONLY_TICK_SPACING) {\n                    (nextTick, isInitialized) = increasing\n                        ? poolInitializedTickBitmaps[poolId].findNextInitializedTick(tick, poolKey.tickSpacing(), skipAhead)\n                        : poolInitializedTickBitmaps[poolId].findPrevInitializedTick(tick, poolKey.tickSpacing(), skipAhead);\n\n                    nextTickSqrtRatio = tickToSqrtRatio(nextTick);\n                } else {\n                    // we never cross ticks in the full range version\n                    // isInitialized = false;\n                    (nextTick, nextTickSqrtRatio) = increasing ? (MAX_TICK, MAX_SQRT_RATIO) : (MIN_TICK, MIN_SQRT_RATIO);\n                }\n\n                SqrtRatio limitedNextSqrtRatio =\n                    increasing ? nextTickSqrtRatio.min(sqrtRatioLimit) : nextTickSqrtRatio.max(sqrtRatioLimit);\n\n                result =\n                    swapResult(sqrtRatio, liquidity, limitedNextSqrtRatio, amountRemaining, isToken1, poolKey.fee());\n\n                // this accounts the fees into the feesPerLiquidity memory struct\n                assembly (\"memory-safe\") {\n                    // div by 0 returns 0, so it's ok\n                    let v := div(shl(128, mload(add(result, 96))), liquidity)\n                    inputTokenFeesPerLiquidity := add(inputTokenFeesPerLiquidity, v)\n                }\n\n                amountRemaining -= result.consumedAmount;\n                calculatedAmount += result.calculatedAmount;\n\n                if (result.sqrtRatioNext == nextTickSqrtRatio) {\n                    sqrtRatio = result.sqrtRatioNext;\n                    tick = increasing ? nextTick : nextTick - 1;\n\n                    if (isInitialized) {\n                        int128 liquidityDelta = poolTicks[poolId][nextTick].liquidityDelta;\n                        liquidity = increasing\n                            ? addLiquidityDelta(liquidity, liquidityDelta)\n                            : subLiquidityDelta(liquidity, liquidityDelta);\n                        FeesPerLiquidity memory tickFpl = poolTickFeesPerLiquidityOutside[poolId][nextTick];\n\n                        FeesPerLiquidity memory totalFpl;\n\n                        // load only the slot we didn't load before into totalFpl\n                        assembly (\"memory-safe\") {\n                            mstore(add(totalFpl, mul(32, increasing)), inputTokenFeesPerLiquidity)\n\n                            let outputTokenFeesPerLiquidity :=\n                                sload(add(sub(inputTokenFeesPerLiquiditySlot, increasing), iszero(increasing)))\n                            mstore(add(totalFpl, mul(32, iszero(increasing))), outputTokenFeesPerLiquidity)\n                        }\n\n                        poolTickFeesPerLiquidityOutside[poolId][nextTick] = totalFpl.sub(tickFpl);\n                    }\n                } else if (sqrtRatio != result.sqrtRatioNext) {\n                    sqrtRatio = result.sqrtRatioNext;\n                    tick = sqrtRatioToTick(sqrtRatio);\n                }\n            }\n\n            unchecked {\n                int256 calculatedAmountSign = int256(FixedPointMathLib.ternary(amount < 0, 1, type(uint256).max));\n                int128 calculatedAmountDelta = SafeCastLib.toInt128(\n                    FixedPointMathLib.max(type(int128).min, calculatedAmountSign * int256(uint256(calculatedAmount)))\n                );\n\n                (delta0, delta1) = isToken1\n                    ? (calculatedAmountDelta, amount - amountRemaining)\n                    : (amount - amountRemaining, calculatedAmountDelta);\n            }\n\n            assembly (\"memory-safe\") {\n                mstore(0, poolId)\n                mstore(32, 2)\n                sstore(keccak256(0, 64), add(add(sqrtRatio, shl(96, and(tick, 0xffffffff))), shl(128, liquidity)))\n            }\n\n            if (poolKey.mustLoadFees()) {\n                assembly (\"memory-safe\") {\n                    // this stores only the input token fees per liquidity\n                    sstore(inputTokenFeesPerLiquiditySlot, inputTokenFeesPerLiquidity)\n                }\n            }\n\n            _maybeAccountDebtToken0(id, poolKey.token0, delta0);\n            _accountDebt(id, poolKey.token1, delta1);\n\n            assembly (\"memory-safe\") {\n                let o := mload(0x40)\n                mstore(o, shl(96, locker))\n                mstore(add(o, 20), poolId)\n                mstore(add(o, 52), or(shl(128, delta0), and(delta1, 0xffffffffffffffffffffffffffffffff)))\n                mstore(add(o, 84), shl(128, liquidity))\n                mstore(add(o, 100), shl(160, sqrtRatio))\n                mstore(add(o, 112), shl(224, tick))\n                log0(o, 116)\n            }\n        }\n\n        if (shouldCallAfterSwap(extension) && locker != extension) {\n            IExtension(extension).afterSwap(\n                locker, poolKey, amount, isToken1, sqrtRatioLimit, skipAhead, delta0, delta1\n            );\n        }\n    }\n}\n"}, "src/types/callPoints.sol": {"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.30;\n\nstruct CallPoints {\n    bool beforeInitializePool;\n    bool afterInitializePool;\n    bool beforeSwap;\n    bool afterSwap;\n    bool beforeUpdatePosition;\n    bool afterUpdatePosition;\n    bool beforeCollectFees;\n    bool afterCollectFees;\n}\n\nusing {eq, isValid, toUint8} for CallPoints global;\n\nfunction eq(CallPoints memory a, CallPoints memory b) pure returns (bool) {\n    return (\n        a.beforeInitializePool == b.beforeInitializePool && a.afterInitializePool == b.afterInitializePool\n            && a.beforeSwap == b.beforeSwap && a.afterSwap == b.afterSwap\n            && a.beforeUpdatePosition == b.beforeUpdatePosition && a.afterUpdatePosition == b.afterUpdatePosition\n            && a.beforeCollectFees == b.beforeCollectFees && a.afterCollectFees == b.afterCollectFees\n    );\n}\n\nfunction isValid(CallPoints memory a) pure returns (bool) {\n    return (\n        a.beforeInitializePool || a.afterInitializePool || a.beforeSwap || a.afterSwap || a.beforeUpdatePosition\n            || a.afterUpdatePosition || a.beforeCollectFees || a.afterCollectFees\n    );\n}\n\nfunction toUint8(CallPoints memory callPoints) pure returns (uint8 b) {\n    assembly (\"memory-safe\") {\n        b :=\n            add(\n                add(\n                    add(\n                        add(\n                            add(\n                                add(\n                                    add(mload(callPoints), mul(128, mload(add(callPoints, 32)))),\n                                    mul(64, mload(add(callPoints, 64)))\n                                ),\n                                mul(32, mload(add(callPoints, 96)))\n                            ),\n                            mul(16, mload(add(callPoints, 128)))\n                        ),\n                        mul(8, mload(add(callPoints, 160)))\n                    ),\n                    mul(4, mload(add(callPoints, 192)))\n                ),\n                mul(2, mload(add(callPoints, 224)))\n            )\n    }\n}\n\nfunction addressToCallPoints(address a) pure returns (CallPoints memory result) {\n    result = byteToCallPoints(uint8(uint160(a) >> 152));\n}\n\nfunction byteToCallPoints(uint8 b) pure returns (CallPoints memory result) {\n    // note the order of bytes does not match the struct order of elements because we are matching the cairo implementation\n    // which for legacy reasons has the fields in this order\n    result = CallPoints({\n        beforeInitializePool: (b & 1) != 0,\n        afterInitializePool: (b & 128) != 0,\n        beforeSwap: (b & 64) != 0,\n        afterSwap: (b & 32) != 0,\n        beforeUpdatePosition: (b & 16) != 0,\n        afterUpdatePosition: (b & 8) != 0,\n        beforeCollectFees: (b & 4) != 0,\n        afterCollectFees: (b & 2) != 0\n    });\n}\n\nfunction shouldCallBeforeInitializePool(address a) pure returns (bool yes) {\n    assembly (\"memory-safe\") {\n        yes := and(shr(152, a), 1)\n    }\n}\n\nfunction shouldCallAfterInitializePool(address a) pure returns (bool yes) {\n    assembly (\"memory-safe\") {\n        yes := and(shr(159, a), 1)\n    }\n}\n\nfunction shouldCallBeforeSwap(address a) pure returns (bool yes) {\n    assembly (\"memory-safe\") {\n        yes := and(shr(158, a), 1)\n    }\n}\n\nfunction shouldCallAfterSwap(address a) pure returns (bool yes) {\n    assembly (\"memory-safe\") {\n        yes := and(shr(157, a), 1)\n    }\n}\n\nfunction shouldCallBeforeUpdatePosition(address a) pure returns (bool yes) {\n    assembly (\"memory-safe\") {\n        yes := and(shr(156, a), 1)\n    }\n}\n\nfunction shouldCallAfterUpdatePosition(address a) pure returns (bool yes) {\n    assembly (\"memory-safe\") {\n        yes := and(shr(155, a), 1)\n    }\n}\n\nfunction shouldCallBeforeCollectFees(address a) pure returns (bool yes) {\n    assembly (\"memory-safe\") {\n        yes := and(shr(154, a), 1)\n    }\n}\n\nfunction shouldCallAfterCollectFees(address a) pure returns (bool yes) {\n    assembly (\"memory-safe\") {\n        yes := and(shr(153, a), 1)\n    }\n}\n"}, "src/types/poolKey.sol": {"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.30;\n\nimport {MAX_TICK_SPACING, FULL_RANGE_ONLY_TICK_SPACING} from \"../math/constants.sol\";\n\nusing {toPoolId, validatePoolKey, isFullRange, mustLoadFees, tickSpacing, fee, extension} for PoolKey global;\n\n// address (20 bytes) | fee (8 bytes) | tickSpacing (4 bytes)\ntype Config is bytes32;\n\nfunction tickSpacing(PoolKey memory pk) pure returns (uint32 r) {\n    assembly (\"memory-safe\") {\n        r := and(mload(add(64, pk)), 0xffffffff)\n    }\n}\n\nfunction fee(PoolKey memory pk) pure returns (uint64 r) {\n    assembly (\"memory-safe\") {\n        r := and(mload(add(60, pk)), 0xffffffffffffffff)\n    }\n}\n\nfunction extension(PoolKey memory pk) pure returns (address r) {\n    assembly (\"memory-safe\") {\n        r := and(mload(add(52, pk)), 0xffffffffffffffffffffffffffffffffffffffff)\n    }\n}\n\nfunction mustLoadFees(PoolKey memory pk) pure returns (bool r) {\n    assembly (\"memory-safe\") {\n        // only if either of tick spacing and fee are nonzero\n        // if _both_ are zero, then we know we do not need to load fees for swaps\n        r := iszero(iszero(and(mload(add(64, pk)), 0xffffffffffffffffffffffff)))\n    }\n}\n\nfunction isFullRange(PoolKey memory pk) pure returns (bool r) {\n    r = pk.tickSpacing() == FULL_RANGE_ONLY_TICK_SPACING;\n}\n\nfunction toConfig(uint64 _fee, uint32 _tickSpacing, address _extension) pure returns (Config c) {\n    assembly (\"memory-safe\") {\n        c := add(add(shl(96, _extension), shl(32, _fee)), _tickSpacing)\n    }\n}\n\n// Each pool has its own state associated with this key\nstruct PoolKey {\n    address token0;\n    address token1;\n    Config config;\n}\n\nerror TokensMustBeSorted();\nerror InvalidTickSpacing();\n\nfunction validatePoolKey(PoolKey memory key) pure {\n    if (key.token0 >= key.token1) revert TokensMustBeSorted();\n    if (key.tickSpacing() > MAX_TICK_SPACING) {\n        revert InvalidTickSpacing();\n    }\n}\n\nfunction toPoolId(PoolKey memory key) pure returns (bytes32 result) {\n    assembly (\"memory-safe\") {\n        // it's already copied into memory\n        result := keccak256(key, 96)\n    }\n}\n"}, "src/types/positionKey.sol": {"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.30;\n\nimport {MIN_TICK, MAX_TICK, FULL_RANGE_ONLY_TICK_SPACING} from \"../math/constants.sol\";\n\nusing {toPositionId} for PositionKey global;\nusing {validateBounds} for Bounds global;\n\n// Bounds are lower and upper prices for which a position is active\nstruct Bounds {\n    int32 lower;\n    int32 upper;\n}\n\nerror BoundsOrder();\nerror MinMaxBounds();\nerror BoundsTickSpacing();\nerror FullRangeOnlyPool();\n\nfunction validateBounds(Bounds memory bounds, uint32 tickSpacing) pure {\n    if (tickSpacing == FULL_RANGE_ONLY_TICK_SPACING) {\n        if (bounds.lower != MIN_TICK || bounds.upper != MAX_TICK) revert FullRangeOnlyPool();\n    } else {\n        if (bounds.lower >= bounds.upper) revert BoundsOrder();\n        if (bounds.lower < MIN_TICK || bounds.upper > MAX_TICK) revert MinMaxBounds();\n        int32 spacing = int32(tickSpacing);\n        if (bounds.lower % spacing != 0 || bounds.upper % spacing != 0) revert BoundsTickSpacing();\n    }\n}\n\n// A position is keyed by the pool and this position key\nstruct PositionKey {\n    bytes32 salt;\n    address owner;\n    Bounds bounds;\n}\n\nfunction toPositionId(PositionKey memory key) pure returns (bytes32 result) {\n    assembly (\"memory-safe\") {\n        // salt and owner\n        mstore(0, keccak256(key, 64))\n        // bounds\n        mstore(32, keccak256(mload(add(key, 64)), 64))\n\n        result := keccak256(0, 64)\n    }\n}\n"}, "src/types/feesPerLiquidity.sol": {"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.30;\n\n// The total fees per liquidity for each token.\n// Since these are always read together we put them in a struct, even though they cannot be packed.\nstruct FeesPerLiquidity {\n    uint256 value0;\n    uint256 value1;\n}\n\nusing {sub} for FeesPerLiquidity global;\n\nfunction sub(FeesPerLiquidity memory a, FeesPerLiquidity memory b) pure returns (FeesPerLiquidity memory result) {\n    assembly (\"memory-safe\") {\n        mstore(result, sub(mload(a), mload(b)))\n        mstore(add(result, 32), sub(mload(add(a, 32)), mload(add(b, 32))))\n    }\n}\n\nfunction feesPerLiquidityFromAmounts(uint128 amount0, uint128 amount1, uint128 liquidity)\n    pure\n    returns (FeesPerLiquidity memory result)\n{\n    assembly (\"memory-safe\") {\n        mstore(result, div(shl(128, amount0), liquidity))\n        mstore(add(result, 32), div(shl(128, amount1), liquidity))\n    }\n}\n"}, "src/math/swap.sol": {"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.30;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {computeFee, amountBeforeFee} from \"./fee.sol\";\nimport {nextSqrtRatioFromAmount0, nextSqrtRatioFromAmount1} from \"./sqrtRatio.sol\";\nimport {amount0Delta, amount1Delta} from \"./delta.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {isPriceIncreasing} from \"./isPriceIncreasing.sol\";\nimport {SqrtRatio} from \"../types/sqrtRatio.sol\";\n\nstruct SwapResult {\n    int128 consumedAmount;\n    uint128 calculatedAmount;\n    SqrtRatio sqrtRatioNext;\n    uint128 feeAmount;\n}\n\nfunction noOpSwapResult(SqrtRatio sqrtRatioNext) pure returns (SwapResult memory) {\n    return SwapResult({consumedAmount: 0, calculatedAmount: 0, feeAmount: 0, sqrtRatioNext: sqrtRatioNext});\n}\n\nerror SqrtRatioLimitWrongDirection();\n\nfunction swapResult(\n    SqrtRatio sqrtRatio,\n    uint128 liquidity,\n    SqrtRatio sqrtRatioLimit,\n    int128 amount,\n    bool isToken1,\n    uint64 fee\n) pure returns (SwapResult memory) {\n    if (amount == 0 || sqrtRatio == sqrtRatioLimit) {\n        return noOpSwapResult(sqrtRatio);\n    }\n\n    bool increasing = isPriceIncreasing(amount, isToken1);\n\n    // We know sqrtRatio != sqrtRatioLimit because we early return above if it is\n    if ((sqrtRatioLimit > sqrtRatio) != increasing) revert SqrtRatioLimitWrongDirection();\n\n    if (liquidity == 0) {\n        // if the pool is empty, the swap will always move all the way to the limit price\n        return noOpSwapResult(sqrtRatioLimit);\n    }\n\n    bool isExactOut = amount < 0;\n\n    // this amount is what moves the price\n    int128 priceImpactAmount;\n    if (isExactOut) {\n        priceImpactAmount = amount;\n    } else {\n        unchecked {\n            // cast is safe because amount is g.t.e. 0\n            // then cast back to int128 is also safe because computeFee never returns a value g.t. the input amount\n            priceImpactAmount = amount - int128(computeFee(uint128(amount), fee));\n        }\n    }\n\n    SqrtRatio sqrtRatioNextFromAmount;\n    if (isToken1) {\n        sqrtRatioNextFromAmount = nextSqrtRatioFromAmount1(sqrtRatio, liquidity, priceImpactAmount);\n    } else {\n        sqrtRatioNextFromAmount = nextSqrtRatioFromAmount0(sqrtRatio, liquidity, priceImpactAmount);\n    }\n\n    int128 consumedAmount;\n    uint128 calculatedAmount;\n    uint128 feeAmount;\n\n    // the amount requires a swapping past the sqrt ratio limit,\n    // so we need to compute the result of swapping only to the limit\n    if (\n        (increasing && sqrtRatioNextFromAmount > sqrtRatioLimit)\n            || (!increasing && sqrtRatioNextFromAmount < sqrtRatioLimit)\n    ) {\n        uint128 specifiedAmountDelta;\n        uint128 calculatedAmountDelta;\n        if (isToken1) {\n            specifiedAmountDelta = amount1Delta(sqrtRatioLimit, sqrtRatio, liquidity, !isExactOut);\n            calculatedAmountDelta = amount0Delta(sqrtRatioLimit, sqrtRatio, liquidity, isExactOut);\n        } else {\n            specifiedAmountDelta = amount0Delta(sqrtRatioLimit, sqrtRatio, liquidity, !isExactOut);\n            calculatedAmountDelta = amount1Delta(sqrtRatioLimit, sqrtRatio, liquidity, isExactOut);\n        }\n\n        if (isExactOut) {\n            uint128 beforeFee = amountBeforeFee(calculatedAmountDelta, fee);\n            consumedAmount = -SafeCastLib.toInt128(specifiedAmountDelta);\n            calculatedAmount = beforeFee;\n            feeAmount = beforeFee - calculatedAmountDelta;\n        } else {\n            uint128 beforeFee = amountBeforeFee(specifiedAmountDelta, fee);\n            consumedAmount = SafeCastLib.toInt128(beforeFee);\n            calculatedAmount = calculatedAmountDelta;\n            feeAmount = beforeFee - specifiedAmountDelta;\n        }\n\n        return SwapResult({\n            consumedAmount: consumedAmount,\n            calculatedAmount: calculatedAmount,\n            sqrtRatioNext: sqrtRatioLimit,\n            feeAmount: feeAmount\n        });\n    }\n\n    if (sqrtRatioNextFromAmount == sqrtRatio) {\n        assert(!isExactOut);\n\n        return SwapResult({\n            consumedAmount: amount,\n            calculatedAmount: 0,\n            sqrtRatioNext: sqrtRatio,\n            feeAmount: uint128(amount)\n        });\n    }\n\n    // rounds down for calculated == output, up for calculated == input\n    uint128 calculatedAmountWithoutFee;\n    if (isToken1) {\n        calculatedAmountWithoutFee = amount0Delta(sqrtRatioNextFromAmount, sqrtRatio, liquidity, isExactOut);\n    } else {\n        calculatedAmountWithoutFee = amount1Delta(sqrtRatioNextFromAmount, sqrtRatio, liquidity, isExactOut);\n    }\n\n    // add on the fee to calculated amount for exact output\n    if (isExactOut) {\n        uint128 includingFee = amountBeforeFee(calculatedAmountWithoutFee, fee);\n        calculatedAmount = includingFee;\n        feeAmount = includingFee - calculatedAmountWithoutFee;\n    } else {\n        calculatedAmount = calculatedAmountWithoutFee;\n        feeAmount = uint128(amount - priceImpactAmount);\n    }\n\n    return SwapResult({\n        consumedAmount: amount,\n        calculatedAmount: calculatedAmount,\n        sqrtRatioNext: sqrtRatioNextFromAmount,\n        feeAmount: feeAmount\n    });\n}\n"}, "src/types/position.sol": {"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.30;\n\nimport {FeesPerLiquidity} from \"./feesPerLiquidity.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nstruct Position {\n    uint128 liquidity;\n    FeesPerLiquidity feesPerLiquidityInsideLast;\n}\n\nusing {fees} for Position global;\n\n/// @dev Returns the fee amounts of token0 and token1 owed to a position based on the given fees per liquidity inside snapshot\n///      Note if the computed fees overflows the uint128 type, it will return only the lower 128 bits. It is assumed that accumulated\n///      fees will never exceed type(uint128).max.\nfunction fees(Position memory position, FeesPerLiquidity memory feesPerLiquidityInside)\n    pure\n    returns (uint128, uint128)\n{\n    FeesPerLiquidity memory difference = feesPerLiquidityInside.sub(position.feesPerLiquidityInsideLast);\n\n    return (\n        uint128(FixedPointMathLib.fullMulDivN(difference.value0, position.liquidity, 128)),\n        uint128(FixedPointMathLib.fullMulDivN(difference.value1, position.liquidity, 128))\n    );\n}\n"}, "lib/solady/src/auth/Ownable.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\n///\n/// @dev Note:\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\n///\n/// While the ownable portion follows\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\nabstract contract Ownable {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The caller is not authorized to call the function.\n    error Unauthorized();\n\n    /// @dev The `newOwner` cannot be the zero address.\n    error NewOwnerIsZeroAddress();\n\n    /// @dev The `pendingOwner` does not have a valid handover request.\n    error NoHandoverRequest();\n\n    /// @dev Cannot double-initialize.\n    error AlreadyInitialized();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                           EVENTS                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\n    /// despite it not being as lightweight as a single argument event.\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    /// @dev An ownership handover to `pendingOwner` has been requested.\n    event OwnershipHandoverRequested(address indexed pendingOwner);\n\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\n\n    /// @dev `keccak256(bytes(\"OwnershipTransferred(address,address)\"))`.\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverRequested(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverCanceled(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          STORAGE                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The owner slot is given by:\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\"_OWNER_SLOT_NOT\")))))`.\n    /// It is intentionally chosen to be a high value\n    /// to avoid collision with lower slots.\n    /// The choice of manual storage layout is to enable compatibility\n    /// with both regular and upgradeable contracts.\n    bytes32 internal constant _OWNER_SLOT =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;\n\n    /// The ownership handover slot of `newOwner` is given by:\n    /// ```\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\n    ///     let handoverSlot := keccak256(0x00, 0x20)\n    /// ```\n    /// It stores the expiry timestamp of the two-step ownership handover.\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                     INTERNAL FUNCTIONS                     */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Override to return true to make `_initializeOwner` prevent double-initialization.\n    function _guardInitializeOwner() internal pure virtual returns (bool guard) {}\n\n    /// @dev Initializes the owner directly without authorization guard.\n    /// This function must be called upon initialization,\n    /// regardless of whether the contract is upgradeable or not.\n    /// This is to enable generalization to both regular and upgradeable contracts,\n    /// and to save gas in case the initial owner is not the caller.\n    /// For performance reasons, this function will not check if there\n    /// is an existing owner.\n    function _initializeOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                if sload(ownerSlot) {\n                    mstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.\n                    revert(0x1c, 0x04)\n                }\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(_OWNER_SLOT, newOwner)\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        }\n    }\n\n    /// @dev Sets the owner directly without authorization guard.\n    function _setOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, newOwner)\n            }\n        }\n    }\n\n    /// @dev Throws if the sender is not the owner.\n    function _checkOwner() internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the caller is not the stored owner, revert.\n            if iszero(eq(caller(), sload(_OWNER_SLOT))) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\n    /// Override to return a different value if needed.\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\n        return 48 * 3600;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(shl(96, newOwner)) {\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _setOwner(newOwner);\n    }\n\n    /// @dev Allows the owner to renounce their ownership.\n    function renounceOwnership() public payable virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /// @dev Request a two-step ownership handover to the caller.\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\n    function requestOwnershipHandover() public payable virtual {\n        unchecked {\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Compute and set the handover slot to `expires`.\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\n                mstore(0x00, caller())\n                sstore(keccak256(0x0c, 0x20), expires)\n                // Emit the {OwnershipHandoverRequested} event.\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\n            }\n        }\n    }\n\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\n    function cancelOwnershipHandover() public payable virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x20), 0)\n            // Emit the {OwnershipHandoverCanceled} event.\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\n        }\n    }\n\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            let handoverSlot := keccak256(0x0c, 0x20)\n            // If the handover does not exist, or has expired.\n            if gt(timestamp(), sload(handoverSlot)) {\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\n                revert(0x1c, 0x04)\n            }\n            // Set the handover slot to 0.\n            sstore(handoverSlot, 0)\n        }\n        _setOwner(pendingOwner);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                   PUBLIC READ FUNCTIONS                    */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the owner of the contract.\n    function owner() public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_OWNER_SLOT)\n        }\n    }\n\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\n    function ownershipHandoverExpiresAt(address pendingOwner)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the handover slot.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            // Load the handover slot.\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         MODIFIERS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Marks a function as only callable by the owner.\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n}\n"}, "src/math/ticks.sol": {"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.30;\n\nimport {MAX_TICK_SPACING, MAX_TICK_MAGNITUDE} from \"./constants.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SqrtRatio, toSqrtRatio} from \"../types/sqrtRatio.sol\";\n\nerror InvalidTick(int32 tick);\n\n// Returns the sqrtRatio corresponding for the tick\nfunction tickToSqrtRatio(int32 tick) pure returns (SqrtRatio r) {\n    unchecked {\n        uint256 t = FixedPointMathLib.abs(tick);\n        if (t > MAX_TICK_MAGNITUDE) revert InvalidTick(tick);\n\n        uint256 ratio;\n        assembly (\"memory-safe\") {\n            ratio := sub(0x100000000000000000000000000000000, mul(and(t, 0x1), 0x8637b66cd638344daef276cd7c5))\n        }\n\n        if ((t & 0x2) != 0) {\n            ratio = (ratio * 0xffffef390978c398134b4ff3764fe410) >> 128;\n        }\n        if ((t & 0x4) != 0) {\n            ratio = (ratio * 0xffffde72140b00a354bd3dc828e976c9) >> 128;\n        }\n        if ((t & 0x8) != 0) {\n            ratio = (ratio * 0xffffbce42c7be6c998ad6318193c0b18) >> 128;\n        }\n        if ((t & 0x10) != 0) {\n            ratio = (ratio * 0xffff79c86a8f6150a32d9778eceef97c) >> 128;\n        }\n        if ((t & 0x20) != 0) {\n            ratio = (ratio * 0xfffef3911b7cff24ba1b3dbb5f8f5974) >> 128;\n        }\n        if ((t & 0x40) != 0) {\n            ratio = (ratio * 0xfffde72350725cc4ea8feece3b5f13c8) >> 128;\n        }\n        if ((t & 0x80) != 0) {\n            ratio = (ratio * 0xfffbce4b06c196e9247ac87695d53c60) >> 128;\n        }\n        if ((t & 0x100) != 0) {\n            ratio = (ratio * 0xfff79ca7a4d1bf1ee8556cea23cdbaa5) >> 128;\n        }\n        if ((t & 0x200) != 0) {\n            ratio = (ratio * 0xffef3995a5b6a6267530f207142a5764) >> 128;\n        }\n        if ((t & 0x400) != 0) {\n            ratio = (ratio * 0xffde7444b28145508125d10077ba83b8) >> 128;\n        }\n        if ((t & 0x800) != 0) {\n            ratio = (ratio * 0xffbceceeb791747f10df216f2e53ec57) >> 128;\n        }\n        if ((t & 0x1000) != 0) {\n            ratio = (ratio * 0xff79eb706b9a64c6431d76e63531e929) >> 128;\n        }\n        if ((t & 0x2000) != 0) {\n            ratio = (ratio * 0xfef41d1a5f2ae3a20676bec6f7f9459a) >> 128;\n        }\n        if ((t & 0x4000) != 0) {\n            ratio = (ratio * 0xfde95287d26d81bea159c37073122c73) >> 128;\n        }\n        if ((t & 0x8000) != 0) {\n            ratio = (ratio * 0xfbd701c7cbc4c8a6bb81efd232d1e4e7) >> 128;\n        }\n        if ((t & 0x10000) != 0) {\n            ratio = (ratio * 0xf7bf5211c72f5185f372aeb1d48f937e) >> 128;\n        }\n        if ((t & 0x20000) != 0) {\n            ratio = (ratio * 0xefc2bf59df33ecc28125cf78ec4f167f) >> 128;\n        }\n        if ((t & 0x40000) != 0) {\n            ratio = (ratio * 0xe08d35706200796273f0b3a981d90cfd) >> 128;\n        }\n        if ((t & 0x80000) != 0) {\n            ratio = (ratio * 0xc4f76b68947482dc198a48a54348c4ed) >> 128;\n        }\n        if ((t & 0x100000) != 0) {\n            ratio = (ratio * 0x978bcb9894317807e5fa4498eee7c0fa) >> 128;\n        }\n        if ((t & 0x200000) != 0) {\n            ratio = (ratio * 0x59b63684b86e9f486ec54727371ba6ca) >> 128;\n        }\n        if ((t & 0x400000) != 0) {\n            ratio = (ratio * 0x1f703399d88f6aa83a28b22d4a1f56e3) >> 128;\n        }\n        if ((t & 0x800000) != 0) {\n            ratio = (ratio * 0x3dc5dac7376e20fc8679758d1bcdcfc) >> 128;\n        }\n        if ((t & 0x1000000) != 0) {\n            ratio = (ratio * 0xee7e32d61fdb0a5e622b820f681d0) >> 128;\n        }\n        if ((t & 0x2000000) != 0) {\n            ratio = (ratio * 0xde2ee4bc381afa7089aa84bb66) >> 128;\n        }\n        if ((t & 0x4000000) != 0) {\n            ratio = (ratio * 0xc0d55d4d7152c25fb139) >> 128;\n        }\n\n        if (tick > 0) {\n            ratio = type(uint256).max / ratio;\n        }\n\n        r = toSqrtRatio(ratio, false);\n    }\n}\n\nfunction sqrtRatioToTick(SqrtRatio sqrtRatio) pure returns (int32) {\n    unchecked {\n        uint256 sqrtRatioFixed = sqrtRatio.toFixed();\n\n        bool negative = (sqrtRatioFixed >> 128) == 0;\n\n        uint256 x = negative ? (type(uint256).max / sqrtRatioFixed) : sqrtRatioFixed;\n\n        // we know x >> 128 is never zero because we check bounds above and then reciprocate sqrtRatio if the high 128 bits are zero\n        // so we don't need to handle the exceptional case of log2(0)\n        uint256 msbHigh = FixedPointMathLib.log2(x >> 128);\n        x = x >> (msbHigh + 1);\n        uint256 log2_unsigned = msbHigh * 0x10000000000000000;\n\n        assembly (\"memory-safe\") {\n            // 63\n            x := shr(127, mul(x, x))\n            let is_high_nonzero := eq(iszero(shr(128, x)), 0)\n            log2_unsigned := add(log2_unsigned, mul(is_high_nonzero, 0x8000000000000000))\n            x := shr(is_high_nonzero, x)\n\n            // 62\n            x := shr(127, mul(x, x))\n            is_high_nonzero := eq(iszero(shr(128, x)), 0)\n            log2_unsigned := add(log2_unsigned, mul(is_high_nonzero, 0x4000000000000000))\n            x := shr(is_high_nonzero, x)\n\n            // 61\n            x := shr(127, mul(x, x))\n            is_high_nonzero := eq(iszero(shr(128, x)), 0)\n            log2_unsigned := add(log2_unsigned, mul(is_high_nonzero, 0x2000000000000000))\n            x := shr(is_high_nonzero, x)\n\n            // 60\n            x := shr(127, mul(x, x))\n            is_high_nonzero := eq(iszero(shr(128, x)), 0)\n            log2_unsigned := add(log2_unsigned, mul(is_high_nonzero, 0x1000000000000000))\n            x := shr(is_high_nonzero, x)\n\n            // 59\n            x := shr(127, mul(x, x))\n            is_high_nonzero := eq(iszero(shr(128, x)), 0)\n            log2_unsigned := add(log2_unsigned, mul(is_high_nonzero, 0x800000000000000))\n            x := shr(is_high_nonzero, x)\n\n            // 58\n            x := shr(127, mul(x, x))\n            is_high_nonzero := eq(iszero(shr(128, x)), 0)\n            log2_unsigned := add(log2_unsigned, mul(is_high_nonzero, 0x400000000000000))\n            x := shr(is_high_nonzero, x)\n\n            // 57\n            x := shr(127, mul(x, x))\n            is_high_nonzero := eq(iszero(shr(128, x)), 0)\n            log2_unsigned := add(log2_unsigned, mul(is_high_nonzero, 0x200000000000000))\n            x := shr(is_high_nonzero, x)\n\n            // 56\n            x := shr(127, mul(x, x))\n            is_high_nonzero := eq(iszero(shr(128, x)), 0)\n            log2_unsigned := add(log2_unsigned, mul(is_high_nonzero, 0x100000000000000))\n            x := shr(is_high_nonzero, x)\n\n            // 55\n            x := shr(127, mul(x, x))\n            is_high_nonzero := eq(iszero(shr(128, x)), 0)\n            log2_unsigned := add(log2_unsigned, mul(is_high_nonzero, 0x80000000000000))\n            x := shr(is_high_nonzero, x)\n\n            // 54\n            x := shr(127, mul(x, x))\n            is_high_nonzero := eq(iszero(shr(128, x)), 0)\n            log2_unsigned := add(log2_unsigned, mul(is_high_nonzero, 0x40000000000000))\n            x := shr(is_high_nonzero, x)\n\n            // 53\n            x := shr(127, mul(x, x))\n            is_high_nonzero := eq(iszero(shr(128, x)), 0)\n            log2_unsigned := add(log2_unsigned, mul(is_high_nonzero, 0x20000000000000))\n            x := shr(is_high_nonzero, x)\n\n            // 52\n            x := shr(127, mul(x, x))\n            is_high_nonzero := eq(iszero(shr(128, x)), 0)\n            log2_unsigned := add(log2_unsigned, mul(is_high_nonzero, 0x10000000000000))\n            x := shr(is_high_nonzero, x)\n\n            // 51\n            x := shr(127, mul(x, x))\n            is_high_nonzero := eq(iszero(shr(128, x)), 0)\n            log2_unsigned := add(log2_unsigned, mul(is_high_nonzero, 0x8000000000000))\n            x := shr(is_high_nonzero, x)\n\n            // 50\n            x := shr(127, mul(x, x))\n            is_high_nonzero := eq(iszero(shr(128, x)), 0)\n            log2_unsigned := add(log2_unsigned, mul(is_high_nonzero, 0x4000000000000))\n            x := shr(is_high_nonzero, x)\n\n            // 49\n            x := shr(127, mul(x, x))\n            is_high_nonzero := eq(iszero(shr(128, x)), 0)\n            log2_unsigned := add(log2_unsigned, mul(is_high_nonzero, 0x2000000000000))\n            x := shr(is_high_nonzero, x)\n\n            // 48\n            x := shr(127, mul(x, x))\n            is_high_nonzero := eq(iszero(shr(128, x)), 0)\n            log2_unsigned := add(log2_unsigned, mul(is_high_nonzero, 0x1000000000000))\n            x := shr(is_high_nonzero, x)\n\n            // 47\n            x := shr(127, mul(x, x))\n            is_high_nonzero := eq(iszero(shr(128, x)), 0)\n            log2_unsigned := add(log2_unsigned, mul(is_high_nonzero, 0x800000000000))\n            x := shr(is_high_nonzero, x)\n\n            // 46\n            x := shr(127, mul(x, x))\n            is_high_nonzero := eq(iszero(shr(128, x)), 0)\n            log2_unsigned := add(log2_unsigned, mul(is_high_nonzero, 0x400000000000))\n            x := shr(is_high_nonzero, x)\n\n            // 45\n            x := shr(127, mul(x, x))\n            is_high_nonzero := eq(iszero(shr(128, x)), 0)\n            log2_unsigned := add(log2_unsigned, mul(is_high_nonzero, 0x200000000000))\n            x := shr(is_high_nonzero, x)\n\n            // 44\n            x := shr(127, mul(x, x))\n            is_high_nonzero := eq(iszero(shr(128, x)), 0)\n            log2_unsigned := add(log2_unsigned, mul(is_high_nonzero, 0x100000000000))\n            x := shr(is_high_nonzero, x)\n\n            // 43\n            x := shr(127, mul(x, x))\n            is_high_nonzero := eq(iszero(shr(128, x)), 0)\n            log2_unsigned := add(log2_unsigned, mul(is_high_nonzero, 0x80000000000))\n            x := shr(is_high_nonzero, x)\n\n            // 42\n            x := shr(127, mul(x, x))\n            is_high_nonzero := eq(iszero(shr(128, x)), 0)\n            log2_unsigned := add(log2_unsigned, mul(is_high_nonzero, 0x40000000000))\n        }\n\n        // 25572630076711825471857579 == 2**64/(log base 2 of sqrt tick size)\n        // https://www.wolframalpha.com/input?i=floor%28%281%2F+log+base+2+of+%28sqrt%281.000001%29%29%29*2**64%29\n        int256 logBaseTickSizeX128 =\n            (negative ? -int256(log2_unsigned) : int256(log2_unsigned)) * 25572630076711825471857579;\n\n        int32 tickLow;\n        int32 tickHigh;\n\n        if (negative) {\n            tickLow = int32((logBaseTickSizeX128 - 112469616488610087266845472033458199637) >> 128);\n            tickHigh = int32((logBaseTickSizeX128) >> 128);\n        } else {\n            tickLow = int32((logBaseTickSizeX128) >> 128);\n            tickHigh = int32((logBaseTickSizeX128 + 112469616488610087266845472033458199637) >> 128);\n        }\n\n        if (tickLow == tickHigh) {\n            return tickLow;\n        }\n\n        if (tickToSqrtRatio(tickHigh) <= sqrtRatio) return tickHigh;\n\n        return tickLow;\n    }\n}\n"}, "src/math/bitmap.sol": {"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.30;\n\nimport {LibBit} from \"solady/utils/LibBit.sol\";\n\ntype Bitmap is uint256;\n\nusing {toggle, isSet, leSetBit, geSetBit} for Bitmap global;\n\nfunction toggle(Bitmap bitmap, uint8 index) pure returns (Bitmap result) {\n    assembly (\"memory-safe\") {\n        result := xor(bitmap, shl(index, 1))\n    }\n}\n\nfunction isSet(Bitmap bitmap, uint8 index) pure returns (bool yes) {\n    assembly (\"memory-safe\") {\n        yes := and(shr(index, bitmap), 1)\n    }\n}\n\n// Returns the index of the most significant bit that is set _and_ less or equally significant to index, or 256 if no such bit exists.\nfunction leSetBit(Bitmap bitmap, uint8 index) pure returns (uint256) {\n    unchecked {\n        uint256 masked;\n        assembly (\"memory-safe\") {\n            masked := and(bitmap, sub(shl(add(index, 1), 1), 1))\n        }\n        return LibBit.fls(masked);\n    }\n}\n\n// Returns the index of the least significant bit that is set _and_ more or equally significant to index, or 256 if no such bit exists.\nfunction geSetBit(Bitmap bitmap, uint8 index) pure returns (uint256) {\n    unchecked {\n        uint256 masked;\n        assembly (\"memory-safe\") {\n            masked := and(bitmap, not(sub(shl(index, 1), 1)))\n        }\n        return LibBit.ffs(masked);\n    }\n}\n"}, "lib/solady/src/utils/FixedPointMathLib.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error ExpOverflow();\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error FactorialOverflow();\n\n    /// @dev The operation failed, due to an overflow.\n    error RPowOverflow();\n\n    /// @dev The mantissa is too big to fit.\n    error MantissaOverflow();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error MulWadFailed();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error SMulWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error DivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error SDivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error MulDivFailed();\n\n    /// @dev The division failed, as the denominator is zero.\n    error DivFailed();\n\n    /// @dev The full precision multiply-divide operation failed, either due\n    /// to the result being larger than 256 bits, or a division by a zero.\n    error FullMulDivFailed();\n\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\n    error LnWadUndefined();\n\n    /// @dev The input outside the acceptable domain.\n    error OutOfDomain();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         CONSTANTS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The scalar of ETH and most ERC20s.\n    uint256 internal constant WAD = 1e18;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if gt(x, div(not(0), y)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function sMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require((x == 0 || z / x == y) && !(x == -1 && y == type(int256).min))`.\n            if iszero(gt(or(iszero(x), eq(sdiv(z, x), y)), lt(not(x), eq(y, shl(255, 1))))) {\n                mstore(0x00, 0xedcd4dd4) // `SMulWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawMulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawSMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if iszero(eq(div(z, y), x)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := add(iszero(iszero(mod(z, WAD))), div(z, WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up, but without overflow checks.\n    function rawMulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function sDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, WAD)\n            // Equivalent to `require(y != 0 && ((x * WAD) / WAD == x))`.\n            if iszero(mul(y, eq(sdiv(z, WAD), x))) {\n                mstore(0x00, 0x5c43740d) // `SDivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawDivWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawSDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up, but without overflow and divide by zero checks.\n    function rawDivWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `x` to the power of `y`.\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\n    /// Note: This function is an approximation.\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Using `ln(x)` means `x` must be greater than 0.\n        return expWad((lnWad(x) * y) / int256(WAD));\n    }\n\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2\u03c0.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is less than 0.5 we return zero.\n            // This happens when `x <= (log(1e-18) * 1e18) ~ -4.15e19`.\n            if (x <= -41446531673892822313) return r;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // When the result is greater than `(2**255 - 1) / 1e18` we can not represent it as\n                // an int. This happens when `x >= floor(log((2**255 - 1) / 1e18) * 1e18) \u2248 135`.\n                if iszero(slt(x, 135305999368893231589)) {\n                    mstore(0x00, 0xa37bfec9) // `ExpOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            // `x` is now in the range `(-42, 136) * 1e18`. Convert to `(-42, 136) * 2**96`\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5 ** 18;\n\n            // Reduce range of x to (-\u00bd ln 2, \u00bd ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // `k` is in the range `[-61, 195]`.\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // `p` is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already `2**96` too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range `(0.09, 0.25) * 2**96`.\n\n            // We now need to multiply r by:\n            // - The scale factor `s \u2248 6.031367120`.\n            // - The `2**k` factor from the range reduction.\n            // - The `1e18 / 2**96` factor for base conversion.\n            // We do this all at once, with an intermediate result in `2**213`\n            // basis, so the final right shift is always by a positive amount.\n            r = int256(\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\n            );\n        }\n    }\n\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2\u03c0.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We want to convert `x` from `10**18` fixed point to `2**96` fixed point.\n            // We do this by multiplying by `2**96 / 10**18`. But since\n            // `ln(x * C) = ln(x) + ln(C)`, we can simply do nothing here\n            // and add `ln(2**96 / 10**18)` at the end.\n\n            // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // We place the check here for more optimal stack operations.\n            if iszero(sgt(x, 0)) {\n                mstore(0x00, 0x1615e638) // `LnWadUndefined()`.\n                revert(0x1c, 0x04)\n            }\n            // forgefmt: disable-next-item\n            r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            x := shr(159, shl(r, x))\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // `p` is made monic, we will multiply by a scale factor later.\n            // forgefmt: disable-next-item\n            let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.\n                sar(96, mul(add(43456485725739037958740375743393,\n                sar(96, mul(add(24828157081833163892658089445524,\n                sar(96, mul(add(3273285459638523848632254066296,\n                    x), x))), x))), x)), 11111509109440967052023855526967)\n            p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)\n            p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)\n            p := sub(mul(p, x), shl(96, 795164235651350426258249787498))\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n\n            // `q` is monic by convention.\n            let q := add(5573035233440673466300451813936, x)\n            q := add(71694874799317883764090561454958, sar(96, mul(x, q)))\n            q := add(283447036172924575727196451306956, sar(96, mul(x, q)))\n            q := add(401686690394027663651624208769553, sar(96, mul(x, q)))\n            q := add(204048457590392012362485061816622, sar(96, mul(x, q)))\n            q := add(31853899698501571402653359427138, sar(96, mul(x, q)))\n            q := add(909429971244387300277376558375, sar(96, mul(x, q)))\n\n            // `p / q` is in the range `(0, 0.125) * 2**96`.\n\n            // Finalization, we need to:\n            // - Multiply by the scale factor `s = 5.549\u2026`.\n            // - Add `ln(2**96 / 10**18)`.\n            // - Add `k * ln(2)`.\n            // - Multiply by `10**18 / 2**96 = 5**18 >> 78`.\n\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already `2**96` too large.\n            p := sdiv(p, q)\n            // Multiply by the scaling factor: `s * 5**18 * 2**96`, base is now `5**18 * 2**192`.\n            p := mul(1677202110996718588342820967067443963516166, p)\n            // Add `ln(2) * k * 5**18 * 2**192`.\n            // forgefmt: disable-next-item\n            p := add(mul(16597577552685614221487285958193947469193820559219878177908093499208371, sub(159, r)), p)\n            // Add `ln(2**96 / 10**18) * 5**18 * 2**192`.\n            p := add(600920179829731861736702779321621459595472258049074101567377883020018308, p)\n            // Base conversion: mul `2**18 / 2**192`.\n            r := sar(174, p)\n        }\n    }\n\n    /// @dev Returns `W_0(x)`, denominated in `WAD`.\n    /// See: https://en.wikipedia.org/wiki/Lambert_W_function\n    /// a.k.a. Product log function. This is an approximation of the principal branch.\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lambertW0Wad(int256 x) internal pure returns (int256 w) {\n        // forgefmt: disable-next-item\n        unchecked {\n            if ((w = x) <= -367879441171442322) revert OutOfDomain(); // `x` less than `-1/e`.\n            (int256 wad, int256 p) = (int256(WAD), x);\n            uint256 c; // Whether we need to avoid catastrophic cancellation.\n            uint256 i = 4; // Number of iterations.\n            if (w <= 0x1ffffffffffff) {\n                if (-0x4000000000000 <= w) {\n                    i = 1; // Inputs near zero only take one step to converge.\n                } else if (w <= -0x3ffffffffffffff) {\n                    i = 32; // Inputs near `-1/e` take very long to converge.\n                }\n            } else if (uint256(w >> 63) == uint256(0)) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // Inline log2 for more performance, since the range is small.\n                    let v := shr(49, w)\n                    let l := shl(3, lt(0xff, v))\n                    l := add(or(l, byte(and(0x1f, shr(shr(l, v), 0x8421084210842108cc6318c6db6d54be)),\n                        0x0706060506020504060203020504030106050205030304010505030400000000)), 49)\n                    w := sdiv(shl(l, 7), byte(sub(l, 31), 0x0303030303030303040506080c13))\n                    c := gt(l, 60)\n                    i := add(2, add(gt(l, 53), c))\n                }\n            } else {\n                int256 ll = lnWad(w = lnWad(w));\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // `w = ln(x) - ln(ln(x)) + b * ln(ln(x)) / ln(x)`.\n                    w := add(sdiv(mul(ll, 1023715080943847266), w), sub(w, ll))\n                    i := add(3, iszero(shr(68, x)))\n                    c := iszero(shr(143, x))\n                }\n                if (c == uint256(0)) {\n                    do { // If `x` is big, use Newton's so that intermediate values won't overflow.\n                        int256 e = expWad(w);\n                        /// @solidity memory-safe-assembly\n                        assembly {\n                            let t := mul(w, div(e, wad))\n                            w := sub(w, sdiv(sub(t, x), div(add(e, t), wad)))\n                        }\n                        if (p <= w) break;\n                        p = w;\n                    } while (--i != uint256(0));\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        w := sub(w, sgt(w, 2))\n                    }\n                    return w;\n                }\n            }\n            do { // Otherwise, use Halley's for faster convergence.\n                int256 e = expWad(w);\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let t := add(w, wad)\n                    let s := sub(mul(w, e), mul(x, wad))\n                    w := sub(w, sdiv(mul(s, wad), sub(mul(e, t), sdiv(mul(add(t, wad), s), add(t, t)))))\n                }\n                if (p <= w) break;\n                p = w;\n            } while (--i != c);\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sub(w, sgt(w, 2))\n            }\n            // For certain ranges of `x`, we'll use the quadratic-rate recursive formula of\n            // R. Iacono and J.P. Boyd for the last iteration, to avoid catastrophic cancellation.\n            if (c == uint256(0)) return w;\n            int256 t = w | 1;\n            /// @solidity memory-safe-assembly\n            assembly {\n                x := sdiv(mul(x, wad), t)\n            }\n            x = (t * (wad + lnWad(x)));\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sdiv(x, add(wad, t))\n            }\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                  GENERAL NUMBER UTILITIES                  */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns `a * b == x * y`, with full precision.\n    function fullMulEq(uint256 a, uint256 b, uint256 x, uint256 y)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(mul(a, b), mul(x, y)), eq(mulmod(x, y, not(0)), mulmod(a, b, not(0))))\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Remco Bloemen under MIT license: https://2\u03c0.com/21/muldiv\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // 512-bit multiply `[p1 p0] = x * y`.\n            // Compute the product mod `2**256` and mod `2**256 - 1`\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that `product = p1 * 2**256 + p0`.\n\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`.\n            for {} 1 {} {\n                // If overflows.\n                if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n\n                    /*------------------- 512 by 256 division --------------------*/\n\n                    // Make division exact by subtracting the remainder from `[p1 p0]`.\n                    let r := mulmod(x, y, d) // Compute remainder using mulmod.\n                    let t := and(d, sub(0, d)) // The least significant bit of `d`. `t >= 1`.\n                    // Make sure `z` is less than `2**256`. Also prevents `d == 0`.\n                    // Placing the check here seems to give more optimal stack operations.\n                    if iszero(gt(d, p1)) {\n                        mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    d := div(d, t) // Divide `d` by `t`, which is a power of two.\n                    // Invert `d mod 2**256`\n                    // Now that `d` is an odd number, it has an inverse\n                    // modulo `2**256` such that `d * inv = 1 mod 2**256`.\n                    // Compute the inverse by starting with a seed that is correct\n                    // correct for four bits. That is, `d * inv = 1 mod 2**4`.\n                    let inv := xor(2, mul(3, d))\n                    // Now use Newton-Raphson iteration to improve the precision.\n                    // Thanks to Hensel's lifting lemma, this also works in modular\n                    // arithmetic, doubling the correct bits in each step.\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\n                    z :=\n                        mul(\n                            // Divide [p1 p0] by the factors of two.\n                            // Shift in bits from `p1` into `p0`. For this we need\n                            // to flip `t` such that it is `2**256 / t`.\n                            or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                            mul(sub(2, mul(d, inv)), inv) // inverse mod 2**256\n                        )\n                    break\n                }\n                z := div(z, d)\n                break\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Behavior is undefined if `d` is zero or the final result cannot fit in 256 bits.\n    /// Performs the full 512 bit calculation regardless.\n    function fullMulDivUnchecked(uint256 x, uint256 y, uint256 d)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            let mm := mulmod(x, y, not(0))\n            let p1 := sub(mm, add(z, lt(mm, z)))\n            let t := and(d, sub(0, d))\n            let r := mulmod(x, y, d)\n            d := div(d, t)\n            let inv := xor(2, mul(3, d))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            z :=\n                mul(\n                    or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                    mul(sub(2, mul(d, inv)), inv)\n                )\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Uniswap-v3-core under MIT license:\n    /// https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/FullMath.sol\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        z = fullMulDiv(x, y, d);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mulmod(x, y, d) {\n                z := add(z, 1)\n                if iszero(z) {\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / 2 ** n)` with full precision.\n    /// Throws if result overflows a uint256.\n    /// Credit to Philogy under MIT license:\n    /// https://github.com/SorellaLabs/angstrom/blob/main/contracts/src/libraries/X128MathLib.sol\n    function fullMulDivN(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`. We'll call this `z`.\n            for {} 1 {} {\n                if iszero(or(iszero(x), eq(div(z, x), y))) {\n                    let k := and(n, 0xff) // `n`, cleaned.\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n                    //         |      p1     |      z     |\n                    // Before: | p1_0 \u00a6 p1_1 | z_0  \u00a6 z_1 |\n                    // Final:  |   0  \u00a6 p1_0 | p1_1 \u00a6 z_0 |\n                    // Check that final `z` doesn't overflow by checking that p1_0 = 0.\n                    if iszero(shr(k, p1)) {\n                        z := add(shl(sub(256, k), p1), shr(k, z))\n                        break\n                    }\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                z := shr(and(n, 0xff), z)\n                break\n            }\n        }\n    }\n\n    /// @dev Returns `floor(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(z, d)\n        }\n    }\n\n    /// @dev Returns `ceil(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(z, d))), div(z, d))\n        }\n    }\n\n    /// @dev Returns `x`, the modular multiplicative inverse of `a`, such that `(a * x) % n == 1`.\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256 x) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let g := n\n            let r := mod(a, n)\n            for { let y := 1 } 1 {} {\n                let q := div(g, r)\n                let t := g\n                g := r\n                r := sub(t, mul(r, q))\n                let u := x\n                x := y\n                y := sub(u, mul(y, q))\n                if iszero(r) { break }\n            }\n            x := mul(eq(g, 1), add(x, mul(slt(x, 0), n)))\n        }\n    }\n\n    /// @dev Returns `ceil(x / d)`.\n    /// Reverts if `d` is zero.\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(d) {\n                mstore(0x00, 0x65244e4e) // `DivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\n        }\n    }\n\n    /// @dev Returns `max(0, x - y)`. Alias for `saturatingSub`.\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n\n    /// @dev Returns `max(0, x - y)`.\n    function saturatingSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n\n    /// @dev Returns `min(2 ** 256 - 1, x + y)`.\n    function saturatingAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(sub(0, lt(add(x, y), x)), add(x, y))\n        }\n    }\n\n    /// @dev Returns `min(2 ** 256 - 1, x * y)`.\n    function saturatingMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(sub(or(iszero(x), eq(div(mul(x, y), x), y)), 1), mul(x, y))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, address x, address y) internal pure returns (address z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `x != 0 ? x : y`, without branching.\n    function coalesce(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, mul(y, iszero(x)))\n        }\n    }\n\n    /// @dev Returns `x != bytes32(0) ? x : y`, without branching.\n    function coalesce(bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, mul(y, iszero(x)))\n        }\n    }\n\n    /// @dev Returns `x != address(0) ? x : y`, without branching.\n    function coalesce(address x, address y) internal pure returns (address z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, mul(y, iszero(shl(96, x))))\n        }\n    }\n\n    /// @dev Exponentiate `x` to `y` by squaring, denominated in base `b`.\n    /// Reverts if the computation overflows.\n    function rpow(uint256 x, uint256 y, uint256 b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(b, iszero(y)) // `0 ** 0 = 1`. Otherwise, `0 ** n = 0`.\n            if x {\n                z := xor(b, mul(xor(b, x), and(y, 1))) // `z = isEven(y) ? scale : x`\n                let half := shr(1, b) // Divide `b` by 2.\n                // Divide `y` by 2 every iteration.\n                for { y := shr(1, y) } y { y := shr(1, y) } {\n                    let xx := mul(x, x) // Store x squared.\n                    let xxRound := add(xx, half) // Round to the nearest number.\n                    // Revert if `xx + half` overflowed, or if `x ** 2` overflows.\n                    if or(lt(xxRound, xx), shr(128, x)) {\n                        mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                        revert(0x1c, 0x04)\n                    }\n                    x := div(xxRound, b) // Set `x` to scaled `xxRound`.\n                    // If `y` is odd:\n                    if and(y, 1) {\n                        let zx := mul(z, x) // Compute `z * x`.\n                        let zxRound := add(zx, half) // Round to the nearest number.\n                        // If `z * x` overflowed or `zx + half` overflowed:\n                        if or(xor(div(zx, x), z), lt(zxRound, zx)) {\n                            // Revert if `x` is non-zero.\n                            if x {\n                                mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                                revert(0x1c, 0x04)\n                            }\n                        }\n                        z := div(zxRound, b) // Return properly scaled `zxRound`.\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns the square root of `x`, rounded down.\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // Let `y = x / 2**r`. We check `y >= 2**(k + 8)`\n            // but shift right by `k` bits to ensure that if `x >= 256`, then `y >= 256`.\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\n            z := shl(shr(1, r), z)\n\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\n\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\n\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\n\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\n            // Then we can estimate `sqrt(y)` using\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\n\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If `x+1` is a perfect square, the Babylonian method cycles between\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, rounded down.\n    /// Credit to bout3fiddy and pcaversaccio under AGPLv3 license:\n    /// https://github.com/pcaversaccio/snekmate/blob/main/src/utils/Math.vy\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // Makeshift lookup table to nudge the approximate log2 result.\n            z := div(shl(div(r, 3), shl(lt(0xf, shr(r, x)), 0xf)), xor(7, mod(r, 3)))\n            // Newton-Raphson's.\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            // Round down.\n            z := sub(z, lt(div(x, mul(z, z)), z))\n        }\n    }\n\n    /// @dev Returns the square root of `x`, denominated in `WAD`, rounded down.\n    function sqrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 18) return sqrt(x * 10 ** 18);\n            z = (1 + sqrt(x)) * 10 ** 9;\n            z = (fullMulDivUnchecked(x, 10 ** 18, z) + z) >> 1;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sub(z, gt(999999999999999999, sub(mulmod(z, z, x), 1))) // Round down.\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, denominated in `WAD`, rounded down.\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 36) return cbrt(x * 10 ** 36);\n            z = (1 + cbrt(x)) * 10 ** 12;\n            z = (fullMulDivUnchecked(x, 10 ** 36, z * z) + z + z) / 3;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let p := x\n            for {} 1 {} {\n                if iszero(shr(229, p)) {\n                    if iszero(shr(199, p)) {\n                        p := mul(p, 100000000000000000) // 10 ** 17.\n                        break\n                    }\n                    p := mul(p, 100000000) // 10 ** 8.\n                    break\n                }\n                if iszero(shr(249, p)) { p := mul(p, 100) }\n                break\n            }\n            let t := mulmod(mul(z, z), z, p)\n            z := sub(z, gt(lt(t, shr(1, p)), iszero(t))) // Round down.\n        }\n    }\n\n    /// @dev Returns the factorial of `x`.\n    function factorial(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := 1\n            if iszero(lt(x, 58)) {\n                mstore(0x00, 0xaba0f2a2) // `FactorialOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            for {} x { x := sub(x, 1) } { z := mul(z, x) }\n        }\n    }\n\n    /// @dev Returns the log2 of `x`.\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\n    /// Returns 0 if `x` is zero.\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020504060203020504030106050205030304010505030400000000))\n        }\n    }\n\n    /// @dev Returns the log2 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\n        r = log2(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(r, 1), x))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log10(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, 100000000000000000000000000000000000000)) {\n                x := div(x, 100000000000000000000000000000000000000)\n                r := 38\n            }\n            if iszero(lt(x, 100000000000000000000)) {\n                x := div(x, 100000000000000000000)\n                r := add(r, 20)\n            }\n            if iszero(lt(x, 10000000000)) {\n                x := div(x, 10000000000)\n                r := add(r, 10)\n            }\n            if iszero(lt(x, 100000)) {\n                x := div(x, 100000)\n                r := add(r, 5)\n            }\n            r := add(r, add(gt(x, 9), add(gt(x, 99), add(gt(x, 999), gt(x, 9999)))))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log10Up(uint256 x) internal pure returns (uint256 r) {\n        r = log10(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(exp(10, r), x))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(shr(3, r), lt(0xff, shr(r, x)))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log256Up(uint256 x) internal pure returns (uint256 r) {\n        r = log256(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(shl(3, r), 1), x))\n        }\n    }\n\n    /// @dev Returns the scientific notation format `mantissa * 10 ** exponent` of `x`.\n    /// Useful for compressing prices (e.g. using 25 bit mantissa and 7 bit exponent).\n    function sci(uint256 x) internal pure returns (uint256 mantissa, uint256 exponent) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mantissa := x\n            if mantissa {\n                if iszero(mod(mantissa, 1000000000000000000000000000000000)) {\n                    mantissa := div(mantissa, 1000000000000000000000000000000000)\n                    exponent := 33\n                }\n                if iszero(mod(mantissa, 10000000000000000000)) {\n                    mantissa := div(mantissa, 10000000000000000000)\n                    exponent := add(exponent, 19)\n                }\n                if iszero(mod(mantissa, 1000000000000)) {\n                    mantissa := div(mantissa, 1000000000000)\n                    exponent := add(exponent, 12)\n                }\n                if iszero(mod(mantissa, 1000000)) {\n                    mantissa := div(mantissa, 1000000)\n                    exponent := add(exponent, 6)\n                }\n                if iszero(mod(mantissa, 10000)) {\n                    mantissa := div(mantissa, 10000)\n                    exponent := add(exponent, 4)\n                }\n                if iszero(mod(mantissa, 100)) {\n                    mantissa := div(mantissa, 100)\n                    exponent := add(exponent, 2)\n                }\n                if iszero(mod(mantissa, 10)) {\n                    mantissa := div(mantissa, 10)\n                    exponent := add(exponent, 1)\n                }\n            }\n        }\n    }\n\n    /// @dev Convenience function for packing `x` into a smaller number using `sci`.\n    /// The `mantissa` will be in bits [7..255] (the upper 249 bits).\n    /// The `exponent` will be in bits [0..6] (the lower 7 bits).\n    /// Use `SafeCastLib` to safely ensure that the `packed` number is small\n    /// enough to fit in the desired unsigned integer type:\n    /// ```\n    ///     uint32 packed = SafeCastLib.toUint32(FixedPointMathLib.packSci(777 ether));\n    /// ```\n    function packSci(uint256 x) internal pure returns (uint256 packed) {\n        (x, packed) = sci(x); // Reuse for `mantissa` and `exponent`.\n        /// @solidity memory-safe-assembly\n        assembly {\n            if shr(249, x) {\n                mstore(0x00, 0xce30380c) // `MantissaOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            packed := or(shl(7, x), packed)\n        }\n    }\n\n    /// @dev Convenience function for unpacking a packed number from `packSci`.\n    function unpackSci(uint256 packed) internal pure returns (uint256 unpacked) {\n        unchecked {\n            unpacked = (packed >> 7) * 10 ** (packed & 0x7f);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards zero.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = (x & y) + ((x ^ y) >> 1);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards negative infinity.\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @dev Returns the absolute value of `x`.\n    function abs(int256 x) internal pure returns (uint256 z) {\n        unchecked {\n            z = (uint256(x) + uint256(x >> 255)) ^ uint256(x >> 255);\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, gt(x, y)), sub(y, x)), gt(x, y))\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, sgt(x, y)), sub(y, x)), sgt(x, y))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), lt(y, x)))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), slt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), gt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), gt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), lt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), sgt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), slt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns greatest common divisor of `x` and `y`.\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { z := x } y {} {\n                let t := y\n                y := mod(z, y)\n                z := t\n            }\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`,\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(uint256 a, uint256 b, uint256 t, uint256 begin, uint256 end)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        unchecked {\n            if (b >= a) return a + fullMulDiv(b - a, t - begin, end - begin);\n            return a - fullMulDiv(a - b, t - begin, end - begin);\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`.\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(int256 a, int256 b, int256 t, int256 begin, int256 end)\n        internal\n        pure\n        returns (int256)\n    {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        // forgefmt: disable-next-item\n        unchecked {\n            if (b >= a) return int256(uint256(a) + fullMulDiv(uint256(b - a),\n                uint256(t - begin), uint256(end - begin)));\n            return int256(uint256(a) - fullMulDiv(uint256(a - b),\n                uint256(t - begin), uint256(end - begin)));\n        }\n    }\n\n    /// @dev Returns if `x` is an even number. Some people may need this.\n    function isEven(uint256 x) internal pure returns (bool) {\n        return x & uint256(1) == uint256(0);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                   RAW NUMBER OPERATIONS                    */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(x, y)\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mod(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := smod(x, y)\n        }\n    }\n\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := addmod(x, y, d)\n        }\n    }\n\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mulmod(x, y, d)\n        }\n    }\n}\n"}, "lib/solady/src/utils/SafeTransferLib.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\n///\n/// @dev Note:\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\nlibrary SafeTransferLib {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /// @dev The ERC20 `transferFrom` has failed.\n    error TransferFromFailed();\n\n    /// @dev The ERC20 `transfer` has failed.\n    error TransferFailed();\n\n    /// @dev The ERC20 `approve` has failed.\n    error ApproveFailed();\n\n    /// @dev The ERC20 `totalSupply` query has failed.\n    error TotalSupplyQueryFailed();\n\n    /// @dev The Permit2 operation has failed.\n    error Permit2Failed();\n\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\n    error Permit2AmountOverflow();\n\n    /// @dev The Permit2 approve operation has failed.\n    error Permit2ApproveFailed();\n\n    /// @dev The Permit2 lockdown operation has failed.\n    error Permit2LockdownFailed();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         CONSTANTS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\n\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\n    /// storage reads and writes, but low enough to prevent griefing.\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\n\n    /// @dev The unique EIP-712 domain domain separator for the DAI token contract.\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\n\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /// @dev The canonical Permit2 address.\n    /// [Github](https://github.com/Uniswap/permit2)\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       ETH OPERATIONS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\n    //\n    // The regular variants:\n    // - Forwards all remaining gas to the target.\n    // - Reverts if the target reverts.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The force variants:\n    // - Forwards with an optional gas stipend\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\n    // - If the target reverts, or if the gas stipend is exhausted,\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The try variants:\n    // - Forwards with a mandatory gas stipend.\n    // - Instead of reverting, returns whether the transfer succeeded.\n\n    /// @dev Sends `amount` (in wei) ETH to `to`.\n    function safeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`.\n    function safeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer all the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // forgefmt: disable-next-item\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      ERC20 OPERATIONS                      */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for\n    /// the current contract to manage.\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                success := lt(or(iszero(extcodesize(token)), returndatasize()), success)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have their entire balance approved for the current contract to manage.\n    function safeTransferAllFrom(address token, address from, address to)\n        internal\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransfer(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n            mstore(0x20, address()) // Store the address of the current contract.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x14, to) // Store the `to` argument.\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// Reverts upon failure.\n    function safeApprove(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\n    /// Reverts upon failure.\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, retrying upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x34, 0) // Store 0 for the `amount`.\n                    mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n                    pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\n                    mstore(0x34, amount) // Store back the original `amount`.\n                    // Retry the approval, reverting upon failure.\n                    success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                    if iszero(and(eq(mload(0x00), 1), success)) {\n                        // Check the `extcodesize` again just in case the token selfdestructs lol.\n                        if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                            mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                            revert(0x1c, 0x04)\n                        }\n                    }\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\n    /// Returns zero if the `token` does not exist.\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, account) // Store the `account` argument.\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            amount :=\n                mul( // The arguments of `mul` are evaluated from right to left.\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\n                    )\n                )\n        }\n    }\n\n    /// @dev Returns the total supply of the `token`.\n    /// Reverts if the token does not exist or does not implement `totalSupply()`.\n    function totalSupply(address token) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x18160ddd) // `totalSupply()`.\n            if iszero(\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), token, 0x1c, 0x04, 0x00, 0x20))\n            ) {\n                mstore(0x00, 0x54cd9435) // `TotalSupplyQueryFailed()`.\n                revert(0x1c, 0x04)\n            }\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\n        if (!trySafeTransferFrom(token, from, to, amount)) {\n            permit2TransferFrom(token, from, to, amount);\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\n    /// Reverts upon failure.\n    function permit2TransferFrom(address token, address from, address to, uint256 amount)\n        internal\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\n            mstore(add(m, 0x54), amount)\n            mstore(add(m, 0x34), to)\n            mstore(add(m, 0x20), shl(96, from))\n            // `transferFrom(address,address,uint160,address)`.\n            mstore(m, 0x36c78516000000000000000000000000)\n            let p := PERMIT2\n            let exists := eq(chainid(), 1)\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\n            if iszero(\n                and(\n                    call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00),\n                    lt(iszero(extcodesize(token)), exists) // Token has code and Permit2 exists.\n                )\n            ) {\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\n            }\n        }\n    }\n\n    /// @dev Permit a user to spend a given amount of\n    /// another user's tokens via native EIP-2612 permit if possible, falling\n    /// back to Permit2 if native permit fails or is not implemented on the token.\n    function permit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        bool success;\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} shl(96, xor(token, WETH9)) {} {\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\n                if iszero(\n                    and( // The arguments of `and` are evaluated from right to left.\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\n                    )\n                ) { break }\n                // After here, we can be sure that token is a contract.\n                let m := mload(0x40)\n                mstore(add(m, 0x34), spender)\n                mstore(add(m, 0x20), shl(96, owner))\n                mstore(add(m, 0x74), deadline)\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\n                    mstore(0x14, owner)\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\n                    mstore(\n                        add(m, 0x94),\n                        lt(iszero(amount), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\n                    )\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\n                    // `nonces` is already at `add(m, 0x54)`.\n                    // `amount != 0` is already stored at `add(m, 0x94)`.\n                    mstore(add(m, 0xb4), and(0xff, v))\n                    mstore(add(m, 0xd4), r)\n                    mstore(add(m, 0xf4), s)\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\n                    break\n                }\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\n                mstore(add(m, 0x54), amount)\n                mstore(add(m, 0x94), and(0xff, v))\n                mstore(add(m, 0xb4), r)\n                mstore(add(m, 0xd4), s)\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\n                break\n            }\n        }\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\n    }\n\n    /// @dev Simple permit on the Permit2 contract.\n    function simplePermit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\n            {\n                let addressMask := shr(96, not(0))\n                mstore(add(m, 0x20), and(addressMask, owner))\n                mstore(add(m, 0x40), and(addressMask, token))\n                mstore(add(m, 0x60), and(addressMask, spender))\n                mstore(add(m, 0xc0), and(addressMask, spender))\n            }\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\n                )\n            ) {\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\n            }\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\n            // `owner` is already `add(m, 0x20)`.\n            // `token` is already at `add(m, 0x40)`.\n            mstore(add(m, 0x60), amount)\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\n            // `nonce` is already at `add(m, 0xa0)`.\n            // `spender` is already at `add(m, 0xc0)`.\n            mstore(add(m, 0xe0), deadline)\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\n            mstore(add(m, 0x120), 0x41) // `signature` length.\n            mstore(add(m, 0x140), r)\n            mstore(add(m, 0x160), s)\n            mstore(add(m, 0x180), shl(248, v))\n            if iszero( // Revert if token does not have code, or if the call fails.\n            mul(extcodesize(token), call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00))) {\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Approves `spender` to spend `amount` of `token` for `address(this)`.\n    function permit2Approve(address token, address spender, uint160 amount, uint48 expiration)\n        internal\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let addressMask := shr(96, not(0))\n            let m := mload(0x40)\n            mstore(m, 0x87517c45) // `approve(address,address,uint160,uint48)`.\n            mstore(add(m, 0x20), and(addressMask, token))\n            mstore(add(m, 0x40), and(addressMask, spender))\n            mstore(add(m, 0x60), and(addressMask, amount))\n            mstore(add(m, 0x80), and(0xffffffffffff, expiration))\n            if iszero(call(gas(), PERMIT2, 0, add(m, 0x1c), 0xa0, codesize(), 0x00)) {\n                mstore(0x00, 0x324f14ae) // `Permit2ApproveFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Revokes an approval for `token` and `spender` for `address(this)`.\n    function permit2Lockdown(address token, address spender) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0xcc53287f) // `Permit2.lockdown`.\n            mstore(add(m, 0x20), 0x20) // Offset of the `approvals`.\n            mstore(add(m, 0x40), 1) // `approvals.length`.\n            mstore(add(m, 0x60), shr(96, shl(96, token)))\n            mstore(add(m, 0x80), shr(96, shl(96, spender)))\n            if iszero(call(gas(), PERMIT2, 0, add(m, 0x1c), 0xa0, codesize(), 0x00)) {\n                mstore(0x00, 0x96b3de23) // `Permit2LockdownFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"}, "lib/solady/src/utils/SafeCastLib.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Safe integer casting library that reverts on overflow.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeCastLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\n/// @dev Optimized for runtime gas for very high number of optimizer runs (i.e. >= 1000000).\nlibrary SafeCastLib {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Unable to cast to the target type due to overflow.\n    error Overflow();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*          UNSIGNED INTEGER SAFE CASTING OPERATIONS          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Casts `x` to a uint8. Reverts on overflow.\n    function toUint8(uint256 x) internal pure returns (uint8) {\n        if (x >= 1 << 8) _revertOverflow();\n        return uint8(x);\n    }\n\n    /// @dev Casts `x` to a uint16. Reverts on overflow.\n    function toUint16(uint256 x) internal pure returns (uint16) {\n        if (x >= 1 << 16) _revertOverflow();\n        return uint16(x);\n    }\n\n    /// @dev Casts `x` to a uint24. Reverts on overflow.\n    function toUint24(uint256 x) internal pure returns (uint24) {\n        if (x >= 1 << 24) _revertOverflow();\n        return uint24(x);\n    }\n\n    /// @dev Casts `x` to a uint32. Reverts on overflow.\n    function toUint32(uint256 x) internal pure returns (uint32) {\n        if (x >= 1 << 32) _revertOverflow();\n        return uint32(x);\n    }\n\n    /// @dev Casts `x` to a uint40. Reverts on overflow.\n    function toUint40(uint256 x) internal pure returns (uint40) {\n        if (x >= 1 << 40) _revertOverflow();\n        return uint40(x);\n    }\n\n    /// @dev Casts `x` to a uint48. Reverts on overflow.\n    function toUint48(uint256 x) internal pure returns (uint48) {\n        if (x >= 1 << 48) _revertOverflow();\n        return uint48(x);\n    }\n\n    /// @dev Casts `x` to a uint56. Reverts on overflow.\n    function toUint56(uint256 x) internal pure returns (uint56) {\n        if (x >= 1 << 56) _revertOverflow();\n        return uint56(x);\n    }\n\n    /// @dev Casts `x` to a uint64. Reverts on overflow.\n    function toUint64(uint256 x) internal pure returns (uint64) {\n        if (x >= 1 << 64) _revertOverflow();\n        return uint64(x);\n    }\n\n    /// @dev Casts `x` to a uint72. Reverts on overflow.\n    function toUint72(uint256 x) internal pure returns (uint72) {\n        if (x >= 1 << 72) _revertOverflow();\n        return uint72(x);\n    }\n\n    /// @dev Casts `x` to a uint80. Reverts on overflow.\n    function toUint80(uint256 x) internal pure returns (uint80) {\n        if (x >= 1 << 80) _revertOverflow();\n        return uint80(x);\n    }\n\n    /// @dev Casts `x` to a uint88. Reverts on overflow.\n    function toUint88(uint256 x) internal pure returns (uint88) {\n        if (x >= 1 << 88) _revertOverflow();\n        return uint88(x);\n    }\n\n    /// @dev Casts `x` to a uint96. Reverts on overflow.\n    function toUint96(uint256 x) internal pure returns (uint96) {\n        if (x >= 1 << 96) _revertOverflow();\n        return uint96(x);\n    }\n\n    /// @dev Casts `x` to a uint104. Reverts on overflow.\n    function toUint104(uint256 x) internal pure returns (uint104) {\n        if (x >= 1 << 104) _revertOverflow();\n        return uint104(x);\n    }\n\n    /// @dev Casts `x` to a uint112. Reverts on overflow.\n    function toUint112(uint256 x) internal pure returns (uint112) {\n        if (x >= 1 << 112) _revertOverflow();\n        return uint112(x);\n    }\n\n    /// @dev Casts `x` to a uint120. Reverts on overflow.\n    function toUint120(uint256 x) internal pure returns (uint120) {\n        if (x >= 1 << 120) _revertOverflow();\n        return uint120(x);\n    }\n\n    /// @dev Casts `x` to a uint128. Reverts on overflow.\n    function toUint128(uint256 x) internal pure returns (uint128) {\n        if (x >= 1 << 128) _revertOverflow();\n        return uint128(x);\n    }\n\n    /// @dev Casts `x` to a uint136. Reverts on overflow.\n    function toUint136(uint256 x) internal pure returns (uint136) {\n        if (x >= 1 << 136) _revertOverflow();\n        return uint136(x);\n    }\n\n    /// @dev Casts `x` to a uint144. Reverts on overflow.\n    function toUint144(uint256 x) internal pure returns (uint144) {\n        if (x >= 1 << 144) _revertOverflow();\n        return uint144(x);\n    }\n\n    /// @dev Casts `x` to a uint152. Reverts on overflow.\n    function toUint152(uint256 x) internal pure returns (uint152) {\n        if (x >= 1 << 152) _revertOverflow();\n        return uint152(x);\n    }\n\n    /// @dev Casts `x` to a uint160. Reverts on overflow.\n    function toUint160(uint256 x) internal pure returns (uint160) {\n        if (x >= 1 << 160) _revertOverflow();\n        return uint160(x);\n    }\n\n    /// @dev Casts `x` to a uint168. Reverts on overflow.\n    function toUint168(uint256 x) internal pure returns (uint168) {\n        if (x >= 1 << 168) _revertOverflow();\n        return uint168(x);\n    }\n\n    /// @dev Casts `x` to a uint176. Reverts on overflow.\n    function toUint176(uint256 x) internal pure returns (uint176) {\n        if (x >= 1 << 176) _revertOverflow();\n        return uint176(x);\n    }\n\n    /// @dev Casts `x` to a uint184. Reverts on overflow.\n    function toUint184(uint256 x) internal pure returns (uint184) {\n        if (x >= 1 << 184) _revertOverflow();\n        return uint184(x);\n    }\n\n    /// @dev Casts `x` to a uint192. Reverts on overflow.\n    function toUint192(uint256 x) internal pure returns (uint192) {\n        if (x >= 1 << 192) _revertOverflow();\n        return uint192(x);\n    }\n\n    /// @dev Casts `x` to a uint200. Reverts on overflow.\n    function toUint200(uint256 x) internal pure returns (uint200) {\n        if (x >= 1 << 200) _revertOverflow();\n        return uint200(x);\n    }\n\n    /// @dev Casts `x` to a uint208. Reverts on overflow.\n    function toUint208(uint256 x) internal pure returns (uint208) {\n        if (x >= 1 << 208) _revertOverflow();\n        return uint208(x);\n    }\n\n    /// @dev Casts `x` to a uint216. Reverts on overflow.\n    function toUint216(uint256 x) internal pure returns (uint216) {\n        if (x >= 1 << 216) _revertOverflow();\n        return uint216(x);\n    }\n\n    /// @dev Casts `x` to a uint224. Reverts on overflow.\n    function toUint224(uint256 x) internal pure returns (uint224) {\n        if (x >= 1 << 224) _revertOverflow();\n        return uint224(x);\n    }\n\n    /// @dev Casts `x` to a uint232. Reverts on overflow.\n    function toUint232(uint256 x) internal pure returns (uint232) {\n        if (x >= 1 << 232) _revertOverflow();\n        return uint232(x);\n    }\n\n    /// @dev Casts `x` to a uint240. Reverts on overflow.\n    function toUint240(uint256 x) internal pure returns (uint240) {\n        if (x >= 1 << 240) _revertOverflow();\n        return uint240(x);\n    }\n\n    /// @dev Casts `x` to a uint248. Reverts on overflow.\n    function toUint248(uint256 x) internal pure returns (uint248) {\n        if (x >= 1 << 248) _revertOverflow();\n        return uint248(x);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*           SIGNED INTEGER SAFE CASTING OPERATIONS           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Casts `x` to a int8. Reverts on overflow.\n    function toInt8(int256 x) internal pure returns (int8) {\n        unchecked {\n            if (((1 << 7) + uint256(x)) >> 8 == uint256(0)) return int8(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int16. Reverts on overflow.\n    function toInt16(int256 x) internal pure returns (int16) {\n        unchecked {\n            if (((1 << 15) + uint256(x)) >> 16 == uint256(0)) return int16(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int24. Reverts on overflow.\n    function toInt24(int256 x) internal pure returns (int24) {\n        unchecked {\n            if (((1 << 23) + uint256(x)) >> 24 == uint256(0)) return int24(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int32. Reverts on overflow.\n    function toInt32(int256 x) internal pure returns (int32) {\n        unchecked {\n            if (((1 << 31) + uint256(x)) >> 32 == uint256(0)) return int32(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int40. Reverts on overflow.\n    function toInt40(int256 x) internal pure returns (int40) {\n        unchecked {\n            if (((1 << 39) + uint256(x)) >> 40 == uint256(0)) return int40(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int48. Reverts on overflow.\n    function toInt48(int256 x) internal pure returns (int48) {\n        unchecked {\n            if (((1 << 47) + uint256(x)) >> 48 == uint256(0)) return int48(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int56. Reverts on overflow.\n    function toInt56(int256 x) internal pure returns (int56) {\n        unchecked {\n            if (((1 << 55) + uint256(x)) >> 56 == uint256(0)) return int56(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int64. Reverts on overflow.\n    function toInt64(int256 x) internal pure returns (int64) {\n        unchecked {\n            if (((1 << 63) + uint256(x)) >> 64 == uint256(0)) return int64(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int72. Reverts on overflow.\n    function toInt72(int256 x) internal pure returns (int72) {\n        unchecked {\n            if (((1 << 71) + uint256(x)) >> 72 == uint256(0)) return int72(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int80. Reverts on overflow.\n    function toInt80(int256 x) internal pure returns (int80) {\n        unchecked {\n            if (((1 << 79) + uint256(x)) >> 80 == uint256(0)) return int80(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int88. Reverts on overflow.\n    function toInt88(int256 x) internal pure returns (int88) {\n        unchecked {\n            if (((1 << 87) + uint256(x)) >> 88 == uint256(0)) return int88(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int96. Reverts on overflow.\n    function toInt96(int256 x) internal pure returns (int96) {\n        unchecked {\n            if (((1 << 95) + uint256(x)) >> 96 == uint256(0)) return int96(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int104. Reverts on overflow.\n    function toInt104(int256 x) internal pure returns (int104) {\n        unchecked {\n            if (((1 << 103) + uint256(x)) >> 104 == uint256(0)) return int104(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int112. Reverts on overflow.\n    function toInt112(int256 x) internal pure returns (int112) {\n        unchecked {\n            if (((1 << 111) + uint256(x)) >> 112 == uint256(0)) return int112(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int120. Reverts on overflow.\n    function toInt120(int256 x) internal pure returns (int120) {\n        unchecked {\n            if (((1 << 119) + uint256(x)) >> 120 == uint256(0)) return int120(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int128. Reverts on overflow.\n    function toInt128(int256 x) internal pure returns (int128) {\n        unchecked {\n            if (((1 << 127) + uint256(x)) >> 128 == uint256(0)) return int128(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int136. Reverts on overflow.\n    function toInt136(int256 x) internal pure returns (int136) {\n        unchecked {\n            if (((1 << 135) + uint256(x)) >> 136 == uint256(0)) return int136(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int144. Reverts on overflow.\n    function toInt144(int256 x) internal pure returns (int144) {\n        unchecked {\n            if (((1 << 143) + uint256(x)) >> 144 == uint256(0)) return int144(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int152. Reverts on overflow.\n    function toInt152(int256 x) internal pure returns (int152) {\n        unchecked {\n            if (((1 << 151) + uint256(x)) >> 152 == uint256(0)) return int152(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int160. Reverts on overflow.\n    function toInt160(int256 x) internal pure returns (int160) {\n        unchecked {\n            if (((1 << 159) + uint256(x)) >> 160 == uint256(0)) return int160(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int168. Reverts on overflow.\n    function toInt168(int256 x) internal pure returns (int168) {\n        unchecked {\n            if (((1 << 167) + uint256(x)) >> 168 == uint256(0)) return int168(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int176. Reverts on overflow.\n    function toInt176(int256 x) internal pure returns (int176) {\n        unchecked {\n            if (((1 << 175) + uint256(x)) >> 176 == uint256(0)) return int176(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int184. Reverts on overflow.\n    function toInt184(int256 x) internal pure returns (int184) {\n        unchecked {\n            if (((1 << 183) + uint256(x)) >> 184 == uint256(0)) return int184(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int192. Reverts on overflow.\n    function toInt192(int256 x) internal pure returns (int192) {\n        unchecked {\n            if (((1 << 191) + uint256(x)) >> 192 == uint256(0)) return int192(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int200. Reverts on overflow.\n    function toInt200(int256 x) internal pure returns (int200) {\n        unchecked {\n            if (((1 << 199) + uint256(x)) >> 200 == uint256(0)) return int200(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int208. Reverts on overflow.\n    function toInt208(int256 x) internal pure returns (int208) {\n        unchecked {\n            if (((1 << 207) + uint256(x)) >> 208 == uint256(0)) return int208(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int216. Reverts on overflow.\n    function toInt216(int256 x) internal pure returns (int216) {\n        unchecked {\n            if (((1 << 215) + uint256(x)) >> 216 == uint256(0)) return int216(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int224. Reverts on overflow.\n    function toInt224(int256 x) internal pure returns (int224) {\n        unchecked {\n            if (((1 << 223) + uint256(x)) >> 224 == uint256(0)) return int224(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int232. Reverts on overflow.\n    function toInt232(int256 x) internal pure returns (int232) {\n        unchecked {\n            if (((1 << 231) + uint256(x)) >> 232 == uint256(0)) return int232(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int240. Reverts on overflow.\n    function toInt240(int256 x) internal pure returns (int240) {\n        unchecked {\n            if (((1 << 239) + uint256(x)) >> 240 == uint256(0)) return int240(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int248. Reverts on overflow.\n    function toInt248(int256 x) internal pure returns (int248) {\n        unchecked {\n            if (((1 << 247) + uint256(x)) >> 248 == uint256(0)) return int248(x);\n            _revertOverflow();\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*               OTHER SAFE CASTING OPERATIONS                */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Casts `x` to a int8. Reverts on overflow.\n    function toInt8(uint256 x) internal pure returns (int8) {\n        if (x >= 1 << 7) _revertOverflow();\n        return int8(int256(x));\n    }\n\n    /// @dev Casts `x` to a int16. Reverts on overflow.\n    function toInt16(uint256 x) internal pure returns (int16) {\n        if (x >= 1 << 15) _revertOverflow();\n        return int16(int256(x));\n    }\n\n    /// @dev Casts `x` to a int24. Reverts on overflow.\n    function toInt24(uint256 x) internal pure returns (int24) {\n        if (x >= 1 << 23) _revertOverflow();\n        return int24(int256(x));\n    }\n\n    /// @dev Casts `x` to a int32. Reverts on overflow.\n    function toInt32(uint256 x) internal pure returns (int32) {\n        if (x >= 1 << 31) _revertOverflow();\n        return int32(int256(x));\n    }\n\n    /// @dev Casts `x` to a int40. Reverts on overflow.\n    function toInt40(uint256 x) internal pure returns (int40) {\n        if (x >= 1 << 39) _revertOverflow();\n        return int40(int256(x));\n    }\n\n    /// @dev Casts `x` to a int48. Reverts on overflow.\n    function toInt48(uint256 x) internal pure returns (int48) {\n        if (x >= 1 << 47) _revertOverflow();\n        return int48(int256(x));\n    }\n\n    /// @dev Casts `x` to a int56. Reverts on overflow.\n    function toInt56(uint256 x) internal pure returns (int56) {\n        if (x >= 1 << 55) _revertOverflow();\n        return int56(int256(x));\n    }\n\n    /// @dev Casts `x` to a int64. Reverts on overflow.\n    function toInt64(uint256 x) internal pure returns (int64) {\n        if (x >= 1 << 63) _revertOverflow();\n        return int64(int256(x));\n    }\n\n    /// @dev Casts `x` to a int72. Reverts on overflow.\n    function toInt72(uint256 x) internal pure returns (int72) {\n        if (x >= 1 << 71) _revertOverflow();\n        return int72(int256(x));\n    }\n\n    /// @dev Casts `x` to a int80. Reverts on overflow.\n    function toInt80(uint256 x) internal pure returns (int80) {\n        if (x >= 1 << 79) _revertOverflow();\n        return int80(int256(x));\n    }\n\n    /// @dev Casts `x` to a int88. Reverts on overflow.\n    function toInt88(uint256 x) internal pure returns (int88) {\n        if (x >= 1 << 87) _revertOverflow();\n        return int88(int256(x));\n    }\n\n    /// @dev Casts `x` to a int96. Reverts on overflow.\n    function toInt96(uint256 x) internal pure returns (int96) {\n        if (x >= 1 << 95) _revertOverflow();\n        return int96(int256(x));\n    }\n\n    /// @dev Casts `x` to a int104. Reverts on overflow.\n    function toInt104(uint256 x) internal pure returns (int104) {\n        if (x >= 1 << 103) _revertOverflow();\n        return int104(int256(x));\n    }\n\n    /// @dev Casts `x` to a int112. Reverts on overflow.\n    function toInt112(uint256 x) internal pure returns (int112) {\n        if (x >= 1 << 111) _revertOverflow();\n        return int112(int256(x));\n    }\n\n    /// @dev Casts `x` to a int120. Reverts on overflow.\n    function toInt120(uint256 x) internal pure returns (int120) {\n        if (x >= 1 << 119) _revertOverflow();\n        return int120(int256(x));\n    }\n\n    /// @dev Casts `x` to a int128. Reverts on overflow.\n    function toInt128(uint256 x) internal pure returns (int128) {\n        if (x >= 1 << 127) _revertOverflow();\n        return int128(int256(x));\n    }\n\n    /// @dev Casts `x` to a int136. Reverts on overflow.\n    function toInt136(uint256 x) internal pure returns (int136) {\n        if (x >= 1 << 135) _revertOverflow();\n        return int136(int256(x));\n    }\n\n    /// @dev Casts `x` to a int144. Reverts on overflow.\n    function toInt144(uint256 x) internal pure returns (int144) {\n        if (x >= 1 << 143) _revertOverflow();\n        return int144(int256(x));\n    }\n\n    /// @dev Casts `x` to a int152. Reverts on overflow.\n    function toInt152(uint256 x) internal pure returns (int152) {\n        if (x >= 1 << 151) _revertOverflow();\n        return int152(int256(x));\n    }\n\n    /// @dev Casts `x` to a int160. Reverts on overflow.\n    function toInt160(uint256 x) internal pure returns (int160) {\n        if (x >= 1 << 159) _revertOverflow();\n        return int160(int256(x));\n    }\n\n    /// @dev Casts `x` to a int168. Reverts on overflow.\n    function toInt168(uint256 x) internal pure returns (int168) {\n        if (x >= 1 << 167) _revertOverflow();\n        return int168(int256(x));\n    }\n\n    /// @dev Casts `x` to a int176. Reverts on overflow.\n    function toInt176(uint256 x) internal pure returns (int176) {\n        if (x >= 1 << 175) _revertOverflow();\n        return int176(int256(x));\n    }\n\n    /// @dev Casts `x` to a int184. Reverts on overflow.\n    function toInt184(uint256 x) internal pure returns (int184) {\n        if (x >= 1 << 183) _revertOverflow();\n        return int184(int256(x));\n    }\n\n    /// @dev Casts `x` to a int192. Reverts on overflow.\n    function toInt192(uint256 x) internal pure returns (int192) {\n        if (x >= 1 << 191) _revertOverflow();\n        return int192(int256(x));\n    }\n\n    /// @dev Casts `x` to a int200. Reverts on overflow.\n    function toInt200(uint256 x) internal pure returns (int200) {\n        if (x >= 1 << 199) _revertOverflow();\n        return int200(int256(x));\n    }\n\n    /// @dev Casts `x` to a int208. Reverts on overflow.\n    function toInt208(uint256 x) internal pure returns (int208) {\n        if (x >= 1 << 207) _revertOverflow();\n        return int208(int256(x));\n    }\n\n    /// @dev Casts `x` to a int216. Reverts on overflow.\n    function toInt216(uint256 x) internal pure returns (int216) {\n        if (x >= 1 << 215) _revertOverflow();\n        return int216(int256(x));\n    }\n\n    /// @dev Casts `x` to a int224. Reverts on overflow.\n    function toInt224(uint256 x) internal pure returns (int224) {\n        if (x >= 1 << 223) _revertOverflow();\n        return int224(int256(x));\n    }\n\n    /// @dev Casts `x` to a int232. Reverts on overflow.\n    function toInt232(uint256 x) internal pure returns (int232) {\n        if (x >= 1 << 231) _revertOverflow();\n        return int232(int256(x));\n    }\n\n    /// @dev Casts `x` to a int240. Reverts on overflow.\n    function toInt240(uint256 x) internal pure returns (int240) {\n        if (x >= 1 << 239) _revertOverflow();\n        return int240(int256(x));\n    }\n\n    /// @dev Casts `x` to a int248. Reverts on overflow.\n    function toInt248(uint256 x) internal pure returns (int248) {\n        if (x >= 1 << 247) _revertOverflow();\n        return int248(int256(x));\n    }\n\n    /// @dev Casts `x` to a int256. Reverts on overflow.\n    function toInt256(uint256 x) internal pure returns (int256) {\n        if (int256(x) >= 0) return int256(x);\n        _revertOverflow();\n    }\n\n    /// @dev Casts `x` to a uint256. Reverts on overflow.\n    function toUint256(int256 x) internal pure returns (uint256) {\n        if (x >= 0) return uint256(x);\n        _revertOverflow();\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    function _revertOverflow() private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Store the function selector of `Overflow()`.\n            mstore(0x00, 0x35278d12)\n            // Revert with (offset, size).\n            revert(0x1c, 0x04)\n        }\n    }\n}\n"}, "src/base/ExposedStorage.sol": {"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.30;\n\nimport {IExposedStorage} from \"../interfaces/IExposedStorage.sol\";\n\nabstract contract ExposedStorage is IExposedStorage {\n    function sload() external view {\n        assembly (\"memory-safe\") {\n            for { let i := 4 } lt(i, calldatasize()) { i := add(i, 32) } { mstore(sub(i, 4), sload(calldataload(i))) }\n            return(0, sub(calldatasize(), 4))\n        }\n    }\n\n    function tload() external view {\n        assembly (\"memory-safe\") {\n            for { let i := 4 } lt(i, calldatasize()) { i := add(i, 32) } { mstore(sub(i, 4), tload(calldataload(i))) }\n            return(0, sub(calldatasize(), 4))\n        }\n    }\n}\n"}, "src/math/liquidity.sol": {"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.30;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {amount0Delta, amount1Delta, sortAndConvertToFixedSqrtRatios} from \"./delta.sol\";\nimport {SqrtRatio} from \"../types/sqrtRatio.sol\";\n\n/**\n * @notice Returns the token0 and token1 delta owed for a given change in liquidity.\n * @param sqrtRatio        Current price (as a sqrt ratio).\n * @param liquidityDelta   Signed liquidity change; positive = added, negative = removed.\n * @param sqrtRatioLower   The lower bound of the price range (as a sqrt ratio).\n * @param sqrtRatioUpper   The upper bound of the price range (as a sqrt ratio).\n */\nfunction liquidityDeltaToAmountDelta(\n    SqrtRatio sqrtRatio,\n    int128 liquidityDelta,\n    SqrtRatio sqrtRatioLower,\n    SqrtRatio sqrtRatioUpper\n) pure returns (int128 delta0, int128 delta1) {\n    unchecked {\n        if (liquidityDelta == 0) {\n            return (0, 0);\n        }\n        bool isPositive = (liquidityDelta > 0);\n        // type(uint256).max cast to int256 is -1\n        int256 sign = int256(FixedPointMathLib.ternary(isPositive, 1, type(uint256).max));\n        // absolute value of a int128 always fits in a uint128\n        uint128 magnitude = uint128(FixedPointMathLib.abs(liquidityDelta));\n\n        if (sqrtRatio <= sqrtRatioLower) {\n            delta0 = SafeCastLib.toInt128(\n                sign * int256(uint256(amount0Delta(sqrtRatioLower, sqrtRatioUpper, magnitude, isPositive)))\n            );\n        } else if (sqrtRatio < sqrtRatioUpper) {\n            delta0 = SafeCastLib.toInt128(\n                sign * int256(uint256(amount0Delta(sqrtRatio, sqrtRatioUpper, magnitude, isPositive)))\n            );\n            delta1 = SafeCastLib.toInt128(\n                sign * int256(uint256(amount1Delta(sqrtRatioLower, sqrtRatio, magnitude, isPositive)))\n            );\n        } else {\n            delta1 = SafeCastLib.toInt128(\n                sign * int256(uint256(amount1Delta(sqrtRatioLower, sqrtRatioUpper, magnitude, isPositive)))\n            );\n        }\n    }\n}\n\nfunction maxLiquidityForToken0(uint256 sqrtRatioLower, uint256 sqrtRatioUpper, uint128 amount) pure returns (uint256) {\n    unchecked {\n        uint256 numerator_1 = FixedPointMathLib.fullMulDivN(sqrtRatioLower, sqrtRatioUpper, 128);\n\n        return FixedPointMathLib.fullMulDiv(amount, numerator_1, (sqrtRatioUpper - sqrtRatioLower));\n    }\n}\n\nfunction maxLiquidityForToken1(uint256 sqrtRatioLower, uint256 sqrtRatioUpper, uint128 amount) pure returns (uint256) {\n    unchecked {\n        return (uint256(amount) << 128) / (sqrtRatioUpper - sqrtRatioLower);\n    }\n}\n\nfunction maxLiquidity(\n    SqrtRatio _sqrtRatio,\n    SqrtRatio sqrtRatioA,\n    SqrtRatio sqrtRatioB,\n    uint128 amount0,\n    uint128 amount1\n) pure returns (uint128) {\n    uint256 sqrtRatio = _sqrtRatio.toFixed();\n    (uint256 sqrtRatioLower, uint256 sqrtRatioUpper) = sortAndConvertToFixedSqrtRatios(sqrtRatioA, sqrtRatioB);\n\n    if (sqrtRatio <= sqrtRatioLower) {\n        return uint128(\n            FixedPointMathLib.min(type(uint128).max, maxLiquidityForToken0(sqrtRatioLower, sqrtRatioUpper, amount0))\n        );\n    } else if (sqrtRatio < sqrtRatioUpper) {\n        return uint128(\n            FixedPointMathLib.min(\n                type(uint128).max,\n                FixedPointMathLib.min(\n                    maxLiquidityForToken0(sqrtRatio, sqrtRatioUpper, amount0),\n                    maxLiquidityForToken1(sqrtRatioLower, sqrtRatio, amount1)\n                )\n            )\n        );\n    } else {\n        return uint128(\n            FixedPointMathLib.min(type(uint128).max, maxLiquidityForToken1(sqrtRatioLower, sqrtRatioUpper, amount1))\n        );\n    }\n}\n\nerror LiquidityDeltaOverflow();\n\nfunction addLiquidityDelta(uint128 liquidity, int128 liquidityDelta) pure returns (uint128 result) {\n    assembly (\"memory-safe\") {\n        result := add(liquidity, liquidityDelta)\n        if and(result, shl(128, 0xffffffffffffffffffffffffffffffff)) {\n            mstore(0, shl(224, 0x6d862c50))\n            revert(0, 4)\n        }\n    }\n}\n\nfunction subLiquidityDelta(uint128 liquidity, int128 liquidityDelta) pure returns (uint128 result) {\n    assembly (\"memory-safe\") {\n        result := sub(liquidity, liquidityDelta)\n        if and(result, shl(128, 0xffffffffffffffffffffffffffffffff)) {\n            mstore(0, shl(224, 0x6d862c50))\n            revert(0, 4)\n        }\n    }\n}\n"}, "src/math/fee.sol": {"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.30;\n\n// Returns the fee to charge based on the amount, which is the fee (a 0.64 number) times the\n// amount, rounded up\nfunction computeFee(uint128 amount, uint64 fee) pure returns (uint128 result) {\n    assembly (\"memory-safe\") {\n        result := shr(64, add(mul(amount, fee), 0xffffffffffffffff))\n    }\n}\n\nerror AmountBeforeFeeOverflow();\n\n// Returns the amount before the fee is applied, which is the amount minus the fee, rounded up\nfunction amountBeforeFee(uint128 afterFee, uint64 fee) pure returns (uint128 result) {\n    uint256 r;\n    assembly (\"memory-safe\") {\n        let v := shl(64, afterFee)\n        let d := sub(0x10000000000000000, fee)\n        let q := div(v, d)\n        r := add(iszero(iszero(mod(v, d))), q)\n    }\n    if (r > type(uint128).max) {\n        revert AmountBeforeFeeOverflow();\n    }\n    result = uint128(r);\n}\n"}, "src/math/tickBitmap.sol": {"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.30;\n\nimport {Bitmap} from \"../math/bitmap.sol\";\nimport {MIN_TICK, MAX_TICK} from \"../math/constants.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\n// Returns the index of the word and the index _in_ that word which contains the bit representing whether the tick is initialized\n// Addition of the offset does two things--it centers the 0 tick within a single bitmap regardless of tick spacing,\n// and gives us a contiguous range of unsigned integers for all ticks\n// Always rounds the tick down to the nearest multiple of tickSpacing\nfunction tickToBitmapWordAndIndex(int32 tick, uint32 tickSpacing) pure returns (uint256 word, uint256 index) {\n    assembly (\"memory-safe\") {\n        let rawIndex := add(sub(sdiv(tick, tickSpacing), slt(smod(tick, tickSpacing), 0)), 89421695)\n        word := div(rawIndex, 256)\n        index := mod(rawIndex, 256)\n    }\n}\n\n// Returns the index of the word and the index _in_ that word which contains the bit representing whether the tick is initialized\n/// @dev This function is only safe if tickSpacing is between 1 and MAX_TICK_SPACING, and word/index correspond to the results of tickToBitmapWordAndIndex for a tick between MIN_TICK and MAX_TICK\nfunction bitmapWordAndIndexToTick(uint256 word, uint256 index, uint32 tickSpacing) pure returns (int32 tick) {\n    assembly (\"memory-safe\") {\n        let rawIndex := add(mul(word, 256), index)\n        tick := mul(sub(rawIndex, 89421695), tickSpacing)\n    }\n}\n\n// Flips the tick in the bitmap from true to false or vice versa\nfunction flipTick(mapping(uint256 word => Bitmap bitmap) storage map, int32 tick, uint32 tickSpacing) {\n    (uint256 word, uint256 index) = tickToBitmapWordAndIndex(tick, tickSpacing);\n    assembly (\"memory-safe\") {\n        mstore(0, word)\n        mstore(32, map.slot)\n        let k := keccak256(0, 64)\n        let v := sload(k)\n        sstore(k, xor(v, shl(index, 1)))\n    }\n}\n\nfunction findNextInitializedTick(\n    mapping(uint256 word => Bitmap bitmap) storage map,\n    int32 fromTick,\n    uint32 tickSpacing,\n    uint256 skipAhead\n) view returns (int32 nextTick, bool isInitialized) {\n    unchecked {\n        nextTick = fromTick;\n        while (true) {\n            // convert the given tick to the bitmap position of the next nearest potential initialized tick\n            (uint256 word, uint256 index) = tickToBitmapWordAndIndex(nextTick + int32(tickSpacing), tickSpacing);\n\n            // find the index of the previous tick in that word\n            uint256 nextIndex = map[word].geSetBit(uint8(index));\n\n            // if we found one, return it\n            if (nextIndex != 256) {\n                (nextTick, isInitialized) = (bitmapWordAndIndexToTick(word, nextIndex, tickSpacing), true);\n                break;\n            }\n\n            // otherwise, return the tick of the most significant bit in the word\n            nextTick = bitmapWordAndIndexToTick(word, 255, tickSpacing);\n\n            if (nextTick >= MAX_TICK) {\n                nextTick = MAX_TICK;\n                break;\n            }\n\n            // if we are done searching, stop here\n            if (skipAhead == 0) {\n                break;\n            }\n\n            skipAhead--;\n        }\n    }\n}\n\nfunction findPrevInitializedTick(\n    mapping(uint256 word => Bitmap bitmap) storage map,\n    int32 fromTick,\n    uint32 tickSpacing,\n    uint256 skipAhead\n) view returns (int32 prevTick, bool isInitialized) {\n    unchecked {\n        prevTick = fromTick;\n        while (true) {\n            // convert the given tick to its bitmap position\n            (uint256 word, uint256 index) = tickToBitmapWordAndIndex(prevTick, tickSpacing);\n\n            // find the index of the previous tick in that word\n            uint256 prevIndex = map[word].leSetBit(uint8(index));\n\n            if (prevIndex != 256) {\n                (prevTick, isInitialized) = (bitmapWordAndIndexToTick(word, prevIndex, tickSpacing), true);\n                break;\n            }\n\n            prevTick = bitmapWordAndIndexToTick(word, 0, tickSpacing);\n\n            if (prevTick <= MIN_TICK) {\n                prevTick = MIN_TICK;\n                break;\n            }\n\n            if (skipAhead == 0) {\n                break;\n            }\n\n            skipAhead--;\n            prevTick--;\n        }\n    }\n}\n"}, "src/interfaces/ICore.sol": {"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.30;\n\nimport {CallPoints} from \"../types/callPoints.sol\";\nimport {PoolKey} from \"../types/poolKey.sol\";\nimport {PositionKey, Bounds} from \"../types/positionKey.sol\";\nimport {FeesPerLiquidity} from \"../types/feesPerLiquidity.sol\";\nimport {IExposedStorage} from \"../interfaces/IExposedStorage.sol\";\nimport {IFlashAccountant} from \"../interfaces/IFlashAccountant.sol\";\nimport {SqrtRatio} from \"../types/sqrtRatio.sol\";\n\nstruct UpdatePositionParameters {\n    bytes32 salt;\n    Bounds bounds;\n    int128 liquidityDelta;\n}\n\ninterface IExtension {\n    function beforeInitializePool(address caller, PoolKey calldata key, int32 tick) external;\n    function afterInitializePool(address caller, PoolKey calldata key, int32 tick, SqrtRatio sqrtRatio) external;\n\n    function beforeUpdatePosition(address locker, PoolKey memory poolKey, UpdatePositionParameters memory params)\n        external;\n    function afterUpdatePosition(\n        address locker,\n        PoolKey memory poolKey,\n        UpdatePositionParameters memory params,\n        int128 delta0,\n        int128 delta1\n    ) external;\n\n    function beforeSwap(\n        address locker,\n        PoolKey memory poolKey,\n        int128 amount,\n        bool isToken1,\n        SqrtRatio sqrtRatioLimit,\n        uint256 skipAhead\n    ) external;\n    function afterSwap(\n        address locker,\n        PoolKey memory poolKey,\n        int128 amount,\n        bool isToken1,\n        SqrtRatio sqrtRatioLimit,\n        uint256 skipAhead,\n        int128 delta0,\n        int128 delta1\n    ) external;\n\n    function beforeCollectFees(address locker, PoolKey memory poolKey, bytes32 salt, Bounds memory bounds) external;\n    function afterCollectFees(\n        address locker,\n        PoolKey memory poolKey,\n        bytes32 salt,\n        Bounds memory bounds,\n        uint128 amount0,\n        uint128 amount1\n    ) external;\n}\n\ninterface ICore is IFlashAccountant, IExposedStorage {\n    event ProtocolFeesWithdrawn(address recipient, address token, uint256 amount);\n    event ExtensionRegistered(address extension);\n    event PoolInitialized(bytes32 poolId, PoolKey poolKey, int32 tick, SqrtRatio sqrtRatio);\n    event PositionFeesCollected(bytes32 poolId, PositionKey positionKey, uint128 amount0, uint128 amount1);\n    event FeesAccumulated(bytes32 poolId, uint128 amount0, uint128 amount1);\n    event PositionUpdated(\n        address locker, bytes32 poolId, UpdatePositionParameters params, int128 delta0, int128 delta1\n    );\n\n    // This error is thrown by swaps and deposits when this particular deployment of the contract is expired.\n    error FailedRegisterInvalidCallPoints();\n    error ExtensionAlreadyRegistered();\n    error InsufficientSavedBalance();\n    error PoolAlreadyInitialized();\n    error ExtensionNotRegistered();\n    error PoolNotInitialized();\n    error MustCollectFeesBeforeWithdrawingAllLiquidity();\n    error SqrtRatioLimitOutOfRange();\n    error InvalidSqrtRatioLimit();\n    error SavedBalanceTokensNotSorted();\n\n    // Allows the owner of the contract to withdraw the protocol withdrawal fees collected\n    // To withdraw the native token protocol fees, call with token = NATIVE_TOKEN_ADDRESS\n    function withdrawProtocolFees(address recipient, address token, uint256 amount) external;\n\n    // Extensions must call this function to become registered. The call points are validated against the caller address\n    function registerExtension(CallPoints memory expectedCallPoints) external;\n\n    // Sets the initial price for a new pool in terms of tick.\n    function initializePool(PoolKey memory poolKey, int32 tick) external returns (SqrtRatio sqrtRatio);\n\n    function prevInitializedTick(bytes32 poolId, int32 fromTick, uint32 tickSpacing, uint256 skipAhead)\n        external\n        view\n        returns (int32 tick, bool isInitialized);\n\n    function nextInitializedTick(bytes32 poolId, int32 fromTick, uint32 tickSpacing, uint256 skipAhead)\n        external\n        view\n        returns (int32 tick, bool isInitialized);\n\n    // Loads 2 tokens from the saved balances of the caller as payment in the current context.\n    function load(address token0, address token1, bytes32 salt, uint128 amount0, uint128 amount1) external;\n\n    // Saves an amount of 2 tokens to be used later, in a single slot.\n    function save(address owner, address token0, address token1, bytes32 salt, uint128 amount0, uint128 amount1)\n        external\n        payable;\n\n    // Returns the pool fees per liquidity inside the given bounds.\n    function getPoolFeesPerLiquidityInside(PoolKey memory poolKey, Bounds memory bounds)\n        external\n        view\n        returns (FeesPerLiquidity memory);\n\n    // Accumulates tokens to fees of a pool. Only callable by the extension of the specified pool\n    // key, i.e. the current locker _must_ be the extension.\n    // The extension must call this function within a lock callback.\n    function accumulateAsFees(PoolKey memory poolKey, uint128 amount0, uint128 amount1) external payable;\n\n    function updatePosition(PoolKey memory poolKey, UpdatePositionParameters memory params)\n        external\n        payable\n        returns (int128 delta0, int128 delta1);\n\n    function collectFees(PoolKey memory poolKey, bytes32 salt, Bounds memory bounds)\n        external\n        returns (uint128 amount0, uint128 amount1);\n\n    function swap_611415377(\n        PoolKey memory poolKey,\n        int128 amount,\n        bool isToken1,\n        SqrtRatio sqrtRatioLimit,\n        uint256 skipAhead\n    ) external payable returns (int128 delta0, int128 delta1);\n}\n"}, "src/base/FlashAccountant.sol": {"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.30;\n\nimport {NATIVE_TOKEN_ADDRESS} from \"../math/constants.sol\";\nimport {IPayer, IFlashAccountant} from \"../interfaces/IFlashAccountant.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nabstract contract FlashAccountant is IFlashAccountant {\n    // These offsets are selected so that they do not accidentally overlap with any other base contract's use of transient storage\n\n    // cast keccak \"FlashAccountant#CURRENT_LOCKER_SLOT\"\n    uint256 private constant _CURRENT_LOCKER_SLOT = 0x07cc7f5195d862f505d6b095c82f92e00cfc1766f5bca4383c28dc5fca1555fd;\n    // cast keccak \"FlashAccountant#NONZERO_DEBT_COUNT_OFFSET\"\n    uint256 private constant _NONZERO_DEBT_COUNT_OFFSET =\n        0x7772acfd7e0f66ebb20a058830296c3dc1301b111d23348e1c961d324223190d;\n    // cast keccak \"FlashAccountant#DEBT_HASH_OFFSET\"\n    uint256 private constant _DEBT_HASH_OFFSET = 0x3fee1dc3ade45aa30d633b5b8645760533723e46597841ef1126c6577a091742;\n    // cast keccak \"FlashAccountant#PAY_REENTRANCY_LOCK\"\n    uint256 private constant _PAY_REENTRANCY_LOCK = 0xe1be600102d456bf2d4dee36e1641404df82292916888bf32557e00dfe166412;\n\n    function _getLocker() internal view returns (uint256 id, address locker) {\n        assembly (\"memory-safe\") {\n            let current := tload(_CURRENT_LOCKER_SLOT)\n\n            if iszero(current) {\n                // cast sig \"NotLocked()\"\n                mstore(0, shl(224, 0x1834e265))\n                revert(0, 4)\n            }\n\n            id := sub(shr(160, current), 1)\n            locker := shr(96, shl(96, current))\n        }\n    }\n\n    function _requireLocker() internal view returns (uint256 id, address locker) {\n        (id, locker) = _getLocker();\n        if (locker != msg.sender) revert LockerOnly();\n    }\n\n    // We assume debtChange cannot exceed a 128 bits value, even though it uses a int256 container\n    // This must be enforced at the places it is called for this contract's safety\n    // Negative means erasing debt, positive means adding debt\n    function _accountDebt(uint256 id, address token, int256 debtChange) internal {\n        assembly (\"memory-safe\") {\n            if iszero(iszero(debtChange)) {\n                mstore(0, add(add(shl(160, id), token), _DEBT_HASH_OFFSET))\n                let deltaSlot := keccak256(0, 32)\n                let current := tload(deltaSlot)\n\n                // we know this never overflows because debtChange is only ever derived from 128 bit values in inheriting contracts\n                let next := add(current, debtChange)\n\n                let nextZero := iszero(next)\n                if xor(iszero(current), nextZero) {\n                    let nzdCountSlot := add(id, _NONZERO_DEBT_COUNT_OFFSET)\n\n                    tstore(nzdCountSlot, add(sub(tload(nzdCountSlot), nextZero), iszero(nextZero)))\n                }\n\n                tstore(deltaSlot, next)\n            }\n        }\n    }\n\n    // The entrypoint for all operations on the core contract\n    function lock() external {\n        assembly (\"memory-safe\") {\n            let current := tload(_CURRENT_LOCKER_SLOT)\n\n            let id := shr(160, current)\n\n            // store the count\n            tstore(_CURRENT_LOCKER_SLOT, or(shl(160, add(id, 1)), caller()))\n\n            let free := mload(0x40)\n            // Prepare call to locked(uint256) -> selector 0xb45a3c0e\n            mstore(free, shl(224, 0xb45a3c0e))\n            mstore(add(free, 4), id) // ID argument\n\n            calldatacopy(add(free, 36), 4, sub(calldatasize(), 4))\n\n            // Call the original caller with the packed data\n            let success := call(gas(), caller(), 0, free, add(calldatasize(), 32), 0, 0)\n\n            // Pass through the error on failure\n            if iszero(success) {\n                returndatacopy(free, 0, returndatasize())\n                revert(free, returndatasize())\n            }\n\n            // Undo the \"locker\" state changes\n            tstore(_CURRENT_LOCKER_SLOT, current)\n\n            // Check if something is nonzero\n            let nonzeroDebtCount := tload(add(_NONZERO_DEBT_COUNT_OFFSET, id))\n            if nonzeroDebtCount {\n                // cast sig \"DebtsNotZeroed(uint256)\"\n                mstore(0x00, 0x9731ba37)\n                mstore(0x20, id)\n                revert(0x1c, 0x24)\n            }\n\n            // Directly return whatever the subcall returned\n            returndatacopy(free, 0, returndatasize())\n            return(free, returndatasize())\n        }\n    }\n\n    // Allows forwarding the lock context to another actor, allowing them to act on the original locker's debt\n    function forward(address to) external {\n        (uint256 id, address locker) = _requireLocker();\n\n        // update this lock's locker to the forwarded address for the duration of the forwarded\n        // call, meaning only the forwarded address can update state\n        assembly (\"memory-safe\") {\n            tstore(_CURRENT_LOCKER_SLOT, or(shl(160, add(id, 1)), to))\n\n            let free := mload(0x40)\n\n            // Prepare call to forwarded(uint256,address) -> selector 0x64919dea\n            mstore(free, shl(224, 0x64919dea))\n            mstore(add(free, 4), id)\n            mstore(add(free, 36), locker)\n\n            calldatacopy(add(free, 68), 36, sub(calldatasize(), 36))\n\n            // Call the forwardee with the packed data\n            let success := call(gas(), to, 0, free, add(32, calldatasize()), 0, 0)\n\n            // Pass through the error on failure\n            if iszero(success) {\n                returndatacopy(free, 0, returndatasize())\n                revert(free, returndatasize())\n            }\n\n            tstore(_CURRENT_LOCKER_SLOT, or(shl(160, add(id, 1)), locker))\n\n            // Directly return whatever the subcall returned\n            returndatacopy(free, 0, returndatasize())\n            return(free, returndatasize())\n        }\n    }\n\n    function pay(address token) external returns (uint128 payment) {\n        assembly (\"memory-safe\") {\n            if tload(_PAY_REENTRANCY_LOCK) {\n                // cast sig \"PayReentrance()\"\n                mstore(0, 0xced108be)\n                revert(0x1c, 0x04)\n            }\n            tstore(_PAY_REENTRANCY_LOCK, 1)\n        }\n\n        (uint256 id,) = _getLocker();\n\n        assembly (\"memory-safe\") {\n            let free := mload(0x40)\n\n            mstore(20, address()) // Store the `account` argument.\n            mstore(0, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            let tokenBalanceBefore :=\n                mul( // The arguments of `mul` are evaluated from right to left.\n                    mload(free),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gas(), token, 0x10, 0x24, free, 0x20)\n                    )\n                )\n\n            // Prepare call to \"payCallback(uint256,address)\"\n            mstore(free, shl(224, 0x599d0714))\n            mstore(add(free, 4), id)\n            mstore(add(free, 36), token)\n\n            // copy the token, plus anything else that they wanted to forward\n            calldatacopy(add(free, 68), 36, sub(calldatasize(), 36))\n\n            // Call the forwardee with the packed data\n            // Pass through the error on failure\n            if iszero(call(gas(), caller(), 0, free, add(32, calldatasize()), 0, 0)) {\n                returndatacopy(free, 0, returndatasize())\n                revert(free, returndatasize())\n            }\n\n            // Arguments are still in scratch, we don't need to rewrite them\n            let tokenBalanceAfter :=\n                mul( // The arguments of `mul` are evaluated from right to left.\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\n                    )\n                )\n\n            if lt(tokenBalanceAfter, tokenBalanceBefore) {\n                // cast sig \"NoPaymentMade()\"\n                mstore(0x00, 0x01b243b9)\n                revert(0x1c, 4)\n            }\n\n            payment := sub(tokenBalanceAfter, tokenBalanceBefore)\n\n            // We never expect tokens to have this much total supply\n            if gt(payment, 0xffffffffffffffffffffffffffffffff) {\n                // cast sig \"PaymentOverflow()\"\n                mstore(0x00, 0x9cac58ca)\n                revert(0x1c, 4)\n            }\n        }\n\n        // The unary negative operator never fails because payment is less than max uint128\n        unchecked {\n            _accountDebt(id, token, -int256(uint256(payment)));\n        }\n\n        assembly (\"memory-safe\") {\n            tstore(_PAY_REENTRANCY_LOCK, 0)\n        }\n    }\n\n    function withdraw(address token, address recipient, uint128 amount) external {\n        (uint256 id,) = _requireLocker();\n\n        _accountDebt(id, token, int256(uint256(amount)));\n\n        if (token == NATIVE_TOKEN_ADDRESS) {\n            SafeTransferLib.safeTransferETH(recipient, amount);\n        } else {\n            SafeTransferLib.safeTransfer(token, recipient, amount);\n        }\n    }\n\n    receive() external payable {\n        (uint256 id,) = _getLocker();\n\n        // Note because we use msg.value here, this contract can never be multicallable, i.e. it should never expose the ability\n        //      to delegatecall itself more than once in a single call\n        unchecked {\n            // We never expect the native token to exceed this supply\n            if (msg.value > type(uint128).max) revert PaymentOverflow();\n\n            _accountDebt(id, NATIVE_TOKEN_ADDRESS, -int256(msg.value));\n        }\n    }\n}\n"}, "lib/solady/src/utils/EfficientHashLib.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Library for efficiently performing keccak256 hashes.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EfficientHashLib.sol)\n/// @dev To avoid stack-too-deep, you can use:\n/// ```\n/// bytes32[] memory buffer = EfficientHashLib.malloc(10);\n/// EfficientHashLib.set(buffer, 0, value0);\n/// ..\n/// EfficientHashLib.set(buffer, 9, value9);\n/// bytes32 finalHash = EfficientHashLib.hash(buffer);\n/// ```\nlibrary EfficientHashLib {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*               MALLOC-LESS HASHING OPERATIONS               */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns `keccak256(abi.encode(v0))`.\n    function hash(bytes32 v0) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            result := keccak256(0x00, 0x20)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0))`.\n    function hash(uint256 v0) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            result := keccak256(0x00, 0x20)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1))`.\n    function hash(bytes32 v0, bytes32 v1) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            mstore(0x20, v1)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1))`.\n    function hash(uint256 v0, uint256 v1) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            mstore(0x20, v1)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1, v2))`.\n    function hash(bytes32 v0, bytes32 v1, bytes32 v2) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            result := keccak256(m, 0x60)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1, v2))`.\n    function hash(uint256 v0, uint256 v1, uint256 v2) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            result := keccak256(m, 0x60)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1, v2, v3))`.\n    function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            result := keccak256(m, 0x80)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1, v2, v3))`.\n    function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            result := keccak256(m, 0x80)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v4))`.\n    function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            result := keccak256(m, 0xa0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v4))`.\n    function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            result := keccak256(m, 0xa0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v5))`.\n    function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            result := keccak256(m, 0xc0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v5))`.\n    function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            result := keccak256(m, 0xc0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v6))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            result := keccak256(m, 0xe0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v6))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            result := keccak256(m, 0xe0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v7))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            result := keccak256(m, 0x100)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v7))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            result := keccak256(m, 0x100)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v8))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            result := keccak256(m, 0x120)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v8))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            result := keccak256(m, 0x120)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v9))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            result := keccak256(m, 0x140)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v9))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            result := keccak256(m, 0x140)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v10))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            result := keccak256(m, 0x160)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v10))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            result := keccak256(m, 0x160)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v11))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10,\n        bytes32 v11\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            result := keccak256(m, 0x180)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v11))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10,\n        uint256 v11\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            result := keccak256(m, 0x180)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v12))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10,\n        bytes32 v11,\n        bytes32 v12\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            result := keccak256(m, 0x1a0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v12))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10,\n        uint256 v11,\n        uint256 v12\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            result := keccak256(m, 0x1a0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v13))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10,\n        bytes32 v11,\n        bytes32 v12,\n        bytes32 v13\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            mstore(add(m, 0x1a0), v13)\n            result := keccak256(m, 0x1c0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v13))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10,\n        uint256 v11,\n        uint256 v12,\n        uint256 v13\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            mstore(add(m, 0x1a0), v13)\n            result := keccak256(m, 0x1c0)\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*             BYTES32 BUFFER HASHING OPERATIONS              */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns `keccak256(abi.encode(buffer[0], .., buffer[buffer.length - 1]))`.\n    function hash(bytes32[] memory buffer) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(add(buffer, 0x20), shl(5, mload(buffer)))\n        }\n    }\n\n    /// @dev Sets `buffer[i]` to `value`, without a bounds check.\n    /// Returns the `buffer` for function chaining.\n    function set(bytes32[] memory buffer, uint256 i, bytes32 value)\n        internal\n        pure\n        returns (bytes32[] memory)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(buffer, shl(5, add(1, i))), value)\n        }\n        return buffer;\n    }\n\n    /// @dev Sets `buffer[i]` to `value`, without a bounds check.\n    /// Returns the `buffer` for function chaining.\n    function set(bytes32[] memory buffer, uint256 i, uint256 value)\n        internal\n        pure\n        returns (bytes32[] memory)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(buffer, shl(5, add(1, i))), value)\n        }\n        return buffer;\n    }\n\n    /// @dev Returns `new bytes32[](n)`, without zeroing out the memory.\n    function malloc(uint256 n) internal pure returns (bytes32[] memory buffer) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            buffer := mload(0x40)\n            mstore(buffer, n)\n            mstore(0x40, add(shl(5, add(1, n)), buffer))\n        }\n    }\n\n    /// @dev Frees memory that has been allocated for `buffer`.\n    /// No-op if `buffer.length` is zero, or if new memory has been allocated after `buffer`.\n    function free(bytes32[] memory buffer) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(buffer)\n            mstore(shl(6, lt(iszero(n), eq(add(shl(5, add(1, n)), buffer), mload(0x40)))), buffer)\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      EQUALITY CHECKS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns `a == abi.decode(b, (bytes32))`.\n    function eq(bytes32 a, bytes memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(0x20, mload(b)), eq(a, mload(add(b, 0x20))))\n        }\n    }\n\n    /// @dev Returns `abi.decode(a, (bytes32)) == a`.\n    function eq(bytes memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(0x20, mload(a)), eq(b, mload(add(a, 0x20))))\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*               BYTE SLICE HASHING OPERATIONS                */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the keccak256 of the slice from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function hash(bytes memory b, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            end := xor(end, mul(xor(end, n), lt(n, end)))\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            result := keccak256(add(add(b, 0x20), start), mul(gt(end, start), sub(end, start)))\n        }\n    }\n\n    /// @dev Returns the keccak256 of the slice from `start` to the end of the bytes.\n    function hash(bytes memory b, uint256 start) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            result := keccak256(add(add(b, 0x20), start), mul(gt(n, start), sub(n, start)))\n        }\n    }\n\n    /// @dev Returns the keccak256 of the bytes.\n    function hash(bytes memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(add(b, 0x20), mload(b))\n        }\n    }\n\n    /// @dev Returns the keccak256 of the slice from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function hashCalldata(bytes calldata b, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            end := xor(end, mul(xor(end, b.length), lt(b.length, end)))\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(end, start), sub(end, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := keccak256(mload(0x40), n)\n        }\n    }\n\n    /// @dev Returns the keccak256 of the slice from `start` to the end of the bytes.\n    function hashCalldata(bytes calldata b, uint256 start) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(b.length, start), sub(b.length, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := keccak256(mload(0x40), n)\n        }\n    }\n\n    /// @dev Returns the keccak256 of the bytes.\n    function hashCalldata(bytes calldata b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            calldatacopy(mload(0x40), b.offset, b.length)\n            result := keccak256(mload(0x40), b.length)\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      SHA2-256 HELPERS                      */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns `sha256(abi.encode(b))`. Yes, it's more efficient.\n    function sha2(bytes32 b) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, b)\n            result := mload(staticcall(gas(), 2, 0x00, 0x20, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the slice from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function sha2(bytes memory b, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            end := xor(end, mul(xor(end, n), lt(n, end)))\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            // forgefmt: disable-next-item\n            result := mload(staticcall(gas(), 2, add(add(b, 0x20), start),\n                mul(gt(end, start), sub(end, start)), 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the slice from `start` to the end of the bytes.\n    function sha2(bytes memory b, uint256 start) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            // forgefmt: disable-next-item\n            result := mload(staticcall(gas(), 2, add(add(b, 0x20), start),\n                mul(gt(n, start), sub(n, start)), 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the bytes.\n    function sha2(bytes memory b) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(staticcall(gas(), 2, add(b, 0x20), mload(b), 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the slice from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function sha2Calldata(bytes calldata b, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            end := xor(end, mul(xor(end, b.length), lt(b.length, end)))\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(end, start), sub(end, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := mload(staticcall(gas(), 2, mload(0x40), n, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the slice from `start` to the end of the bytes.\n    function sha2Calldata(bytes calldata b, uint256 start) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(b.length, start), sub(b.length, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := mload(staticcall(gas(), 2, mload(0x40), n, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the bytes.\n    function sha2Calldata(bytes calldata b) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            calldatacopy(mload(0x40), b.offset, b.length)\n            result := mload(staticcall(gas(), 2, mload(0x40), b.length, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n}\n"}, "src/math/constants.sol": {"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.30;\n\nint32 constant MIN_TICK = -88722835;\nint32 constant MAX_TICK = 88722835;\nuint32 constant MAX_TICK_MAGNITUDE = uint32(MAX_TICK);\nuint32 constant MAX_TICK_SPACING = 698605;\n\nuint32 constant FULL_RANGE_ONLY_TICK_SPACING = 0;\n\n// We use this address to represent the native token within the protocol\naddress constant NATIVE_TOKEN_ADDRESS = address(0);\n"}, "src/types/sqrtRatio.sol": {"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.30;\n\n// A dynamic fixed point number (a la floating point) that stores a shifting 94 bit view of the underlying fixed point value,\n//  based on the most significant bits (mantissa)\n// If the most significant 2 bits are 11, it represents a 64.30\n// If the most significant 2 bits are 10, it represents a 32.62 number\n// If the most significant 2 bits are 01, it represents a 0.94 number\n// If the most significant 2 bits are 00, it represents a 0.126 number that is always less than 2**-32\n\ntype SqrtRatio is uint96;\n\nuint96 constant MIN_SQRT_RATIO_RAW = 4611797791050542631;\nSqrtRatio constant MIN_SQRT_RATIO = SqrtRatio.wrap(MIN_SQRT_RATIO_RAW);\nuint96 constant MAX_SQRT_RATIO_RAW = 79227682466138141934206691491;\nSqrtRatio constant MAX_SQRT_RATIO = SqrtRatio.wrap(MAX_SQRT_RATIO_RAW);\n\nuint96 constant TWO_POW_95 = 0x800000000000000000000000;\nuint96 constant TWO_POW_94 = 0x400000000000000000000000;\nuint96 constant TWO_POW_62 = 0x4000000000000000;\nuint96 constant TWO_POW_62_MINUS_ONE = 0x3fffffffffffffff;\nuint96 constant BIT_MASK = 0xc00000000000000000000000; // TWO_POW_95 | TWO_POW_94\n\nSqrtRatio constant ONE = SqrtRatio.wrap((TWO_POW_95) + (1 << 62));\n\nusing {\n    toFixed,\n    isValid,\n    ge as >=,\n    le as <=,\n    lt as <,\n    gt as >,\n    eq as ==,\n    neq as !=,\n    isZero,\n    min,\n    max\n} for SqrtRatio global;\n\nfunction isValid(SqrtRatio sqrtRatio) pure returns (bool r) {\n    assembly (\"memory-safe\") {\n        r :=\n            and(\n                // greater than or equal to TWO_POW_62, i.e. the whole number portion is nonzero\n                gt(and(sqrtRatio, not(BIT_MASK)), TWO_POW_62_MINUS_ONE),\n                // and between min/max sqrt ratio\n                and(iszero(lt(sqrtRatio, MIN_SQRT_RATIO_RAW)), iszero(gt(sqrtRatio, MAX_SQRT_RATIO_RAW)))\n            )\n    }\n}\n\nerror ValueOverflowsSqrtRatioContainer();\n\n// If passing a value greater than this constant with roundUp = true, toSqrtRatio will overflow\n// For roundUp = false, the constant is type(uint192).max\nuint256 constant MAX_FIXED_VALUE_ROUND_UP =\n    0x1000000000000000000000000000000000000000000000000 - 0x4000000000000000000000000;\n\n// Converts a 64.128 value into the compact SqrtRatio representation\nfunction toSqrtRatio(uint256 sqrtRatio, bool roundUp) pure returns (SqrtRatio r) {\n    assembly (\"memory-safe\") {\n        let addend := mul(roundUp, 0x3)\n\n        // lt 2**96 after rounding up\n        switch lt(sqrtRatio, sub(0x1000000000000000000000000, addend))\n        case 1 { r := shr(2, add(sqrtRatio, addend)) }\n        default {\n            // 2**34 - 1\n            addend := mul(roundUp, 0x3ffffffff)\n            // lt 2**128 after rounding up\n            switch lt(sqrtRatio, sub(0x100000000000000000000000000000000, addend))\n            case 1 { r := or(TWO_POW_94, shr(34, add(sqrtRatio, addend))) }\n            default {\n                addend := mul(roundUp, 0x3ffffffffffffffff)\n                // lt 2**160 after rounding up\n                switch lt(sqrtRatio, sub(0x10000000000000000000000000000000000000000, addend))\n                case 1 { r := or(TWO_POW_95, shr(66, add(sqrtRatio, addend))) }\n                default {\n                    // 2**98 - 1\n                    addend := mul(roundUp, 0x3ffffffffffffffffffffffff)\n                    switch lt(sqrtRatio, sub(0x1000000000000000000000000000000000000000000000000, addend))\n                    case 1 { r := or(BIT_MASK, shr(98, add(sqrtRatio, addend))) }\n                    default {\n                        // cast sig \"ValueOverflowsSqrtRatioContainer()\"\n                        mstore(0, shl(224, 0xa10459f4))\n                        revert(0, 4)\n                    }\n                }\n            }\n        }\n    }\n}\n\n// Returns the 64.128 representation of the given sqrt ratio\nfunction toFixed(SqrtRatio sqrtRatio) pure returns (uint256 r) {\n    assembly (\"memory-safe\") {\n        r := shl(add(2, shr(89, and(sqrtRatio, BIT_MASK))), and(sqrtRatio, not(BIT_MASK)))\n    }\n}\n\n// The below operators assume that the SqrtRatio is valid, i.e. SqrtRatio#isValid returns true\n\nfunction lt(SqrtRatio a, SqrtRatio b) pure returns (bool r) {\n    r = SqrtRatio.unwrap(a) < SqrtRatio.unwrap(b);\n}\n\nfunction gt(SqrtRatio a, SqrtRatio b) pure returns (bool r) {\n    r = SqrtRatio.unwrap(a) > SqrtRatio.unwrap(b);\n}\n\nfunction le(SqrtRatio a, SqrtRatio b) pure returns (bool r) {\n    r = SqrtRatio.unwrap(a) <= SqrtRatio.unwrap(b);\n}\n\nfunction ge(SqrtRatio a, SqrtRatio b) pure returns (bool r) {\n    r = SqrtRatio.unwrap(a) >= SqrtRatio.unwrap(b);\n}\n\nfunction eq(SqrtRatio a, SqrtRatio b) pure returns (bool r) {\n    r = SqrtRatio.unwrap(a) == SqrtRatio.unwrap(b);\n}\n\nfunction neq(SqrtRatio a, SqrtRatio b) pure returns (bool r) {\n    r = SqrtRatio.unwrap(a) != SqrtRatio.unwrap(b);\n}\n\nfunction isZero(SqrtRatio a) pure returns (bool r) {\n    assembly (\"memory-safe\") {\n        r := iszero(a)\n    }\n}\n\nfunction max(SqrtRatio a, SqrtRatio b) pure returns (SqrtRatio r) {\n    assembly (\"memory-safe\") {\n        r := xor(a, mul(xor(a, b), gt(b, a)))\n    }\n}\n\nfunction min(SqrtRatio a, SqrtRatio b) pure returns (SqrtRatio r) {\n    assembly (\"memory-safe\") {\n        r := xor(a, mul(xor(a, b), lt(b, a)))\n    }\n}\n"}, "src/math/sqrtRatio.sol": {"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.30;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SqrtRatio, toSqrtRatio, MAX_FIXED_VALUE_ROUND_UP} from \"../types/sqrtRatio.sol\";\n\nerror ZeroLiquidityNextSqrtRatioFromAmount0();\n\n// Compute the next ratio from a delta amount0, always rounded towards starting price for input, and\n// away from starting price for output\nfunction nextSqrtRatioFromAmount0(SqrtRatio _sqrtRatio, uint128 liquidity, int128 amount)\n    pure\n    returns (SqrtRatio sqrtRatioNext)\n{\n    if (amount == 0) {\n        return _sqrtRatio;\n    }\n\n    if (liquidity == 0) {\n        revert ZeroLiquidityNextSqrtRatioFromAmount0();\n    }\n\n    uint256 sqrtRatio = _sqrtRatio.toFixed();\n\n    uint256 liquidityX128 = uint256(liquidity) << 128;\n    uint256 amountAbs = FixedPointMathLib.abs(int256(amount));\n\n    if (amount < 0) {\n        unchecked {\n            // multiplication will revert on overflow, so we return the maximum value for the type\n            if (amountAbs > type(uint256).max / sqrtRatio) {\n                return SqrtRatio.wrap(type(uint96).max);\n            }\n\n            uint256 product = sqrtRatio * amountAbs;\n\n            // again it will overflow if this is the case, so return the max value\n            if (product >= liquidityX128) {\n                return SqrtRatio.wrap(type(uint96).max);\n            }\n\n            uint256 denominator = liquidityX128 - product;\n\n            uint256 resultFixed = FixedPointMathLib.fullMulDivUp(liquidityX128, sqrtRatio, denominator);\n\n            if (resultFixed > MAX_FIXED_VALUE_ROUND_UP) {\n                return SqrtRatio.wrap(type(uint96).max);\n            }\n\n            sqrtRatioNext = toSqrtRatio(resultFixed, true);\n        }\n    } else {\n        uint256 denominator;\n        unchecked {\n            uint256 denominatorP1 = liquidityX128 / sqrtRatio;\n\n            // this can never overflow, amountAbs is limited to 2**128-1 and liquidityX128 / sqrtRatio is limited to (2**128-1 << 128)\n            // adding the 2 values can at most equal type(uint256).max\n            denominator = denominatorP1 + amountAbs;\n        }\n\n        sqrtRatioNext = toSqrtRatio(FixedPointMathLib.divUp(liquidityX128, denominator), true);\n    }\n}\n\nerror ZeroLiquidityNextSqrtRatioFromAmount1();\n\nfunction nextSqrtRatioFromAmount1(SqrtRatio _sqrtRatio, uint128 liquidity, int128 amount)\n    pure\n    returns (SqrtRatio sqrtRatioNext)\n{\n    if (amount == 0) {\n        return _sqrtRatio;\n    }\n\n    if (liquidity == 0) {\n        revert ZeroLiquidityNextSqrtRatioFromAmount1();\n    }\n\n    uint256 sqrtRatio = _sqrtRatio.toFixed();\n\n    unchecked {\n        uint256 shiftedAmountAbs = FixedPointMathLib.abs(int256(amount)) << 128;\n\n        uint256 quotient = shiftedAmountAbs / liquidity;\n\n        if (amount < 0) {\n            if (quotient >= sqrtRatio) {\n                // Underflow => return 0\n                return SqrtRatio.wrap(0);\n            }\n\n            uint256 sqrtRatioNextFixed = sqrtRatio - quotient;\n\n            assembly (\"memory-safe\") {\n                // subtraction of 1 is safe because sqrtRatio > quotient => sqrtRatio - quotient >= 1\n                sqrtRatioNextFixed := sub(sqrtRatioNextFixed, iszero(iszero(mod(shiftedAmountAbs, liquidity))))\n            }\n\n            sqrtRatioNext = toSqrtRatio(sqrtRatioNextFixed, false);\n        } else {\n            uint256 sum = sqrtRatio + quotient;\n            if (sum < sqrtRatio || sum > type(uint192).max) {\n                return SqrtRatio.wrap(type(uint96).max);\n            }\n            sqrtRatioNext = toSqrtRatio(sum, false);\n        }\n    }\n}\n"}, "src/math/delta.sol": {"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.30;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SqrtRatio} from \"../types/sqrtRatio.sol\";\n\nerror Amount0DeltaOverflow();\nerror Amount1DeltaOverflow();\n\nfunction sortAndConvertToFixedSqrtRatios(SqrtRatio sqrtRatioA, SqrtRatio sqrtRatioB)\n    pure\n    returns (uint256 sqrtRatioLower, uint256 sqrtRatioUpper)\n{\n    uint256 aFixed = sqrtRatioA.toFixed();\n    uint256 bFixed = sqrtRatioB.toFixed();\n    (sqrtRatioLower, sqrtRatioUpper) = (FixedPointMathLib.min(aFixed, bFixed), FixedPointMathLib.max(aFixed, bFixed));\n}\n\nfunction amount0Delta(SqrtRatio sqrtRatioA, SqrtRatio sqrtRatioB, uint128 liquidity, bool roundUp)\n    pure\n    returns (uint128 amount0)\n{\n    unchecked {\n        (uint256 sqrtRatioLower, uint256 sqrtRatioUpper) = sortAndConvertToFixedSqrtRatios(sqrtRatioA, sqrtRatioB);\n\n        if (roundUp) {\n            uint256 result0 = FixedPointMathLib.fullMulDivUp(\n                (uint256(liquidity) << 128), (sqrtRatioUpper - sqrtRatioLower), sqrtRatioUpper\n            );\n            uint256 result = FixedPointMathLib.divUp(result0, sqrtRatioLower);\n            if (result > type(uint128).max) revert Amount0DeltaOverflow();\n            amount0 = uint128(result);\n        } else {\n            uint256 result0 = FixedPointMathLib.fullMulDiv(\n                (uint256(liquidity) << 128), (sqrtRatioUpper - sqrtRatioLower), sqrtRatioUpper\n            );\n            uint256 result = result0 / sqrtRatioLower;\n            if (result > type(uint128).max) revert Amount0DeltaOverflow();\n            amount0 = uint128(result);\n        }\n    }\n}\n\nfunction amount1Delta(SqrtRatio sqrtRatioA, SqrtRatio sqrtRatioB, uint128 liquidity, bool roundUp)\n    pure\n    returns (uint128 amount1)\n{\n    unchecked {\n        (uint256 sqrtRatioLower, uint256 sqrtRatioUpper) = sortAndConvertToFixedSqrtRatios(sqrtRatioA, sqrtRatioB);\n\n        uint256 difference = sqrtRatioUpper - sqrtRatioLower;\n\n        if (roundUp) {\n            uint256 result = FixedPointMathLib.fullMulDivN(difference, liquidity, 128);\n            assembly {\n                // addition is safe from overflow because the result of fullMulDivN will never equal type(uint256).max\n                result :=\n                    add(result, iszero(iszero(mulmod(difference, liquidity, 0x100000000000000000000000000000000))))\n            }\n            if (result > type(uint128).max) revert Amount1DeltaOverflow();\n            amount1 = uint128(result);\n        } else {\n            uint256 result = FixedPointMathLib.fullMulDivN(difference, liquidity, 128);\n            if (result > type(uint128).max) revert Amount1DeltaOverflow();\n            amount1 = uint128(result);\n        }\n    }\n}\n"}, "src/math/isPriceIncreasing.sol": {"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.30;\n\nfunction isPriceIncreasing(int128 amount, bool isToken1) pure returns (bool increasing) {\n    assembly (\"memory-safe\") {\n        increasing := xor(isToken1, slt(amount, 0))\n    }\n}\n"}, "lib/solady/src/utils/LibBit.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Library for bit twiddling and boolean operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBit.sol)\n/// @author Inspired by (https://graphics.stanford.edu/~seander/bithacks.html)\nlibrary LibBit {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                  BIT TWIDDLING OPERATIONS                  */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Find last set.\n    /// Returns the index of the most significant bit of `x`,\n    /// counting from the least significant bit position.\n    /// If `x` is zero, returns 256.\n    function fls(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := or(shl(8, iszero(x)), shl(7, lt(0xffffffffffffffffffffffffffffffff, x)))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020504060203020504030106050205030304010505030400000000))\n        }\n    }\n\n    /// @dev Count leading zeros.\n    /// Returns the number of zeros preceding the most significant one bit.\n    /// If `x` is zero, returns 256.\n    function clz(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := add(xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff)), iszero(x))\n        }\n    }\n\n    /// @dev Find first set.\n    /// Returns the index of the least significant bit of `x`,\n    /// counting from the least significant bit position.\n    /// If `x` is zero, returns 256.\n    /// Equivalent to `ctz` (count trailing zeros), which gives\n    /// the number of zeros following the least significant one bit.\n    function ffs(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Isolate the least significant bit.\n            x := and(x, add(not(x), 1))\n            // For the upper 3 bits of the result, use a De Bruijn-like lookup.\n            // Credit to adhusson: https://blog.adhusson.com/cheap-find-first-set-evm/\n            // forgefmt: disable-next-item\n            r := shl(5, shr(252, shl(shl(2, shr(250, mul(x,\n                0xb6db6db6ddddddddd34d34d349249249210842108c6318c639ce739cffffffff))),\n                0x8040405543005266443200005020610674053026020000107506200176117077)))\n            // For the lower 5 bits of the result, use a De Bruijn lookup.\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(div(0xd76453e0, shr(r, x)), 0x1f),\n                0x001f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405))\n        }\n    }\n\n    /// @dev Returns the number of set bits in `x`.\n    function popCount(uint256 x) internal pure returns (uint256 c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let max := not(0)\n            let isMax := eq(x, max)\n            x := sub(x, and(shr(1, x), div(max, 3)))\n            x := add(and(x, div(max, 5)), and(shr(2, x), div(max, 5)))\n            x := and(add(x, shr(4, x)), div(max, 17))\n            c := or(shl(8, isMax), shr(248, mul(x, div(max, 255))))\n        }\n    }\n\n    /// @dev Returns whether `x` is a power of 2.\n    function isPo2(uint256 x) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `x && !(x & (x - 1))`.\n            result := iszero(add(and(x, sub(x, 1)), iszero(x)))\n        }\n    }\n\n    /// @dev Returns `x` reversed at the bit level.\n    function reverseBits(uint256 x) internal pure returns (uint256 r) {\n        uint256 m0 = 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f;\n        uint256 m1 = m0 ^ (m0 << 2);\n        uint256 m2 = m1 ^ (m1 << 1);\n        r = reverseBytes(x);\n        r = (m2 & (r >> 1)) | ((m2 & r) << 1);\n        r = (m1 & (r >> 2)) | ((m1 & r) << 2);\n        r = (m0 & (r >> 4)) | ((m0 & r) << 4);\n    }\n\n    /// @dev Returns `x` reversed at the byte level.\n    function reverseBytes(uint256 x) internal pure returns (uint256 r) {\n        unchecked {\n            // Computing masks on-the-fly reduces bytecode size by about 200 bytes.\n            uint256 m0 = 0x100000000000000000000000000000001 * (~toUint(x == uint256(0)) >> 192);\n            uint256 m1 = m0 ^ (m0 << 32);\n            uint256 m2 = m1 ^ (m1 << 16);\n            uint256 m3 = m2 ^ (m2 << 8);\n            r = (m3 & (x >> 8)) | ((m3 & x) << 8);\n            r = (m2 & (r >> 16)) | ((m2 & r) << 16);\n            r = (m1 & (r >> 32)) | ((m1 & r) << 32);\n            r = (m0 & (r >> 64)) | ((m0 & r) << 64);\n            r = (r >> 128) | (r << 128);\n        }\n    }\n\n    /// @dev Returns the common prefix of `x` and `y` at the bit level.\n    function commonBitPrefix(uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            uint256 s = 256 - clz(x ^ y);\n            return (x >> s) << s;\n        }\n    }\n\n    /// @dev Returns the common prefix of `x` and `y` at the nibble level.\n    function commonNibblePrefix(uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            uint256 s = (64 - (clz(x ^ y) >> 2)) << 2;\n            return (x >> s) << s;\n        }\n    }\n\n    /// @dev Returns the common prefix of `x` and `y` at the byte level.\n    function commonBytePrefix(uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            uint256 s = (32 - (clz(x ^ y) >> 3)) << 3;\n            return (x >> s) << s;\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                     BOOLEAN OPERATIONS                     */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    // A Solidity bool on the stack or memory is represented as a 256-bit word.\n    // Non-zero values are true, zero is false.\n    // A clean bool is either 0 (false) or 1 (true) under the hood.\n    // Usually, if not always, the bool result of a regular Solidity expression,\n    // or the argument of a public/external function will be a clean bool.\n    // You can usually use the raw variants for more performance.\n    // If uncertain, test (best with exact compiler settings).\n    // Or use the non-raw variants (compiler can sometimes optimize out the double `iszero`s).\n\n    /// @dev Returns `x & y`. Inputs must be clean.\n    function rawAnd(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := and(x, y)\n        }\n    }\n\n    /// @dev Returns `x & y`.\n    function and(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := and(iszero(iszero(x)), iszero(iszero(y)))\n        }\n    }\n\n    /// @dev Returns `x | y`. Inputs must be clean.\n    function rawOr(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, y)\n        }\n    }\n\n    /// @dev Returns `x | y`.\n    function or(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(iszero(iszero(x)), iszero(iszero(y)))\n        }\n    }\n\n    /// @dev Returns 1 if `b` is true, else 0. Input must be clean.\n    function rawToUint(bool b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := b\n        }\n    }\n\n    /// @dev Returns 1 if `b` is true, else 0.\n    function toUint(bool b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := iszero(iszero(b))\n        }\n    }\n}\n"}, "src/interfaces/IExposedStorage.sol": {"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.30;\n\n// Exposes all the storage of a contract via view methods.\n// Absent https://eips.ethereum.org/EIPS/eip-2330 this makes it easier to access specific pieces of state in the inheriting contract.\ninterface IExposedStorage {\n    // Loads each slot after the function selector from the contract's storage and returns all of them.\n    function sload() external view;\n    // Loads each slot after the function selector from the contract's transient storage and returns all of them.\n    function tload() external view;\n}\n"}, "src/interfaces/IFlashAccountant.sol": {"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.30;\n\ninterface ILocker {\n    function locked(uint256 id) external;\n}\n\ninterface IForwardee {\n    function forwarded(uint256 id, address originalLocker) external;\n}\n\ninterface IPayer {\n    function payCallback(uint256 id, address token) external;\n}\n\ninterface IFlashAccountant {\n    error NotLocked();\n    error LockerOnly();\n    error NoPaymentMade();\n    error DebtsNotZeroed(uint256 id);\n    // Thrown if the contract receives too much payment in the payment callback or from a direct native token transfer\n    error PaymentOverflow();\n    error PayReentrance();\n\n    // Create a lock context\n    // Any data passed after the function signature is passed through back to the caller after the locked function signature and data, with no additional encoding\n    // In addition, any data returned from ILocker#locked is also returned from this function exactly as is, i.e. with no additional encoding or decoding\n    // Reverts are also bubbled up\n    function lock() external;\n\n    // Forward the lock from the current locker to the given address\n    // Any additional calldata is also passed through to the forwardee, with no additional encoding\n    // In addition, any data returned from IForwardee#forwarded is also returned from this function exactly as is, i.e. with no additional encoding or decoding\n    // Reverts are also bubbled up\n    function forward(address to) external;\n\n    // Pays the given amount of token, by calling the payCallback function on the caller to afford them the opportunity to make the payment.\n    // This function, unlike lock and forward, does not return any of the returndata from the callback.\n    // This function also cannot be re-entered like lock and forward.\n    // Must be locked, as the contract accounts the payment against the current locker's debts.\n    // Token must not be the NATIVE_TOKEN_ADDRESS, as the `balanceOf` calls will fail.\n    // If you want to pay in the chain's native token, simply transfer it to this contract using a call.\n    // The payer must implement payCallback in which they must transfer the token to Core.\n    function pay(address token) external returns (uint128 payment);\n\n    // Withdraws a token amount from the accountant to the given recipient.\n    // The contract must be locked, as it tracks the withdrawn amount against the current locker's delta.\n    function withdraw(address token, address recipient, uint128 amount) external;\n\n    // This contract can receive ETH as a payment as well\n    receive() external payable;\n}\n"}}, "settings": {"remappings": ["forge-std/=lib/forge-std/src/", "solady/=lib/solady/src/"], "optimizer": {"enabled": true}, "metadata": {"useLiteralContent": false, "bytecodeHash": "ipfs", "appendCBOR": true}, "outputSelection": {"*": {"*": ["evm.legacyAssembly"]}}, "evmVersion": "cancun", "viaIR": false, "libraries": {}}}