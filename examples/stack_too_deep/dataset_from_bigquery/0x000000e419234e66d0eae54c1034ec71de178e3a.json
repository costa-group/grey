{"language": "Solidity", "sources": {"src/ldf/CarpetedGeometricDistribution.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport {PoolKey} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\n\nimport \"./ShiftMode.sol\";\nimport {Guarded} from \"../base/Guarded.sol\";\nimport {LibCarpetedGeometricDistribution} from \"./LibCarpetedGeometricDistribution.sol\";\nimport {ILiquidityDensityFunction} from \"../interfaces/ILiquidityDensityFunction.sol\";\n\n/// @title CarpetedGeometricDistribution\n/// @author zefram.eth\n/// @notice Geometric distribution with a \"carpet\" of uniform liquidity outside of the main range.\n/// Should be used in production when TWAP is enabled, since we always have some liquidity in all ticks.\ncontract CarpetedGeometricDistribution is ILiquidityDensityFunction, Guarded {\n    uint32 internal constant INITIALIZED_STATE = 1 << 24;\n\n    constructor(address hub_, address hook_, address quoter_) Guarded(hub_, hook_, quoter_) {}\n\n    /// @inheritdoc ILiquidityDensityFunction\n    function query(\n        PoolKey calldata key,\n        int24 roundedTick,\n        int24 twapTick,\n        int24, /* spotPriceTick */\n        bytes32 ldfParams,\n        bytes32 ldfState\n    )\n        external\n        view\n        override\n        guarded\n        returns (\n            uint256 liquidityDensityX96_,\n            uint256 cumulativeAmount0DensityX96,\n            uint256 cumulativeAmount1DensityX96,\n            bytes32 newLdfState,\n            bool shouldSurge\n        )\n    {\n        (int24 minTick, int24 length, uint256 alphaX96, uint256 weightCarpet, ShiftMode shiftMode) =\n            LibCarpetedGeometricDistribution.decodeParams(twapTick, key.tickSpacing, ldfParams);\n        (bool initialized, int24 lastMinTick) = _decodeState(ldfState);\n        if (initialized) {\n            minTick = enforceShiftMode(minTick, lastMinTick, shiftMode);\n            shouldSurge = minTick != lastMinTick;\n        }\n\n        (liquidityDensityX96_, cumulativeAmount0DensityX96, cumulativeAmount1DensityX96) =\n        LibCarpetedGeometricDistribution.query(roundedTick, key.tickSpacing, minTick, length, alphaX96, weightCarpet);\n        newLdfState = _encodeState(minTick);\n    }\n\n    /// @inheritdoc ILiquidityDensityFunction\n    function computeSwap(\n        PoolKey calldata key,\n        uint256 inverseCumulativeAmountInput,\n        uint256 totalLiquidity,\n        bool zeroForOne,\n        bool exactIn,\n        int24 twapTick,\n        int24, /* spotPriceTick */\n        bytes32 ldfParams,\n        bytes32 ldfState\n    )\n        external\n        view\n        override\n        guarded\n        returns (\n            bool success,\n            int24 roundedTick,\n            uint256 cumulativeAmount0_,\n            uint256 cumulativeAmount1_,\n            uint256 swapLiquidity\n        )\n    {\n        (int24 minTick, int24 length, uint256 alphaX96, uint256 weightCarpet, ShiftMode shiftMode) =\n            LibCarpetedGeometricDistribution.decodeParams(twapTick, key.tickSpacing, ldfParams);\n        (bool initialized, int24 lastMinTick) = _decodeState(ldfState);\n        if (initialized) {\n            minTick = enforceShiftMode(minTick, lastMinTick, shiftMode);\n        }\n\n        return LibCarpetedGeometricDistribution.computeSwap(\n            inverseCumulativeAmountInput,\n            totalLiquidity,\n            zeroForOne,\n            exactIn,\n            key.tickSpacing,\n            minTick,\n            length,\n            alphaX96,\n            weightCarpet\n        );\n    }\n\n    /// @inheritdoc ILiquidityDensityFunction\n    function cumulativeAmount0(\n        PoolKey calldata key,\n        int24 roundedTick,\n        uint256 totalLiquidity,\n        int24 twapTick,\n        int24, /* spotPriceTick */\n        bytes32 ldfParams,\n        bytes32 ldfState\n    ) external view override guarded returns (uint256) {\n        (int24 minTick, int24 length, uint256 alphaX96, uint256 weightCarpet, ShiftMode shiftMode) =\n            LibCarpetedGeometricDistribution.decodeParams(twapTick, key.tickSpacing, ldfParams);\n        (bool initialized, int24 lastMinTick) = _decodeState(ldfState);\n        if (initialized) {\n            minTick = enforceShiftMode(minTick, lastMinTick, shiftMode);\n        }\n\n        return LibCarpetedGeometricDistribution.cumulativeAmount0(\n            roundedTick, totalLiquidity, key.tickSpacing, minTick, length, alphaX96, weightCarpet\n        );\n    }\n\n    /// @inheritdoc ILiquidityDensityFunction\n    function cumulativeAmount1(\n        PoolKey calldata key,\n        int24 roundedTick,\n        uint256 totalLiquidity,\n        int24 twapTick,\n        int24, /* spotPriceTick */\n        bytes32 ldfParams,\n        bytes32 ldfState\n    ) external view override guarded returns (uint256) {\n        (int24 minTick, int24 length, uint256 alphaX96, uint256 weightCarpet, ShiftMode shiftMode) =\n            LibCarpetedGeometricDistribution.decodeParams(twapTick, key.tickSpacing, ldfParams);\n        (bool initialized, int24 lastMinTick) = _decodeState(ldfState);\n        if (initialized) {\n            minTick = enforceShiftMode(minTick, lastMinTick, shiftMode);\n        }\n\n        return LibCarpetedGeometricDistribution.cumulativeAmount1(\n            roundedTick, totalLiquidity, key.tickSpacing, minTick, length, alphaX96, weightCarpet\n        );\n    }\n\n    /// @inheritdoc ILiquidityDensityFunction\n    function isValidParams(PoolKey calldata key, uint24 twapSecondsAgo, bytes32 ldfParams)\n        external\n        pure\n        override\n        returns (bool)\n    {\n        return LibCarpetedGeometricDistribution.isValidParams(key.tickSpacing, twapSecondsAgo, ldfParams);\n    }\n\n    function _decodeState(bytes32 ldfState) internal pure returns (bool initialized, int24 lastMinTick) {\n        // | initialized - 1 byte | lastMinTick - 3 bytes |\n        initialized = uint8(bytes1(ldfState)) == 1;\n        lastMinTick = int24(uint24(bytes3(ldfState << 8)));\n    }\n\n    function _encodeState(int24 lastMinTick) internal pure returns (bytes32 ldfState) {\n        // | initialized - 1 byte | lastMinTick - 3 bytes |\n        ldfState = bytes32(bytes4(INITIALIZED_STATE + uint32(uint24(lastMinTick))));\n    }\n}\n"}, "lib/v4-core/src/interfaces/IPoolManager.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Currency} from \"../types/Currency.sol\";\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {IHooks} from \"./IHooks.sol\";\nimport {IERC6909Claims} from \"./external/IERC6909Claims.sol\";\nimport {IProtocolFees} from \"./IProtocolFees.sol\";\nimport {BalanceDelta} from \"../types/BalanceDelta.sol\";\nimport {PoolId} from \"../types/PoolId.sol\";\nimport {IExtsload} from \"./IExtsload.sol\";\nimport {IExttload} from \"./IExttload.sol\";\n\n/// @notice Interface for the PoolManager\ninterface IPoolManager is IProtocolFees, IERC6909Claims, IExtsload, IExttload {\n    /// @notice Thrown when a currency is not netted out after the contract is unlocked\n    error CurrencyNotSettled();\n\n    /// @notice Thrown when trying to interact with a non-initialized pool\n    error PoolNotInitialized();\n\n    /// @notice Thrown when unlock is called, but the contract is already unlocked\n    error AlreadyUnlocked();\n\n    /// @notice Thrown when a function is called that requires the contract to be unlocked, but it is not\n    error ManagerLocked();\n\n    /// @notice Pools are limited to type(int16).max tickSpacing in #initialize, to prevent overflow\n    error TickSpacingTooLarge(int24 tickSpacing);\n\n    /// @notice Pools must have a positive non-zero tickSpacing passed to #initialize\n    error TickSpacingTooSmall(int24 tickSpacing);\n\n    /// @notice PoolKey must have currencies where address(currency0) < address(currency1)\n    error CurrenciesOutOfOrderOrEqual(address currency0, address currency1);\n\n    /// @notice Thrown when a call to updateDynamicLPFee is made by an address that is not the hook,\n    /// or on a pool that does not have a dynamic swap fee.\n    error UnauthorizedDynamicLPFeeUpdate();\n\n    /// @notice Thrown when trying to swap amount of 0\n    error SwapAmountCannotBeZero();\n\n    ///@notice Thrown when native currency is passed to a non native settlement\n    error NonzeroNativeValue();\n\n    /// @notice Thrown when `clear` is called with an amount that is not exactly equal to the open currency delta.\n    error MustClearExactPositiveDelta();\n\n    /// @notice Emitted when a new pool is initialized\n    /// @param id The abi encoded hash of the pool key struct for the new pool\n    /// @param currency0 The first currency of the pool by address sort order\n    /// @param currency1 The second currency of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param hooks The hooks contract address for the pool, or address(0) if none\n    /// @param sqrtPriceX96 The price of the pool on initialization\n    /// @param tick The initial tick of the pool corresponding to the initialized price\n    event Initialize(\n        PoolId indexed id,\n        Currency indexed currency0,\n        Currency indexed currency1,\n        uint24 fee,\n        int24 tickSpacing,\n        IHooks hooks,\n        uint160 sqrtPriceX96,\n        int24 tick\n    );\n\n    /// @notice Emitted when a liquidity position is modified\n    /// @param id The abi encoded hash of the pool key struct for the pool that was modified\n    /// @param sender The address that modified the pool\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param liquidityDelta The amount of liquidity that was added or removed\n    /// @param salt The extra data to make positions unique\n    event ModifyLiquidity(\n        PoolId indexed id, address indexed sender, int24 tickLower, int24 tickUpper, int256 liquidityDelta, bytes32 salt\n    );\n\n    /// @notice Emitted for swaps between currency0 and currency1\n    /// @param id The abi encoded hash of the pool key struct for the pool that was modified\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param amount0 The delta of the currency0 balance of the pool\n    /// @param amount1 The delta of the currency1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of the price of the pool after the swap\n    /// @param fee The swap fee in hundredths of a bip\n    event Swap(\n        PoolId indexed id,\n        address indexed sender,\n        int128 amount0,\n        int128 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick,\n        uint24 fee\n    );\n\n    /// @notice Emitted for donations\n    /// @param id The abi encoded hash of the pool key struct for the pool that was donated to\n    /// @param sender The address that initiated the donate call\n    /// @param amount0 The amount donated in currency0\n    /// @param amount1 The amount donated in currency1\n    event Donate(PoolId indexed id, address indexed sender, uint256 amount0, uint256 amount1);\n\n    /// @notice All interactions on the contract that account deltas require unlocking. A caller that calls `unlock` must implement\n    /// `IUnlockCallback(msg.sender).unlockCallback(data)`, where they interact with the remaining functions on this contract.\n    /// @dev The only functions callable without an unlocking are `initialize` and `updateDynamicLPFee`\n    /// @param data Any data to pass to the callback, via `IUnlockCallback(msg.sender).unlockCallback(data)`\n    /// @return The data returned by the call to `IUnlockCallback(msg.sender).unlockCallback(data)`\n    function unlock(bytes calldata data) external returns (bytes memory);\n\n    /// @notice Initialize the state for a given pool ID\n    /// @dev A swap fee totaling MAX_SWAP_FEE (100%) makes exact output swaps impossible since the input is entirely consumed by the fee\n    /// @param key The pool key for the pool to initialize\n    /// @param sqrtPriceX96 The initial square root price\n    /// @return tick The initial tick of the pool\n    function initialize(PoolKey memory key, uint160 sqrtPriceX96) external returns (int24 tick);\n\n    struct ModifyLiquidityParams {\n        // the lower and upper tick of the position\n        int24 tickLower;\n        int24 tickUpper;\n        // how to modify the liquidity\n        int256 liquidityDelta;\n        // a value to set if you want unique liquidity positions at the same range\n        bytes32 salt;\n    }\n\n    /// @notice Modify the liquidity for the given pool\n    /// @dev Poke by calling with a zero liquidityDelta\n    /// @param key The pool to modify liquidity in\n    /// @param params The parameters for modifying the liquidity\n    /// @param hookData The data to pass through to the add/removeLiquidity hooks\n    /// @return callerDelta The balance delta of the caller of modifyLiquidity. This is the total of both principal, fee deltas, and hook deltas if applicable\n    /// @return feesAccrued The balance delta of the fees generated in the liquidity range. Returned for informational purposes\n    /// @dev Note that feesAccrued can be artificially inflated by a malicious actor and integrators should be careful using the value\n    /// For pools with a single liquidity position, actors can donate to themselves to inflate feeGrowthGlobal (and consequently feesAccrued)\n    /// atomically donating and collecting fees in the same unlockCallback may make the inflated value more extreme\n    function modifyLiquidity(PoolKey memory key, ModifyLiquidityParams memory params, bytes calldata hookData)\n        external\n        returns (BalanceDelta callerDelta, BalanceDelta feesAccrued);\n\n    struct SwapParams {\n        /// Whether to swap token0 for token1 or vice versa\n        bool zeroForOne;\n        /// The desired input amount if negative (exactIn), or the desired output amount if positive (exactOut)\n        int256 amountSpecified;\n        /// The sqrt price at which, if reached, the swap will stop executing\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swap against the given pool\n    /// @param key The pool to swap in\n    /// @param params The parameters for swapping\n    /// @param hookData The data to pass through to the swap hooks\n    /// @return swapDelta The balance delta of the address swapping\n    /// @dev Swapping on low liquidity pools may cause unexpected swap amounts when liquidity available is less than amountSpecified.\n    /// Additionally note that if interacting with hooks that have the BEFORE_SWAP_RETURNS_DELTA_FLAG or AFTER_SWAP_RETURNS_DELTA_FLAG\n    /// the hook may alter the swap input/output. Integrators should perform checks on the returned swapDelta.\n    function swap(PoolKey memory key, SwapParams memory params, bytes calldata hookData)\n        external\n        returns (BalanceDelta swapDelta);\n\n    /// @notice Donate the given currency amounts to the in-range liquidity providers of a pool\n    /// @dev Calls to donate can be frontrun adding just-in-time liquidity, with the aim of receiving a portion donated funds.\n    /// Donors should keep this in mind when designing donation mechanisms.\n    /// @dev This function donates to in-range LPs at slot0.tick. In certain edge-cases of the swap algorithm, the `sqrtPrice` of\n    /// a pool can be at the lower boundary of tick `n`, but the `slot0.tick` of the pool is already `n - 1`. In this case a call to\n    /// `donate` would donate to tick `n - 1` (slot0.tick) not tick `n` (getTickAtSqrtPrice(slot0.sqrtPriceX96)).\n    /// Read the comments in `Pool.swap()` for more information about this.\n    /// @param key The key of the pool to donate to\n    /// @param amount0 The amount of currency0 to donate\n    /// @param amount1 The amount of currency1 to donate\n    /// @param hookData The data to pass through to the donate hooks\n    /// @return BalanceDelta The delta of the caller after the donate\n    function donate(PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)\n        external\n        returns (BalanceDelta);\n\n    /// @notice Writes the current ERC20 balance of the specified currency to transient storage\n    /// This is used to checkpoint balances for the manager and derive deltas for the caller.\n    /// @dev This MUST be called before any ERC20 tokens are sent into the contract, but can be skipped\n    /// for native tokens because the amount to settle is determined by the sent value.\n    /// However, if an ERC20 token has been synced and not settled, and the caller instead wants to settle\n    /// native funds, this function can be called with the native currency to then be able to settle the native currency\n    function sync(Currency currency) external;\n\n    /// @notice Called by the user to net out some value owed to the user\n    /// @dev Will revert if the requested amount is not available, consider using `mint` instead\n    /// @dev Can also be used as a mechanism for free flash loans\n    /// @param currency The currency to withdraw from the pool manager\n    /// @param to The address to withdraw to\n    /// @param amount The amount of currency to withdraw\n    function take(Currency currency, address to, uint256 amount) external;\n\n    /// @notice Called by the user to pay what is owed\n    /// @return paid The amount of currency settled\n    function settle() external payable returns (uint256 paid);\n\n    /// @notice Called by the user to pay on behalf of another address\n    /// @param recipient The address to credit for the payment\n    /// @return paid The amount of currency settled\n    function settleFor(address recipient) external payable returns (uint256 paid);\n\n    /// @notice WARNING - Any currency that is cleared, will be non-retrievable, and locked in the contract permanently.\n    /// A call to clear will zero out a positive balance WITHOUT a corresponding transfer.\n    /// @dev This could be used to clear a balance that is considered dust.\n    /// Additionally, the amount must be the exact positive balance. This is to enforce that the caller is aware of the amount being cleared.\n    function clear(Currency currency, uint256 amount) external;\n\n    /// @notice Called by the user to move value into ERC6909 balance\n    /// @param to The address to mint the tokens to\n    /// @param id The currency address to mint to ERC6909s, as a uint256\n    /// @param amount The amount of currency to mint\n    /// @dev The id is converted to a uint160 to correspond to a currency address\n    /// If the upper 12 bytes are not 0, they will be 0-ed out\n    function mint(address to, uint256 id, uint256 amount) external;\n\n    /// @notice Called by the user to move value from ERC6909 balance\n    /// @param from The address to burn the tokens from\n    /// @param id The currency address to burn from ERC6909s, as a uint256\n    /// @param amount The amount of currency to burn\n    /// @dev The id is converted to a uint160 to correspond to a currency address\n    /// If the upper 12 bytes are not 0, they will be 0-ed out\n    function burn(address from, uint256 id, uint256 amount) external;\n\n    /// @notice Updates the pools lp fees for the a pool that has enabled dynamic lp fees.\n    /// @dev A swap fee totaling MAX_SWAP_FEE (100%) makes exact output swaps impossible since the input is entirely consumed by the fee\n    /// @param key The key of the pool to update dynamic LP fees for\n    /// @param newDynamicLPFee The new dynamic pool LP fee\n    function updateDynamicLPFee(PoolKey memory key, uint24 newDynamicLPFee) external;\n}\n"}, "src/ldf/ShiftMode.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nenum ShiftMode {\n    BOTH,\n    LEFT,\n    RIGHT,\n    STATIC\n}\n\nfunction enforceShiftMode(int24 tick, int24 lastTick, ShiftMode shiftMode) pure returns (int24) {\n    if ((shiftMode == ShiftMode.LEFT && tick > lastTick) || (shiftMode == ShiftMode.RIGHT && tick < lastTick)) {\n        return lastTick;\n    }\n    return tick;\n}\n"}, "src/base/Guarded.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {CustomRevert} from \"@uniswap/v4-core/src/libraries/CustomRevert.sol\";\n\nabstract contract Guarded {\n    using CustomRevert for bytes4;\n\n    error GuardedCall();\n\n    /// @dev The original address of this contract\n    address private immutable original;\n\n    address private immutable hub;\n    address private immutable hook;\n    address private immutable quoter;\n\n    function _guardedCheck() private view {\n        if (\n            (msg.sender != hub && msg.sender != hook && msg.sender != quoter && msg.sender != address(0))\n                || address(this) != original\n        ) {\n            GuardedCall.selector.revertWith();\n        }\n    }\n\n    modifier guarded() {\n        _guardedCheck();\n        _;\n    }\n\n    constructor(address hub_, address hook_, address quoter_) {\n        // Immutables are computed in the init code of the contract, and then inlined into the deployed bytecode.\n        // In other words, this variable won't change when it's checked at runtime.\n        original = address(this);\n\n        // Record permitted addresses\n        hub = hub_;\n        hook = hook_;\n        quoter = quoter_;\n    }\n}\n"}, "src/ldf/LibCarpetedGeometricDistribution.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport \"./ShiftMode.sol\";\nimport \"../lib/Math.sol\";\nimport \"../lib/ExpMath.sol\";\nimport \"../base/Constants.sol\";\nimport \"./LibUniformDistribution.sol\";\nimport \"./LibGeometricDistribution.sol\";\n\nlibrary LibCarpetedGeometricDistribution {\n    using SafeCastLib for uint256;\n    using FixedPointMathLib for uint256;\n\n    uint256 internal constant ALPHA_BASE = 1e8; // alpha uses 8 decimals in ldfParams\n    uint256 internal constant MIN_LIQUIDITY_DENSITY = Q96 / 1e3;\n\n    /// @dev Queries the liquidity density and the cumulative amounts at the given rounded tick.\n    /// @param roundedTick The rounded tick to query\n    /// @param tickSpacing The spacing of the ticks\n    /// @return liquidityDensityX96_ The liquidity density at the given rounded tick. Range is [0, 1]. Scaled by 2^96.\n    /// @return cumulativeAmount0DensityX96 The cumulative amount of token0 in the rounded ticks [roundedTick + tickSpacing, minTick + length * tickSpacing)\n    /// @return cumulativeAmount1DensityX96 The cumulative amount of token1 in the rounded ticks [minTick, roundedTick - tickSpacing]\n    function query(\n        int24 roundedTick,\n        int24 tickSpacing,\n        int24 minTick,\n        int24 length,\n        uint256 alphaX96,\n        uint256 weightCarpet\n    )\n        internal\n        pure\n        returns (uint256 liquidityDensityX96_, uint256 cumulativeAmount0DensityX96, uint256 cumulativeAmount1DensityX96)\n    {\n        // compute liquidityDensityX96\n        liquidityDensityX96_ = liquidityDensityX96(roundedTick, tickSpacing, minTick, length, alphaX96, weightCarpet);\n\n        // compute cumulativeAmount0DensityX96\n        cumulativeAmount0DensityX96 =\n            cumulativeAmount0(roundedTick + tickSpacing, Q96, tickSpacing, minTick, length, alphaX96, weightCarpet);\n\n        // compute cumulativeAmount1DensityX96\n        cumulativeAmount1DensityX96 =\n            cumulativeAmount1(roundedTick - tickSpacing, Q96, tickSpacing, minTick, length, alphaX96, weightCarpet);\n    }\n\n    /// @dev Computes the cumulative amount of token0 in the rounded ticks [roundedTick, tickUpper).\n    function cumulativeAmount0(\n        int24 roundedTick,\n        uint256 totalLiquidity,\n        int24 tickSpacing,\n        int24 minTick,\n        int24 length,\n        uint256 alphaX96,\n        uint256 weightCarpet\n    ) internal pure returns (uint256 amount0) {\n        (\n            uint256 leftCarpetLiquidity,\n            uint256 mainLiquidity,\n            uint256 rightCarpetLiquidity,\n            int24 minUsableTick,\n            int24 maxUsableTick\n        ) = getCarpetedLiquidity(totalLiquidity, tickSpacing, minTick, length, weightCarpet);\n\n        return LibUniformDistribution.cumulativeAmount0(\n            roundedTick, leftCarpetLiquidity, tickSpacing, minUsableTick, minTick, true\n        )\n            + LibGeometricDistribution.cumulativeAmount0(roundedTick, mainLiquidity, tickSpacing, minTick, length, alphaX96)\n            + LibUniformDistribution.cumulativeAmount0(\n                roundedTick, rightCarpetLiquidity, tickSpacing, minTick + length * tickSpacing, maxUsableTick, true\n            );\n    }\n\n    /// @dev Computes the cumulative amount of token1 in the rounded ticks [tickLower, roundedTick].\n    function cumulativeAmount1(\n        int24 roundedTick,\n        uint256 totalLiquidity,\n        int24 tickSpacing,\n        int24 minTick,\n        int24 length,\n        uint256 alphaX96,\n        uint256 weightCarpet\n    ) internal pure returns (uint256 amount1) {\n        (\n            uint256 leftCarpetLiquidity,\n            uint256 mainLiquidity,\n            uint256 rightCarpetLiquidity,\n            int24 minUsableTick,\n            int24 maxUsableTick\n        ) = getCarpetedLiquidity(totalLiquidity, tickSpacing, minTick, length, weightCarpet);\n\n        return LibUniformDistribution.cumulativeAmount1(\n            roundedTick, leftCarpetLiquidity, tickSpacing, minUsableTick, minTick, true\n        )\n            + LibGeometricDistribution.cumulativeAmount1(roundedTick, mainLiquidity, tickSpacing, minTick, length, alphaX96)\n            + LibUniformDistribution.cumulativeAmount1(\n                roundedTick, rightCarpetLiquidity, tickSpacing, minTick + length * tickSpacing, maxUsableTick, true\n            );\n    }\n\n    /// @dev Given a cumulativeAmount0, computes the rounded tick whose cumulativeAmount0 is closest to the input. Range is [tickLower, tickUpper].\n    ///      The returned tick will be the largest rounded tick whose cumulativeAmount0 is greater than or equal to the input.\n    ///      In the case that the input exceeds the cumulativeAmount0 of all rounded ticks, the function will return (false, 0).\n    function inverseCumulativeAmount0(\n        uint256 cumulativeAmount0_,\n        uint256 totalLiquidity,\n        int24 tickSpacing,\n        int24 minTick,\n        int24 length,\n        uint256 alphaX96,\n        uint256 weightCarpet\n    ) internal pure returns (bool success, int24 roundedTick) {\n        // try LDFs in the order of right carpet, main, left carpet\n        (\n            uint256 leftCarpetLiquidity,\n            uint256 mainLiquidity,\n            uint256 rightCarpetLiquidity,\n            int24 minUsableTick,\n            int24 maxUsableTick\n        ) = getCarpetedLiquidity(totalLiquidity, tickSpacing, minTick, length, weightCarpet);\n        if (cumulativeAmount0_ == 0) {\n            return (true, maxUsableTick);\n        }\n        uint256 rightCarpetCumulativeAmount0 = LibUniformDistribution.cumulativeAmount0(\n            minTick + length * tickSpacing,\n            rightCarpetLiquidity,\n            tickSpacing,\n            minTick + length * tickSpacing,\n            maxUsableTick,\n            true\n        );\n\n        if (cumulativeAmount0_ <= rightCarpetCumulativeAmount0 && rightCarpetLiquidity != 0) {\n            // use right carpet\n            return LibUniformDistribution.inverseCumulativeAmount0(\n                cumulativeAmount0_, rightCarpetLiquidity, tickSpacing, minTick + length * tickSpacing, maxUsableTick\n            );\n        } else {\n            uint256 remainder = cumulativeAmount0_ - rightCarpetCumulativeAmount0;\n            uint256 mainCumulativeAmount0 = LibGeometricDistribution.cumulativeAmount0(\n                minTick, mainLiquidity, tickSpacing, minTick, length, alphaX96\n            );\n\n            if (remainder <= mainCumulativeAmount0) {\n                // use main\n                return LibGeometricDistribution.inverseCumulativeAmount0(\n                    remainder, mainLiquidity, tickSpacing, minTick, length, alphaX96\n                );\n            } else if (leftCarpetLiquidity != 0) {\n                // use left carpet\n                remainder -= mainCumulativeAmount0;\n\n                (success, roundedTick) = LibUniformDistribution.inverseCumulativeAmount0(\n                    remainder, leftCarpetLiquidity, tickSpacing, minUsableTick, minTick\n                );\n                return (success, roundedTick);\n            }\n        }\n        return (false, 0);\n    }\n\n    /// @dev Given a cumulativeAmount1, computes the rounded tick whose cumulativeAmount1 is closest to the input. Range is [tickLower - tickSpacing, tickUpper - tickSpacing].\n    ///      The returned tick will be the smallest rounded tick whose cumulativeAmount1 is greater than or equal to the input.\n    ///      In the case that the input exceeds the cumulativeAmount1 of all rounded ticks, the function will return (false, 0).\n    function inverseCumulativeAmount1(\n        uint256 cumulativeAmount1_,\n        uint256 totalLiquidity,\n        int24 tickSpacing,\n        int24 minTick,\n        int24 length,\n        uint256 alphaX96,\n        uint256 weightCarpet\n    ) internal pure returns (bool success, int24 roundedTick) {\n        // try LDFs in the order of left carpet, main, right carpet\n        (\n            uint256 leftCarpetLiquidity,\n            uint256 mainLiquidity,\n            uint256 rightCarpetLiquidity,\n            int24 minUsableTick,\n            int24 maxUsableTick\n        ) = getCarpetedLiquidity(totalLiquidity, tickSpacing, minTick, length, weightCarpet);\n        if (cumulativeAmount1_ == 0) {\n            return (true, minUsableTick - tickSpacing);\n        }\n        uint256 leftCarpetCumulativeAmount1 = LibUniformDistribution.cumulativeAmount1(\n            minTick, leftCarpetLiquidity, tickSpacing, minUsableTick, minTick, true\n        );\n\n        if (cumulativeAmount1_ <= leftCarpetCumulativeAmount1 && leftCarpetLiquidity != 0) {\n            // use left carpet\n            return LibUniformDistribution.inverseCumulativeAmount1(\n                cumulativeAmount1_, leftCarpetLiquidity, tickSpacing, minUsableTick, minTick\n            );\n        } else {\n            uint256 remainder = cumulativeAmount1_ - leftCarpetCumulativeAmount1;\n            uint256 mainCumulativeAmount1 = LibGeometricDistribution.cumulativeAmount1(\n                minTick + length * tickSpacing, mainLiquidity, tickSpacing, minTick, length, alphaX96\n            );\n\n            if (remainder <= mainCumulativeAmount1) {\n                // use main\n                return LibGeometricDistribution.inverseCumulativeAmount1(\n                    remainder, mainLiquidity, tickSpacing, minTick, length, alphaX96\n                );\n            } else if (rightCarpetLiquidity != 0) {\n                // use right carpet\n                remainder -= mainCumulativeAmount1;\n                return LibUniformDistribution.inverseCumulativeAmount1(\n                    remainder, rightCarpetLiquidity, tickSpacing, minTick + length * tickSpacing, maxUsableTick\n                );\n            }\n        }\n        return (false, 0);\n    }\n\n    function checkMinLiquidityDensity(int24 tickSpacing, int24 length, uint256 alpha, uint256 weightCarpet)\n        internal\n        pure\n        returns (bool)\n    {\n        // ensure liquidity density is nowhere equal to zero\n        // can check boundaries since function is monotonic\n        int24 minTick = 0; // no loss of generality since shifting doesn't change the min liquidity density\n        {\n            uint256 alphaX96 = uint256(alpha).mulDiv(Q96, ALPHA_BASE);\n            uint256 minLiquidityDensityX96;\n            if (alpha > ALPHA_BASE) {\n                // monotonically increasing\n                // check left boundary\n                minLiquidityDensityX96 =\n                    LibGeometricDistribution.liquidityDensityX96(minTick, tickSpacing, minTick, length, alphaX96);\n            } else {\n                // monotonically decreasing\n                // check right boundary\n                minLiquidityDensityX96 = LibGeometricDistribution.liquidityDensityX96(\n                    minTick + (length - 1) * tickSpacing, tickSpacing, minTick, length, alphaX96\n                );\n            }\n            minLiquidityDensityX96 = minLiquidityDensityX96.mulWad(WAD - weightCarpet);\n            if (minLiquidityDensityX96 < MIN_LIQUIDITY_DENSITY) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function liquidityDensityX96(\n        int24 roundedTick,\n        int24 tickSpacing,\n        int24 minTick,\n        int24 length,\n        uint256 alphaX96,\n        uint256 weightCarpet\n    ) internal pure returns (uint256) {\n        if (roundedTick >= minTick && roundedTick < minTick + length * tickSpacing) {\n            return LibGeometricDistribution.liquidityDensityX96(roundedTick, tickSpacing, minTick, length, alphaX96)\n                .mulWad(WAD - weightCarpet);\n        } else {\n            (int24 minUsableTick, int24 maxUsableTick) =\n                (TickMath.minUsableTick(tickSpacing), TickMath.maxUsableTick(tickSpacing));\n            int24 numRoundedTicksCarpeted = (maxUsableTick - minUsableTick) / tickSpacing - length;\n            if (numRoundedTicksCarpeted <= 0) {\n                return 0;\n            }\n            uint256 mainLiquidity = Q96.mulWad(WAD - weightCarpet);\n            uint256 carpetLiquidity = Q96 - mainLiquidity;\n            return carpetLiquidity / uint24(numRoundedTicksCarpeted);\n        }\n    }\n\n    /// @dev Combines several operations used during a swap into one function to save gas.\n    ///      Given a cumulative amount, it computes its inverse to find the closest rounded tick, then computes the cumulative amount at that tick,\n    ///      and finally computes the liquidity of the tick that will handle the remainder of the swap.\n    function computeSwap(\n        uint256 inverseCumulativeAmountInput,\n        uint256 totalLiquidity,\n        bool zeroForOne,\n        bool exactIn,\n        int24 tickSpacing,\n        int24 minTick,\n        int24 length,\n        uint256 alphaX96,\n        uint256 weightCarpet\n    )\n        internal\n        pure\n        returns (\n            bool success,\n            int24 roundedTick,\n            uint256 cumulativeAmount0_,\n            uint256 cumulativeAmount1_,\n            uint256 swapLiquidity\n        )\n    {\n        if (exactIn == zeroForOne) {\n            // compute roundedTick by inverting the cumulative amount\n            // below is an illustration of 4 rounded ticks, the input amount, and the resulting roundedTick (rick)\n            // notice that the inverse tick is between two rounded ticks, and we round down to the rounded tick to the left\n            // e.g. go from 1.5 to 1\n            //       input\n            //      \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //    \u2502\n            //    \u25bc\n            //   rick\n            (success, roundedTick) = inverseCumulativeAmount0(\n                inverseCumulativeAmountInput, totalLiquidity, tickSpacing, minTick, length, alphaX96, weightCarpet\n            );\n            if (!success) return (false, 0, 0, 0, 0);\n\n            // compute the cumulative amount up to roundedTick\n            // below is an illustration of the cumulative amount at roundedTick\n            // notice that exactIn ? (input - cum) : (cum - input) is the remainder of the swap that will be handled by Uniswap math\n            // exactIn:\n            //         cum\n            //       \u251c\u2500\u2500\u2500\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //       \u2502\n            //       \u25bc\n            //      rick + tickSpacing\n            // exactOut:\n            //        cum\n            //    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //    \u2502\n            //    \u25bc\n            //   rick\n            cumulativeAmount0_ = exactIn\n                ? cumulativeAmount0(\n                    roundedTick + tickSpacing, totalLiquidity, tickSpacing, minTick, length, alphaX96, weightCarpet\n                )\n                : cumulativeAmount0(roundedTick, totalLiquidity, tickSpacing, minTick, length, alphaX96, weightCarpet);\n\n            // compute the cumulative amount of the complementary token\n            // below is an illustration\n            // exactIn:\n            //   cum\n            // \u251c\u2500\u2500\u2500\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //    \u2502\n            //    \u25bc\n            //   rick\n            // exactOut:\n            //  cum\n            // \u251c\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            // \u2502\n            // \u25bc\n            //rick - tickSpacing\n            cumulativeAmount1_ = exactIn\n                ? cumulativeAmount1(roundedTick, totalLiquidity, tickSpacing, minTick, length, alphaX96, weightCarpet)\n                : cumulativeAmount1(\n                    roundedTick - tickSpacing, totalLiquidity, tickSpacing, minTick, length, alphaX96, weightCarpet\n                );\n\n            // compute liquidity of the rounded tick that will handle the remainder of the swap\n            // below is an illustration of the liquidity of the rounded tick that will handle the remainder of the swap\n            //    liq\n            //    \u251c\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //    \u2502\n            //    \u25bc\n            //   rick\n            swapLiquidity = (\n                liquidityDensityX96(roundedTick, tickSpacing, minTick, length, alphaX96, weightCarpet) * totalLiquidity\n            ) >> 96;\n        } else {\n            // compute roundedTick by inverting the cumulative amount\n            // below is an illustration of 4 rounded ticks, the input amount, and the resulting roundedTick (rick)\n            // notice that the inverse tick is between two rounded ticks, and we round up to the rounded tick to the right\n            // e.g. go from 1.5 to 2\n            //  input\n            // \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //       \u2502\n            //       \u25bc\n            //      rick\n            (success, roundedTick) = inverseCumulativeAmount1(\n                inverseCumulativeAmountInput, totalLiquidity, tickSpacing, minTick, length, alphaX96, weightCarpet\n            );\n            if (!success) return (false, 0, 0, 0, 0);\n\n            // compute the cumulative amount up to roundedTick\n            // below is an illustration of the cumulative amount at roundedTick\n            // notice that exactIn ? (input - cum) : (cum - input) is the remainder of the swap that will be handled by Uniswap math\n            // exactIn:\n            //   cum\n            // \u251c\u2500\u2500\u2500\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //    \u2502\n            //    \u25bc\n            //   rick - tickSpacing\n            // exactOut:\n            //     cum\n            // \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //       \u2502\n            //       \u25bc\n            //      rick\n            cumulativeAmount1_ = exactIn\n                ? cumulativeAmount1(\n                    roundedTick - tickSpacing, totalLiquidity, tickSpacing, minTick, length, alphaX96, weightCarpet\n                )\n                : cumulativeAmount1(roundedTick, totalLiquidity, tickSpacing, minTick, length, alphaX96, weightCarpet);\n\n            // compute the cumulative amount of the complementary token\n            // below is an illustration\n            // exactIn:\n            //         cum\n            //       \u251c\u2500\u2500\u2500\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //       \u2502\n            //       \u25bc\n            //      rick\n            // exactOut:\n            //           cum\n            //          \u251c\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //          \u2502\n            //          \u25bc\n            //         rick + tickSpacing\n            cumulativeAmount0_ = exactIn\n                ? cumulativeAmount0(roundedTick, totalLiquidity, tickSpacing, minTick, length, alphaX96, weightCarpet)\n                : cumulativeAmount0(\n                    roundedTick + tickSpacing, totalLiquidity, tickSpacing, minTick, length, alphaX96, weightCarpet\n                );\n\n            // compute liquidity of the rounded tick that will handle the remainder of the swap\n            // below is an illustration of the liquidity of the rounded tick that will handle the remainder of the swap\n            //       liq\n            //       \u251c\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //       \u2502\n            //       \u25bc\n            //      rick\n            swapLiquidity = (\n                liquidityDensityX96(roundedTick, tickSpacing, minTick, length, alphaX96, weightCarpet) * totalLiquidity\n            ) >> 96;\n        }\n    }\n\n    function getCarpetedLiquidity(\n        uint256 totalLiquidity,\n        int24 tickSpacing,\n        int24 minTick,\n        int24 length,\n        uint256 weightCarpet\n    )\n        internal\n        pure\n        returns (\n            uint256 leftCarpetLiquidity,\n            uint256 mainLiquidity,\n            uint256 rightCarpetLiquidity,\n            int24 minUsableTick,\n            int24 maxUsableTick\n        )\n    {\n        (minUsableTick, maxUsableTick) = (TickMath.minUsableTick(tickSpacing), TickMath.maxUsableTick(tickSpacing));\n        int24 numRoundedTicksCarpeted = (maxUsableTick - minUsableTick) / tickSpacing - length;\n        if (numRoundedTicksCarpeted <= 0) {\n            return (0, totalLiquidity, 0, minUsableTick, maxUsableTick);\n        }\n        mainLiquidity = totalLiquidity.mulWad(WAD - weightCarpet);\n        uint256 carpetLiquidity = totalLiquidity - mainLiquidity;\n        uint24 rightCarpetNumRoundedTicks = uint24((maxUsableTick - minTick) / tickSpacing - length);\n        rightCarpetLiquidity = carpetLiquidity.mulDiv(rightCarpetNumRoundedTicks, uint24(numRoundedTicksCarpeted));\n        leftCarpetLiquidity = carpetLiquidity - rightCarpetLiquidity;\n    }\n\n    /// @return minTick The minimum rounded tick of the distribution\n    /// @return length The length of the geometric distribution in number of rounded ticks\n    /// @return alphaX96 The alpha of the geometric distribution\n    /// @return weightCarpet The weight of the carpet distribution, 18 decimals. 32 bits means the max weight is 4.295e-9.\n    /// @return shiftMode The shift mode of the distribution\n    function decodeParams(int24 twapTick, int24 tickSpacing, bytes32 ldfParams)\n        internal\n        pure\n        returns (int24 minTick, int24 length, uint256 alphaX96, uint256 weightCarpet, ShiftMode shiftMode)\n    {\n        // | shiftMode - 1 byte | minTickOrOffset - 3 bytes | length - 2 bytes | alpha - 4 bytes | weightCarpet - 4 bytes |\n        (minTick, length, alphaX96, shiftMode) = LibGeometricDistribution.decodeParams(twapTick, tickSpacing, ldfParams);\n        weightCarpet = uint32(bytes4(ldfParams << 80));\n    }\n\n    function isValidParams(int24 tickSpacing, uint24 twapSecondsAgo, bytes32 ldfParams) internal pure returns (bool) {\n        // | shiftMode - 1 byte | minTickOrOffset - 3 bytes | length - 2 bytes | alpha - 4 bytes | weightCarpet - 4 bytes |\n        int24 length = int24(int16(uint16(bytes2(ldfParams << 32))));\n        uint32 alpha = uint32(bytes4(ldfParams << 48));\n        uint32 weightCarpet = uint32(bytes4(ldfParams << 80));\n\n        return LibGeometricDistribution.isValidParams(tickSpacing, twapSecondsAgo, ldfParams) && weightCarpet != 0\n            && checkMinLiquidityDensity(tickSpacing, length, alpha, weightCarpet);\n    }\n}\n"}, "src/interfaces/ILiquidityDensityFunction.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\npragma abicoder v2;\n\nimport {PoolKey} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\n\n/// @title ILiquidityDensityFunction\n/// @author zefram.eth\n/// @notice Interface for liquidity density functions (LDFs) that dictate how liquidity is distributed over a pool's rounded ticks (each with `tickSpacing` ticks).\n/// Each rounded tick is identified by its leftmost tick, which is a multiple of `tickSpacing`. The liquidity density of all rounded ticks should add up to 1, similar to probability density functions (PDFs).\n/// Also contains functions for efficiently computing the cumulative amount of tokens in a consecutive range of rounded ticks, as well as their inverse functions. These are essential for computing swaps.\n/// Enables arbitrary liquidity shapes, shifting liquidity across ticks, and switching from one liquidity shape to another.\ninterface ILiquidityDensityFunction {\n    /// @notice Queries the liquidity density function for the given pool and rounded tick.\n    /// Returns the density of the rounded tick, cumulative token densities at adjacent ticks, and state relevant info.\n    /// @param key The key of the Uniswap v4 pool\n    /// @param roundedTick The rounded tick to query\n    /// @param twapTick The TWAP tick. Is 0 if `twapSecondsAgo` is 0. It's up to `isValidParams` to ensure `twapSecondsAgo != 0` if the LDF uses the TWAP.\n    /// @param spotPriceTick The spot price tick.\n    /// @param ldfParams The parameters for the liquidity density function\n    /// @param ldfState The current state of the liquidity density function\n    /// @return liquidityDensityX96 The density of the rounded tick, scaled by Q96\n    /// @return cumulativeAmount0DensityX96 The cumulative token0 density in rounded ticks [roundedTick + tickSpacing, maxUsableTick], scaled by Q96\n    /// @return cumulativeAmount1DensityX96 The cumulative token1 density in rounded ticks [minUsableTick, roundedTick - tickSpacing], scaled by Q96\n    /// @return newLdfState The new state of the liquidity density function\n    /// @return shouldSurge Whether the pool should surge. Usually corresponds to whether the LDF has shifted / changed shape.\n    function query(\n        PoolKey calldata key,\n        int24 roundedTick,\n        int24 twapTick,\n        int24 spotPriceTick,\n        bytes32 ldfParams,\n        bytes32 ldfState\n    )\n        external\n        view\n        returns (\n            uint256 liquidityDensityX96,\n            uint256 cumulativeAmount0DensityX96,\n            uint256 cumulativeAmount1DensityX96,\n            bytes32 newLdfState,\n            bool shouldSurge\n        );\n\n    /// @notice Aggregates LDF queries used during a swap.\n    /// @dev A Bunni swap uses the inverseCumulativeAmount function to compute the rounded tick for which the cumulativeAmount is the closest to `inverseCumulativeAmountInput`\n    /// and <= `inverseCumulativeAmountInput`. This rounded tick is the starting point for swapping the remaining tokens, which is done via Uniswap math (not done in this function though).\n    /// @param key The key of the Uniswap v4 pool\n    /// @param inverseCumulativeAmountInput The input to the inverseCumulativeAmount function\n    /// @param totalLiquidity The total liquidity in the pool\n    /// @param zeroForOne Whether the input token is token0\n    /// @param exactIn Whether it's an exact input swap or an exact output swap\n    /// @param twapTick The TWAP tick. Is 0 if `twapSecondsAgo` is 0. It's up to `isValidParams` to ensure `twapSecondsAgo != 0` if the LDF uses the TWAP.\n    /// @param spotPriceTick The spot price tick.\n    /// @param ldfParams The parameters for the liquidity density function\n    /// @param ldfState The current state of the liquidity density function\n    /// @return success Whether the swap computation was successful\n    /// @return roundedTick The rounded tick to start the remainder swap from\n    /// @return cumulativeAmount0_ The cumulative amount of token0 to the right of the starting tick of the Uniswap swap\n    /// @return cumulativeAmount1_ The cumulative amount of token1 to the left of the starting tick of the Uniswap swap\n    /// @return swapLiquidity The liquidity used for the remainder swap\n    function computeSwap(\n        PoolKey calldata key,\n        uint256 inverseCumulativeAmountInput,\n        uint256 totalLiquidity,\n        bool zeroForOne,\n        bool exactIn,\n        int24 twapTick,\n        int24 spotPriceTick,\n        bytes32 ldfParams,\n        bytes32 ldfState\n    )\n        external\n        view\n        returns (\n            bool success,\n            int24 roundedTick,\n            uint256 cumulativeAmount0_,\n            uint256 cumulativeAmount1_,\n            uint256 swapLiquidity\n        );\n\n    /// @notice Computes the cumulative amount of token0 in the rounded ticks [roundedTick, maxUsableTick].\n    /// @param key The key of the Uniswap v4 pool\n    /// @param roundedTick The rounded tick to query\n    /// @param totalLiquidity The total liquidity in the pool\n    /// @param twapTick The TWAP tick. Is 0 if `twapSecondsAgo` is 0. It's up to `isValidParams` to ensure `twapSecondsAgo != 0` if the LDF uses the TWAP.\n    /// @param spotPriceTick The spot price tick.\n    /// @param ldfParams The parameters for the liquidity density function\n    /// @param ldfState The current state of the liquidity density function\n    /// @return The cumulative amount of token0 in the rounded ticks [roundedTick, maxUsableTick]\n    function cumulativeAmount0(\n        PoolKey calldata key,\n        int24 roundedTick,\n        uint256 totalLiquidity,\n        int24 twapTick,\n        int24 spotPriceTick,\n        bytes32 ldfParams,\n        bytes32 ldfState\n    ) external view returns (uint256);\n\n    /// @notice Computes the cumulative amount of token1 in the rounded ticks [minUsableTick, roundedTick].\n    /// @param key The key of the Uniswap v4 pool\n    /// @param roundedTick The rounded tick to query\n    /// @param totalLiquidity The total liquidity in the pool\n    /// @param twapTick The TWAP tick. Is 0 if `twapSecondsAgo` is 0. It's up to `isValidParams` to ensure `twapSecondsAgo != 0` if the LDF uses the TWAP.\n    /// @param spotPriceTick The spot price tick.\n    /// @param ldfParams The parameters for the liquidity density function\n    /// @param ldfState The current state of the liquidity density function\n    /// @return The cumulative amount of token1 in the rounded ticks [minUsableTick, roundedTick]\n    function cumulativeAmount1(\n        PoolKey calldata key,\n        int24 roundedTick,\n        uint256 totalLiquidity,\n        int24 twapTick,\n        int24 spotPriceTick,\n        bytes32 ldfParams,\n        bytes32 ldfState\n    ) external view returns (uint256);\n\n    /// @notice Checks if the given LDF parameters are valid.\n    /// @param key The key of the Uniswap v4 pool\n    /// @param twapSecondsAgo The time window for the TWAP\n    /// @param ldfParams The parameters for the liquidity density function\n    /// @return Whether the parameters are valid\n    function isValidParams(PoolKey calldata key, uint24 twapSecondsAgo, bytes32 ldfParams)\n        external\n        view\n        returns (bool);\n}\n"}, "lib/v4-core/src/types/Currency.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IERC20Minimal} from \"../interfaces/external/IERC20Minimal.sol\";\nimport {CustomRevert} from \"../libraries/CustomRevert.sol\";\n\ntype Currency is address;\n\nusing {greaterThan as >, lessThan as <, greaterThanOrEqualTo as >=, equals as ==} for Currency global;\nusing CurrencyLibrary for Currency global;\n\nfunction equals(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) == Currency.unwrap(other);\n}\n\nfunction greaterThan(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) > Currency.unwrap(other);\n}\n\nfunction lessThan(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) < Currency.unwrap(other);\n}\n\nfunction greaterThanOrEqualTo(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) >= Currency.unwrap(other);\n}\n\n/// @title CurrencyLibrary\n/// @dev This library allows for transferring and holding native tokens and ERC20 tokens\nlibrary CurrencyLibrary {\n    /// @notice Additional context for ERC-7751 wrapped error when a native transfer fails\n    error NativeTransferFailed();\n\n    /// @notice Additional context for ERC-7751 wrapped error when an ERC20 transfer fails\n    error ERC20TransferFailed();\n\n    /// @notice A constant to represent the native currency\n    Currency public constant ADDRESS_ZERO = Currency.wrap(address(0));\n\n    function transfer(Currency currency, address to, uint256 amount) internal {\n        // altered from https://github.com/transmissions11/solmate/blob/44a9963d4c78111f77caa0e65d677b8b46d6f2e6/src/utils/SafeTransferLib.sol\n        // modified custom error selectors\n\n        bool success;\n        if (currency.isAddressZero()) {\n            assembly (\"memory-safe\") {\n                // Transfer the ETH and revert if it fails.\n                success := call(gas(), to, amount, 0, 0, 0, 0)\n            }\n            // revert with NativeTransferFailed, containing the bubbled up error as an argument\n            if (!success) {\n                CustomRevert.bubbleUpAndRevertWith(to, bytes4(0), NativeTransferFailed.selector);\n            }\n        } else {\n            assembly (\"memory-safe\") {\n                // Get a pointer to some free memory.\n                let fmp := mload(0x40)\n\n                // Write the abi-encoded calldata into memory, beginning with the function selector.\n                mstore(fmp, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n                mstore(add(fmp, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n                mstore(add(fmp, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n                success :=\n                    and(\n                        // Set success to whether the call reverted, if not we check it either\n                        // returned exactly 1 (can't just be non-zero data), or had no return data.\n                        or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                        // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                        // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                        // Counterintuitively, this call must be positioned second to the or() call in the\n                        // surrounding and() call or else returndatasize() will be zero during the computation.\n                        call(gas(), currency, 0, fmp, 68, 0, 32)\n                    )\n\n                // Now clean the memory we used\n                mstore(fmp, 0) // 4 byte `selector` and 28 bytes of `to` were stored here\n                mstore(add(fmp, 0x20), 0) // 4 bytes of `to` and 28 bytes of `amount` were stored here\n                mstore(add(fmp, 0x40), 0) // 4 bytes of `amount` were stored here\n            }\n            // revert with ERC20TransferFailed, containing the bubbled up error as an argument\n            if (!success) {\n                CustomRevert.bubbleUpAndRevertWith(\n                    Currency.unwrap(currency), IERC20Minimal.transfer.selector, ERC20TransferFailed.selector\n                );\n            }\n        }\n    }\n\n    function balanceOfSelf(Currency currency) internal view returns (uint256) {\n        if (currency.isAddressZero()) {\n            return address(this).balance;\n        } else {\n            return IERC20Minimal(Currency.unwrap(currency)).balanceOf(address(this));\n        }\n    }\n\n    function balanceOf(Currency currency, address owner) internal view returns (uint256) {\n        if (currency.isAddressZero()) {\n            return owner.balance;\n        } else {\n            return IERC20Minimal(Currency.unwrap(currency)).balanceOf(owner);\n        }\n    }\n\n    function isAddressZero(Currency currency) internal pure returns (bool) {\n        return Currency.unwrap(currency) == Currency.unwrap(ADDRESS_ZERO);\n    }\n\n    function toId(Currency currency) internal pure returns (uint256) {\n        return uint160(Currency.unwrap(currency));\n    }\n\n    // If the upper 12 bytes are non-zero, they will be zero-ed out\n    // Therefore, fromId() and toId() are not inverses of each other\n    function fromId(uint256 id) internal pure returns (Currency) {\n        return Currency.wrap(address(uint160(id)));\n    }\n}\n"}, "lib/v4-core/src/types/PoolKey.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Currency} from \"./Currency.sol\";\nimport {IHooks} from \"../interfaces/IHooks.sol\";\nimport {PoolIdLibrary} from \"./PoolId.sol\";\n\nusing PoolIdLibrary for PoolKey global;\n\n/// @notice Returns the key for identifying a pool\nstruct PoolKey {\n    /// @notice The lower currency of the pool, sorted numerically\n    Currency currency0;\n    /// @notice The higher currency of the pool, sorted numerically\n    Currency currency1;\n    /// @notice The pool LP fee, capped at 1_000_000. If the highest bit is 1, the pool has a dynamic fee and must be exactly equal to 0x800000\n    uint24 fee;\n    /// @notice Ticks that involve positions must be a multiple of tick spacing\n    int24 tickSpacing;\n    /// @notice The hooks of the pool\n    IHooks hooks;\n}\n"}, "lib/v4-core/src/interfaces/IHooks.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {BalanceDelta} from \"../types/BalanceDelta.sol\";\nimport {IPoolManager} from \"./IPoolManager.sol\";\nimport {BeforeSwapDelta} from \"../types/BeforeSwapDelta.sol\";\n\n/// @notice V4 decides whether to invoke specific hooks by inspecting the least significant bits\n/// of the address that the hooks contract is deployed to.\n/// For example, a hooks contract deployed to address: 0x0000000000000000000000000000000000002400\n/// has the lowest bits '10 0100 0000 0000' which would cause the 'before initialize' and 'after add liquidity' hooks to be used.\n/// See the Hooks library for the full spec.\n/// @dev Should only be callable by the v4 PoolManager.\ninterface IHooks {\n    /// @notice The hook called before the state of a pool is initialized\n    /// @param sender The initial msg.sender for the initialize call\n    /// @param key The key for the pool being initialized\n    /// @param sqrtPriceX96 The sqrt(price) of the pool as a Q64.96\n    /// @return bytes4 The function selector for the hook\n    function beforeInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96) external returns (bytes4);\n\n    /// @notice The hook called after the state of a pool is initialized\n    /// @param sender The initial msg.sender for the initialize call\n    /// @param key The key for the pool being initialized\n    /// @param sqrtPriceX96 The sqrt(price) of the pool as a Q64.96\n    /// @param tick The current tick after the state of a pool is initialized\n    /// @return bytes4 The function selector for the hook\n    function afterInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96, int24 tick)\n        external\n        returns (bytes4);\n\n    /// @notice The hook called before liquidity is added\n    /// @param sender The initial msg.sender for the add liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for adding liquidity\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidity provider to be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeAddLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after liquidity is added\n    /// @param sender The initial msg.sender for the add liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for adding liquidity\n    /// @param delta The caller's balance delta after adding liquidity; the sum of principal delta, fees accrued, and hook delta\n    /// @param feesAccrued The fees accrued since the last time fees were collected from this position\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidity provider to be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    /// @return BalanceDelta The hook's delta in token0 and token1. Positive: the hook is owed/took currency, negative: the hook owes/sent currency\n    function afterAddLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        BalanceDelta delta,\n        BalanceDelta feesAccrued,\n        bytes calldata hookData\n    ) external returns (bytes4, BalanceDelta);\n\n    /// @notice The hook called before liquidity is removed\n    /// @param sender The initial msg.sender for the remove liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for removing liquidity\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidity provider to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeRemoveLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after liquidity is removed\n    /// @param sender The initial msg.sender for the remove liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for removing liquidity\n    /// @param delta The caller's balance delta after removing liquidity; the sum of principal delta, fees accrued, and hook delta\n    /// @param feesAccrued The fees accrued since the last time fees were collected from this position\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidity provider to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    /// @return BalanceDelta The hook's delta in token0 and token1. Positive: the hook is owed/took currency, negative: the hook owes/sent currency\n    function afterRemoveLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        BalanceDelta delta,\n        BalanceDelta feesAccrued,\n        bytes calldata hookData\n    ) external returns (bytes4, BalanceDelta);\n\n    /// @notice The hook called before a swap\n    /// @param sender The initial msg.sender for the swap call\n    /// @param key The key for the pool\n    /// @param params The parameters for the swap\n    /// @param hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    /// @return BeforeSwapDelta The hook's delta in specified and unspecified currencies. Positive: the hook is owed/took currency, negative: the hook owes/sent currency\n    /// @return uint24 Optionally override the lp fee, only used if three conditions are met: 1. the Pool has a dynamic fee, 2. the value's 2nd highest bit is set (23rd bit, 0x400000), and 3. the value is less than or equal to the maximum fee (1 million)\n    function beforeSwap(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        bytes calldata hookData\n    ) external returns (bytes4, BeforeSwapDelta, uint24);\n\n    /// @notice The hook called after a swap\n    /// @param sender The initial msg.sender for the swap call\n    /// @param key The key for the pool\n    /// @param params The parameters for the swap\n    /// @param delta The amount owed to the caller (positive) or owed to the pool (negative)\n    /// @param hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    /// @return int128 The hook's delta in unspecified currency. Positive: the hook is owed/took currency, negative: the hook owes/sent currency\n    function afterSwap(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        BalanceDelta delta,\n        bytes calldata hookData\n    ) external returns (bytes4, int128);\n\n    /// @notice The hook called before donate\n    /// @param sender The initial msg.sender for the donate call\n    /// @param key The key for the pool\n    /// @param amount0 The amount of token0 being donated\n    /// @param amount1 The amount of token1 being donated\n    /// @param hookData Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeDonate(\n        address sender,\n        PoolKey calldata key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after donate\n    /// @param sender The initial msg.sender for the donate call\n    /// @param key The key for the pool\n    /// @param amount0 The amount of token0 being donated\n    /// @param amount1 The amount of token1 being donated\n    /// @param hookData Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function afterDonate(\n        address sender,\n        PoolKey calldata key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external returns (bytes4);\n}\n"}, "lib/v4-core/src/interfaces/external/IERC6909Claims.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Interface for claims over a contract balance, wrapped as a ERC6909\ninterface IERC6909Claims {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OperatorSet(address indexed owner, address indexed operator, bool approved);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id, uint256 amount);\n\n    event Transfer(address caller, address indexed from, address indexed to, uint256 indexed id, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                                 FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Owner balance of an id.\n    /// @param owner The address of the owner.\n    /// @param id The id of the token.\n    /// @return amount The balance of the token.\n    function balanceOf(address owner, uint256 id) external view returns (uint256 amount);\n\n    /// @notice Spender allowance of an id.\n    /// @param owner The address of the owner.\n    /// @param spender The address of the spender.\n    /// @param id The id of the token.\n    /// @return amount The allowance of the token.\n    function allowance(address owner, address spender, uint256 id) external view returns (uint256 amount);\n\n    /// @notice Checks if a spender is approved by an owner as an operator\n    /// @param owner The address of the owner.\n    /// @param spender The address of the spender.\n    /// @return approved The approval status.\n    function isOperator(address owner, address spender) external view returns (bool approved);\n\n    /// @notice Transfers an amount of an id from the caller to a receiver.\n    /// @param receiver The address of the receiver.\n    /// @param id The id of the token.\n    /// @param amount The amount of the token.\n    /// @return bool True, always, unless the function reverts\n    function transfer(address receiver, uint256 id, uint256 amount) external returns (bool);\n\n    /// @notice Transfers an amount of an id from a sender to a receiver.\n    /// @param sender The address of the sender.\n    /// @param receiver The address of the receiver.\n    /// @param id The id of the token.\n    /// @param amount The amount of the token.\n    /// @return bool True, always, unless the function reverts\n    function transferFrom(address sender, address receiver, uint256 id, uint256 amount) external returns (bool);\n\n    /// @notice Approves an amount of an id to a spender.\n    /// @param spender The address of the spender.\n    /// @param id The id of the token.\n    /// @param amount The amount of the token.\n    /// @return bool True, always\n    function approve(address spender, uint256 id, uint256 amount) external returns (bool);\n\n    /// @notice Sets or removes an operator for the caller.\n    /// @param operator The address of the operator.\n    /// @param approved The approval status.\n    /// @return bool True, always\n    function setOperator(address operator, bool approved) external returns (bool);\n}\n"}, "lib/v4-core/src/interfaces/IProtocolFees.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Currency} from \"../types/Currency.sol\";\nimport {PoolId} from \"../types/PoolId.sol\";\nimport {PoolKey} from \"../types/PoolKey.sol\";\n\n/// @notice Interface for all protocol-fee related functions in the pool manager\ninterface IProtocolFees {\n    /// @notice Thrown when protocol fee is set too high\n    error ProtocolFeeTooLarge(uint24 fee);\n\n    /// @notice Thrown when collectProtocolFees or setProtocolFee is not called by the controller.\n    error InvalidCaller();\n\n    /// @notice Thrown when collectProtocolFees is attempted on a token that is synced.\n    error ProtocolFeeCurrencySynced();\n\n    /// @notice Emitted when the protocol fee controller address is updated in setProtocolFeeController.\n    event ProtocolFeeControllerUpdated(address indexed protocolFeeController);\n\n    /// @notice Emitted when the protocol fee is updated for a pool.\n    event ProtocolFeeUpdated(PoolId indexed id, uint24 protocolFee);\n\n    /// @notice Given a currency address, returns the protocol fees accrued in that currency\n    /// @param currency The currency to check\n    /// @return amount The amount of protocol fees accrued in the currency\n    function protocolFeesAccrued(Currency currency) external view returns (uint256 amount);\n\n    /// @notice Sets the protocol fee for the given pool\n    /// @param key The key of the pool to set a protocol fee for\n    /// @param newProtocolFee The fee to set\n    function setProtocolFee(PoolKey memory key, uint24 newProtocolFee) external;\n\n    /// @notice Sets the protocol fee controller\n    /// @param controller The new protocol fee controller\n    function setProtocolFeeController(address controller) external;\n\n    /// @notice Collects the protocol fees for a given recipient and currency, returning the amount collected\n    /// @dev This will revert if the contract is unlocked\n    /// @param recipient The address to receive the protocol fees\n    /// @param currency The currency to withdraw\n    /// @param amount The amount of currency to withdraw\n    /// @return amountCollected The amount of currency successfully withdrawn\n    function collectProtocolFees(address recipient, Currency currency, uint256 amount)\n        external\n        returns (uint256 amountCollected);\n\n    /// @notice Returns the current protocol fee controller address\n    /// @return address The current protocol fee controller address\n    function protocolFeeController() external view returns (address);\n}\n"}, "lib/v4-core/src/types/BalanceDelta.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {SafeCast} from \"../libraries/SafeCast.sol\";\n\n/// @dev Two `int128` values packed into a single `int256` where the upper 128 bits represent the amount0\n/// and the lower 128 bits represent the amount1.\ntype BalanceDelta is int256;\n\nusing {add as +, sub as -, eq as ==, neq as !=} for BalanceDelta global;\nusing BalanceDeltaLibrary for BalanceDelta global;\nusing SafeCast for int256;\n\nfunction toBalanceDelta(int128 _amount0, int128 _amount1) pure returns (BalanceDelta balanceDelta) {\n    assembly (\"memory-safe\") {\n        balanceDelta := or(shl(128, _amount0), and(sub(shl(128, 1), 1), _amount1))\n    }\n}\n\nfunction add(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta) {\n    int256 res0;\n    int256 res1;\n    assembly (\"memory-safe\") {\n        let a0 := sar(128, a)\n        let a1 := signextend(15, a)\n        let b0 := sar(128, b)\n        let b1 := signextend(15, b)\n        res0 := add(a0, b0)\n        res1 := add(a1, b1)\n    }\n    return toBalanceDelta(res0.toInt128(), res1.toInt128());\n}\n\nfunction sub(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta) {\n    int256 res0;\n    int256 res1;\n    assembly (\"memory-safe\") {\n        let a0 := sar(128, a)\n        let a1 := signextend(15, a)\n        let b0 := sar(128, b)\n        let b1 := signextend(15, b)\n        res0 := sub(a0, b0)\n        res1 := sub(a1, b1)\n    }\n    return toBalanceDelta(res0.toInt128(), res1.toInt128());\n}\n\nfunction eq(BalanceDelta a, BalanceDelta b) pure returns (bool) {\n    return BalanceDelta.unwrap(a) == BalanceDelta.unwrap(b);\n}\n\nfunction neq(BalanceDelta a, BalanceDelta b) pure returns (bool) {\n    return BalanceDelta.unwrap(a) != BalanceDelta.unwrap(b);\n}\n\n/// @notice Library for getting the amount0 and amount1 deltas from the BalanceDelta type\nlibrary BalanceDeltaLibrary {\n    /// @notice A BalanceDelta of 0\n    BalanceDelta public constant ZERO_DELTA = BalanceDelta.wrap(0);\n\n    function amount0(BalanceDelta balanceDelta) internal pure returns (int128 _amount0) {\n        assembly (\"memory-safe\") {\n            _amount0 := sar(128, balanceDelta)\n        }\n    }\n\n    function amount1(BalanceDelta balanceDelta) internal pure returns (int128 _amount1) {\n        assembly (\"memory-safe\") {\n            _amount1 := signextend(15, balanceDelta)\n        }\n    }\n}\n"}, "lib/v4-core/src/types/PoolId.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {PoolKey} from \"./PoolKey.sol\";\n\ntype PoolId is bytes32;\n\n/// @notice Library for computing the ID of a pool\nlibrary PoolIdLibrary {\n    /// @notice Returns value equal to keccak256(abi.encode(poolKey))\n    function toId(PoolKey memory poolKey) internal pure returns (PoolId poolId) {\n        assembly (\"memory-safe\") {\n            // 0xa0 represents the total size of the poolKey struct (5 slots of 32 bytes)\n            poolId := keccak256(poolKey, 0xa0)\n        }\n    }\n}\n"}, "lib/v4-core/src/interfaces/IExtsload.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Interface for functions to access any storage slot in a contract\ninterface IExtsload {\n    /// @notice Called by external contracts to access granular pool state\n    /// @param slot Key of slot to sload\n    /// @return value The value of the slot as bytes32\n    function extsload(bytes32 slot) external view returns (bytes32 value);\n\n    /// @notice Called by external contracts to access granular pool state\n    /// @param startSlot Key of slot to start sloading from\n    /// @param nSlots Number of slots to load into return value\n    /// @return values List of loaded values.\n    function extsload(bytes32 startSlot, uint256 nSlots) external view returns (bytes32[] memory values);\n\n    /// @notice Called by external contracts to access sparse pool state\n    /// @param slots List of slots to SLOAD from.\n    /// @return values List of loaded values.\n    function extsload(bytes32[] calldata slots) external view returns (bytes32[] memory values);\n}\n"}, "lib/v4-core/src/interfaces/IExttload.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Interface for functions to access any transient storage slot in a contract\ninterface IExttload {\n    /// @notice Called by external contracts to access transient storage of the contract\n    /// @param slot Key of slot to tload\n    /// @return value The value of the slot as bytes32\n    function exttload(bytes32 slot) external view returns (bytes32 value);\n\n    /// @notice Called by external contracts to access sparse transient pool state\n    /// @param slots List of slots to tload\n    /// @return values List of loaded values\n    function exttload(bytes32[] calldata slots) external view returns (bytes32[] memory values);\n}\n"}, "lib/v4-core/src/libraries/CustomRevert.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title Library for reverting with custom errors efficiently\n/// @notice Contains functions for reverting with custom errors with different argument types efficiently\n/// @dev To use this library, declare `using CustomRevert for bytes4;` and replace `revert CustomError()` with\n/// `CustomError.selector.revertWith()`\n/// @dev The functions may tamper with the free memory pointer but it is fine since the call context is exited immediately\nlibrary CustomRevert {\n    /// @dev ERC-7751 error for wrapping bubbled up reverts\n    error WrappedError(address target, bytes4 selector, bytes reason, bytes details);\n\n    /// @dev Reverts with the selector of a custom error in the scratch space\n    function revertWith(bytes4 selector) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            revert(0, 0x04)\n        }\n    }\n\n    /// @dev Reverts with a custom error with an address argument in the scratch space\n    function revertWith(bytes4 selector, address addr) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, and(addr, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(0, 0x24)\n        }\n    }\n\n    /// @dev Reverts with a custom error with an int24 argument in the scratch space\n    function revertWith(bytes4 selector, int24 value) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, signextend(2, value))\n            revert(0, 0x24)\n        }\n    }\n\n    /// @dev Reverts with a custom error with a uint160 argument in the scratch space\n    function revertWith(bytes4 selector, uint160 value) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, and(value, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(0, 0x24)\n        }\n    }\n\n    /// @dev Reverts with a custom error with two int24 arguments\n    function revertWith(bytes4 selector, int24 value1, int24 value2) internal pure {\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(fmp, selector)\n            mstore(add(fmp, 0x04), signextend(2, value1))\n            mstore(add(fmp, 0x24), signextend(2, value2))\n            revert(fmp, 0x44)\n        }\n    }\n\n    /// @dev Reverts with a custom error with two uint160 arguments\n    function revertWith(bytes4 selector, uint160 value1, uint160 value2) internal pure {\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(fmp, selector)\n            mstore(add(fmp, 0x04), and(value1, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(add(fmp, 0x24), and(value2, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(fmp, 0x44)\n        }\n    }\n\n    /// @dev Reverts with a custom error with two address arguments\n    function revertWith(bytes4 selector, address value1, address value2) internal pure {\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(fmp, selector)\n            mstore(add(fmp, 0x04), and(value1, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(add(fmp, 0x24), and(value2, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(fmp, 0x44)\n        }\n    }\n\n    /// @notice bubble up the revert message returned by a call and revert with a wrapped ERC-7751 error\n    /// @dev this method can be vulnerable to revert data bombs\n    function bubbleUpAndRevertWith(\n        address revertingContract,\n        bytes4 revertingFunctionSelector,\n        bytes4 additionalContext\n    ) internal pure {\n        bytes4 wrappedErrorSelector = WrappedError.selector;\n        assembly (\"memory-safe\") {\n            // Ensure the size of the revert data is a multiple of 32 bytes\n            let encodedDataSize := mul(div(add(returndatasize(), 31), 32), 32)\n\n            let fmp := mload(0x40)\n\n            // Encode wrapped error selector, address, function selector, offset, additional context, size, revert reason\n            mstore(fmp, wrappedErrorSelector)\n            mstore(add(fmp, 0x04), and(revertingContract, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(\n                add(fmp, 0x24),\n                and(revertingFunctionSelector, 0xffffffff00000000000000000000000000000000000000000000000000000000)\n            )\n            // offset revert reason\n            mstore(add(fmp, 0x44), 0x80)\n            // offset additional context\n            mstore(add(fmp, 0x64), add(0xa0, encodedDataSize))\n            // size revert reason\n            mstore(add(fmp, 0x84), returndatasize())\n            // revert reason\n            returndatacopy(add(fmp, 0xa4), 0, returndatasize())\n            // size additional context\n            mstore(add(fmp, add(0xa4, encodedDataSize)), 0x04)\n            // additional context\n            mstore(\n                add(fmp, add(0xc4, encodedDataSize)),\n                and(additionalContext, 0xffffffff00000000000000000000000000000000000000000000000000000000)\n            )\n            revert(fmp, add(0xe4, encodedDataSize))\n        }\n    }\n}\n"}, "lib/solady/src/utils/SafeCastLib.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Safe integer casting library that reverts on overflow.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeCastLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\n/// @dev Optimized for runtime gas for very high number of optimizer runs (i.e. >= 1000000).\nlibrary SafeCastLib {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Unable to cast to the target type due to overflow.\n    error Overflow();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*          UNSIGNED INTEGER SAFE CASTING OPERATIONS          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Casts `x` to a uint8. Reverts on overflow.\n    function toUint8(uint256 x) internal pure returns (uint8) {\n        if (x >= 1 << 8) _revertOverflow();\n        return uint8(x);\n    }\n\n    /// @dev Casts `x` to a uint16. Reverts on overflow.\n    function toUint16(uint256 x) internal pure returns (uint16) {\n        if (x >= 1 << 16) _revertOverflow();\n        return uint16(x);\n    }\n\n    /// @dev Casts `x` to a uint24. Reverts on overflow.\n    function toUint24(uint256 x) internal pure returns (uint24) {\n        if (x >= 1 << 24) _revertOverflow();\n        return uint24(x);\n    }\n\n    /// @dev Casts `x` to a uint32. Reverts on overflow.\n    function toUint32(uint256 x) internal pure returns (uint32) {\n        if (x >= 1 << 32) _revertOverflow();\n        return uint32(x);\n    }\n\n    /// @dev Casts `x` to a uint40. Reverts on overflow.\n    function toUint40(uint256 x) internal pure returns (uint40) {\n        if (x >= 1 << 40) _revertOverflow();\n        return uint40(x);\n    }\n\n    /// @dev Casts `x` to a uint48. Reverts on overflow.\n    function toUint48(uint256 x) internal pure returns (uint48) {\n        if (x >= 1 << 48) _revertOverflow();\n        return uint48(x);\n    }\n\n    /// @dev Casts `x` to a uint56. Reverts on overflow.\n    function toUint56(uint256 x) internal pure returns (uint56) {\n        if (x >= 1 << 56) _revertOverflow();\n        return uint56(x);\n    }\n\n    /// @dev Casts `x` to a uint64. Reverts on overflow.\n    function toUint64(uint256 x) internal pure returns (uint64) {\n        if (x >= 1 << 64) _revertOverflow();\n        return uint64(x);\n    }\n\n    /// @dev Casts `x` to a uint72. Reverts on overflow.\n    function toUint72(uint256 x) internal pure returns (uint72) {\n        if (x >= 1 << 72) _revertOverflow();\n        return uint72(x);\n    }\n\n    /// @dev Casts `x` to a uint80. Reverts on overflow.\n    function toUint80(uint256 x) internal pure returns (uint80) {\n        if (x >= 1 << 80) _revertOverflow();\n        return uint80(x);\n    }\n\n    /// @dev Casts `x` to a uint88. Reverts on overflow.\n    function toUint88(uint256 x) internal pure returns (uint88) {\n        if (x >= 1 << 88) _revertOverflow();\n        return uint88(x);\n    }\n\n    /// @dev Casts `x` to a uint96. Reverts on overflow.\n    function toUint96(uint256 x) internal pure returns (uint96) {\n        if (x >= 1 << 96) _revertOverflow();\n        return uint96(x);\n    }\n\n    /// @dev Casts `x` to a uint104. Reverts on overflow.\n    function toUint104(uint256 x) internal pure returns (uint104) {\n        if (x >= 1 << 104) _revertOverflow();\n        return uint104(x);\n    }\n\n    /// @dev Casts `x` to a uint112. Reverts on overflow.\n    function toUint112(uint256 x) internal pure returns (uint112) {\n        if (x >= 1 << 112) _revertOverflow();\n        return uint112(x);\n    }\n\n    /// @dev Casts `x` to a uint120. Reverts on overflow.\n    function toUint120(uint256 x) internal pure returns (uint120) {\n        if (x >= 1 << 120) _revertOverflow();\n        return uint120(x);\n    }\n\n    /// @dev Casts `x` to a uint128. Reverts on overflow.\n    function toUint128(uint256 x) internal pure returns (uint128) {\n        if (x >= 1 << 128) _revertOverflow();\n        return uint128(x);\n    }\n\n    /// @dev Casts `x` to a uint136. Reverts on overflow.\n    function toUint136(uint256 x) internal pure returns (uint136) {\n        if (x >= 1 << 136) _revertOverflow();\n        return uint136(x);\n    }\n\n    /// @dev Casts `x` to a uint144. Reverts on overflow.\n    function toUint144(uint256 x) internal pure returns (uint144) {\n        if (x >= 1 << 144) _revertOverflow();\n        return uint144(x);\n    }\n\n    /// @dev Casts `x` to a uint152. Reverts on overflow.\n    function toUint152(uint256 x) internal pure returns (uint152) {\n        if (x >= 1 << 152) _revertOverflow();\n        return uint152(x);\n    }\n\n    /// @dev Casts `x` to a uint160. Reverts on overflow.\n    function toUint160(uint256 x) internal pure returns (uint160) {\n        if (x >= 1 << 160) _revertOverflow();\n        return uint160(x);\n    }\n\n    /// @dev Casts `x` to a uint168. Reverts on overflow.\n    function toUint168(uint256 x) internal pure returns (uint168) {\n        if (x >= 1 << 168) _revertOverflow();\n        return uint168(x);\n    }\n\n    /// @dev Casts `x` to a uint176. Reverts on overflow.\n    function toUint176(uint256 x) internal pure returns (uint176) {\n        if (x >= 1 << 176) _revertOverflow();\n        return uint176(x);\n    }\n\n    /// @dev Casts `x` to a uint184. Reverts on overflow.\n    function toUint184(uint256 x) internal pure returns (uint184) {\n        if (x >= 1 << 184) _revertOverflow();\n        return uint184(x);\n    }\n\n    /// @dev Casts `x` to a uint192. Reverts on overflow.\n    function toUint192(uint256 x) internal pure returns (uint192) {\n        if (x >= 1 << 192) _revertOverflow();\n        return uint192(x);\n    }\n\n    /// @dev Casts `x` to a uint200. Reverts on overflow.\n    function toUint200(uint256 x) internal pure returns (uint200) {\n        if (x >= 1 << 200) _revertOverflow();\n        return uint200(x);\n    }\n\n    /// @dev Casts `x` to a uint208. Reverts on overflow.\n    function toUint208(uint256 x) internal pure returns (uint208) {\n        if (x >= 1 << 208) _revertOverflow();\n        return uint208(x);\n    }\n\n    /// @dev Casts `x` to a uint216. Reverts on overflow.\n    function toUint216(uint256 x) internal pure returns (uint216) {\n        if (x >= 1 << 216) _revertOverflow();\n        return uint216(x);\n    }\n\n    /// @dev Casts `x` to a uint224. Reverts on overflow.\n    function toUint224(uint256 x) internal pure returns (uint224) {\n        if (x >= 1 << 224) _revertOverflow();\n        return uint224(x);\n    }\n\n    /// @dev Casts `x` to a uint232. Reverts on overflow.\n    function toUint232(uint256 x) internal pure returns (uint232) {\n        if (x >= 1 << 232) _revertOverflow();\n        return uint232(x);\n    }\n\n    /// @dev Casts `x` to a uint240. Reverts on overflow.\n    function toUint240(uint256 x) internal pure returns (uint240) {\n        if (x >= 1 << 240) _revertOverflow();\n        return uint240(x);\n    }\n\n    /// @dev Casts `x` to a uint248. Reverts on overflow.\n    function toUint248(uint256 x) internal pure returns (uint248) {\n        if (x >= 1 << 248) _revertOverflow();\n        return uint248(x);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*           SIGNED INTEGER SAFE CASTING OPERATIONS           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Casts `x` to a int8. Reverts on overflow.\n    function toInt8(int256 x) internal pure returns (int8) {\n        unchecked {\n            if (((1 << 7) + uint256(x)) >> 8 == uint256(0)) return int8(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int16. Reverts on overflow.\n    function toInt16(int256 x) internal pure returns (int16) {\n        unchecked {\n            if (((1 << 15) + uint256(x)) >> 16 == uint256(0)) return int16(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int24. Reverts on overflow.\n    function toInt24(int256 x) internal pure returns (int24) {\n        unchecked {\n            if (((1 << 23) + uint256(x)) >> 24 == uint256(0)) return int24(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int32. Reverts on overflow.\n    function toInt32(int256 x) internal pure returns (int32) {\n        unchecked {\n            if (((1 << 31) + uint256(x)) >> 32 == uint256(0)) return int32(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int40. Reverts on overflow.\n    function toInt40(int256 x) internal pure returns (int40) {\n        unchecked {\n            if (((1 << 39) + uint256(x)) >> 40 == uint256(0)) return int40(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int48. Reverts on overflow.\n    function toInt48(int256 x) internal pure returns (int48) {\n        unchecked {\n            if (((1 << 47) + uint256(x)) >> 48 == uint256(0)) return int48(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int56. Reverts on overflow.\n    function toInt56(int256 x) internal pure returns (int56) {\n        unchecked {\n            if (((1 << 55) + uint256(x)) >> 56 == uint256(0)) return int56(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int64. Reverts on overflow.\n    function toInt64(int256 x) internal pure returns (int64) {\n        unchecked {\n            if (((1 << 63) + uint256(x)) >> 64 == uint256(0)) return int64(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int72. Reverts on overflow.\n    function toInt72(int256 x) internal pure returns (int72) {\n        unchecked {\n            if (((1 << 71) + uint256(x)) >> 72 == uint256(0)) return int72(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int80. Reverts on overflow.\n    function toInt80(int256 x) internal pure returns (int80) {\n        unchecked {\n            if (((1 << 79) + uint256(x)) >> 80 == uint256(0)) return int80(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int88. Reverts on overflow.\n    function toInt88(int256 x) internal pure returns (int88) {\n        unchecked {\n            if (((1 << 87) + uint256(x)) >> 88 == uint256(0)) return int88(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int96. Reverts on overflow.\n    function toInt96(int256 x) internal pure returns (int96) {\n        unchecked {\n            if (((1 << 95) + uint256(x)) >> 96 == uint256(0)) return int96(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int104. Reverts on overflow.\n    function toInt104(int256 x) internal pure returns (int104) {\n        unchecked {\n            if (((1 << 103) + uint256(x)) >> 104 == uint256(0)) return int104(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int112. Reverts on overflow.\n    function toInt112(int256 x) internal pure returns (int112) {\n        unchecked {\n            if (((1 << 111) + uint256(x)) >> 112 == uint256(0)) return int112(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int120. Reverts on overflow.\n    function toInt120(int256 x) internal pure returns (int120) {\n        unchecked {\n            if (((1 << 119) + uint256(x)) >> 120 == uint256(0)) return int120(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int128. Reverts on overflow.\n    function toInt128(int256 x) internal pure returns (int128) {\n        unchecked {\n            if (((1 << 127) + uint256(x)) >> 128 == uint256(0)) return int128(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int136. Reverts on overflow.\n    function toInt136(int256 x) internal pure returns (int136) {\n        unchecked {\n            if (((1 << 135) + uint256(x)) >> 136 == uint256(0)) return int136(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int144. Reverts on overflow.\n    function toInt144(int256 x) internal pure returns (int144) {\n        unchecked {\n            if (((1 << 143) + uint256(x)) >> 144 == uint256(0)) return int144(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int152. Reverts on overflow.\n    function toInt152(int256 x) internal pure returns (int152) {\n        unchecked {\n            if (((1 << 151) + uint256(x)) >> 152 == uint256(0)) return int152(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int160. Reverts on overflow.\n    function toInt160(int256 x) internal pure returns (int160) {\n        unchecked {\n            if (((1 << 159) + uint256(x)) >> 160 == uint256(0)) return int160(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int168. Reverts on overflow.\n    function toInt168(int256 x) internal pure returns (int168) {\n        unchecked {\n            if (((1 << 167) + uint256(x)) >> 168 == uint256(0)) return int168(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int176. Reverts on overflow.\n    function toInt176(int256 x) internal pure returns (int176) {\n        unchecked {\n            if (((1 << 175) + uint256(x)) >> 176 == uint256(0)) return int176(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int184. Reverts on overflow.\n    function toInt184(int256 x) internal pure returns (int184) {\n        unchecked {\n            if (((1 << 183) + uint256(x)) >> 184 == uint256(0)) return int184(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int192. Reverts on overflow.\n    function toInt192(int256 x) internal pure returns (int192) {\n        unchecked {\n            if (((1 << 191) + uint256(x)) >> 192 == uint256(0)) return int192(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int200. Reverts on overflow.\n    function toInt200(int256 x) internal pure returns (int200) {\n        unchecked {\n            if (((1 << 199) + uint256(x)) >> 200 == uint256(0)) return int200(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int208. Reverts on overflow.\n    function toInt208(int256 x) internal pure returns (int208) {\n        unchecked {\n            if (((1 << 207) + uint256(x)) >> 208 == uint256(0)) return int208(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int216. Reverts on overflow.\n    function toInt216(int256 x) internal pure returns (int216) {\n        unchecked {\n            if (((1 << 215) + uint256(x)) >> 216 == uint256(0)) return int216(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int224. Reverts on overflow.\n    function toInt224(int256 x) internal pure returns (int224) {\n        unchecked {\n            if (((1 << 223) + uint256(x)) >> 224 == uint256(0)) return int224(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int232. Reverts on overflow.\n    function toInt232(int256 x) internal pure returns (int232) {\n        unchecked {\n            if (((1 << 231) + uint256(x)) >> 232 == uint256(0)) return int232(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int240. Reverts on overflow.\n    function toInt240(int256 x) internal pure returns (int240) {\n        unchecked {\n            if (((1 << 239) + uint256(x)) >> 240 == uint256(0)) return int240(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int248. Reverts on overflow.\n    function toInt248(int256 x) internal pure returns (int248) {\n        unchecked {\n            if (((1 << 247) + uint256(x)) >> 248 == uint256(0)) return int248(x);\n            _revertOverflow();\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*               OTHER SAFE CASTING OPERATIONS                */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Casts `x` to a int8. Reverts on overflow.\n    function toInt8(uint256 x) internal pure returns (int8) {\n        if (x >= 1 << 7) _revertOverflow();\n        return int8(int256(x));\n    }\n\n    /// @dev Casts `x` to a int16. Reverts on overflow.\n    function toInt16(uint256 x) internal pure returns (int16) {\n        if (x >= 1 << 15) _revertOverflow();\n        return int16(int256(x));\n    }\n\n    /// @dev Casts `x` to a int24. Reverts on overflow.\n    function toInt24(uint256 x) internal pure returns (int24) {\n        if (x >= 1 << 23) _revertOverflow();\n        return int24(int256(x));\n    }\n\n    /// @dev Casts `x` to a int32. Reverts on overflow.\n    function toInt32(uint256 x) internal pure returns (int32) {\n        if (x >= 1 << 31) _revertOverflow();\n        return int32(int256(x));\n    }\n\n    /// @dev Casts `x` to a int40. Reverts on overflow.\n    function toInt40(uint256 x) internal pure returns (int40) {\n        if (x >= 1 << 39) _revertOverflow();\n        return int40(int256(x));\n    }\n\n    /// @dev Casts `x` to a int48. Reverts on overflow.\n    function toInt48(uint256 x) internal pure returns (int48) {\n        if (x >= 1 << 47) _revertOverflow();\n        return int48(int256(x));\n    }\n\n    /// @dev Casts `x` to a int56. Reverts on overflow.\n    function toInt56(uint256 x) internal pure returns (int56) {\n        if (x >= 1 << 55) _revertOverflow();\n        return int56(int256(x));\n    }\n\n    /// @dev Casts `x` to a int64. Reverts on overflow.\n    function toInt64(uint256 x) internal pure returns (int64) {\n        if (x >= 1 << 63) _revertOverflow();\n        return int64(int256(x));\n    }\n\n    /// @dev Casts `x` to a int72. Reverts on overflow.\n    function toInt72(uint256 x) internal pure returns (int72) {\n        if (x >= 1 << 71) _revertOverflow();\n        return int72(int256(x));\n    }\n\n    /// @dev Casts `x` to a int80. Reverts on overflow.\n    function toInt80(uint256 x) internal pure returns (int80) {\n        if (x >= 1 << 79) _revertOverflow();\n        return int80(int256(x));\n    }\n\n    /// @dev Casts `x` to a int88. Reverts on overflow.\n    function toInt88(uint256 x) internal pure returns (int88) {\n        if (x >= 1 << 87) _revertOverflow();\n        return int88(int256(x));\n    }\n\n    /// @dev Casts `x` to a int96. Reverts on overflow.\n    function toInt96(uint256 x) internal pure returns (int96) {\n        if (x >= 1 << 95) _revertOverflow();\n        return int96(int256(x));\n    }\n\n    /// @dev Casts `x` to a int104. Reverts on overflow.\n    function toInt104(uint256 x) internal pure returns (int104) {\n        if (x >= 1 << 103) _revertOverflow();\n        return int104(int256(x));\n    }\n\n    /// @dev Casts `x` to a int112. Reverts on overflow.\n    function toInt112(uint256 x) internal pure returns (int112) {\n        if (x >= 1 << 111) _revertOverflow();\n        return int112(int256(x));\n    }\n\n    /// @dev Casts `x` to a int120. Reverts on overflow.\n    function toInt120(uint256 x) internal pure returns (int120) {\n        if (x >= 1 << 119) _revertOverflow();\n        return int120(int256(x));\n    }\n\n    /// @dev Casts `x` to a int128. Reverts on overflow.\n    function toInt128(uint256 x) internal pure returns (int128) {\n        if (x >= 1 << 127) _revertOverflow();\n        return int128(int256(x));\n    }\n\n    /// @dev Casts `x` to a int136. Reverts on overflow.\n    function toInt136(uint256 x) internal pure returns (int136) {\n        if (x >= 1 << 135) _revertOverflow();\n        return int136(int256(x));\n    }\n\n    /// @dev Casts `x` to a int144. Reverts on overflow.\n    function toInt144(uint256 x) internal pure returns (int144) {\n        if (x >= 1 << 143) _revertOverflow();\n        return int144(int256(x));\n    }\n\n    /// @dev Casts `x` to a int152. Reverts on overflow.\n    function toInt152(uint256 x) internal pure returns (int152) {\n        if (x >= 1 << 151) _revertOverflow();\n        return int152(int256(x));\n    }\n\n    /// @dev Casts `x` to a int160. Reverts on overflow.\n    function toInt160(uint256 x) internal pure returns (int160) {\n        if (x >= 1 << 159) _revertOverflow();\n        return int160(int256(x));\n    }\n\n    /// @dev Casts `x` to a int168. Reverts on overflow.\n    function toInt168(uint256 x) internal pure returns (int168) {\n        if (x >= 1 << 167) _revertOverflow();\n        return int168(int256(x));\n    }\n\n    /// @dev Casts `x` to a int176. Reverts on overflow.\n    function toInt176(uint256 x) internal pure returns (int176) {\n        if (x >= 1 << 175) _revertOverflow();\n        return int176(int256(x));\n    }\n\n    /// @dev Casts `x` to a int184. Reverts on overflow.\n    function toInt184(uint256 x) internal pure returns (int184) {\n        if (x >= 1 << 183) _revertOverflow();\n        return int184(int256(x));\n    }\n\n    /// @dev Casts `x` to a int192. Reverts on overflow.\n    function toInt192(uint256 x) internal pure returns (int192) {\n        if (x >= 1 << 191) _revertOverflow();\n        return int192(int256(x));\n    }\n\n    /// @dev Casts `x` to a int200. Reverts on overflow.\n    function toInt200(uint256 x) internal pure returns (int200) {\n        if (x >= 1 << 199) _revertOverflow();\n        return int200(int256(x));\n    }\n\n    /// @dev Casts `x` to a int208. Reverts on overflow.\n    function toInt208(uint256 x) internal pure returns (int208) {\n        if (x >= 1 << 207) _revertOverflow();\n        return int208(int256(x));\n    }\n\n    /// @dev Casts `x` to a int216. Reverts on overflow.\n    function toInt216(uint256 x) internal pure returns (int216) {\n        if (x >= 1 << 215) _revertOverflow();\n        return int216(int256(x));\n    }\n\n    /// @dev Casts `x` to a int224. Reverts on overflow.\n    function toInt224(uint256 x) internal pure returns (int224) {\n        if (x >= 1 << 223) _revertOverflow();\n        return int224(int256(x));\n    }\n\n    /// @dev Casts `x` to a int232. Reverts on overflow.\n    function toInt232(uint256 x) internal pure returns (int232) {\n        if (x >= 1 << 231) _revertOverflow();\n        return int232(int256(x));\n    }\n\n    /// @dev Casts `x` to a int240. Reverts on overflow.\n    function toInt240(uint256 x) internal pure returns (int240) {\n        if (x >= 1 << 239) _revertOverflow();\n        return int240(int256(x));\n    }\n\n    /// @dev Casts `x` to a int248. Reverts on overflow.\n    function toInt248(uint256 x) internal pure returns (int248) {\n        if (x >= 1 << 247) _revertOverflow();\n        return int248(int256(x));\n    }\n\n    /// @dev Casts `x` to a int256. Reverts on overflow.\n    function toInt256(uint256 x) internal pure returns (int256) {\n        if (int256(x) >= 0) return int256(x);\n        _revertOverflow();\n    }\n\n    /// @dev Casts `x` to a uint256. Reverts on overflow.\n    function toUint256(int256 x) internal pure returns (uint256) {\n        if (x >= 0) return uint256(x);\n        _revertOverflow();\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    function _revertOverflow() private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Store the function selector of `Overflow()`.\n            mstore(0x00, 0x35278d12)\n            // Revert with (offset, size).\n            revert(0x1c, 0x04)\n        }\n    }\n}\n"}, "lib/solady/src/utils/FixedPointMathLib.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error ExpOverflow();\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error FactorialOverflow();\n\n    /// @dev The operation failed, due to an overflow.\n    error RPowOverflow();\n\n    /// @dev The mantissa is too big to fit.\n    error MantissaOverflow();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error MulWadFailed();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error SMulWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error DivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error SDivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error MulDivFailed();\n\n    /// @dev The division failed, as the denominator is zero.\n    error DivFailed();\n\n    /// @dev The full precision multiply-divide operation failed, either due\n    /// to the result being larger than 256 bits, or a division by a zero.\n    error FullMulDivFailed();\n\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\n    error LnWadUndefined();\n\n    /// @dev The input outside the acceptable domain.\n    error OutOfDomain();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         CONSTANTS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The scalar of ETH and most ERC20s.\n    uint256 internal constant WAD = 1e18;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if gt(x, div(not(0), y)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function sMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require((x == 0 || z / x == y) && !(x == -1 && y == type(int256).min))`.\n            if iszero(gt(or(iszero(x), eq(sdiv(z, x), y)), lt(not(x), eq(y, shl(255, 1))))) {\n                mstore(0x00, 0xedcd4dd4) // `SMulWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawMulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawSMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if iszero(eq(div(z, y), x)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := add(iszero(iszero(mod(z, WAD))), div(z, WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up, but without overflow checks.\n    function rawMulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function sDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, WAD)\n            // Equivalent to `require(y != 0 && ((x * WAD) / WAD == x))`.\n            if iszero(mul(y, eq(sdiv(z, WAD), x))) {\n                mstore(0x00, 0x5c43740d) // `SDivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawDivWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawSDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up, but without overflow and divide by zero checks.\n    function rawDivWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `x` to the power of `y`.\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\n    /// Note: This function is an approximation.\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Using `ln(x)` means `x` must be greater than 0.\n        return expWad((lnWad(x) * y) / int256(WAD));\n    }\n\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2\u03c0.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is less than 0.5 we return zero.\n            // This happens when `x <= (log(1e-18) * 1e18) ~ -4.15e19`.\n            if (x <= -41446531673892822313) return r;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // When the result is greater than `(2**255 - 1) / 1e18` we can not represent it as\n                // an int. This happens when `x >= floor(log((2**255 - 1) / 1e18) * 1e18) \u2248 135`.\n                if iszero(slt(x, 135305999368893231589)) {\n                    mstore(0x00, 0xa37bfec9) // `ExpOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            // `x` is now in the range `(-42, 136) * 1e18`. Convert to `(-42, 136) * 2**96`\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5 ** 18;\n\n            // Reduce range of x to (-\u00bd ln 2, \u00bd ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // `k` is in the range `[-61, 195]`.\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // `p` is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already `2**96` too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range `(0.09, 0.25) * 2**96`.\n\n            // We now need to multiply r by:\n            // - The scale factor `s \u2248 6.031367120`.\n            // - The `2**k` factor from the range reduction.\n            // - The `1e18 / 2**96` factor for base conversion.\n            // We do this all at once, with an intermediate result in `2**213`\n            // basis, so the final right shift is always by a positive amount.\n            r = int256(\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\n            );\n        }\n    }\n\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2\u03c0.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We want to convert `x` from `10**18` fixed point to `2**96` fixed point.\n            // We do this by multiplying by `2**96 / 10**18`. But since\n            // `ln(x * C) = ln(x) + ln(C)`, we can simply do nothing here\n            // and add `ln(2**96 / 10**18)` at the end.\n\n            // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // We place the check here for more optimal stack operations.\n            if iszero(sgt(x, 0)) {\n                mstore(0x00, 0x1615e638) // `LnWadUndefined()`.\n                revert(0x1c, 0x04)\n            }\n            // forgefmt: disable-next-item\n            r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            x := shr(159, shl(r, x))\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // `p` is made monic, we will multiply by a scale factor later.\n            // forgefmt: disable-next-item\n            let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.\n                sar(96, mul(add(43456485725739037958740375743393,\n                sar(96, mul(add(24828157081833163892658089445524,\n                sar(96, mul(add(3273285459638523848632254066296,\n                    x), x))), x))), x)), 11111509109440967052023855526967)\n            p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)\n            p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)\n            p := sub(mul(p, x), shl(96, 795164235651350426258249787498))\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n\n            // `q` is monic by convention.\n            let q := add(5573035233440673466300451813936, x)\n            q := add(71694874799317883764090561454958, sar(96, mul(x, q)))\n            q := add(283447036172924575727196451306956, sar(96, mul(x, q)))\n            q := add(401686690394027663651624208769553, sar(96, mul(x, q)))\n            q := add(204048457590392012362485061816622, sar(96, mul(x, q)))\n            q := add(31853899698501571402653359427138, sar(96, mul(x, q)))\n            q := add(909429971244387300277376558375, sar(96, mul(x, q)))\n\n            // `p / q` is in the range `(0, 0.125) * 2**96`.\n\n            // Finalization, we need to:\n            // - Multiply by the scale factor `s = 5.549\u2026`.\n            // - Add `ln(2**96 / 10**18)`.\n            // - Add `k * ln(2)`.\n            // - Multiply by `10**18 / 2**96 = 5**18 >> 78`.\n\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already `2**96` too large.\n            p := sdiv(p, q)\n            // Multiply by the scaling factor: `s * 5**18 * 2**96`, base is now `5**18 * 2**192`.\n            p := mul(1677202110996718588342820967067443963516166, p)\n            // Add `ln(2) * k * 5**18 * 2**192`.\n            // forgefmt: disable-next-item\n            p := add(mul(16597577552685614221487285958193947469193820559219878177908093499208371, sub(159, r)), p)\n            // Add `ln(2**96 / 10**18) * 5**18 * 2**192`.\n            p := add(600920179829731861736702779321621459595472258049074101567377883020018308, p)\n            // Base conversion: mul `2**18 / 2**192`.\n            r := sar(174, p)\n        }\n    }\n\n    /// @dev Returns `W_0(x)`, denominated in `WAD`.\n    /// See: https://en.wikipedia.org/wiki/Lambert_W_function\n    /// a.k.a. Product log function. This is an approximation of the principal branch.\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lambertW0Wad(int256 x) internal pure returns (int256 w) {\n        // forgefmt: disable-next-item\n        unchecked {\n            if ((w = x) <= -367879441171442322) revert OutOfDomain(); // `x` less than `-1/e`.\n            (int256 wad, int256 p) = (int256(WAD), x);\n            uint256 c; // Whether we need to avoid catastrophic cancellation.\n            uint256 i = 4; // Number of iterations.\n            if (w <= 0x1ffffffffffff) {\n                if (-0x4000000000000 <= w) {\n                    i = 1; // Inputs near zero only take one step to converge.\n                } else if (w <= -0x3ffffffffffffff) {\n                    i = 32; // Inputs near `-1/e` take very long to converge.\n                }\n            } else if (uint256(w >> 63) == uint256(0)) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // Inline log2 for more performance, since the range is small.\n                    let v := shr(49, w)\n                    let l := shl(3, lt(0xff, v))\n                    l := add(or(l, byte(and(0x1f, shr(shr(l, v), 0x8421084210842108cc6318c6db6d54be)),\n                        0x0706060506020504060203020504030106050205030304010505030400000000)), 49)\n                    w := sdiv(shl(l, 7), byte(sub(l, 31), 0x0303030303030303040506080c13))\n                    c := gt(l, 60)\n                    i := add(2, add(gt(l, 53), c))\n                }\n            } else {\n                int256 ll = lnWad(w = lnWad(w));\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // `w = ln(x) - ln(ln(x)) + b * ln(ln(x)) / ln(x)`.\n                    w := add(sdiv(mul(ll, 1023715080943847266), w), sub(w, ll))\n                    i := add(3, iszero(shr(68, x)))\n                    c := iszero(shr(143, x))\n                }\n                if (c == uint256(0)) {\n                    do { // If `x` is big, use Newton's so that intermediate values won't overflow.\n                        int256 e = expWad(w);\n                        /// @solidity memory-safe-assembly\n                        assembly {\n                            let t := mul(w, div(e, wad))\n                            w := sub(w, sdiv(sub(t, x), div(add(e, t), wad)))\n                        }\n                        if (p <= w) break;\n                        p = w;\n                    } while (--i != uint256(0));\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        w := sub(w, sgt(w, 2))\n                    }\n                    return w;\n                }\n            }\n            do { // Otherwise, use Halley's for faster convergence.\n                int256 e = expWad(w);\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let t := add(w, wad)\n                    let s := sub(mul(w, e), mul(x, wad))\n                    w := sub(w, sdiv(mul(s, wad), sub(mul(e, t), sdiv(mul(add(t, wad), s), add(t, t)))))\n                }\n                if (p <= w) break;\n                p = w;\n            } while (--i != c);\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sub(w, sgt(w, 2))\n            }\n            // For certain ranges of `x`, we'll use the quadratic-rate recursive formula of\n            // R. Iacono and J.P. Boyd for the last iteration, to avoid catastrophic cancellation.\n            if (c == uint256(0)) return w;\n            int256 t = w | 1;\n            /// @solidity memory-safe-assembly\n            assembly {\n                x := sdiv(mul(x, wad), t)\n            }\n            x = (t * (wad + lnWad(x)));\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sdiv(x, add(wad, t))\n            }\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                  GENERAL NUMBER UTILITIES                  */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns `a * b == x * y`, with full precision.\n    function fullMulEq(uint256 a, uint256 b, uint256 x, uint256 y)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(mul(a, b), mul(x, y)), eq(mulmod(x, y, not(0)), mulmod(a, b, not(0))))\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Remco Bloemen under MIT license: https://2\u03c0.com/21/muldiv\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // 512-bit multiply `[p1 p0] = x * y`.\n            // Compute the product mod `2**256` and mod `2**256 - 1`\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that `product = p1 * 2**256 + p0`.\n\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`.\n            for {} 1 {} {\n                // If overflows.\n                if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n\n                    /*------------------- 512 by 256 division --------------------*/\n\n                    // Make division exact by subtracting the remainder from `[p1 p0]`.\n                    let r := mulmod(x, y, d) // Compute remainder using mulmod.\n                    let t := and(d, sub(0, d)) // The least significant bit of `d`. `t >= 1`.\n                    // Make sure `z` is less than `2**256`. Also prevents `d == 0`.\n                    // Placing the check here seems to give more optimal stack operations.\n                    if iszero(gt(d, p1)) {\n                        mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    d := div(d, t) // Divide `d` by `t`, which is a power of two.\n                    // Invert `d mod 2**256`\n                    // Now that `d` is an odd number, it has an inverse\n                    // modulo `2**256` such that `d * inv = 1 mod 2**256`.\n                    // Compute the inverse by starting with a seed that is correct\n                    // correct for four bits. That is, `d * inv = 1 mod 2**4`.\n                    let inv := xor(2, mul(3, d))\n                    // Now use Newton-Raphson iteration to improve the precision.\n                    // Thanks to Hensel's lifting lemma, this also works in modular\n                    // arithmetic, doubling the correct bits in each step.\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\n                    z :=\n                        mul(\n                            // Divide [p1 p0] by the factors of two.\n                            // Shift in bits from `p1` into `p0`. For this we need\n                            // to flip `t` such that it is `2**256 / t`.\n                            or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                            mul(sub(2, mul(d, inv)), inv) // inverse mod 2**256\n                        )\n                    break\n                }\n                z := div(z, d)\n                break\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Behavior is undefined if `d` is zero or the final result cannot fit in 256 bits.\n    /// Performs the full 512 bit calculation regardless.\n    function fullMulDivUnchecked(uint256 x, uint256 y, uint256 d)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            let mm := mulmod(x, y, not(0))\n            let p1 := sub(mm, add(z, lt(mm, z)))\n            let t := and(d, sub(0, d))\n            let r := mulmod(x, y, d)\n            d := div(d, t)\n            let inv := xor(2, mul(3, d))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            z :=\n                mul(\n                    or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                    mul(sub(2, mul(d, inv)), inv)\n                )\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Uniswap-v3-core under MIT license:\n    /// https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/FullMath.sol\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        z = fullMulDiv(x, y, d);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mulmod(x, y, d) {\n                z := add(z, 1)\n                if iszero(z) {\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / 2 ** n)` with full precision.\n    /// Throws if result overflows a uint256.\n    /// Credit to Philogy under MIT license:\n    /// https://github.com/SorellaLabs/angstrom/blob/main/contracts/src/libraries/X128MathLib.sol\n    function fullMulDivN(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`. We'll call this `z`.\n            for {} 1 {} {\n                if iszero(or(iszero(x), eq(div(z, x), y))) {\n                    let k := and(n, 0xff) // `n`, cleaned.\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n                    //         |      p1     |      z     |\n                    // Before: | p1_0 \u00a6 p1_1 | z_0  \u00a6 z_1 |\n                    // Final:  |   0  \u00a6 p1_0 | p1_1 \u00a6 z_0 |\n                    // Check that final `z` doesn't overflow by checking that p1_0 = 0.\n                    if iszero(shr(k, p1)) {\n                        z := add(shl(sub(256, k), p1), shr(k, z))\n                        break\n                    }\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                z := shr(and(n, 0xff), z)\n                break\n            }\n        }\n    }\n\n    /// @dev Returns `floor(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(z, d)\n        }\n    }\n\n    /// @dev Returns `ceil(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(z, d))), div(z, d))\n        }\n    }\n\n    /// @dev Returns `x`, the modular multiplicative inverse of `a`, such that `(a * x) % n == 1`.\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256 x) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let g := n\n            let r := mod(a, n)\n            for { let y := 1 } 1 {} {\n                let q := div(g, r)\n                let t := g\n                g := r\n                r := sub(t, mul(r, q))\n                let u := x\n                x := y\n                y := sub(u, mul(y, q))\n                if iszero(r) { break }\n            }\n            x := mul(eq(g, 1), add(x, mul(slt(x, 0), n)))\n        }\n    }\n\n    /// @dev Returns `ceil(x / d)`.\n    /// Reverts if `d` is zero.\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(d) {\n                mstore(0x00, 0x65244e4e) // `DivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\n        }\n    }\n\n    /// @dev Returns `max(0, x - y)`.\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, address x, address y) internal pure returns (address z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Exponentiate `x` to `y` by squaring, denominated in base `b`.\n    /// Reverts if the computation overflows.\n    function rpow(uint256 x, uint256 y, uint256 b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(b, iszero(y)) // `0 ** 0 = 1`. Otherwise, `0 ** n = 0`.\n            if x {\n                z := xor(b, mul(xor(b, x), and(y, 1))) // `z = isEven(y) ? scale : x`\n                let half := shr(1, b) // Divide `b` by 2.\n                // Divide `y` by 2 every iteration.\n                for { y := shr(1, y) } y { y := shr(1, y) } {\n                    let xx := mul(x, x) // Store x squared.\n                    let xxRound := add(xx, half) // Round to the nearest number.\n                    // Revert if `xx + half` overflowed, or if `x ** 2` overflows.\n                    if or(lt(xxRound, xx), shr(128, x)) {\n                        mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                        revert(0x1c, 0x04)\n                    }\n                    x := div(xxRound, b) // Set `x` to scaled `xxRound`.\n                    // If `y` is odd:\n                    if and(y, 1) {\n                        let zx := mul(z, x) // Compute `z * x`.\n                        let zxRound := add(zx, half) // Round to the nearest number.\n                        // If `z * x` overflowed or `zx + half` overflowed:\n                        if or(xor(div(zx, x), z), lt(zxRound, zx)) {\n                            // Revert if `x` is non-zero.\n                            if x {\n                                mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                                revert(0x1c, 0x04)\n                            }\n                        }\n                        z := div(zxRound, b) // Return properly scaled `zxRound`.\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns the square root of `x`, rounded down.\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // Let `y = x / 2**r`. We check `y >= 2**(k + 8)`\n            // but shift right by `k` bits to ensure that if `x >= 256`, then `y >= 256`.\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\n            z := shl(shr(1, r), z)\n\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\n\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\n\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\n\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\n            // Then we can estimate `sqrt(y)` using\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\n\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If `x+1` is a perfect square, the Babylonian method cycles between\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, rounded down.\n    /// Credit to bout3fiddy and pcaversaccio under AGPLv3 license:\n    /// https://github.com/pcaversaccio/snekmate/blob/main/src/utils/Math.vy\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // Makeshift lookup table to nudge the approximate log2 result.\n            z := div(shl(div(r, 3), shl(lt(0xf, shr(r, x)), 0xf)), xor(7, mod(r, 3)))\n            // Newton-Raphson's.\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            // Round down.\n            z := sub(z, lt(div(x, mul(z, z)), z))\n        }\n    }\n\n    /// @dev Returns the square root of `x`, denominated in `WAD`, rounded down.\n    function sqrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 18) return sqrt(x * 10 ** 18);\n            z = (1 + sqrt(x)) * 10 ** 9;\n            z = (fullMulDivUnchecked(x, 10 ** 18, z) + z) >> 1;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sub(z, gt(999999999999999999, sub(mulmod(z, z, x), 1))) // Round down.\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, denominated in `WAD`, rounded down.\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 36) return cbrt(x * 10 ** 36);\n            z = (1 + cbrt(x)) * 10 ** 12;\n            z = (fullMulDivUnchecked(x, 10 ** 36, z * z) + z + z) / 3;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let p := x\n            for {} 1 {} {\n                if iszero(shr(229, p)) {\n                    if iszero(shr(199, p)) {\n                        p := mul(p, 100000000000000000) // 10 ** 17.\n                        break\n                    }\n                    p := mul(p, 100000000) // 10 ** 8.\n                    break\n                }\n                if iszero(shr(249, p)) { p := mul(p, 100) }\n                break\n            }\n            let t := mulmod(mul(z, z), z, p)\n            z := sub(z, gt(lt(t, shr(1, p)), iszero(t))) // Round down.\n        }\n    }\n\n    /// @dev Returns the factorial of `x`.\n    function factorial(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := 1\n            if iszero(lt(x, 58)) {\n                mstore(0x00, 0xaba0f2a2) // `FactorialOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            for {} x { x := sub(x, 1) } { z := mul(z, x) }\n        }\n    }\n\n    /// @dev Returns the log2 of `x`.\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\n    /// Returns 0 if `x` is zero.\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020504060203020504030106050205030304010505030400000000))\n        }\n    }\n\n    /// @dev Returns the log2 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\n        r = log2(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(r, 1), x))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log10(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, 100000000000000000000000000000000000000)) {\n                x := div(x, 100000000000000000000000000000000000000)\n                r := 38\n            }\n            if iszero(lt(x, 100000000000000000000)) {\n                x := div(x, 100000000000000000000)\n                r := add(r, 20)\n            }\n            if iszero(lt(x, 10000000000)) {\n                x := div(x, 10000000000)\n                r := add(r, 10)\n            }\n            if iszero(lt(x, 100000)) {\n                x := div(x, 100000)\n                r := add(r, 5)\n            }\n            r := add(r, add(gt(x, 9), add(gt(x, 99), add(gt(x, 999), gt(x, 9999)))))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log10Up(uint256 x) internal pure returns (uint256 r) {\n        r = log10(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(exp(10, r), x))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(shr(3, r), lt(0xff, shr(r, x)))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log256Up(uint256 x) internal pure returns (uint256 r) {\n        r = log256(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(shl(3, r), 1), x))\n        }\n    }\n\n    /// @dev Returns the scientific notation format `mantissa * 10 ** exponent` of `x`.\n    /// Useful for compressing prices (e.g. using 25 bit mantissa and 7 bit exponent).\n    function sci(uint256 x) internal pure returns (uint256 mantissa, uint256 exponent) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mantissa := x\n            if mantissa {\n                if iszero(mod(mantissa, 1000000000000000000000000000000000)) {\n                    mantissa := div(mantissa, 1000000000000000000000000000000000)\n                    exponent := 33\n                }\n                if iszero(mod(mantissa, 10000000000000000000)) {\n                    mantissa := div(mantissa, 10000000000000000000)\n                    exponent := add(exponent, 19)\n                }\n                if iszero(mod(mantissa, 1000000000000)) {\n                    mantissa := div(mantissa, 1000000000000)\n                    exponent := add(exponent, 12)\n                }\n                if iszero(mod(mantissa, 1000000)) {\n                    mantissa := div(mantissa, 1000000)\n                    exponent := add(exponent, 6)\n                }\n                if iszero(mod(mantissa, 10000)) {\n                    mantissa := div(mantissa, 10000)\n                    exponent := add(exponent, 4)\n                }\n                if iszero(mod(mantissa, 100)) {\n                    mantissa := div(mantissa, 100)\n                    exponent := add(exponent, 2)\n                }\n                if iszero(mod(mantissa, 10)) {\n                    mantissa := div(mantissa, 10)\n                    exponent := add(exponent, 1)\n                }\n            }\n        }\n    }\n\n    /// @dev Convenience function for packing `x` into a smaller number using `sci`.\n    /// The `mantissa` will be in bits [7..255] (the upper 249 bits).\n    /// The `exponent` will be in bits [0..6] (the lower 7 bits).\n    /// Use `SafeCastLib` to safely ensure that the `packed` number is small\n    /// enough to fit in the desired unsigned integer type:\n    /// ```\n    ///     uint32 packed = SafeCastLib.toUint32(FixedPointMathLib.packSci(777 ether));\n    /// ```\n    function packSci(uint256 x) internal pure returns (uint256 packed) {\n        (x, packed) = sci(x); // Reuse for `mantissa` and `exponent`.\n        /// @solidity memory-safe-assembly\n        assembly {\n            if shr(249, x) {\n                mstore(0x00, 0xce30380c) // `MantissaOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            packed := or(shl(7, x), packed)\n        }\n    }\n\n    /// @dev Convenience function for unpacking a packed number from `packSci`.\n    function unpackSci(uint256 packed) internal pure returns (uint256 unpacked) {\n        unchecked {\n            unpacked = (packed >> 7) * 10 ** (packed & 0x7f);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards zero.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = (x & y) + ((x ^ y) >> 1);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards negative infinity.\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @dev Returns the absolute value of `x`.\n    function abs(int256 x) internal pure returns (uint256 z) {\n        unchecked {\n            z = (uint256(x) + uint256(x >> 255)) ^ uint256(x >> 255);\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, gt(x, y)), sub(y, x)), gt(x, y))\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, sgt(x, y)), sub(y, x)), sgt(x, y))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), lt(y, x)))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), slt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), gt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), gt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), lt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), sgt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), slt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns greatest common divisor of `x` and `y`.\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { z := x } y {} {\n                let t := y\n                y := mod(z, y)\n                z := t\n            }\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`,\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(uint256 a, uint256 b, uint256 t, uint256 begin, uint256 end)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        unchecked {\n            if (b >= a) return a + fullMulDiv(b - a, t - begin, end - begin);\n            return a - fullMulDiv(a - b, t - begin, end - begin);\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`.\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(int256 a, int256 b, int256 t, int256 begin, int256 end)\n        internal\n        pure\n        returns (int256)\n    {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        // forgefmt: disable-next-item\n        unchecked {\n            if (b >= a) return int256(uint256(a) + fullMulDiv(uint256(b - a),\n                uint256(t - begin), uint256(end - begin)));\n            return int256(uint256(a) - fullMulDiv(uint256(a - b),\n                uint256(t - begin), uint256(end - begin)));\n        }\n    }\n\n    /// @dev Returns if `x` is an even number. Some people may need this.\n    function isEven(uint256 x) internal pure returns (bool) {\n        return x & uint256(1) == uint256(0);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                   RAW NUMBER OPERATIONS                    */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(x, y)\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mod(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := smod(x, y)\n        }\n    }\n\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := addmod(x, y, d)\n        }\n    }\n\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mulmod(x, y, d)\n        }\n    }\n}\n"}, "src/lib/Math.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {TickMath} from \"@uniswap/v4-core/src/libraries/TickMath.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport \"../base/Constants.sol\";\n\nusing FixedPointMathLib for int256;\nusing FixedPointMathLib for uint256;\n\n/// @dev modified from solady\nfunction dist(uint256 x, uint256 y) pure returns (uint256 z) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        z := xor(mul(xor(sub(y, x), sub(x, y)), gt(x, y)), sub(y, x))\n    }\n}\n\n/// @dev modified from solady\nfunction absDiff(uint256 x, uint256 y) pure returns (bool positive, uint256 diff) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        positive := gt(x, y)\n        diff := xor(mul(xor(sub(y, x), sub(x, y)), gt(x, y)), sub(y, x))\n    }\n}\n\nfunction roundTick(int24 currentTick, int24 tickSpacing) pure returns (int24 roundedTick, int24 nextRoundedTick) {\n    int24 compressed = currentTick / tickSpacing;\n    if (currentTick < 0 && currentTick % tickSpacing != 0) compressed--; // round towards negative infinity\n    roundedTick = compressed * tickSpacing;\n    nextRoundedTick = roundedTick + tickSpacing;\n}\n\nfunction roundTickSingle(int24 currentTick, int24 tickSpacing) pure returns (int24 roundedTick) {\n    int24 compressed = currentTick / tickSpacing;\n    if (currentTick < 0 && currentTick % tickSpacing != 0) compressed--; // round towards negative infinity\n    roundedTick = compressed * tickSpacing;\n}\n\nfunction boundTick(int24 tick, int24 tickSpacing) pure returns (int24 boundedTick) {\n    (int24 minTick, int24 maxTick) = (TickMath.minUsableTick(tickSpacing), TickMath.maxUsableTick(tickSpacing));\n    return int24(FixedPointMathLib.clamp(tick, minTick, maxTick));\n}\n\nfunction weightedSum(uint256 value0, uint256 weight0, uint256 value1, uint256 weight1) pure returns (uint256) {\n    return (value0 * weight0 + value1 * weight1) / (weight0 + weight1);\n}\n\n/// @dev Converts xWad, the decimal index of a rounded tick scaled by WAD, to the corresponding rounded tick.\nfunction xWadToRoundedTick(int256 xWad, int24 mu, int24 tickSpacing, bool roundUp) pure returns (int24) {\n    int24 x = SafeCastLib.toInt24(xWad / int256(WAD));\n    if (roundUp) {\n        if (xWad > 0 && xWad % int256(WAD) != 0) x++; // round towards positive infinity\n    } else {\n        if (xWad < 0 && xWad % int256(WAD) != 0) x--; // round towards negative infinity\n    }\n    return x * tickSpacing + mu;\n}\n\nfunction percentDelta(uint256 a, uint256 b) pure returns (uint256) {\n    uint256 absDelta = dist(a, b);\n    return FixedPointMathLib.divWad(absDelta, b);\n}\n\n/// @dev Returns ReLU(x - y) = max(x - y, 0)\nfunction subReLU(uint256 x, uint256 y) pure returns (uint256) {\n    unchecked {\n        return x > y ? x - y : 0;\n    }\n}\n\nfunction divQ96RoundUp(uint256 value) pure returns (uint256) {\n    return (value + ((1 << 96) - 1)) >> 96;\n}\n\nfunction roundUpFullMulDivResult(uint256 x, uint256 y, uint256 d, uint256 resultRoundedDown)\n    pure\n    returns (uint256 result)\n{\n    result = resultRoundedDown;\n    /// @solidity memory-safe-assembly\n    assembly {\n        if mulmod(x, y, d) {\n            result := add(resultRoundedDown, 1)\n            if iszero(result) {\n                mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"}, "src/lib/ExpMath.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nlibrary ExpMath {\n    using ExpMath for int256;\n    using SafeCastLib for int256;\n    using SafeCastLib for uint256;\n    using FixedPointMathLib for int256;\n    using FixedPointMathLib for uint256;\n\n    uint256 internal constant WAD = 1e18;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n    int256 internal constant LN_Q96_DIV_WAD = 25095597659861927392; // ln(Q96 / WAD) * WAD\n    int256 internal constant HALF_LN_TICK_BASE = 49997500166654; // 1/2 ln(1.0001) * WAD\n    int256 internal constant HALF_LN_TICK_BASE_Q96 = 3961210068510634698400736; // 1/2 ln(1.0001) * Q96\n\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\n    error LnQ96Undefined();\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error ExpOverflow();\n\n    /// @dev Returns `exp(x)`, denominated in `Q96`.\n    /// Credit to Remco Bloemen under MIT license: https://2\u03c0.com/22/exp-ln\n    function expQ96(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is less than 0.5 we return zero.\n            // This happens when `x <= floor(ln(1 / 2**96) * 2**96)`.\n            if (x <= -5272010636899917441709581228290) return r;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // When the result is greater than `(2**255 - 1) / 2**96` we can not represent it as\n                // an int. This happens when `x >= floor(log((2**255 - 1) / 2**96) * 2**96) \u2248 110 * 2**96`.\n                if iszero(slt(x, 8731767617365488262831493909354)) {\n                    mstore(0x00, 0xa37bfec9) // `ExpOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            // Reduce range of x to (-\u00bd ln 2, \u00bd ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // `k` is in the range `[-61, 195]`.\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // `p` is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already `2**96` too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range `(0.09, 0.25) * 2**96`.\n\n            // We now need to multiply r by:\n            // - The scale factor `s \u2248 6.031367120`.\n            // - The `2**k` factor from the range reduction.\n            int256 shift = 117 - k;\n            r = shift >= 0\n                ? int256((uint256(r) * 1002132753603162656746435578141647308) >> uint256(shift))\n                : int256((uint256(r) * 1002132753603162656746435578141647308) << uint256(-shift));\n        }\n    }\n\n    /// @dev Returns `ln(x)`, denominated in `Q96`.\n    /// Credit to Remco Bloemen under MIT license: https://2\u03c0.com/22/exp-ln\n    function lnQ96(int256 x) internal pure returns (int256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // We place the check here for more optimal stack operations.\n            if iszero(sgt(x, 0)) {\n                mstore(0x00, 0xe65fd7ca) // `LnQ96Undefined()`.\n                revert(0x1c, 0x04)\n            }\n            // forgefmt: disable-next-item\n            r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            x := shr(159, shl(r, x))\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // `p` is made monic, we will multiply by a scale factor later.\n            // forgefmt: disable-next-item\n            let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.\n                sar(96, mul(add(43456485725739037958740375743393,\n                sar(96, mul(add(24828157081833163892658089445524,\n                sar(96, mul(add(3273285459638523848632254066296,\n                    x), x))), x))), x)), 11111509109440967052023855526967)\n            p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)\n            p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)\n            p := sub(mul(p, x), shl(96, 795164235651350426258249787498))\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n\n            // `q` is monic by convention.\n            let q := add(5573035233440673466300451813936, x)\n            q := add(71694874799317883764090561454958, sar(96, mul(x, q)))\n            q := add(283447036172924575727196451306956, sar(96, mul(x, q)))\n            q := add(401686690394027663651624208769553, sar(96, mul(x, q)))\n            q := add(204048457590392012362485061816622, sar(96, mul(x, q)))\n            q := add(31853899698501571402653359427138, sar(96, mul(x, q)))\n            q := add(909429971244387300277376558375, sar(96, mul(x, q)))\n\n            // `p / q` is in the range `(0, 0.125) * 2**96`.\n\n            // Finalization, we need to:\n            // - Multiply by the scale factor `s = 5.549\u2026`.\n            // - Add `k * ln(2)`.\n\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already `2**96` too large.\n            p := sdiv(p, q)\n            // Multiply by the scaling factor: `s * 2**96`, base is now `2**192`.\n            p := mul(439668470185123797622540459591, p)\n            // Add `ln(2) * k * 2**192`.\n            // forgefmt: disable-next-item\n            p := add(mul(4350955369971217654477563090224794165364344896676135745069, sub(159, r)), p)\n            // Base conversion: div `2**96`.\n            r := sar(96, p)\n        }\n    }\n\n    function lnQ96RoundingUp(int256 x) internal pure returns (int256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // We place the check here for more optimal stack operations.\n            if iszero(sgt(x, 0)) {\n                mstore(0x00, 0xe65fd7ca) // `LnQ96Undefined()`.\n                revert(0x1c, 0x04)\n            }\n            // forgefmt: disable-next-item\n            r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            x := shr(159, shl(r, x))\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // `p` is made monic, we will multiply by a scale factor later.\n            // forgefmt: disable-next-item\n            let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.\n                sar(96, mul(add(43456485725739037958740375743393,\n                sar(96, mul(add(24828157081833163892658089445524,\n                sar(96, mul(add(3273285459638523848632254066296,\n                    x), x))), x))), x)), 11111509109440967052023855526967)\n            p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)\n            p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)\n            p := sub(mul(p, x), shl(96, 795164235651350426258249787498))\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n\n            // `q` is monic by convention.\n            let q := add(5573035233440673466300451813936, x)\n            q := add(71694874799317883764090561454958, sar(96, mul(x, q)))\n            q := add(283447036172924575727196451306956, sar(96, mul(x, q)))\n            q := add(401686690394027663651624208769553, sar(96, mul(x, q)))\n            q := add(204048457590392012362485061816622, sar(96, mul(x, q)))\n            q := add(31853899698501571402653359427138, sar(96, mul(x, q)))\n            q := add(909429971244387300277376558375, sar(96, mul(x, q)))\n\n            // `p / q` is in the range `(0, 0.125) * 2**96`.\n\n            // Finalization, we need to:\n            // - Multiply by the scale factor `s = 5.549\u2026`.\n            // - Add `k * ln(2)`.\n\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already `2**96` too large.\n            p := sdiv(p, q)\n            // Multiply by the scaling factor: `s * 2**96`, base is now `2**192`.\n            p := mul(439668470185123797622540459591, p)\n            // Add `ln(2) * k * 2**192`.\n            // forgefmt: disable-next-item\n            p := add(mul(4350955369971217654477563090224794165364344896676135745069, sub(159, r)), p)\n            // Base conversion: div `2**96`.\n            r := sar(96, p)\n            // If p % 2**96 is not 0, we need to round up.\n            if and(p, 0xffffffffffffffffffffffff) { r := add(r, 1) }\n        }\n    }\n\n    function getSqrtPriceAtTickWad(int256 tickWad) internal pure returns (uint160 sqrtRatioX96) {\n        sqrtRatioX96 = uint256((HALF_LN_TICK_BASE_Q96 * tickWad / int256(WAD)).expQ96()).toUint160();\n    }\n}\n"}, "src/base/Constants.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\npragma abicoder v2;\n\nuint256 constant WAD = 1e18;\nuint256 constant Q96 = 0x1000000000000000000000000;\nuint256 constant MAX_NONCE = 1e6;\nuint256 constant MIN_INITIAL_SHARES = 1e12;\nuint256 constant MAX_SWAP_FEE_RATIO = 2.88e20; // max ratio that avoids overflow in swap fee calculation, roughly sqrt(SWAP_FEE_BASE) * sqrt(sqrt((type(uint256).max - SWAP_FEE_BASE) / type(uint24).max) - 1)\nuint256 constant SWAP_FEE_BASE = 1e6;\nuint256 constant SWAP_FEE_BASE_SQUARED = 1e12;\nuint256 constant RAW_TOKEN_RATIO_BASE = 1e6;\nuint256 constant LN2_WAD = 693147180559945309;\nuint256 constant MAX_VAULT_FEE_ERROR = 1e6;\nuint256 constant MAX_CARDINALITY = 2 ** 24 - 1;\nuint56 constant WITHDRAW_DELAY = 1 minutes;\nuint56 constant WITHDRAW_GRACE_PERIOD = 3 minutes;\nuint256 constant REFERRAL_REWARD_PER_TOKEN_PRECISION = 1e30;\nuint256 constant MODIFIER_BASE = 1e6;\nuint256 constant MIN_DEPOSIT_BALANCE_INCREASE = 1e6;\nuint24 constant MAX_AMAMM_FEE = 0.1e6;\nuint256 constant REBALANCE_MAX_SLIPPAGE_BASE = 1e5;\nuint16 constant MAX_SURGE_HALFLIFE = 1 hours;\nuint16 constant MAX_SURGE_AUTOSTART_TIME = 1 hours;\nuint16 constant MAX_REBALANCE_MAX_SLIPPAGE = 0.25e5; // max value for rebalanceMaxSlippage is 25%\nuint16 constant MAX_REBALANCE_TWAP_SECONDS_AGO = 3 hours;\nuint16 constant MAX_REBALANCE_ORDER_TTL = 1 hours;\n"}, "src/ldf/LibUniformDistribution.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport {TickMath} from \"@uniswap/v4-core/src/libraries/TickMath.sol\";\n\nimport \"./ShiftMode.sol\";\nimport \"../lib/Math.sol\";\nimport \"../base/Constants.sol\";\nimport {FullMathX96} from \"../lib/FullMathX96.sol\";\nimport {SqrtPriceMath} from \"../lib/SqrtPriceMath.sol\";\n\nlibrary LibUniformDistribution {\n    using TickMath for int24;\n    using TickMath for uint160;\n    using FixedPointMathLib for *;\n    using SafeCastLib for uint256;\n    using FullMathX96 for uint256;\n\n    /// @dev Queries the liquidity density and the cumulative amounts at the given rounded tick.\n    /// @param roundedTick The rounded tick to query\n    /// @param tickSpacing The spacing of the ticks\n    /// @return liquidityDensityX96_ The liquidity density at the given rounded tick. Range is [0, 1]. Scaled by 2^96.\n    /// @return cumulativeAmount0DensityX96 The cumulative amount of token0 in the rounded ticks [roundedTick + tickSpacing, tickUpper)\n    /// @return cumulativeAmount1DensityX96 The cumulative amount of token1 in the rounded ticks [tickLower, roundedTick - tickSpacing]\n    function query(int24 roundedTick, int24 tickSpacing, int24 tickLower, int24 tickUpper)\n        internal\n        pure\n        returns (uint256 liquidityDensityX96_, uint256 cumulativeAmount0DensityX96, uint256 cumulativeAmount1DensityX96)\n    {\n        // compute liquidityDensityX96\n        liquidityDensityX96_ = liquidityDensityX96(roundedTick, tickSpacing, tickLower, tickUpper);\n\n        uint24 length = uint24((tickUpper - tickLower) / tickSpacing);\n        uint256 liquidity = Q96.divUp(length);\n\n        uint160 sqrtRatioTickLower = tickLower.getSqrtPriceAtTick();\n        uint160 sqrtRatioTickUpper = tickUpper.getSqrtPriceAtTick();\n\n        // compute cumulativeAmount0DensityX96 for the rounded tick to the right of the rounded current tick\n        if (roundedTick + tickSpacing >= tickUpper) {\n            // cumulativeAmount0DensityX96 is just 0\n            cumulativeAmount0DensityX96 = 0;\n        } else if (roundedTick + tickSpacing <= tickLower) {\n            cumulativeAmount0DensityX96 =\n                SqrtPriceMath.getAmount0Delta(sqrtRatioTickLower, sqrtRatioTickUpper, liquidity, true);\n        } else {\n            cumulativeAmount0DensityX96 = SqrtPriceMath.getAmount0Delta(\n                (roundedTick + tickSpacing).getSqrtPriceAtTick(), sqrtRatioTickUpper, liquidity, true\n            );\n        }\n\n        // compute cumulativeAmount1DensityX96 for the rounded tick to the left of the rounded current tick\n        if (roundedTick - tickSpacing < tickLower) {\n            // cumulativeAmount1DensityX96 is just 0\n            cumulativeAmount1DensityX96 = 0;\n        } else if (roundedTick >= tickUpper) {\n            cumulativeAmount1DensityX96 =\n                SqrtPriceMath.getAmount1Delta(sqrtRatioTickLower, sqrtRatioTickUpper, liquidity, true);\n        } else {\n            cumulativeAmount1DensityX96 =\n                SqrtPriceMath.getAmount1Delta(sqrtRatioTickLower, roundedTick.getSqrtPriceAtTick(), liquidity, true);\n        }\n    }\n\n    /// @dev Computes the cumulative amount of token0 in the rounded ticks [roundedTick, tickUpper).\n    function cumulativeAmount0(\n        int24 roundedTick,\n        uint256 totalLiquidity,\n        int24 tickSpacing,\n        int24 tickLower,\n        int24 tickUpper,\n        bool isCarpet\n    ) internal pure returns (uint256 amount0) {\n        if (roundedTick >= tickUpper || tickLower >= tickUpper) {\n            // cumulativeAmount0DensityX96 is just 0\n            return 0;\n        } else if (roundedTick < tickLower) {\n            roundedTick = tickLower;\n        }\n\n        uint24 length = uint24((tickUpper - tickLower) / tickSpacing);\n        uint160 sqrtRatioTickUpper = tickUpper.getSqrtPriceAtTick();\n        amount0 = isCarpet\n            ? SqrtPriceMath.getAmount0Delta(\n                roundedTick.getSqrtPriceAtTick(), sqrtRatioTickUpper, totalLiquidity.divUp(length), true\n            )\n            : totalLiquidity.fullMulX96Up(\n                SqrtPriceMath.getAmount0Delta(roundedTick.getSqrtPriceAtTick(), sqrtRatioTickUpper, Q96.divUp(length), true)\n            );\n    }\n\n    /// @dev Computes the cumulative amount of token1 in the rounded ticks [tickLower, roundedTick].\n    function cumulativeAmount1(\n        int24 roundedTick,\n        uint256 totalLiquidity,\n        int24 tickSpacing,\n        int24 tickLower,\n        int24 tickUpper,\n        bool isCarpet\n    ) internal pure returns (uint256 amount1) {\n        if (roundedTick < tickLower || tickLower >= tickUpper) {\n            // cumulativeAmount1DensityX96 is just 0\n            return 0;\n        } else if (roundedTick > tickUpper - tickSpacing) {\n            roundedTick = tickUpper - tickSpacing;\n        }\n\n        uint24 length = uint24((tickUpper - tickLower) / tickSpacing);\n        uint160 sqrtRatioTickLower = tickLower.getSqrtPriceAtTick();\n        amount1 = isCarpet\n            ? SqrtPriceMath.getAmount1Delta(\n                sqrtRatioTickLower, (roundedTick + tickSpacing).getSqrtPriceAtTick(), totalLiquidity.divUp(length), true\n            )\n            : totalLiquidity.fullMulX96Up(\n                SqrtPriceMath.getAmount1Delta(\n                    sqrtRatioTickLower, (roundedTick + tickSpacing).getSqrtPriceAtTick(), Q96.divUp(length), true\n                )\n            );\n    }\n\n    /// @dev Given a cumulativeAmount0, computes the rounded tick whose cumulativeAmount0 is closest to the input. Range is [tickLower, tickUpper].\n    ///      The returned tick will be the largest rounded tick whose cumulativeAmount0 is greater than or equal to the input.\n    ///      In the case that the input exceeds the cumulativeAmount0 of all rounded ticks, the function will return (false, 0).\n    function inverseCumulativeAmount0(\n        uint256 cumulativeAmount0_,\n        uint256 totalLiquidity,\n        int24 tickSpacing,\n        int24 tickLower,\n        int24 tickUpper\n    ) internal pure returns (bool success, int24 roundedTick) {\n        // short circuit if cumulativeAmount0_ is 0\n        if (cumulativeAmount0_ == 0) return (true, tickUpper);\n\n        uint24 length = uint24((tickUpper - tickLower) / tickSpacing);\n        uint256 liquidity = totalLiquidity.divUp(length);\n\n        uint160 sqrtRatioTickLower = tickLower.getSqrtPriceAtTick();\n        uint160 sqrtRatioTickUpper = tickUpper.getSqrtPriceAtTick();\n        uint160 sqrtPrice =\n            SqrtPriceMath.getNextSqrtPriceFromAmount0RoundingUp(sqrtRatioTickUpper, liquidity, cumulativeAmount0_, true);\n        if (sqrtPrice < sqrtRatioTickLower) {\n            return (false, 0);\n        }\n        int24 tick = sqrtPrice.getTickAtSqrtPrice();\n        success = true;\n        roundedTick = roundTickSingle(tick, tickSpacing);\n\n        // ensure roundedTick is within the valid range\n        if (roundedTick < tickLower || roundedTick > tickUpper) {\n            return (false, 0);\n        }\n\n        // ensure that roundedTick is not tickUpper when cumulativeAmount0_ is non-zero\n        // this can happen if the corresponding cumulative density is too small\n        if (roundedTick == tickUpper && cumulativeAmount0_ != 0) {\n            return (true, tickUpper - tickSpacing);\n        }\n    }\n\n    /// @dev Given a cumulativeAmount1, computes the rounded tick whose cumulativeAmount1 is closest to the input. Range is [tickLower - tickSpacing, tickUpper - tickSpacing].\n    ///      The returned tick will be the smallest rounded tick whose cumulativeAmount1 is greater than or equal to the input.\n    ///      In the case that the input exceeds the cumulativeAmount1 of all rounded ticks, the function will return (false, 0).\n    function inverseCumulativeAmount1(\n        uint256 cumulativeAmount1_,\n        uint256 totalLiquidity,\n        int24 tickSpacing,\n        int24 tickLower,\n        int24 tickUpper\n    ) internal pure returns (bool success, int24 roundedTick) {\n        // short circuit if cumulativeAmount1_ is 0\n        if (cumulativeAmount1_ == 0) return (true, tickLower - tickSpacing);\n\n        uint24 length = uint24((tickUpper - tickLower) / tickSpacing);\n        uint256 liquidity = totalLiquidity.divUp(length);\n\n        uint160 sqrtRatioTickLower = tickLower.getSqrtPriceAtTick();\n        uint160 sqrtRatioTickUpper = tickUpper.getSqrtPriceAtTick();\n        uint160 sqrtPrice = SqrtPriceMath.getNextSqrtPriceFromAmount1RoundingDown(\n            sqrtRatioTickLower, liquidity, cumulativeAmount1_, true\n        );\n        if (sqrtPrice > sqrtRatioTickUpper) {\n            return (false, 0);\n        }\n        int24 tick = sqrtPrice.getTickAtSqrtPrice();\n        // handle the edge case where cumulativeAmount1_ is exactly the\n        // cumulative amount in [tickLower, tickUpper]\n        if (tick == tickUpper) {\n            tick -= 1;\n        }\n        success = true;\n        roundedTick = roundTickSingle(tick, tickSpacing);\n\n        // ensure roundedTick is within the valid range\n        if (roundedTick < tickLower - tickSpacing || roundedTick >= tickUpper) {\n            return (false, 0);\n        }\n\n        // ensure that roundedTick is not (tickLower - tickSpacing) when cumulativeAmount1_ is non-zero and rounding up\n        // this can happen if the corresponding cumulative density is too small\n        if (roundedTick == tickLower - tickSpacing && cumulativeAmount1_ != 0) {\n            return (true, tickLower);\n        }\n    }\n\n    function liquidityDensityX96(int24 roundedTick, int24 tickSpacing, int24 tickLower, int24 tickUpper)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (roundedTick < tickLower || roundedTick >= tickUpper) {\n            // roundedTick is outside of the distribution\n            return 0;\n        }\n        uint256 length = uint24((tickUpper - tickLower) / tickSpacing);\n        return Q96 / length;\n    }\n\n    /// @dev Combines several operations used during a swap into one function to save gas.\n    ///      Given a cumulative amount, it computes its inverse to find the closest rounded tick, then computes the cumulative amount at that tick,\n    ///      and finally computes the liquidity of the tick that will handle the remainder of the swap.\n    function computeSwap(\n        uint256 inverseCumulativeAmountInput,\n        uint256 totalLiquidity,\n        bool zeroForOne,\n        bool exactIn,\n        int24 tickSpacing,\n        int24 tickLower,\n        int24 tickUpper\n    )\n        internal\n        pure\n        returns (\n            bool success,\n            int24 roundedTick,\n            uint256 cumulativeAmount0_,\n            uint256 cumulativeAmount1_,\n            uint256 swapLiquidity\n        )\n    {\n        if (exactIn == zeroForOne) {\n            // compute roundedTick by inverting the cumulative amount\n            // below is an illustration of 4 rounded ticks, the input amount, and the resulting roundedTick (rick)\n            // notice that the inverse tick is between two rounded ticks, and we round down to the rounded tick to the left\n            // e.g. go from 1.5 to 1\n            //       input\n            //      \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //    \u2502\n            //    \u25bc\n            //   rick\n            (success, roundedTick) = inverseCumulativeAmount0(\n                inverseCumulativeAmountInput, totalLiquidity, tickSpacing, tickLower, tickUpper\n            );\n            if (!success) return (false, 0, 0, 0, 0);\n\n            // compute the cumulative amount up to roundedTick\n            // below is an illustration of the cumulative amount at roundedTick\n            // notice that exactIn ? (input - cum) : (cum - input) is the remainder of the swap that will be handled by Uniswap math\n            // exactIn:\n            //         cum\n            //       \u251c\u2500\u2500\u2500\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //       \u2502\n            //       \u25bc\n            //      rick + tickSpacing\n            // exactOut:\n            //        cum\n            //    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //    \u2502\n            //    \u25bc\n            //   rick\n            cumulativeAmount0_ = exactIn\n                ? cumulativeAmount0(roundedTick + tickSpacing, totalLiquidity, tickSpacing, tickLower, tickUpper, false)\n                : cumulativeAmount0(roundedTick, totalLiquidity, tickSpacing, tickLower, tickUpper, false);\n\n            // compute the cumulative amount of the complementary token\n            // below is an illustration\n            // exactIn:\n            //   cum\n            // \u251c\u2500\u2500\u2500\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //    \u2502\n            //    \u25bc\n            //   rick\n            // exactOut:\n            //  cum\n            // \u251c\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            // \u2502\n            // \u25bc\n            //rick - tickSpacing\n            cumulativeAmount1_ = exactIn\n                ? cumulativeAmount1(roundedTick, totalLiquidity, tickSpacing, tickLower, tickUpper, false)\n                : cumulativeAmount1(roundedTick - tickSpacing, totalLiquidity, tickSpacing, tickLower, tickUpper, false);\n\n            // compute liquidity of the rounded tick that will handle the remainder of the swap\n            // below is an illustration of the liquidity of the rounded tick that will handle the remainder of the swap\n            //    liq\n            //    \u251c\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //    \u2502\n            //    \u25bc\n            //   rick\n            swapLiquidity = (liquidityDensityX96(roundedTick, tickSpacing, tickLower, tickUpper) * totalLiquidity) >> 96;\n        } else {\n            // compute roundedTick by inverting the cumulative amount\n            // below is an illustration of 4 rounded ticks, the input amount, and the resulting roundedTick (rick)\n            // notice that the inverse tick is between two rounded ticks, and we round up to the rounded tick to the right\n            // e.g. go from 1.5 to 2\n            //  input\n            // \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //       \u2502\n            //       \u25bc\n            //      rick\n            (success, roundedTick) = inverseCumulativeAmount1(\n                inverseCumulativeAmountInput, totalLiquidity, tickSpacing, tickLower, tickUpper\n            );\n            if (!success) return (false, 0, 0, 0, 0);\n\n            // compute the cumulative amount up to roundedTick\n            // below is an illustration of the cumulative amount at roundedTick\n            // notice that exactIn ? (input - cum) : (cum - input) is the remainder of the swap that will be handled by Uniswap math\n            // exactIn:\n            //   cum\n            // \u251c\u2500\u2500\u2500\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //    \u2502\n            //    \u25bc\n            //   rick - tickSpacing\n            // exactOut:\n            //     cum\n            // \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //       \u2502\n            //       \u25bc\n            //      rick\n            cumulativeAmount1_ = exactIn\n                ? cumulativeAmount1(roundedTick - tickSpacing, totalLiquidity, tickSpacing, tickLower, tickUpper, false)\n                : cumulativeAmount1(roundedTick, totalLiquidity, tickSpacing, tickLower, tickUpper, false);\n\n            // compute the cumulative amount of the complementary token\n            // below is an illustration\n            // exactIn:\n            //         cum\n            //       \u251c\u2500\u2500\u2500\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //       \u2502\n            //       \u25bc\n            //      rick\n            // exactOut:\n            //           cum\n            //          \u251c\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //          \u2502\n            //          \u25bc\n            //         rick + tickSpacing\n            cumulativeAmount0_ = exactIn\n                ? cumulativeAmount0(roundedTick, totalLiquidity, tickSpacing, tickLower, tickUpper, false)\n                : cumulativeAmount0(roundedTick + tickSpacing, totalLiquidity, tickSpacing, tickLower, tickUpper, false);\n\n            // compute liquidity of the rounded tick that will handle the remainder of the swap\n            // below is an illustration of the liquidity of the rounded tick that will handle the remainder of the swap\n            //       liq\n            //       \u251c\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //       \u2502\n            //       \u25bc\n            //      rick\n            swapLiquidity = (liquidityDensityX96(roundedTick, tickSpacing, tickLower, tickUpper) * totalLiquidity) >> 96;\n        }\n    }\n\n    function isValidParams(int24 tickSpacing, uint24 twapSecondsAgo, bytes32 ldfParams) internal pure returns (bool) {\n        uint8 shiftMode = uint8(bytes1(ldfParams)); // use uint8 since we don't know if the value is in range yet\n        if (shiftMode != uint8(ShiftMode.STATIC)) {\n            // Shifting\n            // | shiftMode - 1 byte | offset - 3 bytes | length - 3 bytes |\n            int24 offset = int24(uint24(bytes3(ldfParams << 8))); // offset (in rounded ticks) of tickLower from the twap tick\n            int24 length = int24(uint24(bytes3(ldfParams << 32))); // length of the position in rounded ticks\n\n            return twapSecondsAgo != 0 && length > 0 && offset % tickSpacing == 0\n                && int256(length) * int256(tickSpacing) <= type(int24).max && shiftMode <= uint8(type(ShiftMode).max);\n        } else {\n            // Static\n            // | shiftMode - 1 byte | tickLower - 3 bytes | tickUpper - 3 bytes |\n            int24 tickLower = int24(uint24(bytes3(ldfParams << 8)));\n            int24 tickUpper = int24(uint24(bytes3(ldfParams << 32)));\n            (int24 minUsableTick, int24 maxUsableTick) =\n                (TickMath.minUsableTick(tickSpacing), TickMath.maxUsableTick(tickSpacing));\n            return tickLower % tickSpacing == 0 && tickUpper % tickSpacing == 0 && tickLower < tickUpper\n                && tickLower >= minUsableTick && tickUpper <= maxUsableTick;\n        }\n    }\n\n    /// @return tickLower The lower tick of the distribution\n    /// @return tickUpper The upper tick of the distribution\n    function decodeParams(int24 twapTick, int24 tickSpacing, bytes32 ldfParams)\n        internal\n        pure\n        returns (int24 tickLower, int24 tickUpper, ShiftMode shiftMode)\n    {\n        shiftMode = ShiftMode(uint8(bytes1(ldfParams)));\n\n        if (shiftMode != ShiftMode.STATIC) {\n            // | shiftMode - 1 byte | offset - 3 bytes | length - 3 bytes |\n            int24 offset = int24(uint24(bytes3(ldfParams << 8))); // offset of tickLower from the twap tick\n            int24 length = int24(uint24(bytes3(ldfParams << 32))); // length of the position in rounded ticks\n            tickLower = roundTickSingle(twapTick + offset, tickSpacing);\n            tickUpper = tickLower + length * tickSpacing;\n\n            // bound distribution to be within the range of usable ticks\n            (int24 minUsableTick, int24 maxUsableTick) =\n                (TickMath.minUsableTick(tickSpacing), TickMath.maxUsableTick(tickSpacing));\n            if (tickLower < minUsableTick) {\n                int24 tickLength = tickUpper - tickLower;\n                tickLower = minUsableTick;\n                tickUpper = int24(FixedPointMathLib.min(tickLower + tickLength, maxUsableTick));\n            } else if (tickUpper > maxUsableTick) {\n                int24 tickLength = tickUpper - tickLower;\n                tickUpper = maxUsableTick;\n                tickLower = int24(FixedPointMathLib.max(tickUpper - tickLength, minUsableTick));\n            }\n        } else {\n            // | shiftMode - 1 byte | tickLower - 3 bytes | tickUpper - 3 bytes |\n            tickLower = int24(uint24(bytes3(ldfParams << 8)));\n            tickUpper = int24(uint24(bytes3(ldfParams << 32)));\n        }\n    }\n}\n"}, "src/ldf/LibGeometricDistribution.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport {TickMath} from \"@uniswap/v4-core/src/libraries/TickMath.sol\";\n\nimport \"./ShiftMode.sol\";\nimport \"../lib/Math.sol\";\nimport \"../lib/ExpMath.sol\";\nimport \"../base/Constants.sol\";\nimport {FullMathX96} from \"../lib/FullMathX96.sol\";\n\nlibrary LibGeometricDistribution {\n    using FullMathX96 for *;\n    using TickMath for int24;\n    using ExpMath for int256;\n    using SafeCastLib for *;\n    using FixedPointMathLib for *;\n\n    uint256 internal constant ALPHA_BASE = 1e8; // alpha uses 8 decimals in ldfParams\n    uint256 internal constant MIN_ALPHA = 1e3;\n    uint256 internal constant MAX_ALPHA = 12e8;\n    uint256 internal constant MIN_LIQUIDITY_DENSITY = Q96 / 1e3;\n\n    /// @dev Queries the liquidity density and the cumulative amounts at the given rounded tick.\n    /// @param roundedTick The rounded tick to query\n    /// @param tickSpacing The spacing of the ticks\n    /// @return liquidityDensityX96_ The liquidity density at the given rounded tick. Range is [0, 1]. Scaled by 2^96.\n    /// @return cumulativeAmount0DensityX96 The cumulative amount of token0 in the rounded ticks [roundedTick + tickSpacing, minTick + length * tickSpacing)\n    /// @return cumulativeAmount1DensityX96 The cumulative amount of token1 in the rounded ticks [minTick, roundedTick - tickSpacing]\n    function query(int24 roundedTick, int24 tickSpacing, int24 minTick, int24 length, uint256 alphaX96)\n        internal\n        pure\n        returns (uint256 liquidityDensityX96_, uint256 cumulativeAmount0DensityX96, uint256 cumulativeAmount1DensityX96)\n    {\n        // compute liquidityDensityX96\n        liquidityDensityX96_ = liquidityDensityX96(roundedTick, tickSpacing, minTick, length, alphaX96);\n\n        // x is the index of the roundedTick in the distribution\n        // should be in the range [0, length)\n        int24 x;\n        if (roundedTick < minTick) {\n            // roundedTick is to the left of the distribution\n            // set x = -1\n            x = -1;\n        } else if (roundedTick >= minTick + length * tickSpacing) {\n            // roundedTick is to the right of the distribution\n            // set x = length\n            x = length;\n        } else {\n            // roundedTick is in the distribution\n            x = (roundedTick - minTick) / tickSpacing;\n        }\n\n        uint256 sqrtRatioTickSpacing = tickSpacing.getSqrtPriceAtTick();\n        uint256 sqrtRatioNegTickSpacing = (-tickSpacing).getSqrtPriceAtTick();\n        uint256 sqrtRatioMinTick = minTick.getSqrtPriceAtTick();\n        uint256 sqrtRatioNegMinTick = (-minTick).getSqrtPriceAtTick();\n\n        if (alphaX96 > Q96) {\n            // alpha > 1\n            // need to make sure that alpha^x doesn't overflow by using alpha^-1 during exponentiation\n            uint256 alphaInvX96 = Q96.mulDiv(Q96, alphaX96);\n\n            // compute cumulativeAmount0DensityX96 for the rounded tick to the right of the rounded current tick\n            if (x >= length - 1) {\n                // roundedTick is the last tick in the distribution\n                // cumulativeAmount0DensityX96 is just 0\n                cumulativeAmount0DensityX96 = 0;\n            } else {\n                int24 xPlus1 = x + 1; // the rounded tick to the right of the current rounded tick\n\n                uint24 lengthMinusX = uint24(length - xPlus1);\n                bool intermediateTermIsPositive = alphaInvX96 > sqrtRatioNegTickSpacing;\n                uint256 numeratorTermLeft = alphaInvX96.rpow(lengthMinusX, Q96);\n                uint256 numeratorTermRight = (-tickSpacing * int24(lengthMinusX)).getSqrtPriceAtTick();\n                cumulativeAmount0DensityX96 = (Q96 - alphaInvX96).mulDivUp(\n                    intermediateTermIsPositive\n                        ? numeratorTermLeft - numeratorTermRight\n                        : numeratorTermRight - numeratorTermLeft,\n                    intermediateTermIsPositive\n                        ? alphaInvX96 - sqrtRatioNegTickSpacing\n                        : sqrtRatioNegTickSpacing - alphaInvX96\n                ).mulDivUp((-tickSpacing * xPlus1).getSqrtPriceAtTick(), Q96 - alphaInvX96.rpow(uint24(length), Q96))\n                    .mulDivUp(Q96 - sqrtRatioNegTickSpacing, sqrtRatioMinTick);\n            }\n\n            // compute cumulativeAmount1DensityX96 for the rounded tick to the left of the rounded current tick\n            if (x <= 0) {\n                // roundedTick is the first tick in the distribution\n                // cumulativeAmount1DensityX96 is just 0\n                cumulativeAmount1DensityX96 = 0;\n            } else {\n                uint256 alphaInvPowLengthX96 = alphaInvX96.rpow(uint24(length), Q96);\n\n                uint256 baseX96 = alphaX96.mulDiv(sqrtRatioTickSpacing, Q96);\n                uint256 numerator1 = alphaX96 - Q96;\n                uint256 denominator1 = baseX96 - Q96;\n                uint256 numerator2 = alphaInvX96.rpow(uint24(length - x), Q96).mulDivUp(\n                    (x * tickSpacing).getSqrtPriceAtTick(), Q96\n                ) - alphaInvPowLengthX96;\n                uint256 denominator2 = Q96 - alphaInvPowLengthX96;\n                cumulativeAmount1DensityX96 = Q96.mulDivUp(numerator2, denominator2).mulDivUp(numerator1, denominator1)\n                    .mulDivUp(sqrtRatioTickSpacing - Q96, sqrtRatioNegMinTick);\n            }\n        } else {\n            // alpha <= 1\n            // will revert if alpha == 1 but that's ok\n\n            // compute cumulativeAmount0DensityX96 for the rounded tick to the right of the rounded current tick\n            if (x >= length - 1) {\n                // roundedTick is the last tick in the distribution\n                // cumulativeAmount0DensityX96 is just 0\n                cumulativeAmount0DensityX96 = 0;\n            } else {\n                uint256 baseX96 = alphaX96.mulDiv(sqrtRatioNegTickSpacing, Q96);\n                int24 xPlus1 = x + 1;\n                uint256 alphaPowXX96 = alphaX96.rpow(uint24(xPlus1), Q96);\n                uint256 alphaPowLengthX96 = alphaX96.rpow(uint24(length), Q96);\n                uint256 numerator = (Q96 - alphaX96)\n                    * (\n                        alphaPowXX96.mulDivUp((-tickSpacing * xPlus1).getSqrtPriceAtTick(), Q96)\n                            - alphaPowLengthX96.mulDivUp((-tickSpacing * length).getSqrtPriceAtTick(), Q96)\n                    );\n                uint256 denominator = (Q96 - alphaPowLengthX96) * (Q96 - baseX96);\n                cumulativeAmount0DensityX96 =\n                    (Q96 - sqrtRatioNegTickSpacing).fullMulDivUp(numerator, denominator).mulDivUp(Q96, sqrtRatioMinTick);\n            }\n\n            // compute cumulativeAmount1DensityX96 for the rounded tick to the left of the rounded current tick\n            if (x <= 0) {\n                // roundedTick is the first tick in the distribution\n                // cumulativeAmount1DensityX96 is just 0\n                cumulativeAmount1DensityX96 = 0;\n            } else {\n                uint256 baseX96 = alphaX96.mulDiv(sqrtRatioTickSpacing, Q96);\n                uint256 numerator = dist(\n                    Q96, alphaX96.rpow(uint24(x), Q96).mulDivUp((tickSpacing * x).getSqrtPriceAtTick(), Q96)\n                ) * (Q96 - alphaX96);\n                uint256 denominator = dist(Q96, baseX96) * (Q96 - alphaX96.rpow(uint24(length), Q96));\n                cumulativeAmount1DensityX96 =\n                    (sqrtRatioTickSpacing - Q96).fullMulDivUp(numerator, denominator).mulDivUp(sqrtRatioMinTick, Q96);\n            }\n        }\n    }\n\n    /// @dev Computes the cumulative amount of token0 in the rounded ticks [roundedTick, tickUpper).\n    function cumulativeAmount0(\n        int24 roundedTick,\n        uint256 totalLiquidity,\n        int24 tickSpacing,\n        int24 minTick,\n        int24 length,\n        uint256 alphaX96\n    ) internal pure returns (uint256 amount0) {\n        uint256 cumulativeAmount0DensityX96;\n\n        // x is the index of the roundedTick in the distribution\n        // should be in the range [0, length)\n        int24 x;\n        if (roundedTick < minTick) {\n            // roundedTick is to the left of the distribution\n            x = 0;\n        } else if (roundedTick >= minTick + length * tickSpacing) {\n            // roundedTick is to the right of the distribution\n            return 0;\n        } else {\n            // roundedTick is in the distribution\n            x = (roundedTick - minTick) / tickSpacing;\n        }\n\n        uint256 sqrtRatioNegTickSpacing = (-tickSpacing).getSqrtPriceAtTick();\n        uint256 sqrtRatioMinTick = minTick.getSqrtPriceAtTick();\n\n        if (alphaX96 > Q96) {\n            // alpha > 1\n            // need to make sure that alpha^x doesn't overflow by using alpha^-1 during exponentiation\n            uint256 alphaInvX96 = Q96.mulDiv(Q96, alphaX96);\n\n            // compute cumulativeAmount0DensityX96 for the rounded tick to the right of the rounded current tick\n            if (x >= length) {\n                // roundedTick is to the right of the last tick in the distribution\n                // amount0 is just 0\n                amount0 = 0;\n            } else {\n                uint24 lengthMinusX = uint24(length - x);\n                bool intermediateTermIsPositive = alphaInvX96 > sqrtRatioNegTickSpacing;\n                uint256 numeratorTermLeft = alphaInvX96.rpow(lengthMinusX, Q96);\n                uint256 numeratorTermRight = (-tickSpacing * int24(lengthMinusX)).getSqrtPriceAtTick();\n                cumulativeAmount0DensityX96 = (Q96 - alphaInvX96).mulDivUp(\n                    intermediateTermIsPositive\n                        ? numeratorTermLeft - numeratorTermRight\n                        : numeratorTermRight - numeratorTermLeft,\n                    intermediateTermIsPositive\n                        ? alphaInvX96 - sqrtRatioNegTickSpacing\n                        : sqrtRatioNegTickSpacing - alphaInvX96\n                ).mulDivUp((-tickSpacing * x).getSqrtPriceAtTick(), Q96 - alphaInvX96.rpow(uint24(length), Q96))\n                    .mulDivUp(Q96 - sqrtRatioNegTickSpacing, sqrtRatioMinTick);\n            }\n        } else {\n            // alpha <= 1\n            // will revert if alpha == 1 but that's ok\n\n            // compute cumulativeAmount0DensityX96 for the rounded tick to the right of the rounded current tick\n            if (x >= length) {\n                // roundedTick is to the right of the last tick in the distribution\n                // amount0 is just 0\n                amount0 = 0;\n            } else {\n                uint256 baseX96 = alphaX96.mulDiv(sqrtRatioNegTickSpacing, Q96);\n                uint256 alphaPowXX96 = alphaX96.rpow(uint24(x), Q96);\n                uint256 alphaPowLengthX96 = alphaX96.rpow(uint24(length), Q96);\n                uint256 numerator = (Q96 - alphaX96)\n                    * (\n                        alphaPowXX96.mulDivUp((-tickSpacing * x).getSqrtPriceAtTick(), Q96)\n                            - alphaPowLengthX96.mulDivUp((-tickSpacing * length).getSqrtPriceAtTick(), Q96)\n                    );\n                uint256 denominator = (Q96 - alphaPowLengthX96) * (Q96 - baseX96);\n\n                cumulativeAmount0DensityX96 = (Q96 - sqrtRatioNegTickSpacing).fullMulDivUp(numerator, denominator)\n                    .fullMulDivUp(Q96, sqrtRatioMinTick);\n            }\n        }\n\n        amount0 = cumulativeAmount0DensityX96.fullMulX96Up(totalLiquidity);\n    }\n\n    /// @dev Computes the cumulative amount of token1 in the rounded ticks [tickLower, roundedTick].\n    function cumulativeAmount1(\n        int24 roundedTick,\n        uint256 totalLiquidity,\n        int24 tickSpacing,\n        int24 minTick,\n        int24 length,\n        uint256 alphaX96\n    ) internal pure returns (uint256 amount1) {\n        uint256 cumulativeAmount1DensityX96;\n\n        // x is the index of the roundedTick in the distribution\n        // should be in the range [0, length)\n        int24 x;\n        if (roundedTick < minTick) {\n            // roundedTick is to the left of the distribution\n            return 0;\n        } else if (roundedTick >= minTick + length * tickSpacing) {\n            // roundedTick is to the right of the distribution\n            // set x = length\n            x = length - 1;\n        } else {\n            // roundedTick is in the distribution\n            x = (roundedTick - minTick) / tickSpacing;\n        }\n\n        uint256 sqrtRatioTickSpacing = tickSpacing.getSqrtPriceAtTick();\n\n        if (alphaX96 > Q96) {\n            // alpha > 1\n            // need to make sure that alpha^x doesn't overflow by using alpha^-1 during exponentiation\n            uint256 alphaInvX96 = Q96.mulDiv(Q96, alphaX96);\n\n            // compute cumulativeAmount1DensityX96 for the rounded tick to the left of the rounded current tick\n            if (x < 0) {\n                // roundedTick is to the left of the first tick in the distribution\n                // cumulativeAmount1DensityX96 is just 0\n                cumulativeAmount1DensityX96 = 0;\n            } else {\n                uint256 alphaInvPowLengthX96 = alphaInvX96.rpow(uint24(length), Q96);\n                uint256 sqrtRatioNegMinTick = (-minTick).getSqrtPriceAtTick();\n\n                uint256 baseX96 = alphaX96.mulDiv(sqrtRatioTickSpacing, Q96);\n                uint256 numerator1 = alphaX96 - Q96;\n                uint256 denominator1 = baseX96 - Q96;\n                uint256 numerator2 = alphaInvX96.rpow(uint24(length - x - 1), Q96).mulDivUp(\n                    ((x + 1) * tickSpacing).getSqrtPriceAtTick(), Q96\n                ) - alphaInvPowLengthX96;\n                uint256 denominator2 = Q96 - alphaInvPowLengthX96;\n                cumulativeAmount1DensityX96 = Q96.mulDivUp(numerator2, denominator2).mulDivUp(numerator1, denominator1)\n                    .mulDivUp(sqrtRatioTickSpacing - Q96, sqrtRatioNegMinTick);\n            }\n        } else {\n            // alpha <= 1\n            // will revert if alpha == 1 but that's ok\n\n            // compute cumulativeAmount1DensityX96 for the rounded tick to the left of the rounded current tick\n            if (x < 0) {\n                // roundedTick is to the left of the first tick in the distribution\n                // cumulativeAmount1DensityX96 is just 0\n                cumulativeAmount1DensityX96 = 0;\n            } else {\n                uint256 sqrtRatioMinTick = minTick.getSqrtPriceAtTick();\n                uint256 baseX96 = alphaX96.mulDiv(sqrtRatioTickSpacing, Q96);\n                uint256 numerator = dist(\n                    Q96, alphaX96.rpow(uint24(x + 1), Q96).mulDivUp((tickSpacing * (x + 1)).getSqrtPriceAtTick(), Q96)\n                ) * (Q96 - alphaX96);\n                uint256 denominator = dist(Q96, baseX96) * (Q96 - alphaX96.rpow(uint24(length), Q96));\n                cumulativeAmount1DensityX96 =\n                    (sqrtRatioTickSpacing - Q96).fullMulDivUp(numerator, denominator).mulDivUp(sqrtRatioMinTick, Q96);\n            }\n        }\n\n        amount1 = cumulativeAmount1DensityX96.fullMulX96Up(totalLiquidity);\n    }\n\n    /// @dev Given a cumulativeAmount0, computes the rounded tick whose cumulativeAmount0 is closest to the input. Range is [tickLower, tickUpper].\n    ///      The returned tick will be the largest rounded tick whose cumulativeAmount0 is greater than or equal to the input.\n    ///      In the case that the input exceeds the cumulativeAmount0 of all rounded ticks, the function will return (false, 0).\n    function inverseCumulativeAmount0(\n        uint256 cumulativeAmount0_,\n        uint256 totalLiquidity,\n        int24 tickSpacing,\n        int24 minTick,\n        int24 length,\n        uint256 alphaX96\n    ) internal pure returns (bool success, int24 roundedTick) {\n        if (cumulativeAmount0_ == 0) {\n            // return right boundary of distribution\n            return (true, minTick + length * tickSpacing);\n        }\n\n        uint256 cumulativeAmount0DensityX96 = cumulativeAmount0_.fullMulDivUp(Q96, totalLiquidity);\n        uint256 sqrtRatioNegTickSpacing = (-tickSpacing).getSqrtPriceAtTick();\n        uint256 sqrtRatioMinTick = minTick.getSqrtPriceAtTick();\n        uint256 baseX96 = alphaX96.mulDiv(sqrtRatioNegTickSpacing, Q96);\n        int256 lnBaseX96 = int256(baseX96).lnQ96(); // int256 conversion is safe since baseX96 < Q96\n\n        int256 xWad;\n        if (alphaX96 > Q96) {\n            // alpha > 1\n            // need to make sure that alpha^x doesn't overflow by using alpha^-1 during exponentiation\n            uint256 alphaInvX96 = Q96.mulDiv(Q96, alphaX96);\n\n            uint256 alphaInvPowLengthX96 = alphaInvX96.rpow(uint24(length), Q96);\n            bool intermediateTermIsPositive = alphaInvX96 > sqrtRatioNegTickSpacing;\n            uint256 tmp = cumulativeAmount0DensityX96.mulDivUp(sqrtRatioMinTick, Q96 - sqrtRatioNegTickSpacing).mulDivUp(\n                Q96 - alphaInvPowLengthX96, Q96\n            ).mulDivUp(\n                intermediateTermIsPositive\n                    ? alphaInvX96 - sqrtRatioNegTickSpacing\n                    : sqrtRatioNegTickSpacing - alphaInvX96,\n                Q96 - alphaInvX96\n            );\n            uint160 sqrtPriceNegTickSpacingMulLength = (-tickSpacing * length).getSqrtPriceAtTick();\n            if (!intermediateTermIsPositive && sqrtPriceNegTickSpacingMulLength <= tmp) {\n                // this usually happens when the maximum cumulativeAmount0 is very close to zero\n                // check to see that cumulativeAmount0_ <= cumulativeAmount0(minTick + (length - 1) * tickSpacing)\n                int24 result = minTick + (length - 1) * tickSpacing;\n                if (\n                    cumulativeAmount0_\n                        <= cumulativeAmount0(result, totalLiquidity, tickSpacing, minTick, length, alphaX96)\n                ) {\n                    return (true, result);\n                } else {\n                    return (false, 0);\n                }\n            }\n            tmp = intermediateTermIsPositive\n                ? tmp + sqrtPriceNegTickSpacingMulLength\n                : sqrtPriceNegTickSpacingMulLength - tmp;\n            xWad = (tmp.toInt256().lnQ96RoundingUp() + int256(length) * (int256(alphaX96).lnQ96RoundingUp())).sDivWad(\n                lnBaseX96\n            );\n        } else {\n            uint256 denominator = (Q96 - alphaX96.rpow(uint24(length), Q96)) * (Q96 - baseX96);\n            uint256 numerator = cumulativeAmount0DensityX96.mulDivUp(sqrtRatioMinTick, Q96).fullMulDivUp(\n                denominator, Q96 - sqrtRatioNegTickSpacing\n            );\n            uint256 basePowXX96 = (numerator / (Q96 - alphaX96) + baseX96.rpow(uint24(length), Q96));\n            xWad = basePowXX96.toInt256().lnQ96RoundingUp().sDivWad(lnBaseX96);\n        }\n\n        // early return if xWad is obviously too small\n        // the result (the largest rounded tick whose cumulativeAmount0 is greater than or equal to the input) doesn't exist\n        // thus return success = false\n        if (xWad < 0) {\n            // compare cumulativeAmount0_ with the max value of cumulativeAmount0()\n            // due to precision errors sometimes xWad can be negative when cumulativeAmount0_\n            // is close to the max value\n            uint256 maxCumulativeAmount0 =\n                cumulativeAmount0(minTick, totalLiquidity, tickSpacing, minTick, length, alphaX96);\n            if (cumulativeAmount0_ > maxCumulativeAmount0) {\n                return (false, 0);\n            } else {\n                // xWad shouldn't actually be negative\n                // set it to 0\n                xWad = 0;\n            }\n        }\n\n        // get rounded tick from xWad\n        success = true;\n        roundedTick = xWadToRoundedTick(xWad, minTick, tickSpacing, false);\n\n        // ensure roundedTick is within the valid range\n        int24 maxTick = minTick + length * tickSpacing;\n        if (roundedTick < minTick || roundedTick > maxTick) {\n            return (false, 0);\n        }\n\n        // ensure that roundedTick is not minTick + length * tickSpacing when cumulativeAmount0_ is non-zero\n        // this can happen if the corresponding cumulative density is too small\n        if (roundedTick == maxTick && cumulativeAmount0_ != 0) {\n            return (true, maxTick - tickSpacing);\n        }\n    }\n\n    /// @dev Given a cumulativeAmount1, computes the rounded tick whose cumulativeAmount1 is closest to the input. Range is [tickLower - tickSpacing, tickUpper - tickSpacing].\n    ///      The returned tick will be the smallest rounded tick whose cumulativeAmount1 is greater than or equal to the input.\n    ///      In the case that the input exceeds the cumulativeAmount1 of all rounded ticks, the function will return (false, 0).\n    function inverseCumulativeAmount1(\n        uint256 cumulativeAmount1_,\n        uint256 totalLiquidity,\n        int24 tickSpacing,\n        int24 minTick,\n        int24 length,\n        uint256 alphaX96\n    ) internal pure returns (bool success, int24 roundedTick) {\n        if (cumulativeAmount1_ == 0) {\n            // return left boundary of distribution\n            return (true, minTick - tickSpacing);\n        }\n\n        uint256 cumulativeAmount1DensityX96 = cumulativeAmount1_.fullMulDiv(Q96, totalLiquidity);\n        uint256 sqrtRatioTickSpacing = tickSpacing.getSqrtPriceAtTick();\n        uint256 baseX96 = alphaX96.mulDiv(sqrtRatioTickSpacing, Q96);\n        int256 lnBaseX96 = int256(baseX96).lnQ96RoundingUp(); // int256 conversion is safe since baseX96 < Q96\n\n        int256 xWad;\n        if (alphaX96 > Q96) {\n            // alpha > 1\n            // need to make sure that alpha^x doesn't overflow by using alpha^-1 during exponentiation\n            uint256 alphaInvX96 = Q96.mulDiv(Q96, alphaX96);\n            uint256 alphaInvPowLengthX96 = alphaInvX96.rpow(uint24(length), Q96);\n            uint256 sqrtRatioNegMinTick = (-minTick).getSqrtPriceAtTick();\n\n            uint256 numerator1 = alphaX96 - Q96;\n            uint256 denominator1 = baseX96 - Q96;\n            uint256 denominator2 = Q96 - alphaInvPowLengthX96;\n            uint256 numerator2 = cumulativeAmount1DensityX96.mulDiv(sqrtRatioNegMinTick, sqrtRatioTickSpacing - Q96)\n                .mulDiv(denominator1, numerator1).mulDiv(denominator2, Q96);\n            if (numerator2 + alphaInvPowLengthX96 == 0) return (false, 0);\n            xWad = ((numerator2 + alphaInvPowLengthX96).toInt256().lnQ96() + int256(length) * int256(alphaX96).lnQ96())\n                .sDivWad(lnBaseX96) - int256(WAD);\n        } else {\n            uint256 sqrtRatioMinTick = minTick.getSqrtPriceAtTick();\n\n            uint256 denominator = dist(Q96, baseX96) * (Q96 - alphaX96.rpow(uint24(length), Q96));\n            uint256 numerator = cumulativeAmount1DensityX96.fullMulDiv(Q96, sqrtRatioMinTick).fullMulDiv(\n                denominator, sqrtRatioTickSpacing - Q96\n            );\n            if (Q96 > baseX96 && Q96 <= numerator / (Q96 - alphaX96)) {\n                // this usually happens when the max cumulativeAmount1 is very close to zero\n                // return minTick if cumulativeAmount1_ <= cumulativeAmount1(minTick)\n                if (\n                    cumulativeAmount1_\n                        <= cumulativeAmount1(minTick, totalLiquidity, tickSpacing, minTick, length, alphaX96)\n                ) {\n                    return (true, minTick);\n                } else {\n                    return (false, 0);\n                }\n            }\n            uint256 basePowXPlusOneX96 =\n                Q96 > baseX96 ? Q96 - numerator / (Q96 - alphaX96) : Q96 + numerator / (Q96 - alphaX96);\n            xWad = basePowXPlusOneX96.toInt256().lnQ96().sDivWad(lnBaseX96) - int256(WAD);\n        }\n\n        // early return if xWad is obviously too large\n        // the result (the smallest rounded tick whose cumulativeAmount1 is greater than or equal to the input) doesn't exist\n        // thus return success = false\n        int256 xWadMax = (length - 1) * int256(WAD);\n        if (xWad > xWadMax) {\n            // compare cumulativeAmount1_ with the max value of cumulativeAmount1()\n            // due to precision errors sometimes xWad can be greater than xWadMax when cumulativeAmount1_\n            // is close to the max value\n            uint256 maxCumulativeAmount1 = cumulativeAmount1(\n                minTick + (length - 1) * tickSpacing, totalLiquidity, tickSpacing, minTick, length, alphaX96\n            );\n            if (cumulativeAmount1_ > maxCumulativeAmount1) {\n                return (false, 0);\n            } else {\n                // xWad shouldn't actually be greater than xWadMax\n                // set it to xWadMax\n                xWad = xWadMax;\n            }\n        }\n\n        // get rounded tick from xWad\n        success = true;\n        roundedTick = xWadToRoundedTick(xWad, minTick, tickSpacing, true);\n\n        // ensure roundedTick is within the valid range\n        if (roundedTick < minTick - tickSpacing || roundedTick >= minTick + length * tickSpacing) {\n            return (false, 0);\n        }\n\n        // ensure that roundedTick is not (minTick - tickSpacing) when cumulativeAmount1_ is non-zero and rounding up\n        // this can happen if the corresponding cumulative density is too small\n        if (roundedTick == minTick - tickSpacing && cumulativeAmount1_ != 0) {\n            return (true, minTick);\n        }\n    }\n\n    function liquidityDensityX96(int24 roundedTick, int24 tickSpacing, int24 minTick, int24 length, uint256 alphaX96)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (roundedTick < minTick || roundedTick >= minTick + length * tickSpacing) {\n            // roundedTick is outside of the distribution\n            return 0;\n        }\n        // x is the index of the roundedTick in the distribution\n        // should be in the range [0, length)\n        uint256 x = uint24((roundedTick - minTick) / tickSpacing);\n        if (alphaX96 > Q96) {\n            // alpha > 1\n            // need to make sure that alpha^x doesn't overflow by using alpha^-1 during exponentiation\n            uint256 alphaInvX96 = Q96.mulDiv(Q96, alphaX96);\n            return alphaInvX96.rpow(uint24(length) - x, Q96).fullMulDiv(\n                alphaX96 - Q96, Q96 - alphaInvX96.rpow(uint24(length), Q96)\n            );\n        } else {\n            // alpha <= 1\n            // will revert if alpha == 1 but that's ok\n            return (Q96 - alphaX96).mulDiv(alphaX96.rpow(x, Q96), Q96 - alphaX96.rpow(uint24(length), Q96));\n        }\n    }\n\n    /// @dev Combines several operations used during a swap into one function to save gas.\n    ///      Given a cumulative amount, it computes its inverse to find the closest rounded tick, then computes the cumulative amount at that tick,\n    ///      and finally computes the liquidity of the tick that will handle the remainder of the swap.\n    function computeSwap(\n        uint256 inverseCumulativeAmountInput,\n        uint256 totalLiquidity,\n        bool zeroForOne,\n        bool exactIn,\n        int24 tickSpacing,\n        int24 minTick,\n        int24 length,\n        uint256 alphaX96\n    )\n        internal\n        pure\n        returns (\n            bool success,\n            int24 roundedTick,\n            uint256 cumulativeAmount0_,\n            uint256 cumulativeAmount1_,\n            uint256 swapLiquidity\n        )\n    {\n        if (exactIn == zeroForOne) {\n            // compute roundedTick by inverting the cumulative amount\n            // below is an illustration of 4 rounded ticks, the input amount, and the resulting roundedTick (rick)\n            // notice that the inverse tick is between two rounded ticks, and we round down to the rounded tick to the left\n            // e.g. go from 1.5 to 1\n            //       input\n            //      \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //    \u2502\n            //    \u25bc\n            //   rick\n            (success, roundedTick) = inverseCumulativeAmount0(\n                inverseCumulativeAmountInput, totalLiquidity, tickSpacing, minTick, length, alphaX96\n            );\n            if (!success) return (false, 0, 0, 0, 0);\n\n            // compute the cumulative amount up to roundedTick\n            // below is an illustration of the cumulative amount at roundedTick\n            // notice that exactIn ? (input - cum) : (cum - input) is the remainder of the swap that will be handled by Uniswap math\n            // exactIn:\n            //         cum\n            //       \u251c\u2500\u2500\u2500\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //       \u2502\n            //       \u25bc\n            //      rick + tickSpacing\n            // exactOut:\n            //        cum\n            //    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //    \u2502\n            //    \u25bc\n            //   rick\n            cumulativeAmount0_ = exactIn\n                ? cumulativeAmount0(roundedTick + tickSpacing, totalLiquidity, tickSpacing, minTick, length, alphaX96)\n                : cumulativeAmount0(roundedTick, totalLiquidity, tickSpacing, minTick, length, alphaX96);\n\n            // compute the cumulative amount of the complementary token\n            // below is an illustration\n            // exactIn:\n            //   cum\n            // \u251c\u2500\u2500\u2500\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //    \u2502\n            //    \u25bc\n            //   rick\n            // exactOut:\n            //  cum\n            // \u251c\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            // \u2502\n            // \u25bc\n            //rick - tickSpacing\n            cumulativeAmount1_ = exactIn\n                ? cumulativeAmount1(roundedTick, totalLiquidity, tickSpacing, minTick, length, alphaX96)\n                : cumulativeAmount1(roundedTick - tickSpacing, totalLiquidity, tickSpacing, minTick, length, alphaX96);\n\n            // compute liquidity of the rounded tick that will handle the remainder of the swap\n            // below is an illustration of the liquidity of the rounded tick that will handle the remainder of the swap\n            //    liq\n            //    \u251c\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2502  \u2502 \u2588\u2502\u2588\u2588\u2502\u2588\u2588\u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //    \u2502\n            //    \u25bc\n            //   rick\n            swapLiquidity =\n                (liquidityDensityX96(roundedTick, tickSpacing, minTick, length, alphaX96) * totalLiquidity) >> 96;\n        } else {\n            // compute roundedTick by inverting the cumulative amount\n            // below is an illustration of 4 rounded ticks, the input amount, and the resulting roundedTick (rick)\n            // notice that the inverse tick is between two rounded ticks, and we round up to the rounded tick to the right\n            // e.g. go from 1.5 to 2\n            //  input\n            // \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //       \u2502\n            //       \u25bc\n            //      rick\n            (success, roundedTick) = inverseCumulativeAmount1(\n                inverseCumulativeAmountInput, totalLiquidity, tickSpacing, minTick, length, alphaX96\n            );\n            if (!success) return (false, 0, 0, 0, 0);\n\n            // compute the cumulative amount up to roundedTick\n            // below is an illustration of the cumulative amount at roundedTick\n            // notice that exactIn ? (input - cum) : (cum - input) is the remainder of the swap that will be handled by Uniswap math\n            // exactIn:\n            //   cum\n            // \u251c\u2500\u2500\u2500\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //    \u2502\n            //    \u25bc\n            //   rick - tickSpacing\n            // exactOut:\n            //     cum\n            // \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //       \u2502\n            //       \u25bc\n            //      rick\n            cumulativeAmount1_ = exactIn\n                ? cumulativeAmount1(roundedTick - tickSpacing, totalLiquidity, tickSpacing, minTick, length, alphaX96)\n                : cumulativeAmount1(roundedTick, totalLiquidity, tickSpacing, minTick, length, alphaX96);\n\n            // compute the cumulative amount of the complementary token\n            // below is an illustration\n            // exactIn:\n            //         cum\n            //       \u251c\u2500\u2500\u2500\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //       \u2502\n            //       \u25bc\n            //      rick\n            // exactOut:\n            //           cum\n            //          \u251c\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //          \u2502\n            //          \u25bc\n            //         rick + tickSpacing\n            cumulativeAmount0_ = exactIn\n                ? cumulativeAmount0(roundedTick, totalLiquidity, tickSpacing, minTick, length, alphaX96)\n                : cumulativeAmount0(roundedTick + tickSpacing, totalLiquidity, tickSpacing, minTick, length, alphaX96);\n\n            // compute liquidity of the rounded tick that will handle the remainder of the swap\n            // below is an illustration of the liquidity of the rounded tick that will handle the remainder of the swap\n            //       liq\n            //       \u251c\u2500\u2500\u2524\n            // \u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2502\u2588\u2588\u2502\u2588\u2588\u2502\u2588 \u2502  \u2502\n            // \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n            // 0  1  2  3  4\n            //       \u2502\n            //       \u25bc\n            //      rick\n            swapLiquidity =\n                (liquidityDensityX96(roundedTick, tickSpacing, minTick, length, alphaX96) * totalLiquidity) >> 96;\n        }\n    }\n\n    function isValidParams(int24 tickSpacing, uint24 twapSecondsAgo, bytes32 ldfParams) internal pure returns (bool) {\n        (int24 minUsableTick, int24 maxUsableTick) =\n            (TickMath.minUsableTick(tickSpacing), TickMath.maxUsableTick(tickSpacing));\n\n        // | shiftMode - 1 byte | minTickOrOffset - 3 bytes | length - 2 bytes | alpha - 4 bytes |\n        uint8 shiftMode = uint8(bytes1(ldfParams));\n        int24 minTickOrOffset = int24(uint24(bytes3(ldfParams << 8)));\n        int24 length = int24(int16(uint16(bytes2(ldfParams << 32))));\n        uint256 alpha = uint32(bytes4(ldfParams << 48));\n\n        // ensure shiftMode is within the valid range\n        if (shiftMode > uint8(type(ShiftMode).max)) {\n            return false;\n        }\n\n        // ensure twapSecondsAgo is non-zero if shiftMode is not static\n        if (shiftMode != uint8(ShiftMode.STATIC) && twapSecondsAgo == 0) {\n            return false;\n        }\n\n        // ensure minTickOrOffset is aligned to tickSpacing\n        if (minTickOrOffset % tickSpacing != 0) {\n            return false;\n        }\n\n        // ensure length > 0 and doesn't overflow when multiplied by tickSpacing\n        // ensure length can be contained between minUsableTick and maxUsableTick\n        if (\n            length <= 0 || int256(length) * int256(tickSpacing) > type(int24).max\n                || length > maxUsableTick / tickSpacing || -length < minUsableTick / tickSpacing\n        ) return false;\n\n        // ensure alpha is in range\n        if (alpha < MIN_ALPHA || alpha > MAX_ALPHA || alpha == ALPHA_BASE) return false;\n\n        // ensure alpha != sqrtRatioTickSpacing which would cause cum0 to always be 0\n        uint256 alphaX96 = alpha.mulDiv(Q96, ALPHA_BASE);\n        uint160 sqrtRatioTickSpacing = tickSpacing.getSqrtPriceAtTick();\n        if (alphaX96 == sqrtRatioTickSpacing) return false;\n\n        // ensure the ticks are within the valid range\n        if (shiftMode == uint8(ShiftMode.STATIC)) {\n            // static minTick set in params\n            int24 maxTick = minTickOrOffset + length * tickSpacing;\n            if (minTickOrOffset < minUsableTick || maxTick > maxUsableTick) return false;\n        }\n\n        // ensure liquidity density is nowhere equal to zero\n        // can check boundaries since function is monotonic\n        uint256 minLiquidityDensityX96;\n        if (alpha > ALPHA_BASE) {\n            // monotonically increasing\n            // check left boundary\n            minLiquidityDensityX96 =\n                liquidityDensityX96(minTickOrOffset, tickSpacing, minTickOrOffset, length, alphaX96);\n        } else {\n            // monotonically decreasing\n            // check right boundary\n            minLiquidityDensityX96 = liquidityDensityX96(\n                minTickOrOffset + (length - 1) * tickSpacing, tickSpacing, minTickOrOffset, length, alphaX96\n            );\n        }\n        if (minLiquidityDensityX96 < MIN_LIQUIDITY_DENSITY) {\n            return false;\n        }\n\n        // if all conditions are met, return true\n        return true;\n    }\n\n    /// @return minTick The minimum rounded tick of the distribution\n    /// @return length The length of the distribution in number of rounded ticks (i.e. the number of ticks / tickSpacing)\n    /// @return alphaX96 Parameter of the discrete laplace distribution, FixedPoint96\n    function decodeParams(int24 twapTick, int24 tickSpacing, bytes32 ldfParams)\n        internal\n        pure\n        returns (int24 minTick, int24 length, uint256 alphaX96, ShiftMode shiftMode)\n    {\n        // | shiftMode - 1 byte | minTickOrOffset - 3 bytes | length - 2 bytes | alpha - 4 bytes |\n        shiftMode = ShiftMode(uint8(bytes1(ldfParams)));\n        length = int24(int16(uint16(bytes2(ldfParams << 32))));\n        uint256 alpha = uint32(bytes4(ldfParams << 48));\n        alphaX96 = alpha.mulDiv(Q96, ALPHA_BASE);\n\n        if (shiftMode != ShiftMode.STATIC) {\n            // use rounded TWAP value + offset as minTick\n            int24 offset = int24(uint24(bytes3(ldfParams << 8))); // the offset applied to the twap tick to get the minTick\n            minTick = roundTickSingle(twapTick + offset, tickSpacing);\n\n            // bound distribution to be within the range of usable ticks\n            (int24 minUsableTick, int24 maxUsableTick) =\n                (TickMath.minUsableTick(tickSpacing), TickMath.maxUsableTick(tickSpacing));\n            if (minTick < minUsableTick) {\n                minTick = minUsableTick;\n            } else if (minTick > maxUsableTick - length * tickSpacing) {\n                minTick = maxUsableTick - length * tickSpacing;\n            }\n        } else {\n            // static minTick set in params\n            minTick = int24(uint24(bytes3(ldfParams << 8))); // must be aligned to tickSpacing\n        }\n    }\n}\n"}, "lib/v4-core/src/interfaces/external/IERC20Minimal.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title Minimal ERC20 interface for Uniswap\n/// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3\ninterface IERC20Minimal {\n    /// @notice Returns an account's balance in the token\n    /// @param account The account for which to look up the number of tokens it has, i.e. its balance\n    /// @return The number of tokens held by the account\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Transfers the amount of token from the `msg.sender` to the recipient\n    /// @param recipient The account that will receive the amount transferred\n    /// @param amount The number of tokens to send from the sender to the recipient\n    /// @return Returns true for a successful transfer, false for an unsuccessful transfer\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /// @notice Returns the current allowance given to a spender by an owner\n    /// @param owner The account of the token owner\n    /// @param spender The account of the token spender\n    /// @return The current allowance granted by `owner` to `spender`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`\n    /// @param spender The account which will be allowed to spend a given amount of the owners tokens\n    /// @param amount The amount of tokens allowed to be used by `spender`\n    /// @return Returns true for a successful approval, false for unsuccessful\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`\n    /// @param sender The account from which the transfer will be initiated\n    /// @param recipient The recipient of the transfer\n    /// @param amount The amount of the transfer\n    /// @return Returns true for a successful transfer, false for unsuccessful\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.\n    /// @param from The account from which the tokens were sent, i.e. the balance decreased\n    /// @param to The account to which the tokens were sent, i.e. the balance increased\n    /// @param value The amount of tokens that were transferred\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.\n    /// @param owner The account that approved spending of its tokens\n    /// @param spender The account for which the spending allowance was modified\n    /// @param value The new allowance from the owner to the spender\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"}, "lib/v4-core/src/types/BeforeSwapDelta.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n// Return type of the beforeSwap hook.\n// Upper 128 bits is the delta in specified tokens. Lower 128 bits is delta in unspecified tokens (to match the afterSwap hook)\ntype BeforeSwapDelta is int256;\n\n// Creates a BeforeSwapDelta from specified and unspecified\nfunction toBeforeSwapDelta(int128 deltaSpecified, int128 deltaUnspecified)\n    pure\n    returns (BeforeSwapDelta beforeSwapDelta)\n{\n    assembly (\"memory-safe\") {\n        beforeSwapDelta := or(shl(128, deltaSpecified), and(sub(shl(128, 1), 1), deltaUnspecified))\n    }\n}\n\n/// @notice Library for getting the specified and unspecified deltas from the BeforeSwapDelta type\nlibrary BeforeSwapDeltaLibrary {\n    /// @notice A BeforeSwapDelta of 0\n    BeforeSwapDelta public constant ZERO_DELTA = BeforeSwapDelta.wrap(0);\n\n    /// extracts int128 from the upper 128 bits of the BeforeSwapDelta\n    /// returned by beforeSwap\n    function getSpecifiedDelta(BeforeSwapDelta delta) internal pure returns (int128 deltaSpecified) {\n        assembly (\"memory-safe\") {\n            deltaSpecified := sar(128, delta)\n        }\n    }\n\n    /// extracts int128 from the lower 128 bits of the BeforeSwapDelta\n    /// returned by beforeSwap and afterSwap\n    function getUnspecifiedDelta(BeforeSwapDelta delta) internal pure returns (int128 deltaUnspecified) {\n        assembly (\"memory-safe\") {\n            deltaUnspecified := signextend(15, delta)\n        }\n    }\n}\n"}, "lib/v4-core/src/libraries/SafeCast.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {CustomRevert} from \"./CustomRevert.sol\";\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n    using CustomRevert for bytes4;\n\n    error SafeCastOverflow();\n\n    /// @notice Cast a uint256 to a uint160, revert on overflow\n    /// @param x The uint256 to be downcasted\n    /// @return y The downcasted integer, now type uint160\n    function toUint160(uint256 x) internal pure returns (uint160 y) {\n        y = uint160(x);\n        if (y != x) SafeCastOverflow.selector.revertWith();\n    }\n\n    /// @notice Cast a uint256 to a uint128, revert on overflow\n    /// @param x The uint256 to be downcasted\n    /// @return y The downcasted integer, now type uint128\n    function toUint128(uint256 x) internal pure returns (uint128 y) {\n        y = uint128(x);\n        if (x != y) SafeCastOverflow.selector.revertWith();\n    }\n\n    /// @notice Cast a int128 to a uint128, revert on overflow or underflow\n    /// @param x The int128 to be casted\n    /// @return y The casted integer, now type uint128\n    function toUint128(int128 x) internal pure returns (uint128 y) {\n        if (x < 0) SafeCastOverflow.selector.revertWith();\n        y = uint128(x);\n    }\n\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\n    /// @param x The int256 to be downcasted\n    /// @return y The downcasted integer, now type int128\n    function toInt128(int256 x) internal pure returns (int128 y) {\n        y = int128(x);\n        if (y != x) SafeCastOverflow.selector.revertWith();\n    }\n\n    /// @notice Cast a uint256 to a int256, revert on overflow\n    /// @param x The uint256 to be casted\n    /// @return y The casted integer, now type int256\n    function toInt256(uint256 x) internal pure returns (int256 y) {\n        y = int256(x);\n        if (y < 0) SafeCastOverflow.selector.revertWith();\n    }\n\n    /// @notice Cast a uint256 to a int128, revert on overflow\n    /// @param x The uint256 to be downcasted\n    /// @return The downcasted integer, now type int128\n    function toInt128(uint256 x) internal pure returns (int128) {\n        if (x >= 1 << 127) SafeCastOverflow.selector.revertWith();\n        return int128(int256(x));\n    }\n}\n"}, "lib/v4-core/src/libraries/TickMath.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {BitMath} from \"./BitMath.sol\";\nimport {CustomRevert} from \"./CustomRevert.sol\";\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    using CustomRevert for bytes4;\n\n    /// @notice Thrown when the tick passed to #getSqrtPriceAtTick is not between MIN_TICK and MAX_TICK\n    error InvalidTick(int24 tick);\n    /// @notice Thrown when the price passed to #getTickAtSqrtPrice does not correspond to a price between MIN_TICK and MAX_TICK\n    error InvalidSqrtPrice(uint160 sqrtPriceX96);\n\n    /// @dev The minimum tick that may be passed to #getSqrtPriceAtTick computed from log base 1.0001 of 2**-128\n    /// @dev If ever MIN_TICK and MAX_TICK are not centered around 0, the absTick logic in getSqrtPriceAtTick cannot be used\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtPriceAtTick computed from log base 1.0001 of 2**128\n    /// @dev If ever MIN_TICK and MAX_TICK are not centered around 0, the absTick logic in getSqrtPriceAtTick cannot be used\n    int24 internal constant MAX_TICK = 887272;\n\n    /// @dev The minimum tick spacing value drawn from the range of type int16 that is greater than 0, i.e. min from the range [1, 32767]\n    int24 internal constant MIN_TICK_SPACING = 1;\n    /// @dev The maximum tick spacing value drawn from the range of type int16, i.e. max from the range [1, 32767]\n    int24 internal constant MAX_TICK_SPACING = type(int16).max;\n\n    /// @dev The minimum value that can be returned from #getSqrtPriceAtTick. Equivalent to getSqrtPriceAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_PRICE = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtPriceAtTick. Equivalent to getSqrtPriceAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_PRICE = 1461446703485210103287273052203988822378723970342;\n    /// @dev A threshold used for optimized bounds check, equals `MAX_SQRT_PRICE - MIN_SQRT_PRICE - 1`\n    uint160 internal constant MAX_SQRT_PRICE_MINUS_MIN_SQRT_PRICE_MINUS_ONE =\n        1461446703485210103287273052203988822378723970342 - 4295128739 - 1;\n\n    /// @notice Given a tickSpacing, compute the maximum usable tick\n    function maxUsableTick(int24 tickSpacing) internal pure returns (int24) {\n        unchecked {\n            return (MAX_TICK / tickSpacing) * tickSpacing;\n        }\n    }\n\n    /// @notice Given a tickSpacing, compute the minimum usable tick\n    function minUsableTick(int24 tickSpacing) internal pure returns (int24) {\n        unchecked {\n            return (MIN_TICK / tickSpacing) * tickSpacing;\n        }\n    }\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the price of the two assets (currency1/currency0)\n    /// at the given tick\n    function getSqrtPriceAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        unchecked {\n            uint256 absTick;\n            assembly (\"memory-safe\") {\n                tick := signextend(2, tick)\n                // mask = 0 if tick >= 0 else -1 (all 1s)\n                let mask := sar(255, tick)\n                // if tick >= 0, |tick| = tick = 0 ^ tick\n                // if tick < 0, |tick| = ~~|tick| = ~(-|tick| - 1) = ~(tick - 1) = (-1) ^ (tick - 1)\n                // either way, |tick| = mask ^ (tick + mask)\n                absTick := xor(mask, add(mask, tick))\n            }\n\n            if (absTick > uint256(int256(MAX_TICK))) InvalidTick.selector.revertWith(tick);\n\n            // The tick is decomposed into bits, and for each bit with index i that is set, the product of 1/sqrt(1.0001^(2^i))\n            // is calculated (using Q128.128). The constants used for this calculation are rounded to the nearest integer\n\n            // Equivalent to:\n            //     price = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n            //     or price = int(2**128 / sqrt(1.0001)) if (absTick & 0x1) else 1 << 128\n            uint256 price;\n            assembly (\"memory-safe\") {\n                price := xor(shl(128, 1), mul(xor(shl(128, 1), 0xfffcb933bd6fad37aa2d162d1a594001), and(absTick, 0x1)))\n            }\n            if (absTick & 0x2 != 0) price = (price * 0xfff97272373d413259a46990580e213a) >> 128;\n            if (absTick & 0x4 != 0) price = (price * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n            if (absTick & 0x8 != 0) price = (price * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n            if (absTick & 0x10 != 0) price = (price * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n            if (absTick & 0x20 != 0) price = (price * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n            if (absTick & 0x40 != 0) price = (price * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n            if (absTick & 0x80 != 0) price = (price * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n            if (absTick & 0x100 != 0) price = (price * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n            if (absTick & 0x200 != 0) price = (price * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n            if (absTick & 0x400 != 0) price = (price * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n            if (absTick & 0x800 != 0) price = (price * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n            if (absTick & 0x1000 != 0) price = (price * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n            if (absTick & 0x2000 != 0) price = (price * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n            if (absTick & 0x4000 != 0) price = (price * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n            if (absTick & 0x8000 != 0) price = (price * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n            if (absTick & 0x10000 != 0) price = (price * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n            if (absTick & 0x20000 != 0) price = (price * 0x5d6af8dedb81196699c329225ee604) >> 128;\n            if (absTick & 0x40000 != 0) price = (price * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n            if (absTick & 0x80000 != 0) price = (price * 0x48a170391f7dc42444e8fa2) >> 128;\n\n            assembly (\"memory-safe\") {\n                // if (tick > 0) price = type(uint256).max / price;\n                if sgt(tick, 0) { price := div(not(0), price) }\n\n                // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n                // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n                // we round up in the division so getTickAtSqrtPrice of the output price is always consistent\n                // `sub(shl(32, 1), 1)` is `type(uint32).max`\n                // `price + type(uint32).max` will not overflow because `price` fits in 192 bits\n                sqrtPriceX96 := shr(32, add(price, sub(shl(32, 1), 1)))\n            }\n        }\n    }\n\n    /// @notice Calculates the greatest tick value such that getSqrtPriceAtTick(tick) <= sqrtPriceX96\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_PRICE, as MIN_SQRT_PRICE is the lowest value getSqrtPriceAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt price for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the getSqrtPriceAtTick(tick) is less than or equal to the input sqrtPriceX96\n    function getTickAtSqrtPrice(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        unchecked {\n            // Equivalent: if (sqrtPriceX96 < MIN_SQRT_PRICE || sqrtPriceX96 >= MAX_SQRT_PRICE) revert InvalidSqrtPrice();\n            // second inequality must be >= because the price can never reach the price at the max tick\n            // if sqrtPriceX96 < MIN_SQRT_PRICE, the `sub` underflows and `gt` is true\n            // if sqrtPriceX96 >= MAX_SQRT_PRICE, sqrtPriceX96 - MIN_SQRT_PRICE > MAX_SQRT_PRICE - MIN_SQRT_PRICE - 1\n            if ((sqrtPriceX96 - MIN_SQRT_PRICE) > MAX_SQRT_PRICE_MINUS_MIN_SQRT_PRICE_MINUS_ONE) {\n                InvalidSqrtPrice.selector.revertWith(sqrtPriceX96);\n            }\n\n            uint256 price = uint256(sqrtPriceX96) << 32;\n\n            uint256 r = price;\n            uint256 msb = BitMath.mostSignificantBit(r);\n\n            if (msb >= 128) r = price >> (msb - 127);\n            else r = price << (127 - msb);\n\n            int256 log_2 = (int256(msb) - 128) << 64;\n\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(63, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(62, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(61, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(60, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(59, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(58, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(57, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(56, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(55, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(54, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(53, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(52, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(51, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(50, f))\n            }\n\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // Q22.128 number\n\n            // Magic number represents the ceiling of the maximum value of the error when approximating log_sqrt10001(x)\n            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n\n            // Magic number represents the minimum value of the error when approximating log_sqrt10001(x), when\n            // sqrtPrice is from the range (2^-64, 2^64). This is safe as MIN_SQRT_PRICE is more than 2^-64. If MIN_SQRT_PRICE\n            // is changed, this may need to be changed too\n            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n            tick = tickLow == tickHi ? tickLow : getSqrtPriceAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n        }\n    }\n}\n"}, "src/lib/FullMathX96.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\nlibrary FullMathX96 {\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n\n    /// @dev Calculates `floor(x * y / 2 ** 96)` with full precision.\n    /// Throws if result overflows a uint256.\n    /// Credit to Philogy under MIT license:\n    /// https://github.com/SorellaLabs/angstrom/blob/main/contracts/src/libraries/X128MathLib.sol\n    function fullMulX96(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`. We'll call this `z`.\n            for {} 1 {} {\n                if iszero(or(iszero(x), eq(div(z, x), y))) {\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n                    //         |      p1     |      z     |\n                    // Before: | p1_0 \u00a6 p1_1 | z_0  \u00a6 z_1 |\n                    // Final:  |   0  \u00a6 p1_0 | p1_1 \u00a6 z_0 |\n                    // Check that final `z` doesn't overflow by checking that p1_0 = 0.\n                    if iszero(shr(96, p1)) {\n                        z := add(shl(160, p1), shr(96, z))\n                        break\n                    }\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                z := shr(96, z)\n                break\n            }\n        }\n    }\n\n    function fullMulX96Up(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = fullMulX96(x, y);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mulmod(x, y, Q96) {\n                z := add(z, 1)\n                if iszero(z) {\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n}\n"}, "src/lib/SqrtPriceMath.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {SafeCast} from \"@uniswap/v4-core/src/libraries/SafeCast.sol\";\n\nimport {FullMath} from \"@uniswap/v4-core/src/libraries/FullMath.sol\";\nimport {UnsafeMath} from \"@uniswap/v4-core/src/libraries/UnsafeMath.sol\";\nimport {FixedPoint96} from \"@uniswap/v4-core/src/libraries/FixedPoint96.sol\";\n\n/// @title Functions based on Q64.96 sqrt price and liquidity\n/// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas\nlibrary SqrtPriceMath {\n    using SafeCast for uint256;\n\n    error InvalidPriceOrLiquidity();\n    error InvalidPrice();\n    error NotEnoughLiquidity();\n    error PriceOverflow();\n\n    /// @notice Gets the next sqrt price given a delta of currency0\n    /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least\n    /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the\n    /// price less in order to not send too much output.\n    /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),\n    /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).\n    /// @param sqrtPX96 The starting price, i.e. before accounting for the currency0 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of currency0 to add or remove from virtual reserves\n    /// @param add Whether to add or remove the amount of currency0\n    /// @return The price after adding or removing amount, depending on add\n    function getNextSqrtPriceFromAmount0RoundingUp(uint160 sqrtPX96, uint256 liquidity, uint256 amount, bool add)\n        internal\n        pure\n        returns (uint160)\n    {\n        // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price\n        if (amount == 0) return sqrtPX96;\n        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n\n        if (add) {\n            unchecked {\n                uint256 product = amount * sqrtPX96;\n                if (product / amount == sqrtPX96) {\n                    uint256 denominator = numerator1 + product;\n                    if (denominator >= numerator1) {\n                        // always fits in 160 bits\n                        return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));\n                    }\n                }\n            }\n            // denominator is checked for overflow\n            return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96) + amount));\n        } else {\n            unchecked {\n                uint256 product = amount * sqrtPX96;\n                // if the product overflows, we know the denominator underflows\n                // in addition, we must check that the denominator does not underflow\n                // equivalent: if (product / amount != sqrtPX96 || numerator1 <= product) revert PriceOverflow();\n                assembly (\"memory-safe\") {\n                    if iszero(\n                        and(\n                            eq(div(product, amount), and(sqrtPX96, 0xffffffffffffffffffffffffffffffffffffffff)),\n                            gt(numerator1, product)\n                        )\n                    ) {\n                        mstore(0, 0xf5c787f1) // selector for PriceOverflow()\n                        revert(0x1c, 0x04)\n                    }\n                }\n                uint256 denominator = numerator1 - product;\n                return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();\n            }\n        }\n    }\n\n    /// @notice Gets the next sqrt price given a delta of currency1\n    /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least\n    /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the\n    /// price less in order to not send too much output.\n    /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the currency1 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of currency1 to add, or remove, from virtual reserves\n    /// @param add Whether to add, or remove, the amount of currency1\n    /// @return The price after adding or removing `amount`\n    function getNextSqrtPriceFromAmount1RoundingDown(uint160 sqrtPX96, uint256 liquidity, uint256 amount, bool add)\n        internal\n        pure\n        returns (uint160)\n    {\n        // if we're adding (subtracting), rounding down requires rounding the quotient down (up)\n        // in both cases, avoid a mulDiv for most inputs\n        if (add) {\n            uint256 quotient = (\n                amount <= type(uint160).max\n                    ? (amount << FixedPoint96.RESOLUTION) / liquidity\n                    : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)\n            );\n\n            return (uint256(sqrtPX96) + quotient).toUint160();\n        } else {\n            uint256 quotient = (\n                amount <= type(uint160).max\n                    ? UnsafeMath.divRoundingUp(amount << FixedPoint96.RESOLUTION, liquidity)\n                    : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity)\n            );\n\n            // equivalent: if (sqrtPX96 <= quotient) revert NotEnoughLiquidity();\n            assembly (\"memory-safe\") {\n                if iszero(gt(and(sqrtPX96, 0xffffffffffffffffffffffffffffffffffffffff), quotient)) {\n                    mstore(0, 0x4323a555) // selector for NotEnoughLiquidity()\n                    revert(0x1c, 0x04)\n                }\n            }\n            // always fits 160 bits\n            unchecked {\n                return uint160(sqrtPX96 - quotient);\n            }\n        }\n    }\n\n    /// @notice Gets the next sqrt price given an input amount of currency0 or currency1\n    /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount\n    /// @param liquidity The amount of usable liquidity\n    /// @param amountIn How much of currency0, or currency1, is being swapped in\n    /// @param zeroForOne Whether the amount in is currency0 or currency1\n    /// @return uint160 The price after adding the input amount to currency0 or currency1\n    function getNextSqrtPriceFromInput(uint160 sqrtPX96, uint256 liquidity, uint256 amountIn, bool zeroForOne)\n        internal\n        pure\n        returns (uint160)\n    {\n        // equivalent: if (sqrtPX96 == 0 || liquidity == 0) revert InvalidPriceOrLiquidity();\n        assembly (\"memory-safe\") {\n            if or(\n                iszero(and(sqrtPX96, 0xffffffffffffffffffffffffffffffffffffffff)),\n                iszero(and(liquidity, 0xffffffffffffffffffffffffffffffff))\n            ) {\n                mstore(0, 0x4f2461b8) // selector for InvalidPriceOrLiquidity()\n                revert(0x1c, 0x04)\n            }\n        }\n\n        // round to make sure that we don't pass the target price\n        return zeroForOne\n            ? getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)\n            : getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);\n    }\n\n    /// @notice Gets the next sqrt price given an output amount of currency0 or currency1\n    /// @dev Throws if price or liquidity are 0 or the next price is out of bounds\n    /// @param sqrtPX96 The starting price before accounting for the output amount\n    /// @param liquidity The amount of usable liquidity\n    /// @param amountOut How much of currency0, or currency1, is being swapped out\n    /// @param zeroForOne Whether the amount out is currency1 or currency0\n    /// @return uint160 The price after removing the output amount of currency0 or currency1\n    function getNextSqrtPriceFromOutput(uint160 sqrtPX96, uint256 liquidity, uint256 amountOut, bool zeroForOne)\n        internal\n        pure\n        returns (uint160)\n    {\n        // equivalent: if (sqrtPX96 == 0 || liquidity == 0) revert InvalidPriceOrLiquidity();\n        assembly (\"memory-safe\") {\n            if or(iszero(and(sqrtPX96, 0xffffffffffffffffffffffffffffffffffffffff)), iszero(liquidity)) {\n                mstore(0, 0x4f2461b8) // selector for InvalidPriceOrLiquidity()\n                revert(0x1c, 0x04)\n            }\n        }\n\n        // round to make sure that we pass the target price\n        return zeroForOne\n            ? getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)\n            : getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);\n    }\n\n    /// @notice Gets the amount0 delta between two prices\n    /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),\n    /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\n    /// @param sqrtPriceAX96 A sqrt price\n    /// @param sqrtPriceBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param roundUp Whether to round the amount up or down\n    /// @return uint256 Amount of currency0 required to cover a position of size liquidity between the two passed prices\n    function getAmount0Delta(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint256 liquidity, bool roundUp)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            if (sqrtPriceAX96 > sqrtPriceBX96) (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96);\n\n            // equivalent: if (sqrtPriceAX96 == 0) revert InvalidPrice();\n            assembly (\"memory-safe\") {\n                if iszero(and(sqrtPriceAX96, 0xffffffffffffffffffffffffffffffffffffffff)) {\n                    mstore(0, 0x00bfc921) // selector for InvalidPrice()\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n            uint256 numerator2 = sqrtPriceBX96 - sqrtPriceAX96;\n\n            return roundUp\n                ? UnsafeMath.divRoundingUp(FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtPriceBX96), sqrtPriceAX96)\n                : FullMath.mulDiv(numerator1, numerator2, sqrtPriceBX96) / sqrtPriceAX96;\n        }\n    }\n\n    /// @notice Equivalent to: `a >= b ? a - b : b - a`\n    function absDiff(uint160 a, uint160 b) internal pure returns (uint256 res) {\n        assembly (\"memory-safe\") {\n            let diff :=\n                sub(and(a, 0xffffffffffffffffffffffffffffffffffffffff), and(b, 0xffffffffffffffffffffffffffffffffffffffff))\n            // mask = 0 if a >= b else -1 (all 1s)\n            let mask := sar(255, diff)\n            // if a >= b, res = a - b = 0 ^ (a - b)\n            // if a < b, res = b - a = ~~(b - a) = ~(-(b - a) - 1) = ~(a - b - 1) = (-1) ^ (a - b - 1)\n            // either way, res = mask ^ (a - b + mask)\n            res := xor(mask, add(mask, diff))\n        }\n    }\n\n    /// @notice Gets the amount1 delta between two prices\n    /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))\n    /// @param sqrtPriceAX96 A sqrt price\n    /// @param sqrtPriceBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param roundUp Whether to round the amount up, or down\n    /// @return amount1 Amount of currency1 required to cover a position of size liquidity between the two passed prices\n    function getAmount1Delta(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint256 liquidity, bool roundUp)\n        internal\n        pure\n        returns (uint256 amount1)\n    {\n        uint256 numerator = absDiff(sqrtPriceAX96, sqrtPriceBX96);\n        uint256 denominator = FixedPoint96.Q96;\n        uint256 _liquidity = uint256(liquidity);\n\n        /**\n         * Equivalent to:\n         *   amount1 = roundUp\n         *       ? FullMath.mulDivRoundingUp(liquidity, sqrtPriceBX96 - sqrtPriceAX96, FixedPoint96.Q96)\n         *       : FullMath.mulDiv(liquidity, sqrtPriceBX96 - sqrtPriceAX96, FixedPoint96.Q96);\n         * Cannot overflow because `type(uint128).max * type(uint160).max >> 96 < (1 << 192)`.\n         */\n        amount1 = FullMath.mulDiv(_liquidity, numerator, denominator);\n        assembly (\"memory-safe\") {\n            amount1 := add(amount1, and(gt(mulmod(_liquidity, numerator, denominator), 0), roundUp))\n        }\n    }\n\n    /// @notice Helper that gets signed currency0 delta\n    /// @param sqrtPriceAX96 A sqrt price\n    /// @param sqrtPriceBX96 Another sqrt price\n    /// @param liquidity The change in liquidity for which to compute the amount0 delta\n    /// @return int256 Amount of currency0 corresponding to the passed liquidityDelta between the two prices\n    function getAmount0Delta(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, int128 liquidity)\n        internal\n        pure\n        returns (int256)\n    {\n        unchecked {\n            return liquidity < 0\n                ? getAmount0Delta(sqrtPriceAX96, sqrtPriceBX96, uint128(-liquidity), false).toInt256()\n                : -getAmount0Delta(sqrtPriceAX96, sqrtPriceBX96, uint128(liquidity), true).toInt256();\n        }\n    }\n\n    /// @notice Helper that gets signed currency1 delta\n    /// @param sqrtPriceAX96 A sqrt price\n    /// @param sqrtPriceBX96 Another sqrt price\n    /// @param liquidity The change in liquidity for which to compute the amount1 delta\n    /// @return int256 Amount of currency1 corresponding to the passed liquidityDelta between the two prices\n    function getAmount1Delta(uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, int128 liquidity)\n        internal\n        pure\n        returns (int256)\n    {\n        unchecked {\n            return liquidity < 0\n                ? getAmount1Delta(sqrtPriceAX96, sqrtPriceBX96, uint128(-liquidity), false).toInt256()\n                : -getAmount1Delta(sqrtPriceAX96, sqrtPriceBX96, uint128(liquidity), true).toInt256();\n        }\n    }\n}\n"}, "lib/v4-core/src/libraries/BitMath.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title BitMath\n/// @dev This library provides functionality for computing bit properties of an unsigned integer\n/// @author Solady (https://github.com/Vectorized/solady/blob/8200a70e8dc2a77ecb074fc2e99a2a0d36547522/src/utils/LibBit.sol)\nlibrary BitMath {\n    /// @notice Returns the index of the most significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @param x the value for which to compute the most significant bit, must be greater than 0\n    /// @return r the index of the most significant bit\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        assembly (\"memory-safe\") {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020500060203020504000106050205030304010505030400000000))\n        }\n    }\n\n    /// @notice Returns the index of the least significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @param x the value for which to compute the least significant bit, must be greater than 0\n    /// @return r the index of the least significant bit\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        assembly (\"memory-safe\") {\n            // Isolate the least significant bit.\n            x := and(x, sub(0, x))\n            // For the upper 3 bits of the result, use a De Bruijn-like lookup.\n            // Credit to adhusson: https://blog.adhusson.com/cheap-find-first-set-evm/\n            // forgefmt: disable-next-item\n            r := shl(5, shr(252, shl(shl(2, shr(250, mul(x,\n                0xb6db6db6ddddddddd34d34d349249249210842108c6318c639ce739cffffffff))),\n                0x8040405543005266443200005020610674053026020000107506200176117077)))\n            // For the lower 5 bits of the result, use a De Bruijn lookup.\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(div(0xd76453e0, shr(r, x)), 0x1f),\n                0x001f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405))\n        }\n    }\n}\n"}, "lib/v4-core/src/libraries/FullMath.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = a * b\n            // Compute the product mod 2**256 and mod 2**256 - 1\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2**256 + prod0\n            uint256 prod0 = a * b; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly (\"memory-safe\") {\n                let mm := mulmod(a, b, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Make sure the result is less than 2**256.\n            // Also prevents denominator == 0\n            require(denominator > prod1);\n\n            // Handle non-overflow cases, 256 by 256 division\n            if (prod1 == 0) {\n                assembly (\"memory-safe\") {\n                    result := div(prod0, denominator)\n                }\n                return result;\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0]\n            // Compute remainder using mulmod\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                remainder := mulmod(a, b, denominator)\n            }\n            // Subtract 256 bit number from 512 bit number\n            assembly (\"memory-safe\") {\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator\n            // Compute largest power of two divisor of denominator.\n            // Always >= 1.\n            uint256 twos = (0 - denominator) & denominator;\n            // Divide denominator by power of two\n            assembly (\"memory-safe\") {\n                denominator := div(denominator, twos)\n            }\n\n            // Divide [prod1 prod0] by the factors of two\n            assembly (\"memory-safe\") {\n                prod0 := div(prod0, twos)\n            }\n            // Shift in bits from prod1 into prod0. For this we need\n            // to flip `twos` such that it is 2**256 / twos.\n            // If twos is zero, then it becomes one\n            assembly (\"memory-safe\") {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n            uint256 inv = (3 * denominator) ^ 2;\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the preconditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n            return result;\n        }\n    }\n\n    /// @notice Calculates ceil(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            result = mulDiv(a, b, denominator);\n            if (mulmod(a, b, denominator) != 0) {\n                require(++result > 0);\n            }\n        }\n    }\n}\n"}, "lib/v4-core/src/libraries/UnsafeMath.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title Math functions that do not check inputs or outputs\n/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks\nlibrary UnsafeMath {\n    /// @notice Returns ceil(x / y)\n    /// @dev division by 0 will return 0, and should be checked externally\n    /// @param x The dividend\n    /// @param y The divisor\n    /// @return z The quotient, ceil(x / y)\n    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly (\"memory-safe\") {\n            z := add(div(x, y), gt(mod(x, y), 0))\n        }\n    }\n\n    /// @notice Calculates floor(a\u00d7b\u00f7denominator)\n    /// @dev division by 0 will return 0, and should be checked externally\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result, floor(a\u00d7b\u00f7denominator)\n    function simpleMulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n        assembly (\"memory-safe\") {\n            result := div(mul(a, b), denominator)\n        }\n    }\n}\n"}, "lib/v4-core/src/libraries/FixedPoint96.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title FixedPoint96\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n/// @dev Used in SqrtPriceMath.sol\nlibrary FixedPoint96 {\n    uint8 internal constant RESOLUTION = 96;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n}\n"}}, "settings": {"remappings": ["@uniswap/v4-core/=lib/v4-core/", "solmate/src/=lib/solmate/src/", "solmate/utils/=lib/solmate/src/utils/", "@ensdomains/=lib/v4-core/node_modules/@ensdomains/", "@openzeppelin/=lib/v4-core/lib/openzeppelin-contracts/", "@openzeppelin/contracts/=lib/v4-core/lib/openzeppelin-contracts/contracts/", "biddog/=lib/biddog/src/", "clones-with-immutable-args/=lib/clones-with-immutable-args/src/", "create3-factory/=lib/create3-factory/", "ds-test/=lib/clones-with-immutable-args/lib/ds-test/src/", "erc4626-tests/=lib/v4-core/lib/openzeppelin-contracts/lib/erc4626-tests/", "flood-contracts/=lib/flood-contracts/", "forge-gas-snapshot/=lib/permit2/lib/forge-gas-snapshot/src/", "forge-std/=lib/forge-std/src/", "hardhat/=lib/v4-core/node_modules/hardhat/", "leb128-nooffset/=lib/flood-contracts/lib/leb128-nooffset/src/", "leb128/=lib/flood-contracts/lib/leb128-nooffset/src/", "multicaller/=lib/multicaller/src/", "openzeppelin-contracts/=lib/v4-core/lib/openzeppelin-contracts/", "permit2/=lib/permit2/", "solady/=lib/solady/src/", "v4-core/=lib/v4-core/src/"], "optimizer": {"enabled": true}, "metadata": {"useLiteralContent": false, "bytecodeHash": "ipfs", "appendCBOR": true}, "outputSelection": {"*": {"*": ["evm.legacyAssembly"]}}, "evmVersion": "cancun", "viaIR": false, "libraries": {}}}