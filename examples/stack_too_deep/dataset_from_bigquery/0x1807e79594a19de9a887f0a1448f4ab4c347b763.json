{"language": "Solidity", "sources": {"lib/delegation-registry/src/IDelegationRegistry.sol": {"content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.30;\n\n/**\n * @title An immutable registry contract to be deployed as a standalone primitive\n * @dev See EIP-5639, new project launches can read previous cold wallet -> hot wallet delegations\n * from here and integrate those permissions into their flow\n */\ninterface IDelegationRegistry {\n    /// @notice Delegation type\n    enum DelegationType {\n        NONE,\n        ALL,\n        CONTRACT,\n        TOKEN\n    }\n\n    /// @notice Info about a single delegation, used for onchain enumeration\n    struct DelegationInfo {\n        DelegationType type_;\n        address vault;\n        address delegate;\n        address contract_;\n        uint256 tokenId;\n    }\n\n    /// @notice Info about a single contract-level delegation\n    struct ContractDelegation {\n        address contract_;\n        address delegate;\n    }\n\n    /// @notice Info about a single token-level delegation\n    struct TokenDelegation {\n        address contract_;\n        uint256 tokenId;\n        address delegate;\n    }\n\n    /// @notice Emitted when a user delegates their entire wallet\n    event DelegateForAll(address vault, address delegate, bool value);\n\n    /// @notice Emitted when a user delegates a specific contract\n    event DelegateForContract(address vault, address delegate, address contract_, bool value);\n\n    /// @notice Emitted when a user delegates a specific token\n    event DelegateForToken(address vault, address delegate, address contract_, uint256 tokenId, bool value);\n\n    /// @notice Emitted when a user revokes all delegations\n    event RevokeAllDelegates(address vault);\n\n    /// @notice Emitted when a user revoes all delegations for a given delegate\n    event RevokeDelegate(address vault, address delegate);\n\n    /**\n     * -----------  WRITE -----------\n     */\n\n    /**\n     * @notice Allow the delegate to act on your behalf for all contracts\n     * @param delegate The hotwallet to act on your behalf\n     * @param value Whether to enable or disable delegation for this address, true for setting and false for revoking\n     */\n    function delegateForAll(address delegate, bool value) external;\n\n    /**\n     * @notice Allow the delegate to act on your behalf for a specific contract\n     * @param delegate The hotwallet to act on your behalf\n     * @param contract_ The address for the contract you're delegating\n     * @param value Whether to enable or disable delegation for this address, true for setting and false for revoking\n     */\n    function delegateForContract(address delegate, address contract_, bool value) external;\n\n    /**\n     * @notice Allow the delegate to act on your behalf for a specific token\n     * @param delegate The hotwallet to act on your behalf\n     * @param contract_ The address for the contract you're delegating\n     * @param tokenId The token id for the token you're delegating\n     * @param value Whether to enable or disable delegation for this address, true for setting and false for revoking\n     */\n    function delegateForToken(address delegate, address contract_, uint256 tokenId, bool value) external;\n\n    /**\n     * @notice Revoke all delegates\n     */\n    function revokeAllDelegates() external;\n\n    /**\n     * @notice Revoke a specific delegate for all their permissions\n     * @param delegate The hotwallet to revoke\n     */\n    function revokeDelegate(address delegate) external;\n\n    /**\n     * @notice Remove yourself as a delegate for a specific vault\n     * @param vault The vault which delegated to the msg.sender, and should be removed\n     */\n    function revokeSelf(address vault) external;\n\n    /**\n     * -----------  READ -----------\n     */\n\n    /**\n     * @notice Returns all active delegations a given delegate is able to claim on behalf of\n     * @param delegate The delegate that you would like to retrieve delegations for\n     * @return info Array of DelegationInfo structs\n     */\n    function getDelegationsByDelegate(address delegate) external view returns (DelegationInfo[] memory);\n\n    /**\n     * @notice Returns an array of wallet-level delegates for a given vault\n     * @param vault The cold wallet who issued the delegation\n     * @return addresses Array of wallet-level delegates for a given vault\n     */\n    function getDelegatesForAll(address vault) external view returns (address[] memory);\n\n    /**\n     * @notice Returns an array of contract-level delegates for a given vault and contract\n     * @param vault The cold wallet who issued the delegation\n     * @param contract_ The address for the contract you're delegating\n     * @return addresses Array of contract-level delegates for a given vault and contract\n     */\n    function getDelegatesForContract(address vault, address contract_) external view returns (address[] memory);\n\n    /**\n     * @notice Returns an array of contract-level delegates for a given vault's token\n     * @param vault The cold wallet who issued the delegation\n     * @param contract_ The address for the contract holding the token\n     * @param tokenId The token id for the token you're delegating\n     * @return addresses Array of contract-level delegates for a given vault's token\n     */\n    function getDelegatesForToken(address vault, address contract_, uint256 tokenId)\n        external\n        view\n        returns (address[] memory);\n\n    /**\n     * @notice Returns all contract-level delegations for a given vault\n     * @param vault The cold wallet who issued the delegations\n     * @return delegations Array of ContractDelegation structs\n     */\n    function getContractLevelDelegations(address vault)\n        external\n        view\n        returns (ContractDelegation[] memory delegations);\n\n    /**\n     * @notice Returns all token-level delegations for a given vault\n     * @param vault The cold wallet who issued the delegations\n     * @return delegations Array of TokenDelegation structs\n     */\n    function getTokenLevelDelegations(address vault) external view returns (TokenDelegation[] memory delegations);\n\n    /**\n     * @notice Returns true if the address is delegated to act on the entire vault\n     * @param delegate The hotwallet to act on your behalf\n     * @param vault The cold wallet who issued the delegation\n     */\n    function checkDelegateForAll(address delegate, address vault) external view returns (bool);\n\n    /**\n     * @notice Returns true if the address is delegated to act on your behalf for a token contract or an entire vault\n     * @param delegate The hotwallet to act on your behalf\n     * @param contract_ The address for the contract you're delegating\n     * @param vault The cold wallet who issued the delegation\n     */\n    function checkDelegateForContract(address delegate, address vault, address contract_)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Returns true if the address is delegated to act on your behalf for a specific token, the token's contract or an entire vault\n     * @param delegate The hotwallet to act on your behalf\n     * @param contract_ The address for the contract you're delegating\n     * @param tokenId The token id for the token you're delegating\n     * @param vault The cold wallet who issued the delegation\n     */\n    function checkDelegateForToken(address delegate, address vault, address contract_, uint256 tokenId)\n        external\n        view\n        returns (bool);\n}\n"}, "lib/nouns-monorepo/packages/nouns-contracts/contracts/governance/NounsDAOInterfaces.sol": {"content": "// SPDX-License-Identifier: BSD-3-Clause\n\n/// @title Nouns DAO Logic interfaces and events\n\n/*********************************\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\n *********************************/\n\n// LICENSE\n// NounsDAOInterfaces.sol is a modified version of Compound Lab's GovernorBravoInterfaces.sol:\n// https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/Governance/GovernorBravoInterfaces.sol\n//\n// GovernorBravoInterfaces.sol source code Copyright 2020 Compound Labs, Inc. licensed under the BSD-3-Clause license.\n// With modifications by Nounders DAO.\n//\n// Additional conditions of BSD-3-Clause can be found here: https://opensource.org/licenses/BSD-3-Clause\n//\n// MODIFICATIONS\n// NounsDAOEvents, NounsDAOProxyStorage, NounsDAOStorageV1 add support for changes made by Nouns DAO to GovernorBravo.sol\n// See NounsDAOLogicV1.sol for more details.\n// NounsDAOStorageV1Adjusted and NounsDAOStorageV2 add support for a dynamic vote quorum.\n// See NounsDAOLogicV2.sol for more details.\n\npragma solidity ^0.8.30;\n\ncontract NounsDAOEvents {\n    /// @notice An event emitted when a new proposal is created\n    event ProposalCreated(\n        uint256 id,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 startBlock,\n        uint256 endBlock,\n        string description\n    );\n\n    /// @notice An event emitted when a new proposal is created, which includes additional information\n    event ProposalCreatedWithRequirements(\n        uint256 id,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 startBlock,\n        uint256 endBlock,\n        uint256 proposalThreshold,\n        uint256 quorumVotes,\n        string description\n    );\n\n    /// @notice An event emitted when a vote has been cast on a proposal\n    /// @param voter The address which casted a vote\n    /// @param proposalId The proposal id which was voted on\n    /// @param support Support value for the vote. 0=against, 1=for, 2=abstain\n    /// @param votes Number of votes which were cast by the voter\n    /// @param reason The reason given for the vote by the voter\n    event VoteCast(address indexed voter, uint256 proposalId, uint8 support, uint256 votes, string reason);\n\n    /// @notice An event emitted when a proposal has been canceled\n    event ProposalCanceled(uint256 id);\n\n    /// @notice An event emitted when a proposal has been queued in the NounsDAOExecutor\n    event ProposalQueued(uint256 id, uint256 eta);\n\n    /// @notice An event emitted when a proposal has been executed in the NounsDAOExecutor\n    event ProposalExecuted(uint256 id);\n\n    /// @notice An event emitted when a proposal has been vetoed by vetoAddress\n    event ProposalVetoed(uint256 id);\n\n    /// @notice An event emitted when the voting delay is set\n    event VotingDelaySet(uint256 oldVotingDelay, uint256 newVotingDelay);\n\n    /// @notice An event emitted when the voting period is set\n    event VotingPeriodSet(uint256 oldVotingPeriod, uint256 newVotingPeriod);\n\n    /// @notice Emitted when implementation is changed\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n    /// @notice Emitted when proposal threshold basis points is set\n    event ProposalThresholdBPSSet(uint256 oldProposalThresholdBPS, uint256 newProposalThresholdBPS);\n\n    /// @notice Emitted when quorum votes basis points is set\n    event QuorumVotesBPSSet(uint256 oldQuorumVotesBPS, uint256 newQuorumVotesBPS);\n\n    /// @notice Emitted when pendingAdmin is changed\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /// @notice Emitted when pendingAdmin is accepted, which means admin is updated\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /// @notice Emitted when vetoer is changed\n    event NewVetoer(address oldVetoer, address newVetoer);\n}\n\ncontract NounsDAOEventsV2 is NounsDAOEvents {\n    /// @notice Emitted when minQuorumVotesBPS is set\n    event MinQuorumVotesBPSSet(uint16 oldMinQuorumVotesBPS, uint16 newMinQuorumVotesBPS);\n\n    /// @notice Emitted when maxQuorumVotesBPS is set\n    event MaxQuorumVotesBPSSet(uint16 oldMaxQuorumVotesBPS, uint16 newMaxQuorumVotesBPS);\n\n    /// @notice Emitted when quorumCoefficient is set\n    event QuorumCoefficientSet(uint32 oldQuorumCoefficient, uint32 newQuorumCoefficient);\n\n    /// @notice Emitted when a voter cast a vote requesting a gas refund.\n    event RefundableVote(address indexed voter, uint256 refundAmount, bool refundSent);\n\n    /// @notice Emitted when admin withdraws the DAO's balance.\n    event Withdraw(uint256 amount, bool sent);\n\n    /// @notice Emitted when pendingVetoer is changed\n    event NewPendingVetoer(address oldPendingVetoer, address newPendingVetoer);\n}\n\ncontract NounsDAOProxyStorage {\n    /// @notice Administrator for this contract\n    address public admin;\n\n    /// @notice Pending administrator for this contract\n    address public pendingAdmin;\n\n    /// @notice Active brains of Governor\n    address public implementation;\n}\n\n/**\n * @title Storage for Governor Bravo Delegate\n * @notice For future upgrades, do not change NounsDAOStorageV1. Create a new\n * contract which implements NounsDAOStorageV1 and following the naming convention\n * NounsDAOStorageVX.\n */\ncontract NounsDAOStorageV1 is NounsDAOProxyStorage {\n    /// @notice Vetoer who has the ability to veto any proposal\n    address public vetoer;\n\n    /// @notice The delay before voting on a proposal may take place, once proposed, in blocks\n    uint256 public votingDelay;\n\n    /// @notice The duration of voting on a proposal, in blocks\n    uint256 public votingPeriod;\n\n    /// @notice The basis point number of votes required in order for a voter to become a proposer. *DIFFERS from GovernerBravo\n    uint256 public proposalThresholdBPS;\n\n    /// @notice The basis point number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed. *DIFFERS from GovernerBravo\n    uint256 public quorumVotesBPS;\n\n    /// @notice The total number of proposals\n    uint256 public proposalCount;\n\n    /// @notice The address of the Nouns DAO Executor NounsDAOExecutor\n    INounsDAOExecutor public timelock;\n\n    /// @notice The address of the Nouns tokens\n    NounsTokenLike public nouns;\n\n    /// @notice The official record of all proposals ever proposed\n    mapping(uint256 => Proposal) public proposals;\n\n    /// @notice The latest proposal for each proposer\n    mapping(address => uint256) public latestProposalIds;\n\n    struct Proposal {\n        /// @notice Unique id for looking up a proposal\n        uint256 id;\n        /// @notice Creator of the proposal\n        address proposer;\n        /// @notice The number of votes needed to create a proposal at the time of proposal creation. *DIFFERS from GovernerBravo\n        uint256 proposalThreshold;\n        /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed at the time of proposal creation. *DIFFERS from GovernerBravo\n        uint256 quorumVotes;\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint256 eta;\n        /// @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint256[] values;\n        /// @notice The ordered list of function signatures to be called\n        string[] signatures;\n        /// @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint256 startBlock;\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint256 endBlock;\n        /// @notice Current number of votes in favor of this proposal\n        uint256 forVotes;\n        /// @notice Current number of votes in opposition to this proposal\n        uint256 againstVotes;\n        /// @notice Current number of votes for abstaining for this proposal\n        uint256 abstainVotes;\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        /// @notice Flag marking whether the proposal has been vetoed\n        bool vetoed;\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n        /// @notice Receipts of ballots for the entire set of voters\n        mapping(address => Receipt) receipts;\n    }\n\n    /// @notice Ballot receipt record for a voter\n    struct Receipt {\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n        /// @notice Whether or not the voter supports the proposal or abstains\n        uint8 support;\n        /// @notice The number of votes the voter had, which were cast\n        uint96 votes;\n    }\n\n    /// @notice Possible states that a proposal may be in\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed,\n        Vetoed\n    }\n}\n\n/**\n * @title Extra fields added to the `Proposal` struct from NounsDAOStorageV1\n * @notice The following fields were added to the `Proposal` struct:\n * - `Proposal.totalSupply`\n * - `Proposal.creationBlock`\n */\ncontract NounsDAOStorageV1Adjusted is NounsDAOProxyStorage {\n    /// @notice Vetoer who has the ability to veto any proposal\n    address public vetoer;\n\n    /// @notice The delay before voting on a proposal may take place, once proposed, in blocks\n    uint256 public votingDelay;\n\n    /// @notice The duration of voting on a proposal, in blocks\n    uint256 public votingPeriod;\n\n    /// @notice The basis point number of votes required in order for a voter to become a proposer. *DIFFERS from GovernerBravo\n    uint256 public proposalThresholdBPS;\n\n    /// @notice The basis point number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed. *DIFFERS from GovernerBravo\n    uint256 public quorumVotesBPS;\n\n    /// @notice The total number of proposals\n    uint256 public proposalCount;\n\n    /// @notice The address of the Nouns DAO Executor NounsDAOExecutor\n    INounsDAOExecutor public timelock;\n\n    /// @notice The address of the Nouns tokens\n    NounsTokenLike public nouns;\n\n    /// @notice The official record of all proposals ever proposed\n    mapping(uint256 => Proposal) internal _proposals;\n\n    /// @notice The latest proposal for each proposer\n    mapping(address => uint256) public latestProposalIds;\n\n    struct Proposal {\n        /// @notice Unique id for looking up a proposal\n        uint256 id;\n        /// @notice Creator of the proposal\n        address proposer;\n        /// @notice The number of votes needed to create a proposal at the time of proposal creation. *DIFFERS from GovernerBravo\n        uint256 proposalThreshold;\n        /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed at the time of proposal creation. *DIFFERS from GovernerBravo\n        uint256 quorumVotes;\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint256 eta;\n        /// @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint256[] values;\n        /// @notice The ordered list of function signatures to be called\n        string[] signatures;\n        /// @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint256 startBlock;\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint256 endBlock;\n        /// @notice Current number of votes in favor of this proposal\n        uint256 forVotes;\n        /// @notice Current number of votes in opposition to this proposal\n        uint256 againstVotes;\n        /// @notice Current number of votes for abstaining for this proposal\n        uint256 abstainVotes;\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        /// @notice Flag marking whether the proposal has been vetoed\n        bool vetoed;\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n        /// @notice Receipts of ballots for the entire set of voters\n        mapping(address => Receipt) receipts;\n        /// @notice The total supply at the time of proposal creation\n        uint256 totalSupply;\n        /// @notice The block at which this proposal was created\n        uint256 creationBlock;\n    }\n\n    /// @notice Ballot receipt record for a voter\n    struct Receipt {\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n        /// @notice Whether or not the voter supports the proposal or abstains\n        uint8 support;\n        /// @notice The number of votes the voter had, which were cast\n        uint96 votes;\n    }\n\n    /// @notice Possible states that a proposal may be in\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed,\n        Vetoed\n    }\n}\n\n/**\n * @title Storage for Governor Bravo Delegate\n * @notice For future upgrades, do not change NounsDAOStorageV2. Create a new\n * contract which implements NounsDAOStorageV2 and following the naming convention\n * NounsDAOStorageVX.\n */\ncontract NounsDAOStorageV2 is NounsDAOStorageV1Adjusted {\n    DynamicQuorumParamsCheckpoint[] public quorumParamsCheckpoints;\n\n    /// @notice Pending new vetoer\n    address public pendingVetoer;\n\n    struct DynamicQuorumParams {\n        /// @notice The minimum basis point number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed.\n        uint16 minQuorumVotesBPS;\n        /// @notice The maximum basis point number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed.\n        uint16 maxQuorumVotesBPS;\n        /// @notice The dynamic quorum coefficient\n        /// @dev Assumed to be fixed point integer with 6 decimals, i.e 0.2 is represented as 0.2 * 1e6 = 200000\n        uint32 quorumCoefficient;\n    }\n\n    /// @notice A checkpoint for storing dynamic quorum params from a given block\n    struct DynamicQuorumParamsCheckpoint {\n        /// @notice The block at which the new values were set\n        uint32 fromBlock;\n        /// @notice The parameter values of this checkpoint\n        DynamicQuorumParams params;\n    }\n\n    struct ProposalCondensed {\n        /// @notice Unique id for looking up a proposal\n        uint256 id;\n        /// @notice Creator of the proposal\n        address proposer;\n        /// @notice The number of votes needed to create a proposal at the time of proposal creation. *DIFFERS from GovernerBravo\n        uint256 proposalThreshold;\n        /// @notice The minimum number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed at the time of proposal creation. *DIFFERS from GovernerBravo\n        uint256 quorumVotes;\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint256 eta;\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint256 startBlock;\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint256 endBlock;\n        /// @notice Current number of votes in favor of this proposal\n        uint256 forVotes;\n        /// @notice Current number of votes in opposition to this proposal\n        uint256 againstVotes;\n        /// @notice Current number of votes for abstaining for this proposal\n        uint256 abstainVotes;\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        /// @notice Flag marking whether the proposal has been vetoed\n        bool vetoed;\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n        /// @notice The total supply at the time of proposal creation\n        uint256 totalSupply;\n        /// @notice The block at which this proposal was created\n        uint256 creationBlock;\n    }\n}\n\ninterface INounsDAOExecutor {\n    function delay() external view returns (uint256);\n\n    function GRACE_PERIOD() external view returns (uint256);\n\n    function acceptAdmin() external;\n\n    function queuedTransactions(bytes32 hash) external view returns (bool);\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external returns (bytes32);\n\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external;\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external payable returns (bytes memory);\n}\n\ninterface NounsTokenLike {\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96);\n\n    function totalSupply() external view returns (uint256);\n}\n"}, "lib/openzeppelin-contracts/contracts/access/IAccessControl.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"}, "lib/openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"}, "lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"}, "lib/openzeppelin-contracts-upgradeable/contracts/security/PausableUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"}, "lib/openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"}, "lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.30;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"}, "lib/relic-sdk/packages/contracts/interfaces/IBatchProver.sol": {"content": "/// SPDX-License-Identifier: MIT\n/// (c) Theori, Inc. 2022\n/// All rights reserved\n\nimport \"../lib/Facts.sol\";\n\npragma solidity ^0.8.30;\n\n/**\n * @title IBatchProver\n * @author Theori, Inc.\n * @notice IBatchProver is a standard interface implemented by some Relic provers.\n *         Supports proving multiple facts ephemerally or proving and storing\n *         them in the Reliquary.\n */\ninterface IBatchProver {\n    /**\n     * @notice prove multiple facts ephemerally\n     * @param proof the encoded proof, depends on the prover implementation\n     * @param store whether to store the facts in the reliquary\n     * @return facts the proven facts' information\n     */\n    function proveBatch(bytes calldata proof, bool store)\n        external\n        payable\n        returns (Fact[] memory facts);\n}\n"}, "lib/relic-sdk/packages/contracts/interfaces/IReliquary.sol": {"content": "/// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"../lib/Facts.sol\";\n\n/**\n * @title Holder of Relics and Artifacts\n * @author Theori, Inc.\n * @notice The Reliquary is the heart of Relic. All issuers of Relics and Artifacts\n *         must be added to the Reliquary. Queries about Relics and Artifacts should\n *         be made to the Reliquary.\n */\ninterface IReliquary is IAccessControl {\n    /**\n     * @notice Issued when a new prover is accepted into the Reliquary\n     * @param prover the address of the prover contract\n     * @param version the identifier that will always be associated with the prover\n     */\n    event NewProver(address prover, uint64 version);\n\n    /**\n     * @notice Issued when a new prover is placed under consideration for acceptance\n     *         into the Reliquary\n     * @param prover the address of the prover contract\n     * @param version the proposed identifier to always be associated with the prover\n     * @param timestamp the earliest this prover can be brought into the Reliquary\n     */\n    event PendingProverAdded(address prover, uint64 version, uint64 timestamp);\n\n    /**\n     * @notice Issued when an existing prover is banished from the Reliquary\n     * @param prover the address of the prover contract\n     * @param version the identifier that can never be used again\n     * @dev revoked provers may not issue new Relics or Artifacts. The meaning of\n     *      any previously introduced Relics or Artifacts is implementation dependent.\n     */\n    event ProverRevoked(address prover, uint64 version);\n\n    struct ProverInfo {\n        uint64 version;\n        FeeInfo feeInfo;\n        bool revoked;\n    }\n\n    enum FeeFlags {\n        FeeNone,\n        FeeNative,\n        FeeCredits,\n        FeeExternalDelegate,\n        FeeExternalToken\n    }\n\n    struct FeeInfo {\n        uint8 flags;\n        uint16 feeCredits;\n        // feeWei = feeWeiMantissa * pow(10, feeWeiExponent)\n        uint8 feeWeiMantissa;\n        uint8 feeWeiExponent;\n        uint32 feeExternalId;\n    }\n\n    function ADD_PROVER_ROLE() external view returns (bytes32);\n\n    function CREDITS_ROLE() external view returns (bytes32);\n\n    function DELAY() external view returns (uint64);\n\n    function GOVERNANCE_ROLE() external view returns (bytes32);\n\n    function SUBSCRIPTION_ROLE() external view returns (bytes32);\n\n    /**\n     * @notice activates a pending prover once the delay has passed. Callable by anyone.\n     * @param prover the address of the pending prover\n     */\n    function activateProver(address prover) external;\n\n    /**\n     * @notice Add credits to an account. Requires the CREDITS_ROLE.\n     * @param user The account to which more credits should be granted\n     * @param amount The number of credits to be added\n     */\n    function addCredits(address user, uint192 amount) external;\n\n    /**\n     * @notice Add/propose a new prover to prove facts. Requires the ADD_PROVER_ROLE.\n     * @param prover the address of the prover in question\n     * @param version the unique version string to associate with this prover\n     * @dev Provers and proposed provers must have unique version IDs\n     * @dev After the Reliquary is initialized, a review period of 64k blocks\n     *      must conclude before a prover may be added. The request must then\n     *      be re-submitted to take effect. Before initialization is complete,\n     *      the review period is skipped.\n     * @dev Emits PendingProverAdded when a prover is proposed for inclusion\n     */\n    function addProver(address prover, uint64 version) external;\n\n    /**\n     * @notice Add/update a subscription. Requires the SUBSCRIPTION_ROLE.\n     * @param user The subscriber account to modify\n     * @param ts The new block timestamp at which the subscription expires\n     */\n    function addSubscriber(address user, uint64 ts) external;\n\n    /**\n     * @notice Asserts that a particular block had a particular hash\n     * @param verifier The block history verifier to use for the query\n     * @param hash The block hash in question\n     * @param num The block number to query\n     * @param proof Any witness information needed by the verifier\n     * @dev Reverts if the given block was not proven to have the given hash.\n     * @dev A fee may be required based on the block in question\n     */\n    function assertValidBlockHash(\n        address verifier,\n        bytes32 hash,\n        uint256 num,\n        bytes memory proof\n    ) external payable;\n\n    /**\n     * @notice Asserts that a particular block had a particular hash. Callable only from provers.\n     * @param verifier The block history verifier to use for the query\n     * @param hash The block hash in question\n     * @param num The block number to query\n     * @param proof Any witness information needed by the verifier\n     * @dev Reverts if the given block was not proven to have the given hash.\n     * @dev This function is only for use by provers (reverts otherwise)\n     */\n    function assertValidBlockHashFromProver(\n        address verifier,\n        bytes32 hash,\n        uint256 num,\n        bytes memory proof\n    ) external view;\n\n    /**\n     * @notice Require that an appropriate fee is paid for proving a fact\n     * @param sender The account wanting to prove a fact\n     * @dev The fee is derived from the prover which calls this  function\n     * @dev Reverts if the fee is not sufficient\n     * @dev Only to be called by a prover\n     */\n    function checkProveFactFee(address sender) external payable;\n\n    /**\n     * @notice Helper function to query the status of a prover\n     * @param prover the ProverInfo associated with the prover in question\n     * @dev reverts if the prover is invalid or revoked\n     */\n    function checkProver(ProverInfo memory prover) external pure;\n\n    /**\n     * @notice Check how many credits a given account possesses\n     * @param user The account in question\n     * @return The number of credits\n     */\n    function credits(address user) external view returns (uint192);\n\n    /**\n     * @notice Verify if a particular block had a particular hash. Only callable by address(0),\n               for debug\n     * @param verifier The block history verifier to use for the query\n     * @param hash The block hash in question\n     * @param num The block number to query\n     * @param proof Any witness information needed by the verifier\n     * @return boolean indication of whether or not the given block was\n     *         proven to have the given hash.\n     * @dev This function is for use by off-chain tools only (reverts otherwise)\n     */\n    function debugValidBlockHash(\n        address verifier,\n        bytes32 hash,\n        uint256 num,\n        bytes memory proof\n    ) external view returns (bool);\n\n    /**\n     * @notice Query for associated information for a fact. Only callable by address(0), for debug\n     * @param account The address to which the fact belongs\n     * @param factSig The unique signature identifying the fact\n     * @return exists whether or not a fact with the given signature\n     *         is associated with the queried account\n     * @return version the prover version id that proved this fact\n     * @return data any associated fact data\n     * @dev This function is for use by off-chain tools only (reverts otherwise)\n     */\n    function debugVerifyFact(address account, FactSignature factSig)\n        external\n        view\n        returns (\n            bool exists,\n            uint64 version,\n            bytes memory data\n        );\n\n    function factFees(uint8) external view returns (FeeInfo memory);\n\n    function feeAccounts(address)\n        external\n        view\n        returns (uint64 subscriberUntilTime, uint192 credits);\n\n    function feeExternals(uint256) external view returns (address);\n\n    /**\n     * @notice Query for associated information for a fact. Only callable from provers.\n     * @param account The address to which the fact belongs\n     * @param factSig The unique signature identifying the fact\n     * @return exists whether or not a fact with the given signature\n     *         is associated with the queried account\n     * @return version the prover version id that proved this fact\n     * @return data any associated fact data\n     * @dev This function is only for use by provers (reverts otherwise)\n     */\n    function getFact(address account, FactSignature factSig)\n        external\n        view\n        returns (\n            bool exists,\n            uint64 version,\n            bytes memory data\n        );\n\n    /**\n     * @notice Determine the appropriate ETH fee to prove a fact\n     * @param prover The prover of the desired fact\n     * @return the fee in wei\n     * @dev Reverts if the fee is not to be paid in ETH\n     */\n    function getProveFactNativeFee(address prover) external view returns (uint256);\n\n    /**\n     * @notice Determine the appropriate token fee to prove a fact\n     * @param prover The prover of the desired fact\n     * @return the fee in wei\n     * @dev Reverts if the fee is not to be paid in external tokens\n     */\n    function getProveFactTokenFee(address prover) external view returns (uint256);\n\n    /**\n     * @notice Determine the appropriate ETH fee to query a fact\n     * @param factSig The signature of the desired fact\n     * @return the fee in wei\n     * @dev Reverts if the fee is not to be paid in ETH\n     */\n    function getVerifyFactNativeFee(FactSignature factSig) external view returns (uint256);\n\n    /**\n     * @notice Determine the appropriate token fee to query a fact\n     * @param factSig The signature of the desired fact\n     * @return the fee in wei\n     * @dev Reverts if the fee is not to be paid in external tokens\n     */\n    function getVerifyFactTokenFee(FactSignature factSig) external view returns (uint256);\n\n    function initialized() external view returns (bool);\n\n    /**\n     * @notice Check if an account has an active subscription\n     * @param user The account in question\n     * @return True if the account is active, otherwise false\n     */\n    function isSubscriber(address user) external view returns (bool);\n\n    function pendingProvers(address) external view returns (uint64 timestamp, uint64 version);\n\n    function provers(address)\n        external\n        view\n        returns (ProverInfo memory);\n\n    /**\n     * @notice Remove credits from an account. Requires the CREDITS_ROLE.\n     * @param user The account from which credits should be removed\n     * @param amount The number of credits to be removed\n     */\n    function removeCredits(address user, uint192 amount) external;\n\n    /**\n     * @notice Remove a subscription. Requires the SUBSCRIPTION_ROLE.\n     * @param user The subscriber account to modify\n     */\n    function removeSubscriber(address user) external;\n\n    /**\n     * @notice Deletes the fact from the Reliquary. Only callable from provers.\n     * @param account The account to which this information is bound (may be\n     *        the null account for information bound to no specific address)\n     * @param factSig The unique signature of the particular fact being deleted\n     * @dev May only be called by non-revoked provers\n     */\n    function resetFact(address account, FactSignature factSig) external;\n\n    /**\n     * @notice Stop accepting proofs from this prover. Requires the GOVERNANCE_ROLE.\n     * @param prover The prover to banish from the reliquary\n     * @dev Emits ProverRevoked\n     * @dev Note: existing facts proved by the prover may still stand\n     */\n    function revokeProver(address prover) external;\n\n    function setCredits(address user, uint192 amount) external;\n\n    /**\n     * @notice Adds the given information to the Reliquary. Only callable from provers.\n     * @param account The account to which this information is bound (may be\n     *        the null account for information bound to no specific address)\n     * @param factSig The unique signature of the particular fact being proven\n     * @param data Associated data to store with this item\n     * @dev May only be called by non-revoked provers\n     */\n    function setFact(\n        address account,\n        FactSignature factSig,\n        bytes memory data\n    ) external;\n\n    /**\n     * @notice Sets the FeeInfo for a particular fee class. Requires the GOVERNANCE_ROLE.\n     * @param cls The fee class\n     * @param feeInfo The FeeInfo to use for the class\n     * @param feeExternal An external fee provider (token or delegate). If\n     *        none is required, this should be set to 0.\n     */\n    function setFactFee(\n        uint8 cls,\n        FeeInfo memory feeInfo,\n        address feeExternal\n    ) external;\n\n    /**\n     * @notice Initialize the Reliquary, enforcing the time lock for new provers. Requires the\n               ADD_PROVER_ROLE.\n     */\n    function setInitialized() external;\n\n    /**\n     * @notice Sets the FeeInfo for a particular prover. Requires the GOVERNANCE_ROLE.\n     * @param prover The prover in question\n     * @param feeInfo The FeeInfo to use for the class\n     * @param feeExternal An external fee provider (token or delegate). If\n     *        none is required, this should be set to 0.\n     */\n    function setProverFee(\n        address prover,\n        FeeInfo memory feeInfo,\n        address feeExternal\n    ) external;\n\n    /**\n     * @notice Sets the FeeInfo for block verification. Requires the GOVERNANCE_ROLE.\n     * @param feeInfo The FeeInfo to use for the class\n     * @param feeExternal An external fee provider (token or delegate). If\n     *        none is required, this should be set to 0.\n     */\n    function setValidBlockFee(FeeInfo memory feeInfo, address feeExternal) external;\n\n    /**\n     * @notice Verify if a particular block had a particular hash\n     * @param verifier The block history verifier to use for the query\n     * @param hash The block hash in question\n     * @param num The block number to query\n     * @param proof Any witness information needed by the verifier\n     * @return boolean indication of whether or not the given block was\n     *         proven to have the given hash.\n     * @dev A fee may be required based on the block in question\n     */\n    function validBlockHash(\n        address verifier,\n        bytes32 hash,\n        uint256 num,\n        bytes memory proof\n    ) external payable returns (bool);\n\n    /**\n     * @notice Verify if a particular block had a particular hash. Only callable from provers.\n     * @param verifier The block history verifier to use for the query\n     * @param hash The block hash in question\n     * @param num The block number to query\n     * @param proof Any witness information needed by the verifier\n     * @return boolean indication of whether or not the given block was\n     *         proven to have the given hash.\n     * @dev This function is only for use by provers (reverts otherwise)\n     */\n    function validBlockHashFromProver(\n        address verifier,\n        bytes32 hash,\n        uint256 num,\n        bytes memory proof\n    ) external view returns (bool);\n\n    /**\n     * @notice FeeInfo struct for block hash queries\n     */\n    function verifyBlockFeeInfo() external view returns (FeeInfo memory);\n\n    /**\n     * @notice Query for associated information for a fact\n     * @param account The address to which the fact belongs\n     * @param factSig The unique signature identifying the fact\n     * @return exists whether or not a fact with the given signature\n     *         is associated with the queried account\n     * @return version the prover version id that proved this fact\n     * @return data any associated fact data\n     * @dev A fee may be required based on the factSig\n     */\n    function verifyFact(address account, FactSignature factSig)\n        external\n        payable\n        returns (\n            bool exists,\n            uint64 version,\n            bytes memory data\n        );\n\n    /**\n     * @notice Query for associated information for a fact which requires no query fee.\n     * @param account The address to which the fact belongs\n     * @param factSig The unique signature identifying the fact\n     * @return exists whether or not a fact with the given signature\n     *         is associated with the queried account\n     * @return version the prover version id that proved this fact\n     * @return data any associated fact data\n     * @dev This function is for use by anyone\n     * @dev This function reverts if the fact requires a fee to query\n     */\n    function verifyFactNoFee(address account, FactSignature factSig)\n        external\n        view\n        returns (\n            bool exists,\n            uint64 version,\n            bytes memory data\n        );\n\n    /**\n     * @notice Query for the prover version for a fact\n     * @param account The address to which the fact belongs\n     * @param factSig The unique signature identifying the fact\n     * @return exists whether or not a fact with the given signature\n     *         is associated with the queried account\n     * @return version the prover version id that proved this fact\n     * @dev A fee may be required based on the factSig\n     */\n    function verifyFactVersion(address account, FactSignature factSig)\n        external\n        payable\n        returns (bool exists, uint64 version);\n\n    /**\n     * @notice Query for the prover version for a fact which requires no query fee.\n     * @param account The address to which the fact belongs\n     * @param factSig The unique signature identifying the fact\n     * @return exists whether or not a fact with the given signature\n     *         is associated with the queried account\n     * @return version the prover version id that proved this fact\n     * @dev This function is for use by anyone\n     * @dev This function reverts if the fact requires a fee to query\n     */\n    function verifyFactVersionNoFee(address account, FactSignature factSig)\n        external\n        view\n        returns (bool exists, uint64 version);\n\n    /**\n     * @notice Reverse mapping of version information to the unique prover able\n     *         to issue statements with that version\n     */\n    function versions(uint64) external view returns (address);\n\n    /**\n     * @notice Extract accumulated fees. Requires the GOVERNANCE_ROLE.\n     * @param token The ERC20 token from which to extract fees. Or the 0 address for\n     *        native ETH\n     * @param dest The address to which fees should be transferred\n     */\n    function withdrawFees(address token, address dest) external;\n}\n"}, "lib/relic-sdk/packages/contracts/lib/FactSigs.sol": {"content": "/// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\nimport \"./Facts.sol\";\n\n/**\n * @title FactSigs\n * @author Theori, Inc.\n * @notice Helper functions for computing fact signatures\n */\nlibrary FactSigs {\n    /**\n     * @notice Produce the fact signature data for birth certificates\n     */\n    function birthCertificateFactSigData() internal pure returns (bytes memory) {\n        return abi.encode(\"BirthCertificate\");\n    }\n\n    /**\n     * @notice Produce the fact signature for a birth certificate fact\n     */\n    function birthCertificateFactSig() internal pure returns (FactSignature) {\n        return Facts.toFactSignature(Facts.NO_FEE, birthCertificateFactSigData());\n    }\n\n    /**\n     * @notice Produce the fact signature data for an account's storage root\n     * @param blockNum the block number to look at\n     * @param storageRoot the storageRoot for the account\n     */\n    function accountStorageFactSigData(uint256 blockNum, bytes32 storageRoot)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encode(\"AccountStorage\", blockNum, storageRoot);\n    }\n\n    /**\n     * @notice Produce a fact signature for an accoun't storage root\n     * @param blockNum the block number to look at\n     * @param storageRoot the storageRoot for the account\n     */\n    function accountStorageFactSig(uint256 blockNum, bytes32 storageRoot)\n        internal\n        pure\n        returns (FactSignature)\n    {\n        return\n            Facts.toFactSignature(Facts.NO_FEE, accountStorageFactSigData(blockNum, storageRoot));\n    }\n\n    /**\n     * @notice Produce the fact signature data for a storage slot\n     * @param slot the account's slot\n     * @param blockNum the block number to look at\n     */\n    function storageSlotFactSigData(bytes32 slot, uint256 blockNum)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encode(\"StorageSlot\", slot, blockNum);\n    }\n\n    /**\n     * @notice Produce a fact signature for a storage slot\n     * @param slot the account's slot\n     * @param blockNum the block number to look at\n     */\n    function storageSlotFactSig(bytes32 slot, uint256 blockNum)\n        internal\n        pure\n        returns (FactSignature)\n    {\n        return Facts.toFactSignature(Facts.NO_FEE, storageSlotFactSigData(slot, blockNum));\n    }\n\n    /**\n     * @notice Produce the fact signature data for a log\n     * @param blockNum the block number to look at\n     * @param txIdx the transaction index in the block\n     * @param logIdx the log index in the transaction\n     */\n    function logFactSigData(\n        uint256 blockNum,\n        uint256 txIdx,\n        uint256 logIdx\n    ) internal pure returns (bytes memory) {\n        return abi.encode(\"Log\", blockNum, txIdx, logIdx);\n    }\n\n    /**\n     * @notice Produce a fact signature for a log\n     * @param blockNum the block number to look at\n     * @param txIdx the transaction index in the block\n     * @param logIdx the log index in the transaction\n     */\n    function logFactSig(\n        uint256 blockNum,\n        uint256 txIdx,\n        uint256 logIdx\n    ) internal pure returns (FactSignature) {\n        return Facts.toFactSignature(Facts.NO_FEE, logFactSigData(blockNum, txIdx, logIdx));\n    }\n\n    /**\n     * @notice Produce the fact signature data for a block header\n     * @param blockNum the block number\n     */\n    function blockHeaderSigData(uint256 blockNum) internal pure returns (bytes memory) {\n        return abi.encode(\"BlockHeader\", blockNum);\n    }\n\n    /**\n     * @notice Produce the fact signature data for a block header\n     * @param blockNum the block number\n     */\n    function blockHeaderSig(uint256 blockNum) internal pure returns (FactSignature) {\n        return Facts.toFactSignature(Facts.NO_FEE, blockHeaderSigData(blockNum));\n    }\n\n    /**\n     * @notice Produce the fact signature data for an event fact\n     * @param eventId The event in question\n     */\n    function eventFactSigData(uint64 eventId) internal pure returns (bytes memory) {\n        return abi.encode(\"EventAttendance\", \"EventID\", eventId);\n    }\n\n    /**\n     * @notice Produce a fact signature for a given event\n     * @param eventId The event in question\n     */\n    function eventFactSig(uint64 eventId) internal pure returns (FactSignature) {\n        return Facts.toFactSignature(Facts.NO_FEE, eventFactSigData(eventId));\n    }\n}"}, "lib/relic-sdk/packages/contracts/lib/Facts.sol": {"content": "/// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\ntype FactSignature is bytes32;\n\nstruct Fact {\n    address account;\n    FactSignature sig;\n    bytes data;\n}\n\n/**\n * @title Facts\n * @author Theori, Inc.\n * @notice Helper functions for fact classes (part of fact signature that determines fee).\n */\nlibrary Facts {\n    uint8 internal constant NO_FEE = 0;\n\n    /**\n     * @notice construct a fact signature from a fact class and some unique data\n     * @param cls the fact class (determines the fee)\n     * @param data the unique data for the signature\n     */\n    function toFactSignature(uint8 cls, bytes memory data) internal pure returns (FactSignature) {\n        return FactSignature.wrap(bytes32((uint256(keccak256(data)) << 8) | cls));\n    }\n\n    /**\n     * @notice extracts the fact class from a fact signature\n     * @param factSig the input fact signature\n     */\n    function toFactClass(FactSignature factSig) internal pure returns (uint8) {\n        return uint8(uint256(FactSignature.unwrap(factSig)));\n    }\n}\n"}, "lib/relic-sdk/packages/contracts/lib/Storage.sol": {"content": "/// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\n/**\n * @title Storage\n * @author Theori, Inc.\n * @notice Helper functions for handling storage slot facts and computing storage slots\n */\nlibrary Storage {\n    /**\n     * @notice compute the slot for an element of a mapping\n     * @param base the slot of the struct base\n     * @param key the mapping key, padded to 32 bytes\n     */\n    function mapElemSlot(bytes32 base, bytes32 key) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(key, base));\n    }\n\n    /**\n     * @notice compute the slot for an element of a static array\n     * @param base the slot of the struct base\n     * @param idx the index of the element\n     * @param slotsPerElem the number of slots per element\n     */\n    function staticArrayElemSlot(\n        bytes32 base,\n        uint256 idx,\n        uint256 slotsPerElem\n    ) internal pure returns (bytes32) {\n        return bytes32(uint256(base) + idx * slotsPerElem);\n    }\n\n    /**\n     * @notice compute the slot for an element of a dynamic array\n     * @param base the slot of the struct base\n     * @param idx the index of the element\n     * @param slotsPerElem the number of slots per element\n     */\n    function dynamicArrayElemSlot(\n        bytes32 base,\n        uint256 idx,\n        uint256 slotsPerElem\n    ) internal pure returns (bytes32) {\n        return bytes32(uint256(keccak256(abi.encode(base))) + idx * slotsPerElem);\n    }\n\n    /**\n     * @notice compute the slot for a struct field given the base slot and offset\n     * @param base the slot of the struct base\n     * @param offset the slot offset in the struct\n     */\n    function structFieldSlot(\n        bytes32 base,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        return bytes32(uint256(base) + offset);\n    }\n\n    function _parseUint256(bytes memory data) internal pure returns (uint256) {\n        return uint256(bytes32(data)) >> (256 - 8 * data.length);\n    }\n\n    /**\n     * @notice parse a uint256 from storage slot bytes\n     * @param data the storage slot bytes\n     * @return address the parsed address\n     */\n    function parseUint256(bytes memory data) internal pure returns (uint256) {\n        require(data.length <= 32, 'data is not a uint256');\n        return _parseUint256(data);\n    }\n\n    /**\n     * @notice parse a uint64 from storage slot bytes\n     * @param data the storage slot bytes\n     */\n    function parseUint64(bytes memory data) internal pure returns (uint64) {\n        require(data.length <= 8, 'data is not a uint64');\n        return uint64(_parseUint256(data));\n    }\n\n    /**\n     * @notice parse an address from storage slot bytes\n     * @param data the storage slot bytes\n     */\n    function parseAddress(bytes memory data) internal pure returns (address) {\n        require(data.length <= 20, 'data is not an address');\n        return address(uint160(_parseUint256(data)));\n    }\n}\n"}, "lib/solady/src/utils/SafeTransferLib.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Caution! This library won't check that a token has code, responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /// @dev The ERC20 `transferFrom` has failed.\n    error TransferFromFailed();\n\n    /// @dev The ERC20 `transfer` has failed.\n    error TransferFailed();\n\n    /// @dev The ERC20 `approve` has failed.\n    error ApproveFailed();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         CONSTANTS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Suggested gas stipend for contract receiving ETH\n    /// that disallows any storage writes.\n    uint256 internal constant _GAS_STIPEND_NO_STORAGE_WRITES = 2300;\n\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\n    /// storage reads and writes, but low enough to prevent griefing.\n    /// Multiply by a small constant (e.g. 2), if needed.\n    uint256 internal constant _GAS_STIPEND_NO_GRIEF = 100000;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       ETH OPERATIONS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Sends `amount` (in wei) ETH to `to`.\n    /// Reverts upon failure.\n    function safeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\n                // Store the function selector of `ETHTransferFailed()`.\n                mstore(0x00, 0xb12d13eb)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    /// The `gasStipend` can be set to a low enough value to prevent\n    /// storage writes or gas griefing.\n    ///\n    /// If sending via the normal procedure fails, force sends the ETH by\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\n    ///\n    /// Reverts if the current contract has insufficient balance.\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If insufficient balance, revert.\n            if lt(selfbalance(), amount) {\n                // Store the function selector of `ETHTransferFailed()`.\n                mstore(0x00, 0xb12d13eb)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Transfer the ETH and check if it succeeded or not.\n            if iszero(call(gasStipend, to, amount, 0, 0, 0, 0)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                // We can directly use `SELFDESTRUCT` in the contract creation.\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\n                pop(create(amount, 0x0b, 0x16))\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a gas stipend\n    /// equal to `_GAS_STIPEND_NO_GRIEF`. This gas stipend is a reasonable default\n    /// for 99% of cases and can be overriden with the three-argument version of this\n    /// function if necessary.\n    ///\n    /// If sending via the normal procedure fails, force sends the ETH by\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\n    ///\n    /// Reverts if the current contract has insufficient balance.\n    function forceSafeTransferETH(address to, uint256 amount) internal {\n        // Manually inlined because the compiler doesn't inline functions with branches.\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If insufficient balance, revert.\n            if lt(selfbalance(), amount) {\n                // Store the function selector of `ETHTransferFailed()`.\n                mstore(0x00, 0xb12d13eb)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Transfer the ETH and check if it succeeded or not.\n            if iszero(call(_GAS_STIPEND_NO_GRIEF, to, amount, 0, 0, 0, 0)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                // We can directly use `SELFDESTRUCT` in the contract creation.\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\n                pop(create(amount, 0x0b, 0x16))\n            }\n        }\n    }\n\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    /// The `gasStipend` can be set to a low enough value to prevent\n    /// storage writes or gas griefing.\n    ///\n    /// Simply use `gasleft()` for `gasStipend` if you don't need a gas stipend.\n    ///\n    /// Note: Does NOT revert upon failure.\n    /// Returns whether the transfer of ETH is successful instead.\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and check if it succeeded or not.\n            success := call(gasStipend, to, amount, 0, 0, 0, 0)\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      ERC20 OPERATIONS                      */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for\n    /// the current contract to manage.\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n\n            // Store the function selector of `transferFrom(address,address,uint256)`.\n            mstore(0x00, 0x23b872dd)\n            mstore(0x20, from) // Store the `from` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x60, amount) // Store the `amount` argument.\n\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFromFailed()`.\n                mstore(0x00, 0x7939f424)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for\n    /// the current contract to manage.\n    function safeTransferAllFrom(address token, address from, address to)\n        internal\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n            mstore(0x20, from) // Store the `from` argument.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFromFailed()`.\n                mstore(0x00, 0x7939f424)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Store the function selector of `transferFrom(address,address,uint256)`.\n            mstore(0x00, 0x23b872dd)\n            mstore(0x40, to) // Store the `to` argument.\n            // The `amount` argument is already written to the memory word at 0x6a.\n            amount := mload(0x60)\n\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFromFailed()`.\n                mstore(0x00, 0x7939f424)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransfer(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x1a, to) // Store the `to` argument.\n            mstore(0x3a, amount) // Store the `amount` argument.\n            // Store the function selector of `transfer(address,uint256)`,\n            // left by 6 bytes (enough for 8tb of memory represented by the free memory pointer).\n            // We waste 6-3 = 3 bytes to save on 6 runtime gas (PUSH1 0x224 SHL).\n            mstore(0x00, 0xa9059cbb000000000000)\n\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    call(gas(), token, 0, 0x16, 0x44, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFailed()`.\n                mstore(0x00, 0x90b8ec18)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Restore the part of the free memory pointer that was overwritten,\n            // which is guaranteed to be zero, if less than 8tb of memory is used.\n            mstore(0x3a, 0)\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n            mstore(0x20, address()) // Store the address of the current contract.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x3a, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFailed()`.\n                mstore(0x00, 0x90b8ec18)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            mstore(0x1a, to) // Store the `to` argument.\n            // The `amount` argument is already written to the memory word at 0x3a.\n            amount := mload(0x3a)\n            // Store the function selector of `transfer(address,uint256)`,\n            // left by 6 bytes (enough for 8tb of memory represented by the free memory pointer).\n            // We waste 6-3 = 3 bytes to save on 6 runtime gas (PUSH1 0x224 SHL).\n            mstore(0x00, 0xa9059cbb000000000000)\n\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    call(gas(), token, 0, 0x16, 0x44, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFailed()`.\n                mstore(0x00, 0x90b8ec18)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Restore the part of the free memory pointer that was overwritten,\n            // which is guaranteed to be zero, if less than 8tb of memory is used.\n            mstore(0x3a, 0)\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// Reverts upon failure.\n    function safeApprove(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x1a, to) // Store the `to` argument.\n            mstore(0x3a, amount) // Store the `amount` argument.\n            // Store the function selector of `approve(address,uint256)`,\n            // left by 6 bytes (enough for 8tb of memory represented by the free memory pointer).\n            // We waste 6-3 = 3 bytes to save on 6 runtime gas (PUSH1 0x224 SHL).\n            mstore(0x00, 0x095ea7b3000000000000)\n\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    call(gas(), token, 0, 0x16, 0x44, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `ApproveFailed()`.\n                mstore(0x00, 0x3e3f8f73)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Restore the part of the free memory pointer that was overwritten,\n            // which is guaranteed to be zero, if less than 8tb of memory is used.\n            mstore(0x3a, 0)\n        }\n    }\n\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\n    /// Returns zero if the `token` does not exist.\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n            mstore(0x20, account) // Store the `account` argument.\n            amount :=\n                mul(\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gas(), token, 0x1c, 0x24, 0x20, 0x20)\n                    )\n                )\n        }\n    }\n}\n"}, "src/incentives/Motivator.sol": {"content": "// SPDX-License-Identifier: GPL-3.0\n\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\n\npragma solidity ^0.8.30;\n\n/// This is a base contract to aid in adding incentives to your protocol\nabstract contract Motivator {\n  /// Emitted when a caller receives a gas refund with tip\n  event GasRefundWithTip(address indexed to, uint256 refund, uint256 tip);\n\n  /// Base gas to refund\n  uint256 public constant REFUND_BASE_GAS = 36000;\n\n  /// Max priority fee used for refunds\n  uint256 public constant MAX_REFUND_PRIORITY_FEE = 1 gwei;\n\n  /// Max gas units that will be refunded\n  uint256 public constant MAX_REFUND_GAS_USED = 200_000;\n\n  /// Refunds gas spent on a transaction and includes a tip\n  function _gasRefundWithTipAndCap(\n    uint256 _startGas,\n    uint256 _cap,\n    uint256 _maxBaseFee,\n    uint256 _tip\n  ) internal view returns (uint256) {\n    unchecked {\n      uint256 balance = address(this).balance;\n      if (balance == 0) {\n        return 0;\n      }\n\n      uint256 basefee = min(block.basefee, _maxBaseFee);\n      uint256 gasPrice = min(tx.gasprice, basefee + MAX_REFUND_PRIORITY_FEE);\n      uint256 gasUsed = min(_startGas - gasleft() + REFUND_BASE_GAS, MAX_REFUND_GAS_USED);\n      uint256 refundAmount = min((gasPrice * gasUsed) + _tip, balance);\n      return min(_cap, refundAmount);\n    }\n  }\n\n  /// Returns the min of two integers\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n}\n"}, "src/module/Module.sol": {"content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.30;\n\n/// Wraps Federation module functionality\ninterface Module {\n  /// init is called when a new module is enabled from a base wallet\n  function init(bytes calldata) external payable;\n}\n"}, "src/module/governance-pool/FactValidator.sol": {"content": "// SPDX-License-Identifier: GPL-3.0\n\nimport { Fact, FactSignature } from \"relic-sdk/packages/contracts/lib/Facts.sol\";\nimport { FactSigs } from \"relic-sdk/packages/contracts/lib/FactSigs.sol\";\n\npragma solidity ^0.8.30;\n\ninterface Validator {\n  function validate(Fact memory fact, bytes32 expectedSlot, uint256 expectedBlock, address account)\n    external\n    pure\n    returns (bool);\n}\n\n/// FactValidator abstracts proof validation functionality\ncontract FactValidator is Validator {\n  function validate(Fact memory fact, bytes32 expectedSlot, uint256 expectedBlock, address account)\n    external\n    pure\n    returns (bool)\n  {\n    FactSignature expectedSig = FactSigs.storageSlotFactSig(expectedSlot, expectedBlock);\n    if (keccak256(abi.encodePacked(fact.sig)) != keccak256(abi.encodePacked(expectedSig))) {\n      return false;\n    }\n\n    if (fact.account != account) {\n      return false;\n    }\n\n    return true;\n  }\n}\n"}, "src/module/governance-pool/GovernancePool.sol": {"content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.30;\n\nimport { Module } from \"src/module/Module.sol\";\nimport { ModuleConfig } from \"src/module/governance-pool/ModuleConfig.sol\";\n\n/// GovernancePool Wraps governance pool module functionality\ninterface GovernancePool is Module {\n  error InitExternalDAONotSet();\n  error InitExternalTokenNotSet();\n  error InitFeeRecipientNotSet();\n  error InitCastWindowNotSet();\n  error InitBaseWalletNotSet();\n\n  error BidTooLow();\n  error BidAuctionEnded();\n  error BidInvalidSupport();\n  error BidReserveNotMet();\n  error BidProposalNotActive();\n  error BidVoteAlreadyCast();\n  error BidMaxBidExceeded();\n  error BidModulePaused();\n\n  error CastVoteBidDoesNotExist();\n  error CastVoteNotInWindow();\n  error CastVoteNoDelegations();\n  error CastVoteMustWait();\n  error CastVoteAlreadyCast();\n\n  error ClaimOnlyBidder();\n  error ClaimAlreadyRefunded();\n  error ClaimNotRefundable();\n\n  error WithdrawDelegateOrOwnerOnly();\n  error WithdrawBidNotOffered();\n  error WithdrawBidRefunded();\n  error WithdrawVoteNotCast();\n  error WithdrawPropIsActive();\n  error WithdrawAlreadyClaimed();\n  error WithdrawInvalidProof(string);\n  error WithdrawNoBalanceAtPropStart();\n  error WithdrawNoTokensDelegated();\n  error WithdrawMaxProverVersion();\n\n  /// Bid is the structure of an offer to cast a vote on a proposal\n  struct Bid {\n    /// The amount of ETH bid\n    uint256 amount;\n    /// The remaining amount of ETH left to be withdrawn\n    uint256 remainingAmount;\n    /// The remaining amount of votes left to withdraw proceeds from the pool\n    uint256 remainingVotes;\n    /// The block number the external proposal was created\n    uint256 creationBlock;\n    /// The block number the external proposal voting period started\n    uint256 startBlock;\n    /// The block number the external proposal voting period ends\n    uint256 endBlock;\n    /// the block number the bid was made\n    uint256 bidBlock;\n    /// The support value to cast if this bid wins\n    uint256 support;\n    /// The address of the bidder\n    address bidder;\n    /// Whether the vote was cast for this bid\n    bool executed;\n    /// Whether the bid was refunded\n    bool refunded;\n  }\n\n  /// Emitted when a vote has been cast against an external proposal\n  event VoteCast(\n    address indexed dao, uint256 indexed propId, uint256 support, uint256 amount, address bidder\n  );\n\n  /// Emitted when a bid has been placed\n  event BidPlaced(\n    address indexed dao, uint256 indexed propId, uint256 support, uint256 amount, address bidder\n  );\n\n  /// Emitted when a refund has been claimed\n  event RefundClaimed(\n    address indexed dao, uint256 indexed propId, uint256 amount, address receiver\n  );\n\n  /// Emitted when proceeds have been withdrawn for a proposal\n  event Withdraw(address indexed dao, address indexed receiver, uint256[] propId, uint256 amount);\n\n  /// Emitted when a protocol fee has been applied when casting votes\n  event ProtocolFeeApplied(address indexed recipient, uint256 amount);\n\n  /// Bid on a proposal\n  function bid(uint256, uint256) external payable;\n\n  /// Cast a vote from the contract to external proposal\n  function castVote(uint256) external;\n\n  /// Claim a refund for a bid where the vote was not cast\n  function claimRefund(uint256) external;\n\n  /// Withdraw proceeds in proportion of delegation from a bid where the vote was cast\n  /// A max of 5 props can be withdrawn from at once\n  function withdraw(\n    address _prover,\n    address _delegator,\n    uint256[] calldata _pId,\n    uint256[] calldata _fee,\n    bytes[] calldata _proof\n  ) external payable returns (uint256);\n\n  /// Get the bid for a proposal\n  function getBid(uint256 _pId) external view returns (Bid memory);\n\n  /// Returns whether an account has made a withdrawal for a proposal\n  function withdrawn(uint256 _pId, address _account) external view returns (bool);\n\n  /// Returns the next minimum bid amount for a proposal\n  function minBidAmount(uint256 _pid) external view returns (uint256);\n}\n"}, "src/module/governance-pool/ModuleConfig.sol": {"content": "// SPDX-License-Identifier: GPL-3.0\n\nimport { OwnableUpgradeable } from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\nimport { IDelegationRegistry } from \"delegate-cash/IDelegationRegistry.sol\";\nimport { IBatchProver } from \"relic-sdk/packages/contracts/interfaces/IBatchProver.sol\";\nimport { IReliquary } from \"relic-sdk/packages/contracts/interfaces/IReliquary.sol\";\nimport { GovernancePool } from \"src/module/governance-pool/GovernancePool.sol\";\nimport { Wallet } from \"src/wallet/Wallet.sol\";\n\npragma solidity ^0.8.30;\n\n// The storage slot index of the mapping containing Nouns token balance\nbytes32 constant SLOT_INDEX_TOKEN_BALANCE = bytes32(uint256(4));\n\n// The storage slot index of the mapping containing Nouns delegate addresses\nbytes32 constant SLOT_INDEX_DELEGATE = bytes32(uint256(11));\n\nabstract contract ModuleConfig is OwnableUpgradeable {\n  /// Emitted when storage slots are updated\n  event SlotsUpdated(bytes32 balanceSlot, bytes32 delegateSlot);\n\n  /// Emitted when the config is updated\n  event ConfigChanged();\n\n  /// Returns if a lock is active for this module\n  error ConfigModuleHasActiveLock();\n\n  /// Config is the structure of cfg for a Governance Pool module\n  struct Config {\n    /// The base wallet address for this module\n    address base;\n    /// The address of the DAO we are casting votes against\n    address externalDAO;\n    /// The address of the token used for voting in the external DAO\n    address externalToken;\n    /// feeRecipient is the address that receives any configured protocol fee\n    address feeRecipient;\n    /// The minimum bid accepted to cast a vote\n    uint256 reservePrice;\n    /// castWaitBlocks prevents any votes from being cast until this time in blocks has passed\n    uint256 castWaitBlocks;\n    /// The minimum percent difference between the last bid placed for a\n    /// proposal vote and the current one\n    uint256 minBidIncrementPercentage;\n    /// The window in blocks when a vote can be cast\n    uint256 castWindow;\n    /// The default tip configured for casting a vote\n    uint256 tip;\n    /// feeBPS as parts per 10_000, i.e. 10% = 1000\n    uint256 feeBPS;\n    /// The maximum amount of base fee that can be refunded when casting a vote\n    uint256 maxBaseFeeRefund;\n    /// max relic batch prover version; if 0 any prover version is accepted\n    uint256 maxProverVersion;\n    /// relic reliquary address\n    address reliquary;\n    /// delegate cash registry address\n    address dcash;\n    /// fact validator address\n    address factValidator;\n    /// in preparation for Nouns governance v2->v3 we need to know\n    /// handle switching vote snapshots to a proposal's start block\n    uint256 useStartBlockFromPropId;\n    /// configurable vote reason\n    string reason;\n  }\n\n  /// The storage slot index containing nouns token balance mappings\n  bytes32 public balanceSlotIdx = SLOT_INDEX_TOKEN_BALANCE;\n\n  /// The storage slot index containing nouns delegate mappings\n  bytes32 public delegateSlotIdx = SLOT_INDEX_DELEGATE;\n\n  /// The config of this module\n  Config internal _cfg;\n\n  modifier isNotLocked() {\n    _isNotLocked();\n    _;\n  }\n\n  /// Reverts if the module has an open lock\n  function _isNotLocked() internal view virtual {\n    if (Wallet(_cfg.base).hasActiveLock()) {\n      revert ConfigModuleHasActiveLock();\n    }\n  }\n\n  /// Management function to get this contracts config\n  function getConfig() external view returns (Config memory) {\n    return _cfg;\n  }\n\n  /// Management function to update the config post initialization\n  function setConfig(Config memory _config) external onlyOwner isNotLocked {\n    // fees cannot be updated after initialization\n    _config.feeBPS = _cfg.feeBPS;\n    _config.feeRecipient = _cfg.feeRecipient;\n\n    _cfg = _validateConfig(_config);\n    emit ConfigChanged();\n  }\n\n  function setTipAndRefund(uint256 _tip, uint256 _maxBaseFeeRefund) external onlyOwner isNotLocked {\n    _cfg.tip = _tip;\n    _cfg.maxBaseFeeRefund = _maxBaseFeeRefund;\n    emit ConfigChanged();\n  }\n\n  /// Management function to set token storage slots for proof verification\n  function setSlots(uint256 balanceSlot, uint256 delegateSlot) external onlyOwner isNotLocked {\n    balanceSlotIdx = bytes32(balanceSlot);\n    delegateSlotIdx = bytes32(delegateSlot);\n    emit SlotsUpdated(balanceSlotIdx, delegateSlotIdx);\n  }\n\n  /// Management function to update dependency addresses\n  function setAddresses(address _reliquary, address _delegateCash, address _factValidator)\n    external\n    onlyOwner\n    isNotLocked\n  {\n    require(_reliquary != address(0), \"invalid reliquary addr\");\n    require(_delegateCash != address(0), \"invalid delegate cash registry addr\");\n    require(_factValidator != address(0), \"invalid fact validator addr\");\n\n    _cfg.reliquary = _reliquary;\n    _cfg.dcash = _delegateCash;\n    _cfg.factValidator = _factValidator;\n    emit ConfigChanged();\n  }\n\n  /// Management function to set a max required prover version\n  /// Protects the pool in the event that relic is compromised\n  function setMaxProverVersion(uint256 _version) external onlyOwner {\n    _cfg.maxProverVersion = _version;\n    emit ConfigChanged();\n  }\n\n  /// Management function to set the prop id for when we should start using\n  /// proposal start blocks for voting snapshots\n  function setUseStartBlockFromPropId(uint256 _pId) external onlyOwner {\n    _cfg.useStartBlockFromPropId = _pId;\n    emit ConfigChanged();\n  }\n\n  /// Management function to set vote reason\n  function setReason(string calldata _reason) external onlyOwner {\n    _cfg.reason = _reason;\n    emit ConfigChanged();\n  }\n\n  /// Management function to reduce fees\n  function setFeeBPS(uint256 _feeBPS) external onlyOwner {\n    require(_feeBPS < _cfg.feeBPS, \"fee cannot be increased\");\n    _cfg.feeBPS = _feeBPS;\n    emit ConfigChanged();\n  }\n\n  /// Management function to update auction reserve price\n  function setReservePrice(uint256 _reservePrice) external onlyOwner {\n    require(_reservePrice > 0, \"reserve cannot be 0\");\n    _cfg.reservePrice = _reservePrice;\n    emit ConfigChanged();\n  }\n\n  /// Management function to update castWindow\n  function setCastWindow(uint256 _castWindow) external onlyOwner {\n    require(_castWindow > 0, \"cast window 0\");\n    _cfg.castWindow = _castWindow;\n    emit ConfigChanged();\n  }\n\n  /// Validates that the config is set properly and sets default values if necessary\n  function _validateConfig(Config memory _config) internal pure returns (Config memory) {\n    if (_config.castWindow == 0) {\n      revert GovernancePool.InitCastWindowNotSet();\n    }\n\n    if (_config.externalDAO == address(0)) {\n      revert GovernancePool.InitExternalDAONotSet();\n    }\n\n    if (_config.externalToken == address(0)) {\n      revert GovernancePool.InitExternalTokenNotSet();\n    }\n\n    if (_config.feeBPS > 0 && _config.feeRecipient == address(0)) {\n      revert GovernancePool.InitFeeRecipientNotSet();\n    }\n\n    if (_config.base == address(0)) {\n      revert GovernancePool.InitBaseWalletNotSet();\n    }\n\n    // default reserve price\n    if (_config.reservePrice == 0) {\n      _config.reservePrice = 1 wei;\n    }\n\n    // default cast wait blocks 5 ~= 1 minute\n    if (_config.castWaitBlocks == 0) {\n      _config.castWaitBlocks = 5;\n    }\n\n    return _config;\n  }\n}\n"}, "src/module/governance-pool/Nouns.sol": {"content": "// SPDX-License-Identifier: GPL-3.0\n\nimport { GovernancePool } from \"src/module/governance-pool/GovernancePool.sol\";\nimport { Motivator } from \"src/incentives/Motivator.sol\";\nimport {\n  ModuleConfig,\n  SLOT_INDEX_TOKEN_BALANCE,\n  SLOT_INDEX_DELEGATE\n} from \"src/module/governance-pool/ModuleConfig.sol\";\nimport { Wallet } from \"src/wallet/Wallet.sol\";\nimport { Validator } from \"src/module/governance-pool/FactValidator.sol\";\nimport { IReliquary } from \"relic-sdk/packages/contracts/interfaces/IReliquary.sol\";\nimport { IDelegationRegistry } from \"delegate-cash/IDelegationRegistry.sol\";\nimport { IBatchProver } from \"relic-sdk/packages/contracts/interfaces/IBatchProver.sol\";\nimport { Fact, FactSignature } from \"relic-sdk/packages/contracts/lib/Facts.sol\";\nimport { Storage } from \"relic-sdk/packages/contracts/lib/Storage.sol\";\nimport { FactSigs } from \"relic-sdk/packages/contracts/lib/FactSigs.sol\";\nimport { PausableUpgradeable } from \"openzeppelin-upgradeable/security/PausableUpgradeable.sol\";\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\nimport { NounsDAOStorageV2 } from \"nouns-contracts/governance/NounsDAOInterfaces.sol\";\n\npragma solidity ^0.8.30;\n\n/// Wrapper for NounsDAOStorageV2 functionality\ninterface NounsGovernanceV2 {\n  function castRefundableVoteWithReason(uint256, uint8, string calldata) external;\n  function proposals(uint256) external view returns (NounsDAOStorageV2.ProposalCondensed memory);\n  function state(uint256) external view returns (uint256);\n}\n\n/// Wrapper for Nouns token governance functionality\ninterface NounsToken {\n  function getPriorVotes(address, uint256) external view returns (uint96);\n}\n\n// This module auctions off the collective voting power delegated to the highest\n// bidder. Delegators can withdraw proceeds in proportion to their share of the\n// pool for each prop once a vote has been cast and the voting period ends.\ncontract NounsPool is PausableUpgradeable, Motivator, GovernancePool, ModuleConfig {\n  /// The name of this contract\n  string public constant name = \"Federation Nouns Governance Pool v0.1\";\n\n  /// The maximum uint256 value. Necessary to track this for overflow reasons\n  /// fee switch as bps\n  uint256 internal constant MAX_INT = type(uint256).max;\n\n  /// The active bid on each proposal\n  mapping(uint256 => Bid) internal bids;\n\n  /// The delegators that have withdrawn proceeds from a bid\n  mapping(uint256 => mapping(address => bool)) internal withdrawals;\n\n  /// Do not leave implementation uninitialized\n  constructor() {\n    _disableInitializers();\n  }\n\n  /// Module initialization; Can only be called once\n  function init(bytes calldata _data) external payable initializer {\n    __Ownable_init();\n    __Pausable_init();\n\n    _cfg = _validateConfig(abi.decode(_data, (Config)));\n\n    balanceSlotIdx = SLOT_INDEX_TOKEN_BALANCE;\n    delegateSlotIdx = SLOT_INDEX_DELEGATE;\n\n    if (msg.sender != _cfg.base) {\n      _transferOwnership(_cfg.base);\n    }\n  }\n\n  /// Submit a bid for a proposal vote\n  function bid(uint256 _pId, uint256 _support) external payable {\n    if (_support > 2) {\n      revert BidInvalidSupport();\n    }\n\n    if (msg.value < _cfg.reservePrice) {\n      revert BidReserveNotMet();\n    }\n\n    // we calc fee shares using bps; we need to ensure that\n    // the bid amount can never overflow any of our math calcs\n    if (msg.value >= MAX_INT / 10000) {\n      revert BidMaxBidExceeded();\n    }\n\n    // only allow bidding on a prop if voting is active\n    if (!_active(_pId)) {\n      revert BidProposalNotActive();\n    }\n\n    Bid storage b = bids[_pId];\n    if (b.executed) {\n      revert BidVoteAlreadyCast();\n    }\n\n    address lastBidder = b.bidder;\n    uint256 lastAmount = b.amount;\n    if (msg.value < this.minBidAmount(_pId)) {\n      revert BidTooLow();\n    }\n\n    // prevent a new auction from starting if the module is paused\n    if (paused() && lastAmount == 0) {\n      revert BidModulePaused();\n    }\n\n    // if we are in the cast window and have a winning bid, the auction has ended and the\n    // vote can be cast. auctions are not extended so that we can always guarantee a vote\n    // is cast before the external proposal voting period ends\n    if (block.number + _cfg.castWindow > b.endBlock) {\n      if (lastAmount >= _cfg.reservePrice) {\n        revert BidAuctionEnded();\n      }\n    }\n\n    b.amount = msg.value;\n    b.bidder = msg.sender;\n    b.support = _support;\n    b.bidBlock = block.number;\n    b.remainingAmount = b.amount;\n\n    NounsDAOStorageV2.ProposalCondensed memory eProp =\n      NounsGovernanceV2(_cfg.externalDAO).proposals(_pId);\n    b.creationBlock = eProp.creationBlock;\n    b.startBlock = eProp.startBlock;\n    b.endBlock = eProp.endBlock;\n\n    // request base lock so that this module cannot be disabled while a bid is active\n    // requestLock works on a rolling basis so this module will always be allowed\n    // to cast votes if it has an active bid\n    Wallet(_cfg.base).requestLock((b.endBlock + 1) - block.number);\n\n    // refund any previous bid on this prop\n    if (lastBidder != address(0)) {\n      SafeTransferLib.forceSafeTransferETH(lastBidder, lastAmount);\n    }\n\n    emit BidPlaced(_cfg.externalDAO, _pId, _support, b.amount, msg.sender);\n  }\n\n  /// Refunds a bid if a proposal is canceled, vetoed, or votes could not be cast\n  function claimRefund(uint256 _pId) external {\n    Bid storage b = bids[_pId];\n\n    if (msg.sender != b.bidder) {\n      revert ClaimOnlyBidder();\n    }\n\n    if (b.refunded) {\n      revert ClaimAlreadyRefunded();\n    }\n\n    if (_refundable(_pId, b.executed)) {\n      b.refunded = true;\n      SafeTransferLib.forceSafeTransferETH(b.bidder, b.remainingAmount);\n      emit RefundClaimed(_cfg.externalDAO, _pId, b.remainingAmount, msg.sender);\n      return;\n    }\n\n    revert ClaimNotRefundable();\n  }\n\n  /// Casts a vote on an external proposal. A tip is awarded to the caller\n  function castVote(uint256 _pId) external {\n    Bid storage b = bids[_pId];\n    if (b.amount == 0) {\n      revert CastVoteBidDoesNotExist();\n    }\n\n    if (block.number + _cfg.castWindow < b.endBlock) {\n      revert CastVoteNotInWindow();\n    }\n\n    // no atomic bid / casts\n    if (block.number < b.bidBlock + _cfg.castWaitBlocks) {\n      revert CastVoteMustWait();\n    }\n\n    if (b.executed) {\n      revert CastVoteAlreadyCast();\n    }\n\n    b.executed = true;\n    b.remainingVotes =\n      NounsToken(_cfg.externalToken).getPriorVotes(_cfg.base, _voteSnapshotBlock(b, _pId));\n\n    if (b.remainingVotes == 0) {\n      revert CastVoteNoDelegations();\n    }\n\n    // cast vwr through base wallet, Nouns refunds gas\n    bytes4 s = NounsGovernanceV2.castRefundableVoteWithReason.selector;\n    bytes memory callData = abi.encodeWithSelector(s, _pId, uint8(b.support), _cfg.reason);\n    Wallet(_cfg.base).execute(_cfg.externalDAO, 0, callData);\n\n    // base tx refund covers validation checks performed in this fn before\n    // votes were cast\n    uint256 startGas = gasleft();\n    emit VoteCast(_cfg.externalDAO, _pId, b.support, b.amount, b.bidder);\n\n    // protocol fee switch\n    uint256 fee;\n    if (_cfg.feeBPS > 0) {\n      fee = _bpsToUint(_cfg.feeBPS, b.amount);\n      b.remainingAmount -= fee;\n    }\n\n    // deduct gas refund and tip from bid proceeds to incentivize casting of a vote\n    // cap refund + tip by the bid amount so that we can never refund more than the\n    // highest bid - any fees applied\n    uint256 refund =\n      _gasRefundWithTipAndCap(startGas, b.remainingAmount, _cfg.maxBaseFeeRefund, _cfg.tip);\n\n    b.remainingAmount -= refund;\n\n    if (fee > 0) {\n      SafeTransferLib.forceSafeTransferETH(_cfg.feeRecipient, fee);\n      emit ProtocolFeeApplied(_cfg.feeRecipient, fee);\n    }\n\n    SafeTransferLib.forceSafeTransferETH(tx.origin, refund);\n    emit GasRefundWithTip(tx.origin, refund, _cfg.tip);\n  }\n\n  /// Withdraw proceeds from a proposal in proportion to voting weight delegated\n  function withdraw(\n    address _tokenOwner,\n    address _prover,\n    uint256[] calldata _pIds,\n    uint256[] calldata _fee,\n    bytes[] calldata _proofBatches\n  ) external payable returns (uint256) {\n    // verify prover version is a valid relic contract\n    IReliquary reliq = IReliquary(_cfg.reliquary);\n    IReliquary.ProverInfo memory p = reliq.provers(_prover);\n    reliq.checkProver(p);\n    if (_cfg.maxProverVersion != 0) {\n      if (p.version > _cfg.maxProverVersion) {\n        revert WithdrawMaxProverVersion();\n      }\n    }\n\n    // to withdraw, sender must have permission set in the delegate cash registry\n    // or they must be the owner of the Nouns delegated to the base wallet\n    if (msg.sender != _tokenOwner) {\n      IDelegationRegistry dr = IDelegationRegistry(_cfg.dcash);\n      bool isDelegate = dr.checkDelegateForContract(msg.sender, _tokenOwner, address(this));\n      if (!isDelegate) {\n        revert WithdrawDelegateOrOwnerOnly();\n      }\n    }\n\n    // calc the slot for the balance and delegate of the token owner to ensure that\n    // proofs cannot be spoofed\n    bytes32 balanceSlot = Storage.mapElemSlot(balanceSlotIdx, _addressToBytes32(_tokenOwner));\n\n    bytes32 delegateSlot = Storage.mapElemSlot(delegateSlotIdx, _addressToBytes32(_tokenOwner));\n\n    // how many props to loop over\n    uint256 len = _pIds.length;\n\n    // keep track of total amount to withdraw\n    uint256 withdrawAmount;\n\n    for (uint256 i = 0; i < len;) {\n      Bid storage b = bids[_pIds[i]];\n      if (b.amount == 0) {\n        revert WithdrawBidNotOffered();\n      }\n\n      if (_refundable(_pIds[i], b.executed)) {\n        revert WithdrawBidRefunded();\n      }\n\n      if (!b.executed) {\n        revert WithdrawVoteNotCast();\n      }\n\n      if (withdrawals[_pIds[i]][_tokenOwner]) {\n        revert WithdrawAlreadyClaimed();\n      }\n\n      // only allow withdrawals after the voting period has ended\n      if (_active(_pIds[i])) {\n        revert WithdrawPropIsActive();\n      }\n\n      // prevent multiple withdrawals from the same user on this prop\n      withdrawals[_pIds[i]][_tokenOwner] = true;\n\n      // validate that proofs are correctly formatted (for the correct slot, block, and token address)\n      Fact[] memory facts =\n        IBatchProver(_prover).proveBatch{ value: _fee[i] }(_proofBatches[i], false);\n\n      Validator v = Validator(_cfg.factValidator);\n      if (!v.validate(facts[0], balanceSlot, _voteSnapshotBlock(b, _pIds[i]), _cfg.externalToken)) {\n        revert WithdrawInvalidProof(\"balanceOf\");\n      }\n\n      if (!v.validate(facts[1], delegateSlot, _voteSnapshotBlock(b, _pIds[i]), _cfg.externalToken))\n      {\n        revert WithdrawInvalidProof(\"delegate\");\n      }\n\n      bytes memory slotBalanceData = facts[0].data;\n      uint256 nounsBalanceVal = Storage.parseUint256(slotBalanceData);\n      if (nounsBalanceVal == 0) {\n        revert WithdrawNoBalanceAtPropStart();\n      }\n\n      // ensure that the owner had delegated their Nouns to the base wallet when voting\n      // started on this proposal\n      bytes memory slotDelegateData = facts[1].data;\n      address nounsDelegateVal = Storage.parseAddress(slotDelegateData);\n      if (nounsDelegateVal != _cfg.base) {\n        revert WithdrawNoTokensDelegated();\n      }\n\n      uint256 ownerShare = (nounsBalanceVal * b.remainingAmount) / b.remainingVotes;\n      withdrawAmount += ownerShare;\n\n      b.remainingVotes -= nounsBalanceVal;\n      b.remainingAmount -= withdrawAmount;\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    if (withdrawAmount > 0) {\n      SafeTransferLib.forceSafeTransferETH(_tokenOwner, withdrawAmount);\n      emit Withdraw(_cfg.externalDAO, _tokenOwner, _pIds, withdrawAmount);\n    }\n\n    return withdrawAmount;\n  }\n\n  /// Locks the contract to prevent bidding on new proposals\n  function pause() external onlyOwner {\n    _pause();\n  }\n\n  /// Unlocks the contract to allow bidding\n  function unpause() external onlyOwner {\n    _unpause();\n  }\n\n  /// Returns the latest bid for the given proposal\n  function getBid(uint256 _pId) external view returns (Bid memory) {\n    return bids[_pId];\n  }\n\n  /// Returns whether an account has made a withdrawal for a proposal\n  function withdrawn(uint256 _pId, address _account) external view returns (bool) {\n    return withdrawals[_pId][_account];\n  }\n\n  /// Returns the next minimum bid amount for a proposal\n  function minBidAmount(uint256 _pid) external view returns (uint256) {\n    Bid memory b = bids[_pid];\n    if (b.amount == 0) {\n      return _cfg.reservePrice;\n    }\n\n    return b.amount + ((b.amount * _cfg.minBidIncrementPercentage) / 100);\n  }\n\n  /// Helper that calculates percent of number using bps\n  function _bpsToUint(uint256 bps, uint256 number) internal pure returns (uint256) {\n    require(number < MAX_INT / 10000);\n    require(bps <= 10000);\n\n    return (number * bps) / 10000;\n  }\n\n  /// Helper that converts type address to bytes32\n  function _addressToBytes32(address _addr) internal pure returns (bytes32) {\n    return bytes32(uint256(uint160(_addr)));\n  }\n\n  /// Helper that determines if a bid is eligible for a refund\n  /// Canceled or vetoed proposals are always refundable.\n  function _refundable(uint256 _pId, bool _voteCast) internal view returns (bool) {\n    uint256 state = NounsGovernanceV2(_cfg.externalDAO).state(_pId);\n\n    // canceled\n    if (state == 2) {\n      return true;\n    }\n\n    // vetoed\n    if (state == 8) {\n      return true;\n    }\n\n    // pending, active, or updatable states should never be refundable since\n    // voting is either in progress or has not started\n    // 0 == Pending, 1 == Active, 10 == Updatable\n    if (state == 0 || state == 1 || state == 10) {\n      return false;\n    }\n\n    // if votes were not cast against the proposal, it is refundable\n    return !_voteCast;\n  }\n\n  /// Helper that determines whether to use startBlock or creationBlock for voting\n  /// on proposals. This ensures that the module is compatible with future\n  /// expected Nouns governance updates\n  function _voteSnapshotBlock(Bid memory _b, uint256 _pId) internal view returns (uint256) {\n    // default to using creation block\n    if (_cfg.useStartBlockFromPropId == 0) {\n      return _b.creationBlock;\n    }\n\n    if (_pId >= _cfg.useStartBlockFromPropId) {\n      return _b.startBlock;\n    }\n\n    return _b.creationBlock;\n  }\n\n  /// Helper that determines if a proposal voting period is active\n  function _active(uint256 _pId) internal view returns (bool) {\n    return NounsGovernanceV2(_cfg.externalDAO).state(_pId) == 1;\n  }\n}\n"}, "src/wallet/Wallet.sol": {"content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.30;\n\n/// Wraps the functionality of a Federation base wallet\ninterface Wallet {\n  error NotEnabled();\n  error ModuleAlreadyInitialized();\n  error TransactionReverted();\n  error LockDurationRequestTooLong();\n  error LockActive();\n\n  event SetModule(address indexed module, bool enabled);\n\n  event ExecuteTransaction(address indexed caller, address indexed target, uint256 value);\n\n  event Received(uint256 indexed value, address indexed sender, bytes data);\n\n  event RequestLock(address indexed module, uint256 duration);\n\n  event ReleaseLock(address indexed module);\n\n  event MaxLockDurationBlocksChanged(uint256 blocks);\n\n  function initialize(address) external;\n\n  function execute(address, uint256, bytes calldata) external returns (bytes memory);\n\n  function setModule(address, bool) external;\n\n  function moduleEnabled(address) external view returns (bool);\n\n  function requestLock(uint256) external returns (uint256);\n\n  function releaseLock() external;\n\n  function hasActiveLock() external view returns (bool);\n\n  function setMaxLockDurationBlocks(uint256 _blocks) external;\n\n  function maxLockDurationBlocks() external view returns (uint256);\n}\n"}}, "settings": {"remappings": ["@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/", "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/", "delegate-cash/=lib/delegation-registry/src/", "delegation-registry/=lib/delegation-registry/", "ds-test/=lib/forge-std/lib/ds-test/src/", "forge-std/=lib/forge-std/src/", "nouns-contracts/=lib/nouns-monorepo/packages/nouns-contracts/contracts/", "nouns-monorepo/=lib/nouns-monorepo/", "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/", "openzeppelin-contracts/=lib/openzeppelin-contracts/", "openzeppelin-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/", "openzeppelin/=lib/openzeppelin-contracts/contracts/", "relic-sdk/=lib/relic-sdk/", "solady/=lib/solady/src/", "solmate/=lib/solady/lib/solmate/src/"], "optimizer": {"enabled": true}, "metadata": {"bytecodeHash": "ipfs", "appendCBOR": true}, "outputSelection": {"*": {"*": ["evm.legacyAssembly"]}}, "evmVersion": "london", "viaIR": false, "libraries": {}}}