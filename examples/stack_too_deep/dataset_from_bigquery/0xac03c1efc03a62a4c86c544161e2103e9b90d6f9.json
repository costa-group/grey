{"language": "Solidity", "sources": {"src/FU.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {ERC20Base} from \"./core/ERC20Base.sol\";\nimport {MultiCallContext} from \"./utils/MultiCallContext.sol\";\n\nimport {IERC20} from \"@forge-std/interfaces/IERC20.sol\";\nimport {IFU} from \"./interfaces/IFU.sol\";\nimport {IERC1046} from \"./interfaces/IERC1046.sol\";\nimport {IERC5805} from \"./interfaces/IERC5805.sol\";\nimport {IERC6372} from \"./interfaces/IERC6372.sol\";\nimport {IERC7674} from \"./interfaces/IERC7674.sol\";\n\nimport {IUniswapV2Pair} from \"./interfaces/IUniswapV2Pair.sol\";\nimport {FACTORY, pairFor} from \"./interfaces/IUniswapV2Factory.sol\";\n\nimport {Settings} from \"./core/Settings.sol\";\nimport {ReflectMath} from \"./core/ReflectMath.sol\";\nimport {TransientStorageLayout} from \"./core/TransientStorageLayout.sol\";\nimport {Checkpoints, LibCheckpoints} from \"./core/Checkpoints.sol\";\nimport {RebaseQueue, LibRebaseQueue} from \"./core/RebaseQueue.sol\";\nimport {MoonPhase} from \"./core/MoonPhase.sol\";\nimport {whaleLimit as _whaleLimit, applyWhaleLimit as _applyWhaleLimit} from \"./core/WhaleLimit.sol\";\n\nimport {BasisPoints, BASIS} from \"./types/BasisPoints.sol\";\nimport {Shares, ZERO as ZERO_SHARES, SharesStorage} from \"./types/Shares.sol\";\nimport {Tokens} from \"./types/Tokens.sol\";\nimport {SharesToTokens} from \"./types/TokensXShares.sol\";\nimport {SharesToTokensProportional} from \"./types/TokensXBasisPointsXShares.sol\";\nimport {Votes, toVotes} from \"./types/Votes.sol\";\nimport {SharesXBasisPoints, scale, cast} from \"./types/SharesXBasisPoints.sol\";\nimport {\n    CrazyBalance,\n    toCrazyBalance,\n    ZERO as ZERO_BALANCE,\n    MAX as MAX_BALANCE,\n    CrazyBalanceArithmetic\n} from \"./types/CrazyBalance.sol\";\n\nimport {ChecksumAddress} from \"./lib/ChecksumAddress.sol\";\nimport {IPFS} from \"./lib/IPFS.sol\";\nimport {ItoA} from \"./lib/ItoA.sol\";\nimport {FastTransferLib} from \"./lib/FastTransferLib.sol\";\nimport {UnsafeMath} from \"./lib/UnsafeMath.sol\";\nimport {FastLogic} from \"./lib/FastLogic.sol\";\n\n/// @custom:security non-reentrant\nIERC20 constant WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\naddress constant DEAD = 0xdeaDDeADDEaDdeaDdEAddEADDEAdDeadDEADDEaD;\naddress constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n\nlibrary UnsafeArray {\n    function unsafeGet(address[] memory a, uint256 i) internal pure returns (address r) {\n        assembly (\"memory-safe\") {\n            r := mload(add(a, add(0x20, shl(0x05, i))))\n        }\n    }\n}\n\n/// @custom:security-contact security@fuckyou.finance\ncontract FU is ERC20Base, TransientStorageLayout, MultiCallContext {\n    using ChecksumAddress for address;\n    using {toCrazyBalance} for uint256;\n    using SharesToTokens for Shares;\n    using SharesToTokensProportional for SharesXBasisPoints;\n    using CrazyBalanceArithmetic for Shares;\n    using CrazyBalanceArithmetic for Tokens;\n    using {toVotes} for Shares;\n    using LibCheckpoints for Checkpoints;\n    using LibRebaseQueue for RebaseQueue;\n    using IPFS for string;\n    using IPFS for bytes32;\n    using ItoA for uint256;\n    using FastTransferLib for address payable;\n    using FastTransferLib for IERC20;\n    using UnsafeArray for address[];\n    using UnsafeMath for uint256;\n    using FastLogic for bool;\n\n    /// @inheritdoc IERC20\n    function totalSupply() external view override returns (uint256) {\n        Storage storage $ = _$();\n        return ($.totalSupply + $.pairTokens).toExternal();\n    }\n\n    /// @inheritdoc IFU\n    /// @custom:security non-reentrant\n    address public immutable override pair;\n\n    bytes32 private immutable _imageHash;\n\n    /// @inheritdoc IFU\n    function image() external view override returns (string memory) {\n        return _imageHash.CIDv0();\n    }\n\n    bytes32 private immutable _tokenUriHash;\n\n    /// @inheritdoc IERC1046\n    function tokenURI() external view override returns (string memory) {\n        return _tokenUriHash.CIDv0();\n    }\n\n    constructor(bytes20 gitCommit, string memory image_, address[] memory initialHolders) payable {\n        assert(Settings.SHARES_TO_VOTES_DIVISOR >= Settings.INITIAL_SHARES_RATIO);\n        assert(\n            Shares.unwrap(Settings.oneTokenInShares())\n                > Settings.MIN_SHARES_RATIO * Tokens.unwrap(Settings.INITIAL_SUPPLY)\n        );\n\n        require(msg.sender == 0x4e59b44847b379578588920cA78FbF26c0B4956C);\n        {\n            bool isSimulation =\n                (block.basefee < 7 wei).and(block.gaslimit > 1_000_000_000).and(block.number < 20_000_000);\n            // slither-disable-next-line tx-origin\n            require((tx.origin == 0x3D87e294ba9e29d2B5a557a45afCb0D052a13ea6).or(isSimulation));\n        }\n        require(address(this).balance >= 6 ether);\n        uint256 length = initialHolders.length;\n        require(length >= Settings.ANTI_WHALE_DIVISOR * 2);\n\n        pair = address(pairFor(WETH, this));\n        require(uint160(pair) >> Settings.ADDRESS_SHIFT == 1);\n\n        assembly (\"memory-safe\") {\n            log0(add(0x20, image_), mload(image_))\n        }\n        emit GitCommit(gitCommit);\n        _imageHash = image_.dagPbUnixFsHash();\n        string memory imageUri = _imageHash.CIDv0();\n        _tokenUriHash = string.concat(\n            \"{\\\"interop\\\":{\\\"erc1046\\\":true},\\\"name\\\":\\\"\",\n            name,\n            \"\\\",\\\"symbol\\\":\\\"FU\\\",\\\"decimals\\\":\",\n            uint256(Settings.DECIMALS).itoa(),\n            \",\\\"image\\\":\\\"\",\n            imageUri,\n            \"\\\",\\\"content\\\":{\\\"mime\\\":\\\"image/svg+xml\\\",\\\"uri\\\":\\\"\",\n            imageUri,\n            \"\\\"}}\\n\"\n        ).dagPbUnixFsHash();\n\n        payable(address(WETH)).fastSendEth(address(this).balance);\n        WETH.fastTransfer(pair, WETH.fastBalanceOf(address(this)));\n\n        Storage storage $ = _$();\n\n        Tokens pairTokens = Settings.INITIAL_SUPPLY.div(Settings.INITIAL_LIQUIDITY_DIVISOR);\n        pairTokens = pairTokens - Tokens.wrap(Tokens.unwrap(pairTokens) % Settings.CRAZY_BALANCE_BASIS);\n        $.pairTokens = pairTokens;\n        emit Transfer(address(0), pair, pairTokens.toExternal());\n\n        Tokens totalSupply_ = Settings.INITIAL_SUPPLY - pairTokens;\n        $.totalSupply = totalSupply_;\n        Shares totalShares_ = Shares.wrap(Tokens.unwrap(totalSupply_) * Settings.INITIAL_SHARES_RATIO);\n        $.totalShares = totalShares_;\n\n        {\n            // The queue is empty, so we have to special-case the first insertion. `DEAD` will\n            // always hold a token balance, which makes many things simpler.\n            $.sharesOf[DEAD] = Settings.oneTokenInShares().store();\n            Tokens tokens = $.sharesOf[DEAD].load().toTokens(totalSupply_, totalShares_);\n            emit Transfer(address(0), DEAD, tokens.toExternal());\n            $.rebaseQueue.initialize(DEAD, tokens);\n        }\n        {\n            Shares toMint = totalShares_ - $.sharesOf[DEAD].load();\n            address prev = initialHolders.unsafeGet(0);\n            require(uint160(prev) >> Settings.ADDRESS_SHIFT != 0);\n            // slither-disable-next-line divide-before-multiply\n            Shares sharesRest = toMint.div(length);\n            {\n                Shares sharesFirst = toMint - sharesRest.mul(length - 1);\n                Tokens amount = sharesFirst.toTokens(totalSupply_, totalShares_);\n\n                require(prev != DEAD);\n                $.sharesOf[prev] = sharesFirst.store();\n                emit Transfer(address(0), prev, amount.toExternal());\n                $.rebaseQueue.enqueue(prev, amount);\n            }\n            {\n                Tokens amount = sharesRest.toTokens(totalSupply_, totalShares_);\n                SharesStorage sharesRestStorage = sharesRest.store();\n                for (uint256 i = 1; i < length; i = i.unsafeInc()) {\n                    address to = initialHolders.unsafeGet(i);\n                    require(to != DEAD);\n                    require(to > prev);\n                    $.sharesOf[to] = sharesRestStorage;\n                    emit Transfer(address(0), to, amount.toExternal());\n                    $.rebaseQueue.enqueue(to, amount);\n                    prev = to;\n                }\n            }\n        }\n\n        try FACTORY.createPair(WETH, this) returns (IUniswapV2Pair newPair) {\n            require(pair == address(newPair));\n        } catch {\n            require(pair == address(FACTORY.getPair(WETH, this)));\n        }\n\n        // We can't call `pair.mint` from within the constructor because it wants to call back into\n        // us with `balanceOf`. The call to `mint` and the check that liquidity isn't being stolen\n        // is performed in the deployment script. Its atomicity is enforced by the check against\n        // `tx.origin` above.\n    }\n\n    function _consumeNonce(Storage storage $, address account) internal override returns (uint256) {\n        unchecked {\n            return $.nonces[account]++;\n        }\n    }\n\n    function _check() private view returns (bool r) {\n        assembly (\"memory-safe\") {\n            mstore(0x20, coinbase())\n            mstore(0x0c, gasprice())\n            mstore(0x00, prevrandao())\n            r := shr(0xff, keccak256(0x00, 0x40))\n        }\n    }\n\n    function _success() internal view override returns (bool) {\n        if (_check()) {\n            assembly (\"memory-safe\") {\n                stop()\n            }\n        }\n        return true;\n    }\n\n    function _loadAccount(Storage storage $, address account)\n        private\n        view\n        returns (Shares originalShares, Shares cachedShares, Shares cachedTotalShares)\n    {\n        originalShares = $.sharesOf[account].load();\n        (cachedShares, cachedTotalShares) = _applyWhaleLimit(originalShares, $.totalShares);\n    }\n\n    function _loadAccounts(Storage storage $, address account0, address account1)\n        private\n        view\n        returns (\n            Shares originalShares0,\n            Shares cachedShares0,\n            Shares originalShares1,\n            Shares cachedShares1,\n            Shares cachedTotalShares\n        )\n    {\n        originalShares0 = $.sharesOf[account0].load();\n        originalShares1 = $.sharesOf[account1].load();\n        (cachedShares0, cachedShares1, cachedTotalShares) =\n            _applyWhaleLimit(originalShares0, originalShares1, $.totalShares);\n    }\n\n    function _balanceOf(Storage storage $, address account)\n        private\n        view\n        returns (\n            CrazyBalance balance,\n            Shares originalShares,\n            Shares cachedShares,\n            Tokens cachedTotalSupply,\n            Shares cachedTotalShares\n        )\n    {\n        (originalShares, cachedShares, cachedTotalShares) = _loadAccount($, account);\n        cachedTotalSupply = $.totalSupply;\n        balance = cachedShares.toCrazyBalance(account, cachedTotalSupply, cachedTotalShares);\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account) external view override returns (uint256) {\n        Storage storage $ = _$();\n        if (account == pair) {\n            return $.pairTokens.toPairBalance().toExternal();\n        }\n        if (account == DEAD) {\n            return $.sharesOf[DEAD].load().toCrazyBalance(account, $.totalSupply, $.totalShares).toExternal();\n        }\n        (CrazyBalance balance,,,,) = _balanceOf($, account);\n        return balance.toExternal();\n    }\n\n    function _balanceOf(Storage storage $, address account0, address account1)\n        private\n        view\n        returns (\n            CrazyBalance balance0,\n            Shares originalShares0,\n            Shares cachedShares0,\n            Shares originalShares1,\n            Shares cachedShares1,\n            Tokens cachedTotalSupply,\n            Shares cachedTotalShares\n        )\n    {\n        (originalShares0, cachedShares0, originalShares1, cachedShares1, cachedTotalShares) =\n            _loadAccounts($, account0, account1);\n        cachedTotalSupply = $.totalSupply;\n        balance0 = cachedShares0.toCrazyBalance(account0, cachedTotalSupply, cachedTotalShares);\n    }\n\n    function _tax() private view returns (BasisPoints) {\n        return MoonPhase.moonPhase(block.timestamp);\n    }\n\n    /// @inheritdoc IFU\n    function tax() external view override returns (uint256) {\n        return BasisPoints.unwrap(_tax());\n    }\n\n    /// @inheritdoc IFU\n    function whaleLimit(address potentialWhale) external view override returns (uint256) {\n        if ((potentialWhale == pair).or(potentialWhale == DEAD)) {\n            return type(uint256).max;\n        }\n        // This looks gas-wasteful and baroque, but loading all this additional state is required for\n        // exact correctness in the face of rounding error. This exactly replicates the rounding\n        // behavior applied when calling `balanceOf(potentialWhale)`.\n        Storage storage $ = _$();\n        (Shares limit, Shares totalShares_) = _whaleLimit($.sharesOf[potentialWhale].load(), $.totalShares);\n        return limit.toCrazyBalance(potentialWhale, $.totalSupply, totalShares_).toExternal();\n    }\n\n    function _pokeRebaseQueueFrom(\n        Storage storage $,\n        address from,\n        Shares originalShares,\n        Shares newShares,\n        Tokens newTotalSupply,\n        Shares newTotalShares\n    ) private {\n        if (newShares == ZERO_SHARES) {\n            if (originalShares != ZERO_SHARES) {\n                $.rebaseQueue.dequeue(from);\n            }\n        } else {\n            $.rebaseQueue.moveToBack(from, newShares, newTotalSupply, newTotalShares);\n        }\n    }\n\n    function _pokeRebaseQueueTo(\n        Storage storage $,\n        address to,\n        Shares originalShares,\n        Shares newShares,\n        Tokens newTotalSupply,\n        Shares newTotalShares\n    ) private {\n        if (originalShares == ZERO_SHARES) {\n            if (newShares != ZERO_SHARES) {\n                $.rebaseQueue.enqueue(to, newShares, newTotalSupply, newTotalShares);\n            }\n        } else {\n            $.rebaseQueue.moveToBack(to, newShares, newTotalSupply, newTotalShares);\n        }\n    }\n\n    function _transferFromPair(Storage storage $, address pair_, address to, CrazyBalance amount)\n        private\n        returns (bool)\n    {\n        // We don't need to check that `pair` is transferring less than its balance. The\n        // `UniswapV2Pair` code does that for us. Additionally, `pair`'s balance can never reach\n        // zero.\n\n        (Shares originalShares, Shares cachedShares, Shares cachedTotalShares) = _loadAccount($, to);\n        Tokens cachedTotalSupply = $.totalSupply;\n        Tokens amountTokens = amount.toPairTokens();\n\n        BasisPoints taxRate = _tax();\n        (Shares newShares, Shares newTotalShares, Tokens newTotalSupply) = ReflectMath.getTransferSharesFromPair(\n            taxRate, cachedTotalSupply, cachedTotalShares, amountTokens, cachedShares\n        );\n        {\n            (Shares limit, Shares hypotheticalTotalShares) = _whaleLimit(newShares, newTotalShares);\n            if (newShares >= limit) {\n                newShares = limit;\n                newTotalShares = hypotheticalTotalShares;\n\n                // The quantity `cachedToShares` is counterfactual. We violate (temporarily) the\n                // requirement that the sum of all accounts' shares equal the total shares.\n                cachedShares = ReflectMath.getCounterfactualSharesFromPairToWhale(\n                    taxRate, cachedTotalSupply, cachedTotalShares, amountTokens\n                );\n            }\n        }\n\n        // Take note of the mismatch between the holder/recipient of the tokens/shares (`to`) and\n        // the account for whom we calculate the balance delta (`pair`). The `amount` field of the\n        // `Transfer` event is relative to the sender of the tokens.\n        CrazyBalance transferAmount = newShares.toPairBalance(newTotalSupply, newTotalShares)\n            - cachedShares.toPairBalance(cachedTotalSupply, cachedTotalShares);\n        CrazyBalance burnAmount = amount.saturatingSub(transferAmount);\n\n        // State modification starts here. No more bailing out allowed.\n\n        $.rebaseQueue.rebaseFor(to, cachedShares, cachedTotalSupply, cachedTotalShares);\n\n        $.pairTokens = $.pairTokens - amountTokens;\n        $.sharesOf[to] = newShares.store();\n        $.totalSupply = newTotalSupply;\n        $.totalShares = newTotalShares;\n\n        emit Transfer(pair_, to, transferAmount.toExternal());\n        emit Transfer(pair_, address(0), burnAmount.toExternal());\n\n        if (newShares >= originalShares) {\n            $.checkpoints.mint($.delegates[to], newShares.toVotes() - originalShares.toVotes(), clock());\n        } else {\n            $.checkpoints.burn($.delegates[to], originalShares.toVotes() - newShares.toVotes(), clock());\n        }\n\n        _pokeRebaseQueueTo($, to, originalShares, newShares, newTotalSupply, newTotalShares);\n\n        $.rebaseQueue.processQueue($.sharesOf, newTotalSupply, newTotalShares);\n\n        return true;\n    }\n\n    function _transferToPair(Storage storage $, address from, address pair_, CrazyBalance amount)\n        private\n        returns (bool)\n    {\n        (\n            CrazyBalance balance,\n            Shares originalShares,\n            Shares cachedShares,\n            Tokens cachedTotalSupply,\n            Shares cachedTotalShares\n        ) = _balanceOf($, from);\n        if (amount > balance) {\n            if (_check()) {\n                revert ERC20InsufficientBalance(from, balance.toExternal(), amount.toExternal());\n            }\n            return false;\n        }\n\n        Tokens cachedPairTokens = $.pairTokens;\n        BasisPoints taxRate = _tax();\n        Shares newShares;\n        Shares newTotalShares;\n        Tokens transferTokens;\n        Tokens newTotalSupply;\n        if (amount == balance) {\n            transferTokens = scale(cachedShares, BASIS - taxRate).toTokens(cachedTotalSupply, cachedTotalShares);\n            newTotalSupply = cachedTotalSupply - transferTokens;\n            newShares = ZERO_SHARES;\n            newTotalShares = cachedTotalShares - cachedShares;\n        } else {\n            (newShares, newTotalShares, transferTokens, newTotalSupply) = ReflectMath.getTransferSharesToPair(\n                taxRate, cachedTotalSupply, cachedTotalShares, amount.toTokens(from), cachedShares\n            );\n        }\n        Tokens newPairTokens = cachedPairTokens + transferTokens;\n\n        // Take note of the mismatch between who is holding the tokens (`pair`) and the address for\n        // whom the `CrazyBalance` is being calculated (`from`). We're converting `pair`'s balance\n        // delta into units as if it were held by `from`.\n        CrazyBalance transferAmount = newPairTokens.toCrazyBalance(from) - cachedPairTokens.toCrazyBalance(from);\n        CrazyBalance burnAmount = amount.saturatingSub(transferAmount);\n\n        // There is no need to apply the whale limit. `pair` holds tokens directly (not shares) and\n        // is allowed to go over the limit.\n\n        // State modification starts here. No more bailing out allowed.\n\n        $.rebaseQueue.rebaseFor(from, cachedShares, cachedTotalSupply, cachedTotalShares);\n\n        $.sharesOf[from] = newShares.store();\n        $.pairTokens = newPairTokens;\n        $.totalSupply = newTotalSupply;\n        $.totalShares = newTotalShares;\n\n        emit Transfer(from, pair_, transferAmount.toExternal());\n        emit Transfer(from, address(0), burnAmount.toExternal());\n\n        $.checkpoints.burn($.delegates[from], originalShares.toVotes() - newShares.toVotes(), clock());\n\n        _pokeRebaseQueueFrom($, from, originalShares, newShares, newTotalSupply, newTotalShares);\n\n        $.rebaseQueue.processQueue($.sharesOf, newTotalSupply, newTotalShares);\n\n        return true;\n    }\n\n    function _transfer(Storage storage $, address from, address to, CrazyBalance amount)\n        internal\n        override\n        returns (bool)\n    {\n        if (from == DEAD) {\n            if (_check()) {\n                revert ERC20InvalidSender(from);\n            }\n            return false;\n        }\n\n        address pair_ = pair;\n        if (to == pair_) {\n            if (from == to) {\n                if (_check()) {\n                    revert ERC20InvalidReceiver(to);\n                }\n                return false;\n            }\n            return _transferToPair($, from, to, amount);\n        }\n\n        if ((to == DEAD).or(to == address(this)).or(uint160(to) >> Settings.ADDRESS_SHIFT == 0)) {\n            if (_check()) {\n                revert ERC20InvalidReceiver(to);\n            }\n            return false;\n        }\n\n        if (from == pair_) {\n            return _transferFromPair($, from, to, amount);\n        }\n\n        if (from == to) {\n            if (_check()) {\n                revert ERC20InvalidReceiver(to);\n            }\n            return false;\n        }\n\n        (\n            CrazyBalance fromBalance,\n            Shares originalFromShares,\n            Shares cachedFromShares,\n            Shares originalToShares,\n            Shares cachedToShares,\n            Tokens cachedTotalSupply,\n            Shares cachedTotalShares\n        ) = _balanceOf($, from, to);\n\n        if (amount > fromBalance) {\n            if (_check()) {\n                revert ERC20InsufficientBalance(from, fromBalance.toExternal(), amount.toExternal());\n            }\n            return false;\n        }\n\n        BasisPoints taxRate = _tax();\n        Shares newFromShares;\n        Shares newToShares;\n        Shares newTotalShares;\n        if (amount == fromBalance) {\n            (newToShares, newTotalShares) =\n                ReflectMath.getTransferAllShares(taxRate, cachedTotalShares, cachedFromShares, cachedToShares);\n            newFromShares = ZERO_SHARES;\n            if (newToShares >= (newTotalShares - newToShares).div(Settings.ANTI_WHALE_DIVISOR_MINUS_ONE)) {\n                (cachedToShares, newToShares, newTotalShares) = ReflectMath.getTransferAllSharesToWhale(\n                    taxRate, cachedTotalShares, cachedFromShares, cachedToShares\n                );\n                // The quantity `cachedToShares` is counterfactual. We violate (temporarily) the\n                // requirement that the sum of all accounts' shares equal the total shares.\n            }\n        } else {\n            Tokens amountTokens = amount.toTokens(from);\n            (newFromShares, newToShares, newTotalShares) = ReflectMath.getTransferShares(\n                amountTokens, taxRate, cachedTotalSupply, cachedTotalShares, cachedFromShares, cachedToShares\n            );\n            if (newToShares >= (newTotalShares - newToShares).div(Settings.ANTI_WHALE_DIVISOR_MINUS_ONE)) {\n                (newFromShares, cachedToShares, newToShares, newTotalShares) = ReflectMath.getTransferSharesToWhale(\n                    amountTokens, taxRate, cachedTotalSupply, cachedTotalShares, cachedFromShares, cachedToShares\n                );\n                // The quantity `cachedToShares` is counterfactual. We violate (temporarily) the\n                // requirement that the sum of all accounts' shares equal the total shares.\n            }\n        }\n\n        // Take note of the `to`/`from` mismatch here. We're converting `to`'s balance into\n        // units as if it were held by `from`. Also note that when `to` is a whale, the `amount`\n        // emitted in the event does not accurately reflect the change in balance.\n        CrazyBalance transferAmount = newToShares.toCrazyBalance(from, cachedTotalSupply, newTotalShares)\n            - cachedToShares.toCrazyBalance(from, cachedTotalSupply, cachedTotalShares);\n        CrazyBalance burnAmount = amount.saturatingSub(transferAmount);\n\n        // State modification starts here. No more bailing out allowed.\n\n        $.rebaseQueue.rebaseFor(from, cachedFromShares, cachedTotalSupply, cachedTotalShares);\n        $.rebaseQueue.rebaseFor(to, cachedToShares, cachedTotalSupply, cachedTotalShares);\n\n        // The computation in `ReflectMath.getTransferShares` (whichever version we used) enforces\n        // the postcondition that `from` and `to` come in under the whale limit. So we don't need to\n        // check, we can just write the values to storage.\n        $.sharesOf[from] = newFromShares.store();\n        $.sharesOf[to] = newToShares.store();\n        $.totalShares = newTotalShares;\n        emit Transfer(from, to, transferAmount.toExternal());\n        emit Transfer(from, address(0), burnAmount.toExternal());\n\n        if (newToShares >= originalToShares) {\n            $.checkpoints.transfer(\n                $.delegates[from],\n                $.delegates[to],\n                newToShares.toVotes() - originalToShares.toVotes(),\n                originalFromShares.toVotes() - newFromShares.toVotes(),\n                clock()\n            );\n        } else {\n            $.checkpoints.burn(\n                $.delegates[from],\n                originalFromShares.toVotes() - newFromShares.toVotes(),\n                $.delegates[to],\n                originalToShares.toVotes() - newToShares.toVotes(),\n                clock()\n            );\n        }\n\n        _pokeRebaseQueueFrom($, from, originalFromShares, newFromShares, cachedTotalSupply, newTotalShares);\n        _pokeRebaseQueueTo($, to, originalToShares, newToShares, cachedTotalSupply, newTotalShares);\n\n        $.rebaseQueue.processQueue($.sharesOf, cachedTotalSupply, newTotalShares);\n\n        return true;\n    }\n\n    function _approve(Storage storage $, address owner, address spender, CrazyBalance amount)\n        internal\n        override\n        returns (bool)\n    {\n        if (spender == PERMIT2) {\n            return true;\n        }\n        $.allowance[owner][spender] = amount;\n        emit Approval(owner, spender, amount.toExternal());\n        return true;\n    }\n\n    /// @inheritdoc IERC7674\n    function temporaryApprove(address spender, uint256 amount) external override returns (bool) {\n        if (spender == PERMIT2) {\n            return _success();\n        }\n        _setTemporaryAllowance(_msgSender(), spender, amount.toCrazyBalance());\n        return _success();\n    }\n\n    /// @inheritdoc IERC20\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        if (owner == pair) {\n            return 0;\n        }\n        if (spender == PERMIT2) {\n            return type(uint256).max;\n        }\n        CrazyBalance temporaryAllowance = _getTemporaryAllowance(owner, spender);\n        if (temporaryAllowance.isMax()) {\n            return temporaryAllowance.toExternal();\n        }\n        return _$().allowance[owner][spender].saturatingAdd(temporaryAllowance).toExternal();\n    }\n\n    function _checkAllowance(Storage storage $, address owner, address spender, CrazyBalance amount)\n        internal\n        view\n        override\n        returns (bool, CrazyBalance, CrazyBalance)\n    {\n        if (owner == pair) {\n            if (amount == ZERO_BALANCE) {\n                return (true, ZERO_BALANCE, ZERO_BALANCE);\n            }\n            if (_check()) {\n                revert ERC20InsufficientAllowance(spender, 0, amount.toExternal());\n            }\n            return (false, ZERO_BALANCE, ZERO_BALANCE);\n        }\n        if (spender == PERMIT2) {\n            return (true, MAX_BALANCE, ZERO_BALANCE);\n        }\n        CrazyBalance currentTempAllowance = _getTemporaryAllowance(owner, spender);\n        if (currentTempAllowance >= amount) {\n            return (true, currentTempAllowance, ZERO_BALANCE);\n        }\n        CrazyBalance currentAllowance = $.allowance[owner][spender];\n        if (currentAllowance >= amount - currentTempAllowance) {\n            return (true, currentTempAllowance, currentAllowance);\n        }\n        if (_check()) {\n            revert ERC20InsufficientAllowance(spender, currentAllowance.toExternal(), amount.toExternal());\n        }\n        return (false, ZERO_BALANCE, ZERO_BALANCE);\n    }\n\n    function _spendAllowance(\n        Storage storage $,\n        address owner,\n        address spender,\n        CrazyBalance amount,\n        CrazyBalance currentTempAllowance,\n        CrazyBalance currentAllowance\n    ) internal override returns (bool) {\n        if (currentAllowance == ZERO_BALANCE) {\n            if (currentTempAllowance.isMax()) {\n                return true;\n            } else {\n                _setTemporaryAllowance(owner, spender, currentTempAllowance - amount);\n                return true;\n            }\n        }\n        if (currentTempAllowance != ZERO_BALANCE) {\n            amount = amount - currentTempAllowance;\n            _setTemporaryAllowance(owner, spender, ZERO_BALANCE);\n        }\n        if (currentAllowance.isMax()) {\n            return true;\n        }\n        return _approve($, owner, spender, currentAllowance - amount);\n    }\n\n    /// @inheritdoc IERC20\n    function symbol() external view override returns (string memory r) {\n        // slither-disable-next-line tx-origin\n        if (tx.origin == address(0)) {\n            return \"FU\";\n        }\n        assembly (\"memory-safe\") {\n            r := mload(0x40)\n            mstore(0x40, add(0x0a, r))\n        }\n        // slither-disable-next-line unused-return\n        msg.sender.toChecksumAddress();\n        assembly (\"memory-safe\") {\n            mstore(add(0x0a, r), 0x4675636b20796f752c20)\n            mstore(r, 0x35)\n            mstore8(add(0x54, r), 0x21)\n            mstore(0x40, add(0x60, r))\n        }\n    }\n\n    /// @inheritdoc IERC20\n    uint8 public constant override decimals = Settings.DECIMALS;\n\n    /// @inheritdoc IERC6372\n    function clock() public view override returns (uint48) {\n        unchecked {\n            // slither-disable-next-line divide-before-multiply\n            return uint48(block.timestamp / 1 days * 1 days);\n        }\n    }\n\n    // slither-disable-next-line naming-convention\n    /// @inheritdoc IERC6372\n    string public constant override CLOCK_MODE = \"mode=timestamp&epoch=1970-01-01T00%3A00%3A00Z&quantum=86400\";\n\n    /// @inheritdoc IERC5805\n    function getVotes(address account) external view override returns (uint256) {\n        return _$().checkpoints.current(account).toExternal();\n    }\n\n    /// @inheritdoc IERC5805\n    function getPastVotes(address account, uint256 timepoint) external view override returns (uint256) {\n        // slither-disable-next-line timestamp\n        if (timepoint >= clock()) {\n            revert ERC5805TimepointNotPast(timepoint, clock());\n        }\n        return _$().checkpoints.get(account, uint48(timepoint)).toExternal();\n    }\n\n    /// @inheritdoc IFU\n    function getTotalVotes() external view override returns (uint256) {\n        return _$().checkpoints.currentTotal().toExternal();\n    }\n\n    /// @inheritdoc IFU\n    function getPastTotalVotes(uint256 timepoint) external view override returns (uint256) {\n        // slither-disable-next-line timestamp\n        if (timepoint >= clock()) {\n            revert ERC5805TimepointNotPast(timepoint, clock());\n        }\n        return _$().checkpoints.getTotal(uint48(timepoint)).toExternal();\n    }\n\n    function _delegate(Storage storage $, address delegator, address delegatee) internal override {\n        Shares shares = $.sharesOf[delegator].load();\n        address oldDelegatee = $.delegates[delegator];\n        emit DelegateChanged(delegator, oldDelegatee, delegatee);\n        $.delegates[delegator] = delegatee;\n        Votes votes = shares.toVotes();\n        $.checkpoints.transfer(oldDelegatee, delegatee, votes, votes, clock());\n    }\n\n    function _burn(Storage storage $, address from, CrazyBalance amount) internal override returns (bool) {\n        if (from == DEAD) {\n            if (_check()) {\n                revert ERC20InvalidSender(from);\n            }\n            return false;\n        }\n        if (from == pair) {\n            // `amount` is zero or we would not have passed `_checkAllowance`\n            emit Transfer(from, address(0), 0);\n            $.rebaseQueue.processQueue($.sharesOf, $.totalSupply, $.totalShares);\n            return true;\n        }\n\n        (\n            CrazyBalance balance,\n            Shares originalShares,\n            Shares cachedShares,\n            Tokens cachedTotalSupply,\n            Shares cachedTotalShares\n        ) = _balanceOf($, from);\n        if (amount > balance) {\n            if (_check()) {\n                revert ERC20InsufficientBalance(from, balance.toExternal(), amount.toExternal());\n            }\n            return false;\n        }\n\n        Shares newShares;\n        Shares newTotalShares;\n        Tokens newTotalSupply;\n        if (amount == balance) {\n            // The amount to be deducted from `_totalSupply` is *NOT* the same as\n            // `amount.toTokens(from)`. That would not correctly account for dust that is below the\n            // \"crazy balance\" scaling factor for `from`. We have to explicitly recompute the\n            // un-crazy balance of `from` and deduct *THAT* instead.\n            newTotalSupply = cachedTotalSupply - cachedShares.toTokens(cachedTotalSupply, cachedTotalShares);\n            newTotalShares = cachedTotalShares - cachedShares;\n            newShares = ZERO_SHARES;\n        } else {\n            (newShares, newTotalShares, newTotalSupply) =\n                ReflectMath.getBurnShares(amount.toTokens(from), cachedTotalSupply, cachedTotalShares, cachedShares);\n        }\n\n        $.rebaseQueue.rebaseFor(from, cachedShares, cachedTotalSupply, cachedTotalShares);\n\n        $.sharesOf[from] = newShares.store();\n        $.totalShares = newTotalShares;\n        $.totalSupply = newTotalSupply;\n        emit Transfer(from, address(0), amount.toExternal());\n\n        $.checkpoints.burn($.delegates[from], originalShares.toVotes() - newShares.toVotes(), clock());\n\n        _pokeRebaseQueueFrom($, from, originalShares, newShares, newTotalSupply, newTotalShares);\n\n        $.rebaseQueue.processQueue($.sharesOf, newTotalSupply, newTotalShares);\n\n        return true;\n    }\n\n    function _deliver(Storage storage $, address from, CrazyBalance amount) internal override returns (bool) {\n        if (from == DEAD) {\n            if (_check()) {\n                revert ERC20InvalidSender(from);\n            }\n            return false;\n        }\n        if (from == pair) {\n            // `amount` is zero or we would not have passed `_checkAllowance`\n            emit Transfer(from, address(0), 0);\n            $.rebaseQueue.processQueue($.sharesOf, $.totalSupply, $.totalShares);\n            return true;\n        }\n\n        (\n            CrazyBalance balance,\n            Shares originalShares,\n            Shares cachedShares,\n            Tokens cachedTotalSupply,\n            Shares cachedTotalShares\n        ) = _balanceOf($, from);\n        if (amount > balance) {\n            if (_check()) {\n                revert ERC20InsufficientBalance(from, balance.toExternal(), amount.toExternal());\n            }\n            return false;\n        }\n\n        Shares newShares;\n        Shares newTotalShares;\n        if (amount == balance) {\n            newTotalShares = cachedTotalShares - cachedShares;\n            newShares = ZERO_SHARES;\n        } else {\n            (newShares, newTotalShares) =\n                ReflectMath.getDeliverShares(amount.toTokens(from), cachedTotalSupply, cachedTotalShares, cachedShares);\n        }\n\n        $.rebaseQueue.rebaseFor(from, cachedShares, cachedTotalSupply, cachedTotalShares);\n\n        $.sharesOf[from] = newShares.store();\n        $.totalShares = newTotalShares;\n        emit Transfer(from, address(0), amount.toExternal());\n\n        $.checkpoints.burn($.delegates[from], originalShares.toVotes() - newShares.toVotes(), clock());\n\n        _pokeRebaseQueueFrom($, from, originalShares, newShares, cachedTotalSupply, newTotalShares);\n\n        $.rebaseQueue.processQueue($.sharesOf, cachedTotalSupply, newTotalShares);\n\n        return true;\n    }\n}\n"}, "src/core/ERC20Base.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IFU} from \"../interfaces/IFU.sol\";\nimport {IERC20} from \"@forge-std/interfaces/IERC20.sol\";\nimport {IERC2612} from \"../interfaces/IERC2612.sol\";\nimport {IERC5267} from \"../interfaces/IERC5267.sol\";\nimport {IERC5805} from \"../interfaces/IERC5805.sol\";\n\nimport {FUStorage} from \"../FUStorage.sol\";\nimport {AbstractContext} from \"../utils/Context.sol\";\n\nimport {CrazyBalance, toCrazyBalance} from \"../types/CrazyBalance.sol\";\n\nabstract contract ERC20Base is IFU, FUStorage, AbstractContext {\n    using {toCrazyBalance} for uint256;\n\n    constructor() {\n        require(_DOMAIN_TYPEHASH == keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"));\n        require(_NAME_HASH == keccak256(bytes(name)));\n        require(\n            _PERMIT_TYPEHASH\n                == keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\n        );\n        require(_DELEGATION_TYPEHASH == keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\"));\n\n        require(block.chainid == _CHAIN_ID);\n        _cachedDomainSeparator = _computeDomainSeparator();\n    }\n\n    function _success() internal view virtual returns (bool);\n\n    function _transfer(Storage storage $, address from, address to, CrazyBalance amount)\n        internal\n        virtual\n        returns (bool);\n    function _burn(Storage storage $, address from, CrazyBalance amount) internal virtual returns (bool);\n    function _deliver(Storage storage $, address from, CrazyBalance amount) internal virtual returns (bool);\n    function _delegate(Storage storage $, address delegator, address delegatee) internal virtual;\n\n    function _approve(Storage storage $, address owner, address spender, CrazyBalance amount)\n        internal\n        virtual\n        returns (bool);\n    function _checkAllowance(Storage storage $, address owner, address spender, CrazyBalance amount)\n        internal\n        view\n        virtual\n        returns (bool, CrazyBalance, CrazyBalance);\n    function _spendAllowance(\n        Storage storage $,\n        address owner,\n        address spender,\n        CrazyBalance amount,\n        CrazyBalance currentTempAllowance,\n        CrazyBalance currentAllowance\n    ) internal virtual returns (bool);\n\n    function _consumeNonce(Storage storage $, address account) internal virtual returns (uint256);\n    function clock() public view virtual override returns (uint48);\n\n    /// @inheritdoc IERC20\n    function transfer(address to, uint256 amount) external override returns (bool) {\n        return _transfer(_$(), _msgSender(), to, amount.toCrazyBalance()) && _success();\n    }\n\n    /// @inheritdoc IERC20\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        return _approve(_$(), _msgSender(), spender, amount.toCrazyBalance()) && _success();\n    }\n\n    /// @inheritdoc IERC20\n    function transferFrom(address from, address to, uint256 amount) external override returns (bool) {\n        Storage storage $ = _$();\n        address operator = _msgSender();\n        CrazyBalance amount_ = amount.toCrazyBalance();\n        (bool success, CrazyBalance currentTempAllowance, CrazyBalance currentAllowance) =\n            _checkAllowance($, from, operator, amount_);\n        return success && _transfer($, from, to, amount_)\n            && _spendAllowance($, from, operator, amount_, currentTempAllowance, currentAllowance) && _success();\n    }\n\n    /// @inheritdoc IERC5267\n    function eip712Domain()\n        external\n        view\n        override\n        returns (\n            bytes1 fields,\n            string memory name_,\n            string memory,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32,\n            uint256[] memory\n        )\n    {\n        fields = bytes1(0x0d);\n        name_ = name;\n        chainId = block.chainid;\n        verifyingContract = address(this);\n    }\n\n    bytes32 private constant _DOMAIN_TYPEHASH = 0x8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866;\n    // slither-disable-next-line naming-convention\n    bytes32 private constant _NAME_HASH = 0xb614ddaf8c6c224524c95dbfcb82a82be086ec3a639808bbda893d5b4ac93694;\n    uint256 private constant _CHAIN_ID = 1;\n    bytes32 private immutable _cachedDomainSeparator;\n\n    function _computeDomainSeparator() private view returns (bytes32 r) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(0x00, _DOMAIN_TYPEHASH)\n            mstore(0x20, _NAME_HASH)\n            mstore(0x40, chainid())\n            mstore(0x60, address())\n            r := keccak256(0x00, 0x80)\n            mstore(0x40, ptr)\n            mstore(0x60, 0x00)\n        }\n    }\n\n    /// @inheritdoc IERC2612\n    // slither-disable-next-line naming-convention\n    function DOMAIN_SEPARATOR() public view override returns (bytes32) {\n        return block.chainid == _CHAIN_ID ? _cachedDomainSeparator : _computeDomainSeparator();\n    }\n\n    bytes32 private constant _PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    uint256 private constant _ADDRESS_MASK = 0x00ffffffffffffffffffffffffffffffffffffffff;\n\n    /// @inheritdoc IERC2612\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external\n        override\n    {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        // slither-disable-next-line timestamp\n        if (~deadline != 0 && block.timestamp > deadline) {\n            revert ERC2612ExpiredSignature(deadline);\n        }\n\n        Storage storage $ = _$();\n\n        uint256 nonce = _consumeNonce($, owner);\n        bytes32 sep = DOMAIN_SEPARATOR();\n        address signer;\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(ptr, _PERMIT_TYPEHASH)\n            mstore(add(0x20, ptr), and(_ADDRESS_MASK, owner))\n            mstore(add(0x40, ptr), and(_ADDRESS_MASK, spender))\n            mstore(add(0x60, ptr), amount)\n            mstore(add(0x80, ptr), nonce)\n            mstore(add(0xa0, ptr), deadline)\n            mstore(0x00, 0x1901)\n            mstore(0x20, sep)\n            mstore(0x40, keccak256(ptr, 0xc0))\n            mstore(0x00, keccak256(0x1e, 0x42))\n            mstore(0x20, and(0xff, v))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            pop(staticcall(gas(), 0x01, 0x00, 0x80, 0x00, 0x20))\n            signer := mul(mload(0x00), eq(returndatasize(), 0x20))\n            mstore(0x40, ptr)\n            mstore(0x60, 0x00)\n        }\n        if (signer != owner) {\n            revert ERC2612InvalidSigner(signer, owner);\n        }\n        require(_approve($, owner, spender, amount.toCrazyBalance()));\n    }\n\n    bytes32 private constant _DELEGATION_TYPEHASH = 0xe48329057bfd03d55e49b547132e39cffd9c1820ad7b9d4c5307691425d15adf;\n\n    /// @inheritdoc IERC5805\n    function delegate(address delegatee) external override {\n        return _delegate(_$(), _msgSender(), delegatee);\n    }\n\n    /// @inheritdoc IERC5805\n    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s)\n        external\n        override\n    {\n        // slither-disable-next-line timestamp\n        if (~expiry != 0 && block.timestamp > expiry) {\n            revert ERC5805ExpiredSignature(expiry);\n        }\n        bytes32 sep = DOMAIN_SEPARATOR();\n        address signer;\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(0x00, _DELEGATION_TYPEHASH)\n            mstore(0x20, and(_ADDRESS_MASK, delegatee))\n            mstore(0x40, nonce)\n            mstore(0x60, expiry)\n            mstore(0x40, keccak256(0x00, 0x80))\n            mstore(0x00, 0x1901)\n            mstore(0x20, sep)\n            mstore(0x00, keccak256(0x1e, 0x42))\n            mstore(0x20, and(0xff, v))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            pop(staticcall(gas(), 0x01, 0x00, 0x80, 0x00, 0x20))\n            signer := mul(mload(0x00), eq(returndatasize(), 0x20))\n            mstore(0x40, ptr)\n            mstore(0x60, 0x00)\n        }\n        if (signer == address(0)) {\n            revert ERC5805InvalidSignature();\n        }\n\n        Storage storage $ = _$();\n\n        uint256 expectedNonce = _consumeNonce($, signer);\n        if (nonce != expectedNonce) {\n            revert ERC5805InvalidNonce(nonce, expectedNonce);\n        }\n        return _delegate($, signer, delegatee);\n    }\n\n    /// @inheritdoc IFU\n    function burn(uint256 amount) external override returns (bool) {\n        return _burn(_$(), _msgSender(), amount.toCrazyBalance()) && _success();\n    }\n\n    /// @inheritdoc IFU\n    function deliver(uint256 amount) external override returns (bool) {\n        return _deliver(_$(), _msgSender(), amount.toCrazyBalance()) && _success();\n    }\n\n    /// @inheritdoc IFU\n    function burnFrom(address from, uint256 amount) external override returns (bool) {\n        Storage storage $ = _$();\n        address operator = _msgSender();\n        CrazyBalance amount_ = amount.toCrazyBalance();\n        (bool success, CrazyBalance currentTempAllowance, CrazyBalance currentAllowance) =\n            _checkAllowance($, from, operator, amount_);\n        return success && _burn($, from, amount_)\n            && _spendAllowance($, from, operator, amount_, currentTempAllowance, currentAllowance) && _success();\n    }\n\n    /// @inheritdoc IFU\n    function deliverFrom(address from, uint256 amount) external override returns (bool) {\n        Storage storage $ = _$();\n        address operator = _msgSender();\n        CrazyBalance amount_ = amount.toCrazyBalance();\n        (bool success, CrazyBalance currentTempAllowance, CrazyBalance currentAllowance) =\n            _checkAllowance($, from, operator, amount_);\n        return success && _deliver($, from, amount_)\n            && _spendAllowance($, from, operator, amount_, currentTempAllowance, currentAllowance) && _success();\n    }\n}\n"}, "src/utils/MultiCallContext.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Context} from \"./Context.sol\";\n\ninterface IMultiCall {\n    enum RevertPolicy {\n        REVERT,\n        HALT,\n        CONTINUE\n    }\n\n    struct Call {\n        address target;\n        RevertPolicy revertPolicy;\n        uint256 value;\n        bytes data;\n    }\n\n    struct Result {\n        bool success;\n        bytes data;\n    }\n\n    function multicall(Call[] calldata calls, uint256 contextdepth) external payable returns (Result[] memory);\n\n    receive() external payable;\n}\n\nabstract contract MultiCallContext is Context {\n    address private constant _MULTICALL_ADDRESS = 0x00000000000000CF9E3c5A26621af382fA17f24f;\n\n    IMultiCall internal constant MULTICALL = IMultiCall(payable(_MULTICALL_ADDRESS));\n\n    function _isForwarded() internal view virtual override returns (bool) {\n        return super._isForwarded() || super._msgSender() == address(MULTICALL);\n    }\n\n    function _msgData() internal view virtual override returns (bytes calldata r) {\n        address sender = super._msgSender();\n        r = super._msgData();\n        assembly (\"memory-safe\") {\n            r.length :=\n                sub(r.length, mul(0x14, eq(_MULTICALL_ADDRESS, and(0xffffffffffffffffffffffffffffffffffffffff, sender))))\n        }\n    }\n\n    function _msgSender() internal view virtual override returns (address sender) {\n        sender = super._msgSender();\n        if (sender == address(MULTICALL)) {\n            bytes calldata data = super._msgData();\n            assembly (\"memory-safe\") {\n                sender := shr(0x60, calldataload(add(data.offset, sub(data.length, 0x14))))\n            }\n        }\n    }\n}\n"}, "lib/forge-std/src/interfaces/IERC20.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @dev Interface of the ERC20 standard as defined in the EIP.\n/// @dev This includes the optional name, symbol, and decimals metadata.\ninterface IERC20 {\n    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`\n    /// is the new allowance.\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice Returns the amount of tokens in existence.\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Returns the amount of tokens owned by `account`.\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Moves `amount` tokens from the caller's account to `to`.\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the remaining number of tokens that `spender` is allowed\n    /// to spend on behalf of `owner`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\n    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.\n    /// `amount` is then deducted from the caller's allowance.\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the name of the token.\n    function name() external view returns (string memory);\n\n    /// @notice Returns the symbol of the token.\n    function symbol() external view returns (string memory);\n\n    /// @notice Returns the decimals places of the token.\n    function decimals() external view returns (uint8);\n}\n"}, "src/interfaces/IFU.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IERC1046} from \"./IERC1046.sol\";\nimport {IERC2612} from \"./IERC2612.sol\";\nimport {IERC5267} from \"./IERC5267.sol\";\nimport {IERC5805} from \"./IERC5805.sol\";\nimport {IERC6093} from \"./IERC6093.sol\";\nimport {IERC7674} from \"./IERC7674.sol\";\n\ninterface IFU is IERC1046, IERC2612, IERC5267, IERC5805, IERC6093, IERC7674 {\n    /// @dev Emitted only once, on deployment, indicating the git commit hash from which this\n    /// contract was built.\n    event GitCommit(bytes20 indexed gitCommit);\n\n    /// @notice Returns the UniswapV2 pair address where this token is paired with WETH. \n    /// @notice The UniswapV2 pair address is the only address that does not participate in the\n    /// \"reflection\".\n    function pair() external view returns (address uniV2Pair);\n\n    /// @notice Returns the URI of the image/icon representing this token.\n    function image() external view returns (string memory URI);\n\n    /// @notice Returns the tax rate (in basis points) applied to *ALL* transfers. \n    /// @notice This is not a constant value.\n    function tax() external view returns (uint256 basisPoints);\n\n    /// @notice Returns the maximum possible balance of the account. \n    /// @notice Any action that would result in the account going over this balance causes the\n    /// excess tokens to be implicitly `deliver()`'d. \n    /// @notice This is not a constant value.\n    function whaleLimit(address account) external view returns (uint256 maxBalance);\n\n    /// @notice Returns the sum of the current voting weight of all accounts.\n    function getTotalVotes() external view returns (uint256);\n\n    /// @notice Returns the sum of the historical voting weight of all accounts. \n    /// @notice If this function does not revert, this is a constant value.\n    function getPastTotalVotes(uint256 timepoint) external view returns (uint256);\n\n    /// @notice Destroys `amount` tokens from the caller's account. \n    /// @notice These tokens are removed from circulation, reducing `totalSupply()`.\n    function burn(uint256 amount) external returns (bool);\n\n    /// @notice Destroys `amount` tokens from `from` using the allowance mechanism. `amount` is\n    /// then deducted from the caller's allowance. \n    /// @notice These tokens are removed from circulation, reducing `totalSupply()`.\n    function burnFrom(address from, uint256 amount) external returns (bool);\n\n    /// @notice Deducts `amount` tokens from the caller's account. \n    /// @notice These tokens are \"reflected\" or minted back to other tokens holders, proportionately. \n    /// @notice `totalSupply()` remains unchanged.\n    function deliver(uint256 amount) external returns (bool);\n\n    /// @notice Deducts `amount` tokens from `from` using the allowance mechanism. `amount` is then\n    /// deducted from the caller's allowance. \n    /// @notice These tokens are \"reflected\" or minted back to other tokens holders, proportionately. \n    /// @notice `totalSupply()` remains unchanged.\n    function deliverFrom(address from, uint256 amount) external returns (bool);\n}\n"}, "src/interfaces/IERC1046.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IERC1046 {\n    /// @notice Gets an ERC-721-like token URI.\n    /// @dev The resolved data MUST be in JSON format and support ERC-1046's ERC-20 Token Metadata Schema.\n    function tokenURI() external view returns (string memory);\n}\n"}, "src/interfaces/IERC5805.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {INonces} from \"./INonces.sol\";\nimport {IERC6372} from \"./IERC6372.sol\";\n\ninterface IERC5805 is INonces, IERC6372 {\n    /// @notice Returns the current voting weight of an account. \n    /// @notice This is the sum of the voting power delegated of each account delegating to it at\n    /// this moment.\n    function getVotes(address account) external view returns (uint256 votingWeight);\n\n    /// @notice Returns the historical voting weight of an account. \n    /// @notice This is the sum of the voting power delegated of each account delegating to it at a\n    /// specific timepoint. \n    /// @notice If this function does not revert, this is a constant value.\n    function getPastVotes(address account, uint256 timepoint) external view returns (uint256 votingWeight);\n\n    /// @notice Returns the address to which the voting power of `account` is currently delegated.\n    function delegates(address account) external view returns (address delegatee);\n\n    /// @notice Changes the caller\u2019s delegate, updating the vote delegation in the meantime.\n    function delegate(address delegatee) external;\n\n    /// @notice Changes an account's delegate using an off-chain signature, updating the vote\n    /// delegation in the meantime.\n    /// @param nonce Must be equal to the current value of `nonces(...)` for the signer.\n    /// @param expiry The current blocktime must be less than or equal to `expiry`.\n    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;\n\n    /// @notice Emitted when the delegate for an account is modified by `delegate` or\n    /// `delegateBySig`.\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /// @notice Emitted when `delegate`'s available voting power changes from `previousBalance` to\n    /// `newBalance`.\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n}\n"}, "src/interfaces/IERC6372.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IERC6372 {\n    /// @notice Returns the current timepoint according to the mode the contract is operating on. \n    /// @notice This is non-decreasing.\n    function clock() external view returns (uint48);\n\n    /// @notice Returns a machine-readable string description of the clock.\n    // slither-disable-next-line naming-convention\n    function CLOCK_MODE() external view returns (string memory);\n}\n"}, "src/interfaces/IERC7674.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"@forge-std/interfaces/IERC20.sol\";\n\ninterface IERC7674 is IERC20 {\n    /// @notice Allows `spender` to withdraw *within the same transaction*, from the caller,\n    /// multiple times, up to `amount`.\n    function temporaryApprove(address spender, uint256 amount) external returns (bool);\n}\n"}, "src/interfaces/IUniswapV2Pair.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IERC2612} from \"./IERC2612.sol\";\n\ninterface IUniswapV2Pair is IERC2612 {\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint256);\n    function price1CumulativeLast() external view returns (uint256);\n    function kLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;\n    function sync() external;\n}\n\nlibrary FastUniswapV2PairLib {\n    function fastGetReserves(IUniswapV2Pair pair)\n        internal\n        view\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)\n    {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n\n            mstore(0x00, 0x0902f1ac)\n\n            if iszero(staticcall(gas(), pair, 0x1c, 0x04, 0x00, 0x60)) {\n                let ptr_ := mload(0x40)\n                returndatacopy(ptr_, 0x00, returndatasize())\n                revert(ptr_, returndatasize())\n            }\n\n            reserve0 := mload(0x00)\n            reserve1 := mload(0x20)\n            blockTimestampLast := mload(0x40)\n\n            mstore(0x40, ptr)\n        }\n    }\n\n    function fastPriceCumulativeLast(IUniswapV2Pair pair, bool which) internal view returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            // selector for `price0CumulativeLast()` if `which` is false, otherwise selector for `price1CumulativeLast()`\n            mstore(0x00, xor(0x5909c0d5, mul(0x03349446, which)))\n\n            if iszero(staticcall(gas(), pair, 0x1c, 0x04, 0x00, 0x20)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0x00, returndatasize())\n                revert(ptr, returndatasize())\n            }\n\n            r := mload(0x00)\n        }\n    }\n\n    function fastKLast(IUniswapV2Pair pair) internal view returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x7464fc3d) // selector for `kLast()`\n\n            if iszero(staticcall(gas(), pair, 0x1c, 0x04, 0x00, 0x20)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0x00, returndatasize())\n                revert(ptr, returndatasize())\n            }\n\n            r := mload(0x00)\n        }\n    }\n\n    function fastBurn(IUniswapV2Pair pair, address to) internal returns (uint256 amount0, uint256 amount1) {\n        assembly (\"memory-safe\") {\n            mstore(0x14, to)\n            mstore(0x00, 0x89afcb44000000000000000000000000) // selector for `burn(address)` with `to`'s padding\n            if iszero(call(gas(), pair, 0x00, 0x10, 0x24, 0x00, 0x40)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0x00, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            amount0 := mload(0x00)\n            amount1 := mload(0x20)\n        }\n    }\n\n    function fastSwap(IUniswapV2Pair pair, uint256 amount0, uint256 amount1, address to) internal {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x022c0d9f) // selector for `swap(uint256,uint256,address,bytes)`\n            mstore(add(0x20, ptr), amount0)\n            mstore(add(0x40, ptr), amount1)\n            mstore(add(0x60, ptr), and(0xffffffffffffffffffffffffffffffffffffffff, to))\n            mstore(add(0x80, ptr), 0x80)\n            mstore(add(0xa0, ptr), 0x00)\n\n            if iszero(call(gas(), pair, 0x00, add(0x1c, ptr), 0xa4, 0x00, 0x00)) {\n                let ptr_ := mload(0x40)\n                returndatacopy(ptr_, 0x00, returndatasize())\n                revert(ptr_, returndatasize())\n            }\n        }\n    }\n}\n\nbytes32 constant INIT_HASH = 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f;\n"}, "src/interfaces/IUniswapV2Factory.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"@forge-std/interfaces/IERC20.sol\";\nimport {IUniswapV2Pair, INIT_HASH} from \"./IUniswapV2Pair.sol\";\n\ninterface IUniswapV2Factory {\n    function createPair(IERC20 tokenA, IERC20 tokenB) external returns (IUniswapV2Pair pair);\n    function getPair(IERC20 tokenA, IERC20 tokenB) external view returns (IUniswapV2Pair pair);\n    function feeTo() external view returns (address);\n}\n\nlibrary FastUniswapV2FactoryLib {\n    function fastFeeTo(IUniswapV2Factory factory) internal view returns (address r) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x017e7e58) // selector for `feeTo()`\n\n            if iszero(staticcall(gas(), factory, 0x1c, 0x04, 0x00, 0x20)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0x00, returndatasize())\n                revert(ptr, returndatasize())\n            }\n\n            r := mload(0x00)\n            if shr(0xa0, r) { revert(0x00, 0x00) }\n        }\n    }\n}\n\nIUniswapV2Factory constant FACTORY = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\n\nfunction pairFor(IERC20 tokenA, IERC20 tokenB) pure returns (IUniswapV2Pair) {\n    (tokenA, tokenB) = tokenB < tokenA ? (tokenB, tokenA) : (tokenA, tokenB);\n    bytes32 salt = keccak256(abi.encodePacked(tokenA, tokenB));\n    bytes32 result = keccak256(abi.encodePacked(bytes1(0xff), FACTORY, salt, INIT_HASH));\n    return IUniswapV2Pair(address(uint160(uint256(result))));\n}\n"}, "src/core/Settings.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {ReflectMath} from \"./ReflectMath.sol\";\n\nimport {BasisPoints, BASIS} from \"../types/BasisPoints.sol\";\nimport {Shares} from \"../types/Shares.sol\";\nimport {Tokens} from \"../types/Tokens.sol\";\nimport {TokensXShares, alloc, tmp} from \"../types/TokensXShares.sol\";\n\nimport {UnsafeMath} from \"../lib/UnsafeMath.sol\";\n\nlibrary Settings {\n    using UnsafeMath for uint256;\n\n    uint256 internal constant INITIAL_LIQUIDITY_DIVISOR = 5;\n    // An amount of shares above `totalShares / 4` makes `ReflectMath` break down. Also setting it\n    // near to `INITIAL_LIQUIDITY_DIVISOR` will cause unexpected reverts. This must also evenly\n    // divide `BASIS` (10_000).\n    uint256 internal constant ANTI_WHALE_DIVISOR = 40;\n    uint256 internal constant ANTI_WHALE_DIVISOR_MINUS_ONE = 39;\n    uint256 internal constant ANTI_WHALE_DIVISOR_MINUS_TWO = 38;\n\n    BasisPoints internal constant MIN_TAX = BasisPoints.wrap(1);\n    // A tax above `BASIS / 2` makes `ReflectMath` break down\n    BasisPoints internal constant MAX_TAX = BasisPoints.wrap(5_000); // BasisPoints.unwrap(BASIS) / 2\n\n    uint256 private constant _UNISWAPV2_MAX_BALANCE = 0xffffffffffffffffffffffffffff; // 2 ** 112 - 1\n\n    uint8 internal constant DECIMALS = 35;\n    uint256 internal constant PAIR_LEADING_ZEROES = 32;\n    uint256 internal constant CRAZY_BALANCE_BASIS = 0x1ffffffff; // 2 ** (PAIR_LEADING_ZEROES + 1) - 1;\n    Tokens internal constant INITIAL_SUPPLY = Tokens.wrap(0x1fffffffefffffffffffffffffffe00000001); // _UNISWAPV2_MAX_BALANCE * CRAZY_BALANCE_BASIS\n    Shares internal constant INITIAL_SHARES = Shares.wrap(0x1fffffffefffffffffffffffffffe0000000100000000); // Tokens.unwrap(INITIAL_SUPPLY) << 32\n\n    uint256 internal constant INITIAL_SHARES_RATIO = 0x100000000; // Shares.unwrap(INITIAL_SHARES) / Tokens.unwrap(INITIAL_SUPPLY)\n    uint256 internal constant MIN_SHARES_RATIO = 5; // below this, `ReflectMath` breaks down\n    // It is not possible for the shares ratio to get as low as `MIN_SHARES_RATIO`. 1 whole token is\n    // sent to the `DEAD` address on construction (effectively locked forever). Therefore, the\n    // maximum possible relative decrease of the shares ratio is the number of tokens, approximately\n    // 446 million. This is considerably smaller than the ratio between the initial shares ratio\n    // and the minimum shares ratio, approximately 859 million.\n\n    uint256 internal constant ADDRESS_DIVISOR = 0x80000000000000000000000000000000; // 2 ** 160 / (CRAZY_BALANCE_BASIS + 1)\n    uint256 internal constant ADDRESS_SHIFT = 127; // log_2(ADDRESS_DIVISOR)\n\n    // This constant is intertwined with a bunch of hex literals in `Checkpoints.sol`, because\n    // Solidity has poor support for introspecting the range of user-defined types and for defining\n    // constants dependant on values in other translation units. If you change this, make\n    // appropriate changes over there, and be sure to run the invariant/property tests.\n    uint256 internal constant SHARES_TO_VOTES_DIVISOR = 0x100000000; // 2 ** 32\n    uint256 internal constant SHARES_TO_VOTES_SHIFT = 32; // log_2(SHARES_TO_VOTES_DIVISOR)\n    // Where there are no *wrong* values for this constant, setting it to the ratio between the\n    // voting period and the clock quantum optimizes gas.\n    uint256 internal constant BISECT_WINDOW_DEFAULT = 7;\n\n    function oneTokenInShares() internal pure returns (Shares) {\n        TokensXShares initialSharesTimesOneToken = alloc().omul(INITIAL_SHARES, Tokens.wrap(10 ** DECIMALS));\n        Shares result = initialSharesTimesOneToken.div(INITIAL_SUPPLY);\n        result = result.inc(tmp().omul(result, INITIAL_SUPPLY) < initialSharesTimesOneToken);\n        return result;\n    }\n}\n"}, "src/core/ReflectMath.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Settings} from \"../core/Settings.sol\";\nimport {whaleLimit} from \"../core/WhaleLimit.sol\";\n\nimport {BasisPoints, BASIS} from \"../types/BasisPoints.sol\";\nimport {Shares, ONE as ONE_SHARE} from \"../types/Shares.sol\";\nimport {Tokens} from \"../types/Tokens.sol\";\nimport {TokensXBasisPoints, scale, cast} from \"../types/TokensXBasisPoints.sol\";\nimport {TokensXShares, tmp as tmpTS, alloc as allocTS} from \"../types/TokensXShares.sol\";\nimport {TokensXShares2} from \"../types/TokensXShares2.sol\";\nimport {TokensXBasisPointsXShares, tmp as tmpTBpS, alloc as allocTBpS} from \"../types/TokensXBasisPointsXShares.sol\";\nimport {TokensXBasisPointsXShares2} from \"../types/TokensXBasisPointsXShares2.sol\";\nimport {SharesXBasisPoints, scale, cast} from \"../types/SharesXBasisPoints.sol\";\nimport {Shares2XBasisPoints, alloc as allocS2Bp} from \"../types/Shares2XBasisPoints.sol\";\n\n/*\n\nWARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING\n  ***                                                                     ***\nWARNING                     This code is unaudited                      WARNING\n  ***                                                                     ***\nWARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING\n\n*/\n\nlibrary ReflectMath {\n    modifier freeMemory() {\n        uint256 freePtr;\n        assembly (\"memory-safe\") {\n            freePtr := mload(0x40)\n        }\n        _;\n        assembly (\"memory-safe\") {\n            mstore(0x40, freePtr)\n        }\n    }\n\n    // TODO: reorder arguments for clarity/consistency\n    function getTransferShares(\n        Tokens amount,\n        BasisPoints taxRate,\n        Tokens totalSupply,\n        Shares totalShares,\n        Shares fromShares,\n        Shares toShares\n    ) internal pure freeMemory returns (Shares newFromShares, Shares newToShares, Shares newTotalShares) {\n        Shares uninvolvedShares = totalShares - fromShares - toShares;\n        TokensXBasisPointsXShares2 n0 = allocTS().omul(fromShares, totalSupply).isub(tmpTS().omul(amount, totalShares))\n            .imul(scale(uninvolvedShares, BASIS));\n        TokensXBasisPointsXShares d = allocTBpS().omul(totalSupply, scale(uninvolvedShares, BASIS)).iadd(\n            tmpTBpS().omul(amount, scale(totalShares, taxRate))\n        );\n        TokensXBasisPointsXShares2 n1 = allocTBpS().omul(amount, scale(totalShares, BASIS - taxRate)).iadd(\n            tmpTBpS().omul(scale(toShares, BASIS), totalSupply)\n        ).imul(uninvolvedShares);\n\n        (newFromShares, newToShares) = (n0.div(d), n1.div(d));\n        newTotalShares = totalShares + (newToShares - toShares) - (fromShares - newFromShares);\n    }\n\n    function getTransferAllShares(BasisPoints taxRate, Shares totalShares, Shares fromShares, Shares toShares)\n        internal\n        pure\n        freeMemory\n        returns (Shares newToShares, Shares newTotalShares)\n    {\n        Shares uninvolvedShares = totalShares - fromShares - toShares;\n        Shares2XBasisPoints n = allocS2Bp().omul(scale(uninvolvedShares, BASIS), totalShares);\n        SharesXBasisPoints d = scale(uninvolvedShares, BASIS) + scale(fromShares, taxRate);\n\n        newTotalShares = n.div(d);\n        newToShares = toShares + fromShares - (totalShares - newTotalShares);\n    }\n\n    function getTransferSharesToWhale(\n        Tokens amount,\n        BasisPoints taxRate,\n        Tokens totalSupply,\n        Shares totalShares,\n        Shares fromShares,\n        Shares toShares\n    )\n        internal\n        pure\n        freeMemory\n        returns (Shares newFromShares, Shares counterfactualToShares, Shares newToShares, Shares newTotalShares)\n    {\n        TokensXShares d = allocTS().omul(totalShares.mul(Settings.ANTI_WHALE_DIVISOR), totalSupply + amount).isub(\n            tmpTS().omul(fromShares.mul(Settings.ANTI_WHALE_DIVISOR) + totalShares, totalSupply)\n        );\n        Shares uninvolvedShares = totalShares - fromShares - toShares;\n        TokensXShares2 n0 =\n            allocTS().omul(totalShares.mul(Settings.ANTI_WHALE_DIVISOR), totalSupply).imul(uninvolvedShares);\n        TokensXShares2 n1 = allocTS().omul(fromShares, totalSupply).isub(tmpTS().omul(totalShares, amount)).imul(\n            uninvolvedShares.mul(Settings.ANTI_WHALE_DIVISOR)\n        );\n\n        (newToShares, newFromShares) = (n0.div(d), n1.div(d));\n        newToShares = newToShares.div(Settings.ANTI_WHALE_DIVISOR) - ONE_SHARE;\n        newTotalShares = totalShares - (fromShares + toShares - newFromShares - newToShares);\n        counterfactualToShares = tmpTBpS().omul(\n            scale(totalSupply, BASIS.div(Settings.ANTI_WHALE_DIVISOR)) - scale(amount, BASIS - taxRate), totalShares\n        ).div(scale(totalSupply, BASIS));\n    }\n\n    function getTransferAllSharesToWhale(BasisPoints taxRate, Shares totalShares, Shares fromShares, Shares toShares)\n        internal\n        pure\n        returns (Shares counterfactualToShares, Shares newToShares, Shares newTotalShares)\n    {\n        (newToShares, newTotalShares) = whaleLimit(toShares, totalShares - fromShares);\n        counterfactualToShares =\n            cast(scale(totalShares, BASIS.div(Settings.ANTI_WHALE_DIVISOR)) - scale(fromShares, BASIS - taxRate));\n    }\n\n    function getTransferSharesFromPair(\n        BasisPoints taxRate,\n        Tokens totalSupply,\n        Shares totalShares,\n        Tokens amount,\n        Shares toShares\n    ) internal pure freeMemory returns (Shares newToShares, Shares newTotalShares, Tokens newTotalSupply) {\n        TokensXBasisPointsXShares d = allocTBpS().omul(scale(totalSupply, BASIS), totalShares).iadd(\n            tmpTBpS().omul(scale(amount, taxRate), totalShares)\n        );\n        TokensXBasisPointsXShares t = tmpTBpS().omul(scale(totalSupply, BASIS), toShares);\n        // slither-disable-next-line unused-return\n        d.isub(t);\n        TokensXBasisPointsXShares2 n =\n            allocTBpS().omul(scale(amount, BASIS - taxRate), totalShares).iadd(t).imul(totalShares - toShares);\n\n        newToShares = n.div(d);\n        newTotalShares = totalShares + newToShares - toShares;\n        newTotalSupply = totalSupply + amount;\n    }\n\n    function getCounterfactualSharesFromPairToWhale(\n        BasisPoints taxRate,\n        Tokens totalSupply,\n        Shares totalShares,\n        Tokens amount\n    ) internal pure returns (Shares counterfactualToShares) {\n        TokensXBasisPoints left = scale(totalSupply + amount, BASIS);\n        TokensXBasisPoints right = scale(amount.mul(Settings.ANTI_WHALE_DIVISOR), BASIS - taxRate);\n        counterfactualToShares = tmpTBpS().omul(left.saturatingSub(right), totalShares).div(\n            scale(totalSupply.mul(Settings.ANTI_WHALE_DIVISOR), BASIS)\n        );\n    }\n\n    function getTransferSharesToPair(\n        BasisPoints taxRate,\n        Tokens totalSupply,\n        Shares totalShares,\n        Tokens amount,\n        Shares fromShares\n    )\n        internal\n        pure\n        freeMemory\n        returns (Shares newFromShares, Shares newTotalShares, Tokens transferTokens, Tokens newTotalSupply)\n    {\n        TokensXBasisPointsXShares2 n = allocTBpS().omul(scale(fromShares, BASIS), totalSupply).isub(\n            tmpTBpS().omul(scale(totalShares, BASIS), amount)\n        ).imul(totalShares - fromShares);\n\n        TokensXBasisPointsXShares d = allocTBpS().omul(scale(totalShares, taxRate), amount).iadd(\n            tmpTBpS().omul(scale(totalShares - fromShares, BASIS), totalSupply)\n        );\n\n        newFromShares = n.div(d);\n        newTotalShares = totalShares - (fromShares - newFromShares);\n        transferTokens = cast(scale(amount, BASIS - taxRate));\n        newTotalSupply = totalSupply - transferTokens;\n    }\n\n    function getDeliverShares(Tokens amount, Tokens totalSupply, Shares totalShares, Shares fromShares)\n        internal\n        pure\n        freeMemory\n        returns (Shares newFromShares, Shares newTotalShares)\n    {\n        TokensXShares d = allocTS().omul(totalSupply, totalShares - fromShares);\n        TokensXShares t = tmpTS().omul(amount, totalShares);\n        // slither-disable-next-line unused-return\n        d.iadd(t);\n        TokensXShares2 n = allocTS().omul(fromShares, totalSupply).isub(t).imul(totalShares - fromShares);\n\n        newFromShares = n.div(d);\n        newTotalShares = totalShares + newFromShares - fromShares;\n    }\n\n    // getDeliverShares(Tokens,Shares,Shares) is not provided because it's extremely straightforward\n\n    function getBurnShares(Tokens amount, Tokens totalSupply, Shares totalShares, Shares fromShares)\n        internal\n        pure\n        freeMemory\n        returns (Shares newFromShares, Shares newTotalShares, Tokens newTotalSupply)\n    {\n        TokensXShares n = allocTS().omul(fromShares, totalSupply).isub(tmpTS().omul(totalShares, amount));\n        newFromShares = n.div(totalSupply);\n        newTotalShares = totalShares + newFromShares - fromShares;\n        newTotalSupply = totalSupply - amount;\n    }\n\n    // getBurnShares(Tokens,Shares,Shares) is not provided because it's extremely straightforward\n}\n"}, "src/core/TransientStorageLayout.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {CrazyBalance} from \"../types/CrazyBalance.sol\";\n\nabstract contract TransientStorageLayout {\n    function _setTemporaryAllowance(address owner, address spender, CrazyBalance amount) internal {\n        assembly (\"memory-safe\") {\n            mstore(0x14, spender)\n            mstore(0x00, owner)\n            tstore(keccak256(0x0c, 0x28), amount)\n        }\n    }\n\n    function _getTemporaryAllowance(address owner, address spender) internal view returns (CrazyBalance r) {\n        assembly (\"memory-safe\") {\n            mstore(0x14, spender)\n            mstore(0x00, owner)\n            r := tload(keccak256(0x0c, 0x28))\n        }\n    }\n}\n"}, "src/core/Checkpoints.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IERC5805} from \"../interfaces/IERC5805.sol\";\n\nimport {Settings} from \"./Settings.sol\";\n\nimport {Votes, ZERO as ZERO_VOTES} from \"../types/Votes.sol\";\n\nstruct Checkpoint {\n    uint48 key;\n    uint56 _pad;\n    uint152 value;\n}\n\nstruct Checkpoints {\n    mapping(address => Checkpoint[]) each;\n    Checkpoint[] total;\n}\n\nlibrary LibCheckpoints {\n    function transfer(Checkpoints storage checkpoints, address from, address to, Votes incr, Votes decr, uint48 clock)\n        internal\n    {\n        if (from == address(0)) {\n            if (to == address(0)) {\n                return;\n            }\n            return _mint(checkpoints, to, incr, clock);\n        }\n        if (to == address(0)) {\n            return _burn(checkpoints, from, decr, clock);\n        }\n        if (from == to) {\n            if (incr > decr) {\n                _mint(checkpoints, from, incr - decr, clock);\n            } else if (incr < decr) {\n                _burn(checkpoints, to, decr - incr, clock);\n            }\n            return;\n        }\n        if (incr > decr) {\n            _mint(checkpoints, incr - decr, clock);\n        } else if (incr < decr) {\n            _burn(checkpoints, decr - incr, clock);\n        }\n        _burn(checkpoints.each[from], from, decr, clock);\n        _mint(checkpoints.each[to], to, incr, clock);\n    }\n\n    function mint(Checkpoints storage checkpoints, address to, Votes incr, uint48 clock) internal {\n        if (to == address(0)) {\n            return;\n        }\n        return _mint(checkpoints, to, incr, clock);\n    }\n\n    function burn(Checkpoints storage checkpoints, address from, Votes decr, uint48 clock) internal {\n        if (from == address(0)) {\n            return;\n        }\n        return _burn(checkpoints, from, decr, clock);\n    }\n\n    function burn(Checkpoints storage checkpoints, address from0, Votes decr0, address from1, Votes decr1, uint48 clock)\n        internal\n    {\n        if (from0 == address(0)) {\n            return burn(checkpoints, from1, decr1, clock);\n        }\n        if (from1 == address(0)) {\n            return _burn(checkpoints, from0, decr0, clock);\n        }\n        return _burn(checkpoints, from0, decr0, from1, decr1, clock);\n    }\n\n    function _load(Checkpoint[] storage arr)\n        private\n        view\n        returns (Votes value, uint256 len, uint256 key, bytes32 slotValue)\n    {\n        assembly (\"memory-safe\") {\n            slotValue := sload(arr.slot)\n            key := shr(0xd0, slotValue)\n            len := and(0xffffffffffffff, shr(0x98, slotValue))\n            value := and(0x1ffffffffffffffffffffffffffffffffffff, slotValue)\n        }\n    }\n\n    function _get(Checkpoint[] storage arr, uint256 clock) private returns (Votes value, uint256 len) {\n        uint256 key;\n        bytes32 slotValue;\n        (value, len, key, slotValue) = _load(arr);\n        assembly (\"memory-safe\") {\n            if mul(key, gt(clock, key)) {\n                mstore(0x00, arr.slot)\n                sstore(\n                    add(keccak256(0x00, 0x20), len),\n                    and(0xffffffffffff0000000000000001ffffffffffffffffffffffffffffffffffff, slotValue)\n                )\n                len := add(0x01, len)\n            }\n        }\n    }\n\n    function _set(Checkpoint[] storage arr, uint256 clock, Votes value, uint256 len) private {\n        assembly (\"memory-safe\") {\n            sstore(\n                arr.slot, or(shl(0x98, len), or(shl(0xd0, clock), and(0x1ffffffffffffffffffffffffffffffffffff, value)))\n            )\n        }\n    }\n\n    function _mintUpdateState(Checkpoints storage checkpoints, Votes incr, uint256 clock) private {\n        Checkpoint[] storage arr = checkpoints.total;\n        (Votes oldValue, uint256 len) = _get(arr, clock);\n        _set(arr, clock, oldValue + incr, len);\n    }\n\n    function _mint(Checkpoints storage checkpoints, Votes incr, uint256 clock) private {\n        if (incr == ZERO_VOTES) {\n            return;\n        }\n        _mintUpdateState(checkpoints, incr, clock);\n    }\n\n    function _mintUpdateState(Checkpoint[] storage array, address to, Votes incr, uint256 clock) private {\n        (Votes oldValue, uint256 len) = _get(array, clock);\n        Votes newValue = oldValue + incr;\n        _set(array, clock, newValue, len);\n        emit IERC5805.DelegateVotesChanged(to, oldValue.toExternal(), newValue.toExternal());\n    }\n\n    function _mint(Checkpoint[] storage array, address to, Votes incr, uint256 clock) private {\n        if (incr == ZERO_VOTES) {\n            return;\n        }\n        _mintUpdateState(array, to, incr, clock);\n    }\n\n    function _mint(Checkpoints storage checkpoints, address to, Votes incr, uint256 clock) private {\n        if (incr == ZERO_VOTES) {\n            return;\n        }\n        _mintUpdateState(checkpoints, incr, clock);\n        _mintUpdateState(checkpoints.each[to], to, incr, clock);\n    }\n\n    function _burnUpdateState(Checkpoints storage checkpoints, Votes decr, uint256 clock) private {\n        Checkpoint[] storage arr = checkpoints.total;\n        (Votes oldValue, uint256 len) = _get(arr, clock);\n        _set(arr, clock, oldValue - decr, len);\n    }\n\n    function _burn(Checkpoints storage checkpoints, Votes decr, uint256 clock) private {\n        if (decr == ZERO_VOTES) {\n            return;\n        }\n        _burnUpdateState(checkpoints, decr, clock);\n    }\n\n    function _burnUpdateState(Checkpoint[] storage array, address from, Votes decr, uint256 clock) private {\n        (Votes oldValue, uint256 len) = _get(array, clock);\n        Votes newValue = oldValue - decr;\n        _set(array, clock, newValue, len);\n        emit IERC5805.DelegateVotesChanged(from, oldValue.toExternal(), newValue.toExternal());\n    }\n\n    function _burn(Checkpoint[] storage array, address from, Votes decr, uint256 clock) private {\n        if (decr == ZERO_VOTES) {\n            return;\n        }\n        _burnUpdateState(array, from, decr, clock);\n    }\n\n    function _burn(Checkpoints storage checkpoints, address from, Votes decr, uint256 clock) private {\n        if (decr == ZERO_VOTES) {\n            return;\n        }\n        _burnUpdateState(checkpoints, decr, clock);\n        _burnUpdateState(checkpoints.each[from], from, decr, clock);\n    }\n\n    function _burn(\n        Checkpoints storage checkpoints,\n        address from0,\n        Votes decr0,\n        address from1,\n        Votes decr1,\n        uint256 clock\n    ) private {\n        Votes decr = decr0 + decr1;\n        if (decr == ZERO_VOTES) {\n            return;\n        }\n        _burnUpdateState(checkpoints, decr, clock);\n        _burn(checkpoints.each[from0], from0, decr0, clock);\n        _burn(checkpoints.each[from1], from1, decr1, clock);\n    }\n\n    function current(Checkpoints storage checkpoints, address account) internal view returns (Votes value) {\n        Checkpoint[] storage each = checkpoints.each[account];\n        assembly (\"memory-safe\") {\n            value := and(0x1ffffffffffffffffffffffffffffffffffff, sload(each.slot))\n        }\n    }\n\n    function currentTotal(Checkpoints storage checkpoints) internal view returns (Votes value) {\n        Checkpoint[] storage total = checkpoints.total;\n        assembly (\"memory-safe\") {\n            value := and(0x1ffffffffffffffffffffffffffffffffffff, sload(total.slot))\n        }\n    }\n\n    function _bisect(Checkpoint[] storage arr, uint256 query) private view returns (Votes value) {\n        uint256 len;\n        {\n            uint256 key;\n            (value, len, key,) = _load(arr);\n            if (key <= query) {\n                return value;\n            }\n        }\n        uint256 initialWindow = Settings.BISECT_WINDOW_DEFAULT;\n        assembly (\"memory-safe\") {\n            // A dynamic array's elements are encoded in storage beginning at\n            // the slot named by the hash of the base slot\n            mstore(0x00, arr.slot)\n            let start := keccak256(0x00, 0x20)\n\n            // Because we tend to query near the current time, we optimize by\n            // bounding our search to progressively larger portions near the end\n            // of the array, until we find one that contains the checkpoint of\n            // interest\n            let hi := add(start, len)\n            let lo := sub(hi, initialWindow)\n            for {} true {} {\n                if lt(lo, start) {\n                    lo := start\n                    value := 0x00\n                    break\n                }\n                value := sload(lo)\n                if iszero(gt(shr(0xd0, value), query)) {\n                    lo := add(0x01, lo)\n                    break\n                }\n                let newLo := sub(lo, shl(0x01, sub(hi, lo)))\n                hi := lo\n                lo := newLo\n            }\n\n            // Apply normal binary search\n            for {} xor(hi, lo) {} {\n                let mid := add(shr(0x01, sub(hi, lo)), lo)\n                let newValue := sload(mid)\n                if gt(shr(0xd0, newValue), query) {\n                    // down\n                    hi := mid\n                    continue\n                }\n                // up\n                value := newValue\n                lo := add(0x01, mid)\n            }\n\n            value := and(0x1ffffffffffffffffffffffffffffffffffff, value)\n        }\n    }\n\n    function get(Checkpoints storage checkpoints, address account, uint48 timepoint) internal view returns (Votes) {\n        return _bisect(checkpoints.each[account], timepoint);\n    }\n\n    function getTotal(Checkpoints storage checkpoints, uint48 timepoint) internal view returns (Votes) {\n        return _bisect(checkpoints.total, timepoint);\n    }\n}\n"}, "src/core/RebaseQueue.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"@forge-std/interfaces/IERC20.sol\";\n\nimport {Settings} from \"./Settings.sol\";\nimport {applyWhaleLimit} from \"./WhaleLimit.sol\";\n\nimport {Tokens, ZERO as ZERO_TOKENS} from \"../types/Tokens.sol\";\nimport {Shares, SharesStorage, ONE as ONE_SHARE} from \"../types/Shares.sol\";\nimport {SharesToTokens} from \"../types/TokensXShares.sol\";\nimport {Tokens} from \"../types/Tokens.sol\";\nimport {UnsafeMath} from \"../lib/UnsafeMath.sol\";\n\nstruct RebaseQueueElem {\n    address prev;\n    address next;\n    Tokens lastTokens;\n}\n\nstruct RebaseQueue {\n    mapping(address => RebaseQueueElem) queue;\n    address head;\n}\n\nlibrary LibRebaseQueue {\n    using UnsafeMath for uint256;\n    using SharesToTokens for Shares;\n\n    function initialize(RebaseQueue storage self, address account, Tokens tokens) internal {\n        self.head = account;\n        RebaseQueueElem storage elem = self.queue[account];\n        elem.prev = account;\n        elem.next = account;\n        elem.lastTokens = tokens;\n    }\n\n    function enqueue(RebaseQueue storage self, address account, Tokens balance) internal {\n        RebaseQueueElem storage elem = self.queue[account];\n        address head = self.head;\n        RebaseQueueElem storage headElem = self.queue[head];\n        address tail = headElem.prev;\n\n        elem.prev = tail;\n        elem.next = head;\n        elem.lastTokens = balance;\n\n        self.queue[tail].next = account;\n        headElem.prev = account;\n    }\n\n    function enqueue(RebaseQueue storage self, address account, Shares shares, Tokens totalSupply, Shares totalShares)\n        internal\n    {\n        return enqueue(self, account, shares.toTokens(totalSupply, totalShares));\n    }\n\n    function dequeue(RebaseQueue storage self, address account) internal {\n        RebaseQueueElem storage elem = self.queue[account];\n        elem.lastTokens = ZERO_TOKENS;\n        address prev = elem.prev;\n        address next = elem.next;\n\n        elem.prev = address(0);\n        elem.next = address(0);\n\n        self.queue[prev].next = next;\n        self.queue[next].prev = prev;\n\n        if (self.head == account) {\n            self.head = next;\n        }\n    }\n\n    function moveToBack(\n        RebaseQueue storage self,\n        address account,\n        Shares shares,\n        Tokens totalSupply,\n        Shares totalShares\n    ) internal {\n        RebaseQueueElem storage elem = self.queue[account];\n        elem.lastTokens = shares.toTokens(totalSupply, totalShares);\n\n        if (self.head == account) {\n            self.head = elem.next;\n            return;\n        }\n\n        address next = elem.next;\n        address head = self.head;\n        if (next == head) {\n            return;\n        }\n        address prev = elem.prev;\n        RebaseQueueElem storage headElem = self.queue[head];\n        address tail = headElem.prev;\n\n        elem.prev = tail;\n        elem.next = head;\n\n        self.queue[prev].next = next;\n        self.queue[next].prev = prev;\n\n        self.queue[tail].next = account;\n        headElem.prev = account;\n    }\n\n    function _rebaseFor(\n        RebaseQueueElem storage elem,\n        address account,\n        Shares shares,\n        Tokens totalSupply,\n        Shares totalShares\n    ) private returns (Tokens newTokens) {\n        Tokens oldTokens = elem.lastTokens;\n        newTokens = shares.toTokens(totalSupply, totalShares);\n        if (newTokens > oldTokens) {\n            emit IERC20.Transfer(address(0), account, (newTokens - oldTokens).toExternal());\n        } else {\n            newTokens = oldTokens;\n        }\n    }\n\n    function rebaseFor(RebaseQueue storage self, address account, Shares shares, Tokens totalSupply, Shares totalShares)\n        internal\n    {\n        _rebaseFor(self.queue[account], account, shares, totalSupply, totalShares);\n    }\n\n    function processQueue(\n        RebaseQueue storage self,\n        mapping(address => SharesStorage) storage sharesOf,\n        Tokens totalSupply,\n        Shares totalShares\n    ) internal {\n        address cursor = self.head;\n        RebaseQueueElem storage elem = self.queue[cursor];\n        uint256 i;\n        assembly (\"memory-safe\") {\n            mstore(0x00, gas())\n            i := shr(0xfd, keccak256(0x00, 0x20))\n        }\n        for (;; i = i.unsafeDec()) {\n            (Shares shares, Shares totalSharesLimited) = applyWhaleLimit(sharesOf[cursor].load(), totalShares);\n            elem.lastTokens = _rebaseFor(elem, cursor, shares, totalSupply, totalSharesLimited);\n            cursor = elem.next;\n            if (i == 0) {\n                break;\n            }\n            elem = self.queue[cursor];\n        }\n        self.head = cursor;\n    }\n}\n"}, "src/core/MoonPhase.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {BasisPoints} from \"../types/BasisPoints.sol\";\n\nimport {Ternary} from \"../lib/Ternary.sol\";\nimport {UnsafeMath} from \"../lib/UnsafeMath.sol\";\n\nlibrary MoonPhase {\n    using Ternary for bool;\n    using UnsafeMath for int256;\n\n    uint256 private constant _EPOCH = 1740721485; // 2025-02-28T00:44:45Z, the last new moon of February 2025\n    // This is the AVERAGE length of the synodic month at the epoch. The duration between actual new\n    // moons varies significantly over short periods of time. Over long periods of time, the average\n    // length of the synodic month increases slightly.\n    uint256 private constant _SYNODIC_MONTH = 0x17348a775920; // 29.530588907 * 10 ** 7 * 1 days\n    uint256 private constant _SCALE = 0x9896800000000000000000; // 2 ** 64 * 10 ** 7\n\n    int256 private constant _ONE_HALF = 0x8000000000000000; // 0.5 * 2 ** 64\n    int256 private constant _ONE_QUARTER = 0x4000000000000000; // 0.25 * 2 ** 64\n    int256 private constant _THREE_QUARTERS = 0xc000000000000000; // 0.75 * 2 ** 64\n\n    function moonPhase(uint256 timestamp) internal pure returns (BasisPoints) {\n        // This is performed outside the `unchecked` block because we want underflow checking\n        uint256 reEpoch = timestamp - _EPOCH;\n        unchecked {\n            // `monthElapsed` represents the position of the current moment within the current lunar\n            // month. It's a linear value, even though the illumination of the moon is nonlinear in\n            // time. The basis, `2 ** 64`, is chosen so that when we compute `sin` below, we can\n            // avoid some extraneous bit shifts. The author considered a higher-order polynomial\n            // approximation of the length of the synodic month, but concluded that it was excessive\n            // given the relatively small second and third moments (compared to \"reasonable\"\n            // timescales) as well as the significant additional complexity in taking the integral\n            // of that approximation from the epoch to the present.\n            int256 monthElapsed = int256((reEpoch * _SCALE / _SYNODIC_MONTH) & type(uint64).max);\n\n            // Now that we have the sawtooth function `monthElapsed` that ranges from 0 at the new\n            // moon to 0.5 at the full moon to 1 at the next new moon, we want to convert that into\n            // a smooth function representing the (un)illuminated portion of the moon's face. We\n            // must take the cosine of `monthElapsed`.\n\n            // For convenience, rather than represent the input to `cos` in radians, we represent it\n            // in turns (with a full circle represented by 1 instead of 2\u03c0). We first reduce the\n            // range of `x` from 0 to 1 to 0 to 0.25 and reflect it so that we can compute `sign *\n            // sin(x)` instead.\n            int256 x;\n            {\n                int256 thresh = (monthElapsed < _ONE_HALF).ternary(_ONE_QUARTER, _THREE_QUARTERS);\n                x = (monthElapsed < thresh).ternary(thresh - monthElapsed, monthElapsed - thresh);\n            }\n            int256 sign = (uint256(monthElapsed) - uint256(_ONE_QUARTER) < uint256(_ONE_HALF)).ternary(-1, 1); // underflow is desired\n\n            // Now we approximate `sign * sin(x)` via a (4, 3)-term monic-numerator rational\n            // polynomial. This technique was popularized by Remco Bloemen\n            // (https://2\u03c0.com/22/approximation/). The basis `2 ** 64` was chosen to give enough\n            // extra precision to avoid significant rounding error in the coefficients, but not so\n            // much that we have to perform wasteful right shifts between each term. We use Horner's\n            // rule to evaluate each polynomial because Knuth's and Winograd's algorithms give worse\n            // rounding error. This relatively small rational polynomial is only accurate to ~1e-5,\n            // but that is more than sufficient for our purposes.\n\n            int256 p = x; // `p` is monic; the leading coefficient is 1\n            p += 0x152c603e02fe2031; // ~0.0827\n            p *= x;\n            p -= 0x462df383df0568550000000000000000; // ~0.274\n            p *= x;\n            // The constant coefficient of `p` is so small (~3.98e-7) that it does not affect\n            // accuracy if it is elided\n            p *= sign;\n\n            int256 q = -0x1d98428cf2b72221; // ~-0.116\n            q *= x;\n            q += 0x032c1ccefcbad6dd0000000000000000; // ~0.0124\n            q *= x;\n            q -= 0x0b2a3a89efcf885e00000000000000000000000000000000; // ~0.0436\n\n            // Now `p/q` if computed exactly represents `cos(monthElapsed)`. What we actually want,\n            // though, is `(1 + cos(monthElapsed)) / 2`. We also want to represent the output as a\n            // value from 1 to 5000 inclusive; this gives rise to the awkward `2500` as well as the\n            // `+ 1`. `q` has no zeroes in the domain, so we don't need to worry about\n            // divide-by-zero.\n            return BasisPoints.wrap(uint256(((p + q) * 2500).unsafeDiv(q)) + 1);\n        }\n    }\n}\n"}, "src/core/WhaleLimit.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Shares, ONE as ONE_SHARE, ternary, maybeSwap} from \"../types/Shares.sol\";\nimport {Settings} from \"./Settings.sol\";\n\nfunction whaleLimit(Shares shares, Shares totalShares) pure returns (Shares limit, Shares newTotalShares) {\n    Shares uninvolved = totalShares - shares;\n    limit = uninvolved.div(Settings.ANTI_WHALE_DIVISOR_MINUS_ONE) - ONE_SHARE;\n    newTotalShares = uninvolved + limit;\n}\n\nfunction applyWhaleLimit(Shares shares, Shares totalShares) pure returns (Shares, Shares) {\n    (Shares limit, Shares newTotalShares) = whaleLimit(shares, totalShares);\n    bool condition = shares > limit;\n    return (ternary(condition, limit, shares), ternary(condition, newTotalShares, totalShares));\n}\n\nfunction applyWhaleLimit(Shares shares0, Shares shares1, Shares totalShares) pure returns (Shares, Shares, Shares) {\n    bool condition = shares0 > shares1;\n    (Shares sharesLo, Shares sharesHi) = maybeSwap(condition, shares0, shares1);\n    (Shares firstLimit, Shares newTotalShares) = whaleLimit(sharesHi, totalShares);\n    if (sharesHi > firstLimit) {\n        Shares uninvolved = totalShares - sharesHi - sharesLo;\n        Shares secondLimit = uninvolved.div(Settings.ANTI_WHALE_DIVISOR_MINUS_TWO) - ONE_SHARE;\n        if (sharesLo > secondLimit) {\n            totalShares = uninvolved + secondLimit.mul(2);\n            sharesHi = secondLimit;\n            sharesLo = secondLimit;\n        } else {\n            totalShares = newTotalShares;\n            sharesHi = firstLimit;\n        }\n    }\n    (shares0, shares1) = maybeSwap(condition, sharesLo, sharesHi);\n    return (shares0, shares1, totalShares);\n}\n"}, "src/types/BasisPoints.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {UnsafeMath} from \"../lib/UnsafeMath.sol\";\n\n/// This type is given as `uint256` for efficiency, but it is capped at 10_000\n/// (14 bits).\ntype BasisPoints is uint256;\n\nBasisPoints constant ZERO = BasisPoints.wrap(0);\nBasisPoints constant BASIS = BasisPoints.wrap(10_000);\n\nlibrary BasisPointsArithmetic {\n    using UnsafeMath for uint256;\n\n    function mul(BasisPoints x, uint256 y) internal pure returns (BasisPoints) {\n        unchecked {\n            return BasisPoints.wrap(BasisPoints.unwrap(x) * y);\n        }\n    }\n\n    function div(BasisPoints n, uint256 d) internal pure returns (BasisPoints) {\n        return BasisPoints.wrap(BasisPoints.unwrap(n).unsafeDiv(d));\n    }\n}\n\nusing BasisPointsArithmetic for BasisPoints global;\n\nfunction __sub(BasisPoints a, BasisPoints b) pure returns (BasisPoints) {\n    unchecked {\n        return BasisPoints.wrap(BasisPoints.unwrap(a) - BasisPoints.unwrap(b));\n    }\n}\n\nusing {__sub as -} for BasisPoints global;\n\nfunction __eq(BasisPoints a, BasisPoints b) pure returns (bool) {\n    return BasisPoints.unwrap(a) == BasisPoints.unwrap(b);\n}\n\nfunction __lt(BasisPoints a, BasisPoints b) pure returns (bool) {\n    return BasisPoints.unwrap(a) < BasisPoints.unwrap(b);\n}\n\nfunction __gt(BasisPoints a, BasisPoints b) pure returns (bool) {\n    return BasisPoints.unwrap(a) > BasisPoints.unwrap(b);\n}\n\nfunction __ne(BasisPoints a, BasisPoints b) pure returns (bool) {\n    return BasisPoints.unwrap(a) != BasisPoints.unwrap(b);\n}\n\nfunction __le(BasisPoints a, BasisPoints b) pure returns (bool) {\n    return BasisPoints.unwrap(a) <= BasisPoints.unwrap(b);\n}\n\nfunction __ge(BasisPoints a, BasisPoints b) pure returns (bool) {\n    return BasisPoints.unwrap(a) >= BasisPoints.unwrap(b);\n}\n\nusing {__eq as ==, __lt as <, __gt as >, __ne as !=, __le as <=, __gt as >=} for BasisPoints global;\n\nfunction scale(uint256 x, BasisPoints bp) pure returns (uint256) {\n    unchecked {\n        return x * BasisPoints.unwrap(bp) / BasisPoints.unwrap(BASIS);\n    }\n}\n\nfunction scaleUp(uint256 x, BasisPoints bp) pure returns (uint256) {\n    unchecked {\n        return UnsafeMath.unsafeDivUp(x * BasisPoints.unwrap(bp), BasisPoints.unwrap(BASIS));\n    }\n}\n"}, "src/types/Shares.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {UnsafeMath} from \"../lib/UnsafeMath.sol\";\nimport {Ternary} from \"../lib/Ternary.sol\";\n\n/// This type is given as `uint256` for efficiency, but it is capped at `2 ** 177 - 1`.\ntype Shares is uint256;\n\nShares constant ZERO = Shares.wrap(0);\nShares constant ONE = Shares.wrap(1);\n\nlibrary SharesUnsafeMathAdapter {\n    using UnsafeMath for uint256;\n\n    function inc(Shares x, bool c) internal pure returns (Shares) {\n        return Shares.wrap(Shares.unwrap(x).unsafeInc(c));\n    }\n\n    function dec(Shares x, bool c) internal pure returns (Shares) {\n        return Shares.wrap(Shares.unwrap(x).unsafeDec(c));\n    }\n}\n\nusing SharesUnsafeMathAdapter for Shares global;\n\nlibrary SharesArithmetic {\n    using UnsafeMath for uint256;\n\n    function mul(Shares x, uint256 y) internal pure returns (Shares) {\n        unchecked {\n            return Shares.wrap(Shares.unwrap(x) * y);\n        }\n    }\n\n    function div(Shares n, uint256 d) internal pure returns (Shares) {\n        return Shares.wrap(Shares.unwrap(n).unsafeDiv(d));\n    }\n}\n\nusing SharesArithmetic for Shares global;\n\nfunction __add(Shares a, Shares b) pure returns (Shares) {\n    unchecked {\n        return Shares.wrap(Shares.unwrap(a) + Shares.unwrap(b));\n    }\n}\n\nfunction __sub(Shares a, Shares b) pure returns (Shares) {\n    unchecked {\n        return Shares.wrap(Shares.unwrap(a) - Shares.unwrap(b));\n    }\n}\n\nfunction __eq(Shares a, Shares b) pure returns (bool) {\n    return Shares.unwrap(a) == Shares.unwrap(b);\n}\n\nfunction __lt(Shares a, Shares b) pure returns (bool) {\n    return Shares.unwrap(a) < Shares.unwrap(b);\n}\n\nfunction __gt(Shares a, Shares b) pure returns (bool) {\n    return Shares.unwrap(a) > Shares.unwrap(b);\n}\n\nfunction __ne(Shares a, Shares b) pure returns (bool) {\n    return Shares.unwrap(a) != Shares.unwrap(b);\n}\n\nfunction __le(Shares a, Shares b) pure returns (bool) {\n    return Shares.unwrap(a) <= Shares.unwrap(b);\n}\n\nfunction __ge(Shares a, Shares b) pure returns (bool) {\n    return Shares.unwrap(a) >= Shares.unwrap(b);\n}\n\nusing {\n    __add as +, __sub as -, __eq as ==, __lt as <, __gt as >, __ne as !=, __le as <=, __gt as >=\n} for Shares global;\n\nfunction ternary(bool c, Shares x, Shares y) pure returns (Shares) {\n    return Shares.wrap(Ternary.ternary(c, Shares.unwrap(x), Shares.unwrap(y)));\n}\n\nfunction maybeSwap(bool c, Shares x, Shares y) pure returns (Shares, Shares) {\n    (uint256 a, uint256 b) = Ternary.maybeSwap(c, Shares.unwrap(x), Shares.unwrap(y));\n    return (Shares.wrap(a), Shares.wrap(b));\n}\n\n// This is the same as `Shares`, except it has padding on both ends, just to make life harder for\n// people who do state overrides. Also, unlike \"normal\" Solidity behavior, dirty padding is not\n// cleaned, but instead results in the entire slot being implicitly cleared.\ntype SharesStorage is uint256;\n\nfunction load(SharesStorage x) pure returns (Shares r) {\n    assembly (\"memory-safe\") {\n        r := mul(shr(0x28, x), iszero(and(0xffffffffff00000000000000000000000000000000000000000000ffffffffff, x)))\n    }\n}\n\nfunction store(Shares x) pure returns (SharesStorage r) {\n    assembly (\"memory-safe\") {\n        r := shl(0x28, x)\n    }\n}\n\nusing {load} for SharesStorage global;\nusing {store} for Shares global;\n"}, "src/types/Tokens.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {UnsafeMath} from \"../lib/UnsafeMath.sol\";\n\n/// This type is given as `uint256` for efficiency, but it is capped at `2 ** 145 - 1`.\ntype Tokens is uint256;\n\nlibrary TokensAccessors {\n    function toExternal(Tokens x) internal pure returns (uint256) {\n        return Tokens.unwrap(x);\n    }\n}\n\nusing TokensAccessors for Tokens global;\n\nTokens constant ZERO = Tokens.wrap(0);\nTokens constant ONE = Tokens.wrap(1);\n\nlibrary TokensUnsafeMathAdapter {\n    using UnsafeMath for uint256;\n\n    function inc(Tokens x, bool c) internal pure returns (Tokens) {\n        return Tokens.wrap(Tokens.unwrap(x).unsafeInc(c));\n    }\n\n    function dec(Tokens x, bool c) internal pure returns (Tokens) {\n        return Tokens.wrap(Tokens.unwrap(x).unsafeDec(c));\n    }\n}\n\nusing TokensUnsafeMathAdapter for Tokens global;\n\nlibrary TokensArithmetic {\n    using UnsafeMath for uint256;\n\n    function mul(Tokens x, uint256 y) internal pure returns (Tokens) {\n        unchecked {\n            return Tokens.wrap(Tokens.unwrap(x) * y);\n        }\n    }\n\n    function div(Tokens n, uint256 d) internal pure returns (Tokens) {\n        return Tokens.wrap(Tokens.unwrap(n).unsafeDiv(d));\n    }\n}\n\nusing TokensArithmetic for Tokens global;\n\nfunction __add(Tokens a, Tokens b) pure returns (Tokens) {\n    unchecked {\n        return Tokens.wrap(Tokens.unwrap(a) + Tokens.unwrap(b));\n    }\n}\n\nfunction __sub(Tokens a, Tokens b) pure returns (Tokens) {\n    unchecked {\n        return Tokens.wrap(Tokens.unwrap(a) - Tokens.unwrap(b));\n    }\n}\n\nfunction __eq(Tokens a, Tokens b) pure returns (bool) {\n    return Tokens.unwrap(a) == Tokens.unwrap(b);\n}\n\nfunction __lt(Tokens a, Tokens b) pure returns (bool) {\n    return Tokens.unwrap(a) < Tokens.unwrap(b);\n}\n\nfunction __gt(Tokens a, Tokens b) pure returns (bool) {\n    return Tokens.unwrap(a) > Tokens.unwrap(b);\n}\n\nfunction __ne(Tokens a, Tokens b) pure returns (bool) {\n    return Tokens.unwrap(a) != Tokens.unwrap(b);\n}\n\nfunction __le(Tokens a, Tokens b) pure returns (bool) {\n    return Tokens.unwrap(a) <= Tokens.unwrap(b);\n}\n\nfunction __ge(Tokens a, Tokens b) pure returns (bool) {\n    return Tokens.unwrap(a) >= Tokens.unwrap(b);\n}\n\nusing {\n    __add as +, __sub as -, __eq as ==, __lt as <, __gt as >, __ne as !=, __le as <=, __ge as >=\n} for Tokens global;\n"}, "src/types/TokensXShares.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Shares} from \"./Shares.sol\";\nimport {Tokens} from \"./Tokens.sol\";\nimport {BasisPoints} from \"./BasisPoints.sol\";\nimport {SharesXBasisPoints} from \"./SharesXBasisPoints.sol\";\n\nimport {TokensXShares2, cast2} from \"./TokensXShares2.sol\";\nimport {TokensXBasisPointsXShares, cast as cast3} from \"./TokensXBasisPointsXShares.sol\";\nimport {TokensXBasisPointsXShares2, cast as cast4} from \"./TokensXBasisPointsXShares2.sol\";\n\nimport {uint512, tmp as baseTmp, alloc as baseAlloc} from \"../lib/512Math.sol\";\n\ntype TokensXShares is bytes32;\n\nfunction cast(TokensXShares x) pure returns (uint512) {\n    return uint512.wrap(TokensXShares.unwrap(x));\n}\n\nfunction cast(uint512 x) pure returns (TokensXShares) {\n    return TokensXShares.wrap(uint512.unwrap(x));\n}\n\nfunction alloc() pure returns (TokensXShares) {\n    return cast(baseAlloc());\n}\n\nfunction tmp() pure returns (TokensXShares) {\n    return cast(baseTmp());\n}\n\nlibrary TokensXSharesArithmetic {\n    function iadd(TokensXShares r, TokensXShares x) internal pure returns (TokensXShares) {\n        return cast(cast(r).iadd(cast(x)));\n    }\n\n    function isub(TokensXShares r, TokensXShares x) internal pure returns (TokensXShares) {\n        return cast(cast(r).isub(cast(x)));\n    }\n\n    function omul(TokensXShares r, Tokens b, Shares s) internal pure returns (TokensXShares) {\n        return cast(cast(r).omul(Tokens.unwrap(b), Shares.unwrap(s)));\n    }\n\n    function omul(TokensXShares r, Shares s, Tokens b) internal pure returns (TokensXShares) {\n        return cast(cast(r).omul(Shares.unwrap(s), Tokens.unwrap(b)));\n    }\n\n    function imul(TokensXShares r, Shares s) internal pure returns (TokensXShares2) {\n        return cast2(cast(r).imul(Shares.unwrap(s)));\n    }\n\n    function imul(TokensXShares r, BasisPoints bp) internal pure returns (TokensXBasisPointsXShares) {\n        return cast3(cast(r).imul(BasisPoints.unwrap(bp)));\n    }\n\n    function imul(TokensXShares r, SharesXBasisPoints s) internal pure returns (TokensXBasisPointsXShares2) {\n        return cast4(cast(r).imul(SharesXBasisPoints.unwrap(s)));\n    }\n\n    function div(TokensXShares n, Tokens d) internal pure returns (Shares) {\n        return Shares.wrap(cast(n).div(Tokens.unwrap(d)));\n    }\n\n    function div(TokensXShares n, Shares d) internal pure returns (Tokens) {\n        return Tokens.wrap(cast(n).div(Shares.unwrap(d)));\n    }\n\n    function divMulti(TokensXShares n0, TokensXShares n1, Tokens d) internal pure returns (Shares, Shares) {\n        (uint256 r0, uint256 r1) = cast(n0).divMulti(cast(n1), Tokens.unwrap(d));\n        return (Shares.wrap(r0), Shares.wrap(r1));\n    }\n\n    function divMulti(TokensXShares n0, TokensXShares n1, Shares d) internal pure returns (Tokens, Tokens) {\n        (uint256 r0, uint256 r1) = cast(n0).divMulti(cast(n1), Shares.unwrap(d));\n        return (Tokens.wrap(r0), Tokens.wrap(r1));\n    }\n}\n\nusing TokensXSharesArithmetic for TokensXShares global;\n\nfunction __eq(TokensXShares a, TokensXShares b) pure returns (bool) {\n    return cast(a) == cast(b);\n}\n\nfunction __lt(TokensXShares a, TokensXShares b) pure returns (bool) {\n    return cast(a) < cast(b);\n}\n\nfunction __gt(TokensXShares a, TokensXShares b) pure returns (bool) {\n    return cast(a) > cast(b);\n}\n\nfunction __ne(TokensXShares a, TokensXShares b) pure returns (bool) {\n    return cast(a) != cast(b);\n}\n\nfunction __le(TokensXShares a, TokensXShares b) pure returns (bool) {\n    return cast(a) <= cast(b);\n}\n\nfunction __ge(TokensXShares a, TokensXShares b) pure returns (bool) {\n    return cast(a) >= cast(b);\n}\n\nusing {__eq as ==, __lt as <, __gt as >, __ne as !=, __le as <=, __ge as >=} for TokensXShares global;\n\nlibrary SharesToTokens {\n    function toTokens(Shares shares, Tokens totalSupply, Shares totalShares) internal pure returns (Tokens) {\n        return tmp().omul(shares, totalSupply).div(totalShares);\n    }\n\n    modifier freeMemory() {\n        uint256 freePtr;\n        assembly (\"memory-safe\") {\n            freePtr := mload(0x40)\n        }\n        _;\n        assembly (\"memory-safe\") {\n            mstore(0x40, freePtr)\n        }\n    }\n\n    function toTokensMulti(Shares shares0, Shares shares1, Tokens totalSupply, Shares totalShares)\n        internal\n        pure\n        freeMemory\n        returns (Tokens r0, Tokens r1)\n    {\n        TokensXShares n0 = alloc().omul(shares0, totalSupply);\n        TokensXShares n1 = tmp().omul(shares1, totalSupply);\n        (r0, r1) = n0.divMulti(n1, totalShares);\n    }\n}\n"}, "src/types/TokensXBasisPointsXShares.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {BASIS} from \"./BasisPoints.sol\";\nimport {Shares} from \"./Shares.sol\";\nimport {Tokens} from \"./Tokens.sol\";\nimport {SharesXBasisPoints, scale} from \"./SharesXBasisPoints.sol\";\nimport {TokensXBasisPoints} from \"./TokensXBasisPoints.sol\";\n\nimport {TokensXBasisPointsXShares2, cast as cast2} from \"./TokensXBasisPointsXShares2.sol\";\n\nimport {uint512, tmp as baseTmp, alloc as baseAlloc} from \"../lib/512Math.sol\";\n\ntype TokensXBasisPointsXShares is bytes32;\n\nfunction cast(TokensXBasisPointsXShares x) pure returns (uint512) {\n    return uint512.wrap(TokensXBasisPointsXShares.unwrap(x));\n}\n\nfunction cast(uint512 x) pure returns (TokensXBasisPointsXShares) {\n    return TokensXBasisPointsXShares.wrap(uint512.unwrap(x));\n}\n\nfunction alloc() pure returns (TokensXBasisPointsXShares) {\n    return cast(baseAlloc());\n}\n\nfunction tmp() pure returns (TokensXBasisPointsXShares) {\n    return cast(baseTmp());\n}\n\nlibrary TokensXBasisPointsXSharesArithmetic {\n    function iadd(TokensXBasisPointsXShares r, TokensXBasisPointsXShares x)\n        internal\n        pure\n        returns (TokensXBasisPointsXShares)\n    {\n        return cast(cast(r).iadd(cast(x)));\n    }\n\n    function isub(TokensXBasisPointsXShares r, TokensXBasisPointsXShares x)\n        internal\n        pure\n        returns (TokensXBasisPointsXShares)\n    {\n        return cast(cast(r).isub(cast(x)));\n    }\n\n    function omul(TokensXBasisPointsXShares r, Tokens b, SharesXBasisPoints s)\n        internal\n        pure\n        returns (TokensXBasisPointsXShares)\n    {\n        return cast(cast(r).omul(Tokens.unwrap(b), SharesXBasisPoints.unwrap(s)));\n    }\n\n    function omul(TokensXBasisPointsXShares r, SharesXBasisPoints s, Tokens b)\n        internal\n        pure\n        returns (TokensXBasisPointsXShares)\n    {\n        return cast(cast(r).omul(SharesXBasisPoints.unwrap(s), Tokens.unwrap(b)));\n    }\n\n    function omul(TokensXBasisPointsXShares r, Shares s, TokensXBasisPoints b)\n        internal\n        pure\n        returns (TokensXBasisPointsXShares)\n    {\n        return cast(cast(r).omul(Shares.unwrap(s), TokensXBasisPoints.unwrap(b)));\n    }\n\n    function omul(TokensXBasisPointsXShares r, TokensXBasisPoints b, Shares s)\n        internal\n        pure\n        returns (TokensXBasisPointsXShares)\n    {\n        return cast(cast(r).omul(TokensXBasisPoints.unwrap(b), Shares.unwrap(s)));\n    }\n\n    function imul(TokensXBasisPointsXShares r, Shares s) internal pure returns (TokensXBasisPointsXShares2) {\n        return cast2(cast(r).imul(Shares.unwrap(s)));\n    }\n\n    function div(TokensXBasisPointsXShares n, SharesXBasisPoints d) internal pure returns (Tokens) {\n        return Tokens.wrap(cast(n).div(SharesXBasisPoints.unwrap(d)));\n    }\n\n    function div(TokensXBasisPointsXShares n, TokensXBasisPoints d) internal pure returns (Shares) {\n        return Shares.wrap(cast(n).div(TokensXBasisPoints.unwrap(d)));\n    }\n}\n\nusing TokensXBasisPointsXSharesArithmetic for TokensXBasisPointsXShares global;\n\nlibrary SharesToTokensProportional {\n    function toTokens(SharesXBasisPoints sharesBp, Tokens totalSupply, Shares totalShares)\n        internal\n        pure\n        returns (Tokens)\n    {\n        return tmp().omul(sharesBp, totalSupply).div(scale(totalShares, BASIS));\n    }\n}\n"}, "src/types/Votes.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Settings} from \"../core/Settings.sol\";\n\nimport {Shares} from \"./Shares.sol\";\n\n// This is actually only 145 bits, but we set it to 256 bits here to convince the compiler we don't\n// need to do as much masking.\ntype Votes is uint256;\n\nVotes constant ZERO = Votes.wrap(0);\n\nfunction toVotes(Shares s) pure returns (Votes) {\n    return Votes.wrap(Shares.unwrap(s) >> Settings.SHARES_TO_VOTES_SHIFT);\n}\n\nfunction toExternal(Votes v) pure returns (uint256) {\n    return Votes.unwrap(v);\n}\n\nusing {toExternal} for Votes global;\n\nfunction __add(Votes a, Votes b) pure returns (Votes) {\n    unchecked {\n        return Votes.wrap(Votes.unwrap(a) + Votes.unwrap(b));\n    }\n}\n\nfunction __sub(Votes a, Votes b) pure returns (Votes) {\n    unchecked {\n        return Votes.wrap(Votes.unwrap(a) - Votes.unwrap(b));\n    }\n}\n\nfunction __eq(Votes a, Votes b) pure returns (bool) {\n    return Votes.unwrap(a) == Votes.unwrap(b);\n}\n\nfunction __lt(Votes a, Votes b) pure returns (bool) {\n    return Votes.unwrap(a) < Votes.unwrap(b);\n}\n\nfunction __gt(Votes a, Votes b) pure returns (bool) {\n    return Votes.unwrap(a) > Votes.unwrap(b);\n}\n\nfunction __ne(Votes a, Votes b) pure returns (bool) {\n    return Votes.unwrap(a) != Votes.unwrap(b);\n}\n\nfunction __le(Votes a, Votes b) pure returns (bool) {\n    return Votes.unwrap(a) <= Votes.unwrap(b);\n}\n\nfunction __ge(Votes a, Votes b) pure returns (bool) {\n    return Votes.unwrap(a) >= Votes.unwrap(b);\n}\n\nusing {\n    __add as +, __sub as -, __eq as ==, __lt as <, __gt as >, __ne as !=, __le as <=, __ge as >=\n} for Votes global;\n"}, "src/types/SharesXBasisPoints.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {BasisPoints, BASIS} from \"./BasisPoints.sol\";\nimport {Shares} from \"./Shares.sol\";\n\nimport {UnsafeMath} from \"../lib/UnsafeMath.sol\";\n\n/// This type is given as `uint256` for efficiency, but it is actually only 191 bits.\ntype SharesXBasisPoints is uint256;\n\nfunction scale(Shares s, BasisPoints bp) pure returns (SharesXBasisPoints) {\n    unchecked {\n        return SharesXBasisPoints.wrap(Shares.unwrap(s) * BasisPoints.unwrap(bp));\n    }\n}\n\nfunction cast(SharesXBasisPoints tbp) pure returns (Shares) {\n    return Shares.wrap(UnsafeMath.unsafeDiv(SharesXBasisPoints.unwrap(tbp), BasisPoints.unwrap(BASIS)));\n}\n\nfunction __add(SharesXBasisPoints a, SharesXBasisPoints b) pure returns (SharesXBasisPoints) {\n    unchecked {\n        return SharesXBasisPoints.wrap(SharesXBasisPoints.unwrap(a) + SharesXBasisPoints.unwrap(b));\n    }\n}\n\nfunction __sub(SharesXBasisPoints a, SharesXBasisPoints b) pure returns (SharesXBasisPoints) {\n    unchecked {\n        return SharesXBasisPoints.wrap(SharesXBasisPoints.unwrap(a) - SharesXBasisPoints.unwrap(b));\n    }\n}\n\nusing {__add as +, __sub as -} for SharesXBasisPoints global;\n"}, "src/types/CrazyBalance.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Settings} from \"../core/Settings.sol\";\n\nimport {Math} from \"../lib/Math.sol\";\n\nimport {Shares} from \"./Shares.sol\";\nimport {Tokens} from \"./Tokens.sol\";\nimport {tmp, SharesToTokens} from \"./TokensXShares.sol\";\n\ntype CrazyBalance is uint256;\n\nlibrary CrazyBalanceAccessors {\n    function toExternal(CrazyBalance x) internal pure returns (uint256) {\n        return CrazyBalance.unwrap(x);\n    }\n\n    function isMax(CrazyBalance x) internal pure returns (bool) {\n        return ~CrazyBalance.unwrap(x) == 0;\n    }\n}\n\nusing CrazyBalanceAccessors for CrazyBalance global;\n\nfunction toCrazyBalance(uint256 x) pure returns (CrazyBalance) {\n    return CrazyBalance.wrap(x);\n}\n\nCrazyBalance constant ZERO = CrazyBalance.wrap(0);\nCrazyBalance constant MAX = CrazyBalance.wrap(type(uint256).max);\n\nfunction __sub(CrazyBalance a, CrazyBalance b) pure returns (CrazyBalance) {\n    unchecked {\n        return CrazyBalance.wrap(CrazyBalance.unwrap(a) - CrazyBalance.unwrap(b));\n    }\n}\n\nfunction __eq(CrazyBalance a, CrazyBalance b) pure returns (bool) {\n    return CrazyBalance.unwrap(a) == CrazyBalance.unwrap(b);\n}\n\nfunction __lt(CrazyBalance a, CrazyBalance b) pure returns (bool) {\n    return CrazyBalance.unwrap(a) < CrazyBalance.unwrap(b);\n}\n\nfunction __gt(CrazyBalance a, CrazyBalance b) pure returns (bool) {\n    return CrazyBalance.unwrap(a) > CrazyBalance.unwrap(b);\n}\n\nfunction __ne(CrazyBalance a, CrazyBalance b) pure returns (bool) {\n    return CrazyBalance.unwrap(a) != CrazyBalance.unwrap(b);\n}\n\nfunction __le(CrazyBalance a, CrazyBalance b) pure returns (bool) {\n    return CrazyBalance.unwrap(a) <= CrazyBalance.unwrap(b);\n}\n\nfunction __ge(CrazyBalance a, CrazyBalance b) pure returns (bool) {\n    return CrazyBalance.unwrap(a) >= CrazyBalance.unwrap(b);\n}\n\nusing {__sub as -, __eq as ==, __lt as <, __gt as >, __ne as !=, __le as <=, __ge as >=} for CrazyBalance global;\n\nlibrary CrazyBalanceArithmetic {\n    using SharesToTokens for Shares;\n\n    function saturatingAdd(CrazyBalance x, CrazyBalance y) internal pure returns (CrazyBalance r) {\n        return CrazyBalance.wrap(Math.saturatingAdd(CrazyBalance.unwrap(x), CrazyBalance.unwrap(y)));\n    }\n\n    function saturatingSub(CrazyBalance x, CrazyBalance y) internal pure returns (CrazyBalance r) {\n        return CrazyBalance.wrap(Math.saturatingSub(CrazyBalance.unwrap(x), CrazyBalance.unwrap(y)));\n    }\n\n    function toCrazyBalance(Shares shares, address account, Tokens totalSupply, Shares totalShares)\n        internal\n        pure\n        returns (CrazyBalance)\n    {\n        // slither-disable-next-line divide-before-multiply\n        return CrazyBalance.wrap(\n            Tokens.unwrap(\n                tmp().omul(shares, totalSupply.mul(uint160(account) >> Settings.ADDRESS_SHIFT)).div(\n                    totalShares.mul(Settings.CRAZY_BALANCE_BASIS)\n                )\n            )\n        );\n    }\n\n    function toCrazyBalance(Tokens tokens, address account) internal pure returns (CrazyBalance) {\n        unchecked {\n            // slither-disable-next-line divide-before-multiply\n            return CrazyBalance.wrap(\n                Tokens.unwrap(tokens) * (uint160(account) >> Settings.ADDRESS_SHIFT) / Settings.CRAZY_BALANCE_BASIS\n            );\n        }\n    }\n\n    function toTokens(CrazyBalance balance, address account) internal pure returns (Tokens) {\n        unchecked {\n            // Checking for overflow in the multiplication is unnecessary. Checking for division by\n            // zero is required.\n            return Tokens.wrap(\n                CrazyBalance.unwrap(balance) * Settings.CRAZY_BALANCE_BASIS\n                    / (uint160(account) >> Settings.ADDRESS_SHIFT)\n            );\n        }\n    }\n\n    function toPairBalance(Tokens tokens) internal pure returns (CrazyBalance) {\n        return CrazyBalance.wrap(Tokens.unwrap(tokens) / Settings.CRAZY_BALANCE_BASIS);\n    }\n\n    function toPairBalance(Shares shares, Tokens totalSupply, Shares totalShares)\n        internal\n        pure\n        returns (CrazyBalance)\n    {\n        return CrazyBalance.wrap(\n            Tokens.unwrap(shares.toTokens(totalSupply, totalShares.mul(Settings.CRAZY_BALANCE_BASIS)))\n        );\n    }\n\n    function toPairTokens(CrazyBalance balance) internal pure returns (Tokens) {\n        unchecked {\n            return Tokens.wrap(CrazyBalance.unwrap(balance) * Settings.CRAZY_BALANCE_BASIS);\n        }\n    }\n}\n\nusing CrazyBalanceArithmetic for CrazyBalance global;\n"}, "src/lib/ChecksumAddress.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nlibrary ChecksumAddress {\n    /// Adapted from Solady https://github.com/Vectorized/solady/blob/1dd8967b93b379ca6cf384640e0715e55ef08e3d/src/utils/g/LibString.sol#L334\n    function toChecksumAddress(address addr) internal pure returns (string memory r) {\n        assembly (\"memory-safe\") {\n            r := mload(0x40)\n            mstore(0x40, add(0x60, r))\n            mstore(0x0f, 0x30313233343536373839616263646566) // \"0123456789abcdef\" lookup table\n\n            mstore(add(0x02, r), 0x3078) // \"0x\" prefix\n            mstore(r, 0x2a) // length\n\n            addr := shl(0x60, addr)\n            let o := add(0x22, r)\n            // Hexlify `addr` and write it into the output region. This is a do..while loop.\n            for { let i } true {} {\n                let p := add(o, add(i, i))\n                let temp := byte(i, addr)\n                // Split `temp` into nibbles and output the corresponding lookup table entries\n                mstore8(add(0x01, p), mload(and(0x0f, temp)))\n                mstore8(p, mload(shr(0x04, temp)))\n                i := add(0x01, i)\n                if eq(i, 0x14) { break }\n            }\n\n            // EIP-55 checksum is based on the keccak of the hexlified address. Hash it and extract\n            // the hash bits that (might) form the checksum.\n            let hash := and(0x8888888888888888888888888888888888888888000000000000000000000000, keccak256(o, 0x28))\n\n            // Again, in a do..while, space the nibble-spaced bits of the hash into byte-spaced and\n            // aligned as bit 6 of each byte\n            for { let i } true {} {\n                mstore(add(i, i), mul(0x88000000000000000000000000000000000000000000000000000000000000, byte(i, hash)))\n                i := add(0x01, i)\n                if eq(i, 0x14) { break }\n            }\n\n            let mask := 0x4040404040404040404040404040404040404040404040404040404040404040\n            // Extract bit 6 of each byte of the hexlified output (indicates that the character is\n            // a..f) and mask the hash with this. Shift those bits up to bit 7 (the case bit) and\n            // flip it to zero (uppercase) wherever the hash is set\n            mstore(o, xor(mload(o), shr(0x01, and(mload(0x00), and(mload(o), mask)))))\n            o := add(0x20, o)\n            // Do it again for the second word of the hexlified output\n            mstore(o, xor(mload(o), shr(0x01, and(mload(0x20), and(mload(o), mask)))))\n        }\n    }\n}\n"}, "src/lib/IPFS.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Panic} from \"./Panic.sol\";\n\nlibrary IPFS {\n    /// @return r SHA256(Protobuf({1: Protobuf({1: 2, 2: contentString, 3: contentString.length})}))\n    /// @param contentString File contents to be encoded and hashed\n    /// @dev if `contentString` is empty, field 2 is omitted, but field 3 is retained as zero\n    /// @dev if `contentString` is longer than 256kiB, it exceeds an IPFS chunk and cannot be handled by this function (reverts)\n    function dagPbUnixFsHash(string memory contentString) internal view returns (bytes32 r) {\n        unchecked {\n            uint256 contentLength = bytes(contentString).length;\n            if (contentLength >= 0x40001) {\n                Panic.panic(Panic.OUT_OF_MEMORY);\n            }\n            bytes memory len = _protobufVarint(contentLength);\n            bytes memory len2 = _protobufVarint(contentLength == 0 ? 4 : contentLength + 4 + 2 * len.length);\n            assembly (\"memory-safe\") {\n                let ptr := mload(0x40)\n                let dst := ptr\n                mstore8(ptr, 0x0a)\n                dst := add(dst, 0x01)\n                mcopy(dst, add(len2, 0x20), mload(len2))\n                dst := add(dst, mload(len2))\n                mstore(dst, hex\"080212\") // TODO: remove padding\n                switch contentLength\n                case 0 { dst := add(dst, 0x02) }\n                default {\n                    dst := add(dst, 0x03)\n                    mcopy(dst, add(len, 0x20), mload(len))\n                    dst := add(dst, mload(len))\n                    mcopy(dst, add(contentString, 0x20), contentLength)\n                    dst := add(dst, contentLength)\n                }\n                mstore8(dst, 0x18)\n                dst := add(dst, 0x01)\n                mcopy(dst, add(len, 0x20), mload(len))\n                dst := add(dst, mload(len))\n                if or(xor(returndatasize(), 0x20), iszero(staticcall(gas(), 0x02, ptr, sub(dst, ptr), ptr, 0x20))) {\n                    invalid()\n                }\n                r := mload(ptr)\n            }\n        }\n    }\n\n    /// @return r string.concat(\"ipfs://\", Base58(bytes.concat(hex\"1220\", h)))\n    /// @param h The SHA256 hash value to be encoded. Must be the output of `ipfsDagPbUnixFsHash`\n    // slither-disable-next-line naming-convention\n    function CIDv0(bytes32 h) internal pure returns (string memory r) {\n        assembly (\"memory-safe\") {\n            // we're going to take total control of the first 4 words of\n            // memory. we will restore the free memory pointer and the zero word\n            // at the end\n            r := mload(0x40)\n            let ptr := add(r, 0x54)\n\n            // store the base58 alphabet lookup table\n            mstore(0x19, 0x31323334353637383941424344454647484a4b4c4d4e50515253)\n            mstore(0x39, 0x5455565758595a6162636465666768696a6b6d6e6f707172737475767778797a)\n\n            // the first 3 iterations are special because we're actually encoding 34 bytes\n            mstore8(ptr, mload(mod(h, 0x3a)))\n            ptr := sub(ptr, 0x01)\n            h := add(0x04, div(h, 0x3a)) // 0x04 is the residue of prepending `hex\"1220\"`\n            mstore8(ptr, mload(mod(h, 0x3a)))\n            ptr := sub(ptr, 0x01)\n            h := add(0x28, div(h, 0x3a)) // 0x28 is the residue of prepending `hex\"1220\"`\n            mstore8(ptr, mload(mod(h, 0x3a)))\n            ptr := sub(ptr, 0x01)\n            h := div(h, 0x3a)\n            // this absurd constant prepends `hex\"1220\"` to `h`\n            h := add(h, 0x616868b6a3c45673102217be3fec84b7db78d8bb82965f94d9f33718a8074e3)\n\n            // the rest is \"normal\"\n            for { let end := sub(ptr, 0x2b) } gt(ptr, end) { ptr := sub(ptr, 0x01) } {\n                mstore8(ptr, mload(mod(h, 0x3a)))\n                h := div(h, 0x3a)\n            }\n\n            mstore(r, 0x00)\n            // length plus \"ipfs://\"\n            mstore(add(r, 0x07), 0x35697066733a2f2f)\n            mstore(0x40, add(r, 0x55))\n            mstore(0x60, 0x00)\n        }\n    }\n\n    function _protobufVarint(uint256 x) private pure returns (bytes memory r) {\n        if (x >= 0x200000) {\n            Panic.panic(Panic.ARITHMETIC_OVERFLOW);\n        }\n        assembly (\"memory-safe\") {\n            r := mload(0x40)\n            let length := 0x01\n            mstore8(add(r, 0x20), or(0x80, and(0x7f, x)))\n            x := shr(0x07, x)\n            if x {\n                mstore8(add(r, 0x21), or(0x80, and(0x7f, x)))\n                x := shr(0x07, x)\n                switch x\n                case 0 { length := 0x02 }\n                default {\n                    mstore8(add(r, 0x22), and(0x7f, x))\n                    length := 0x03\n                }\n            }\n\n            mstore(r, length)\n            let last := add(r, length)\n            mstore(last, and(0xffffff7f, mload(last)))\n            mstore(0x40, add(last, 0x20))\n        }\n    }\n}\n"}, "src/lib/ItoA.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nlibrary ItoA {\n    function itoa(uint256 x) internal pure returns (string memory r) {\n        assembly (\"memory-safe\") {\n            mstore(9, 0x30313233343536373839) // lookup table [0..9]\n\n            // we over-allocate memory here because that's cheaper than\n            // computing the correct length and allocating exactly that much\n            let end := add(mload(0x40), 0x6e)\n            mstore(0x40, end)\n\n            for {\n                r := sub(end, 0x01)\n                mstore8(r, mload(mod(x, 0x0a)))\n                x := div(x, 0x0a)\n            } x {} {\n                r := sub(r, 0x01)\n                mstore8(r, mload(mod(x, 0x0a)))\n                x := div(x, 0x0a)\n            }\n            let length := sub(end, r)\n            r := sub(r, 0x20)\n            mstore(r, length)\n        }\n    }\n\n    function itoa(int256 value) internal pure returns (string memory) {\n        if (value < 0) {\n            return string.concat(\"-\", itoa(uint256(-value)));\n        } else {\n            return itoa(uint256(value));\n        }\n    }\n}\n"}, "src/lib/FastTransferLib.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"@forge-std/interfaces/IERC20.sol\";\n\nlibrary FastTransferLib {\n    function fastSendEth(address payable to, uint256 value) internal {\n        assembly (\"memory-safe\") {\n            if iszero(call(gas(), to, value, 0x00, 0x00, 0x00, 0x00)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0x00, returndatasize())\n                revert(ptr, returndatasize())\n            }\n        }\n    }\n\n    function fastBalanceOf(IERC20 token, address acct) internal view returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            mstore(0x14, acct) // Store the `acct` argument.\n            mstore(0x00, 0x70a08231000000000000000000000000) // Selector for `balanceOf(address)`, with `acct`'s padding.\n\n            // Call and check for revert. Storing the selector with padding in memory at 0 results\n            // in a start of calldata at offset 16. Calldata is 36 bytes long (4 bytes selector, 32\n            // bytes argument).\n            if iszero(staticcall(gas(), token, 0x10, 0x24, 0x00, 0x20)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0x00, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            // We assume that `token`'s code exists and that it conforms to ERC20 (won't return\n            // short calldata). We do not bother to check for either of these conditions.\n\n            r := mload(0x00)\n        }\n    }\n\n    function fastTransfer(IERC20 token, address to, uint256 amount) internal {\n        assembly (\"memory-safe\") {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            // Storing `amount` clobbers the upper bits of the free memory pointer, but those bits\n            // can never be set without running into an OOG, so it's safe. We'll restore them to\n            // zero at the end.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // Selector for `transfer(address,uint256)`, with `to`'s padding.\n\n            // Calldata starts at offset 16 and is 68 bytes long (2 * 32 + 4). We're not checking\n            // the return value, so we don't bother to copy the returndata into memory.\n            if iszero(call(gas(), token, 0x00, 0x10, 0x44, 0x00, 0x00)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0x00, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            // We assume that the token we're calling is well-behaved. We don't check that it\n            // might've returned `false`.\n\n            mstore(0x34, 0x00) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    function fastTotalSupply(IERC20 token) internal view returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x18160ddd) // selector for `totalSupply()`\n\n            // Call and check for revert. Storing the misaligned selector in memory at 0 results in\n            // a start of calldata at offset 28. Calldata is 4 bytes long.\n            if iszero(staticcall(gas(), token, 0x1c, 0x04, 0x00, 0x20)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0x00, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            // We assume that `token`'s code exists and that it conforms to ERC20 (won't return\n            // short calldata). We do not bother to check for either of these conditions.\n\n            r := mload(0x00)\n        }\n    }\n}\n"}, "src/lib/UnsafeMath.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nlibrary UnsafeMath {\n    function unsafeInc(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return x + 1;\n        }\n    }\n\n    function unsafeInc(uint256 x, bool b) internal pure returns (uint256) {\n        assembly (\"memory-safe\") {\n            x := add(x, b)\n        }\n        return x;\n    }\n\n    function unsafeInc(int256 x) internal pure returns (int256) {\n        unchecked {\n            return x + 1;\n        }\n    }\n\n    function unsafeInc(int256 x, bool b) internal pure returns (int256) {\n        assembly (\"memory-safe\") {\n            x := add(x, b)\n        }\n        return x;\n    }\n\n    function unsafeDec(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return x - 1;\n        }\n    }\n\n    function unsafeDec(uint256 x, bool b) internal pure returns (uint256) {\n        assembly (\"memory-safe\") {\n            x := sub(x, b)\n        }\n        return x;\n    }\n\n    function unsafeDec(int256 x) internal pure returns (int256) {\n        unchecked {\n            return x - 1;\n        }\n    }\n\n    function unsafeDec(int256 x, bool b) internal pure returns (int256) {\n        assembly (\"memory-safe\") {\n            x := sub(x, b)\n        }\n        return x;\n    }\n\n    function unsafeNeg(int256 x) internal pure returns (int256) {\n        unchecked {\n            return -x;\n        }\n    }\n\n    function unsafeDiv(uint256 numerator, uint256 denominator) internal pure returns (uint256 quotient) {\n        assembly (\"memory-safe\") {\n            quotient := div(numerator, denominator)\n        }\n    }\n\n    function unsafeDiv(int256 numerator, int256 denominator) internal pure returns (int256 quotient) {\n        assembly (\"memory-safe\") {\n            quotient := sdiv(numerator, denominator)\n        }\n    }\n\n    function unsafeMod(uint256 numerator, uint256 denominator) internal pure returns (uint256 remainder) {\n        assembly (\"memory-safe\") {\n            remainder := mod(numerator, denominator)\n        }\n    }\n\n    function unsafeMod(int256 numerator, int256 denominator) internal pure returns (int256 remainder) {\n        assembly (\"memory-safe\") {\n            remainder := smod(numerator, denominator)\n        }\n    }\n\n    function unsafeMulMod(uint256 a, uint256 b, uint256 m) internal pure returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            r := mulmod(a, b, m)\n        }\n    }\n\n    function unsafeAddMod(uint256 a, uint256 b, uint256 m) internal pure returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            r := addmod(a, b, m)\n        }\n    }\n\n    function unsafeDivUp(uint256 n, uint256 d) internal pure returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            r := add(gt(mod(n, d), 0x00), div(n, d))\n        }\n    }\n}\n"}, "src/lib/FastLogic.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nlibrary FastLogic {\n    function or(bool a, bool b) internal pure returns (bool r) {\n        assembly (\"memory-safe\") {\n            r := or(a, b)\n        }\n    }\n\n    function and(bool a, bool b) internal pure returns (bool r) {\n        assembly (\"memory-safe\") {\n            r := and(a, b)\n        }\n    }\n}\n"}, "src/interfaces/IERC2612.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"@forge-std/interfaces/IERC20.sol\";\nimport {INonces} from \"./INonces.sol\";\n\ninterface IERC2612 is IERC20, INonces {\n    /// @notice Approves `spender` to spend `value` tokens on behalf of `owner` via an off-chain\n    /// signature.\n    /// @param owner The holder of the tokens and the signer of the EIP-712 object. Must not be the\n    /// zero address.\n    /// @param spender The account for which to create the allowance. `permit` causes `spender` to\n    /// be able to move `owner`'s tokens.\n    /// @param value The token amount of the allowance to be created.\n    /// @param deadline The current blocktime must be less than or equal to `deadline`.\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external;\n\n    /// @notice Returns the EIP-712 domain separator used for signature verification.\n    // slither-disable-next-line naming-convention\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"}, "src/interfaces/IERC5267.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IERC5267 {\n    /// @notice Returns the un-hashed fields that comprise the EIP-712 domain.\n    /// @return fields A bitmask indicating which domain fields are used.\n    /// @return name The human-readable name of the domain.\n    /// @return chainId The chain ID of the network.\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32,\n            uint256[] memory\n        );\n}\n"}, "src/FUStorage.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"@forge-std/interfaces/IERC20.sol\";\nimport {INonces} from \"./interfaces/INonces.sol\";\nimport {IERC5805} from \"./interfaces/IERC5805.sol\";\n\nimport {Tokens} from \"./types/Tokens.sol\";\nimport {Shares, SharesStorage} from \"./types/Shares.sol\";\nimport {CrazyBalance} from \"./types/CrazyBalance.sol\";\n\nimport {Checkpoints} from \"./core/Checkpoints.sol\";\nimport {RebaseQueue} from \"./core/RebaseQueue.sol\";\n\nabstract contract FUStorage is IERC20, INonces, IERC5805 {\n    struct Storage {\n        Tokens totalSupply;\n        Tokens pairTokens;\n        Shares totalShares;\n        RebaseQueue rebaseQueue;\n        Checkpoints checkpoints;\n        mapping(address account => SharesStorage shares) sharesOf;\n        mapping(address owner => mapping(address spender => CrazyBalance allowed)) allowance;\n        mapping(address account => address delegatee) delegates;\n        mapping(address account => uint256 nonce) nonces;\n    }\n\n    /// @inheritdoc IERC5805\n    function delegates(address account) external view override returns (address delegatee) {\n        return _$().delegates[account];\n    }\n\n    /// @inheritdoc INonces\n    function nonces(address account) external view override returns (uint256 nonce) {\n        return _$().nonces[account];\n    }\n\n    /// @inheritdoc IERC20\n    string public constant override name = \"Fuck You!\";\n\n    constructor() {\n        Storage storage $ = _$();\n        uint256 $int;\n        assembly (\"memory-safe\") {\n            $int := $.slot\n        }\n        assert($int == uint128(uint256(keccak256(bytes(name))) - 1) & ~uint256(0xff));\n    }\n\n    // slither-disable-next-line naming-convention\n    function _$() internal pure returns (Storage storage $) {\n        assembly (\"memory-safe\") {\n            $.slot := 0xe086ec3a639808bbda893d5b4ac93600\n        }\n    }\n}\n"}, "src/utils/Context.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nabstract contract AbstractContext {\n    function _msgSender() internal view virtual returns (address);\n\n    function _msgData() internal view virtual returns (bytes calldata);\n\n    function _isForwarded() internal view virtual returns (bool);\n}\n\nabstract contract Context is AbstractContext {\n    function _msgSender() internal view virtual override returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _isForwarded() internal view virtual override returns (bool) {\n        return false;\n    }\n}\n"}, "src/interfaces/IERC6093.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IERC6093 {\n    /// @notice Indicates an error related to the current `balance` of a `sender`.\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /// @notice Indicates a failure with the token `sender`.\n    error ERC20InvalidSender(address sender);\n\n    /// @notice Indicates a failure with the token `receiver`.\n    error ERC20InvalidReceiver(address receiver);\n\n    /// @notice Indicates a failure with the `spender`\u2019s `allowance`.\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /// @notice Indicates a failure with the `approver` of a token to be approved.\n    error ERC20InvalidApprover(address approver);\n\n    /// @notice Indicates that the `deadline` of the `permit` has passed.\n    error ERC2612ExpiredSignature(uint256 deadline);\n\n    /// @notice Indicates a mismatch between the `owner` of a permit and the signer of the EIP-712\n    /// object.\n    error ERC2612InvalidSigner(address signer, address owner);\n\n    /// @notice Indicates that the `expiry` of the `delegateBySig` has passed.\n    error ERC5805ExpiredSignature(uint256 expiry);\n\n    /// @notice Indicates that the signature of the `delegateBySig` is malformed.\n    error ERC5805InvalidSignature();\n\n    /// @notice Indicates that the current `nonces(...)` of the signer does not match the given\n    /// `nonce` value.\n    error ERC5805InvalidNonce(uint256 actual, uint256 expected);\n\n    /// @notice Indicates that the queried `timepoint` is equal to or greater than the current value\n    /// `clock`.\n    error ERC5805TimepointNotPast(uint256 timepoint, uint256 clock);\n}\n"}, "src/interfaces/INonces.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface INonces {\n    /// @notice Returns the current nonce for `account` to be used for off-chain signatures.\n    function nonces(address account) external view returns (uint256 nonce);\n}\n"}, "src/types/TokensXBasisPoints.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {BasisPoints, BASIS} from \"./BasisPoints.sol\";\nimport {Tokens} from \"./Tokens.sol\";\n\nimport {Math} from \"../lib/Math.sol\";\nimport {UnsafeMath} from \"../lib/UnsafeMath.sol\";\n\n/// This type is given as `uint256` for efficiency, but it is actually only 159 bits.\ntype TokensXBasisPoints is uint256;\n\nlibrary TokensXBasisPointsArithmetic {\n    function saturatingAdd(TokensXBasisPoints x, TokensXBasisPoints y) internal pure returns (TokensXBasisPoints r) {\n        return TokensXBasisPoints.wrap(Math.saturatingAdd(TokensXBasisPoints.unwrap(x), TokensXBasisPoints.unwrap(y)));\n    }\n\n    function saturatingSub(TokensXBasisPoints x, TokensXBasisPoints y) internal pure returns (TokensXBasisPoints r) {\n        return TokensXBasisPoints.wrap(Math.saturatingSub(TokensXBasisPoints.unwrap(x), TokensXBasisPoints.unwrap(y)));\n    }\n}\n\nusing TokensXBasisPointsArithmetic for TokensXBasisPoints global;\n\nfunction scale(Tokens s, BasisPoints bp) pure returns (TokensXBasisPoints) {\n    unchecked {\n        return TokensXBasisPoints.wrap(Tokens.unwrap(s) * BasisPoints.unwrap(bp));\n    }\n}\n\nfunction cast(TokensXBasisPoints tbp) pure returns (Tokens) {\n    return Tokens.wrap(UnsafeMath.unsafeDiv(TokensXBasisPoints.unwrap(tbp), BasisPoints.unwrap(BASIS)));\n}\n\nfunction castUp(TokensXBasisPoints tbp) pure returns (Tokens) {\n    return Tokens.wrap(UnsafeMath.unsafeDivUp(TokensXBasisPoints.unwrap(tbp), BasisPoints.unwrap(BASIS)));\n}\n\nfunction __sub(TokensXBasisPoints a, TokensXBasisPoints b) pure returns (TokensXBasisPoints) {\n    unchecked {\n        return TokensXBasisPoints.wrap(TokensXBasisPoints.unwrap(a) - TokensXBasisPoints.unwrap(b));\n    }\n}\n\nfunction __eq(TokensXBasisPoints a, TokensXBasisPoints b) pure returns (bool) {\n    return TokensXBasisPoints.unwrap(a) == TokensXBasisPoints.unwrap(b);\n}\n\nfunction __lt(TokensXBasisPoints a, TokensXBasisPoints b) pure returns (bool) {\n    return TokensXBasisPoints.unwrap(a) < TokensXBasisPoints.unwrap(b);\n}\n\nfunction __gt(TokensXBasisPoints a, TokensXBasisPoints b) pure returns (bool) {\n    return TokensXBasisPoints.unwrap(a) > TokensXBasisPoints.unwrap(b);\n}\n\nfunction __ne(TokensXBasisPoints a, TokensXBasisPoints b) pure returns (bool) {\n    return TokensXBasisPoints.unwrap(a) != TokensXBasisPoints.unwrap(b);\n}\n\nfunction __le(TokensXBasisPoints a, TokensXBasisPoints b) pure returns (bool) {\n    return TokensXBasisPoints.unwrap(a) <= TokensXBasisPoints.unwrap(b);\n}\n\nfunction __ge(TokensXBasisPoints a, TokensXBasisPoints b) pure returns (bool) {\n    return TokensXBasisPoints.unwrap(a) >= TokensXBasisPoints.unwrap(b);\n}\n\nusing {\n    __sub as -, __eq as ==, __lt as <, __gt as >, __ne as !=, __le as <=, __ge as >=\n} for TokensXBasisPoints global;\n"}, "src/types/TokensXShares2.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Shares} from \"./Shares.sol\";\nimport {TokensXShares, cast} from \"./TokensXShares.sol\";\n\nimport {uint512} from \"../lib/512Math.sol\";\n\ntype TokensXShares2 is bytes32;\n\nfunction cast(TokensXShares2 x) pure returns (uint512) {\n    return uint512.wrap(TokensXShares2.unwrap(x));\n}\n\nfunction cast2(uint512 x) pure returns (TokensXShares2) {\n    return TokensXShares2.wrap(uint512.unwrap(x));\n}\n\nlibrary TokensXShares2Arithmetic {\n    function div(TokensXShares2 n, TokensXShares d) internal pure returns (Shares) {\n        return Shares.wrap(cast(n).div(cast(d)));\n    }\n}\n\nusing TokensXShares2Arithmetic for TokensXShares2 global;\n\nfunction __eq(TokensXShares2 a, TokensXShares2 b) pure returns (bool) {\n    return cast(a) == cast(b);\n}\n\nfunction __lt(TokensXShares2 a, TokensXShares2 b) pure returns (bool) {\n    return cast(a) < cast(b);\n}\n\nfunction __gt(TokensXShares2 a, TokensXShares2 b) pure returns (bool) {\n    return cast(a) > cast(b);\n}\n\nfunction __ne(TokensXShares2 a, TokensXShares2 b) pure returns (bool) {\n    return cast(a) != cast(b);\n}\n\nfunction __le(TokensXShares2 a, TokensXShares2 b) pure returns (bool) {\n    return cast(a) <= cast(b);\n}\n\nfunction __ge(TokensXShares2 a, TokensXShares2 b) pure returns (bool) {\n    return cast(a) >= cast(b);\n}\n\nusing {__eq as ==, __lt as <, __gt as >, __ne as !=, __le as <=, __ge as >=} for TokensXShares2 global;\n"}, "src/types/TokensXBasisPointsXShares2.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Shares} from \"./Shares.sol\";\nimport {TokensXBasisPointsXShares, cast as cast1} from \"./TokensXBasisPointsXShares.sol\";\n\nimport {uint512} from \"../lib/512Math.sol\";\n\ntype TokensXBasisPointsXShares2 is bytes32;\n\nfunction cast(TokensXBasisPointsXShares2 x) pure returns (uint512) {\n    return uint512.wrap(TokensXBasisPointsXShares2.unwrap(x));\n}\n\nfunction cast(uint512 x) pure returns (TokensXBasisPointsXShares2) {\n    return TokensXBasisPointsXShares2.wrap(uint512.unwrap(x));\n}\n\nlibrary TokensXBasisPointsXShares2Arithmetic {\n    function div(TokensXBasisPointsXShares2 n, TokensXBasisPointsXShares d) internal pure returns (Shares) {\n        return Shares.wrap(cast(n).div(cast1(d)));\n    }\n}\n\nusing TokensXBasisPointsXShares2Arithmetic for TokensXBasisPointsXShares2 global;\n"}, "src/types/Shares2XBasisPoints.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Shares} from \"./Shares.sol\";\nimport {SharesXBasisPoints} from \"./SharesXBasisPoints.sol\";\n\nimport {uint512, alloc as baseAlloc} from \"../lib/512Math.sol\";\n\ntype Shares2XBasisPoints is bytes32;\n\nfunction cast(Shares2XBasisPoints x) pure returns (uint512) {\n    return uint512.wrap(Shares2XBasisPoints.unwrap(x));\n}\n\nfunction cast(uint512 x) pure returns (Shares2XBasisPoints) {\n    return Shares2XBasisPoints.wrap(uint512.unwrap(x));\n}\n\nfunction alloc() pure returns (Shares2XBasisPoints) {\n    return cast(baseAlloc());\n}\n\nlibrary Shares2XBasisPointsArithmetic {\n    function omul(Shares2XBasisPoints r, SharesXBasisPoints sbp, Shares s)\n        internal\n        pure\n        returns (Shares2XBasisPoints)\n    {\n        return cast(cast(r).omul(SharesXBasisPoints.unwrap(sbp), Shares.unwrap(s)));\n    }\n\n    function omul(Shares2XBasisPoints r, Shares s, SharesXBasisPoints sbp)\n        internal\n        pure\n        returns (Shares2XBasisPoints)\n    {\n        return cast(cast(r).omul(Shares.unwrap(s), SharesXBasisPoints.unwrap(sbp)));\n    }\n\n    function div(Shares2XBasisPoints n, SharesXBasisPoints d) internal pure returns (Shares) {\n        return Shares.wrap(cast(n).div(SharesXBasisPoints.unwrap(d)));\n    }\n\n    function div(Shares2XBasisPoints n, Shares d) internal pure returns (SharesXBasisPoints) {\n        return SharesXBasisPoints.wrap(cast(n).div(Shares.unwrap(d)));\n    }\n}\n\nusing Shares2XBasisPointsArithmetic for Shares2XBasisPoints global;\n\nfunction __eq(Shares2XBasisPoints a, Shares2XBasisPoints b) pure returns (bool) {\n    return cast(a) == cast(b);\n}\n\nfunction __lt(Shares2XBasisPoints a, Shares2XBasisPoints b) pure returns (bool) {\n    return cast(a) < cast(b);\n}\n\nfunction __gt(Shares2XBasisPoints a, Shares2XBasisPoints b) pure returns (bool) {\n    return cast(a) > cast(b);\n}\n\nfunction __ne(Shares2XBasisPoints a, Shares2XBasisPoints b) pure returns (bool) {\n    return cast(a) != cast(b);\n}\n\nfunction __le(Shares2XBasisPoints a, Shares2XBasisPoints b) pure returns (bool) {\n    return cast(a) <= cast(b);\n}\n\nfunction __ge(Shares2XBasisPoints a, Shares2XBasisPoints b) pure returns (bool) {\n    return cast(a) >= cast(b);\n}\n\nusing {__eq as ==, __lt as <, __gt as >, __ne as !=, __le as <=, __ge as >=} for Shares2XBasisPoints global;\n"}, "src/lib/Ternary.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nlibrary Ternary {\n    function ternary(bool c, uint256 x, uint256 y) internal pure returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            r := xor(y, mul(xor(x, y), c))\n        }\n    }\n\n    function ternary(bool c, int256 x, int256 y) internal pure returns (int256 r) {\n        assembly (\"memory-safe\") {\n            r := xor(y, mul(xor(x, y), c))\n        }\n    }\n\n    function maybeSwap(bool c, uint256 x, uint256 y) internal pure returns (uint256 a, uint256 b) {\n        assembly (\"memory-safe\") {\n            let t := mul(xor(x, y), c)\n            a := xor(x, t)\n            b := xor(y, t)\n        }\n    }\n}\n"}, "src/lib/512Math.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Panic} from \"./Panic.sol\";\nimport {UnsafeMath} from \"./UnsafeMath.sol\";\n\n/*\n\nWARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING\n  ***                                                                     ***\nWARNING                     This code is unaudited                      WARNING\n  ***                                                                     ***\nWARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING\n\n*/\n\n/// The type uint512 behaves as if it were declared as\n///     struct uint512 {\n///         uint256 hi;\n///         uint256 lo;\n///     }\n/// However, returning `memory` references from internal functions is impossible\n/// to do efficiently, especially when the functions are small and are called\n/// frequently. Therefore, we assume direct control over memory allocation using\n/// the functions `tmp()` and `alloc()` defined below. If you need to pass\n/// 512-bit integers between contracts (generally a bad idea), the struct\n/// `uint512_external` defined at the end of this file is provided for this\n/// purpose and has exactly the definition you'd expect (as well as convenient\n/// conversion functions).\n///\n/// MAKING A DECLARATION OF THE FOLLOWING FORM WILL CAUSE UNEXPECTED BEHAVIOR:\n///     uint512 x;\n/// INSTEAD OF DOING THAT, YOU MUST USE `alloc()`, LIKE THIS:\n///     uint512 x = alloc();\n/// IF YOU REALLY WANTED TO DO THAT (ADVANCED USAGE) THEN FOR CLARITY, WRITE THE\n/// FOLLOWING:\n///     uint512 x = tmp();\n///\n/// While user-defined arithmetic operations (i.e. +, -, *, %, /) are provided\n/// for `uint512`, they are not gas-optimal, full-featured, or composable. You\n/// will get a revert upon incorrect usage. Their primary usage is when a simple\n/// arithmetic operation needs to be performed followed by a comparison (e.g. <,\n/// >, ==, etc.) or conversion to a pair of `uint256`s (i.e. `.into()`). The use\n/// of the user-defined arithmetic operations is not composable with the usage\n/// of `tmp()`.\n///\n/// In general, correct usage of `uint512` requires always specifying the output\n/// location of each operation. For each `o*` operation (mnemonic:\n/// out-of-place), the first argument is the output location and the remaining\n/// arguments are the input. For each `i*` operation (mnemonic: in-place), the\n/// first argument is both input and output and the remaining arguments are\n/// purely input. For each `ir*` operation (mnemonic: in-place reverse; only for\n/// non-commutative operations), the semantics of the input arguments are\n/// flipped (i.e. `irsub(foo, bar)` is semantically equivalent to `foo = bar -\n/// foo`); the first argument is still the output location. Only `irsub`,\n/// `irmod`, `irdiv`, `irmod`, and `irdiv` exist. Unless otherwise noted, the\n/// return value of each function is the output location. This supports\n/// chaining/pipeline/tacit-style programming.\n///\n/// All provided arithmetic operations behave as if they were inside an\n/// `unchecked` block. We assume that because you're reaching for 512-bit math,\n/// you have domain knowledge about the range of values that you will\n/// encounter. Overflow causes truncation, not a revert. Division or modulo by\n/// zero still causes a panic revert with code 18 (identical behavior to\n/// \"normal\" unchecked arithmetic).\n///\n/// Three additional arithmetic operations are provided, bare `sub`, `mod`, and\n/// `div`. These are provided for use when it is known that the result of the\n/// operation will fit into 256 bits. This fact is not checked, but more\n/// efficient algorithms are employed assuming this. The result is a `uint256`.\n///\n/// ## Full list of provided functions\n///\n/// Unless otherwise noted, all functions return `(uint512)`\n///\n/// ### Utility\n///\n/// * from(uint256)\n/// * from(uint256,uint256) -- The EVM is big-endian. The most-significant word is first.\n/// * from(uint512) -- performs a copy\n/// * into() returns (uint256,uint256) -- Again, the most-significant word is first.\n/// * toExternal(uint512) returns (uint512_external memory)\n///\n/// ### Comparison (all functions return `(bool)`)\n///\n/// * isZero(uint512)\n/// * isMax(uint512)\n/// * eq(uint512,uint256)\n/// * eq(uint512,uint512)\n/// * ne(uint512,uint256)\n/// * ne(uint512,uint512)\n/// * gt(uint512,uint256)\n/// * gt(uint512,uint512)\n/// * ge(uint512,uint256)\n/// * ge(uint512,uint512)\n/// * lt(uint512,uint256)\n/// * lt(uint512,uint512)\n/// * le(uint512,uint256)\n/// * le(uint512,uint512)\n///\n/// ### Addition\n///\n/// * oadd(uint512,uint256,uint256) -- iadd(uint256,uint256) is not provided for somewhat obvious reasons\n/// * oadd(uint512,uint512,uint256)\n/// * iadd(uint512,uint256)\n/// * oadd(uint512,uint512,uint512)\n/// * iadd(uint512,uint512)\n///\n/// ### Subtraction\n///\n/// * sub(uint512,uint256) returns (uint256)\n/// * sub(uint512,uint512) returns (uint256)\n/// * osub(uint512,uint512,uint256)\n/// * isub(uint512,uint256)\n/// * osub(uint512,uint512,uint512)\n/// * isub(uint512,uint512)\n/// * irsub(uint512,uint512)\n///\n/// ### Multiplication\n///\n/// * omul(uint512,uint256,uint256)\n/// * omul(uint512,uint512,uint256)\n/// * imul(uint512,uint256)\n/// * omul(uint512,uint512,uint512)\n/// * imul(uint512,uint512)\n///\n/// ### Modulo\n///\n/// * mod(uint512,uint256) returns (uint256) -- mod(uint512,uint512) is not provided for less obvious reasons\n/// * omod(uint512,uint512,uint512)\n/// * imod(uint512,uint512)\n/// * irmod(uint512,uint512)\n///\n/// ### Division\n///\n/// * div(uint512,uint256) returns (uint256)\n/// * div(uint512,uint512) returns (uint256)\n/// * odiv(uint512,uint512,uint256)\n/// * idiv(uint512,uint256)\n/// * odiv(uint512,uint512,uint512)\n/// * idiv(uint512,uint512)\n/// * irdiv(uint512,uint512)\n///\n/// ### Multi-division\n///\n/// * divMulti(uint512,uint512,uint256) returns (uint256,uint256) -- the last argument is the denominator\n///\n/// The implementation of other variants of multi-division is left as an\n/// exercise for the reader.\ntype uint512 is bytes32;\n\nfunction alloc() pure returns (uint512 r) {\n    assembly (\"memory-safe\") {\n        r := mload(0x40)\n        mstore(0x40, add(0x40, r))\n    }\n}\n\nfunction tmp() pure returns (uint512 r) {}\n\nlibrary Lib512MathAccessors {\n    function from(uint512 r, uint256 x) internal pure returns (uint512 r_out) {\n        assembly (\"memory-safe\") {\n            mstore(r, 0x00)\n            mstore(add(0x20, r), x)\n            r_out := r\n        }\n    }\n\n    // slither-disable-next-line naming-convention\n    function from(uint512 r, uint256 x_hi, uint256 x_lo) internal pure returns (uint512 r_out) {\n        assembly (\"memory-safe\") {\n            mstore(r, x_hi)\n            mstore(add(0x20, r), x_lo)\n            r_out := r\n        }\n    }\n\n    function from(uint512 r, uint512 x) internal pure returns (uint512 r_out) {\n        assembly (\"memory-safe\") {\n            // Paradoxically, using `mload` and `mstore` here (instead of\n            // `mcopy`) produces more optimal code because it gives solc the\n            // opportunity to optimize-out the use of memory entirely, in\n            // typical usage. As a happy side effect, it also means that we\n            // don't have to deal with Cancun hardfork compatibility issues.\n            mstore(r, mload(x))\n            mstore(add(0x20, r), mload(add(0x20, x)))\n            r_out := r\n        }\n    }\n\n    function into(uint512 x) internal pure returns (uint256 r_hi, uint256 r_lo) {\n        assembly (\"memory-safe\") {\n            r_hi := mload(x)\n            r_lo := mload(add(0x20, x))\n        }\n    }\n}\n\nusing Lib512MathAccessors for uint512 global;\n\nlibrary Lib512MathComparisons {\n    function isZero(uint512 x) internal pure returns (bool r) {\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        assembly (\"memory-safe\") {\n            r := iszero(or(x_hi, x_lo))\n        }\n    }\n\n    function isMax(uint512 x) internal pure returns (bool r) {\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        assembly (\"memory-safe\") {\n            r := iszero(not(and(x_hi, x_lo)))\n        }\n    }\n\n    function eq(uint512 x, uint256 y) internal pure returns (bool r) {\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        assembly (\"memory-safe\") {\n            r := and(iszero(x_hi), eq(x_lo, y))\n        }\n    }\n\n    function gt(uint512 x, uint256 y) internal pure returns (bool r) {\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        assembly (\"memory-safe\") {\n            r := or(gt(x_hi, 0x00), gt(x_lo, y))\n        }\n    }\n\n    function lt(uint512 x, uint256 y) internal pure returns (bool r) {\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        assembly (\"memory-safe\") {\n            r := and(iszero(x_hi), lt(x_lo, y))\n        }\n    }\n\n    function ne(uint512 x, uint256 y) internal pure returns (bool) {\n        return !eq(x, y);\n    }\n\n    function ge(uint512 x, uint256 y) internal pure returns (bool) {\n        return !lt(x, y);\n    }\n\n    function le(uint512 x, uint256 y) internal pure returns (bool) {\n        return !gt(x, y);\n    }\n\n    function eq(uint512 x, uint512 y) internal pure returns (bool r) {\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        (uint256 y_hi, uint256 y_lo) = y.into();\n        assembly (\"memory-safe\") {\n            r := and(eq(x_hi, y_hi), eq(x_lo, y_lo))\n        }\n    }\n\n    function gt(uint512 x, uint512 y) internal pure returns (bool r) {\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        (uint256 y_hi, uint256 y_lo) = y.into();\n        assembly (\"memory-safe\") {\n            r := or(gt(x_hi, y_hi), and(eq(x_hi, y_hi), gt(x_lo, y_lo)))\n        }\n    }\n\n    function lt(uint512 x, uint512 y) internal pure returns (bool r) {\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        (uint256 y_hi, uint256 y_lo) = y.into();\n        assembly (\"memory-safe\") {\n            r := or(lt(x_hi, y_hi), and(eq(x_hi, y_hi), lt(x_lo, y_lo)))\n        }\n    }\n\n    function ne(uint512 x, uint512 y) internal pure returns (bool) {\n        return !eq(x, y);\n    }\n\n    function ge(uint512 x, uint512 y) internal pure returns (bool) {\n        return !lt(x, y);\n    }\n\n    function le(uint512 x, uint512 y) internal pure returns (bool) {\n        return !gt(x, y);\n    }\n}\n\nusing Lib512MathComparisons for uint512 global;\n\nfunction __eq(uint512 x, uint512 y) pure returns (bool) {\n    return x.eq(y);\n}\n\nfunction __gt(uint512 x, uint512 y) pure returns (bool) {\n    return x.gt(y);\n}\n\nfunction __lt(uint512 x, uint512 y) pure returns (bool r) {\n    return x.lt(y);\n}\n\nfunction __ne(uint512 x, uint512 y) pure returns (bool) {\n    return x.ne(y);\n}\n\nfunction __ge(uint512 x, uint512 y) pure returns (bool) {\n    return x.ge(y);\n}\n\nfunction __le(uint512 x, uint512 y) pure returns (bool) {\n    return x.le(y);\n}\n\nusing {__eq as ==, __gt as >, __lt as <, __ne as !=, __ge as >=, __le as <=} for uint512 global;\n\nlibrary Lib512MathArithmetic {\n    using UnsafeMath for uint256;\n\n    function oadd(uint512 r, uint256 x, uint256 y) internal pure returns (uint512) {\n        uint256 r_hi;\n        uint256 r_lo;\n        assembly (\"memory-safe\") {\n            r_lo := add(x, y)\n            // `lt(r_lo, x)` indicates overflow in the lower addition. We can\n            // add the bool directly to the integer to perform carry\n            r_hi := lt(r_lo, x)\n        }\n        return r.from(r_hi, r_lo);\n    }\n\n    function oadd(uint512 r, uint512 x, uint256 y) internal pure returns (uint512) {\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        uint256 r_hi;\n        uint256 r_lo;\n        assembly (\"memory-safe\") {\n            r_lo := add(x_lo, y)\n            // `lt(r_lo, x_lo)` indicates overflow in the lower\n            // addition. Overflow in the high limb is simply ignored\n            r_hi := add(x_hi, lt(r_lo, x_lo))\n        }\n        return r.from(r_hi, r_lo);\n    }\n\n    function iadd(uint512 r, uint256 y) internal pure returns (uint512) {\n        return oadd(r, r, y);\n    }\n\n    function _add(uint256 x_hi, uint256 x_lo, uint256 y_hi, uint256 y_lo)\n        private\n        pure\n        returns (uint256 r_hi, uint256 r_lo)\n    {\n        assembly (\"memory-safe\") {\n            r_lo := add(x_lo, y_lo)\n            // `lt(r_lo, x_lo)` indicates overflow in the lower\n            // addition. Overflow in the high limb is simply ignored.\n            r_hi := add(add(x_hi, y_hi), lt(r_lo, x_lo))\n        }\n    }\n\n    function oadd(uint512 r, uint512 x, uint512 y) internal pure returns (uint512) {\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        (uint256 y_hi, uint256 y_lo) = y.into();\n        (uint256 r_hi, uint256 r_lo) = _add(x_hi, x_lo, y_hi, y_lo);\n        return r.from(r_hi, r_lo);\n    }\n\n    function iadd(uint512 r, uint512 y) internal pure returns (uint512) {\n        return oadd(r, r, y);\n    }\n\n    function _sub(uint256 x_hi, uint256 x_lo, uint256 y) private pure returns (uint256 r_hi, uint256 r_lo) {\n        assembly (\"memory-safe\") {\n            r_lo := sub(x_lo, y)\n            // `gt(r_lo, x_lo)` indicates underflow in the lower subtraction. We\n            // can subtract the bool directly from the integer to perform carry.\n            r_hi := sub(x_hi, gt(r_lo, x_lo))\n        }\n    }\n\n    function osub(uint512 r, uint512 x, uint256 y) internal pure returns (uint512) {\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        (uint256 r_hi, uint256 r_lo) = _sub(x_hi, x_lo, y);\n        return r.from(r_hi, r_lo);\n    }\n\n    function isub(uint512 r, uint256 y) internal pure returns (uint512) {\n        return osub(r, r, y);\n    }\n\n    function _sub(uint256 x_hi, uint256 x_lo, uint256 y_hi, uint256 y_lo)\n        private\n        pure\n        returns (uint256 r_hi, uint256 r_lo)\n    {\n        assembly (\"memory-safe\") {\n            r_lo := sub(x_lo, y_lo)\n            // `gt(r_lo, x_lo)` indicates underflow in the lower subtraction.\n            // Underflow in the high limb is simply ignored.\n            r_hi := sub(sub(x_hi, y_hi), gt(r_lo, x_lo))\n        }\n    }\n\n    function osub(uint512 r, uint512 x, uint512 y) internal pure returns (uint512) {\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        (uint256 y_hi, uint256 y_lo) = y.into();\n        (uint256 r_hi, uint256 r_lo) = _sub(x_hi, x_lo, y_hi, y_lo);\n        return r.from(r_hi, r_lo);\n    }\n\n    function isub(uint512 r, uint512 y) internal pure returns (uint512) {\n        return osub(r, r, y);\n    }\n\n    function irsub(uint512 r, uint512 y) internal pure returns (uint512) {\n        return osub(r, y, r);\n    }\n\n    function sub(uint512 x, uint256 y) internal pure returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            r := sub(mload(add(0x20, x)), y)\n        }\n    }\n\n    function sub(uint512 x, uint512 y) internal pure returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            r := sub(mload(add(0x20, x)), mload(add(0x20, y)))\n        }\n    }\n\n    //// The technique implemented in the following functions for multiplication is\n    //// adapted from Remco Bloemen's work https://2\u03c0.com/17/full-mul/ .\n    //// The original code was released under the MIT license.\n\n    function _mul(uint256 x, uint256 y) private pure returns (uint256 r_hi, uint256 r_lo) {\n        assembly (\"memory-safe\") {\n            let mm := mulmod(x, y, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            r_lo := mul(x, y)\n            r_hi := sub(sub(mm, r_lo), lt(mm, r_lo))\n        }\n    }\n\n    function omul(uint512 r, uint256 x, uint256 y) internal pure returns (uint512) {\n        (uint256 r_hi, uint256 r_lo) = _mul(x, y);\n        return r.from(r_hi, r_lo);\n    }\n\n    function _mul(uint256 x_hi, uint256 x_lo, uint256 y) private pure returns (uint256 r_hi, uint256 r_lo) {\n        assembly (\"memory-safe\") {\n            let mm := mulmod(x_lo, y, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            r_lo := mul(x_lo, y)\n            r_hi := add(mul(x_hi, y), sub(sub(mm, r_lo), lt(mm, r_lo)))\n        }\n    }\n\n    function omul(uint512 r, uint512 x, uint256 y) internal pure returns (uint512) {\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        (uint256 r_hi, uint256 r_lo) = _mul(x_hi, x_lo, y);\n        return r.from(r_hi, r_lo);\n    }\n\n    function imul(uint512 r, uint256 y) internal pure returns (uint512) {\n        return omul(r, r, y);\n    }\n\n    function _mul(uint256 x_hi, uint256 x_lo, uint256 y_hi, uint256 y_lo)\n        private\n        pure\n        returns (uint256 r_hi, uint256 r_lo)\n    {\n        assembly (\"memory-safe\") {\n            let mm := mulmod(x_lo, y_lo, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            r_lo := mul(x_lo, y_lo)\n            r_hi := add(add(mul(x_hi, y_lo), mul(x_lo, y_hi)), sub(sub(mm, r_lo), lt(mm, r_lo)))\n        }\n    }\n\n    function omul(uint512 r, uint512 x, uint512 y) internal pure returns (uint512) {\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        (uint256 y_hi, uint256 y_lo) = y.into();\n        (uint256 r_hi, uint256 r_lo) = _mul(x_hi, x_lo, y_hi, y_lo);\n        return r.from(r_hi, r_lo);\n    }\n\n    function imul(uint512 r, uint512 y) internal pure returns (uint512) {\n        return omul(r, r, y);\n    }\n\n    function mod(uint512 n, uint256 d) internal pure returns (uint256 r) {\n        if (d == 0) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        (uint256 n_hi, uint256 n_lo) = n.into();\n        assembly (\"memory-safe\") {\n            r := mulmod(n_hi, sub(0x00, d), d)\n            r := addmod(n_lo, r, d)\n        }\n    }\n\n    /// Multiply 512-bit [x_hi x_lo] by 256-bit [y] giving 768-bit [r_ex r_hi r_lo]\n    function _mul768(uint256 x_hi, uint256 x_lo, uint256 y)\n        private\n        pure\n        returns (uint256 r_ex, uint256 r_hi, uint256 r_lo)\n    {\n        assembly (\"memory-safe\") {\n            let mm0 := mulmod(x_lo, y, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            r_lo := mul(x_lo, y)\n            let mm1 := mulmod(x_hi, y, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            let r_partial := mul(x_hi, y)\n            r_ex := sub(sub(mm1, r_partial), lt(mm1, r_partial))\n\n            r_hi := add(r_partial, sub(sub(mm0, r_lo), lt(mm0, r_lo)))\n            // `lt(r_hi, r_partial)` indicates overflow in the addition to form\n            // `r_hi`. We can add the bool directly to the integer to perform\n            // carry.\n            r_ex := add(r_ex, lt(r_hi, r_partial))\n        }\n    }\n\n    //// The technique implemented in the following functions for division is\n    //// adapted from Remco Bloemen's work https://2\u03c0.com/21/muldiv/ .\n    //// The original code was released under the MIT license.\n\n    function _roundDown(uint256 x_hi, uint256 x_lo, uint256 d) private pure returns (uint256 r_hi, uint256 r_lo) {\n        assembly (\"memory-safe\") {\n            // Get the remainder [n_hi n_lo] % d (< 2\u00b2\u2075\u2076 - 1)\n            // 2**256 % d = -d % 2**256 % d -- https://2\u03c0.com/17/512-bit-division/\n            let rem := mulmod(x_hi, sub(0x00, d), d)\n            rem := addmod(x_lo, rem, d)\n\n            r_hi := sub(x_hi, gt(rem, x_lo))\n            r_lo := sub(x_lo, rem)\n        }\n    }\n\n    function _twos(uint256 x) private pure returns (uint256 twos, uint256 twosInv) {\n        assembly (\"memory-safe\") {\n            // Compute largest power of two divisor of `x`. `x` is nonzero, so\n            // this is always \u2265 1.\n            twos := and(sub(0x00, x), x)\n\n            // To shift up (bits from the high limb into the low limb) we need\n            // the inverse of `twos`. That is, 2\u00b2\u2075\u2076 / twos.\n            //     2**256 / twos = -twos % 2**256 / twos + 1 -- https://2\u03c0.com/17/512-bit-division/\n            // If `twos` is zero, then `twosInv` becomes one (not possible)\n            twosInv := add(div(sub(0x00, twos), twos), 0x01)\n        }\n    }\n\n    function _toOdd256(uint256 x_hi, uint256 x_lo, uint256 y) private pure returns (uint256 rx_lo, uint256 ry) {\n        // Factor powers of two out of `y` and apply the same shift to [x_hi\n        // x_lo]\n        (uint256 twos, uint256 twosInv) = _twos(y);\n\n        assembly (\"memory-safe\") {\n            // Divide `y` by the power of two\n            ry := div(y, twos)\n\n            // Divide [x_hi x_lo] by the power of two\n            rx_lo := or(div(x_lo, twos), mul(x_hi, twosInv))\n        }\n    }\n\n    function _toOdd256Multi(uint256 x_hi, uint256 x_lo, uint256 y_hi, uint256 y_lo, uint256 d)\n        private\n        pure\n        returns (uint256 rx_lo, uint256 ry_lo, uint256 rd)\n    {\n        // Factor powers of two out of `d` and apply the same shift to [x_hi\n        // x_lo] and [y_hi y_lo]\n        (uint256 twos, uint256 twosInv) = _twos(d);\n\n        assembly (\"memory-safe\") {\n            // Divide `d` by the power of two\n            rd := div(d, twos)\n\n            // Divide [x_hi x_lo] by the power of two\n            rx_lo := or(div(x_lo, twos), mul(x_hi, twosInv))\n\n            // Divide [y_hi y_lo] by the power of two\n            ry_lo := or(div(y_lo, twos), mul(y_hi, twosInv))\n        }\n    }\n\n    function _toOdd512(uint256 x_hi, uint256 x_lo, uint256 y)\n        private\n        pure\n        returns (uint256 rx_hi, uint256 rx_lo, uint256 ry)\n    {\n        // Factor powers of two out of `y` and apply the same shift to [x_hi\n        // x_lo]\n        (uint256 twos, uint256 twosInv) = _twos(y);\n\n        assembly (\"memory-safe\") {\n            // Divide `y` by the power of two\n            ry := div(y, twos)\n\n            // Divide [x_hi x_lo] by the power of two\n            rx_hi := div(x_hi, twos)\n            rx_lo := or(div(x_lo, twos), mul(x_hi, twosInv))\n        }\n    }\n\n    function _invert256(uint256 d) private pure returns (uint256 inv) {\n        assembly (\"memory-safe\") {\n            // Invert `d` mod 2\u00b2\u2075\u2076 -- https://2\u03c0.com/18/multiplitcative-inverses/\n            // `d` is an odd number (from _toOdd*). It has an inverse modulo\n            // 2\u00b2\u2075\u2076 such that d * inv \u2261 1 mod 2\u00b2\u2075\u2076.\n            // We use Newton-Raphson iterations compute inv. Thanks to Hensel's\n            // lifting lemma, this also works in modular arithmetic, doubling\n            // the correct bits in each step. The Newton-Raphson-Hensel step is:\n            //    inv_{n+1} = inv_n * (2 - d*inv_n) % 2**256\n\n            // To kick off Newton-Raphson-Hensel iterations, we start with a\n            // seed of the inverse that is correct correct for four bits.\n            //     d * inv \u2261 1 mod 2\u2074\n            inv := xor(mul(0x03, d), 0x02)\n\n            // Each Newton-Raphson-Hensel step doubles the number of correct\n            // bits in `inv`. After 6 iterations, full convergence is\n            // guaranteed.\n            inv := mul(inv, sub(0x02, mul(d, inv))) // inverse mod 2\u2078\n            inv := mul(inv, sub(0x02, mul(d, inv))) // inverse mod 2\u00b9\u2076\n            inv := mul(inv, sub(0x02, mul(d, inv))) // inverse mod 2\u00b3\u00b2\n            inv := mul(inv, sub(0x02, mul(d, inv))) // inverse mod 2\u2076\u2074\n            inv := mul(inv, sub(0x02, mul(d, inv))) // inverse mod 2\u00b9\u00b2\u2078\n            inv := mul(inv, sub(0x02, mul(d, inv))) // inverse mod 2\u00b2\u2075\u2076\n        }\n    }\n\n    function _invert512(uint256 d) private pure returns (uint256 inv_hi, uint256 inv_lo) {\n        // First, we get the inverse of `d` mod 2\u00b2\u2075\u2076\n        inv_lo = _invert256(d);\n\n        // To extend this to the inverse mod 2\u2075\u00b9\u00b2, we perform a more elaborate\n        // 7th Newton-Raphson-Hensel iteration with 512 bits of precision.\n\n        // tmp = d * inv_lo % 2**512\n        (uint256 tmp_hi, uint256 tmp_lo) = _mul(d, inv_lo);\n        // tmp = 2 - tmp % 2**512\n        (tmp_hi, tmp_lo) = _sub(0, 2, tmp_hi, tmp_lo);\n\n        assembly (\"memory-safe\") {\n            // inv_hi = inv_lo * tmp / 2**256 % 2**256\n            let mm := mulmod(inv_lo, tmp_lo, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            inv_hi := add(mul(inv_lo, tmp_hi), sub(sub(mm, inv_lo), lt(mm, inv_lo)))\n        }\n    }\n\n    function div(uint512 n, uint256 d) internal pure returns (uint256) {\n        if (d == 0) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        (uint256 n_hi, uint256 n_lo) = n.into();\n        if (n_hi == 0) {\n            return n_lo.unsafeDiv(d);\n        }\n\n        // Round the numerator down to a multiple of the denominator. This makes\n        // the division exact without affecting the result.\n        (n_hi, n_lo) = _roundDown(n_hi, n_lo, d);\n\n        // Make `d` odd so that it has a multiplicative inverse mod 2\u00b2\u2075\u2076\n        // After this we can discard `n_hi` because our result is only 256 bits\n        (n_lo, d) = _toOdd256(n_hi, n_lo, d);\n\n        // We perform division by multiplying by the multiplicative inverse of\n        // the denominator mod 2\u00b2\u2075\u2076. Since `d` is odd, this inverse\n        // exists. Compute that inverse\n        d = _invert256(d);\n\n        unchecked {\n            // Because the division is now exact (we rounded `n` down to a\n            // multiple of `d`), we perform it by multiplying with the modular\n            // inverse of the denominator. This is the correct result mod 2\u00b2\u2075\u2076.\n            return n_lo * d;\n        }\n    }\n\n    function divMulti(uint512 n0, uint512 n1, uint256 d) internal pure returns (uint256, uint256) {\n        if (d == 0) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        (uint256 n0_hi, uint256 n0_lo) = n0.into();\n        (uint256 n1_hi, uint256 n1_lo) = n1.into();\n        {\n            bool condition;\n            assembly (\"memory-safe\") {\n                condition := iszero(or(n0_hi, n1_hi))\n            }\n            if (condition) {\n                return (n0_lo.unsafeDiv(d), n1_lo.unsafeDiv(d));\n            }\n        }\n\n        // Round the numerators down to multiples of the denominator. This makes\n        // division exact without affecting the result.\n        (n0_hi, n0_lo) = _roundDown(n0_hi, n0_lo, d);\n        (n1_hi, n1_lo) = _roundDown(n1_hi, n1_lo, d);\n\n        // Make `d` odd so that it has a multiplicative inverse mod 2\u00b2\u2075\u2076 After\n        // this we can discard `n0_hi` and `n1_hi` because our results are only\n        // 256 bits\n        (n0_lo, n1_lo, d) = _toOdd256Multi(n0_hi, n0_lo, n1_hi, n1_lo, d);\n\n        // We perform division by multiplying by the multiplicative inverse of\n        // the denominator mod 2\u00b2\u2075\u2076. Since `d` is odd, this inverse\n        // exists. Compute that inverse\n        d = _invert256(d);\n\n        unchecked {\n            // Because the divisions are now exact (we rounded `n0` and `n1`\n            // down to multiples of `d`), we perform them by multiplying with\n            // the modular inverse of the denominator. These are the correct\n            // results mod 2\u00b2\u2075\u2076.\n            return (n0_lo * d, n1_lo * d);\n        }\n    }\n\n    function _gt(uint256 x_hi, uint256 x_lo, uint256 y_hi, uint256 y_lo) private pure returns (bool r) {\n        assembly (\"memory-safe\") {\n            r := or(gt(x_hi, y_hi), and(eq(x_hi, y_hi), gt(x_lo, y_lo)))\n        }\n    }\n\n    function odiv(uint512 r, uint512 x, uint256 y) internal pure returns (uint512) {\n        if (y == 0) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        if (x_hi == 0) {\n            return r.from(0, x_lo.unsafeDiv(y));\n        }\n\n        // Round the numerator down to a multiple of the denominator. This makes\n        // the division exact without affecting the result.\n        (x_hi, x_lo) = _roundDown(x_hi, x_lo, y);\n\n        // Make `y` odd so that it has a multiplicative inverse mod 2\u2075\u00b9\u00b2\n        (x_hi, x_lo, y) = _toOdd512(x_hi, x_lo, y);\n\n        // We perform division by multiplying by the multiplicative inverse of\n        // the denominator mod 2\u2075\u00b9\u00b2. Since `y` is odd, this inverse\n        // exists. Compute that inverse\n        (uint256 inv_hi, uint256 inv_lo) = _invert512(y);\n\n        // Because the division is now exact (we rounded `x` down to a multiple\n        // of `y`), we perform it by multiplying with the modular inverse of the\n        // denominator.\n        (uint256 r_hi, uint256 r_lo) = _mul(x_hi, x_lo, inv_hi, inv_lo);\n        return r.from(r_hi, r_lo);\n    }\n\n    function idiv(uint512 r, uint256 y) internal pure returns (uint512) {\n        return odiv(r, r, y);\n    }\n\n    function _gt(uint256 x_ex, uint256 x_hi, uint256 x_lo, uint256 y_ex, uint256 y_hi, uint256 y_lo)\n        private\n        pure\n        returns (bool r)\n    {\n        assembly (\"memory-safe\") {\n            r :=\n                or(\n                    or(gt(x_ex, y_ex), and(eq(x_ex, y_ex), gt(x_hi, y_hi))),\n                    and(and(eq(x_ex, y_ex), eq(x_hi, y_hi)), gt(x_lo, y_lo))\n                )\n        }\n    }\n\n    /// The technique implemented in the following helper function for Knuth\n    /// Algorithm D (a modification of the citation further below) is adapted\n    /// from ridiculous fish's (aka corydoras) work\n    /// https://ridiculousfish.com/blog/posts/labor-of-division-episode-iv.html\n    /// and\n    /// https://ridiculousfish.com/blog/posts/labor-of-division-episode-v.html .\n\n    function _correctQ(uint256 q, uint256 r, uint256 x_next, uint256 y_next, uint256 y_whole)\n        private\n        pure\n        returns (uint256 q_out)\n    {\n        assembly (\"memory-safe\") {\n            let c1 := mul(q, y_next)\n            let c2 := or(shl(0x80, r), x_next)\n            q_out := sub(q, shl(gt(sub(c1, c2), y_whole), gt(c1, c2)))\n        }\n    }\n\n    /// The technique implemented in the following function for division is\n    /// adapted from Donald Knuth, The Art of Computer Programming (TAOCP)\n    /// Volume 2, Section 4.3.1, Algorithm D.\n\n    function _algorithmD(uint256 x_hi, uint256 x_lo, uint256 y_hi, uint256 y_lo) private pure returns (uint256 q) {\n        // We treat `x` and `y` each as \u22644-limb bigints where each limb is half\n        // a machine word (128 bits). This lets us perform 2-limb \u00f7 1-limb\n        // divisions as a single operation (`div`) as required by Algorithm\n        // D. It also simplifies/optimizes some of the multiplications.\n\n        if (y_hi >> 128 != 0) {\n            // y is 4 limbs, x is 4 limbs, q is 1 limb\n\n            // Normalize. Ensure the uppermost limb of y \u2265 2\u00b9\u00b2\u2077 (equivalently\n            // y_hi >= 2**255). This is step D1 of Algorithm D\n            // The author's copy of TAOCP (3rd edition) states to set `d = (2 **\n            // 128 - 1) // y_hi`, however this is incorrect. Setting `d` in this\n            // fashion may result in overflow in the subsequent `_mul`. Setting\n            // `d` as implemented below still satisfies the postcondition (`y_hi\n            // >> 128 >= 1 << 127`) but never results in overflow.\n            uint256 d = uint256(1 << 128).unsafeDiv((y_hi >> 128).unsafeInc());\n            uint256 x_ex;\n            (x_ex, x_hi, x_lo) = _mul768(x_hi, x_lo, d);\n            (y_hi, y_lo) = _mul(y_hi, y_lo, d);\n\n            // `n_approx` is the 2 most-significant limbs of x, after\n            // normalization\n            uint256 n_approx = (x_ex << 128) | (x_hi >> 128);\n            // `d_approx` is the most significant limb of y, after normalization\n            uint256 d_approx = y_hi >> 128;\n            // Normalization ensures that result of this division is an\n            // approximation of the most significant (and only) limb of the\n            // quotient and is too high by at most 3. This is the \"Calculate\n            // q-hat\" (D3) step of Algorithm D. (did you know that U+0302,\n            // COMBINING CIRCUMFLEX ACCENT cannot be combined with q? shameful)\n            q = n_approx.unsafeDiv(d_approx);\n            uint256 r_hat = n_approx.unsafeMod(d_approx);\n\n            // The process of `_correctQ` subtracts up to 2 from `q`, to make it\n            // more accurate. This is still part of the \"Calculate q-hat\" (D3)\n            // step of Algorithm D.\n            q = _correctQ(q, r_hat, x_hi & type(uint128).max, y_hi & type(uint128).max, y_hi);\n\n            // This final, low-probability, computationally-expensive correction\n            // conditionally subtracts 1 from `q` to make it exactly the\n            // most-significant limb of the quotient. This is the \"Multiply and\n            // subtract\" (D4), \"Test remainder\" (D5), and \"Add back\" (D6) steps\n            // of Algorithm D, with substantial shortcutting\n            {\n                (uint256 tmp_ex, uint256 tmp_hi, uint256 tmp_lo) = _mul768(y_hi, y_lo, q);\n                bool neg = _gt(tmp_ex, tmp_hi, tmp_lo, x_ex, x_hi, x_lo);\n                assembly (\"memory-safe\") {\n                    q := sub(q, neg)\n                }\n            }\n        } else {\n            // y is 3 limbs\n\n            // Normalize. Ensure the most significant limb of y \u2265 2\u00b9\u00b2\u2077 (step D1)\n            // See above comment about the error in TAOCP.\n            uint256 d = uint256(1 << 128).unsafeDiv(y_hi.unsafeInc());\n            (y_hi, y_lo) = _mul(y_hi, y_lo, d);\n            // `y_next` is the second-most-significant, nonzero, normalized limb\n            // of y\n            uint256 y_next = y_lo >> 128;\n            // `y_whole` is the 2 most-significant, nonzero, normalized limbs of\n            // y\n            uint256 y_whole = (y_hi << 128) | y_next;\n\n            if (x_hi >> 128 != 0) {\n                // x is 4 limbs, q is 2 limbs\n\n                // Finish normalizing (step D1)\n                uint256 x_ex;\n                (x_ex, x_hi, x_lo) = _mul768(x_hi, x_lo, d);\n\n                uint256 n_approx = (x_ex << 128) | (x_hi >> 128);\n                // As before, `q_hat` is the most significant limb of the\n                // quotient and too high by at most 3 (step D3)\n                uint256 q_hat = n_approx.unsafeDiv(y_hi);\n                uint256 r_hat = n_approx.unsafeMod(y_hi);\n\n                // Subtract up to 2 from `q_hat`, improving our estimate (step\n                // D3)\n                q_hat = _correctQ(q_hat, r_hat, x_hi & type(uint128).max, y_next, y_whole);\n                q = q_hat << 128;\n\n                {\n                    // \"Multiply and subtract\" (D4) step of Algorithm D\n                    (uint256 tmp_hi, uint256 tmp_lo) = _mul(y_hi, y_lo, q_hat);\n                    uint256 tmp_ex = tmp_hi >> 128;\n                    tmp_hi = (tmp_hi << 128) | (tmp_lo >> 128);\n                    tmp_lo <<= 128;\n\n                    // \"Test remainder\" (D5) step of Algorithm D\n                    bool neg = _gt(tmp_ex, tmp_hi, tmp_lo, x_ex, x_hi, x_lo);\n                    // Finish step D4\n                    (x_hi, x_lo) = _sub(x_hi, x_lo, tmp_hi, tmp_lo);\n\n                    // \"Add back\" (D6) step of Algorithm D\n                    if (neg) {\n                        // This branch is quite rare, so it's gas-advantageous\n                        // to actually branch and usually skip the costly `_add`\n                        unchecked {\n                            q -= 1 << 128;\n                        }\n                        (x_hi, x_lo) = _add(x_hi, x_lo, y_whole, y_lo << 128);\n                    }\n                }\n                // `x_ex` is now zero (implicitly)\n\n                // Run another loop (steps D3 through D6) of Algorithm D to get\n                // the lower limb of the quotient\n                q_hat = x_hi.unsafeDiv(y_hi);\n                r_hat = x_hi.unsafeMod(y_hi);\n\n                q_hat = _correctQ(q_hat, r_hat, x_lo >> 128, y_next, y_whole);\n\n                {\n                    (uint256 tmp_hi, uint256 tmp_lo) = _mul(y_hi, y_lo, q_hat);\n                    bool neg = _gt(tmp_hi, tmp_lo, x_hi, x_lo);\n                    assembly (\"memory-safe\") {\n                        q_hat := sub(q_hat, neg)\n                    }\n                }\n\n                q |= q_hat;\n            } else {\n                // x is 3 limbs, q is 1 limb\n\n                // Finish normalizing (step D1)\n                (x_hi, x_lo) = _mul(x_hi, x_lo, d);\n\n                // `q` is the most significant (and only) limb of the quotient\n                // and too high by at most 3 (step D3)\n                q = x_hi.unsafeDiv(y_hi);\n                uint256 r_hat = x_hi.unsafeMod(y_hi);\n\n                // Subtract up to 2 from `q`, improving our estimate (step D3)\n                q = _correctQ(q, r_hat, x_lo >> 128, y_next, y_whole);\n\n                // Subtract up to 1 from `q` to make it exact (steps D4 through\n                // D6)\n                {\n                    (uint256 tmp_hi, uint256 tmp_lo) = _mul(y_hi, y_lo, q);\n                    bool neg = _gt(tmp_hi, tmp_lo, x_hi, x_lo);\n                    assembly (\"memory-safe\") {\n                        q := sub(q, neg)\n                    }\n                }\n            }\n        }\n        // All other cases are handled by the checks that y \u2265 2\u00b2\u2075\u2076 (equivalently\n        // y_hi != 0) and that x \u2265 y\n    }\n\n    /// Modified from Solady (https://github.com/Vectorized/solady/blob/a3d6a974f9c9f00dcd95b235619a209a63c61d94/src/utils/LibBit.sol#L33-L45)\n    /// The original code was released under the MIT license.\n    function _clzLower(uint256 x) private pure returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            r := shl(0x06, lt(0xffffffffffffffff, x))\n            r := or(r, shl(0x05, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(0x04, lt(0xffff, shr(r, x))))\n            r := or(r, shl(0x03, lt(0xff, shr(r, x))))\n            // We use a 5-bit deBruijn Sequence to convert `x`'s 8\n            // most-significant bits into an index. We then index the lookup\n            // table (bytewise) by the deBruijn symbol to obtain the bitwise\n            // inverse of its logarithm.\n            // slither-disable-next-line incorrect-shift\n            r :=\n                xor(\n                    r,\n                    byte(\n                        and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                        0x7879797a797d7a7b797d7c7d7a7b7c7e797a7d7a7c7c7b7e7a7a7c7b7f7f7f7f\n                    )\n                )\n        }\n    }\n\n    function _clzUpper(uint256 x) private pure returns (uint256) {\n        return _clzLower(x >> 128);\n    }\n\n    function _shl(uint256 x_hi, uint256 x_lo, uint256 s) private pure returns (uint256 r_hi, uint256 r_lo) {\n        assembly (\"memory-safe\") {\n            r_hi := or(shl(s, x_hi), shr(sub(0x100, s), x_lo))\n            r_lo := shl(s, x_lo)\n        }\n    }\n\n    function _shl768(uint256 x_hi, uint256 x_lo, uint256 s)\n        private\n        pure\n        returns (uint256 r_ex, uint256 r_hi, uint256 r_lo)\n    {\n        assembly (\"memory-safe\") {\n            let neg_s := sub(0x100, s)\n            r_ex := shr(neg_s, x_hi)\n            r_hi := or(shl(s, x_hi), shr(neg_s, x_lo))\n            r_lo := shl(s, x_lo)\n        }\n    }\n\n    function _shr(uint256 x_hi, uint256 x_lo, uint256 s) private pure returns (uint256 r_hi, uint256 r_lo) {\n        assembly (\"memory-safe\") {\n            r_hi := shr(s, x_hi)\n            r_lo := or(shl(sub(0x100, s), x_hi), shr(s, x_lo))\n        }\n    }\n\n    // This function is a different modification of Knuth's Algorithm D. In this\n    // case, we're only interested in the (normalized) remainder instead of the\n    // quotient. We also substitute the normalization by division for\n    // normalization by shifting because it makes un-normalization more\n    // gas-efficient.\n\n    function _algorithmDRemainder(uint256 x_hi, uint256 x_lo, uint256 y_hi, uint256 y_lo)\n        private\n        pure\n        returns (uint256, uint256)\n    {\n        // We treat `x` and `y` each as \u22644-limb bigints where each limb is half\n        // a machine word (128 bits). This lets us perform 2-limb \u00f7 1-limb\n        // divisions as a single operation (`div`) as required by Algorithm D.\n\n        uint256 s;\n        if (y_hi >> 128 != 0) {\n            // y is 4 limbs, x is 4 limbs\n\n            // Normalize. Ensure the uppermost limb of y \u2265 2\u00b9\u00b2\u2077 (equivalently\n            // y_hi >= 2**255). This is step D1 of Algorithm D. Unlike the\n            // preceeding implementation of Algorithm D, we use a binary shift\n            // instead of a multiply to normalize. This performs a costly \"count\n            // leading zeroes\" operation, but it lets us transform an\n            // even-more-costly division-by-inversion operation later into a\n            // simple shift. This still ultimately satisfies the postcondition\n            // (y_hi >> 128 >= 1 << 127) without overflowing.\n            s = _clzUpper(y_hi);\n            uint256 x_ex;\n            (x_ex, x_hi, x_lo) = _shl768(x_hi, x_lo, s);\n            (y_hi, y_lo) = _shl(y_hi, y_lo, s);\n\n            // `n_approx` is the 2 most-significant limbs of x, after\n            // normalization\n            uint256 n_approx = (x_ex << 128) | (x_hi >> 128); // TODO: this can probably be optimized (combined with `_shl`)\n            // `d_approx` is the most significant limb of y, after normalization\n            uint256 d_approx = y_hi >> 128;\n            // Normalization ensures that result of this division is an\n            // approximation of the most significant (and only) limb of the\n            // quotient and is too high by at most 3. This is the \"Calculate\n            // q-hat\" (D3) step of Algorithm D. (did you know that U+0302,\n            // COMBINING CIRCUMFLEX ACCENT cannot be combined with q? shameful)\n            uint256 q_hat = n_approx.unsafeDiv(d_approx);\n            uint256 r_hat = n_approx.unsafeMod(d_approx);\n\n            // The process of `_correctQ` subtracts up to 2 from `q_hat`, to\n            // make it more accurate. This is still part of the \"Calculate\n            // q-hat\" (D3) step of Algorithm D.\n            q_hat = _correctQ(q_hat, r_hat, x_hi & type(uint128).max, y_hi & type(uint128).max, y_hi);\n\n            {\n                // This penultimate correction subtracts q-hat \u00d7 y from x to\n                // obtain the normalized remainder. This is the \"Multiply and\n                // subtract\" (D4) and \"Test remainder\" (D5) steps of Algorithm\n                // D, with some shortcutting\n                (uint256 tmp_ex, uint256 tmp_hi, uint256 tmp_lo) = _mul768(y_hi, y_lo, q_hat);\n                bool neg = _gt(tmp_ex, tmp_hi, tmp_lo, x_ex, x_hi, x_lo);\n                (x_hi, x_lo) = _sub(x_hi, x_lo, tmp_hi, tmp_lo);\n                // `x_ex` is now implicitly zero (or signals a carry that we\n                // will clear in the next step)\n\n                // Because `q_hat` may be too high by 1, we have to detect\n                // underflow from the previous step and correct it. This is the\n                // \"Add back\" (D6) step of Algorithm D\n                if (neg) {\n                    (x_hi, x_lo) = _add(x_hi, x_lo, y_hi, y_lo);\n                }\n            }\n        } else {\n            // y is 3 limbs\n\n            // Normalize. Ensure the most significant limb of y \u2265 2\u00b9\u00b2\u2077 (step D1)\n            // See above comment about the use of a shift instead of division.\n            s = _clzLower(y_hi);\n            (y_hi, y_lo) = _shl(y_hi, y_lo, s);\n            // `y_next` is the second-most-significant, nonzero, normalized limb\n            // of y\n            uint256 y_next = y_lo >> 128; // TODO: this can probably be optimized (combined with `_shl`)\n            // `y_whole` is the 2 most-significant, nonzero, normalized limbs of\n            // y\n            uint256 y_whole = (y_hi << 128) | y_next; // TODO: this can probably be optimized (combined with `_shl`)\n\n            if (x_hi >> 128 != 0) {\n                // x is 4 limbs; we have to run 2 iterations of Algorithm D to\n                // fully divide out by y\n\n                // Finish normalizing (step D1)\n                uint256 x_ex;\n                (x_ex, x_hi, x_lo) = _shl768(x_hi, x_lo, s);\n\n                uint256 n_approx = (x_ex << 128) | (x_hi >> 128); // TODO: this can probably be optimized (combined with `_shl768`)\n                // As before, `q_hat` is the most significant limb of the\n                // quotient and too high by at most 3 (step D3)\n                uint256 q_hat = n_approx.unsafeDiv(y_hi);\n                uint256 r_hat = n_approx.unsafeMod(y_hi);\n\n                // Subtract up to 2 from `q_hat`, improving our estimate (step\n                // D3)\n                q_hat = _correctQ(q_hat, r_hat, x_hi & type(uint128).max, y_next, y_whole);\n\n                // Subtract up to 1 from q-hat to make it exactly the\n                // most-significant limb of the quotient and subtract q-hat \u00d7 y\n                // from x to clear the most-significant limb of x.\n                {\n                    // \"Multiply and subtract\" (D4) step of Algorithm D\n                    (uint256 tmp_hi, uint256 tmp_lo) = _mul(y_hi, y_lo, q_hat);\n                    uint256 tmp_ex = tmp_hi >> 128;\n                    tmp_hi = (tmp_hi << 128) | (tmp_lo >> 128);\n                    tmp_lo <<= 128;\n\n                    // \"Test remainder\" (D5) step of Algorithm D\n                    bool neg = _gt(tmp_ex, tmp_hi, tmp_lo, x_ex, x_hi, x_lo);\n                    // Finish step D4\n                    (x_hi, x_lo) = _sub(x_hi, x_lo, tmp_hi, tmp_lo);\n\n                    // \"Add back\" (D6) step of Algorithm D. We implicitly\n                    // subtract 1 from `q_hat`, but elide explicitly\n                    // representing that because `q_hat` is no longer needed.\n                    if (neg) {\n                        // This branch is quite rare, so it's gas-advantageous\n                        // to actually branch and usually skip the costly `_add`\n                        (x_hi, x_lo) = _add(x_hi, x_lo, y_whole, y_lo << 128);\n                    }\n                }\n                // `x_ex` is now zero (implicitly)\n                // [x_hi x_lo] now represents the partial, normalized remainder.\n\n                // Run another loop (steps D3 through D6) of Algorithm D to get\n                // the lower limb of the quotient\n                // Step D3\n                q_hat = x_hi.unsafeDiv(y_hi);\n                r_hat = x_hi.unsafeMod(y_hi);\n\n                // Step D3\n                q_hat = _correctQ(q_hat, r_hat, x_lo >> 128, y_next, y_whole);\n\n                // Again, implicitly correct q-hat to make it exactly the\n                // least-significant limb of the quotient. Subtract q-hat \u00d7 y\n                // from x to obtain the normalized remainder.\n                {\n                    // Steps D4 and D5\n                    (uint256 tmp_hi, uint256 tmp_lo) = _mul(y_hi, y_lo, q_hat);\n                    bool neg = _gt(tmp_hi, tmp_lo, x_hi, x_lo);\n                    (x_hi, x_lo) = _sub(x_hi, x_lo, tmp_hi, tmp_lo);\n\n                    // Step D6\n                    if (neg) {\n                        (x_hi, x_lo) = _add(x_hi, x_lo, y_hi, y_lo);\n                    }\n                }\n            } else {\n                // x is 3 limbs\n\n                // Finish normalizing (step D1)\n                (x_hi, x_lo) = _shl(x_hi, x_lo, s);\n\n                // `q_hat` is the most significant (and only) limb of the\n                // quotient and too high by at most 3 (step D3)\n                uint256 q_hat = x_hi.unsafeDiv(y_hi);\n                uint256 r_hat = x_hi.unsafeMod(y_hi);\n\n                // Subtract up to 2 from `q_hat`, improving our estimate (step\n                // D3)\n                q_hat = _correctQ(q_hat, r_hat, x_lo >> 128, y_next, y_whole);\n\n                // Make `q_hat` exact (implicitly) and subtract q-hat \u00d7 y from x\n                // to obtain the normalized remainder. (steps D4 through D6)\n                {\n                    (uint256 tmp_hi, uint256 tmp_lo) = _mul(y_hi, y_lo, q_hat);\n                    bool neg = _gt(tmp_hi, tmp_lo, x_hi, x_lo);\n                    (x_hi, x_lo) = _sub(x_hi, x_lo, tmp_hi, tmp_lo);\n                    if (neg) {\n                        (x_hi, x_lo) = _add(x_hi, x_lo, y_hi, y_lo);\n                    }\n                }\n            }\n        }\n        // All other cases are handled by the checks that y \u2265 2\u00b2\u2075\u2076 (equivalently\n        // y_hi != 0) and that x \u2265 y\n\n        // The second-most-significant limb of normalized x is now zero\n        // (equivalently x_hi < 2**128), but because the entire machine is not\n        // guaranteed to be cleared, we can't optimize any further.\n\n        // [x_hi x_lo] now represents remainder \u00d7 2\u02e2 (the normalized remainder);\n        // we shift right by `s` (un-normalize) to obtain the result.\n        return _shr(x_hi, x_lo, s);\n    }\n\n    function odiv(uint512 r, uint512 x, uint512 y) internal pure returns (uint512) {\n        (uint256 y_hi, uint256 y_lo) = y.into();\n        if (y_hi == 0) {\n            // This is the only case where we can have a 2-word quotient\n            return odiv(r, x, y_lo);\n        }\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        if (y_lo == 0) {\n            uint256 r_lo = x_hi.unsafeDiv(y_hi);\n            return r.from(0, r_lo);\n        }\n        if (_gt(y_hi, y_lo, x_hi, x_lo)) {\n            return r.from(0, 0);\n        }\n\n        // At this point, we know that both `x` and `y` are fully represented by\n        // 2 words. There is no simpler representation for the problem. We must\n        // use Knuth's Algorithm D.\n        {\n            uint256 r_lo = _algorithmD(x_hi, x_lo, y_hi, y_lo);\n            return r.from(0, r_lo);\n        }\n    }\n\n    function idiv(uint512 r, uint512 y) internal pure returns (uint512) {\n        return odiv(r, r, y);\n    }\n\n    function irdiv(uint512 r, uint512 y) internal pure returns (uint512) {\n        return odiv(r, y, r);\n    }\n\n    function div(uint512 x, uint512 y) internal pure returns (uint256) {\n        (uint256 y_hi, uint256 y_lo) = y.into();\n        if (y_hi == 0) {\n            return div(x, y_lo);\n        }\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        if (y_lo == 0) {\n            return x_hi.unsafeDiv(y_hi);\n        }\n        if (_gt(y_hi, y_lo, x_hi, x_lo)) {\n            return 0;\n        }\n\n        // At this point, we know that both `x` and `y` are fully represented by\n        // 2 words. There is no simpler representation for the problem. We must\n        // use Knuth's Algorithm D.\n        return _algorithmD(x_hi, x_lo, y_hi, y_lo);\n    }\n\n    function omod(uint512 r, uint512 x, uint512 y) internal pure returns (uint512) {\n        (uint256 y_hi, uint256 y_lo) = y.into();\n        if (y_hi == 0) {\n            uint256 r_lo = mod(x, y_lo);\n            return r.from(0, r_lo);\n        }\n        (uint256 x_hi, uint256 x_lo) = x.into();\n        if (y_lo == 0) {\n            uint256 r_hi = x_hi.unsafeMod(y_hi);\n            return r.from(r_hi, x_lo);\n        }\n        if (_gt(y_hi, y_lo, x_hi, x_lo)) {\n            return r.from(x_hi, x_lo);\n        }\n\n        // At this point, we know that both `x` and `y` are fully represented by\n        // 2 words. There is no simpler representation for the problem. We must\n        // use Knuth's Algorithm D.\n        {\n            (uint256 r_hi, uint256 r_lo) = _algorithmDRemainder(x_hi, x_lo, y_hi, y_lo);\n            return r.from(r_hi, r_lo);\n        }\n    }\n\n    function imod(uint512 r, uint512 y) internal pure returns (uint512) {\n        return omod(r, r, y);\n    }\n\n    function irmod(uint512 r, uint512 y) internal pure returns (uint512) {\n        return omod(r, y, r);\n    }\n}\n\nusing Lib512MathArithmetic for uint512 global;\n\nlibrary Lib512MathUserDefinedHelpers {\n    function checkNull(uint512 x, uint512 y) internal pure {\n        unchecked {\n            if (uint256(uint512.unwrap(x)) * uint256(uint512.unwrap(y)) == 0) {\n                Panic.panic(Panic.ASSERT_FAIL);\n            }\n        }\n    }\n}\n\nfunction __add(uint512 x, uint512 y) pure returns (uint512 r) {\n    Lib512MathUserDefinedHelpers.checkNull(x, y);\n    r.oadd(x, y);\n}\n\nfunction __sub(uint512 x, uint512 y) pure returns (uint512 r) {\n    Lib512MathUserDefinedHelpers.checkNull(x, y);\n    r.osub(x, y);\n}\n\nfunction __mul(uint512 x, uint512 y) pure returns (uint512 r) {\n    Lib512MathUserDefinedHelpers.checkNull(x, y);\n    r.omul(x, y);\n}\n\nfunction __mod(uint512 x, uint512 y) pure returns (uint512 r) {\n    Lib512MathUserDefinedHelpers.checkNull(x, y);\n    r.omod(x, y);\n}\n\nfunction __div(uint512 x, uint512 y) pure returns (uint512 r) {\n    Lib512MathUserDefinedHelpers.checkNull(x, y);\n    r.odiv(x, y);\n}\n\nusing {__add as +, __sub as -, __mul as *, __mod as %, __div as / } for uint512 global;\n\nstruct uint512_external {\n    uint256 hi;\n    uint256 lo;\n}\n\nlibrary Lib512MathExternal {\n    function from(uint512 r, uint512_external memory x) internal pure returns (uint512) {\n        assembly (\"memory-safe\") {\n            mstore(r, mload(x))\n            mstore(add(0x20, r), mload(add(0x20, x)))\n        }\n        return r;\n    }\n\n    function into(uint512_external memory x) internal pure returns (uint512 r) {\n        assembly (\"memory-safe\") {\n            r := x\n        }\n    }\n\n    function toExternal(uint512 x) internal pure returns (uint512_external memory r) {\n        assembly (\"memory-safe\") {\n            if iszero(eq(mload(0x40), add(0x40, r))) { revert(0x00, 0x00) }\n            mstore(0x40, r)\n            r := x\n        }\n    }\n}\n\nusing Lib512MathExternal for uint512 global;\nusing Lib512MathExternal for uint512_external global;\n"}, "src/lib/Math.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nlibrary Math {\n    function saturatingAdd(uint256 x, uint256 y) internal pure returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            r := add(x, y)\n            r := or(r, sub(0x00, lt(r, y)))\n        }\n    }\n\n    function saturatingSub(uint256 x, uint256 y) internal pure returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            r := mul(sub(x, y), gt(x, y))\n        }\n    }\n\n    /// Copied from Solmate (https://github.com/transmissions11/solmate/blob/eaa7041378f9a6c12f943de08a6c41b31a9870fc/src/utils/FixedPointMathLib.sol#L288)\n    /// The original code was released under the MIT license.\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly (\"memory-safe\") {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between floor(sqrt(x)) and\n            // ceil(sqrt(x)). Therefore, we may rarely return ceil(sqrt(x)) instead of the expected value.\n            // This error is not corrected because in our practical usage it doesn't matter and it saves some gas.\n        }\n    }\n}\n"}, "src/lib/Panic.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nlibrary Panic {\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71) // selector for `Panic(uint256)`\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n\n    // https://docs.soliditylang.org/en/latest/control-structures.html#panic-via-assert-and-error-via-require\n    uint8 internal constant GENERIC = 0x00;\n    uint8 internal constant ASSERT_FAIL = 0x01;\n    uint8 internal constant ARITHMETIC_OVERFLOW = 0x11;\n    uint8 internal constant DIVISION_BY_ZERO = 0x12;\n    uint8 internal constant ENUM_CAST = 0x21;\n    uint8 internal constant CORRUPT_STORAGE_ARRAY = 0x22;\n    uint8 internal constant POP_EMPTY_ARRAY = 0x31;\n    uint8 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    uint8 internal constant OUT_OF_MEMORY = 0x41;\n    uint8 internal constant ZERO_FUNCTION_POINTER = 0x51;\n}\n"}}, "settings": {"remappings": ["@forge-std/=lib/forge-std/src/"], "optimizer": {"enabled": true}, "metadata": {"useLiteralContent": false, "bytecodeHash": "ipfs", "appendCBOR": true}, "outputSelection": {"*": {"*": ["evm.legacyAssembly"]}}, "evmVersion": "cancun", "viaIR": false, "libraries": {}}}