{"language": "Solidity", "sources": {"src/SwapRouter.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {UniversalRouter} from \"@uniswap/universal-router/contracts/UniversalRouter.sol\";\nimport {IPermit2} from \"@uniswap/permit2/src/interfaces/IPermit2.sol\";\nimport {IAllowanceTransfer} from \"@uniswap/permit2/src/interfaces/IAllowanceTransfer.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\ninterface IWETH9 {\n    function deposit() external payable;\n    function withdraw(uint256) external;\n    function transfer(address, uint256) external returns (bool);\n}\n\ncontract ZiaSwapRouter is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    UniversalRouter public immutable router;\n    address public immutable feeCollector;\n    IAllowanceTransfer public immutable permit2;\n\n    uint256 public constant ZIA_FEE_BPS = 9; // 0.09%\n\n    event SwapCompleted(\n        address indexed user,\n        address inputToken,\n        address outputToken,\n        uint256 amountIn,\n        uint256 amountOutAfterFee,\n        uint256 feeAmount\n    );\n\n    constructor(address payable _router, address _permit2, address _feeCollector) {\n        router = UniversalRouter(_router);\n        permit2 = IAllowanceTransfer(_permit2);\n        feeCollector = _feeCollector;\n    }\n\n    receive() external payable {}\n\n    function swapExactTokensForTokensWithPermit(\n        bytes calldata commands,\n        bytes[] calldata inputs,\n        address inputToken,\n        address outputToken,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        bool usePermit,\n        IAllowanceTransfer.PermitSingle calldata permitSingle,\n        bytes calldata signature\n    ) external payable nonReentrant returns (uint256 amountOut) {\n        bool isInputTokenNative = inputToken == address(0);\n\n        bool isOutputTokenNative = outputToken == address(0);\n\n        if (!isInputTokenNative) {\n            // Execute the Permit2 approval to this contract\n            if (usePermit) {\n                permit2.permit(msg.sender, permitSingle, signature);\n            }\n            require(amountIn <= type(uint160).max, \"Amount exceeds uint160\");\n            permit2.transferFrom(msg.sender, address(this), uint160(amountIn), inputToken);\n\n            // Reset approval to 0\n            IERC20(inputToken).approve(address(router), 0);\n\n            // Approve UniversalRouter to spend amount after fee\n            IERC20(inputToken).approve(address(router), amountIn);\n        } else {\n            require(msg.value == amountIn, \"ETH value mismatch\");\n        }\n\n        uint256 balanceBefore;\n\n        // Track output token balance before swap\n        if (!isOutputTokenNative) {\n            balanceBefore = IERC20(outputToken).balanceOf(address(this));\n        } else {\n            balanceBefore = address(this).balance;\n        }\n\n        if (!isInputTokenNative) {\n            IERC20(inputToken).safeTransfer(address(router), amountIn);\n\n            // Execute the swap via Universal Router\n            router.execute{value: msg.value}(commands, inputs, block.timestamp + 500);\n        } else {\n            router.execute{value: amountIn}(commands, inputs, block.timestamp + 500);\n        }\n\n        uint256 balanceAfter;\n\n        // Check how much output token was received\n        if (!isOutputTokenNative) {\n            balanceAfter = IERC20(outputToken).balanceOf(address(this));\n        } else {\n            balanceAfter = address(this).balance;\n        }\n\n        amountOut = balanceAfter - balanceBefore;\n        require(amountOut >= minAmountOut, \"Slippage: too little received\");\n\n        // Take Zia fee (fixed 0.09%)\n        uint256 feeAmount = (amountOut * ZIA_FEE_BPS) / 10000;\n        uint256 amountOutAfterFee = amountOut - feeAmount;\n\n        if (!isOutputTokenNative) {\n            // Transfer fee to feeCollector\n            IERC20(outputToken).safeTransfer(feeCollector, feeAmount);\n\n            // Send output tokens to the user\n            IERC20(outputToken).safeTransfer(msg.sender, amountOutAfterFee);\n        } else {\n            (bool feeSent,) = feeCollector.call{value: feeAmount}(\"\");\n            require(feeSent, \"Fee transfer failed\");\n\n            (bool success,) = msg.sender.call{value: amountOutAfterFee}(\"\");\n            require(success, \"ETH transfer failed\");\n        }\n\n        emit SwapCompleted(msg.sender, inputToken, outputToken, amountIn, minAmountOut, amountOutAfterFee);\n    }\n\n    function multiSwapExactTokensForTokensWithPermit(\n        bytes[] calldata commandsList,\n        bytes[][] calldata inputsList,\n        address[] calldata inputTokens,\n        address[] calldata outputTokens,\n        uint256[] calldata inputAmounts,\n        bool[] calldata usePermits,\n        IAllowanceTransfer.PermitSingle[] calldata permitSingles,\n        bytes[] calldata signatures\n    ) external payable nonReentrant returns (uint256 amountOut) {\n        require(\n            inputTokens.length == inputAmounts.length && inputTokens.length == outputTokens.length\n                && inputTokens.length == commandsList.length && inputTokens.length == inputsList.length\n                && inputTokens.length == usePermits.length && inputTokens.length == permitSingles.length\n                && inputTokens.length == signatures.length,\n            \"ZiaRouter: array length mismatch\"\n        );\n\n        address[] memory seenTokens = new address[](inputTokens.length);\n        uint256 seenCount = 0;\n\n        for (uint256 i = 0; i < inputTokens.length; ++i) {\n            address inToken = inputTokens[i];\n            address outToken = outputTokens[i];\n            uint256 amountIn = inputAmounts[i];\n\n            // Check if this token has already had permit() called\n            bool alreadySeen = false;\n            for (uint256 j = 0; j < seenCount; ++j) {\n                if (seenTokens[j] == inToken) {\n                    alreadySeen = true;\n                    break;\n                }\n            }\n\n            if (usePermits[i] && !alreadySeen) {\n                permit2.permit(msg.sender, permitSingles[i], signatures[i]);\n                seenTokens[seenCount++] = inToken;\n            }\n\n            require(amountIn <= type(uint160).max, \"Amount exceeds uint160\");\n            permit2.transferFrom(msg.sender, address(this), uint160(amountIn), inToken);\n\n            IERC20(inToken).approve(address(router), 0);\n            IERC20(inToken).approve(address(router), amountIn);\n\n            uint256 balanceBefore = IERC20(outToken).balanceOf(address(this));\n\n            IERC20(inToken).safeTransfer(address(router), amountIn);\n\n            router.execute{value: msg.value}(commandsList[i], inputsList[i], block.timestamp + 500);\n\n            uint256 balanceAfter = IERC20(outToken).balanceOf(address(this));\n            amountOut = balanceAfter - balanceBefore;\n\n            uint256 feeAmount = (amountOut * ZIA_FEE_BPS) / 10000;\n            uint256 amountOutAfterFee = amountOut - feeAmount;\n\n            IERC20(outToken).safeTransfer(feeCollector, feeAmount);\n            IERC20(outToken).safeTransfer(msg.sender, amountOutAfterFee);\n\n            emit SwapCompleted(msg.sender, inToken, outToken, amountIn, amountOutAfterFee, feeAmount);\n        }\n    }\n}\n"}, "lib/universal-router/contracts/UniversalRouter.sol": {"content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.30;\n\n// Command implementations\nimport {Dispatcher} from './base/Dispatcher.sol';\nimport {RouterParameters} from './types/RouterParameters.sol';\nimport {PaymentsImmutables, PaymentsParameters} from './modules/PaymentsImmutables.sol';\nimport {UniswapImmutables, UniswapParameters} from './modules/uniswap/UniswapImmutables.sol';\nimport {V4SwapRouter} from './modules/uniswap/v4/V4SwapRouter.sol';\nimport {Commands} from './libraries/Commands.sol';\nimport {IUniversalRouter} from './interfaces/IUniversalRouter.sol';\nimport {MigratorImmutables, MigratorParameters} from './modules/MigratorImmutables.sol';\n\ncontract UniversalRouter is IUniversalRouter, Dispatcher {\n    constructor(RouterParameters memory params)\n        UniswapImmutables(\n            UniswapParameters(params.v2Factory, params.v3Factory, params.pairInitCodeHash, params.poolInitCodeHash)\n        )\n        V4SwapRouter(params.v4PoolManager)\n        PaymentsImmutables(PaymentsParameters(params.permit2, params.weth9))\n        MigratorImmutables(MigratorParameters(params.v3NFTPositionManager, params.v4PositionManager))\n    {}\n\n    modifier checkDeadline(uint256 deadline) {\n        if (block.timestamp > deadline) revert TransactionDeadlinePassed();\n        _;\n    }\n\n    /// @notice To receive ETH from WETH\n    receive() external payable {\n        if (msg.sender != address(WETH9) && msg.sender != address(poolManager)) revert InvalidEthSender();\n    }\n\n    /// @inheritdoc IUniversalRouter\n    function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline)\n        external\n        payable\n        checkDeadline(deadline)\n    {\n        execute(commands, inputs);\n    }\n\n    /// @inheritdoc Dispatcher\n    function execute(bytes calldata commands, bytes[] calldata inputs) public payable override isNotLocked {\n        bool success;\n        bytes memory output;\n        uint256 numCommands = commands.length;\n        if (inputs.length != numCommands) revert LengthMismatch();\n\n        // loop through all given commands, execute them and pass along outputs as defined\n        for (uint256 commandIndex = 0; commandIndex < numCommands; commandIndex++) {\n            bytes1 command = commands[commandIndex];\n\n            bytes calldata input = inputs[commandIndex];\n\n            (success, output) = dispatch(command, input);\n\n            if (!success && successRequired(command)) {\n                revert ExecutionFailed({commandIndex: commandIndex, message: output});\n            }\n        }\n    }\n\n    function successRequired(bytes1 command) internal pure returns (bool) {\n        return command & Commands.FLAG_ALLOW_REVERT == 0;\n    }\n}\n"}, "lib/permit2/src/interfaces/IPermit2.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {ISignatureTransfer} from \"./ISignatureTransfer.sol\";\nimport {IAllowanceTransfer} from \"./IAllowanceTransfer.sol\";\n\n/// @notice Permit2 handles signature-based transfers in SignatureTransfer and allowance-based transfers in AllowanceTransfer.\n/// @dev Users must approve Permit2 before calling any of the transfer functions.\ninterface IPermit2 is ISignatureTransfer, IAllowanceTransfer {\n// IPermit2 unifies the two interfaces so users have maximal flexibility with their approval.\n}\n"}, "lib/permit2/src/interfaces/IAllowanceTransfer.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IEIP712} from \"./IEIP712.sol\";\n\n/// @title AllowanceTransfer\n/// @notice Handles ERC20 token permissions through signature based allowance setting and ERC20 token transfers by checking allowed amounts\n/// @dev Requires user's token approval on the Permit2 contract\ninterface IAllowanceTransfer is IEIP712 {\n    /// @notice Thrown when an allowance on a token has expired.\n    /// @param deadline The timestamp at which the allowed amount is no longer valid\n    error AllowanceExpired(uint256 deadline);\n\n    /// @notice Thrown when an allowance on a token has been depleted.\n    /// @param amount The maximum amount allowed\n    error InsufficientAllowance(uint256 amount);\n\n    /// @notice Thrown when too many nonces are invalidated.\n    error ExcessiveInvalidation();\n\n    /// @notice Emits an event when the owner successfully invalidates an ordered nonce.\n    event NonceInvalidation(\n        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce\n    );\n\n    /// @notice Emits an event when the owner successfully sets permissions on a token for the spender.\n    event Approval(\n        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration\n    );\n\n    /// @notice Emits an event when the owner successfully sets permissions using a permit signature on a token for the spender.\n    event Permit(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 nonce\n    );\n\n    /// @notice Emits an event when the owner sets the allowance back to 0 with the lockdown function.\n    event Lockdown(address indexed owner, address token, address spender);\n\n    /// @notice The permit data for a token\n    struct PermitDetails {\n        // ERC20 token address\n        address token;\n        // the maximum amount allowed to spend\n        uint160 amount;\n        // timestamp at which a spender's token allowances become invalid\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n\n    /// @notice The permit message signed for a single token allowance\n    struct PermitSingle {\n        // the permit data for a single token alownce\n        PermitDetails details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n\n    /// @notice The permit message signed for multiple token allowances\n    struct PermitBatch {\n        // the permit data for multiple token allowances\n        PermitDetails[] details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n\n    /// @notice The saved permissions\n    /// @dev This info is saved per owner, per token, per spender and all signed over in the permit message\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\n    struct PackedAllowance {\n        // amount allowed\n        uint160 amount;\n        // permission expiry\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n\n    /// @notice A token spender pair.\n    struct TokenSpenderPair {\n        // the token the spender is approved\n        address token;\n        // the spender address\n        address spender;\n    }\n\n    /// @notice Details for a token transfer.\n    struct AllowanceTransferDetails {\n        // the owner of the token\n        address from;\n        // the recipient of the token\n        address to;\n        // the amount of the token\n        uint160 amount;\n        // the token to be transferred\n        address token;\n    }\n\n    /// @notice A mapping from owner address to token address to spender address to PackedAllowance struct, which contains details and conditions of the approval.\n    /// @notice The mapping is indexed in the above order see: allowance[ownerAddress][tokenAddress][spenderAddress]\n    /// @dev The packed slot holds the allowed amount, expiration at which the allowed amount is no longer valid, and current nonce thats updated on any signature based approvals.\n    function allowance(address user, address token, address spender)\n        external\n        view\n        returns (uint160 amount, uint48 expiration, uint48 nonce);\n\n    /// @notice Approves the spender to use up to amount of the specified token up until the expiration\n    /// @param token The token to approve\n    /// @param spender The spender address to approve\n    /// @param amount The approved amount of the token\n    /// @param expiration The timestamp at which the approval is no longer valid\n    /// @dev The packed allowance also holds a nonce, which will stay unchanged in approve\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n\n    /// @notice Permit a spender to a given amount of the owners token via the owner's EIP-712 signature\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\n    /// @param owner The owner of the tokens being approved\n    /// @param permitSingle Data signed over by the owner specifying the terms of approval\n    /// @param signature The owner's signature over the permit data\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n\n    /// @notice Permit a spender to the signed amounts of the owners tokens via the owner's EIP-712 signature\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\n    /// @param owner The owner of the tokens being approved\n    /// @param permitBatch Data signed over by the owner specifying the terms of approval\n    /// @param signature The owner's signature over the permit data\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n\n    /// @notice Transfer approved tokens from one address to another\n    /// @param from The address to transfer from\n    /// @param to The address of the recipient\n    /// @param amount The amount of the token to transfer\n    /// @param token The token address to transfer\n    /// @dev Requires the from address to have approved at least the desired amount\n    /// of tokens to msg.sender.\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n\n    /// @notice Transfer approved tokens in a batch\n    /// @param transferDetails Array of owners, recipients, amounts, and tokens for the transfers\n    /// @dev Requires the from addresses to have approved at least the desired amount\n    /// of tokens to msg.sender.\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n\n    /// @notice Enables performing a \"lockdown\" of the sender's Permit2 identity\n    /// by batch revoking approvals\n    /// @param approvals Array of approvals to revoke.\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\n\n    /// @notice Invalidate nonces for a given (token, spender) pair\n    /// @param token The token to invalidate nonces for\n    /// @param spender The spender to invalidate nonces for\n    /// @param newNonce The new nonce to set. Invalidates all nonces less than it.\n    /// @dev Can't invalidate more than 2**16 nonces per transaction.\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\n}\n"}, "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"}, "lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"}, "lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"}, "lib/universal-router/contracts/base/Dispatcher.sol": {"content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.30;\n\nimport {V2SwapRouter} from '../modules/uniswap/v2/V2SwapRouter.sol';\nimport {V3SwapRouter} from '../modules/uniswap/v3/V3SwapRouter.sol';\nimport {V4SwapRouter} from '../modules/uniswap/v4/V4SwapRouter.sol';\nimport {BytesLib} from '../modules/uniswap/v3/BytesLib.sol';\nimport {Payments} from '../modules/Payments.sol';\nimport {PaymentsImmutables} from '../modules/PaymentsImmutables.sol';\nimport {V3ToV4Migrator} from '../modules/V3ToV4Migrator.sol';\nimport {Commands} from '../libraries/Commands.sol';\nimport {Lock} from './Lock.sol';\nimport {ERC20} from 'solmate/src/tokens/ERC20.sol';\nimport {IAllowanceTransfer} from 'permit2/src/interfaces/IAllowanceTransfer.sol';\nimport {ActionConstants} from '@uniswap/v4-periphery/src/libraries/ActionConstants.sol';\nimport {CalldataDecoder} from '@uniswap/v4-periphery/src/libraries/CalldataDecoder.sol';\nimport {PoolKey} from '@uniswap/v4-core/src/types/PoolKey.sol';\nimport {IPoolManager} from '@uniswap/v4-core/src/interfaces/IPoolManager.sol';\n\n/// @title Decodes and Executes Commands\n/// @notice Called by the UniversalRouter contract to efficiently decode and execute a singular command\nabstract contract Dispatcher is Payments, V2SwapRouter, V3SwapRouter, V4SwapRouter, V3ToV4Migrator, Lock {\n    using BytesLib for bytes;\n    using CalldataDecoder for bytes;\n\n    error InvalidCommandType(uint256 commandType);\n    error BalanceTooLow();\n\n    /// @notice Executes encoded commands along with provided inputs.\n    /// @param commands A set of concatenated commands, each 1 byte in length\n    /// @param inputs An array of byte strings containing abi encoded inputs for each command\n    function execute(bytes calldata commands, bytes[] calldata inputs) external payable virtual;\n\n    /// @notice Public view function to be used instead of msg.sender, as the contract performs self-reentrancy and at\n    /// times msg.sender == address(this). Instead msgSender() returns the initiator of the lock\n    /// @dev overrides BaseActionsRouter.msgSender in V4Router\n    function msgSender() public view override returns (address) {\n        return _getLocker();\n    }\n\n    /// @notice Decodes and executes the given command with the given inputs\n    /// @param commandType The command type to execute\n    /// @param inputs The inputs to execute the command with\n    /// @dev 2 masks are used to enable use of a nested-if statement in execution for efficiency reasons\n    /// @return success True on success of the command, false on failure\n    /// @return output The outputs or error messages, if any, from the command\n    function dispatch(bytes1 commandType, bytes calldata inputs) internal returns (bool success, bytes memory output) {\n        uint256 command = uint8(commandType & Commands.COMMAND_TYPE_MASK);\n\n        success = true;\n\n        // 0x00 <= command < 0x21\n        if (command < Commands.EXECUTE_SUB_PLAN) {\n            // 0x00 <= command < 0x10\n            if (command < Commands.V4_SWAP) {\n                // 0x00 <= command < 0x08\n                if (command < Commands.V2_SWAP_EXACT_IN) {\n                    if (command == Commands.V3_SWAP_EXACT_IN) {\n                        // equivalent: abi.decode(inputs, (address, uint256, uint256, bytes, bool))\n                        address recipient;\n                        uint256 amountIn;\n                        uint256 amountOutMin;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountIn := calldataload(add(inputs.offset, 0x20))\n                            amountOutMin := calldataload(add(inputs.offset, 0x40))\n                            // 0x60 offset is the path, decoded below\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        bytes calldata path = inputs.toBytes(3);\n                        address payer = payerIsUser ? msgSender() : address(this);\n                        v3SwapExactInput(map(recipient), amountIn, amountOutMin, path, payer);\n                    } else if (command == Commands.V3_SWAP_EXACT_OUT) {\n                        // equivalent: abi.decode(inputs, (address, uint256, uint256, bytes, bool))\n                        address recipient;\n                        uint256 amountOut;\n                        uint256 amountInMax;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountOut := calldataload(add(inputs.offset, 0x20))\n                            amountInMax := calldataload(add(inputs.offset, 0x40))\n                            // 0x60 offset is the path, decoded below\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        bytes calldata path = inputs.toBytes(3);\n                        address payer = payerIsUser ? msgSender() : address(this);\n                        v3SwapExactOutput(map(recipient), amountOut, amountInMax, path, payer);\n                    } else if (command == Commands.PERMIT2_TRANSFER_FROM) {\n                        // equivalent: abi.decode(inputs, (address, address, uint160))\n                        address token;\n                        address recipient;\n                        uint160 amount;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            amount := calldataload(add(inputs.offset, 0x40))\n                        }\n                        permit2TransferFrom(token, msgSender(), map(recipient), amount);\n                    } else if (command == Commands.PERMIT2_PERMIT_BATCH) {\n                        IAllowanceTransfer.PermitBatch calldata permitBatch;\n                        assembly {\n                            // this is a variable length struct, so calldataload(inputs.offset) contains the\n                            // offset from inputs.offset at which the struct begins\n                            permitBatch := add(inputs.offset, calldataload(inputs.offset))\n                        }\n                        bytes calldata data = inputs.toBytes(1);\n                        (success, output) = address(PERMIT2).call(\n                            abi.encodeWithSignature(\n                                'permit(address,((address,uint160,uint48,uint48)[],address,uint256),bytes)',\n                                msgSender(),\n                                permitBatch,\n                                data\n                            )\n                        );\n                    } else if (command == Commands.SWEEP) {\n                        // equivalent:  abi.decode(inputs, (address, address, uint256))\n                        address token;\n                        address recipient;\n                        uint160 amountMin;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            amountMin := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.sweep(token, map(recipient), amountMin);\n                    } else if (command == Commands.TRANSFER) {\n                        // equivalent:  abi.decode(inputs, (address, address, uint256))\n                        address token;\n                        address recipient;\n                        uint256 value;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            value := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.pay(token, map(recipient), value);\n                    } else if (command == Commands.PAY_PORTION) {\n                        // equivalent:  abi.decode(inputs, (address, address, uint256))\n                        address token;\n                        address recipient;\n                        uint256 bips;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            bips := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.payPortion(token, map(recipient), bips);\n                    } else {\n                        // placeholder area for command 0x07\n                        revert InvalidCommandType(command);\n                    }\n                } else {\n                    // 0x08 <= command < 0x10\n                    if (command == Commands.V2_SWAP_EXACT_IN) {\n                        // equivalent: abi.decode(inputs, (address, uint256, uint256, bytes, bool))\n                        address recipient;\n                        uint256 amountIn;\n                        uint256 amountOutMin;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountIn := calldataload(add(inputs.offset, 0x20))\n                            amountOutMin := calldataload(add(inputs.offset, 0x40))\n                            // 0x60 offset is the path, decoded below\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        address[] calldata path = inputs.toAddressArray(3);\n                        address payer = payerIsUser ? msgSender() : address(this);\n                        v2SwapExactInput(map(recipient), amountIn, amountOutMin, path, payer);\n                    } else if (command == Commands.V2_SWAP_EXACT_OUT) {\n                        // equivalent: abi.decode(inputs, (address, uint256, uint256, bytes, bool))\n                        address recipient;\n                        uint256 amountOut;\n                        uint256 amountInMax;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountOut := calldataload(add(inputs.offset, 0x20))\n                            amountInMax := calldataload(add(inputs.offset, 0x40))\n                            // 0x60 offset is the path, decoded below\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        address[] calldata path = inputs.toAddressArray(3);\n                        address payer = payerIsUser ? msgSender() : address(this);\n                        v2SwapExactOutput(map(recipient), amountOut, amountInMax, path, payer);\n                    } else if (command == Commands.PERMIT2_PERMIT) {\n                        // equivalent: abi.decode(inputs, (IAllowanceTransfer.PermitSingle, bytes))\n                        IAllowanceTransfer.PermitSingle calldata permitSingle;\n                        assembly {\n                            permitSingle := inputs.offset\n                        }\n                        bytes calldata data = inputs.toBytes(6); // PermitSingle takes first 6 slots (0..5)\n                        (success, output) = address(PERMIT2).call(\n                            abi.encodeWithSignature(\n                                'permit(address,((address,uint160,uint48,uint48),address,uint256),bytes)',\n                                msgSender(),\n                                permitSingle,\n                                data\n                            )\n                        );\n                    } else if (command == Commands.WRAP_ETH) {\n                        // equivalent: abi.decode(inputs, (address, uint256))\n                        address recipient;\n                        uint256 amount;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amount := calldataload(add(inputs.offset, 0x20))\n                        }\n                        Payments.wrapETH(map(recipient), amount);\n                    } else if (command == Commands.UNWRAP_WETH) {\n                        // equivalent: abi.decode(inputs, (address, uint256))\n                        address recipient;\n                        uint256 amountMin;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountMin := calldataload(add(inputs.offset, 0x20))\n                        }\n                        Payments.unwrapWETH9(map(recipient), amountMin);\n                    } else if (command == Commands.PERMIT2_TRANSFER_FROM_BATCH) {\n                        IAllowanceTransfer.AllowanceTransferDetails[] calldata batchDetails;\n                        (uint256 length, uint256 offset) = inputs.toLengthOffset(0);\n                        assembly {\n                            batchDetails.length := length\n                            batchDetails.offset := offset\n                        }\n                        permit2TransferFrom(batchDetails, msgSender());\n                    } else if (command == Commands.BALANCE_CHECK_ERC20) {\n                        // equivalent: abi.decode(inputs, (address, address, uint256))\n                        address owner;\n                        address token;\n                        uint256 minBalance;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            minBalance := calldataload(add(inputs.offset, 0x40))\n                        }\n                        success = (ERC20(token).balanceOf(owner) >= minBalance);\n                        if (!success) output = abi.encodePacked(BalanceTooLow.selector);\n                    } else {\n                        // placeholder area for command 0x0f\n                        revert InvalidCommandType(command);\n                    }\n                }\n            } else {\n                // 0x10 <= command < 0x21\n                if (command == Commands.V4_SWAP) {\n                    // pass the calldata provided to V4SwapRouter._executeActions (defined in BaseActionsRouter)\n                    _executeActions(inputs);\n                    // This contract MUST be approved to spend the token since its going to be doing the call on the position manager\n                } else if (command == Commands.V3_POSITION_MANAGER_PERMIT) {\n                    _checkV3PermitCall(inputs);\n                    (success, output) = address(V3_POSITION_MANAGER).call(inputs);\n                } else if (command == Commands.V3_POSITION_MANAGER_CALL) {\n                    _checkV3PositionManagerCall(inputs, msgSender());\n                    (success, output) = address(V3_POSITION_MANAGER).call(inputs);\n                } else if (command == Commands.V4_INITIALIZE_POOL) {\n                    PoolKey calldata poolKey;\n                    uint160 sqrtPriceX96;\n                    assembly {\n                        poolKey := inputs.offset\n                        sqrtPriceX96 := calldataload(add(inputs.offset, 0xa0))\n                    }\n                    (success, output) =\n                        address(poolManager).call(abi.encodeCall(IPoolManager.initialize, (poolKey, sqrtPriceX96)));\n                } else if (command == Commands.V4_POSITION_MANAGER_CALL) {\n                    // should only call modifyLiquidities() to mint\n                    _checkV4PositionManagerCall(inputs);\n                    (success, output) = address(V4_POSITION_MANAGER).call{value: address(this).balance}(inputs);\n                } else {\n                    // placeholder area for commands 0x15-0x20\n                    revert InvalidCommandType(command);\n                }\n            }\n        } else {\n            // 0x21 <= command\n            if (command == Commands.EXECUTE_SUB_PLAN) {\n                (bytes calldata _commands, bytes[] calldata _inputs) = inputs.decodeCommandsAndInputs();\n                (success, output) = (address(this)).call(abi.encodeCall(Dispatcher.execute, (_commands, _inputs)));\n            } else {\n                // placeholder area for commands 0x22-0x3f\n                revert InvalidCommandType(command);\n            }\n        }\n    }\n\n    /// @notice Calculates the recipient address for a command\n    /// @param recipient The recipient or recipient-flag for the command\n    /// @return output The resultant recipient for the command\n    function map(address recipient) internal view returns (address) {\n        if (recipient == ActionConstants.MSG_SENDER) {\n            return msgSender();\n        } else if (recipient == ActionConstants.ADDRESS_THIS) {\n            return address(this);\n        } else {\n            return recipient;\n        }\n    }\n}\n"}, "lib/universal-router/contracts/types/RouterParameters.sol": {"content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.30;\n\nstruct RouterParameters {\n    // Payment parameters\n    address permit2;\n    address weth9;\n    // Uniswap swapping parameters\n    address v2Factory;\n    address v3Factory;\n    bytes32 pairInitCodeHash;\n    bytes32 poolInitCodeHash;\n    address v4PoolManager;\n    // Uniswap v3->v4 migration parameters\n    address v3NFTPositionManager;\n    address v4PositionManager;\n}\n"}, "lib/universal-router/contracts/modules/PaymentsImmutables.sol": {"content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.30;\n\nimport {IWETH9} from '@uniswap/v4-periphery/src/interfaces/external/IWETH9.sol';\nimport {IPermit2} from 'permit2/src/interfaces/IPermit2.sol';\n\nstruct PaymentsParameters {\n    address permit2;\n    address weth9;\n}\n\ncontract PaymentsImmutables {\n    /// @notice WETH9 address\n    IWETH9 internal immutable WETH9;\n\n    /// @notice Permit2 address\n    IPermit2 internal immutable PERMIT2;\n\n    constructor(PaymentsParameters memory params) {\n        WETH9 = IWETH9(params.weth9);\n        PERMIT2 = IPermit2(params.permit2);\n    }\n}\n"}, "lib/universal-router/contracts/modules/uniswap/UniswapImmutables.sol": {"content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.30;\n\nstruct UniswapParameters {\n    address v2Factory;\n    address v3Factory;\n    bytes32 pairInitCodeHash;\n    bytes32 poolInitCodeHash;\n}\n\ncontract UniswapImmutables {\n    /// @notice The address of UniswapV2Factory\n    address internal immutable UNISWAP_V2_FACTORY;\n\n    /// @notice The UniswapV2Pair initcodehash\n    bytes32 internal immutable UNISWAP_V2_PAIR_INIT_CODE_HASH;\n\n    /// @notice The address of UniswapV3Factory\n    address internal immutable UNISWAP_V3_FACTORY;\n\n    /// @notice The UniswapV3Pool initcodehash\n    bytes32 internal immutable UNISWAP_V3_POOL_INIT_CODE_HASH;\n\n    constructor(UniswapParameters memory params) {\n        UNISWAP_V2_FACTORY = params.v2Factory;\n        UNISWAP_V2_PAIR_INIT_CODE_HASH = params.pairInitCodeHash;\n        UNISWAP_V3_FACTORY = params.v3Factory;\n        UNISWAP_V3_POOL_INIT_CODE_HASH = params.poolInitCodeHash;\n    }\n}\n"}, "lib/universal-router/contracts/modules/uniswap/v4/V4SwapRouter.sol": {"content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.30;\n\nimport {UniswapImmutables} from '../UniswapImmutables.sol';\nimport {Permit2Payments} from '../../Permit2Payments.sol';\nimport {V4Router} from '@uniswap/v4-periphery/src/V4Router.sol';\nimport {IPoolManager} from '@uniswap/v4-core/src/interfaces/IPoolManager.sol';\nimport {Currency} from '@uniswap/v4-core/src/types/Currency.sol';\n\n/// @title Router for Uniswap v4 Trades\nabstract contract V4SwapRouter is V4Router, Permit2Payments {\n    constructor(address _poolManager) V4Router(IPoolManager(_poolManager)) {}\n\n    function _pay(Currency token, address payer, uint256 amount) internal override {\n        payOrPermit2Transfer(Currency.unwrap(token), payer, address(poolManager), amount);\n    }\n}\n"}, "lib/universal-router/contracts/libraries/Commands.sol": {"content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.30;\n\n/// @title Commands\n/// @notice Command Flags used to decode commands\nlibrary Commands {\n    // Masks to extract certain bits of commands\n    bytes1 internal constant FLAG_ALLOW_REVERT = 0x80;\n    bytes1 internal constant COMMAND_TYPE_MASK = 0x3f;\n\n    // Command Types. Maximum supported command at this moment is 0x3f.\n    // The commands are executed in nested if blocks to minimise gas consumption\n\n    // Command Types where value<=0x07, executed in the first nested-if block\n    uint256 constant V3_SWAP_EXACT_IN = 0x00;\n    uint256 constant V3_SWAP_EXACT_OUT = 0x01;\n    uint256 constant PERMIT2_TRANSFER_FROM = 0x02;\n    uint256 constant PERMIT2_PERMIT_BATCH = 0x03;\n    uint256 constant SWEEP = 0x04;\n    uint256 constant TRANSFER = 0x05;\n    uint256 constant PAY_PORTION = 0x06;\n    // COMMAND_PLACEHOLDER = 0x07;\n\n    // Command Types where 0x08<=value<=0x0f, executed in the second nested-if block\n    uint256 constant V2_SWAP_EXACT_IN = 0x08;\n    uint256 constant V2_SWAP_EXACT_OUT = 0x09;\n    uint256 constant PERMIT2_PERMIT = 0x0a;\n    uint256 constant WRAP_ETH = 0x0b;\n    uint256 constant UNWRAP_WETH = 0x0c;\n    uint256 constant PERMIT2_TRANSFER_FROM_BATCH = 0x0d;\n    uint256 constant BALANCE_CHECK_ERC20 = 0x0e;\n    // COMMAND_PLACEHOLDER = 0x0f;\n\n    // Command Types where 0x10<=value<=0x20, executed in the third nested-if block\n    uint256 constant V4_SWAP = 0x10;\n    uint256 constant V3_POSITION_MANAGER_PERMIT = 0x11;\n    uint256 constant V3_POSITION_MANAGER_CALL = 0x12;\n    uint256 constant V4_INITIALIZE_POOL = 0x13;\n    uint256 constant V4_POSITION_MANAGER_CALL = 0x14;\n    // COMMAND_PLACEHOLDER = 0x15 -> 0x20\n\n    // Command Types where 0x21<=value<=0x3f\n    uint256 constant EXECUTE_SUB_PLAN = 0x21;\n    // COMMAND_PLACEHOLDER for 0x22 to 0x3f\n}\n"}, "lib/universal-router/contracts/interfaces/IUniversalRouter.sol": {"content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.30;\n\ninterface IUniversalRouter {\n    /// @notice Thrown when a required command has failed\n    error ExecutionFailed(uint256 commandIndex, bytes message);\n\n    /// @notice Thrown when attempting to send ETH directly to the contract\n    error ETHNotAccepted();\n\n    /// @notice Thrown when executing commands with an expired deadline\n    error TransactionDeadlinePassed();\n\n    /// @notice Thrown when attempting to execute commands and an incorrect number of inputs are provided\n    error LengthMismatch();\n\n    // @notice Thrown when an address that isn't WETH tries to send ETH to the router without calldata\n    error InvalidEthSender();\n\n    /// @notice Executes encoded commands along with provided inputs. Reverts if deadline has expired.\n    /// @param commands A set of concatenated commands, each 1 byte in length\n    /// @param inputs An array of byte strings containing abi encoded inputs for each command\n    /// @param deadline The deadline by which the transaction must be executed\n    function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline) external payable;\n}\n"}, "lib/universal-router/contracts/modules/MigratorImmutables.sol": {"content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.30;\n\nimport {INonfungiblePositionManager} from '@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol';\nimport {IPositionManager} from '@uniswap/v4-periphery/src/interfaces/IPositionManager.sol';\nimport {IPoolManager} from '@uniswap/v4-core/src/interfaces/IPoolManager.sol';\n\nstruct MigratorParameters {\n    address v3PositionManager;\n    address v4PositionManager;\n}\n\n/// @title Migrator Immutables\n/// @notice Immutable state for liquidity-migration contracts\ncontract MigratorImmutables {\n    /// @notice v3 PositionManager address\n    INonfungiblePositionManager public immutable V3_POSITION_MANAGER;\n    /// @notice v4 PositionManager address\n    IPositionManager public immutable V4_POSITION_MANAGER;\n\n    constructor(MigratorParameters memory params) {\n        V3_POSITION_MANAGER = INonfungiblePositionManager(params.v3PositionManager);\n        V4_POSITION_MANAGER = IPositionManager(params.v4PositionManager);\n    }\n}\n"}, "lib/permit2/src/interfaces/ISignatureTransfer.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IEIP712} from \"./IEIP712.sol\";\n\n/// @title SignatureTransfer\n/// @notice Handles ERC20 token transfers through signature based actions\n/// @dev Requires user's token approval on the Permit2 contract\ninterface ISignatureTransfer is IEIP712 {\n    /// @notice Thrown when the requested amount for a transfer is larger than the permissioned amount\n    /// @param maxAmount The maximum amount a spender can request to transfer\n    error InvalidAmount(uint256 maxAmount);\n\n    /// @notice Thrown when the number of tokens permissioned to a spender does not match the number of tokens being transferred\n    /// @dev If the spender does not need to transfer the number of tokens permitted, the spender can request amount 0 to be transferred\n    error LengthMismatch();\n\n    /// @notice Emits an event when the owner successfully invalidates an unordered nonce.\n    event UnorderedNonceInvalidation(address indexed owner, uint256 word, uint256 mask);\n\n    /// @notice The token and amount details for a transfer signed in the permit transfer signature\n    struct TokenPermissions {\n        // ERC20 token address\n        address token;\n        // the maximum amount that can be spent\n        uint256 amount;\n    }\n\n    /// @notice The signed permit message for a single token transfer\n    struct PermitTransferFrom {\n        TokenPermissions permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice Specifies the recipient address and amount for batched transfers.\n    /// @dev Recipients and amounts correspond to the index of the signed token permissions array.\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount.\n    struct SignatureTransferDetails {\n        // recipient address\n        address to;\n        // spender requested amount\n        uint256 requestedAmount;\n    }\n\n    /// @notice Used to reconstruct the signed permit message for multiple token transfers\n    /// @dev Do not need to pass in spender address as it is required that it is msg.sender\n    /// @dev Note that a user still signs over a spender address\n    struct PermitBatchTransferFrom {\n        // the tokens and corresponding amounts permitted for a transfer\n        TokenPermissions[] permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice A map from token owner address and a caller specified word index to a bitmap. Used to set bits in the bitmap to prevent against signature replay protection\n    /// @dev Uses unordered nonces so that permit messages do not need to be spent in a certain order\n    /// @dev The mapping is indexed first by the token owner, then by an index specified in the nonce\n    /// @dev It returns a uint256 bitmap\n    /// @dev The index, or wordPosition is capped at type(uint248).max\n    function nonceBitmap(address, uint256) external view returns (uint256);\n\n    /// @notice Transfers a token using a signed permit message\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers a token using a signed permit message\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Invalidates the bits specified in mask for the bitmap at the word position\n    /// @dev The wordPos is maxed at type(uint248).max\n    /// @param wordPos A number to index the nonceBitmap at\n    /// @param mask A bitmap masked against msg.sender's current bitmap at the word position\n    function invalidateUnorderedNonces(uint256 wordPos, uint256 mask) external;\n}\n"}, "lib/permit2/src/interfaces/IEIP712.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IEIP712 {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"}, "lib/openzeppelin-contracts/contracts/interfaces/IERC1363.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"}, "lib/universal-router/contracts/modules/uniswap/v2/V2SwapRouter.sol": {"content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.30;\n\nimport {IUniswapV2Pair} from '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\nimport {UniswapV2Library} from './UniswapV2Library.sol';\nimport {UniswapImmutables} from '../UniswapImmutables.sol';\nimport {Permit2Payments} from '../../Permit2Payments.sol';\nimport {Constants} from '../../../libraries/Constants.sol';\nimport {ERC20} from 'solmate/src/tokens/ERC20.sol';\n\n/// @title Router for Uniswap v2 Trades\nabstract contract V2SwapRouter is UniswapImmutables, Permit2Payments {\n    error V2TooLittleReceived();\n    error V2TooMuchRequested();\n    error V2InvalidPath();\n\n    function _v2Swap(address[] calldata path, address recipient, address pair) private {\n        unchecked {\n            if (path.length < 2) revert V2InvalidPath();\n\n            // cached to save on duplicate operations\n            (address token0,) = UniswapV2Library.sortTokens(path[0], path[1]);\n            uint256 finalPairIndex = path.length - 1;\n            uint256 penultimatePairIndex = finalPairIndex - 1;\n            for (uint256 i; i < finalPairIndex; i++) {\n                (address input, address output) = (path[i], path[i + 1]);\n                (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n                (uint256 reserveInput, uint256 reserveOutput) =\n                    input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                uint256 amountInput = ERC20(input).balanceOf(pair) - reserveInput;\n                uint256 amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n                (uint256 amount0Out, uint256 amount1Out) =\n                    input == token0 ? (uint256(0), amountOutput) : (amountOutput, uint256(0));\n                address nextPair;\n                (nextPair, token0) = i < penultimatePairIndex\n                    ? UniswapV2Library.pairAndToken0For(\n                        UNISWAP_V2_FACTORY, UNISWAP_V2_PAIR_INIT_CODE_HASH, output, path[i + 2]\n                    )\n                    : (recipient, address(0));\n                IUniswapV2Pair(pair).swap(amount0Out, amount1Out, nextPair, new bytes(0));\n                pair = nextPair;\n            }\n        }\n    }\n\n    /// @notice Performs a Uniswap v2 exact input swap\n    /// @param recipient The recipient of the output tokens\n    /// @param amountIn The amount of input tokens for the trade\n    /// @param amountOutMinimum The minimum desired amount of output tokens\n    /// @param path The path of the trade as an array of token addresses\n    /// @param payer The address that will be paying the input\n    function v2SwapExactInput(\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        address[] calldata path,\n        address payer\n    ) internal {\n        address firstPair =\n            UniswapV2Library.pairFor(UNISWAP_V2_FACTORY, UNISWAP_V2_PAIR_INIT_CODE_HASH, path[0], path[1]);\n        if (\n            amountIn != Constants.ALREADY_PAID // amountIn of 0 to signal that the pair already has the tokens\n        ) {\n            payOrPermit2Transfer(path[0], payer, firstPair, amountIn);\n        }\n\n        ERC20 tokenOut = ERC20(path[path.length - 1]);\n        uint256 balanceBefore = tokenOut.balanceOf(recipient);\n\n        _v2Swap(path, recipient, firstPair);\n\n        uint256 amountOut = tokenOut.balanceOf(recipient) - balanceBefore;\n        if (amountOut < amountOutMinimum) revert V2TooLittleReceived();\n    }\n\n    /// @notice Performs a Uniswap v2 exact output swap\n    /// @param recipient The recipient of the output tokens\n    /// @param amountOut The amount of output tokens to receive for the trade\n    /// @param amountInMaximum The maximum desired amount of input tokens\n    /// @param path The path of the trade as an array of token addresses\n    /// @param payer The address that will be paying the input\n    function v2SwapExactOutput(\n        address recipient,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address[] calldata path,\n        address payer\n    ) internal {\n        (uint256 amountIn, address firstPair) =\n            UniswapV2Library.getAmountInMultihop(UNISWAP_V2_FACTORY, UNISWAP_V2_PAIR_INIT_CODE_HASH, amountOut, path);\n        if (amountIn > amountInMaximum) revert V2TooMuchRequested();\n\n        payOrPermit2Transfer(path[0], payer, firstPair, amountIn);\n        _v2Swap(path, recipient, firstPair);\n    }\n}\n"}, "lib/universal-router/contracts/modules/uniswap/v3/V3SwapRouter.sol": {"content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.30;\n\nimport {V3Path} from './V3Path.sol';\nimport {BytesLib} from './BytesLib.sol';\nimport {SafeCast} from '@uniswap/v3-core/contracts/libraries/SafeCast.sol';\nimport {IUniswapV3Pool} from '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\nimport {IUniswapV3SwapCallback} from '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\nimport {ActionConstants} from '@uniswap/v4-periphery/src/libraries/ActionConstants.sol';\nimport {CalldataDecoder} from '@uniswap/v4-periphery/src/libraries/CalldataDecoder.sol';\nimport {Permit2Payments} from '../../Permit2Payments.sol';\nimport {UniswapImmutables} from '../UniswapImmutables.sol';\nimport {MaxInputAmount} from '../../../libraries/MaxInputAmount.sol';\nimport {ERC20} from 'solmate/src/tokens/ERC20.sol';\n\n/// @title Router for Uniswap v3 Trades\nabstract contract V3SwapRouter is UniswapImmutables, Permit2Payments, IUniswapV3SwapCallback {\n    using V3Path for bytes;\n    using BytesLib for bytes;\n    using CalldataDecoder for bytes;\n    using SafeCast for uint256;\n\n    error V3InvalidSwap();\n    error V3TooLittleReceived();\n    error V3TooMuchRequested();\n    error V3InvalidAmountOut();\n    error V3InvalidCaller();\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external {\n        if (amount0Delta <= 0 && amount1Delta <= 0) revert V3InvalidSwap(); // swaps entirely within 0-liquidity regions are not supported\n        (, address payer) = abi.decode(data, (bytes, address));\n        bytes calldata path = data.toBytes(0);\n\n        // because exact output swaps are executed in reverse order, in this case tokenOut is actually tokenIn\n        (address tokenIn, uint24 fee, address tokenOut) = path.decodeFirstPool();\n\n        if (computePoolAddress(tokenIn, tokenOut, fee) != msg.sender) revert V3InvalidCaller();\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0 ? (tokenIn < tokenOut, uint256(amount0Delta)) : (tokenOut < tokenIn, uint256(amount1Delta));\n\n        if (isExactInput) {\n            // Pay the pool (msg.sender)\n            payOrPermit2Transfer(tokenIn, payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (path.hasMultiplePools()) {\n                // this is an intermediate step so the payer is actually this contract\n                path = path.skipToken();\n                _swap(-amountToPay.toInt256(), msg.sender, path, payer, false);\n            } else {\n                if (amountToPay > MaxInputAmount.get()) revert V3TooMuchRequested();\n                // note that because exact output swaps are executed in reverse order, tokenOut is actually tokenIn\n                payOrPermit2Transfer(tokenOut, payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    /// @notice Performs a Uniswap v3 exact input swap\n    /// @param recipient The recipient of the output tokens\n    /// @param amountIn The amount of input tokens for the trade\n    /// @param amountOutMinimum The minimum desired amount of output tokens\n    /// @param path The path of the trade as a bytes string\n    /// @param payer The address that will be paying the input\n    function v3SwapExactInput(\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        bytes calldata path,\n        address payer\n    ) internal {\n        // use amountIn == ActionConstants.CONTRACT_BALANCE as a flag to swap the entire balance of the contract\n        if (amountIn == ActionConstants.CONTRACT_BALANCE) {\n            address tokenIn = path.decodeFirstToken();\n            amountIn = ERC20(tokenIn).balanceOf(address(this));\n        }\n\n        uint256 amountOut;\n        while (true) {\n            bool hasMultiplePools = path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            (int256 amount0Delta, int256 amount1Delta, bool zeroForOne) = _swap(\n                amountIn.toInt256(),\n                hasMultiplePools ? address(this) : recipient, // for intermediate swaps, this contract custodies\n                path.getFirstPool(), // only the first pool is needed\n                payer, // for intermediate swaps, this contract custodies\n                true\n            );\n\n            amountIn = uint256(-(zeroForOne ? amount1Delta : amount0Delta));\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this);\n                path = path.skipToken();\n            } else {\n                amountOut = amountIn;\n                break;\n            }\n        }\n\n        if (amountOut < amountOutMinimum) revert V3TooLittleReceived();\n    }\n\n    /// @notice Performs a Uniswap v3 exact output swap\n    /// @param recipient The recipient of the output tokens\n    /// @param amountOut The amount of output tokens to receive for the trade\n    /// @param amountInMaximum The maximum desired amount of input tokens\n    /// @param path The path of the trade as a bytes string\n    /// @param payer The address that will be paying the input\n    function v3SwapExactOutput(\n        address recipient,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        bytes calldata path,\n        address payer\n    ) internal {\n        MaxInputAmount.set(amountInMaximum);\n        (int256 amount0Delta, int256 amount1Delta, bool zeroForOne) =\n            _swap(-amountOut.toInt256(), recipient, path, payer, false);\n\n        uint256 amountOutReceived = zeroForOne ? uint256(-amount1Delta) : uint256(-amount0Delta);\n\n        if (amountOutReceived != amountOut) revert V3InvalidAmountOut();\n\n        MaxInputAmount.set(0);\n    }\n\n    /// @dev Performs a single swap for both exactIn and exactOut\n    /// For exactIn, `amount` is `amountIn`. For exactOut, `amount` is `-amountOut`\n    function _swap(int256 amount, address recipient, bytes calldata path, address payer, bool isExactIn)\n        private\n        returns (int256 amount0Delta, int256 amount1Delta, bool zeroForOne)\n    {\n        (address tokenIn, uint24 fee, address tokenOut) = path.decodeFirstPool();\n\n        zeroForOne = isExactIn ? tokenIn < tokenOut : tokenOut < tokenIn;\n\n        (amount0Delta, amount1Delta) = IUniswapV3Pool(computePoolAddress(tokenIn, tokenOut, fee)).swap(\n            recipient,\n            zeroForOne,\n            amount,\n            (zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1),\n            abi.encode(path, payer)\n        );\n    }\n\n    function computePoolAddress(address tokenA, address tokenB, uint24 fee) private view returns (address pool) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            UNISWAP_V3_FACTORY,\n                            keccak256(abi.encode(tokenA, tokenB, fee)),\n                            UNISWAP_V3_POOL_INIT_CODE_HASH\n                        )\n                    )\n                )\n            )\n        );\n    }\n}\n"}, "lib/universal-router/contracts/modules/uniswap/v3/BytesLib.sol": {"content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/// @title Library for Bytes Manipulation\npragma solidity ^0.8.30;\n\nimport {Constants} from '../../../libraries/Constants.sol';\nimport {CalldataDecoder} from '@uniswap/v4-periphery/src/libraries/CalldataDecoder.sol';\n\nlibrary BytesLib {\n    using CalldataDecoder for bytes;\n\n    error SliceOutOfBounds();\n\n    /// @notice Returns the address starting at byte 0\n    /// @dev length and overflow checks must be carried out before calling\n    /// @param _bytes The input bytes string to slice\n    /// @return _address The address starting at byte 0\n    function toAddress(bytes calldata _bytes) internal pure returns (address _address) {\n        if (_bytes.length < Constants.ADDR_SIZE) revert SliceOutOfBounds();\n        assembly {\n            _address := shr(96, calldataload(_bytes.offset))\n        }\n    }\n\n    /// @notice Returns the pool details starting at byte 0\n    /// @dev length and overflow checks must be carried out before calling\n    /// @param _bytes The input bytes string to slice\n    /// @return token0 The address at byte 0\n    /// @return fee The uint24 starting at byte 20\n    /// @return token1 The address at byte 23\n    function toPool(bytes calldata _bytes) internal pure returns (address token0, uint24 fee, address token1) {\n        if (_bytes.length < Constants.V3_POP_OFFSET) revert SliceOutOfBounds();\n        assembly {\n            let firstWord := calldataload(_bytes.offset)\n            token0 := shr(96, firstWord)\n            fee := and(shr(72, firstWord), 0xffffff)\n            token1 := shr(96, calldataload(add(_bytes.offset, 23)))\n        }\n    }\n\n    /// @notice Decode the `_arg`-th element in `_bytes` as a dynamic array\n    /// @dev The decoding of `length` and `offset` is universal,\n    /// whereas the type declaration of `res` instructs the compiler how to read it.\n    /// @param _bytes The input bytes string to slice\n    /// @param _arg The index of the argument to extract\n    /// @return length Length of the array\n    /// @return offset Pointer to the data part of the array\n    function toLengthOffset(bytes calldata _bytes, uint256 _arg)\n        internal\n        pure\n        returns (uint256 length, uint256 offset)\n    {\n        uint256 relativeOffset;\n        assembly {\n            // The offset of the `_arg`-th element is `32 * arg`, which stores the offset of the length pointer.\n            // shl(5, x) is equivalent to mul(32, x)\n            let lengthPtr := add(_bytes.offset, calldataload(add(_bytes.offset, shl(5, _arg))))\n            length := calldataload(lengthPtr)\n            offset := add(lengthPtr, 0x20)\n            relativeOffset := sub(offset, _bytes.offset)\n        }\n        if (_bytes.length < length + relativeOffset) revert SliceOutOfBounds();\n    }\n\n    /// @notice Decode the `_arg`-th element in `_bytes` as `address[]`\n    /// @param _bytes The input bytes string to extract an address array from\n    /// @param _arg The index of the argument to extract\n    function toAddressArray(bytes calldata _bytes, uint256 _arg) internal pure returns (address[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n\n    /// @notice Equivalent to abi.decode(bytes, bytes[])\n    /// @param _bytes The input bytes string to extract an parameters from\n    function decodeCommandsAndInputs(bytes calldata _bytes) internal pure returns (bytes calldata, bytes[] calldata) {\n        return _bytes.decodeActionsRouterParams();\n    }\n}\n"}, "lib/universal-router/contracts/modules/Payments.sol": {"content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.30;\n\nimport {Constants} from '../libraries/Constants.sol';\nimport {ActionConstants} from '@uniswap/v4-periphery/src/libraries/ActionConstants.sol';\nimport {BipsLibrary} from '@uniswap/v4-periphery/src/libraries/BipsLibrary.sol';\nimport {PaymentsImmutables} from '../modules/PaymentsImmutables.sol';\nimport {SafeTransferLib} from 'solmate/src/utils/SafeTransferLib.sol';\nimport {ERC20} from 'solmate/src/tokens/ERC20.sol';\n\n/// @title Payments contract\n/// @notice Performs various operations around the payment of ETH and tokens\nabstract contract Payments is PaymentsImmutables {\n    using SafeTransferLib for ERC20;\n    using SafeTransferLib for address;\n    using BipsLibrary for uint256;\n\n    error InsufficientToken();\n    error InsufficientETH();\n\n    /// @notice Pays an amount of ETH or ERC20 to a recipient\n    /// @param token The token to pay (can be ETH using Constants.ETH)\n    /// @param recipient The address that will receive the payment\n    /// @param value The amount to pay\n    function pay(address token, address recipient, uint256 value) internal {\n        if (token == Constants.ETH) {\n            recipient.safeTransferETH(value);\n        } else {\n            if (value == ActionConstants.CONTRACT_BALANCE) {\n                value = ERC20(token).balanceOf(address(this));\n            }\n\n            ERC20(token).safeTransfer(recipient, value);\n        }\n    }\n\n    /// @notice Pays a proportion of the contract's ETH or ERC20 to a recipient\n    /// @param token The token to pay (can be ETH using Constants.ETH)\n    /// @param recipient The address that will receive payment\n    /// @param bips Portion in bips of whole balance of the contract\n    function payPortion(address token, address recipient, uint256 bips) internal {\n        if (token == Constants.ETH) {\n            uint256 balance = address(this).balance;\n            uint256 amount = balance.calculatePortion(bips);\n            recipient.safeTransferETH(amount);\n        } else {\n            uint256 balance = ERC20(token).balanceOf(address(this));\n            uint256 amount = balance.calculatePortion(bips);\n            ERC20(token).safeTransfer(recipient, amount);\n        }\n    }\n\n    /// @notice Sweeps all of the contract's ERC20 or ETH to an address\n    /// @param token The token to sweep (can be ETH using Constants.ETH)\n    /// @param recipient The address that will receive payment\n    /// @param amountMinimum The minimum desired amount\n    function sweep(address token, address recipient, uint256 amountMinimum) internal {\n        uint256 balance;\n        if (token == Constants.ETH) {\n            balance = address(this).balance;\n            if (balance < amountMinimum) revert InsufficientETH();\n            if (balance > 0) recipient.safeTransferETH(balance);\n        } else {\n            balance = ERC20(token).balanceOf(address(this));\n            if (balance < amountMinimum) revert InsufficientToken();\n            if (balance > 0) ERC20(token).safeTransfer(recipient, balance);\n        }\n    }\n\n    /// @notice Wraps an amount of ETH into WETH\n    /// @param recipient The recipient of the WETH\n    /// @param amount The amount to wrap (can be CONTRACT_BALANCE)\n    function wrapETH(address recipient, uint256 amount) internal {\n        if (amount == ActionConstants.CONTRACT_BALANCE) {\n            amount = address(this).balance;\n        } else if (amount > address(this).balance) {\n            revert InsufficientETH();\n        }\n        if (amount > 0) {\n            WETH9.deposit{value: amount}();\n            if (recipient != address(this)) {\n                WETH9.transfer(recipient, amount);\n            }\n        }\n    }\n\n    /// @notice Unwraps all of the contract's WETH into ETH\n    /// @param recipient The recipient of the ETH\n    /// @param amountMinimum The minimum amount of ETH desired\n    function unwrapWETH9(address recipient, uint256 amountMinimum) internal {\n        uint256 value = WETH9.balanceOf(address(this));\n        if (value < amountMinimum) {\n            revert InsufficientETH();\n        }\n        if (value > 0) {\n            WETH9.withdraw(value);\n            if (recipient != address(this)) {\n                recipient.safeTransferETH(value);\n            }\n        }\n    }\n}\n"}, "lib/universal-router/contracts/modules/V3ToV4Migrator.sol": {"content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.30;\n\nimport {MigratorImmutables} from '../modules/MigratorImmutables.sol';\nimport {INonfungiblePositionManager} from '@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol';\nimport {Actions} from '@uniswap/v4-periphery/src/libraries/Actions.sol';\nimport {IERC721Permit} from '@uniswap/v3-periphery/contracts/interfaces/IERC721Permit.sol';\nimport {CalldataDecoder} from '@uniswap/v4-periphery/src/libraries/CalldataDecoder.sol';\n\n/// @title V3 to V4 Migrator\n/// @notice A contract that migrates liquidity from Uniswap V3 to V4\nabstract contract V3ToV4Migrator is MigratorImmutables {\n    using CalldataDecoder for bytes;\n\n    error InvalidAction(bytes4 action);\n    error OnlyMintAllowed();\n    error NotAuthorizedForToken(uint256 tokenId);\n\n    /// @dev validate if an action is decreaseLiquidity, collect, or burn\n    function _isValidAction(bytes4 selector) private pure returns (bool) {\n        return selector == INonfungiblePositionManager.decreaseLiquidity.selector\n            || selector == INonfungiblePositionManager.collect.selector\n            || selector == INonfungiblePositionManager.burn.selector;\n    }\n\n    /// @dev the caller is authorized for the token if its the owner, spender, or operator\n    function _isAuthorizedForToken(address caller, uint256 tokenId) private view returns (bool) {\n        address owner = V3_POSITION_MANAGER.ownerOf(tokenId);\n        return caller == owner || V3_POSITION_MANAGER.getApproved(tokenId) == caller\n            || V3_POSITION_MANAGER.isApprovedForAll(owner, caller);\n    }\n\n    /// @dev check that a call is to the ERC721 permit function\n    function _checkV3PermitCall(bytes calldata inputs) internal pure {\n        bytes4 selector;\n        assembly {\n            selector := calldataload(inputs.offset)\n        }\n\n        if (selector != IERC721Permit.permit.selector) {\n            revert InvalidAction(selector);\n        }\n    }\n\n    /// @dev check that the v3 position manager call is a safe call\n    function _checkV3PositionManagerCall(bytes calldata inputs, address caller) internal view {\n        bytes4 selector;\n        assembly {\n            selector := calldataload(inputs.offset)\n        }\n\n        if (!_isValidAction(selector)) {\n            revert InvalidAction(selector);\n        }\n\n        uint256 tokenId;\n        assembly {\n            // tokenId is always the first parameter in the valid actions\n            tokenId := calldataload(add(inputs.offset, 0x04))\n        }\n        // If any other address that is not the owner wants to call this function, it also needs to be approved (in addition to this contract)\n        // This can be done in 2 ways:\n        //    1. This contract is permitted for the specific token and the caller is approved for ALL of the owner's tokens\n        //    2. This contract is permitted for ALL of the owner's tokens and the caller is permitted for the specific token\n        if (!_isAuthorizedForToken(caller, tokenId)) {\n            revert NotAuthorizedForToken(tokenId);\n        }\n    }\n\n    /// @dev check that the v4 position manager call is a safe call\n    /// of the position-altering Actions, we only allow Actions.MINT\n    /// this is because, if a user could be tricked into approving the UniversalRouter for\n    /// their position, an attacker could take their fees, or drain their entire position\n    function _checkV4PositionManagerCall(bytes calldata inputs) internal view {\n        bytes4 selector;\n        assembly {\n            selector := calldataload(inputs.offset)\n        }\n        if (selector != V4_POSITION_MANAGER.modifyLiquidities.selector) {\n            revert InvalidAction(selector);\n        }\n\n        // slice is `abi.encode(bytes unlockData, uint256 deadline)`\n        bytes calldata slice = inputs[4:];\n        // the first bytes(0) extracts the unlockData parameter from modifyLiquidities\n        // unlockData = `abi.encode(bytes actions, bytes[] params)`\n        // the second bytes(0) extracts the actions parameter from unlockData\n        bytes calldata actions = slice.toBytes(0).toBytes(0);\n\n        uint256 numActions = actions.length;\n\n        for (uint256 actionIndex = 0; actionIndex < numActions; actionIndex++) {\n            uint256 action = uint8(actions[actionIndex]);\n\n            if (\n                action == Actions.INCREASE_LIQUIDITY || action == Actions.DECREASE_LIQUIDITY\n                    || action == Actions.BURN_POSITION\n            ) {\n                revert OnlyMintAllowed();\n            }\n        }\n    }\n}\n"}, "lib/universal-router/contracts/base/Lock.sol": {"content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.30;\n\nimport {Locker} from '../libraries/Locker.sol';\n\n/// @title Lock\n/// @notice A contract that provides a reentrancy lock for external calls\ncontract Lock {\n    /// @notice Thrown when attempting to reenter a locked function from an external caller\n    error ContractLocked();\n\n    /// @notice Modifier enforcing a reentrancy lock that allows self-reentrancy\n    /// @dev If the contract is not locked, use msg.sender as the locker\n    modifier isNotLocked() {\n        // Apply a reentrancy lock for all external callers\n        if (msg.sender != address(this)) {\n            if (Locker.isLocked()) revert ContractLocked();\n            Locker.set(msg.sender);\n            _;\n            Locker.set(address(0));\n        } else {\n            // The contract is allowed to reenter itself, so the lock is not checked\n            _;\n        }\n    }\n\n    /// @notice return the current locker of the contract\n    function _getLocker() internal view returns (address) {\n        return Locker.get();\n    }\n}\n"}, "lib/solmate/src/tokens/ERC20.sol": {"content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.30;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"}, "lib/v4-periphery/src/libraries/ActionConstants.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title Action Constants\n/// @notice Common constants used in actions\n/// @dev Constants are gas efficient alternatives to their literal values\nlibrary ActionConstants {\n    /// @notice used to signal that an action should use the input value of the open delta on the pool manager\n    /// or of the balance that the contract holds\n    uint128 internal constant OPEN_DELTA = 0;\n    /// @notice used to signal that an action should use the contract's entire balance of a currency\n    /// This value is equivalent to 1<<255, i.e. a singular 1 in the most significant bit.\n    uint256 internal constant CONTRACT_BALANCE = 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n    /// @notice used to signal that the recipient of an action should be the msgSender\n    address internal constant MSG_SENDER = address(1);\n\n    /// @notice used to signal that the recipient of an action should be the address(this)\n    address internal constant ADDRESS_THIS = address(2);\n}\n"}, "lib/v4-periphery/src/libraries/CalldataDecoder.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Currency} from \"@uniswap/v4-core/src/types/Currency.sol\";\nimport {IV4Router} from \"../interfaces/IV4Router.sol\";\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\n\n/// @title Library for abi decoding in calldata\nlibrary CalldataDecoder {\n    using CalldataDecoder for bytes;\n\n    error SliceOutOfBounds();\n\n    /// @notice mask used for offsets and lengths to ensure no overflow\n    /// @dev no sane abi encoding will pass in an offset or length greater than type(uint32).max\n    ///      (note that this does deviate from standard solidity behavior and offsets/lengths will\n    ///      be interpreted as mod type(uint32).max which will only impact malicious/buggy callers)\n    uint256 constant OFFSET_OR_LENGTH_MASK = 0xffffffff;\n    uint256 constant OFFSET_OR_LENGTH_MASK_AND_WORD_ALIGN = 0xffffffe0;\n\n    /// @notice equivalent to SliceOutOfBounds.selector, stored in least-significant bits\n    uint256 constant SLICE_ERROR_SELECTOR = 0x3b99b53d;\n\n    /// @dev equivalent to: abi.decode(params, (bytes, bytes[])) in calldata (requires strict abi encoding)\n    function decodeActionsRouterParams(bytes calldata _bytes)\n        internal\n        pure\n        returns (bytes calldata actions, bytes[] calldata params)\n    {\n        assembly (\"memory-safe\") {\n            // Strict encoding requires that the data begin with:\n            // 0x00: 0x40 (offset to `actions.length`)\n            // 0x20: 0x60 + actions.length (offset to `params.length`)\n            // 0x40: `actions.length`\n            // 0x60: beginning of actions\n\n            // Verify actions offset matches strict encoding\n            let invalidData := xor(calldataload(_bytes.offset), 0x40)\n            actions.offset := add(_bytes.offset, 0x60)\n            actions.length := and(calldataload(add(_bytes.offset, 0x40)), OFFSET_OR_LENGTH_MASK)\n\n            // Round actions length up to be word-aligned, and add 0x60 (for the first 3 words of encoding)\n            let paramsLengthOffset := add(and(add(actions.length, 0x1f), OFFSET_OR_LENGTH_MASK_AND_WORD_ALIGN), 0x60)\n            // Verify params offset matches strict encoding\n            invalidData := or(invalidData, xor(calldataload(add(_bytes.offset, 0x20)), paramsLengthOffset))\n            let paramsLengthPointer := add(_bytes.offset, paramsLengthOffset)\n            params.length := and(calldataload(paramsLengthPointer), OFFSET_OR_LENGTH_MASK)\n            params.offset := add(paramsLengthPointer, 0x20)\n\n            // Expected offset for `params[0]` is params.length * 32\n            // As the first `params.length` slots are pointers to each of the array element lengths\n            let tailOffset := shl(5, params.length)\n            let expectedOffset := tailOffset\n\n            for { let offset := 0 } lt(offset, tailOffset) { offset := add(offset, 32) } {\n                let itemLengthOffset := calldataload(add(params.offset, offset))\n                // Verify that the offset matches the expected offset from strict encoding\n                invalidData := or(invalidData, xor(itemLengthOffset, expectedOffset))\n                let itemLengthPointer := add(params.offset, itemLengthOffset)\n                let length :=\n                    add(and(add(calldataload(itemLengthPointer), 0x1f), OFFSET_OR_LENGTH_MASK_AND_WORD_ALIGN), 0x20)\n                expectedOffset := add(expectedOffset, length)\n            }\n\n            // if the data encoding was invalid, or the provided bytes string isnt as long as the encoding says, revert\n            if or(invalidData, lt(add(_bytes.length, _bytes.offset), add(params.offset, expectedOffset))) {\n                mstore(0, SLICE_ERROR_SELECTOR)\n                revert(0x1c, 4)\n            }\n        }\n    }\n\n    /// @dev equivalent to: abi.decode(params, (uint256, uint256, uint128, uint128, bytes)) in calldata\n    function decodeModifyLiquidityParams(bytes calldata params)\n        internal\n        pure\n        returns (uint256 tokenId, uint256 liquidity, uint128 amount0, uint128 amount1, bytes calldata hookData)\n    {\n        // no length check performed, as there is a length check in `toBytes`\n        assembly (\"memory-safe\") {\n            tokenId := calldataload(params.offset)\n            liquidity := calldataload(add(params.offset, 0x20))\n            amount0 := calldataload(add(params.offset, 0x40))\n            amount1 := calldataload(add(params.offset, 0x60))\n        }\n\n        hookData = params.toBytes(4);\n    }\n\n    /// @dev equivalent to: abi.decode(params, (uint256, uint128, uint128, bytes)) in calldata\n    function decodeIncreaseLiquidityFromDeltasParams(bytes calldata params)\n        internal\n        pure\n        returns (uint256 tokenId, uint128 amount0Max, uint128 amount1Max, bytes calldata hookData)\n    {\n        // no length check performed, as there is a length check in `toBytes`\n        assembly (\"memory-safe\") {\n            tokenId := calldataload(params.offset)\n            amount0Max := calldataload(add(params.offset, 0x20))\n            amount1Max := calldataload(add(params.offset, 0x40))\n        }\n\n        hookData = params.toBytes(3);\n    }\n\n    /// @dev equivalent to: abi.decode(params, (PoolKey, int24, int24, uint256, uint128, uint128, address, bytes)) in calldata\n    function decodeMintParams(bytes calldata params)\n        internal\n        pure\n        returns (\n            PoolKey calldata poolKey,\n            int24 tickLower,\n            int24 tickUpper,\n            uint256 liquidity,\n            uint128 amount0Max,\n            uint128 amount1Max,\n            address owner,\n            bytes calldata hookData\n        )\n    {\n        // no length check performed, as there is a length check in `toBytes`\n        assembly (\"memory-safe\") {\n            poolKey := params.offset\n            tickLower := calldataload(add(params.offset, 0xa0))\n            tickUpper := calldataload(add(params.offset, 0xc0))\n            liquidity := calldataload(add(params.offset, 0xe0))\n            amount0Max := calldataload(add(params.offset, 0x100))\n            amount1Max := calldataload(add(params.offset, 0x120))\n            owner := calldataload(add(params.offset, 0x140))\n        }\n        hookData = params.toBytes(11);\n    }\n\n    /// @dev equivalent to: abi.decode(params, (PoolKey, int24, int24, uint128, uint128, address, bytes)) in calldata\n    function decodeMintFromDeltasParams(bytes calldata params)\n        internal\n        pure\n        returns (\n            PoolKey calldata poolKey,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 amount0Max,\n            uint128 amount1Max,\n            address owner,\n            bytes calldata hookData\n        )\n    {\n        // no length check performed, as there is a length check in `toBytes`\n        assembly (\"memory-safe\") {\n            poolKey := params.offset\n            tickLower := calldataload(add(params.offset, 0xa0))\n            tickUpper := calldataload(add(params.offset, 0xc0))\n            amount0Max := calldataload(add(params.offset, 0xe0))\n            amount1Max := calldataload(add(params.offset, 0x100))\n            owner := calldataload(add(params.offset, 0x120))\n        }\n\n        hookData = params.toBytes(10);\n    }\n\n    /// @dev equivalent to: abi.decode(params, (uint256, uint128, uint128, bytes)) in calldata\n    function decodeBurnParams(bytes calldata params)\n        internal\n        pure\n        returns (uint256 tokenId, uint128 amount0Min, uint128 amount1Min, bytes calldata hookData)\n    {\n        // no length check performed, as there is a length check in `toBytes`\n        assembly (\"memory-safe\") {\n            tokenId := calldataload(params.offset)\n            amount0Min := calldataload(add(params.offset, 0x20))\n            amount1Min := calldataload(add(params.offset, 0x40))\n        }\n\n        hookData = params.toBytes(3);\n    }\n\n    /// @dev equivalent to: abi.decode(params, (IV4Router.ExactInputParams))\n    function decodeSwapExactInParams(bytes calldata params)\n        internal\n        pure\n        returns (IV4Router.ExactInputParams calldata swapParams)\n    {\n        // ExactInputParams is a variable length struct so we just have to look up its location\n        assembly (\"memory-safe\") {\n            // only safety checks for the minimum length, where path is empty\n            // 0xa0 = 5 * 0x20 -> 3 elements, path offset, and path length 0\n            if lt(params.length, 0xa0) {\n                mstore(0, SLICE_ERROR_SELECTOR)\n                revert(0x1c, 4)\n            }\n            swapParams := add(params.offset, calldataload(params.offset))\n        }\n    }\n\n    /// @dev equivalent to: abi.decode(params, (IV4Router.ExactInputSingleParams))\n    function decodeSwapExactInSingleParams(bytes calldata params)\n        internal\n        pure\n        returns (IV4Router.ExactInputSingleParams calldata swapParams)\n    {\n        // ExactInputSingleParams is a variable length struct so we just have to look up its location\n        assembly (\"memory-safe\") {\n            // only safety checks for the minimum length, where hookData is empty\n            // 0x140 = 10 * 0x20 -> 8 elements, bytes offset, and bytes length 0\n            if lt(params.length, 0x140) {\n                mstore(0, SLICE_ERROR_SELECTOR)\n                revert(0x1c, 4)\n            }\n            swapParams := add(params.offset, calldataload(params.offset))\n        }\n    }\n\n    /// @dev equivalent to: abi.decode(params, (IV4Router.ExactOutputParams))\n    function decodeSwapExactOutParams(bytes calldata params)\n        internal\n        pure\n        returns (IV4Router.ExactOutputParams calldata swapParams)\n    {\n        // ExactOutputParams is a variable length struct so we just have to look up its location\n        assembly (\"memory-safe\") {\n            // only safety checks for the minimum length, where path is empty\n            // 0xa0 = 5 * 0x20 -> 3 elements, path offset, and path length 0\n            if lt(params.length, 0xa0) {\n                mstore(0, SLICE_ERROR_SELECTOR)\n                revert(0x1c, 4)\n            }\n            swapParams := add(params.offset, calldataload(params.offset))\n        }\n    }\n\n    /// @dev equivalent to: abi.decode(params, (IV4Router.ExactOutputSingleParams))\n    function decodeSwapExactOutSingleParams(bytes calldata params)\n        internal\n        pure\n        returns (IV4Router.ExactOutputSingleParams calldata swapParams)\n    {\n        // ExactOutputSingleParams is a variable length struct so we just have to look up its location\n        assembly (\"memory-safe\") {\n            // only safety checks for the minimum length, where hookData is empty\n            // 0x140 = 10 * 0x20 -> 8 elements, bytes offset, and bytes length 0\n            if lt(params.length, 0x140) {\n                mstore(0, SLICE_ERROR_SELECTOR)\n                revert(0x1c, 4)\n            }\n            swapParams := add(params.offset, calldataload(params.offset))\n        }\n    }\n\n    /// @dev equivalent to: abi.decode(params, (Currency)) in calldata\n    function decodeCurrency(bytes calldata params) internal pure returns (Currency currency) {\n        assembly (\"memory-safe\") {\n            if lt(params.length, 0x20) {\n                mstore(0, SLICE_ERROR_SELECTOR)\n                revert(0x1c, 4)\n            }\n            currency := calldataload(params.offset)\n        }\n    }\n\n    /// @dev equivalent to: abi.decode(params, (Currency, Currency)) in calldata\n    function decodeCurrencyPair(bytes calldata params) internal pure returns (Currency currency0, Currency currency1) {\n        assembly (\"memory-safe\") {\n            if lt(params.length, 0x40) {\n                mstore(0, SLICE_ERROR_SELECTOR)\n                revert(0x1c, 4)\n            }\n            currency0 := calldataload(params.offset)\n            currency1 := calldataload(add(params.offset, 0x20))\n        }\n    }\n\n    /// @dev equivalent to: abi.decode(params, (Currency, Currency, address)) in calldata\n    function decodeCurrencyPairAndAddress(bytes calldata params)\n        internal\n        pure\n        returns (Currency currency0, Currency currency1, address _address)\n    {\n        assembly (\"memory-safe\") {\n            if lt(params.length, 0x60) {\n                mstore(0, SLICE_ERROR_SELECTOR)\n                revert(0x1c, 4)\n            }\n            currency0 := calldataload(params.offset)\n            currency1 := calldataload(add(params.offset, 0x20))\n            _address := calldataload(add(params.offset, 0x40))\n        }\n    }\n\n    /// @dev equivalent to: abi.decode(params, (Currency, address)) in calldata\n    function decodeCurrencyAndAddress(bytes calldata params)\n        internal\n        pure\n        returns (Currency currency, address _address)\n    {\n        assembly (\"memory-safe\") {\n            if lt(params.length, 0x40) {\n                mstore(0, SLICE_ERROR_SELECTOR)\n                revert(0x1c, 4)\n            }\n            currency := calldataload(params.offset)\n            _address := calldataload(add(params.offset, 0x20))\n        }\n    }\n\n    /// @dev equivalent to: abi.decode(params, (Currency, address, uint256)) in calldata\n    function decodeCurrencyAddressAndUint256(bytes calldata params)\n        internal\n        pure\n        returns (Currency currency, address _address, uint256 amount)\n    {\n        assembly (\"memory-safe\") {\n            if lt(params.length, 0x60) {\n                mstore(0, SLICE_ERROR_SELECTOR)\n                revert(0x1c, 4)\n            }\n            currency := calldataload(params.offset)\n            _address := calldataload(add(params.offset, 0x20))\n            amount := calldataload(add(params.offset, 0x40))\n        }\n    }\n\n    /// @dev equivalent to: abi.decode(params, (Currency, uint256)) in calldata\n    function decodeCurrencyAndUint256(bytes calldata params)\n        internal\n        pure\n        returns (Currency currency, uint256 amount)\n    {\n        assembly (\"memory-safe\") {\n            if lt(params.length, 0x40) {\n                mstore(0, SLICE_ERROR_SELECTOR)\n                revert(0x1c, 4)\n            }\n            currency := calldataload(params.offset)\n            amount := calldataload(add(params.offset, 0x20))\n        }\n    }\n\n    /// @dev equivalent to: abi.decode(params, (uint256)) in calldata\n    function decodeUint256(bytes calldata params) internal pure returns (uint256 amount) {\n        assembly (\"memory-safe\") {\n            if lt(params.length, 0x20) {\n                mstore(0, SLICE_ERROR_SELECTOR)\n                revert(0x1c, 4)\n            }\n            amount := calldataload(params.offset)\n        }\n    }\n\n    /// @dev equivalent to: abi.decode(params, (Currency, uint256, bool)) in calldata\n    function decodeCurrencyUint256AndBool(bytes calldata params)\n        internal\n        pure\n        returns (Currency currency, uint256 amount, bool boolean)\n    {\n        assembly (\"memory-safe\") {\n            if lt(params.length, 0x60) {\n                mstore(0, SLICE_ERROR_SELECTOR)\n                revert(0x1c, 4)\n            }\n            currency := calldataload(params.offset)\n            amount := calldataload(add(params.offset, 0x20))\n            boolean := calldataload(add(params.offset, 0x40))\n        }\n    }\n\n    /// @notice Decode the `_arg`-th element in `_bytes` as `bytes`\n    /// @param _bytes The input bytes string to extract a bytes string from\n    /// @param _arg The index of the argument to extract\n    function toBytes(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes calldata res) {\n        uint256 length;\n        assembly (\"memory-safe\") {\n            // The offset of the `_arg`-th element is `32 * arg`, which stores the offset of the length pointer.\n            // shl(5, x) is equivalent to mul(32, x)\n            let lengthPtr :=\n                add(_bytes.offset, and(calldataload(add(_bytes.offset, shl(5, _arg))), OFFSET_OR_LENGTH_MASK))\n            // the number of bytes in the bytes string\n            length := and(calldataload(lengthPtr), OFFSET_OR_LENGTH_MASK)\n            // the offset where the bytes string begins\n            let offset := add(lengthPtr, 0x20)\n            // assign the return parameters\n            res.length := length\n            res.offset := offset\n\n            // if the provided bytes string isnt as long as the encoding says, revert\n            if lt(add(_bytes.length, _bytes.offset), add(length, offset)) {\n                mstore(0, SLICE_ERROR_SELECTOR)\n                revert(0x1c, 4)\n            }\n        }\n    }\n}\n"}, "lib/v4-core/src/types/PoolKey.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Currency} from \"./Currency.sol\";\nimport {IHooks} from \"../interfaces/IHooks.sol\";\nimport {PoolIdLibrary} from \"./PoolId.sol\";\n\nusing PoolIdLibrary for PoolKey global;\n\n/// @notice Returns the key for identifying a pool\nstruct PoolKey {\n    /// @notice The lower currency of the pool, sorted numerically\n    Currency currency0;\n    /// @notice The higher currency of the pool, sorted numerically\n    Currency currency1;\n    /// @notice The pool LP fee, capped at 1_000_000. If the highest bit is 1, the pool has a dynamic fee and must be exactly equal to 0x800000\n    uint24 fee;\n    /// @notice Ticks that involve positions must be a multiple of tick spacing\n    int24 tickSpacing;\n    /// @notice The hooks of the pool\n    IHooks hooks;\n}\n"}, "lib/v4-core/src/interfaces/IPoolManager.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Currency} from \"../types/Currency.sol\";\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {IHooks} from \"./IHooks.sol\";\nimport {IERC6909Claims} from \"./external/IERC6909Claims.sol\";\nimport {IProtocolFees} from \"./IProtocolFees.sol\";\nimport {BalanceDelta} from \"../types/BalanceDelta.sol\";\nimport {PoolId} from \"../types/PoolId.sol\";\nimport {IExtsload} from \"./IExtsload.sol\";\nimport {IExttload} from \"./IExttload.sol\";\n\n/// @notice Interface for the PoolManager\ninterface IPoolManager is IProtocolFees, IERC6909Claims, IExtsload, IExttload {\n    /// @notice Thrown when a currency is not netted out after the contract is unlocked\n    error CurrencyNotSettled();\n\n    /// @notice Thrown when trying to interact with a non-initialized pool\n    error PoolNotInitialized();\n\n    /// @notice Thrown when unlock is called, but the contract is already unlocked\n    error AlreadyUnlocked();\n\n    /// @notice Thrown when a function is called that requires the contract to be unlocked, but it is not\n    error ManagerLocked();\n\n    /// @notice Pools are limited to type(int16).max tickSpacing in #initialize, to prevent overflow\n    error TickSpacingTooLarge(int24 tickSpacing);\n\n    /// @notice Pools must have a positive non-zero tickSpacing passed to #initialize\n    error TickSpacingTooSmall(int24 tickSpacing);\n\n    /// @notice PoolKey must have currencies where address(currency0) < address(currency1)\n    error CurrenciesOutOfOrderOrEqual(address currency0, address currency1);\n\n    /// @notice Thrown when a call to updateDynamicLPFee is made by an address that is not the hook,\n    /// or on a pool that does not have a dynamic swap fee.\n    error UnauthorizedDynamicLPFeeUpdate();\n\n    /// @notice Thrown when trying to swap amount of 0\n    error SwapAmountCannotBeZero();\n\n    ///@notice Thrown when native currency is passed to a non native settlement\n    error NonzeroNativeValue();\n\n    /// @notice Thrown when `clear` is called with an amount that is not exactly equal to the open currency delta.\n    error MustClearExactPositiveDelta();\n\n    /// @notice Emitted when a new pool is initialized\n    /// @param id The abi encoded hash of the pool key struct for the new pool\n    /// @param currency0 The first currency of the pool by address sort order\n    /// @param currency1 The second currency of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param hooks The hooks contract address for the pool, or address(0) if none\n    /// @param sqrtPriceX96 The price of the pool on initialization\n    /// @param tick The initial tick of the pool corresponding to the initialized price\n    event Initialize(\n        PoolId indexed id,\n        Currency indexed currency0,\n        Currency indexed currency1,\n        uint24 fee,\n        int24 tickSpacing,\n        IHooks hooks,\n        uint160 sqrtPriceX96,\n        int24 tick\n    );\n\n    /// @notice Emitted when a liquidity position is modified\n    /// @param id The abi encoded hash of the pool key struct for the pool that was modified\n    /// @param sender The address that modified the pool\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param liquidityDelta The amount of liquidity that was added or removed\n    /// @param salt The extra data to make positions unique\n    event ModifyLiquidity(\n        PoolId indexed id, address indexed sender, int24 tickLower, int24 tickUpper, int256 liquidityDelta, bytes32 salt\n    );\n\n    /// @notice Emitted for swaps between currency0 and currency1\n    /// @param id The abi encoded hash of the pool key struct for the pool that was modified\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param amount0 The delta of the currency0 balance of the pool\n    /// @param amount1 The delta of the currency1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of the price of the pool after the swap\n    /// @param fee The swap fee in hundredths of a bip\n    event Swap(\n        PoolId indexed id,\n        address indexed sender,\n        int128 amount0,\n        int128 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick,\n        uint24 fee\n    );\n\n    /// @notice Emitted for donations\n    /// @param id The abi encoded hash of the pool key struct for the pool that was donated to\n    /// @param sender The address that initiated the donate call\n    /// @param amount0 The amount donated in currency0\n    /// @param amount1 The amount donated in currency1\n    event Donate(PoolId indexed id, address indexed sender, uint256 amount0, uint256 amount1);\n\n    /// @notice All interactions on the contract that account deltas require unlocking. A caller that calls `unlock` must implement\n    /// `IUnlockCallback(msg.sender).unlockCallback(data)`, where they interact with the remaining functions on this contract.\n    /// @dev The only functions callable without an unlocking are `initialize` and `updateDynamicLPFee`\n    /// @param data Any data to pass to the callback, via `IUnlockCallback(msg.sender).unlockCallback(data)`\n    /// @return The data returned by the call to `IUnlockCallback(msg.sender).unlockCallback(data)`\n    function unlock(bytes calldata data) external returns (bytes memory);\n\n    /// @notice Initialize the state for a given pool ID\n    /// @dev A swap fee totaling MAX_SWAP_FEE (100%) makes exact output swaps impossible since the input is entirely consumed by the fee\n    /// @param key The pool key for the pool to initialize\n    /// @param sqrtPriceX96 The initial square root price\n    /// @return tick The initial tick of the pool\n    function initialize(PoolKey memory key, uint160 sqrtPriceX96) external returns (int24 tick);\n\n    struct ModifyLiquidityParams {\n        // the lower and upper tick of the position\n        int24 tickLower;\n        int24 tickUpper;\n        // how to modify the liquidity\n        int256 liquidityDelta;\n        // a value to set if you want unique liquidity positions at the same range\n        bytes32 salt;\n    }\n\n    /// @notice Modify the liquidity for the given pool\n    /// @dev Poke by calling with a zero liquidityDelta\n    /// @param key The pool to modify liquidity in\n    /// @param params The parameters for modifying the liquidity\n    /// @param hookData The data to pass through to the add/removeLiquidity hooks\n    /// @return callerDelta The balance delta of the caller of modifyLiquidity. This is the total of both principal, fee deltas, and hook deltas if applicable\n    /// @return feesAccrued The balance delta of the fees generated in the liquidity range. Returned for informational purposes\n    /// @dev Note that feesAccrued can be artificially inflated by a malicious actor and integrators should be careful using the value\n    /// For pools with a single liquidity position, actors can donate to themselves to inflate feeGrowthGlobal (and consequently feesAccrued)\n    /// atomically donating and collecting fees in the same unlockCallback may make the inflated value more extreme\n    function modifyLiquidity(PoolKey memory key, ModifyLiquidityParams memory params, bytes calldata hookData)\n        external\n        returns (BalanceDelta callerDelta, BalanceDelta feesAccrued);\n\n    struct SwapParams {\n        /// Whether to swap token0 for token1 or vice versa\n        bool zeroForOne;\n        /// The desired input amount if negative (exactIn), or the desired output amount if positive (exactOut)\n        int256 amountSpecified;\n        /// The sqrt price at which, if reached, the swap will stop executing\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swap against the given pool\n    /// @param key The pool to swap in\n    /// @param params The parameters for swapping\n    /// @param hookData The data to pass through to the swap hooks\n    /// @return swapDelta The balance delta of the address swapping\n    /// @dev Swapping on low liquidity pools may cause unexpected swap amounts when liquidity available is less than amountSpecified.\n    /// Additionally note that if interacting with hooks that have the BEFORE_SWAP_RETURNS_DELTA_FLAG or AFTER_SWAP_RETURNS_DELTA_FLAG\n    /// the hook may alter the swap input/output. Integrators should perform checks on the returned swapDelta.\n    function swap(PoolKey memory key, SwapParams memory params, bytes calldata hookData)\n        external\n        returns (BalanceDelta swapDelta);\n\n    /// @notice Donate the given currency amounts to the in-range liquidity providers of a pool\n    /// @dev Calls to donate can be frontrun adding just-in-time liquidity, with the aim of receiving a portion donated funds.\n    /// Donors should keep this in mind when designing donation mechanisms.\n    /// @dev This function donates to in-range LPs at slot0.tick. In certain edge-cases of the swap algorithm, the `sqrtPrice` of\n    /// a pool can be at the lower boundary of tick `n`, but the `slot0.tick` of the pool is already `n - 1`. In this case a call to\n    /// `donate` would donate to tick `n - 1` (slot0.tick) not tick `n` (getTickAtSqrtPrice(slot0.sqrtPriceX96)).\n    /// Read the comments in `Pool.swap()` for more information about this.\n    /// @param key The key of the pool to donate to\n    /// @param amount0 The amount of currency0 to donate\n    /// @param amount1 The amount of currency1 to donate\n    /// @param hookData The data to pass through to the donate hooks\n    /// @return BalanceDelta The delta of the caller after the donate\n    function donate(PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)\n        external\n        returns (BalanceDelta);\n\n    /// @notice Writes the current ERC20 balance of the specified currency to transient storage\n    /// This is used to checkpoint balances for the manager and derive deltas for the caller.\n    /// @dev This MUST be called before any ERC20 tokens are sent into the contract, but can be skipped\n    /// for native tokens because the amount to settle is determined by the sent value.\n    /// However, if an ERC20 token has been synced and not settled, and the caller instead wants to settle\n    /// native funds, this function can be called with the native currency to then be able to settle the native currency\n    function sync(Currency currency) external;\n\n    /// @notice Called by the user to net out some value owed to the user\n    /// @dev Will revert if the requested amount is not available, consider using `mint` instead\n    /// @dev Can also be used as a mechanism for free flash loans\n    /// @param currency The currency to withdraw from the pool manager\n    /// @param to The address to withdraw to\n    /// @param amount The amount of currency to withdraw\n    function take(Currency currency, address to, uint256 amount) external;\n\n    /// @notice Called by the user to pay what is owed\n    /// @return paid The amount of currency settled\n    function settle() external payable returns (uint256 paid);\n\n    /// @notice Called by the user to pay on behalf of another address\n    /// @param recipient The address to credit for the payment\n    /// @return paid The amount of currency settled\n    function settleFor(address recipient) external payable returns (uint256 paid);\n\n    /// @notice WARNING - Any currency that is cleared, will be non-retrievable, and locked in the contract permanently.\n    /// A call to clear will zero out a positive balance WITHOUT a corresponding transfer.\n    /// @dev This could be used to clear a balance that is considered dust.\n    /// Additionally, the amount must be the exact positive balance. This is to enforce that the caller is aware of the amount being cleared.\n    function clear(Currency currency, uint256 amount) external;\n\n    /// @notice Called by the user to move value into ERC6909 balance\n    /// @param to The address to mint the tokens to\n    /// @param id The currency address to mint to ERC6909s, as a uint256\n    /// @param amount The amount of currency to mint\n    /// @dev The id is converted to a uint160 to correspond to a currency address\n    /// If the upper 12 bytes are not 0, they will be 0-ed out\n    function mint(address to, uint256 id, uint256 amount) external;\n\n    /// @notice Called by the user to move value from ERC6909 balance\n    /// @param from The address to burn the tokens from\n    /// @param id The currency address to burn from ERC6909s, as a uint256\n    /// @param amount The amount of currency to burn\n    /// @dev The id is converted to a uint160 to correspond to a currency address\n    /// If the upper 12 bytes are not 0, they will be 0-ed out\n    function burn(address from, uint256 id, uint256 amount) external;\n\n    /// @notice Updates the pools lp fees for the a pool that has enabled dynamic lp fees.\n    /// @dev A swap fee totaling MAX_SWAP_FEE (100%) makes exact output swaps impossible since the input is entirely consumed by the fee\n    /// @param key The key of the pool to update dynamic LP fees for\n    /// @param newDynamicLPFee The new dynamic pool LP fee\n    function updateDynamicLPFee(PoolKey memory key, uint24 newDynamicLPFee) external;\n}\n"}, "lib/v4-periphery/src/interfaces/external/IWETH9.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title IWETH9\ninterface IWETH9 is IERC20 {\n    /// @notice Deposit ether to get wrapped ether\n    function deposit() external payable;\n\n    /// @notice Withdraw wrapped ether to get ether\n    function withdraw(uint256) external;\n}\n"}, "lib/universal-router/contracts/modules/Permit2Payments.sol": {"content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.30;\n\nimport {IAllowanceTransfer} from 'permit2/src/interfaces/IAllowanceTransfer.sol';\nimport {SafeCast160} from 'permit2/src/libraries/SafeCast160.sol';\nimport {Payments} from './Payments.sol';\n\n/// @title Payments through Permit2\n/// @notice Performs interactions with Permit2 to transfer tokens\nabstract contract Permit2Payments is Payments {\n    using SafeCast160 for uint256;\n\n    error FromAddressIsNotOwner();\n\n    /// @notice Performs a transferFrom on Permit2\n    /// @param token The token to transfer\n    /// @param from The address to transfer from\n    /// @param to The recipient of the transfer\n    /// @param amount The amount to transfer\n    function permit2TransferFrom(address token, address from, address to, uint160 amount) internal {\n        PERMIT2.transferFrom(from, to, amount, token);\n    }\n\n    /// @notice Performs a batch transferFrom on Permit2\n    /// @param batchDetails An array detailing each of the transfers that should occur\n    /// @param owner The address that should be the owner of all transfers\n    function permit2TransferFrom(IAllowanceTransfer.AllowanceTransferDetails[] calldata batchDetails, address owner)\n        internal\n    {\n        uint256 batchLength = batchDetails.length;\n        for (uint256 i = 0; i < batchLength; ++i) {\n            if (batchDetails[i].from != owner) revert FromAddressIsNotOwner();\n        }\n        PERMIT2.transferFrom(batchDetails);\n    }\n\n    /// @notice Either performs a regular payment or transferFrom on Permit2, depending on the payer address\n    /// @param token The token to transfer\n    /// @param payer The address to pay for the transfer\n    /// @param recipient The recipient of the transfer\n    /// @param amount The amount to transfer\n    function payOrPermit2Transfer(address token, address payer, address recipient, uint256 amount) internal {\n        if (payer == address(this)) pay(token, recipient, amount);\n        else permit2TransferFrom(token, payer, recipient, amount.toUint160());\n    }\n}\n"}, "lib/v4-periphery/src/V4Router.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\nimport {BalanceDelta} from \"@uniswap/v4-core/src/types/BalanceDelta.sol\";\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\nimport {Currency} from \"@uniswap/v4-core/src/types/Currency.sol\";\nimport {TickMath} from \"@uniswap/v4-core/src/libraries/TickMath.sol\";\nimport {SafeCast} from \"@uniswap/v4-core/src/libraries/SafeCast.sol\";\n\nimport {PathKey} from \"./libraries/PathKey.sol\";\nimport {CalldataDecoder} from \"./libraries/CalldataDecoder.sol\";\nimport {IV4Router} from \"./interfaces/IV4Router.sol\";\nimport {BaseActionsRouter} from \"./base/BaseActionsRouter.sol\";\nimport {DeltaResolver} from \"./base/DeltaResolver.sol\";\nimport {Actions} from \"./libraries/Actions.sol\";\nimport {ActionConstants} from \"./libraries/ActionConstants.sol\";\nimport {BipsLibrary} from \"./libraries/BipsLibrary.sol\";\n\n/// @title UniswapV4Router\n/// @notice Abstract contract that contains all internal logic needed for routing through Uniswap v4 pools\n/// @dev the entry point to executing actions in this contract is calling `BaseActionsRouter._executeActions`\n/// An inheriting contract should call _executeActions at the point that they wish actions to be executed\nabstract contract V4Router is IV4Router, BaseActionsRouter, DeltaResolver {\n    using SafeCast for *;\n    using CalldataDecoder for bytes;\n    using BipsLibrary for uint256;\n\n    constructor(IPoolManager _poolManager) BaseActionsRouter(_poolManager) {}\n\n    function _handleAction(uint256 action, bytes calldata params) internal override {\n        // swap actions and payment actions in different blocks for gas efficiency\n        if (action < Actions.SETTLE) {\n            if (action == Actions.SWAP_EXACT_IN) {\n                IV4Router.ExactInputParams calldata swapParams = params.decodeSwapExactInParams();\n                _swapExactInput(swapParams);\n                return;\n            } else if (action == Actions.SWAP_EXACT_IN_SINGLE) {\n                IV4Router.ExactInputSingleParams calldata swapParams = params.decodeSwapExactInSingleParams();\n                _swapExactInputSingle(swapParams);\n                return;\n            } else if (action == Actions.SWAP_EXACT_OUT) {\n                IV4Router.ExactOutputParams calldata swapParams = params.decodeSwapExactOutParams();\n                _swapExactOutput(swapParams);\n                return;\n            } else if (action == Actions.SWAP_EXACT_OUT_SINGLE) {\n                IV4Router.ExactOutputSingleParams calldata swapParams = params.decodeSwapExactOutSingleParams();\n                _swapExactOutputSingle(swapParams);\n                return;\n            }\n        } else {\n            if (action == Actions.SETTLE_ALL) {\n                (Currency currency, uint256 maxAmount) = params.decodeCurrencyAndUint256();\n                uint256 amount = _getFullDebt(currency);\n                if (amount > maxAmount) revert V4TooMuchRequested(maxAmount, amount);\n                _settle(currency, msgSender(), amount);\n                return;\n            } else if (action == Actions.TAKE_ALL) {\n                (Currency currency, uint256 minAmount) = params.decodeCurrencyAndUint256();\n                uint256 amount = _getFullCredit(currency);\n                if (amount < minAmount) revert V4TooLittleReceived(minAmount, amount);\n                _take(currency, msgSender(), amount);\n                return;\n            } else if (action == Actions.SETTLE) {\n                (Currency currency, uint256 amount, bool payerIsUser) = params.decodeCurrencyUint256AndBool();\n                _settle(currency, _mapPayer(payerIsUser), _mapSettleAmount(amount, currency));\n                return;\n            } else if (action == Actions.TAKE) {\n                (Currency currency, address recipient, uint256 amount) = params.decodeCurrencyAddressAndUint256();\n                _take(currency, _mapRecipient(recipient), _mapTakeAmount(amount, currency));\n                return;\n            } else if (action == Actions.TAKE_PORTION) {\n                (Currency currency, address recipient, uint256 bips) = params.decodeCurrencyAddressAndUint256();\n                _take(currency, _mapRecipient(recipient), _getFullCredit(currency).calculatePortion(bips));\n                return;\n            }\n        }\n        revert UnsupportedAction(action);\n    }\n\n    function _swapExactInputSingle(IV4Router.ExactInputSingleParams calldata params) private {\n        uint128 amountIn = params.amountIn;\n        if (amountIn == ActionConstants.OPEN_DELTA) {\n            amountIn =\n                _getFullCredit(params.zeroForOne ? params.poolKey.currency0 : params.poolKey.currency1).toUint128();\n        }\n        uint128 amountOut =\n            _swap(params.poolKey, params.zeroForOne, -int256(uint256(amountIn)), params.hookData).toUint128();\n        if (amountOut < params.amountOutMinimum) revert V4TooLittleReceived(params.amountOutMinimum, amountOut);\n    }\n\n    function _swapExactInput(IV4Router.ExactInputParams calldata params) private {\n        unchecked {\n            // Caching for gas savings\n            uint256 pathLength = params.path.length;\n            uint128 amountOut;\n            Currency currencyIn = params.currencyIn;\n            uint128 amountIn = params.amountIn;\n            if (amountIn == ActionConstants.OPEN_DELTA) amountIn = _getFullCredit(currencyIn).toUint128();\n            PathKey calldata pathKey;\n\n            for (uint256 i = 0; i < pathLength; i++) {\n                pathKey = params.path[i];\n                (PoolKey memory poolKey, bool zeroForOne) = pathKey.getPoolAndSwapDirection(currencyIn);\n                // The output delta will always be positive, except for when interacting with certain hook pools\n                amountOut = _swap(poolKey, zeroForOne, -int256(uint256(amountIn)), pathKey.hookData).toUint128();\n\n                amountIn = amountOut;\n                currencyIn = pathKey.intermediateCurrency;\n            }\n\n            if (amountOut < params.amountOutMinimum) revert V4TooLittleReceived(params.amountOutMinimum, amountOut);\n        }\n    }\n\n    function _swapExactOutputSingle(IV4Router.ExactOutputSingleParams calldata params) private {\n        uint128 amountOut = params.amountOut;\n        if (amountOut == ActionConstants.OPEN_DELTA) {\n            amountOut =\n                _getFullDebt(params.zeroForOne ? params.poolKey.currency1 : params.poolKey.currency0).toUint128();\n        }\n        uint128 amountIn = (\n            uint256(-int256(_swap(params.poolKey, params.zeroForOne, int256(uint256(amountOut)), params.hookData)))\n        ).toUint128();\n        if (amountIn > params.amountInMaximum) revert V4TooMuchRequested(params.amountInMaximum, amountIn);\n    }\n\n    function _swapExactOutput(IV4Router.ExactOutputParams calldata params) private {\n        unchecked {\n            // Caching for gas savings\n            uint256 pathLength = params.path.length;\n            uint128 amountIn;\n            uint128 amountOut = params.amountOut;\n            Currency currencyOut = params.currencyOut;\n            PathKey calldata pathKey;\n\n            if (amountOut == ActionConstants.OPEN_DELTA) {\n                amountOut = _getFullDebt(currencyOut).toUint128();\n            }\n\n            for (uint256 i = pathLength; i > 0; i--) {\n                pathKey = params.path[i - 1];\n                (PoolKey memory poolKey, bool oneForZero) = pathKey.getPoolAndSwapDirection(currencyOut);\n                // The output delta will always be negative, except for when interacting with certain hook pools\n                amountIn = (uint256(-int256(_swap(poolKey, !oneForZero, int256(uint256(amountOut)), pathKey.hookData))))\n                    .toUint128();\n\n                amountOut = amountIn;\n                currencyOut = pathKey.intermediateCurrency;\n            }\n            if (amountIn > params.amountInMaximum) revert V4TooMuchRequested(params.amountInMaximum, amountIn);\n        }\n    }\n\n    function _swap(PoolKey memory poolKey, bool zeroForOne, int256 amountSpecified, bytes calldata hookData)\n        private\n        returns (int128 reciprocalAmount)\n    {\n        // for protection of exactOut swaps, sqrtPriceLimit is not exposed as a feature in this contract\n        unchecked {\n            BalanceDelta delta = poolManager.swap(\n                poolKey,\n                IPoolManager.SwapParams(\n                    zeroForOne, amountSpecified, zeroForOne ? TickMath.MIN_SQRT_PRICE + 1 : TickMath.MAX_SQRT_PRICE - 1\n                ),\n                hookData\n            );\n\n            reciprocalAmount = (zeroForOne == amountSpecified < 0) ? delta.amount1() : delta.amount0();\n        }\n    }\n}\n"}, "lib/v4-core/src/types/Currency.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IERC20Minimal} from \"../interfaces/external/IERC20Minimal.sol\";\nimport {CustomRevert} from \"../libraries/CustomRevert.sol\";\n\ntype Currency is address;\n\nusing {greaterThan as >, lessThan as <, greaterThanOrEqualTo as >=, equals as ==} for Currency global;\nusing CurrencyLibrary for Currency global;\n\nfunction equals(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) == Currency.unwrap(other);\n}\n\nfunction greaterThan(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) > Currency.unwrap(other);\n}\n\nfunction lessThan(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) < Currency.unwrap(other);\n}\n\nfunction greaterThanOrEqualTo(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) >= Currency.unwrap(other);\n}\n\n/// @title CurrencyLibrary\n/// @dev This library allows for transferring and holding native tokens and ERC20 tokens\nlibrary CurrencyLibrary {\n    /// @notice Additional context for ERC-7751 wrapped error when a native transfer fails\n    error NativeTransferFailed();\n\n    /// @notice Additional context for ERC-7751 wrapped error when an ERC20 transfer fails\n    error ERC20TransferFailed();\n\n    /// @notice A constant to represent the native currency\n    Currency public constant ADDRESS_ZERO = Currency.wrap(address(0));\n\n    function transfer(Currency currency, address to, uint256 amount) internal {\n        // altered from https://github.com/transmissions11/solmate/blob/44a9963d4c78111f77caa0e65d677b8b46d6f2e6/src/utils/SafeTransferLib.sol\n        // modified custom error selectors\n\n        bool success;\n        if (currency.isAddressZero()) {\n            assembly (\"memory-safe\") {\n                // Transfer the ETH and revert if it fails.\n                success := call(gas(), to, amount, 0, 0, 0, 0)\n            }\n            // revert with NativeTransferFailed, containing the bubbled up error as an argument\n            if (!success) {\n                CustomRevert.bubbleUpAndRevertWith(to, bytes4(0), NativeTransferFailed.selector);\n            }\n        } else {\n            assembly (\"memory-safe\") {\n                // Get a pointer to some free memory.\n                let fmp := mload(0x40)\n\n                // Write the abi-encoded calldata into memory, beginning with the function selector.\n                mstore(fmp, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n                mstore(add(fmp, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n                mstore(add(fmp, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n                success :=\n                    and(\n                        // Set success to whether the call reverted, if not we check it either\n                        // returned exactly 1 (can't just be non-zero data), or had no return data.\n                        or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                        // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                        // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                        // Counterintuitively, this call must be positioned second to the or() call in the\n                        // surrounding and() call or else returndatasize() will be zero during the computation.\n                        call(gas(), currency, 0, fmp, 68, 0, 32)\n                    )\n\n                // Now clean the memory we used\n                mstore(fmp, 0) // 4 byte `selector` and 28 bytes of `to` were stored here\n                mstore(add(fmp, 0x20), 0) // 4 bytes of `to` and 28 bytes of `amount` were stored here\n                mstore(add(fmp, 0x40), 0) // 4 bytes of `amount` were stored here\n            }\n            // revert with ERC20TransferFailed, containing the bubbled up error as an argument\n            if (!success) {\n                CustomRevert.bubbleUpAndRevertWith(\n                    Currency.unwrap(currency), IERC20Minimal.transfer.selector, ERC20TransferFailed.selector\n                );\n            }\n        }\n    }\n\n    function balanceOfSelf(Currency currency) internal view returns (uint256) {\n        if (currency.isAddressZero()) {\n            return address(this).balance;\n        } else {\n            return IERC20Minimal(Currency.unwrap(currency)).balanceOf(address(this));\n        }\n    }\n\n    function balanceOf(Currency currency, address owner) internal view returns (uint256) {\n        if (currency.isAddressZero()) {\n            return owner.balance;\n        } else {\n            return IERC20Minimal(Currency.unwrap(currency)).balanceOf(owner);\n        }\n    }\n\n    function isAddressZero(Currency currency) internal pure returns (bool) {\n        return Currency.unwrap(currency) == Currency.unwrap(ADDRESS_ZERO);\n    }\n\n    function toId(Currency currency) internal pure returns (uint256) {\n        return uint160(Currency.unwrap(currency));\n    }\n\n    // If the upper 12 bytes are non-zero, they will be zero-ed out\n    // Therefore, fromId() and toId() are not inverses of each other\n    function fromId(uint256 id) internal pure returns (Currency) {\n        return Currency.wrap(address(uint160(id)));\n    }\n}\n"}, "lib/universal-router/lib/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol';\n\nimport './IPoolInitializer.sol';\nimport './IERC721Permit.sol';\nimport './IPeripheryPayments.sol';\nimport './IPeripheryImmutableState.sol';\nimport '../libraries/PoolAddress.sol';\n\n/// @title Non-fungible token for positions\n/// @notice Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred\n/// and authorized.\ninterface INonfungiblePositionManager is\n    IPoolInitializer,\n    IPeripheryPayments,\n    IPeripheryImmutableState,\n    IERC721Metadata,\n    IERC721Enumerable,\n    IERC721Permit\n{\n    /// @notice Emitted when liquidity is increased for a position NFT\n    /// @dev Also emitted when a token is minted\n    /// @param tokenId The ID of the token for which liquidity was increased\n    /// @param liquidity The amount by which liquidity for the NFT position was increased\n    /// @param amount0 The amount of token0 that was paid for the increase in liquidity\n    /// @param amount1 The amount of token1 that was paid for the increase in liquidity\n    event IncreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\n    /// @notice Emitted when liquidity is decreased for a position NFT\n    /// @param tokenId The ID of the token for which liquidity was decreased\n    /// @param liquidity The amount by which liquidity for the NFT position was decreased\n    /// @param amount0 The amount of token0 that was accounted for the decrease in liquidity\n    /// @param amount1 The amount of token1 that was accounted for the decrease in liquidity\n    event DecreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\n    /// @notice Emitted when tokens are collected for a position NFT\n    /// @dev The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior\n    /// @param tokenId The ID of the token for which underlying tokens were collected\n    /// @param recipient The address of the account that received the collected tokens\n    /// @param amount0 The amount of token0 owed to the position that was collected\n    /// @param amount1 The amount of token1 owed to the position that was collected\n    event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1);\n\n    /// @notice Returns the position information associated with a given token ID.\n    /// @dev Throws if the token ID is not valid.\n    /// @param tokenId The ID of the token that represents the position\n    /// @return nonce The nonce for permits\n    /// @return operator The address that is approved for spending\n    /// @return token0 The address of the token0 for a specific pool\n    /// @return token1 The address of the token1 for a specific pool\n    /// @return fee The fee associated with the pool\n    /// @return tickLower The lower end of the tick range for the position\n    /// @return tickUpper The higher end of the tick range for the position\n    /// @return liquidity The liquidity of the position\n    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position\n    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position\n    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation\n    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation\n    function positions(uint256 tokenId)\n        external\n        view\n        returns (\n            uint96 nonce,\n            address operator,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    struct MintParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n\n    /// @notice Creates a new position wrapped in a NFT\n    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized\n    /// a method does not exist, i.e. the pool is assumed to be initialized.\n    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata\n    /// @return tokenId The ID of the token that represents the minted position\n    /// @return liquidity The amount of liquidity for this position\n    /// @return amount0 The amount of token0\n    /// @return amount1 The amount of token1\n    function mint(MintParams calldata params)\n        external\n        payable\n        returns (\n            uint256 tokenId,\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    struct IncreaseLiquidityParams {\n        uint256 tokenId;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`\n    /// @param params tokenId The ID of the token for which liquidity is being increased,\n    /// amount0Desired The desired amount of token0 to be spent,\n    /// amount1Desired The desired amount of token1 to be spent,\n    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,\n    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,\n    /// deadline The time by which the transaction must be included to effect the change\n    /// @return liquidity The new liquidity amount as a result of the increase\n    /// @return amount0 The amount of token0 to acheive resulting liquidity\n    /// @return amount1 The amount of token1 to acheive resulting liquidity\n    function increaseLiquidity(IncreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    struct DecreaseLiquidityParams {\n        uint256 tokenId;\n        uint128 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /// @notice Decreases the amount of liquidity in a position and accounts it to the position\n    /// @param params tokenId The ID of the token for which liquidity is being decreased,\n    /// amount The amount by which liquidity will be decreased,\n    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,\n    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,\n    /// deadline The time by which the transaction must be included to effect the change\n    /// @return amount0 The amount of token0 accounted to the position's tokens owed\n    /// @return amount1 The amount of token1 accounted to the position's tokens owed\n    function decreaseLiquidity(DecreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (uint256 amount0, uint256 amount1);\n\n    struct CollectParams {\n        uint256 tokenId;\n        address recipient;\n        uint128 amount0Max;\n        uint128 amount1Max;\n    }\n\n    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\n    /// @param params tokenId The ID of the NFT for which tokens are being collected,\n    /// recipient The account that should receive the tokens,\n    /// amount0Max The maximum amount of token0 to collect,\n    /// amount1Max The maximum amount of token1 to collect\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens\n    /// must be collected first.\n    /// @param tokenId The ID of the token that is being burned\n    function burn(uint256 tokenId) external payable;\n}\n"}, "lib/v4-periphery/src/interfaces/IPositionManager.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\nimport {PositionInfo} from \"../libraries/PositionInfoLibrary.sol\";\n\nimport {INotifier} from \"./INotifier.sol\";\nimport {IImmutableState} from \"./IImmutableState.sol\";\nimport {IERC721Permit_v4} from \"./IERC721Permit_v4.sol\";\nimport {IEIP712_v4} from \"./IEIP712_v4.sol\";\nimport {IMulticall_v4} from \"./IMulticall_v4.sol\";\nimport {IPoolInitializer_v4} from \"./IPoolInitializer_v4.sol\";\nimport {IUnorderedNonce} from \"./IUnorderedNonce.sol\";\nimport {IPermit2Forwarder} from \"./IPermit2Forwarder.sol\";\n\n/// @title IPositionManager\n/// @notice Interface for the PositionManager contract\ninterface IPositionManager is\n    INotifier,\n    IImmutableState,\n    IERC721Permit_v4,\n    IEIP712_v4,\n    IMulticall_v4,\n    IPoolInitializer_v4,\n    IUnorderedNonce,\n    IPermit2Forwarder\n{\n    /// @notice Thrown when the caller is not approved to modify a position\n    error NotApproved(address caller);\n    /// @notice Thrown when the block.timestamp exceeds the user-provided deadline\n    error DeadlinePassed(uint256 deadline);\n    /// @notice Thrown when calling transfer, subscribe, or unsubscribe when the PoolManager is unlocked.\n    /// @dev This is to prevent hooks from being able to trigger notifications at the same time the position is being modified.\n    error PoolManagerMustBeLocked();\n\n    /// @notice Unlocks Uniswap v4 PoolManager and batches actions for modifying liquidity\n    /// @dev This is the standard entrypoint for the PositionManager\n    /// @param unlockData is an encoding of actions, and parameters for those actions\n    /// @param deadline is the deadline for the batched actions to be executed\n    function modifyLiquidities(bytes calldata unlockData, uint256 deadline) external payable;\n\n    /// @notice Batches actions for modifying liquidity without unlocking v4 PoolManager\n    /// @dev This must be called by a contract that has already unlocked the v4 PoolManager\n    /// @param actions the actions to perform\n    /// @param params the parameters to provide for the actions\n    function modifyLiquiditiesWithoutUnlock(bytes calldata actions, bytes[] calldata params) external payable;\n\n    /// @notice Used to get the ID that will be used for the next minted liquidity position\n    /// @return uint256 The next token ID\n    function nextTokenId() external view returns (uint256);\n\n    /// @notice Returns the liquidity of a position\n    /// @param tokenId the ERC721 tokenId\n    /// @return liquidity the position's liquidity, as a liquidityAmount\n    /// @dev this value can be processed as an amount0 and amount1 by using the LiquidityAmounts library\n    function getPositionLiquidity(uint256 tokenId) external view returns (uint128 liquidity);\n\n    /// @notice Returns the pool key and position info of a position\n    /// @param tokenId the ERC721 tokenId\n    /// @return poolKey the pool key of the position\n    /// @return PositionInfo a uint256 packed value holding information about the position including the range (tickLower, tickUpper)\n    function getPoolAndPositionInfo(uint256 tokenId) external view returns (PoolKey memory, PositionInfo);\n\n    /// @notice Returns the position info of a position\n    /// @param tokenId the ERC721 tokenId\n    /// @return a uint256 packed value holding information about the position including the range (tickLower, tickUpper)\n    function positionInfo(uint256 tokenId) external view returns (PositionInfo);\n}\n"}, "lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"}, "lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.30;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"}, "lib/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {"content": "pragma solidity ^0.8.30;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"}, "lib/universal-router/contracts/modules/uniswap/v2/UniswapV2Library.sol": {"content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.30;\n\nimport {IUniswapV2Pair} from '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\n\n/// @title Uniswap v2 Helper Library\n/// @notice Calculates the recipient address for a command\nlibrary UniswapV2Library {\n    error InvalidReserves();\n    error InvalidPath();\n\n    /// @notice Calculates the v2 address for a pair without making any external calls\n    /// @param factory The address of the v2 factory\n    /// @param initCodeHash The hash of the pair initcode\n    /// @param tokenA One of the tokens in the pair\n    /// @param tokenB The other token in the pair\n    /// @return pair The resultant v2 pair address\n    function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair)\n    {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n\n    /// @notice Calculates the v2 address for a pair and the pair's token0\n    /// @param factory The address of the v2 factory\n    /// @param initCodeHash The hash of the pair initcode\n    /// @param tokenA One of the tokens in the pair\n    /// @param tokenB The other token in the pair\n    /// @return pair The resultant v2 pair address\n    /// @return token0 The token considered token0 in this pair\n    function pairAndToken0For(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair, address token0)\n    {\n        address token1;\n        (token0, token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n\n    /// @notice Calculates the v2 address for a pair assuming the input tokens are pre-sorted\n    /// @param factory The address of the v2 factory\n    /// @param initCodeHash The hash of the pair initcode\n    /// @param token0 The pair's token0\n    /// @param token1 The pair's token1\n    /// @return pair The resultant v2 pair address\n    function pairForPreSorted(address factory, bytes32 initCodeHash, address token0, address token1)\n        private\n        pure\n        returns (address pair)\n    {\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), initCodeHash)\n                    )\n                )\n            )\n        );\n    }\n\n    /// @notice Calculates the v2 address for a pair and fetches the reserves for each token\n    /// @param factory The address of the v2 factory\n    /// @param initCodeHash The hash of the pair initcode\n    /// @param tokenA One of the tokens in the pair\n    /// @param tokenB The other token in the pair\n    /// @return pair The resultant v2 pair address\n    /// @return reserveA The reserves for tokenA\n    /// @return reserveB The reserves for tokenB\n    function pairAndReservesFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        private\n        view\n        returns (address pair, uint256 reserveA, uint256 reserveB)\n    {\n        address token0;\n        (pair, token0) = pairAndToken0For(factory, initCodeHash, tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    /// @notice Given an input asset amount returns the maximum output amount of the other asset\n    /// @param amountIn The token input amount\n    /// @param reserveIn The reserves available of the input token\n    /// @param reserveOut The reserves available of the output token\n    /// @return amountOut The output amount of the output token\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 1000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n\n    /// @notice Returns the input amount needed for a desired output amount in a single-hop trade\n    /// @param amountOut The desired output amount\n    /// @param reserveIn The reserves available of the input token\n    /// @param reserveOut The reserves available of the output token\n    /// @return amountIn The input amount of the input token\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 numerator = reserveIn * amountOut * 1000;\n        uint256 denominator = (reserveOut - amountOut) * 997;\n        amountIn = (numerator / denominator) + 1;\n    }\n\n    /// @notice Returns the input amount needed for a desired output amount in a multi-hop trade\n    /// @param factory The address of the v2 factory\n    /// @param initCodeHash The hash of the pair initcode\n    /// @param amountOut The desired output amount\n    /// @param path The path of the multi-hop trade\n    /// @return amount The input amount of the input token\n    /// @return pair The first pair in the trade\n    function getAmountInMultihop(address factory, bytes32 initCodeHash, uint256 amountOut, address[] calldata path)\n        internal\n        view\n        returns (uint256 amount, address pair)\n    {\n        if (path.length < 2) revert InvalidPath();\n        amount = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            uint256 reserveIn;\n            uint256 reserveOut;\n\n            (pair, reserveIn, reserveOut) = pairAndReservesFor(factory, initCodeHash, path[i - 1], path[i]);\n            amount = getAmountIn(amount, reserveIn, reserveOut);\n        }\n    }\n\n    /// @notice Sorts two tokens to return token0 and token1\n    /// @param tokenA The first token to sort\n    /// @param tokenB The other token to sort\n    /// @return token0 The smaller token by address value\n    /// @return token1 The larger token by address value\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n}\n"}, "lib/universal-router/contracts/libraries/Constants.sol": {"content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.30;\n\n/// @title Constant state\n/// @notice Constant state used by the Universal Router\nlibrary Constants {\n    /// @dev Used for identifying cases when a v2 pair has already received input tokens\n    uint256 internal constant ALREADY_PAID = 0;\n\n    /// @dev Used as a flag for identifying the transfer of ETH instead of a token\n    address internal constant ETH = address(0);\n\n    /// @dev The length of the bytes encoded address\n    uint256 internal constant ADDR_SIZE = 20;\n\n    /// @dev The length of the bytes encoded fee\n    uint256 internal constant V3_FEE_SIZE = 3;\n\n    /// @dev The offset of a single token address (20) and pool fee (3)\n    uint256 internal constant NEXT_V3_POOL_OFFSET = ADDR_SIZE + V3_FEE_SIZE;\n\n    /// @dev The offset of an encoded pool key\n    /// Token (20) + Fee (3) + Token (20) = 43\n    uint256 internal constant V3_POP_OFFSET = NEXT_V3_POOL_OFFSET + ADDR_SIZE;\n\n    /// @dev The minimum length of an encoding that contains 2 or more pools\n    uint256 internal constant MULTIPLE_V3_POOLS_MIN_LENGTH = V3_POP_OFFSET + NEXT_V3_POOL_OFFSET;\n}\n"}, "lib/universal-router/contracts/modules/uniswap/v3/V3Path.sol": {"content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.30;\n\nimport {BytesLib} from './BytesLib.sol';\nimport {Constants} from '../../../libraries/Constants.sol';\n\n/// @title Functions for manipulating path data for multihop swaps\nlibrary V3Path {\n    using BytesLib for bytes;\n\n    /// @notice Returns true iff the path contains two or more pools\n    /// @param path The encoded swap path\n    /// @return True if path contains two or more pools, otherwise false\n    function hasMultiplePools(bytes calldata path) internal pure returns (bool) {\n        return path.length >= Constants.MULTIPLE_V3_POOLS_MIN_LENGTH;\n    }\n\n    /// @notice Decodes the first pool in path\n    /// @param path The bytes encoded swap path\n    /// @return tokenA The first token of the given pool\n    /// @return fee The fee level of the pool\n    /// @return tokenB The second token of the given pool\n    function decodeFirstPool(bytes calldata path) internal pure returns (address, uint24, address) {\n        return path.toPool();\n    }\n\n    /// @notice Gets the segment corresponding to the first pool in the path\n    /// @param path The bytes encoded swap path\n    /// @return The segment containing all data necessary to target the first pool in the path\n    function getFirstPool(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[:Constants.V3_POP_OFFSET];\n    }\n\n    function decodeFirstToken(bytes calldata path) internal pure returns (address tokenA) {\n        tokenA = path.toAddress();\n    }\n\n    /// @notice Skips a token + fee element\n    /// @param path The swap path\n    function skipToken(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[Constants.NEXT_V3_POOL_OFFSET:];\n    }\n}\n"}, "lib/v3-core/contracts/libraries/SafeCast.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n    /// @notice Cast a uint256 to a uint160, revert on overflow\n    /// @param y The uint256 to be downcasted\n    /// @return z The downcasted integer, now type uint160\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }\n\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\n    /// @param y The int256 to be downcasted\n    /// @return z The downcasted integer, now type int128\n    function toInt128(int256 y) internal pure returns (int128 z) {\n        require((z = int128(y)) == y);\n    }\n\n    /// @notice Cast a uint256 to a int256, revert on overflow\n    /// @param y The uint256 to be casted\n    /// @return z The casted integer, now type int256\n    function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y < 2**255);\n        z = int256(y);\n    }\n}\n"}, "lib/v3-core/contracts/interfaces/IUniswapV3Pool.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\nimport './pool/IUniswapV3PoolImmutables.sol';\nimport './pool/IUniswapV3PoolState.sol';\nimport './pool/IUniswapV3PoolDerivedState.sol';\nimport './pool/IUniswapV3PoolActions.sol';\nimport './pool/IUniswapV3PoolOwnerActions.sol';\nimport './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n    IUniswapV3PoolImmutables,\n    IUniswapV3PoolState,\n    IUniswapV3PoolDerivedState,\n    IUniswapV3PoolActions,\n    IUniswapV3PoolOwnerActions,\n    IUniswapV3PoolEvents\n{\n\n}\n"}, "lib/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"}, "lib/universal-router/contracts/libraries/MaxInputAmount.sol": {"content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.30;\n\n/// @notice A library used to store the maximum desired amount of input tokens for exact output swaps; used for checking slippage\nlibrary MaxInputAmount {\n    // The slot holding the the maximum desired amount of input tokens, transiently. bytes32(uint256(keccak256(\"MaxAmountIn\")) - 1)\n    bytes32 constant MAX_AMOUNT_IN_SLOT = 0xaf28d9864a81dfdf71cab65f4e5d79a0cf9b083905fb8971425e6cb581b3f692;\n\n    function set(uint256 maxAmountIn) internal {\n        assembly (\"memory-safe\") {\n            tstore(MAX_AMOUNT_IN_SLOT, maxAmountIn)\n        }\n    }\n\n    function get() internal view returns (uint256 maxAmountIn) {\n        assembly (\"memory-safe\") {\n            maxAmountIn := tload(MAX_AMOUNT_IN_SLOT)\n        }\n    }\n}\n"}, "lib/v4-periphery/src/libraries/BipsLibrary.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title For calculating a percentage of an amount, using bips\nlibrary BipsLibrary {\n    uint256 internal constant BPS_DENOMINATOR = 10_000;\n\n    /// @notice emitted when an invalid percentage is provided\n    error InvalidBips();\n\n    /// @param amount The total amount to calculate a percentage of\n    /// @param bips The percentage to calculate, in bips\n    function calculatePortion(uint256 amount, uint256 bips) internal pure returns (uint256) {\n        if (bips > BPS_DENOMINATOR) revert InvalidBips();\n        return (amount * bips) / BPS_DENOMINATOR;\n    }\n}\n"}, "lib/solmate/src/utils/SafeTransferLib.sol": {"content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.30;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n            // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n            success := call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n\n            // Set success to whether the call reverted, if not we check it either\n            // returned exactly 1 (can't just be non-zero data), or had no return data and token has code.\n            if and(iszero(and(eq(mload(0), 1), gt(returndatasize(), 31))), success) {\n                success := iszero(or(iszero(extcodesize(token)), returndatasize())) \n            }\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n            // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n            success := call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n\n            // Set success to whether the call reverted, if not we check it either\n            // returned exactly 1 (can't just be non-zero data), or had no return data and token has code.\n            if and(iszero(and(eq(mload(0), 1), gt(returndatasize(), 31))), success) {\n                success := iszero(or(iszero(extcodesize(token)), returndatasize())) \n            }\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n            // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n            success := call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n\n            // Set success to whether the call reverted, if not we check it either\n            // returned exactly 1 (can't just be non-zero data), or had no return data and token has code.\n            if and(iszero(and(eq(mload(0), 1), gt(returndatasize(), 31))), success) {\n                success := iszero(or(iszero(extcodesize(token)), returndatasize())) \n            }\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"}, "lib/v4-periphery/src/libraries/Actions.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Library to define different pool actions.\n/// @dev These are suggested common commands, however additional commands should be defined as required\n/// Some of these actions are not supported in the Router contracts or Position Manager contracts, but are left as they may be helpful commands for other peripheral contracts.\nlibrary Actions {\n    // pool actions\n    // liquidity actions\n    uint256 internal constant INCREASE_LIQUIDITY = 0x00;\n    uint256 internal constant DECREASE_LIQUIDITY = 0x01;\n    uint256 internal constant MINT_POSITION = 0x02;\n    uint256 internal constant BURN_POSITION = 0x03;\n    uint256 internal constant INCREASE_LIQUIDITY_FROM_DELTAS = 0x04;\n    uint256 internal constant MINT_POSITION_FROM_DELTAS = 0x05;\n\n    // swapping\n    uint256 internal constant SWAP_EXACT_IN_SINGLE = 0x06;\n    uint256 internal constant SWAP_EXACT_IN = 0x07;\n    uint256 internal constant SWAP_EXACT_OUT_SINGLE = 0x08;\n    uint256 internal constant SWAP_EXACT_OUT = 0x09;\n\n    // donate\n    // note this is not supported in the position manager or router\n    uint256 internal constant DONATE = 0x0a;\n\n    // closing deltas on the pool manager\n    // settling\n    uint256 internal constant SETTLE = 0x0b;\n    uint256 internal constant SETTLE_ALL = 0x0c;\n    uint256 internal constant SETTLE_PAIR = 0x0d;\n    // taking\n    uint256 internal constant TAKE = 0x0e;\n    uint256 internal constant TAKE_ALL = 0x0f;\n    uint256 internal constant TAKE_PORTION = 0x10;\n    uint256 internal constant TAKE_PAIR = 0x11;\n\n    uint256 internal constant CLOSE_CURRENCY = 0x12;\n    uint256 internal constant CLEAR_OR_TAKE = 0x13;\n    uint256 internal constant SWEEP = 0x14;\n\n    uint256 internal constant WRAP = 0x15;\n    uint256 internal constant UNWRAP = 0x16;\n\n    // minting/burning 6909s to close deltas\n    // note this is not supported in the position manager or router\n    uint256 internal constant MINT_6909 = 0x17;\n    uint256 internal constant BURN_6909 = 0x18;\n}\n"}, "lib/universal-router/lib/v3-periphery/contracts/interfaces/IERC721Permit.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/// @title ERC721 with permit\n/// @notice Extension to ERC721 that includes a permit function for signature based approvals\ninterface IERC721Permit is IERC721 {\n    /// @notice The permit typehash used in the permit signature\n    /// @return The typehash for the permit\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    /// @notice The domain separator used in the permit signature\n    /// @return The domain seperator used in encoding of permit signature\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    /// @notice Approve of a specific token ID for spending by spender via signature\n    /// @param spender The account that is being approved\n    /// @param tokenId The ID of the token that is being approved for spending\n    /// @param deadline The deadline timestamp by which the call must be mined for the approve to work\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function permit(\n        address spender,\n        uint256 tokenId,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n}\n"}, "lib/universal-router/contracts/libraries/Locker.sol": {"content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.30;\n\n/// @notice A library to implement a reentrancy lock in transient storage.\n/// @dev Instead of storing a boolean, the locker's address is stored to allow the contract to know who locked the contract\n/// TODO: This library can be deleted when we have the transient keyword support in solidity.\nlibrary Locker {\n    // The slot holding the locker state, transiently. bytes32(uint256(keccak256(\"Locker\")) - 1)\n    bytes32 constant LOCKER_SLOT = 0x0e87e1788ebd9ed6a7e63c70a374cd3283e41cad601d21fbe27863899ed4a708;\n\n    function set(address locker) internal {\n        // The locker is always msg.sender or address(0) so does not need to be cleaned\n        assembly (\"memory-safe\") {\n            tstore(LOCKER_SLOT, locker)\n        }\n    }\n\n    function get() internal view returns (address locker) {\n        assembly (\"memory-safe\") {\n            locker := tload(LOCKER_SLOT)\n        }\n    }\n\n    function isLocked() internal view returns (bool) {\n        return Locker.get() != address(0);\n    }\n}\n"}, "lib/v4-periphery/src/interfaces/IV4Router.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\nimport {Currency} from \"@uniswap/v4-core/src/types/Currency.sol\";\nimport {PathKey} from \"../libraries/PathKey.sol\";\nimport {IImmutableState} from \"./IImmutableState.sol\";\n\n/// @title IV4Router\n/// @notice Interface for the V4Router contract\ninterface IV4Router is IImmutableState {\n    /// @notice Emitted when an exactInput swap does not receive its minAmountOut\n    error V4TooLittleReceived(uint256 minAmountOutReceived, uint256 amountReceived);\n    /// @notice Emitted when an exactOutput is asked for more than its maxAmountIn\n    error V4TooMuchRequested(uint256 maxAmountInRequested, uint256 amountRequested);\n\n    /// @notice Parameters for a single-hop exact-input swap\n    struct ExactInputSingleParams {\n        PoolKey poolKey;\n        bool zeroForOne;\n        uint128 amountIn;\n        uint128 amountOutMinimum;\n        bytes hookData;\n    }\n\n    /// @notice Parameters for a multi-hop exact-input swap\n    struct ExactInputParams {\n        Currency currencyIn;\n        PathKey[] path;\n        uint128 amountIn;\n        uint128 amountOutMinimum;\n    }\n\n    /// @notice Parameters for a single-hop exact-output swap\n    struct ExactOutputSingleParams {\n        PoolKey poolKey;\n        bool zeroForOne;\n        uint128 amountOut;\n        uint128 amountInMaximum;\n        bytes hookData;\n    }\n\n    /// @notice Parameters for a multi-hop exact-output swap\n    struct ExactOutputParams {\n        Currency currencyOut;\n        PathKey[] path;\n        uint128 amountOut;\n        uint128 amountInMaximum;\n    }\n}\n"}, "lib/v4-core/src/interfaces/IHooks.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {BalanceDelta} from \"../types/BalanceDelta.sol\";\nimport {IPoolManager} from \"./IPoolManager.sol\";\nimport {BeforeSwapDelta} from \"../types/BeforeSwapDelta.sol\";\n\n/// @notice V4 decides whether to invoke specific hooks by inspecting the least significant bits\n/// of the address that the hooks contract is deployed to.\n/// For example, a hooks contract deployed to address: 0x0000000000000000000000000000000000002400\n/// has the lowest bits '10 0100 0000 0000' which would cause the 'before initialize' and 'after add liquidity' hooks to be used.\n/// See the Hooks library for the full spec.\n/// @dev Should only be callable by the v4 PoolManager.\ninterface IHooks {\n    /// @notice The hook called before the state of a pool is initialized\n    /// @param sender The initial msg.sender for the initialize call\n    /// @param key The key for the pool being initialized\n    /// @param sqrtPriceX96 The sqrt(price) of the pool as a Q64.96\n    /// @return bytes4 The function selector for the hook\n    function beforeInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96) external returns (bytes4);\n\n    /// @notice The hook called after the state of a pool is initialized\n    /// @param sender The initial msg.sender for the initialize call\n    /// @param key The key for the pool being initialized\n    /// @param sqrtPriceX96 The sqrt(price) of the pool as a Q64.96\n    /// @param tick The current tick after the state of a pool is initialized\n    /// @return bytes4 The function selector for the hook\n    function afterInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96, int24 tick)\n        external\n        returns (bytes4);\n\n    /// @notice The hook called before liquidity is added\n    /// @param sender The initial msg.sender for the add liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for adding liquidity\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidity provider to be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeAddLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after liquidity is added\n    /// @param sender The initial msg.sender for the add liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for adding liquidity\n    /// @param delta The caller's balance delta after adding liquidity; the sum of principal delta, fees accrued, and hook delta\n    /// @param feesAccrued The fees accrued since the last time fees were collected from this position\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidity provider to be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    /// @return BalanceDelta The hook's delta in token0 and token1. Positive: the hook is owed/took currency, negative: the hook owes/sent currency\n    function afterAddLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        BalanceDelta delta,\n        BalanceDelta feesAccrued,\n        bytes calldata hookData\n    ) external returns (bytes4, BalanceDelta);\n\n    /// @notice The hook called before liquidity is removed\n    /// @param sender The initial msg.sender for the remove liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for removing liquidity\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidity provider to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeRemoveLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after liquidity is removed\n    /// @param sender The initial msg.sender for the remove liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for removing liquidity\n    /// @param delta The caller's balance delta after removing liquidity; the sum of principal delta, fees accrued, and hook delta\n    /// @param feesAccrued The fees accrued since the last time fees were collected from this position\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidity provider to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    /// @return BalanceDelta The hook's delta in token0 and token1. Positive: the hook is owed/took currency, negative: the hook owes/sent currency\n    function afterRemoveLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        BalanceDelta delta,\n        BalanceDelta feesAccrued,\n        bytes calldata hookData\n    ) external returns (bytes4, BalanceDelta);\n\n    /// @notice The hook called before a swap\n    /// @param sender The initial msg.sender for the swap call\n    /// @param key The key for the pool\n    /// @param params The parameters for the swap\n    /// @param hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    /// @return BeforeSwapDelta The hook's delta in specified and unspecified currencies. Positive: the hook is owed/took currency, negative: the hook owes/sent currency\n    /// @return uint24 Optionally override the lp fee, only used if three conditions are met: 1. the Pool has a dynamic fee, 2. the value's 2nd highest bit is set (23rd bit, 0x400000), and 3. the value is less than or equal to the maximum fee (1 million)\n    function beforeSwap(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        bytes calldata hookData\n    ) external returns (bytes4, BeforeSwapDelta, uint24);\n\n    /// @notice The hook called after a swap\n    /// @param sender The initial msg.sender for the swap call\n    /// @param key The key for the pool\n    /// @param params The parameters for the swap\n    /// @param delta The amount owed to the caller (positive) or owed to the pool (negative)\n    /// @param hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    /// @return int128 The hook's delta in unspecified currency. Positive: the hook is owed/took currency, negative: the hook owes/sent currency\n    function afterSwap(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        BalanceDelta delta,\n        bytes calldata hookData\n    ) external returns (bytes4, int128);\n\n    /// @notice The hook called before donate\n    /// @param sender The initial msg.sender for the donate call\n    /// @param key The key for the pool\n    /// @param amount0 The amount of token0 being donated\n    /// @param amount1 The amount of token1 being donated\n    /// @param hookData Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeDonate(\n        address sender,\n        PoolKey calldata key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after donate\n    /// @param sender The initial msg.sender for the donate call\n    /// @param key The key for the pool\n    /// @param amount0 The amount of token0 being donated\n    /// @param amount1 The amount of token1 being donated\n    /// @param hookData Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function afterDonate(\n        address sender,\n        PoolKey calldata key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external returns (bytes4);\n}\n"}, "lib/v4-core/src/types/PoolId.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {PoolKey} from \"./PoolKey.sol\";\n\ntype PoolId is bytes32;\n\n/// @notice Library for computing the ID of a pool\nlibrary PoolIdLibrary {\n    /// @notice Returns value equal to keccak256(abi.encode(poolKey))\n    function toId(PoolKey memory poolKey) internal pure returns (PoolId poolId) {\n        assembly (\"memory-safe\") {\n            // 0xa0 represents the total size of the poolKey struct (5 slots of 32 bytes)\n            poolId := keccak256(poolKey, 0xa0)\n        }\n    }\n}\n"}, "lib/v4-core/src/interfaces/external/IERC6909Claims.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Interface for claims over a contract balance, wrapped as a ERC6909\ninterface IERC6909Claims {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OperatorSet(address indexed owner, address indexed operator, bool approved);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id, uint256 amount);\n\n    event Transfer(address caller, address indexed from, address indexed to, uint256 indexed id, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                                 FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Owner balance of an id.\n    /// @param owner The address of the owner.\n    /// @param id The id of the token.\n    /// @return amount The balance of the token.\n    function balanceOf(address owner, uint256 id) external view returns (uint256 amount);\n\n    /// @notice Spender allowance of an id.\n    /// @param owner The address of the owner.\n    /// @param spender The address of the spender.\n    /// @param id The id of the token.\n    /// @return amount The allowance of the token.\n    function allowance(address owner, address spender, uint256 id) external view returns (uint256 amount);\n\n    /// @notice Checks if a spender is approved by an owner as an operator\n    /// @param owner The address of the owner.\n    /// @param spender The address of the spender.\n    /// @return approved The approval status.\n    function isOperator(address owner, address spender) external view returns (bool approved);\n\n    /// @notice Transfers an amount of an id from the caller to a receiver.\n    /// @param receiver The address of the receiver.\n    /// @param id The id of the token.\n    /// @param amount The amount of the token.\n    /// @return bool True, always, unless the function reverts\n    function transfer(address receiver, uint256 id, uint256 amount) external returns (bool);\n\n    /// @notice Transfers an amount of an id from a sender to a receiver.\n    /// @param sender The address of the sender.\n    /// @param receiver The address of the receiver.\n    /// @param id The id of the token.\n    /// @param amount The amount of the token.\n    /// @return bool True, always, unless the function reverts\n    function transferFrom(address sender, address receiver, uint256 id, uint256 amount) external returns (bool);\n\n    /// @notice Approves an amount of an id to a spender.\n    /// @param spender The address of the spender.\n    /// @param id The id of the token.\n    /// @param amount The amount of the token.\n    /// @return bool True, always\n    function approve(address spender, uint256 id, uint256 amount) external returns (bool);\n\n    /// @notice Sets or removes an operator for the caller.\n    /// @param operator The address of the operator.\n    /// @param approved The approval status.\n    /// @return bool True, always\n    function setOperator(address operator, bool approved) external returns (bool);\n}\n"}, "lib/v4-core/src/interfaces/IProtocolFees.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Currency} from \"../types/Currency.sol\";\nimport {PoolId} from \"../types/PoolId.sol\";\nimport {PoolKey} from \"../types/PoolKey.sol\";\n\n/// @notice Interface for all protocol-fee related functions in the pool manager\ninterface IProtocolFees {\n    /// @notice Thrown when protocol fee is set too high\n    error ProtocolFeeTooLarge(uint24 fee);\n\n    /// @notice Thrown when collectProtocolFees or setProtocolFee is not called by the controller.\n    error InvalidCaller();\n\n    /// @notice Thrown when collectProtocolFees is attempted on a token that is synced.\n    error ProtocolFeeCurrencySynced();\n\n    /// @notice Emitted when the protocol fee controller address is updated in setProtocolFeeController.\n    event ProtocolFeeControllerUpdated(address indexed protocolFeeController);\n\n    /// @notice Emitted when the protocol fee is updated for a pool.\n    event ProtocolFeeUpdated(PoolId indexed id, uint24 protocolFee);\n\n    /// @notice Given a currency address, returns the protocol fees accrued in that currency\n    /// @param currency The currency to check\n    /// @return amount The amount of protocol fees accrued in the currency\n    function protocolFeesAccrued(Currency currency) external view returns (uint256 amount);\n\n    /// @notice Sets the protocol fee for the given pool\n    /// @param key The key of the pool to set a protocol fee for\n    /// @param newProtocolFee The fee to set\n    function setProtocolFee(PoolKey memory key, uint24 newProtocolFee) external;\n\n    /// @notice Sets the protocol fee controller\n    /// @param controller The new protocol fee controller\n    function setProtocolFeeController(address controller) external;\n\n    /// @notice Collects the protocol fees for a given recipient and currency, returning the amount collected\n    /// @dev This will revert if the contract is unlocked\n    /// @param recipient The address to receive the protocol fees\n    /// @param currency The currency to withdraw\n    /// @param amount The amount of currency to withdraw\n    /// @return amountCollected The amount of currency successfully withdrawn\n    function collectProtocolFees(address recipient, Currency currency, uint256 amount)\n        external\n        returns (uint256 amountCollected);\n\n    /// @notice Returns the current protocol fee controller address\n    /// @return address The current protocol fee controller address\n    function protocolFeeController() external view returns (address);\n}\n"}, "lib/v4-core/src/types/BalanceDelta.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {SafeCast} from \"../libraries/SafeCast.sol\";\n\n/// @dev Two `int128` values packed into a single `int256` where the upper 128 bits represent the amount0\n/// and the lower 128 bits represent the amount1.\ntype BalanceDelta is int256;\n\nusing {add as +, sub as -, eq as ==, neq as !=} for BalanceDelta global;\nusing BalanceDeltaLibrary for BalanceDelta global;\nusing SafeCast for int256;\n\nfunction toBalanceDelta(int128 _amount0, int128 _amount1) pure returns (BalanceDelta balanceDelta) {\n    assembly (\"memory-safe\") {\n        balanceDelta := or(shl(128, _amount0), and(sub(shl(128, 1), 1), _amount1))\n    }\n}\n\nfunction add(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta) {\n    int256 res0;\n    int256 res1;\n    assembly (\"memory-safe\") {\n        let a0 := sar(128, a)\n        let a1 := signextend(15, a)\n        let b0 := sar(128, b)\n        let b1 := signextend(15, b)\n        res0 := add(a0, b0)\n        res1 := add(a1, b1)\n    }\n    return toBalanceDelta(res0.toInt128(), res1.toInt128());\n}\n\nfunction sub(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta) {\n    int256 res0;\n    int256 res1;\n    assembly (\"memory-safe\") {\n        let a0 := sar(128, a)\n        let a1 := signextend(15, a)\n        let b0 := sar(128, b)\n        let b1 := signextend(15, b)\n        res0 := sub(a0, b0)\n        res1 := sub(a1, b1)\n    }\n    return toBalanceDelta(res0.toInt128(), res1.toInt128());\n}\n\nfunction eq(BalanceDelta a, BalanceDelta b) pure returns (bool) {\n    return BalanceDelta.unwrap(a) == BalanceDelta.unwrap(b);\n}\n\nfunction neq(BalanceDelta a, BalanceDelta b) pure returns (bool) {\n    return BalanceDelta.unwrap(a) != BalanceDelta.unwrap(b);\n}\n\n/// @notice Library for getting the amount0 and amount1 deltas from the BalanceDelta type\nlibrary BalanceDeltaLibrary {\n    /// @notice A BalanceDelta of 0\n    BalanceDelta public constant ZERO_DELTA = BalanceDelta.wrap(0);\n\n    function amount0(BalanceDelta balanceDelta) internal pure returns (int128 _amount0) {\n        assembly (\"memory-safe\") {\n            _amount0 := sar(128, balanceDelta)\n        }\n    }\n\n    function amount1(BalanceDelta balanceDelta) internal pure returns (int128 _amount1) {\n        assembly (\"memory-safe\") {\n            _amount1 := signextend(15, balanceDelta)\n        }\n    }\n}\n"}, "lib/v4-core/src/interfaces/IExtsload.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Interface for functions to access any storage slot in a contract\ninterface IExtsload {\n    /// @notice Called by external contracts to access granular pool state\n    /// @param slot Key of slot to sload\n    /// @return value The value of the slot as bytes32\n    function extsload(bytes32 slot) external view returns (bytes32 value);\n\n    /// @notice Called by external contracts to access granular pool state\n    /// @param startSlot Key of slot to start sloading from\n    /// @param nSlots Number of slots to load into return value\n    /// @return values List of loaded values.\n    function extsload(bytes32 startSlot, uint256 nSlots) external view returns (bytes32[] memory values);\n\n    /// @notice Called by external contracts to access sparse pool state\n    /// @param slots List of slots to SLOAD from.\n    /// @return values List of loaded values.\n    function extsload(bytes32[] calldata slots) external view returns (bytes32[] memory values);\n}\n"}, "lib/v4-core/src/interfaces/IExttload.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Interface for functions to access any transient storage slot in a contract\ninterface IExttload {\n    /// @notice Called by external contracts to access transient storage of the contract\n    /// @param slot Key of slot to tload\n    /// @return value The value of the slot as bytes32\n    function exttload(bytes32 slot) external view returns (bytes32 value);\n\n    /// @notice Called by external contracts to access sparse transient pool state\n    /// @param slots List of slots to tload\n    /// @return values List of loaded values\n    function exttload(bytes32[] calldata slots) external view returns (bytes32[] memory values);\n}\n"}, "lib/permit2/src/libraries/SafeCast160.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nlibrary SafeCast160 {\n    /// @notice Thrown when a valude greater than type(uint160).max is cast to uint160\n    error UnsafeCast();\n\n    /// @notice Safely casts uint256 to uint160\n    /// @param value The uint256 to be cast\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) revert UnsafeCast();\n        return uint160(value);\n    }\n}\n"}, "lib/v4-core/src/libraries/TickMath.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {BitMath} from \"./BitMath.sol\";\nimport {CustomRevert} from \"./CustomRevert.sol\";\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    using CustomRevert for bytes4;\n\n    /// @notice Thrown when the tick passed to #getSqrtPriceAtTick is not between MIN_TICK and MAX_TICK\n    error InvalidTick(int24 tick);\n    /// @notice Thrown when the price passed to #getTickAtSqrtPrice does not correspond to a price between MIN_TICK and MAX_TICK\n    error InvalidSqrtPrice(uint160 sqrtPriceX96);\n\n    /// @dev The minimum tick that may be passed to #getSqrtPriceAtTick computed from log base 1.0001 of 2**-128\n    /// @dev If ever MIN_TICK and MAX_TICK are not centered around 0, the absTick logic in getSqrtPriceAtTick cannot be used\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtPriceAtTick computed from log base 1.0001 of 2**128\n    /// @dev If ever MIN_TICK and MAX_TICK are not centered around 0, the absTick logic in getSqrtPriceAtTick cannot be used\n    int24 internal constant MAX_TICK = 887272;\n\n    /// @dev The minimum tick spacing value drawn from the range of type int16 that is greater than 0, i.e. min from the range [1, 32767]\n    int24 internal constant MIN_TICK_SPACING = 1;\n    /// @dev The maximum tick spacing value drawn from the range of type int16, i.e. max from the range [1, 32767]\n    int24 internal constant MAX_TICK_SPACING = type(int16).max;\n\n    /// @dev The minimum value that can be returned from #getSqrtPriceAtTick. Equivalent to getSqrtPriceAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_PRICE = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtPriceAtTick. Equivalent to getSqrtPriceAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_PRICE = 1461446703485210103287273052203988822378723970342;\n    /// @dev A threshold used for optimized bounds check, equals `MAX_SQRT_PRICE - MIN_SQRT_PRICE - 1`\n    uint160 internal constant MAX_SQRT_PRICE_MINUS_MIN_SQRT_PRICE_MINUS_ONE =\n        1461446703485210103287273052203988822378723970342 - 4295128739 - 1;\n\n    /// @notice Given a tickSpacing, compute the maximum usable tick\n    function maxUsableTick(int24 tickSpacing) internal pure returns (int24) {\n        unchecked {\n            return (MAX_TICK / tickSpacing) * tickSpacing;\n        }\n    }\n\n    /// @notice Given a tickSpacing, compute the minimum usable tick\n    function minUsableTick(int24 tickSpacing) internal pure returns (int24) {\n        unchecked {\n            return (MIN_TICK / tickSpacing) * tickSpacing;\n        }\n    }\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the price of the two assets (currency1/currency0)\n    /// at the given tick\n    function getSqrtPriceAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        unchecked {\n            uint256 absTick;\n            assembly (\"memory-safe\") {\n                tick := signextend(2, tick)\n                // mask = 0 if tick >= 0 else -1 (all 1s)\n                let mask := sar(255, tick)\n                // if tick >= 0, |tick| = tick = 0 ^ tick\n                // if tick < 0, |tick| = ~~|tick| = ~(-|tick| - 1) = ~(tick - 1) = (-1) ^ (tick - 1)\n                // either way, |tick| = mask ^ (tick + mask)\n                absTick := xor(mask, add(mask, tick))\n            }\n\n            if (absTick > uint256(int256(MAX_TICK))) InvalidTick.selector.revertWith(tick);\n\n            // The tick is decomposed into bits, and for each bit with index i that is set, the product of 1/sqrt(1.0001^(2^i))\n            // is calculated (using Q128.128). The constants used for this calculation are rounded to the nearest integer\n\n            // Equivalent to:\n            //     price = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n            //     or price = int(2**128 / sqrt(1.0001)) if (absTick & 0x1) else 1 << 128\n            uint256 price;\n            assembly (\"memory-safe\") {\n                price := xor(shl(128, 1), mul(xor(shl(128, 1), 0xfffcb933bd6fad37aa2d162d1a594001), and(absTick, 0x1)))\n            }\n            if (absTick & 0x2 != 0) price = (price * 0xfff97272373d413259a46990580e213a) >> 128;\n            if (absTick & 0x4 != 0) price = (price * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n            if (absTick & 0x8 != 0) price = (price * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n            if (absTick & 0x10 != 0) price = (price * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n            if (absTick & 0x20 != 0) price = (price * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n            if (absTick & 0x40 != 0) price = (price * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n            if (absTick & 0x80 != 0) price = (price * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n            if (absTick & 0x100 != 0) price = (price * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n            if (absTick & 0x200 != 0) price = (price * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n            if (absTick & 0x400 != 0) price = (price * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n            if (absTick & 0x800 != 0) price = (price * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n            if (absTick & 0x1000 != 0) price = (price * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n            if (absTick & 0x2000 != 0) price = (price * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n            if (absTick & 0x4000 != 0) price = (price * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n            if (absTick & 0x8000 != 0) price = (price * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n            if (absTick & 0x10000 != 0) price = (price * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n            if (absTick & 0x20000 != 0) price = (price * 0x5d6af8dedb81196699c329225ee604) >> 128;\n            if (absTick & 0x40000 != 0) price = (price * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n            if (absTick & 0x80000 != 0) price = (price * 0x48a170391f7dc42444e8fa2) >> 128;\n\n            assembly (\"memory-safe\") {\n                // if (tick > 0) price = type(uint256).max / price;\n                if sgt(tick, 0) { price := div(not(0), price) }\n\n                // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n                // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n                // we round up in the division so getTickAtSqrtPrice of the output price is always consistent\n                // `sub(shl(32, 1), 1)` is `type(uint32).max`\n                // `price + type(uint32).max` will not overflow because `price` fits in 192 bits\n                sqrtPriceX96 := shr(32, add(price, sub(shl(32, 1), 1)))\n            }\n        }\n    }\n\n    /// @notice Calculates the greatest tick value such that getSqrtPriceAtTick(tick) <= sqrtPriceX96\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_PRICE, as MIN_SQRT_PRICE is the lowest value getSqrtPriceAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt price for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the getSqrtPriceAtTick(tick) is less than or equal to the input sqrtPriceX96\n    function getTickAtSqrtPrice(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        unchecked {\n            // Equivalent: if (sqrtPriceX96 < MIN_SQRT_PRICE || sqrtPriceX96 >= MAX_SQRT_PRICE) revert InvalidSqrtPrice();\n            // second inequality must be >= because the price can never reach the price at the max tick\n            // if sqrtPriceX96 < MIN_SQRT_PRICE, the `sub` underflows and `gt` is true\n            // if sqrtPriceX96 >= MAX_SQRT_PRICE, sqrtPriceX96 - MIN_SQRT_PRICE > MAX_SQRT_PRICE - MIN_SQRT_PRICE - 1\n            if ((sqrtPriceX96 - MIN_SQRT_PRICE) > MAX_SQRT_PRICE_MINUS_MIN_SQRT_PRICE_MINUS_ONE) {\n                InvalidSqrtPrice.selector.revertWith(sqrtPriceX96);\n            }\n\n            uint256 price = uint256(sqrtPriceX96) << 32;\n\n            uint256 r = price;\n            uint256 msb = BitMath.mostSignificantBit(r);\n\n            if (msb >= 128) r = price >> (msb - 127);\n            else r = price << (127 - msb);\n\n            int256 log_2 = (int256(msb) - 128) << 64;\n\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(63, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(62, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(61, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(60, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(59, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(58, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(57, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(56, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(55, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(54, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(53, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(52, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(51, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(50, f))\n            }\n\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // Q22.128 number\n\n            // Magic number represents the ceiling of the maximum value of the error when approximating log_sqrt10001(x)\n            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n\n            // Magic number represents the minimum value of the error when approximating log_sqrt10001(x), when\n            // sqrtPrice is from the range (2^-64, 2^64). This is safe as MIN_SQRT_PRICE is more than 2^-64. If MIN_SQRT_PRICE\n            // is changed, this may need to be changed too\n            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n            tick = tickLow == tickHi ? tickLow : getSqrtPriceAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n        }\n    }\n}\n"}, "lib/v4-core/src/libraries/SafeCast.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {CustomRevert} from \"./CustomRevert.sol\";\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n    using CustomRevert for bytes4;\n\n    error SafeCastOverflow();\n\n    /// @notice Cast a uint256 to a uint160, revert on overflow\n    /// @param x The uint256 to be downcasted\n    /// @return y The downcasted integer, now type uint160\n    function toUint160(uint256 x) internal pure returns (uint160 y) {\n        y = uint160(x);\n        if (y != x) SafeCastOverflow.selector.revertWith();\n    }\n\n    /// @notice Cast a uint256 to a uint128, revert on overflow\n    /// @param x The uint256 to be downcasted\n    /// @return y The downcasted integer, now type uint128\n    function toUint128(uint256 x) internal pure returns (uint128 y) {\n        y = uint128(x);\n        if (x != y) SafeCastOverflow.selector.revertWith();\n    }\n\n    /// @notice Cast a int128 to a uint128, revert on overflow or underflow\n    /// @param x The int128 to be casted\n    /// @return y The casted integer, now type uint128\n    function toUint128(int128 x) internal pure returns (uint128 y) {\n        if (x < 0) SafeCastOverflow.selector.revertWith();\n        y = uint128(x);\n    }\n\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\n    /// @param x The int256 to be downcasted\n    /// @return y The downcasted integer, now type int128\n    function toInt128(int256 x) internal pure returns (int128 y) {\n        y = int128(x);\n        if (y != x) SafeCastOverflow.selector.revertWith();\n    }\n\n    /// @notice Cast a uint256 to a int256, revert on overflow\n    /// @param x The uint256 to be casted\n    /// @return y The casted integer, now type int256\n    function toInt256(uint256 x) internal pure returns (int256 y) {\n        y = int256(x);\n        if (y < 0) SafeCastOverflow.selector.revertWith();\n    }\n\n    /// @notice Cast a uint256 to a int128, revert on overflow\n    /// @param x The uint256 to be downcasted\n    /// @return The downcasted integer, now type int128\n    function toInt128(uint256 x) internal pure returns (int128) {\n        if (x >= 1 << 127) SafeCastOverflow.selector.revertWith();\n        return int128(int256(x));\n    }\n}\n"}, "lib/v4-periphery/src/libraries/PathKey.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Currency} from \"@uniswap/v4-core/src/types/Currency.sol\";\nimport {IHooks} from \"@uniswap/v4-core/src/interfaces/IHooks.sol\";\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\n\nstruct PathKey {\n    Currency intermediateCurrency;\n    uint24 fee;\n    int24 tickSpacing;\n    IHooks hooks;\n    bytes hookData;\n}\n\nusing PathKeyLibrary for PathKey global;\n\n/// @title PathKey Library\n/// @notice Functions for working with PathKeys\nlibrary PathKeyLibrary {\n    /// @notice Get the pool and swap direction for a given PathKey\n    /// @param params the given PathKey\n    /// @param currencyIn the input currency\n    /// @return poolKey the pool key of the swap\n    /// @return zeroForOne the direction of the swap, true if currency0 is being swapped for currency1\n    function getPoolAndSwapDirection(PathKey calldata params, Currency currencyIn)\n        internal\n        pure\n        returns (PoolKey memory poolKey, bool zeroForOne)\n    {\n        Currency currencyOut = params.intermediateCurrency;\n        (Currency currency0, Currency currency1) =\n            currencyIn < currencyOut ? (currencyIn, currencyOut) : (currencyOut, currencyIn);\n\n        zeroForOne = currencyIn == currency0;\n        poolKey = PoolKey(currency0, currency1, params.fee, params.tickSpacing, params.hooks);\n    }\n}\n"}, "lib/v4-periphery/src/base/BaseActionsRouter.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\nimport {SafeCallback} from \"./SafeCallback.sol\";\nimport {CalldataDecoder} from \"../libraries/CalldataDecoder.sol\";\nimport {ActionConstants} from \"../libraries/ActionConstants.sol\";\n\n/// @notice Abstract contract for performing a combination of actions on Uniswap v4.\n/// @dev Suggested uint256 action values are defined in Actions.sol, however any definition can be used\nabstract contract BaseActionsRouter is SafeCallback {\n    using CalldataDecoder for bytes;\n\n    /// @notice emitted when different numbers of parameters and actions are provided\n    error InputLengthMismatch();\n\n    /// @notice emitted when an inheriting contract does not support an action\n    error UnsupportedAction(uint256 action);\n\n    constructor(IPoolManager _poolManager) SafeCallback(_poolManager) {}\n\n    /// @notice internal function that triggers the execution of a set of actions on v4\n    /// @dev inheriting contracts should call this function to trigger execution\n    function _executeActions(bytes calldata unlockData) internal {\n        poolManager.unlock(unlockData);\n    }\n\n    /// @notice function that is called by the PoolManager through the SafeCallback.unlockCallback\n    /// @param data Abi encoding of (bytes actions, bytes[] params)\n    /// where params[i] is the encoded parameters for actions[i]\n    function _unlockCallback(bytes calldata data) internal override returns (bytes memory) {\n        // abi.decode(data, (bytes, bytes[]));\n        (bytes calldata actions, bytes[] calldata params) = data.decodeActionsRouterParams();\n        _executeActionsWithoutUnlock(actions, params);\n        return \"\";\n    }\n\n    function _executeActionsWithoutUnlock(bytes calldata actions, bytes[] calldata params) internal {\n        uint256 numActions = actions.length;\n        if (numActions != params.length) revert InputLengthMismatch();\n\n        for (uint256 actionIndex = 0; actionIndex < numActions; actionIndex++) {\n            uint256 action = uint8(actions[actionIndex]);\n\n            _handleAction(action, params[actionIndex]);\n        }\n    }\n\n    /// @notice function to handle the parsing and execution of an action and its parameters\n    function _handleAction(uint256 action, bytes calldata params) internal virtual;\n\n    /// @notice function that returns address considered executor of the actions\n    /// @dev The other context functions, _msgData and _msgValue, are not supported by this contract\n    /// In many contracts this will be the address that calls the initial entry point that calls `_executeActions`\n    /// `msg.sender` shouldn't be used, as this will be the v4 pool manager contract that calls `unlockCallback`\n    /// If using ReentrancyLock.sol, this function can return _getLocker()\n    function msgSender() public view virtual returns (address);\n\n    /// @notice Calculates the address for a action\n    function _mapRecipient(address recipient) internal view returns (address) {\n        if (recipient == ActionConstants.MSG_SENDER) {\n            return msgSender();\n        } else if (recipient == ActionConstants.ADDRESS_THIS) {\n            return address(this);\n        } else {\n            return recipient;\n        }\n    }\n\n    /// @notice Calculates the payer for an action\n    function _mapPayer(bool payerIsUser) internal view returns (address) {\n        return payerIsUser ? msgSender() : address(this);\n    }\n}\n"}, "lib/v4-periphery/src/base/DeltaResolver.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Currency} from \"@uniswap/v4-core/src/types/Currency.sol\";\nimport {TransientStateLibrary} from \"@uniswap/v4-core/src/libraries/TransientStateLibrary.sol\";\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\nimport {ImmutableState} from \"./ImmutableState.sol\";\nimport {ActionConstants} from \"../libraries/ActionConstants.sol\";\n\n/// @notice Abstract contract used to sync, send, and settle funds to the pool manager\n/// @dev Note that sync() is called before any erc-20 transfer in `settle`.\nabstract contract DeltaResolver is ImmutableState {\n    using TransientStateLibrary for IPoolManager;\n\n    /// @notice Emitted trying to settle a positive delta.\n    error DeltaNotPositive(Currency currency);\n    /// @notice Emitted trying to take a negative delta.\n    error DeltaNotNegative(Currency currency);\n    /// @notice Emitted when the contract does not have enough balance to wrap or unwrap.\n    error InsufficientBalance();\n\n    /// @notice Take an amount of currency out of the PoolManager\n    /// @param currency Currency to take\n    /// @param recipient Address to receive the currency\n    /// @param amount Amount to take\n    /// @dev Returns early if the amount is 0\n    function _take(Currency currency, address recipient, uint256 amount) internal {\n        if (amount == 0) return;\n        poolManager.take(currency, recipient, amount);\n    }\n\n    /// @notice Pay and settle a currency to the PoolManager\n    /// @dev The implementing contract must ensure that the `payer` is a secure address\n    /// @param currency Currency to settle\n    /// @param payer Address of the payer\n    /// @param amount Amount to send\n    /// @dev Returns early if the amount is 0\n    function _settle(Currency currency, address payer, uint256 amount) internal {\n        if (amount == 0) return;\n\n        poolManager.sync(currency);\n        if (currency.isAddressZero()) {\n            poolManager.settle{value: amount}();\n        } else {\n            _pay(currency, payer, amount);\n            poolManager.settle();\n        }\n    }\n\n    /// @notice Abstract function for contracts to implement paying tokens to the poolManager\n    /// @dev The recipient of the payment should be the poolManager\n    /// @param token The token to settle. This is known not to be the native currency\n    /// @param payer The address who should pay tokens\n    /// @param amount The number of tokens to send\n    function _pay(Currency token, address payer, uint256 amount) internal virtual;\n\n    /// @notice Obtain the full amount owed by this contract (negative delta)\n    /// @param currency Currency to get the delta for\n    /// @return amount The amount owed by this contract as a uint256\n    function _getFullDebt(Currency currency) internal view returns (uint256 amount) {\n        int256 _amount = poolManager.currencyDelta(address(this), currency);\n        // If the amount is positive, it should be taken not settled.\n        if (_amount > 0) revert DeltaNotNegative(currency);\n        // Casting is safe due to limits on the total supply of a pool\n        amount = uint256(-_amount);\n    }\n\n    /// @notice Obtain the full credit owed to this contract (positive delta)\n    /// @param currency Currency to get the delta for\n    /// @return amount The amount owed to this contract as a uint256\n    function _getFullCredit(Currency currency) internal view returns (uint256 amount) {\n        int256 _amount = poolManager.currencyDelta(address(this), currency);\n        // If the amount is negative, it should be settled not taken.\n        if (_amount < 0) revert DeltaNotPositive(currency);\n        amount = uint256(_amount);\n    }\n\n    /// @notice Calculates the amount for a settle action\n    function _mapSettleAmount(uint256 amount, Currency currency) internal view returns (uint256) {\n        if (amount == ActionConstants.CONTRACT_BALANCE) {\n            return currency.balanceOfSelf();\n        } else if (amount == ActionConstants.OPEN_DELTA) {\n            return _getFullDebt(currency);\n        } else {\n            return amount;\n        }\n    }\n\n    /// @notice Calculates the amount for a take action\n    function _mapTakeAmount(uint256 amount, Currency currency) internal view returns (uint256) {\n        if (amount == ActionConstants.OPEN_DELTA) {\n            return _getFullCredit(currency);\n        } else {\n            return amount;\n        }\n    }\n\n    /// @notice Calculates the sanitized amount before wrapping/unwrapping.\n    /// @param inputCurrency The currency, either native or wrapped native, that this contract holds\n    /// @param amount The amount to wrap or unwrap. Can be CONTRACT_BALANCE, OPEN_DELTA or a specific amount\n    /// @param outputCurrency The currency after the wrap/unwrap that the user may owe a balance in on the poolManager\n    function _mapWrapUnwrapAmount(Currency inputCurrency, uint256 amount, Currency outputCurrency)\n        internal\n        view\n        returns (uint256)\n    {\n        // if wrapping, the balance in this contract is in ETH\n        // if unwrapping, the balance in this contract is in WETH\n        uint256 balance = inputCurrency.balanceOf(address(this));\n        if (amount == ActionConstants.CONTRACT_BALANCE) {\n            // return early to avoid unnecessary balance check\n            return balance;\n        }\n        if (amount == ActionConstants.OPEN_DELTA) {\n            // if wrapping, the open currency on the PoolManager is WETH.\n            // if unwrapping, the open currency on the PoolManager is ETH.\n            // note that we use the DEBT amount. Positive deltas can be taken and then wrapped.\n            amount = _getFullDebt(outputCurrency);\n        }\n        if (amount > balance) revert InsufficientBalance();\n        return amount;\n    }\n}\n"}, "lib/v4-core/src/interfaces/external/IERC20Minimal.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title Minimal ERC20 interface for Uniswap\n/// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3\ninterface IERC20Minimal {\n    /// @notice Returns an account's balance in the token\n    /// @param account The account for which to look up the number of tokens it has, i.e. its balance\n    /// @return The number of tokens held by the account\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Transfers the amount of token from the `msg.sender` to the recipient\n    /// @param recipient The account that will receive the amount transferred\n    /// @param amount The number of tokens to send from the sender to the recipient\n    /// @return Returns true for a successful transfer, false for an unsuccessful transfer\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /// @notice Returns the current allowance given to a spender by an owner\n    /// @param owner The account of the token owner\n    /// @param spender The account of the token spender\n    /// @return The current allowance granted by `owner` to `spender`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`\n    /// @param spender The account which will be allowed to spend a given amount of the owners tokens\n    /// @param amount The amount of tokens allowed to be used by `spender`\n    /// @return Returns true for a successful approval, false for unsuccessful\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`\n    /// @param sender The account from which the transfer will be initiated\n    /// @param recipient The recipient of the transfer\n    /// @param amount The amount of the transfer\n    /// @return Returns true for a successful transfer, false for unsuccessful\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.\n    /// @param from The account from which the tokens were sent, i.e. the balance decreased\n    /// @param to The account to which the tokens were sent, i.e. the balance increased\n    /// @param value The amount of tokens that were transferred\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.\n    /// @param owner The account that approved spending of its tokens\n    /// @param spender The account for which the spending allowance was modified\n    /// @param value The new allowance from the owner to the spender\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"}, "lib/v4-core/src/libraries/CustomRevert.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title Library for reverting with custom errors efficiently\n/// @notice Contains functions for reverting with custom errors with different argument types efficiently\n/// @dev To use this library, declare `using CustomRevert for bytes4;` and replace `revert CustomError()` with\n/// `CustomError.selector.revertWith()`\n/// @dev The functions may tamper with the free memory pointer but it is fine since the call context is exited immediately\nlibrary CustomRevert {\n    /// @dev ERC-7751 error for wrapping bubbled up reverts\n    error WrappedError(address target, bytes4 selector, bytes reason, bytes details);\n\n    /// @dev Reverts with the selector of a custom error in the scratch space\n    function revertWith(bytes4 selector) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            revert(0, 0x04)\n        }\n    }\n\n    /// @dev Reverts with a custom error with an address argument in the scratch space\n    function revertWith(bytes4 selector, address addr) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, and(addr, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(0, 0x24)\n        }\n    }\n\n    /// @dev Reverts with a custom error with an int24 argument in the scratch space\n    function revertWith(bytes4 selector, int24 value) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, signextend(2, value))\n            revert(0, 0x24)\n        }\n    }\n\n    /// @dev Reverts with a custom error with a uint160 argument in the scratch space\n    function revertWith(bytes4 selector, uint160 value) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, and(value, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(0, 0x24)\n        }\n    }\n\n    /// @dev Reverts with a custom error with two int24 arguments\n    function revertWith(bytes4 selector, int24 value1, int24 value2) internal pure {\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(fmp, selector)\n            mstore(add(fmp, 0x04), signextend(2, value1))\n            mstore(add(fmp, 0x24), signextend(2, value2))\n            revert(fmp, 0x44)\n        }\n    }\n\n    /// @dev Reverts with a custom error with two uint160 arguments\n    function revertWith(bytes4 selector, uint160 value1, uint160 value2) internal pure {\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(fmp, selector)\n            mstore(add(fmp, 0x04), and(value1, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(add(fmp, 0x24), and(value2, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(fmp, 0x44)\n        }\n    }\n\n    /// @dev Reverts with a custom error with two address arguments\n    function revertWith(bytes4 selector, address value1, address value2) internal pure {\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(fmp, selector)\n            mstore(add(fmp, 0x04), and(value1, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(add(fmp, 0x24), and(value2, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(fmp, 0x44)\n        }\n    }\n\n    /// @notice bubble up the revert message returned by a call and revert with a wrapped ERC-7751 error\n    /// @dev this method can be vulnerable to revert data bombs\n    function bubbleUpAndRevertWith(\n        address revertingContract,\n        bytes4 revertingFunctionSelector,\n        bytes4 additionalContext\n    ) internal pure {\n        bytes4 wrappedErrorSelector = WrappedError.selector;\n        assembly (\"memory-safe\") {\n            // Ensure the size of the revert data is a multiple of 32 bytes\n            let encodedDataSize := mul(div(add(returndatasize(), 31), 32), 32)\n\n            let fmp := mload(0x40)\n\n            // Encode wrapped error selector, address, function selector, offset, additional context, size, revert reason\n            mstore(fmp, wrappedErrorSelector)\n            mstore(add(fmp, 0x04), and(revertingContract, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(\n                add(fmp, 0x24),\n                and(revertingFunctionSelector, 0xffffffff00000000000000000000000000000000000000000000000000000000)\n            )\n            // offset revert reason\n            mstore(add(fmp, 0x44), 0x80)\n            // offset additional context\n            mstore(add(fmp, 0x64), add(0xa0, encodedDataSize))\n            // size revert reason\n            mstore(add(fmp, 0x84), returndatasize())\n            // revert reason\n            returndatacopy(add(fmp, 0xa4), 0, returndatasize())\n            // size additional context\n            mstore(add(fmp, add(0xa4, encodedDataSize)), 0x04)\n            // additional context\n            mstore(\n                add(fmp, add(0xc4, encodedDataSize)),\n                and(additionalContext, 0xffffffff00000000000000000000000000000000000000000000000000000000)\n            )\n            revert(fmp, add(0xe4, encodedDataSize))\n        }\n    }\n}\n"}, "lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Metadata.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.30;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"}, "lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.30;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"}, "lib/universal-router/lib/v3-periphery/contracts/interfaces/IPoolInitializer.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\npragma abicoder v2;\n\n/// @title Creates and initializes V3 Pools\n/// @notice Provides a method for creating and initializing a pool, if necessary, for bundling with other methods that\n/// require the pool to exist.\ninterface IPoolInitializer {\n    /// @notice Creates a new pool if it does not exist, then initializes if not initialized\n    /// @dev This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool\n    /// @param token0 The contract address of token0 of the pool\n    /// @param token1 The contract address of token1 of the pool\n    /// @param fee The fee amount of the v3 pool for the specified token pair\n    /// @param sqrtPriceX96 The initial square root price of the pool as a Q64.96 value\n    /// @return pool Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary\n    function createAndInitializePoolIfNecessary(\n        address token0,\n        address token1,\n        uint24 fee,\n        uint160 sqrtPriceX96\n    ) external payable returns (address pool);\n}\n"}, "lib/universal-router/lib/v3-periphery/contracts/interfaces/IPeripheryPayments.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\n/// @title Periphery Payments\n/// @notice Functions to ease deposits and withdrawals of ETH\ninterface IPeripheryPayments {\n    /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH.\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.\n    /// @param amountMinimum The minimum amount of WETH9 to unwrap\n    /// @param recipient The address receiving ETH\n    function unwrapWETH9(uint256 amountMinimum, address recipient) external payable;\n\n    /// @notice Refunds any ETH balance held by this contract to the `msg.sender`\n    /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps\n    /// that use ether for the input amount\n    function refundETH() external payable;\n\n    /// @notice Transfers the full amount of a token held by this contract to recipient\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users\n    /// @param token The contract address of the token which will be transferred to `recipient`\n    /// @param amountMinimum The minimum amount of token required for a transfer\n    /// @param recipient The destination address of the token\n    function sweepToken(\n        address token,\n        uint256 amountMinimum,\n        address recipient\n    ) external payable;\n}\n"}, "lib/universal-router/lib/v3-periphery/contracts/interfaces/IPeripheryImmutableState.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\n/// @title Immutable state\n/// @notice Functions that return immutable state of the router\ninterface IPeripheryImmutableState {\n    /// @return Returns the address of the Uniswap V3 factory\n    function factory() external view returns (address);\n\n    /// @return Returns the address of WETH9\n    function WETH9() external view returns (address);\n}\n"}, "lib/universal-router/lib/v3-periphery/contracts/libraries/PoolAddress.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\n/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee\nlibrary PoolAddress {\n    bytes32 internal constant POOL_INIT_CODE_HASH = 0xa598dd2fba360510c5a8f02f44423a4468e902df5857dbce3ca162a43a3a31ff;\n\n    /// @notice The identifying key of the pool\n    struct PoolKey {\n        address token0;\n        address token1;\n        uint24 fee;\n    }\n\n    /// @notice Returns PoolKey: the ordered tokens with the matched fee levels\n    /// @param tokenA The first token of a pool, unsorted\n    /// @param tokenB The second token of a pool, unsorted\n    /// @param fee The fee level of the pool\n    /// @return Poolkey The pool details with ordered token0 and token1 assignments\n    function getPoolKey(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) internal pure returns (PoolKey memory) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\n    }\n\n    /// @notice Deterministically computes the pool address given the factory and PoolKey\n    /// @param factory The Uniswap V3 factory contract address\n    /// @param key The PoolKey\n    /// @return pool The contract address of the V3 pool\n    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {\n        require(key.token0 < key.token1);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            factory,\n                            keccak256(abi.encode(key.token0, key.token1, key.fee)),\n                            POOL_INIT_CODE_HASH\n                        )\n                    )\n                )\n            )\n        );\n    }\n}\n"}, "lib/v4-periphery/src/libraries/PositionInfoLibrary.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\nimport {PoolId} from \"@uniswap/v4-core/src/types/PoolId.sol\";\n\n/**\n * @dev PositionInfo is a packed version of solidity structure.\n * Using the packaged version saves gas and memory by not storing the structure fields in memory slots.\n *\n * Layout:\n * 200 bits poolId | 24 bits tickUpper | 24 bits tickLower | 8 bits hasSubscriber\n *\n * Fields in the direction from the least significant bit:\n *\n * A flag to know if the tokenId is subscribed to an address\n * uint8 hasSubscriber;\n *\n * The tickUpper of the position\n * int24 tickUpper;\n *\n * The tickLower of the position\n * int24 tickLower;\n *\n * The truncated poolId. Truncates a bytes32 value so the most signifcant (highest) 200 bits are used.\n * bytes25 poolId;\n *\n * Note: If more bits are needed, hasSubscriber can be a single bit.\n *\n */\ntype PositionInfo is uint256;\n\nusing PositionInfoLibrary for PositionInfo global;\n\nlibrary PositionInfoLibrary {\n    PositionInfo internal constant EMPTY_POSITION_INFO = PositionInfo.wrap(0);\n\n    uint256 internal constant MASK_UPPER_200_BITS = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000;\n    uint256 internal constant MASK_8_BITS = 0xFF;\n    uint24 internal constant MASK_24_BITS = 0xFFFFFF;\n    uint256 internal constant SET_UNSUBSCRIBE = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00;\n    uint256 internal constant SET_SUBSCRIBE = 0x01;\n    uint8 internal constant TICK_LOWER_OFFSET = 8;\n    uint8 internal constant TICK_UPPER_OFFSET = 32;\n\n    /// @dev This poolId is NOT compatible with the poolId used in UniswapV4 core. It is truncated to 25 bytes, and just used to lookup PoolKey in the poolKeys mapping.\n    function poolId(PositionInfo info) internal pure returns (bytes25 _poolId) {\n        assembly (\"memory-safe\") {\n            _poolId := and(MASK_UPPER_200_BITS, info)\n        }\n    }\n\n    function tickLower(PositionInfo info) internal pure returns (int24 _tickLower) {\n        assembly (\"memory-safe\") {\n            _tickLower := signextend(2, shr(TICK_LOWER_OFFSET, info))\n        }\n    }\n\n    function tickUpper(PositionInfo info) internal pure returns (int24 _tickUpper) {\n        assembly (\"memory-safe\") {\n            _tickUpper := signextend(2, shr(TICK_UPPER_OFFSET, info))\n        }\n    }\n\n    function hasSubscriber(PositionInfo info) internal pure returns (bool _hasSubscriber) {\n        assembly (\"memory-safe\") {\n            _hasSubscriber := and(MASK_8_BITS, info)\n        }\n    }\n\n    /// @dev this does not actually set any storage\n    function setSubscribe(PositionInfo info) internal pure returns (PositionInfo _info) {\n        assembly (\"memory-safe\") {\n            _info := or(info, SET_SUBSCRIBE)\n        }\n    }\n\n    /// @dev this does not actually set any storage\n    function setUnsubscribe(PositionInfo info) internal pure returns (PositionInfo _info) {\n        assembly (\"memory-safe\") {\n            _info := and(info, SET_UNSUBSCRIBE)\n        }\n    }\n\n    /// @notice Creates the default PositionInfo struct\n    /// @dev Called when minting a new position\n    /// @param _poolKey the pool key of the position\n    /// @param _tickLower the lower tick of the position\n    /// @param _tickUpper the upper tick of the position\n    /// @return info packed position info, with the truncated poolId and the hasSubscriber flag set to false\n    function initialize(PoolKey memory _poolKey, int24 _tickLower, int24 _tickUpper)\n        internal\n        pure\n        returns (PositionInfo info)\n    {\n        bytes25 _poolId = bytes25(PoolId.unwrap(_poolKey.toId()));\n        assembly {\n            info :=\n                or(\n                    or(and(MASK_UPPER_200_BITS, _poolId), shl(TICK_UPPER_OFFSET, and(MASK_24_BITS, _tickUpper))),\n                    shl(TICK_LOWER_OFFSET, and(MASK_24_BITS, _tickLower))\n                )\n        }\n    }\n}\n"}, "lib/v4-periphery/src/interfaces/INotifier.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {ISubscriber} from \"./ISubscriber.sol\";\n\n/// @title INotifier\n/// @notice Interface for the Notifier contract\ninterface INotifier {\n    /// @notice Thrown when unsubscribing without a subscriber\n    error NotSubscribed();\n    /// @notice Thrown when a subscriber does not have code\n    error NoCodeSubscriber();\n    /// @notice Thrown when a user specifies a gas limit too low to avoid valid unsubscribe notifications\n    error GasLimitTooLow();\n    /// @notice Wraps the revert message of the subscriber contract on a reverting subscription\n    error SubscriptionReverted(address subscriber, bytes reason);\n    /// @notice Wraps the revert message of the subscriber contract on a reverting modify liquidity notification\n    error ModifyLiquidityNotificationReverted(address subscriber, bytes reason);\n    /// @notice Wraps the revert message of the subscriber contract on a reverting burn notification\n    error BurnNotificationReverted(address subscriber, bytes reason);\n    /// @notice Thrown when a tokenId already has a subscriber\n    error AlreadySubscribed(uint256 tokenId, address subscriber);\n\n    /// @notice Emitted on a successful call to subscribe\n    event Subscription(uint256 indexed tokenId, address indexed subscriber);\n    /// @notice Emitted on a successful call to unsubscribe\n    event Unsubscription(uint256 indexed tokenId, address indexed subscriber);\n\n    /// @notice Returns the subscriber for a respective position\n    /// @param tokenId the ERC721 tokenId\n    /// @return subscriber the subscriber contract\n    function subscriber(uint256 tokenId) external view returns (ISubscriber subscriber);\n\n    /// @notice Enables the subscriber to receive notifications for a respective position\n    /// @param tokenId the ERC721 tokenId\n    /// @param newSubscriber the address of the subscriber contract\n    /// @param data caller-provided data that's forwarded to the subscriber contract\n    /// @dev Calling subscribe when a position is already subscribed will revert\n    /// @dev payable so it can be multicalled with NATIVE related actions\n    /// @dev will revert if pool manager is locked\n    function subscribe(uint256 tokenId, address newSubscriber, bytes calldata data) external payable;\n\n    /// @notice Removes the subscriber from receiving notifications for a respective position\n    /// @param tokenId the ERC721 tokenId\n    /// @dev Callers must specify a high gas limit (remaining gas should be higher than unsubscriberGasLimit) such that the subscriber can be notified\n    /// @dev payable so it can be multicalled with NATIVE related actions\n    /// @dev Must always allow a user to unsubscribe. In the case of a malicious subscriber, a user can always unsubscribe safely, ensuring liquidity is always modifiable.\n    /// @dev will revert if pool manager is locked\n    function unsubscribe(uint256 tokenId) external payable;\n\n    /// @notice Returns and determines the maximum allowable gas-used for notifying unsubscribe\n    /// @return uint256 the maximum gas limit when notifying a subscriber's `notifyUnsubscribe` function\n    function unsubscribeGasLimit() external view returns (uint256);\n}\n"}, "lib/v4-periphery/src/interfaces/IImmutableState.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\n\n/// @title IImmutableState\n/// @notice Interface for the ImmutableState contract\ninterface IImmutableState {\n    /// @notice The Uniswap v4 PoolManager contract\n    function poolManager() external view returns (IPoolManager);\n}\n"}, "lib/v4-periphery/src/interfaces/IERC721Permit_v4.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title IERC721Permit_v4\n/// @notice Interface for the ERC721Permit_v4 contract\ninterface IERC721Permit_v4 {\n    error SignatureDeadlineExpired();\n    error NoSelfPermit();\n    error Unauthorized();\n\n    /// @notice Approve of a specific token ID for spending by spender via signature\n    /// @param spender The account that is being approved\n    /// @param tokenId The ID of the token that is being approved for spending\n    /// @param deadline The deadline timestamp by which the call must be mined for the approve to work\n    /// @param nonce a unique value, for an owner, to prevent replay attacks; an unordered nonce where the top 248 bits correspond to a word and the bottom 8 bits calculate the bit position of the word\n    /// @param signature Concatenated data from a valid secp256k1 signature from the holder, i.e. abi.encodePacked(r, s, v)\n    /// @dev payable so it can be multicalled with NATIVE related actions\n    function permit(address spender, uint256 tokenId, uint256 deadline, uint256 nonce, bytes calldata signature)\n        external\n        payable;\n\n    /// @notice Set an operator with full permission to an owner's tokens via signature\n    /// @param owner The address that is setting the operator\n    /// @param operator The address that will be set as an operator for the owner\n    /// @param approved The permission to set on the operator\n    /// @param deadline The deadline timestamp by which the call must be mined for the approve to work\n    /// @param nonce a unique value, for an owner, to prevent replay attacks; an unordered nonce where the top 248 bits correspond to a word and the bottom 8 bits calculate the bit position of the word\n    /// @param signature Concatenated data from a valid secp256k1 signature from the holder, i.e. abi.encodePacked(r, s, v)\n    /// @dev payable so it can be multicalled with NATIVE related actions\n    function permitForAll(\n        address owner,\n        address operator,\n        bool approved,\n        uint256 deadline,\n        uint256 nonce,\n        bytes calldata signature\n    ) external payable;\n}\n"}, "lib/v4-periphery/src/interfaces/IEIP712_v4.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title IEIP712_v4\n/// @notice Interface for the EIP712 contract\ninterface IEIP712_v4 {\n    /// @notice Returns the domain separator for the current chain.\n    /// @return bytes32 The domain separator\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"}, "lib/v4-periphery/src/interfaces/IMulticall_v4.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title IMulticall_v4\n/// @notice Interface for the Multicall_v4 contract\ninterface IMulticall_v4 {\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n    /// @dev The `msg.value` is passed onto all subcalls, even if a previous subcall has consumed the ether.\n    /// Subcalls can instead use `address(this).value` to see the available ETH, and consume it using {value: x}.\n    /// @param data The encoded function data for each of the calls to make to this contract\n    /// @return results The results from each of the calls passed in via data\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n}\n"}, "lib/v4-periphery/src/interfaces/IPoolInitializer_v4.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\n\n/// @title IPoolInitializer_v4\n/// @notice Interface for the PoolInitializer_v4 contract\ninterface IPoolInitializer_v4 {\n    /// @notice Initialize a Uniswap v4 Pool\n    /// @dev If the pool is already initialized, this function will not revert and just return type(int24).max\n    /// @param key The PoolKey of the pool to initialize\n    /// @param sqrtPriceX96 The initial starting price of the pool, expressed as a sqrtPriceX96\n    /// @return The current tick of the pool, or type(int24).max if the pool creation failed, or the pool already existed\n    function initializePool(PoolKey calldata key, uint160 sqrtPriceX96) external payable returns (int24);\n}\n"}, "lib/v4-periphery/src/interfaces/IUnorderedNonce.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title IUnorderedNonce\n/// @notice Interface for the UnorderedNonce contract\ninterface IUnorderedNonce {\n    error NonceAlreadyUsed();\n\n    /// @notice mapping of nonces consumed by each address, where a nonce is a single bit on the 256-bit bitmap\n    /// @dev word is at most type(uint248).max\n    function nonces(address owner, uint256 word) external view returns (uint256);\n\n    /// @notice Revoke a nonce by spending it, preventing it from being used again\n    /// @dev Used in cases where a valid nonce has not been broadcasted onchain, and the owner wants to revoke the validity of the nonce\n    /// @dev payable so it can be multicalled with native-token related actions\n    function revokeNonce(uint256 nonce) external payable;\n}\n"}, "lib/v4-periphery/src/interfaces/IPermit2Forwarder.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IAllowanceTransfer} from \"permit2/src/interfaces/IAllowanceTransfer.sol\";\n\n/// @title IPermit2Forwarder\n/// @notice Interface for the Permit2Forwarder contract\ninterface IPermit2Forwarder {\n    /// @notice allows forwarding a single permit to permit2\n    /// @dev this function is payable to allow multicall with NATIVE based actions\n    /// @param owner the owner of the tokens\n    /// @param permitSingle the permit data\n    /// @param signature the signature of the permit; abi.encodePacked(r, s, v)\n    /// @return err the error returned by a reverting permit call, empty if successful\n    function permit(address owner, IAllowanceTransfer.PermitSingle calldata permitSingle, bytes calldata signature)\n        external\n        payable\n        returns (bytes memory err);\n\n    /// @notice allows forwarding batch permits to permit2\n    /// @dev this function is payable to allow multicall with NATIVE based actions\n    /// @param owner the owner of the tokens\n    /// @param _permitBatch a batch of approvals\n    /// @param signature the signature of the permit; abi.encodePacked(r, s, v)\n    /// @return err the error returned by a reverting permit call, empty if successful\n    function permitBatch(address owner, IAllowanceTransfer.PermitBatch calldata _permitBatch, bytes calldata signature)\n        external\n        payable\n        returns (bytes memory err);\n}\n"}, "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"}, "lib/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n"}, "lib/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return _liquidity The amount of liquidity in the position,\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n"}, "lib/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}\n"}, "lib/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"}, "lib/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}\n"}, "lib/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol": {"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.30;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"}, "lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.30;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"}, "lib/v4-core/src/types/BeforeSwapDelta.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n// Return type of the beforeSwap hook.\n// Upper 128 bits is the delta in specified tokens. Lower 128 bits is delta in unspecified tokens (to match the afterSwap hook)\ntype BeforeSwapDelta is int256;\n\n// Creates a BeforeSwapDelta from specified and unspecified\nfunction toBeforeSwapDelta(int128 deltaSpecified, int128 deltaUnspecified)\n    pure\n    returns (BeforeSwapDelta beforeSwapDelta)\n{\n    assembly (\"memory-safe\") {\n        beforeSwapDelta := or(shl(128, deltaSpecified), and(sub(shl(128, 1), 1), deltaUnspecified))\n    }\n}\n\n/// @notice Library for getting the specified and unspecified deltas from the BeforeSwapDelta type\nlibrary BeforeSwapDeltaLibrary {\n    /// @notice A BeforeSwapDelta of 0\n    BeforeSwapDelta public constant ZERO_DELTA = BeforeSwapDelta.wrap(0);\n\n    /// extracts int128 from the upper 128 bits of the BeforeSwapDelta\n    /// returned by beforeSwap\n    function getSpecifiedDelta(BeforeSwapDelta delta) internal pure returns (int128 deltaSpecified) {\n        assembly (\"memory-safe\") {\n            deltaSpecified := sar(128, delta)\n        }\n    }\n\n    /// extracts int128 from the lower 128 bits of the BeforeSwapDelta\n    /// returned by beforeSwap and afterSwap\n    function getUnspecifiedDelta(BeforeSwapDelta delta) internal pure returns (int128 deltaUnspecified) {\n        assembly (\"memory-safe\") {\n            deltaUnspecified := signextend(15, delta)\n        }\n    }\n}\n"}, "lib/v4-core/src/libraries/BitMath.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title BitMath\n/// @dev This library provides functionality for computing bit properties of an unsigned integer\n/// @author Solady (https://github.com/Vectorized/solady/blob/8200a70e8dc2a77ecb074fc2e99a2a0d36547522/src/utils/LibBit.sol)\nlibrary BitMath {\n    /// @notice Returns the index of the most significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @param x the value for which to compute the most significant bit, must be greater than 0\n    /// @return r the index of the most significant bit\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        assembly (\"memory-safe\") {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020500060203020504000106050205030304010505030400000000))\n        }\n    }\n\n    /// @notice Returns the index of the least significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @param x the value for which to compute the least significant bit, must be greater than 0\n    /// @return r the index of the least significant bit\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        assembly (\"memory-safe\") {\n            // Isolate the least significant bit.\n            x := and(x, sub(0, x))\n            // For the upper 3 bits of the result, use a De Bruijn-like lookup.\n            // Credit to adhusson: https://blog.adhusson.com/cheap-find-first-set-evm/\n            // forgefmt: disable-next-item\n            r := shl(5, shr(252, shl(shl(2, shr(250, mul(x,\n                0xb6db6db6ddddddddd34d34d349249249210842108c6318c639ce739cffffffff))),\n                0x8040405543005266443200005020610674053026020000107506200176117077)))\n            // For the lower 5 bits of the result, use a De Bruijn lookup.\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(div(0xd76453e0, shr(r, x)), 0x1f),\n                0x001f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405))\n        }\n    }\n}\n"}, "lib/v4-periphery/src/base/SafeCallback.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IUnlockCallback} from \"@uniswap/v4-core/src/interfaces/callback/IUnlockCallback.sol\";\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\nimport {ImmutableState} from \"./ImmutableState.sol\";\n\n/// @title Safe Callback\n/// @notice A contract that only allows the Uniswap v4 PoolManager to call the unlockCallback\nabstract contract SafeCallback is ImmutableState, IUnlockCallback {\n    constructor(IPoolManager _poolManager) ImmutableState(_poolManager) {}\n\n    /// @inheritdoc IUnlockCallback\n    /// @dev We force the onlyPoolManager modifier by exposing a virtual function after the onlyPoolManager check.\n    function unlockCallback(bytes calldata data) external onlyPoolManager returns (bytes memory) {\n        return _unlockCallback(data);\n    }\n\n    /// @dev to be implemented by the child contract, to safely guarantee the logic is only executed by the PoolManager\n    function _unlockCallback(bytes calldata data) internal virtual returns (bytes memory);\n}\n"}, "lib/v4-core/src/libraries/TransientStateLibrary.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IPoolManager} from \"../interfaces/IPoolManager.sol\";\nimport {Currency} from \"../types/Currency.sol\";\nimport {CurrencyReserves} from \"./CurrencyReserves.sol\";\nimport {NonzeroDeltaCount} from \"./NonzeroDeltaCount.sol\";\nimport {Lock} from \"./Lock.sol\";\n\n/// @notice A helper library to provide state getters that use exttload\nlibrary TransientStateLibrary {\n    /// @notice returns the reserves for the synced currency\n    /// @param manager The pool manager contract.\n\n    /// @return uint256 The reserves of the currency.\n    /// @dev returns 0 if the reserves are not synced or value is 0.\n    /// Checks the synced currency to only return valid reserve values (after a sync and before a settle).\n    function getSyncedReserves(IPoolManager manager) internal view returns (uint256) {\n        if (getSyncedCurrency(manager).isAddressZero()) return 0;\n        return uint256(manager.exttload(CurrencyReserves.RESERVES_OF_SLOT));\n    }\n\n    function getSyncedCurrency(IPoolManager manager) internal view returns (Currency) {\n        return Currency.wrap(address(uint160(uint256(manager.exttload(CurrencyReserves.CURRENCY_SLOT)))));\n    }\n\n    /// @notice Returns the number of nonzero deltas open on the PoolManager that must be zeroed out before the contract is locked\n    function getNonzeroDeltaCount(IPoolManager manager) internal view returns (uint256) {\n        return uint256(manager.exttload(NonzeroDeltaCount.NONZERO_DELTA_COUNT_SLOT));\n    }\n\n    /// @notice Get the current delta for a caller in the given currency\n    /// @param target The credited account address\n    /// @param currency The currency for which to lookup the delta\n    function currencyDelta(IPoolManager manager, address target, Currency currency) internal view returns (int256) {\n        bytes32 key;\n        assembly (\"memory-safe\") {\n            mstore(0, and(target, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(32, and(currency, 0xffffffffffffffffffffffffffffffffffffffff))\n            key := keccak256(0, 64)\n        }\n        return int256(uint256(manager.exttload(key)));\n    }\n\n    /// @notice Returns whether the contract is unlocked or not\n    function isUnlocked(IPoolManager manager) internal view returns (bool) {\n        return manager.exttload(Lock.IS_UNLOCKED_SLOT) != 0x0;\n    }\n}\n"}, "lib/v4-periphery/src/base/ImmutableState.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\nimport {IImmutableState} from \"../interfaces/IImmutableState.sol\";\n\n/// @title Immutable State\n/// @notice A collection of immutable state variables, commonly used across multiple contracts\ncontract ImmutableState is IImmutableState {\n    /// @inheritdoc IImmutableState\n    IPoolManager public immutable poolManager;\n\n    /// @notice Thrown when the caller is not PoolManager\n    error NotPoolManager();\n\n    /// @notice Only allow calls from the PoolManager contract\n    modifier onlyPoolManager() {\n        if (msg.sender != address(poolManager)) revert NotPoolManager();\n        _;\n    }\n\n    constructor(IPoolManager _poolManager) {\n        poolManager = _poolManager;\n    }\n}\n"}, "lib/v4-periphery/src/interfaces/ISubscriber.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {BalanceDelta} from \"@uniswap/v4-core/src/types/BalanceDelta.sol\";\nimport {PositionInfo} from \"../libraries/PositionInfoLibrary.sol\";\n\n/// @title ISubscriber\n/// @notice Interface that a Subscriber contract should implement to receive updates from the v4 position manager\ninterface ISubscriber {\n    /// @notice Called when a position subscribes to this subscriber contract\n    /// @param tokenId the token ID of the position\n    /// @param data additional data passed in by the caller\n    function notifySubscribe(uint256 tokenId, bytes memory data) external;\n\n    /// @notice Called when a position unsubscribes from the subscriber\n    /// @dev This call's gas is capped at `unsubscribeGasLimit` (set at deployment)\n    /// @dev Because of EIP-150, solidity may only allocate 63/64 of gasleft()\n    /// @param tokenId the token ID of the position\n    function notifyUnsubscribe(uint256 tokenId) external;\n\n    /// @notice Called when a position is burned\n    /// @param tokenId the token ID of the position\n    /// @param owner the current owner of the tokenId\n    /// @param info information about the position\n    /// @param liquidity the amount of liquidity decreased in the position, may be 0\n    /// @param feesAccrued the fees accrued by the position if liquidity was decreased\n    function notifyBurn(uint256 tokenId, address owner, PositionInfo info, uint256 liquidity, BalanceDelta feesAccrued)\n        external;\n\n    /// @notice Called when a position modifies its liquidity or collects fees\n    /// @param tokenId the token ID of the position\n    /// @param liquidityChange the change in liquidity on the underlying position\n    /// @param feesAccrued the fees to be collected from the position as a result of the modifyLiquidity call\n    /// @dev Note that feesAccrued can be artificially inflated by a malicious user\n    /// Pools with a single liquidity position can inflate feeGrowthGlobal (and consequently feesAccrued) by donating to themselves;\n    /// atomically donating and collecting fees within the same unlockCallback may further inflate feeGrowthGlobal/feesAccrued\n    function notifyModifyLiquidity(uint256 tokenId, int256 liquidityChange, BalanceDelta feesAccrued) external;\n}\n"}, "lib/v4-core/src/interfaces/callback/IUnlockCallback.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Interface for the callback executed when an address unlocks the pool manager\ninterface IUnlockCallback {\n    /// @notice Called by the pool manager on `msg.sender` when the manager is unlocked\n    /// @param data The data that was passed to the call to unlock\n    /// @return Any data that you want to be returned from the unlock call\n    function unlockCallback(bytes calldata data) external returns (bytes memory);\n}\n"}, "lib/v4-core/src/libraries/CurrencyReserves.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\nimport {Currency} from \"../types/Currency.sol\";\nimport {CustomRevert} from \"./CustomRevert.sol\";\n\nlibrary CurrencyReserves {\n    using CustomRevert for bytes4;\n\n    /// bytes32(uint256(keccak256(\"ReservesOf\")) - 1)\n    bytes32 constant RESERVES_OF_SLOT = 0x1e0745a7db1623981f0b2a5d4232364c00787266eb75ad546f190e6cebe9bd95;\n    /// bytes32(uint256(keccak256(\"Currency\")) - 1)\n    bytes32 constant CURRENCY_SLOT = 0x27e098c505d44ec3574004bca052aabf76bd35004c182099d8c575fb238593b9;\n\n    function getSyncedCurrency() internal view returns (Currency currency) {\n        assembly (\"memory-safe\") {\n            currency := tload(CURRENCY_SLOT)\n        }\n    }\n\n    function resetCurrency() internal {\n        assembly (\"memory-safe\") {\n            tstore(CURRENCY_SLOT, 0)\n        }\n    }\n\n    function syncCurrencyAndReserves(Currency currency, uint256 value) internal {\n        assembly (\"memory-safe\") {\n            tstore(CURRENCY_SLOT, and(currency, 0xffffffffffffffffffffffffffffffffffffffff))\n            tstore(RESERVES_OF_SLOT, value)\n        }\n    }\n\n    function getSyncedReserves() internal view returns (uint256 value) {\n        assembly (\"memory-safe\") {\n            value := tload(RESERVES_OF_SLOT)\n        }\n    }\n}\n"}, "lib/v4-core/src/libraries/NonzeroDeltaCount.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\n/// @notice This is a temporary library that allows us to use transient storage (tstore/tload)\n/// for the nonzero delta count.\n/// TODO: This library can be deleted when we have the transient keyword support in solidity.\nlibrary NonzeroDeltaCount {\n    // The slot holding the number of nonzero deltas. bytes32(uint256(keccak256(\"NonzeroDeltaCount\")) - 1)\n    bytes32 internal constant NONZERO_DELTA_COUNT_SLOT =\n        0x7d4b3164c6e45b97e7d87b7125a44c5828d005af88f9d751cfd78729c5d99a0b;\n\n    function read() internal view returns (uint256 count) {\n        assembly (\"memory-safe\") {\n            count := tload(NONZERO_DELTA_COUNT_SLOT)\n        }\n    }\n\n    function increment() internal {\n        assembly (\"memory-safe\") {\n            let count := tload(NONZERO_DELTA_COUNT_SLOT)\n            count := add(count, 1)\n            tstore(NONZERO_DELTA_COUNT_SLOT, count)\n        }\n    }\n\n    /// @notice Potential to underflow. Ensure checks are performed by integrating contracts to ensure this does not happen.\n    /// Current usage ensures this will not happen because we call decrement with known boundaries (only up to the number of times we call increment).\n    function decrement() internal {\n        assembly (\"memory-safe\") {\n            let count := tload(NONZERO_DELTA_COUNT_SLOT)\n            count := sub(count, 1)\n            tstore(NONZERO_DELTA_COUNT_SLOT, count)\n        }\n    }\n}\n"}, "lib/v4-core/src/libraries/Lock.sol": {"content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.30;\n\n/// @notice This is a temporary library that allows us to use transient storage (tstore/tload)\n/// TODO: This library can be deleted when we have the transient keyword support in solidity.\nlibrary Lock {\n    // The slot holding the unlocked state, transiently. bytes32(uint256(keccak256(\"Unlocked\")) - 1)\n    bytes32 internal constant IS_UNLOCKED_SLOT = 0xc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab23;\n\n    function unlock() internal {\n        assembly (\"memory-safe\") {\n            // unlock\n            tstore(IS_UNLOCKED_SLOT, true)\n        }\n    }\n\n    function lock() internal {\n        assembly (\"memory-safe\") {\n            tstore(IS_UNLOCKED_SLOT, false)\n        }\n    }\n\n    function isUnlocked() internal view returns (bool unlocked) {\n        assembly (\"memory-safe\") {\n            unlocked := tload(IS_UNLOCKED_SLOT)\n        }\n    }\n}\n"}}, "settings": {"remappings": ["@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/", "@uniswap/v4-core/src/=lib/v4-core/src/", "@uniswap/v4-periphery/src/=lib/v4-periphery/src/", "@uniswap/permit2/src/=lib/permit2/src/", "@uniswap/universal-router/contracts/=lib/universal-router/contracts/", "@uniswap/v3-core/contracts/=lib/v3-core/contracts/", "@uniswap/v2-core/contracts/=lib/v2-core/contracts/", "@uniswap/v4-periphery/base/=lib/v4-periphery/src/base/", "solmate/src/=lib/solmate/src/", "forge-std/=lib/forge-std/src/", "@ensdomains/=lib/v4-core/node_modules/@ensdomains/", "@uniswap/v3-periphery/=lib/universal-router/lib/v3-periphery/", "ds-test/=lib/solmate/lib/ds-test/src/", "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/", "forge-gas-snapshot/=lib/permit2/lib/forge-gas-snapshot/src/", "halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/", "hardhat/=lib/v4-core/node_modules/hardhat/", "openzeppelin-contracts/=lib/openzeppelin-contracts/", "permit2/=lib/permit2/", "universal-router/=lib/universal-router/", "v2-core/=lib/v2-core/contracts/", "v3-core/=lib/v3-core/", "v3-periphery/=lib/universal-router/lib/v3-periphery/contracts/", "v4-core/=lib/v4-core/src/", "v4-periphery/=lib/v4-periphery/"], "optimizer": {"enabled": true}, "metadata": {"useLiteralContent": false, "bytecodeHash": "ipfs", "appendCBOR": true}, "outputSelection": {"*": {"*": ["evm.legacyAssembly"]}}, "evmVersion": "cancun", "viaIR": false, "libraries": {}}}