{"language": "Solidity", "sources": {"src/flat/MainnetFlat.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n// lib/forge-std/src/interfaces/IERC20.sol\n\n/// @dev Interface of the ERC20 standard as defined in the EIP.\n/// @dev This includes the optional name, symbol, and decimals metadata.\ninterface IERC20 {\n    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`\n    /// is the new allowance.\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice Returns the amount of tokens in existence.\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Returns the amount of tokens owned by `account`.\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Moves `amount` tokens from the caller's account to `to`.\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the remaining number of tokens that `spender` is allowed\n    /// to spend on behalf of `owner`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\n    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.\n    /// `amount` is then deducted from the caller's allowance.\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the name of the token.\n    function name() external view returns (string memory);\n\n    /// @notice Returns the symbol of the token.\n    function symbol() external view returns (string memory);\n\n    /// @notice Returns the decimals places of the token.\n    function decimals() external view returns (uint8);\n}\n\n// lib/permit2/src/interfaces/IEIP712.sol\n\ninterface IEIP712 {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n\n// src/Context.sol\n\nabstract contract AbstractContext {\n    function _msgSender() internal view virtual returns (address);\n\n    function _msgData() internal view virtual returns (bytes calldata);\n\n    function _isForwarded() internal view virtual returns (bool);\n}\n\nabstract contract Context is AbstractContext {\n    function _msgSender() internal view virtual override returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _isForwarded() internal view virtual override returns (bool) {\n        return false;\n    }\n}\n\n// src/IERC721Owner.sol\n\ninterface IERC721Owner {\n    function ownerOf(uint256) external view returns (address);\n}\n\n// src/allowanceholder/IAllowanceHolder.sol\n\ninterface IAllowanceHolder {\n    /// @notice Executes against `target` with the `data` payload. Prior to execution, token permits\n    ///         are temporarily stored for the duration of the transaction. These permits can be\n    ///         consumed by the `operator` during the execution\n    /// @notice `operator` consumes the funds during its operations by calling back into\n    ///         `AllowanceHolder` with `transferFrom`, consuming a token permit.\n    /// @dev Neither `exec` nor `transferFrom` check that `token` contains code.\n    /// @dev msg.sender is forwarded to target appended to the msg data (similar to ERC-2771)\n    /// @param operator An address which is allowed to consume the token permits\n    /// @param token The ERC20 token the caller has authorised to be consumed\n    /// @param amount The quantity of `token` the caller has authorised to be consumed\n    /// @param target A contract to execute operations with `data`\n    /// @param data The data to forward to `target`\n    /// @return result The returndata from calling `target` with `data`\n    /// @notice If calling `target` with `data` reverts, the revert is propagated\n    function exec(address operator, address token, uint256 amount, address payable target, bytes calldata data)\n        external\n        payable\n        returns (bytes memory result);\n\n    /// @notice The counterpart to `exec` which allows for the consumption of token permits later\n    ///         during execution\n    /// @dev *DOES NOT* check that `token` contains code. This function vacuously succeeds if\n    ///      `token` is empty.\n    /// @dev can only be called by the `operator` previously registered in `exec`\n    /// @param token The ERC20 token to transfer\n    /// @param owner The owner of tokens to transfer\n    /// @param recipient The destination/beneficiary of the ERC20 `transferFrom`\n    /// @param amount The quantity of `token` to transfer`\n    /// @return true\n    function transferFrom(address token, address owner, address recipient, uint256 amount) external returns (bool);\n}\n\n// src/core/univ3forks/PancakeSwapV3.sol\n\naddress constant pancakeSwapV3Factory = 0x41ff9AA7e16B8B1a8a8dc4f0eFacd93D02d071c9;\nbytes32 constant pancakeSwapV3InitHash = 0x6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2;\nuint8 constant pancakeSwapV3ForkId = 1;\n\ninterface IPancakeSwapV3Callback {\n    function pancakeV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external;\n}\n\n// src/core/univ3forks/SolidlyV3.sol\n\naddress constant solidlyV3Factory = 0x70Fe4a44EA505cFa3A57b95cF2862D4fd5F0f687;\nbytes32 constant solidlyV3InitHash = 0xe9b68c5f77858eecac2e651646e208175e9b1359d68d0e14fc69f8c54e5010bf;\nuint8 constant solidlyV3ForkId = 3;\n\ninterface ISolidlyV3Callback {\n    function solidlyV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external;\n}\n\n// src/core/univ3forks/UniswapV3.sol\n\naddress constant uniswapV3MainnetFactory = 0x1F98431c8aD98523631AE4a59f267346ea31F984;\naddress constant uniswapV3SepoliaFactory = 0x0227628f3F023bb0B980b67D528571c95c6DaC1c;\naddress constant uniswapV3BaseFactory = 0x33128a8fC17869897dcE68Ed026d694621f6FDfD;\naddress constant uniswapV3BnbFactory = 0xdB1d10011AD0Ff90774D0C6Bb92e5C5c8b4461F7;\naddress constant uniswapV3AvalancheFactory = 0x740b1c1de25031C31FF4fC9A62f554A55cdC1baD;\naddress constant uniswapV3BlastFactory = 0x792edAdE80af5fC680d96a2eD80A44247D2Cf6Fd;\nbytes32 constant uniswapV3InitHash = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\nuint8 constant uniswapV3ForkId = 0;\n\ninterface IUniswapV3Callback {\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external;\n}\n\n// src/utils/FreeMemory.sol\n\nabstract contract FreeMemory {\n    modifier DANGEROUS_freeMemory() {\n        uint256 freeMemPtr;\n        assembly (\"memory-safe\") {\n            freeMemPtr := mload(0x40)\n        }\n        _;\n        assembly (\"memory-safe\") {\n            mstore(0x40, freeMemPtr)\n        }\n    }\n}\n\n// src/utils/Panic.sol\n\nlibrary Panic {\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71) // selector for `Panic(uint256)`\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n\n    // https://docs.soliditylang.org/en/latest/control-structures.html#panic-via-assert-and-error-via-require\n    uint8 internal constant GENERIC = 0x00;\n    uint8 internal constant ASSERT_FAIL = 0x01;\n    uint8 internal constant ARITHMETIC_OVERFLOW = 0x11;\n    uint8 internal constant DIVISION_BY_ZERO = 0x12;\n    uint8 internal constant ENUM_CAST = 0x21;\n    uint8 internal constant CORRUPT_STORAGE_ARRAY = 0x22;\n    uint8 internal constant POP_EMPTY_ARRAY = 0x31;\n    uint8 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    uint8 internal constant OUT_OF_MEMORY = 0x41;\n    uint8 internal constant ZERO_FUNCTION_POINTER = 0x51;\n}\n\n// src/utils/Revert.sol\n\nlibrary Revert {\n    function _revert(bytes memory reason) internal pure {\n        assembly (\"memory-safe\") {\n            revert(add(reason, 0x20), mload(reason))\n        }\n    }\n\n    function maybeRevert(bool success, bytes memory reason) internal pure {\n        if (!success) {\n            _revert(reason);\n        }\n    }\n}\n\n// src/utils/UnsafeMath.sol\n\nlibrary UnsafeMath {\n    function unsafeInc(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return x + 1;\n        }\n    }\n\n    function unsafeInc(int256 x) internal pure returns (int256) {\n        unchecked {\n            return x + 1;\n        }\n    }\n\n    function unsafeNeg(int256 x) internal pure returns (int256) {\n        unchecked {\n            return -x;\n        }\n    }\n\n    function unsafeDiv(uint256 numerator, uint256 denominator) internal pure returns (uint256 quotient) {\n        assembly (\"memory-safe\") {\n            quotient := div(numerator, denominator)\n        }\n    }\n\n    function unsafeDiv(int256 numerator, int256 denominator) internal pure returns (int256 quotient) {\n        assembly (\"memory-safe\") {\n            quotient := sdiv(numerator, denominator)\n        }\n    }\n\n    function unsafeMod(uint256 numerator, uint256 denominator) internal pure returns (uint256 remainder) {\n        assembly (\"memory-safe\") {\n            remainder := mod(numerator, denominator)\n        }\n    }\n\n    function unsafeMod(int256 numerator, int256 denominator) internal pure returns (int256 remainder) {\n        assembly (\"memory-safe\") {\n            remainder := smod(numerator, denominator)\n        }\n    }\n\n    function unsafeMulMod(uint256 a, uint256 b, uint256 m) internal pure returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            r := mulmod(a, b, m)\n        }\n    }\n\n    function unsafeAddMod(uint256 a, uint256 b, uint256 m) internal pure returns (uint256 r) {\n        assembly (\"memory-safe\") {\n            r := addmod(a, b, m)\n        }\n    }\n}\n\n// lib/permit2/src/interfaces/ISignatureTransfer.sol\n\n/// @title SignatureTransfer\n/// @notice Handles ERC20 token transfers through signature based actions\n/// @dev Requires user's token approval on the Permit2 contract\ninterface ISignatureTransfer is IEIP712 {\n    /// @notice Thrown when the requested amount for a transfer is larger than the permissioned amount\n    /// @param maxAmount The maximum amount a spender can request to transfer\n    error InvalidAmount(uint256 maxAmount);\n\n    /// @notice Thrown when the number of tokens permissioned to a spender does not match the number of tokens being transferred\n    /// @dev If the spender does not need to transfer the number of tokens permitted, the spender can request amount 0 to be transferred\n    error LengthMismatch();\n\n    /// @notice Emits an event when the owner successfully invalidates an unordered nonce.\n    event UnorderedNonceInvalidation(address indexed owner, uint256 word, uint256 mask);\n\n    /// @notice The token and amount details for a transfer signed in the permit transfer signature\n    struct TokenPermissions {\n        // ERC20 token address\n        address token;\n        // the maximum amount that can be spent\n        uint256 amount;\n    }\n\n    /// @notice The signed permit message for a single token transfer\n    struct PermitTransferFrom {\n        TokenPermissions permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice Specifies the recipient address and amount for batched transfers.\n    /// @dev Recipients and amounts correspond to the index of the signed token permissions array.\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount.\n    struct SignatureTransferDetails {\n        // recipient address\n        address to;\n        // spender requested amount\n        uint256 requestedAmount;\n    }\n\n    /// @notice Used to reconstruct the signed permit message for multiple token transfers\n    /// @dev Do not need to pass in spender address as it is required that it is msg.sender\n    /// @dev Note that a user still signs over a spender address\n    struct PermitBatchTransferFrom {\n        // the tokens and corresponding amounts permitted for a transfer\n        TokenPermissions[] permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice A map from token owner address and a caller specified word index to a bitmap. Used to set bits in the bitmap to prevent against signature replay protection\n    /// @dev Uses unordered nonces so that permit messages do not need to be spent in a certain order\n    /// @dev The mapping is indexed first by the token owner, then by an index specified in the nonce\n    /// @dev It returns a uint256 bitmap\n    /// @dev The index, or wordPosition is capped at type(uint248).max\n    function nonceBitmap(address, uint256) external view returns (uint256);\n\n    /// @notice Transfers a token using a signed permit message\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers a token using a signed permit message\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Invalidates the bits specified in mask for the bitmap at the word position\n    /// @dev The wordPos is maxed at type(uint248).max\n    /// @param wordPos A number to index the nonceBitmap at\n    /// @param mask A bitmap masked against msg.sender's current bitmap at the word position\n    function invalidateUnorderedNonces(uint256 wordPos, uint256 mask) external;\n}\n\n// src/core/SettlerErrors.sol\n\n/// @notice Thrown when an offset is not the expected value\nerror InvalidOffset();\n\n/// @notice Thrown when a validating a target contract to avoid certain types of targets\nerror ConfusedDeputy();\n\n/// @notice Thrown when a target contract is invalid given the context\nerror InvalidTarget();\n\n/// @notice Thrown when validating the caller against the expected caller\nerror InvalidSender();\n\n/// @notice Thrown in cases when using a Trusted Forwarder / AllowanceHolder is not allowed\nerror ForwarderNotAllowed();\n\n/// @notice Thrown when a signature length is not the expected length\nerror InvalidSignatureLen();\n\n/// @notice Thrown when a slippage limit is exceeded\nerror TooMuchSlippage(IERC20 token, uint256 expected, uint256 actual);\n\n/// @notice Thrown when a byte array that is supposed to encode a function from ISettlerActions is\n///         not recognized in context.\nerror ActionInvalid(uint256 i, bytes4 action, bytes data);\n\n/// @notice Thrown when the encoded fork ID as part of UniswapV3 fork path is not on the list of\n///         recognized forks for this chain.\nerror UnknownForkId(uint8 forkId);\n\n/// @notice Thrown when an AllowanceHolder transfer's permit is past its deadline\nerror SignatureExpired(uint256 deadline);\n\n/// @notice An internal error that should never be thrown. Thrown when a callback reenters the\n///         entrypoint and attempts to clobber the existing callback.\nerror ReentrantCallback(uint256 callbackInt);\n\n/// @notice An internal error that should never be thrown. This error can only be thrown by\n///         non-metatx-supporting Settler instances. Thrown when a callback-requiring liquidity\n///         source is called, but Settler never receives the callback.\nerror CallbackNotSpent(uint256 callbackInt);\n\n/// @notice Thrown when a metatransaction has reentrancy.\nerror ReentrantMetatransaction(bytes32 oldWitness);\n\n/// @notice Thrown when any transaction has reentrancy, not just taker-submitted or metatransaction.\nerror ReentrantPayer(address oldPayer);\n\n/// @notice An internal error that should never be thrown. Thrown when a metatransaction fails to\n///         spend a coupon.\nerror WitnessNotSpent(bytes32 oldWitness);\n\n/// @notice An internal error that should never be thrown. Thrown when the payer is unset\n///         unexpectedly.\nerror PayerSpent();\n\n// src/vendor/SafeTransferLib.sol\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    uint32 private constant _TRANSFER_FROM_FAILED_SELECTOR = 0x7939f424; // bytes4(keccak256(\"TransferFromFailed()\"))\n    uint32 private constant _TRANSFER_FAILED_SELECTOR = 0x90b8ec18; // bytes4(keccak256(\"TransferFailed()\"))\n    uint32 private constant _APPROVE_FAILED_SELECTOR = 0x3e3f8f73; // bytes4(keccak256(\"ApproveFailed()\"))\n\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address payable to, uint256 amount) internal {\n        assembly (\"memory-safe\") {\n            // Transfer the ETH and store if it succeeded or not.\n            if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\n                let freeMemoryPointer := mload(0x40)\n                returndatacopy(freeMemoryPointer, 0, returndatasize())\n                revert(freeMemoryPointer, returndatasize())\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 amount) internal {\n        assembly (\"memory-safe\") {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n            // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n            if iszero(call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)) {\n                returndatacopy(freeMemoryPointer, 0, returndatasize())\n                revert(freeMemoryPointer, returndatasize())\n            }\n            // We check that the call either returned exactly 1 (can't just be non-zero data), or had no\n            // return data.\n            if iszero(or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize()))) {\n                mstore(0, _TRANSFER_FROM_FAILED_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\n        assembly (\"memory-safe\") {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n            // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n            if iszero(call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)) {\n                returndatacopy(freeMemoryPointer, 0, returndatasize())\n                revert(freeMemoryPointer, returndatasize())\n            }\n            // We check that the call either returned exactly 1 (can't just be non-zero data), or had no\n            // return data.\n            if iszero(or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize()))) {\n                mstore(0, _TRANSFER_FAILED_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    function safeApprove(IERC20 token, address to, uint256 amount) internal {\n        assembly (\"memory-safe\") {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n            // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n            if iszero(call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)) {\n                returndatacopy(freeMemoryPointer, 0, returndatasize())\n                revert(freeMemoryPointer, returndatasize())\n            }\n            // We check that the call either returned exactly 1 (can't just be non-zero data), or had no\n            // return data.\n            if iszero(or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize()))) {\n                mstore(0, _APPROVE_FAILED_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    function safeApproveIfBelow(IERC20 token, address spender, uint256 amount) internal {\n        uint256 allowance = token.allowance(address(this), spender);\n        if (allowance < amount) {\n            if (allowance != 0) {\n                safeApprove(token, spender, 0);\n            }\n            safeApprove(token, spender, type(uint256).max);\n        }\n    }\n}\n\n// src/ISettlerActions.sol\n\ninterface ISettlerActions {\n    /// @dev Transfer funds from msg.sender Permit2.\n    function TRANSFER_FROM(address recipient, ISignatureTransfer.PermitTransferFrom memory permit, bytes memory sig)\n        external;\n\n    /// @dev Transfer funds from metatransaction requestor into the Settler contract using Permit2. Only for use in `Settler.executeMetaTxn` where the signature is provided as calldata\n    function METATXN_TRANSFER_FROM(address recipient, ISignatureTransfer.PermitTransferFrom memory permit) external;\n\n    /// @dev Settle an RfqOrder between maker and taker transfering funds directly between the parties\n    // Post-req: Payout if recipient != taker\n    function RFQ_VIP(\n        address recipient,\n        ISignatureTransfer.PermitTransferFrom memory makerPermit,\n        address maker,\n        bytes memory makerSig,\n        ISignatureTransfer.PermitTransferFrom memory takerPermit,\n        bytes memory takerSig\n    ) external;\n\n    /// @dev Settle an RfqOrder between maker and taker transfering funds directly between the parties for the entire amount\n    function METATXN_RFQ_VIP(\n        address recipient,\n        ISignatureTransfer.PermitTransferFrom memory makerPermit,\n        address maker,\n        bytes memory makerSig,\n        ISignatureTransfer.PermitTransferFrom memory takerPermit\n    ) external;\n\n    /// @dev Settle an RfqOrder between Maker and Settler. Transfering funds from the Settler contract to maker.\n    /// Retaining funds in the settler contract.\n    // Pre-req: Funded\n    // Post-req: Payout\n    function RFQ(\n        address recipient,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        address maker,\n        bytes memory makerSig,\n        address takerToken,\n        uint256 maxTakerAmount\n    ) external;\n\n    /// @dev Trades against UniswapV3 using the contracts balance for funding\n    // Pre-req: Funded\n    // Post-req: Payout\n    function UNISWAPV3(address recipient, uint256 bps, bytes memory path, uint256 amountOutMin) external;\n\n    /// @dev Trades against UniswapV3 using user funds via Permit2 for funding\n    function UNISWAPV3_VIP(\n        address recipient,\n        bytes memory path,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        bytes memory sig,\n        uint256 amountOutMin\n    ) external;\n\n    function MAKERPSM(address recipient, address gemToken, uint256 bps, address psm, bool buyGem) external;\n\n    function CURVE_TRICRYPTO_VIP(\n        address recipient,\n        uint80 poolInfo,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        bytes memory sig,\n        uint256 minBuyAmount\n    ) external;\n    function METATXN_CURVE_TRICRYPTO_VIP(\n        address recipient,\n        uint80 poolInfo,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        uint256 minBuyAmount\n    ) external;\n\n    function DODOV1(address sellToken, uint256 bps, address pool, bool quoteForBase, uint256 minBuyAmount) external;\n\n    function VELODROME(address recipient, uint256 bps, address pool, uint24 swapInfo, uint256 minBuyAmount) external;\n\n    /// @dev Trades against UniswapV3 using user funds via Permit2 for funding. Metatransaction variant. Signature is over all actions.\n    function METATXN_UNISWAPV3_VIP(\n        address recipient,\n        bytes memory path,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        uint256 amountOutMin\n    ) external;\n\n    /// @dev Trades against UniswapV2 using the contracts balance for funding\n    /// @param swapInfo is encoded as the upper 16 bits as the fee of the pool in bps, the second\n    ///                 lowest bit as \"sell token has transfer fee\", and the lowest bit as the\n    ///                 \"token0 for token1\" flag.\n    function UNISWAPV2(\n        address recipient,\n        address sellToken,\n        uint256 bps,\n        address pool,\n        uint24 swapInfo,\n        uint256 amountOutMin\n    ) external;\n\n    function POSITIVE_SLIPPAGE(address recipient, address token, uint256 expectedAmount) external;\n\n    /// @dev Trades against a basic AMM which follows the approval, transferFrom(msg.sender) interaction\n    // Pre-req: Funded\n    // Post-req: Payout\n    function BASIC(address sellToken, uint256 bps, address pool, uint256 offset, bytes calldata data) external;\n}\n\n// src/allowanceholder/AllowanceHolderContext.sol\n\nabstract contract AllowanceHolderContext is Context {\n    IAllowanceHolder internal constant _ALLOWANCE_HOLDER = IAllowanceHolder(0x0000000000001fF3684f28c67538d4D072C22734);\n\n    function _isForwarded() internal view virtual override returns (bool) {\n        return super._isForwarded() || super._msgSender() == address(_ALLOWANCE_HOLDER);\n    }\n\n    function _msgSender() internal view virtual override returns (address sender) {\n        sender = super._msgSender();\n        if (sender == address(_ALLOWANCE_HOLDER)) {\n            // ERC-2771 like usage where the _trusted_ `AllowanceHolder` has appended the appropriate\n            // msg.sender to the msg data\n            assembly (\"memory-safe\") {\n                sender := shr(0x60, calldataload(sub(calldatasize(), 0x14)))\n            }\n        }\n    }\n\n    // this is here to avoid foot-guns and make it very explicit that we intend\n    // to pass the confused deputy check in AllowanceHolder\n    function balanceOf(address) external pure {\n        assembly (\"memory-safe\") {\n            mstore8(0x00, 0x00)\n            return(0x00, 0x01)\n        }\n    }\n}\n\n// src/utils/AddressDerivation.sol\n\nlibrary AddressDerivation {\n    using UnsafeMath for uint256;\n\n    uint256 internal constant _SECP256K1_P = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;\n    uint256 internal constant _SECP256K1_N = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;\n    uint256 internal constant SECP256K1_GX = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798;\n    uint256 internal constant SECP256K1_GY = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8;\n\n    error InvalidCurve(uint256 x, uint256 y);\n\n    // keccak256(abi.encodePacked(ECMUL([x, y], k)))[12:]\n    function deriveEOA(uint256 x, uint256 y, uint256 k) internal pure returns (address) {\n        if (k == 0) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        if (k >= _SECP256K1_N || x >= _SECP256K1_P || y >= _SECP256K1_P) {\n            Panic.panic(Panic.ARITHMETIC_OVERFLOW);\n        }\n\n        // +/-7 are neither square nor cube mod p, so we only have to check one\n        // coordinate against 0. if it is 0, then the other is too (the point at\n        // infinity) or the point is invalid\n        if (\n            x == 0\n                || y.unsafeMulMod(y, _SECP256K1_P)\n                    != x.unsafeMulMod(x, _SECP256K1_P).unsafeMulMod(x, _SECP256K1_P).unsafeAddMod(7, _SECP256K1_P)\n        ) {\n            revert InvalidCurve(x, y);\n        }\n\n        unchecked {\n            // https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384\n            return ecrecover(\n                bytes32(0), uint8(27 + (y & 1)), bytes32(x), bytes32(UnsafeMath.unsafeMulMod(x, k, _SECP256K1_N))\n            );\n        }\n    }\n\n    // keccak256(RLP([deployer, nonce]))[12:]\n    function deriveContract(address deployer, uint64 nonce) internal pure returns (address result) {\n        if (nonce == 0) {\n            assembly (\"memory-safe\") {\n                mstore(\n                    0x00,\n                    or(\n                        0xd694000000000000000000000000000000000000000080,\n                        shl(8, and(0xffffffffffffffffffffffffffffffffffffffff, deployer))\n                    )\n                )\n                result := keccak256(0x09, 0x17)\n            }\n        } else if (nonce < 0x80) {\n            assembly (\"memory-safe\") {\n                // we don't care about dirty bits in `deployer`; they'll be overwritten later\n                mstore(0x14, deployer)\n                mstore(0x00, 0xd694)\n                mstore8(0x34, nonce)\n                result := keccak256(0x1e, 0x17)\n            }\n        } else {\n            // compute ceil(log_256(nonce)) + 1\n            uint256 nonceLength = 8;\n            unchecked {\n                if ((uint256(nonce) >> 32) != 0) {\n                    nonceLength += 32;\n                    if (nonce == type(uint64).max) {\n                        Panic.panic(Panic.ARITHMETIC_OVERFLOW);\n                    }\n                }\n                if ((uint256(nonce) >> 8) >= (1 << nonceLength)) {\n                    nonceLength += 16;\n                }\n                if (uint256(nonce) >= (1 << nonceLength)) {\n                    nonceLength += 8;\n                }\n                // ceil\n                if ((uint256(nonce) << 8) >= (1 << nonceLength)) {\n                    nonceLength += 8;\n                }\n                // bytes, not bits\n                nonceLength >>= 3;\n            }\n            assembly (\"memory-safe\") {\n                // we don't care about dirty bits in `deployer` or `nonce`. they'll be overwritten later\n                mstore(nonceLength, nonce)\n                mstore8(0x20, add(0x7f, nonceLength))\n                mstore(0x00, deployer)\n                mstore8(0x0a, add(0xd5, nonceLength))\n                mstore8(0x0b, 0x94)\n                result := keccak256(0x0a, add(0x16, nonceLength))\n            }\n        }\n    }\n\n    // keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, initHash))[12:]\n    function deriveDeterministicContract(address deployer, bytes32 salt, bytes32 initHash)\n        internal\n        pure\n        returns (address result)\n    {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // we don't care about dirty bits in `deployer`; they'll be overwritten later\n            mstore(ptr, deployer)\n            mstore8(add(ptr, 0x0b), 0xff)\n            mstore(add(ptr, 0x20), salt)\n            mstore(add(ptr, 0x40), initHash)\n            result := keccak256(add(ptr, 0x0b), 0x55)\n        }\n    }\n}\n\n// src/vendor/FullMath.sol\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\n/// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\nlibrary FullMath {\n    using UnsafeMath for uint256;\n\n    /// @notice 512-bit multiply [prod1 prod0] = a * b\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return prod0 Least significant 256 bits of the product\n    /// @return prod1 Most significant 256 bits of the product\n    /// @return remainder Remainder of full-precision division\n    function _mulDivSetup(uint256 a, uint256 b, uint256 denominator)\n        private\n        pure\n        returns (uint256 prod0, uint256 prod1, uint256 remainder)\n    {\n        // Compute the product mod 2**256 and mod 2**256 - 1 then use the Chinese\n        // Remainder Theorem to reconstruct the 512 bit result. The result is stored\n        // in two 256 variables such that product = prod1 * 2**256 + prod0\n        assembly (\"memory-safe\") {\n            // Full-precision multiplication\n            {\n                let mm := mulmod(a, b, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n                prod0 := mul(a, b)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            remainder := mulmod(a, b, denominator)\n        }\n    }\n\n    /// @notice 512-bit by 256-bit division.\n    /// @param prod0 Least significant 256 bits of the product\n    /// @param prod1 Most significant 256 bits of the product\n    /// @param denominator The divisor\n    /// @param remainder Remainder of full-precision division\n    /// @return The 256-bit result\n    /// @dev Overflow and division by zero aren't checked and are GIGO errors\n    function _mulDivInvert(uint256 prod0, uint256 prod1, uint256 denominator, uint256 remainder)\n        private\n        pure\n        returns (uint256)\n    {\n        uint256 inv;\n        assembly (\"memory-safe\") {\n            // Make division exact by rounding [prod1 prod0] down to a multiple of\n            // denominator\n            // Subtract 256 bit number from 512 bit number\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n\n            // Factor powers of two out of denominator\n            {\n                // Compute largest power of two divisor of denominator.\n                // Always >= 1.\n                let twos := and(sub(0, denominator), denominator)\n\n                // Divide denominator by power of two\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by the factors of two\n                prod0 := div(prod0, twos)\n                // Shift in bits from prod1 into prod0. For this we need to flip `twos`\n                // such that it is 2**256 / twos.\n                // If twos is zero, then it becomes one\n                twos := add(div(sub(0, twos), twos), 1)\n                prod0 := or(prod0, mul(prod1, twos))\n            }\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse modulo 2**256\n            // such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct correct for\n            // four bits. That is, denominator * inv = 1 mod 2**4\n            inv := xor(mul(3, denominator), 2)\n\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv := mul(inv, sub(2, mul(denominator, inv))) // inverse mod 2**8\n            inv := mul(inv, sub(2, mul(denominator, inv))) // inverse mod 2**16\n            inv := mul(inv, sub(2, mul(denominator, inv))) // inverse mod 2**32\n            inv := mul(inv, sub(2, mul(denominator, inv))) // inverse mod 2**64\n            inv := mul(inv, sub(2, mul(denominator, inv))) // inverse mod 2**128\n            inv := mul(inv, sub(2, mul(denominator, inv))) // inverse mod 2**256\n        }\n\n        // Because the division is now exact we can divide by multiplying with the\n        // modular inverse of denominator. This will give us the correct result\n        // modulo 2**256. Since the precoditions guarantee that the outcome is less\n        // than 2**256, this is the final result.  We don't need to compute the high\n        // bits of the result and prod1 is no longer required.\n        unchecked {\n            return prod0 * inv;\n        }\n    }\n\n    /// @notice Calculates a\u00d7b\u00f7denominator with full precision then rounds towards 0. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return The 256-bit result\n    function mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256) {\n        (uint256 prod0, uint256 prod1, uint256 remainder) = _mulDivSetup(a, b, denominator);\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n        if (denominator <= prod1) {\n            Panic.panic(denominator == 0 ? Panic.DIVISION_BY_ZERO : Panic.ARITHMETIC_OVERFLOW);\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            return prod0.unsafeDiv(denominator);\n        }\n        return _mulDivInvert(prod0, prod1, denominator, remainder);\n    }\n\n    /// @notice Calculates a\u00d7b\u00f7denominator with full precision then rounds towards 0. Overflowing a uint256 or denominator == 0 are GIGO errors\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return The 256-bit result\n    function unsafeMulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256) {\n        (uint256 prod0, uint256 prod1, uint256 remainder) = _mulDivSetup(a, b, denominator);\n        // Overflow and zero-division checks are skipped\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            return prod0.unsafeDiv(denominator);\n        }\n        return _mulDivInvert(prod0, prod1, denominator, remainder);\n    }\n}\n\n// src/core/MakerPSM.sol\n\ninterface IPSM {\n    /// @dev Get the fee for selling DAI to USDC in PSM\n    /// @return tout toll out [wad]\n    function tout() external view returns (uint256);\n\n    /// @dev Get the address of the underlying vault powering PSM\n    /// @return address of gemJoin contract\n    function gemJoin() external view returns (address);\n\n    /// @dev Sell USDC for DAI\n    /// @param usr The address of the account trading USDC for DAI.\n    /// @param gemAmt The amount of USDC to sell in USDC base units\n    function sellGem(address usr, uint256 gemAmt) external;\n\n    /// @dev Buy USDC for DAI\n    /// @param usr The address of the account trading DAI for USDC\n    /// @param gemAmt The amount of USDC to buy in USDC base units\n    function buyGem(address usr, uint256 gemAmt) external;\n}\n\nabstract contract MakerPSM {\n    using UnsafeMath for uint256;\n    using SafeTransferLib for IERC20;\n\n    // Maker units https://github.com/makerdao/dss/blob/master/DEVELOPING.md\n    // wad: fixed point decimal with 18 decimals (for basic quantities, e.g. balances)\n    uint256 internal constant WAD = 10 ** 18;\n\n    IERC20 internal constant DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n\n    constructor() {\n        assert(block.chainid == 1 || block.chainid == 31337);\n    }\n\n    function sellToMakerPsm(address recipient, IERC20 gemToken, uint256 bps, IPSM psm, bool buyGem) internal {\n        if (buyGem) {\n            // phantom overflow can't happen here because DAI has decimals = 18\n            uint256 sellAmount = (DAI.balanceOf(address(this)) * bps).unsafeDiv(10_000);\n            unchecked {\n                uint256 feeDivisor = psm.tout() + WAD; // eg. 1.001 * 10 ** 18 with 0.1% fee [tout is in wad];\n                // overflow can't happen at all because DAI is reasonable and PSM prohibits gemToken with decimals > 18\n                uint256 buyAmount = (sellAmount * 10 ** uint256(gemToken.decimals())).unsafeDiv(feeDivisor);\n\n                DAI.safeApproveIfBelow(address(psm), sellAmount);\n                psm.buyGem(recipient, buyAmount);\n            }\n        } else {\n            // phantom overflow can't happen here because PSM prohibits gemToken with decimals > 18\n            uint256 sellAmount = (gemToken.balanceOf(address(this)) * bps).unsafeDiv(10_000);\n            gemToken.safeApproveIfBelow(psm.gemJoin(), sellAmount);\n            psm.sellGem(recipient, sellAmount);\n        }\n    }\n}\n\n// src/core/Permit2PaymentAbstract.sol\n\nabstract contract Permit2PaymentAbstract is AbstractContext {\n    string internal constant TOKEN_PERMISSIONS_TYPE = \"TokenPermissions(address token,uint256 amount)\";\n\n    function _isRestrictedTarget(address) internal view virtual returns (bool);\n\n    function _operator() internal view virtual returns (address);\n\n    function _permitToTransferDetails(ISignatureTransfer.PermitTransferFrom memory permit, address recipient)\n        internal\n        pure\n        virtual\n        returns (ISignatureTransfer.SignatureTransferDetails memory transferDetails, address token, uint256 amount);\n\n    function _transferFromIKnowWhatImDoing(\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        ISignatureTransfer.SignatureTransferDetails memory transferDetails,\n        address from,\n        bytes32 witness,\n        string memory witnessTypeString,\n        bytes memory sig,\n        bool isForwarded\n    ) internal virtual;\n\n    function _transferFromIKnowWhatImDoing(\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        ISignatureTransfer.SignatureTransferDetails memory transferDetails,\n        address from,\n        bytes32 witness,\n        string memory witnessTypeString,\n        bytes memory sig\n    ) internal virtual;\n\n    function _transferFrom(\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        ISignatureTransfer.SignatureTransferDetails memory transferDetails,\n        bytes memory sig,\n        bool isForwarded\n    ) internal virtual;\n\n    function _transferFrom(\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        ISignatureTransfer.SignatureTransferDetails memory transferDetails,\n        bytes memory sig\n    ) internal virtual;\n\n    function _setOperatorAndCall(\n        address target,\n        bytes memory data,\n        uint32 selector,\n        function (bytes calldata) internal returns (bytes memory) callback\n    ) internal virtual returns (bytes memory);\n\n    modifier metaTx(address msgSender, bytes32 witness) virtual;\n\n    modifier takerSubmitted() virtual;\n\n    function _allowanceHolderTransferFrom(address token, address owner, address recipient, uint256 amount)\n        internal\n        virtual;\n}\n\n// src/SettlerAbstract.sol\n\nabstract contract SettlerAbstract is Permit2PaymentAbstract {\n    // Permit2 Witness for meta transactions\n    string internal constant SLIPPAGE_AND_ACTIONS_TYPE =\n        \"SlippageAndActions(address recipient,address buyToken,uint256 minAmountOut,bytes[] actions)\";\n    bytes32 internal constant SLIPPAGE_AND_ACTIONS_TYPEHASH =\n        0x615e8d716cef7295e75dd3f1f10d679914ad6d7759e8e9459f0109ef75241701;\n\n    constructor() {\n        assert(SLIPPAGE_AND_ACTIONS_TYPEHASH == keccak256(bytes(SLIPPAGE_AND_ACTIONS_TYPE)));\n    }\n\n    function _hasMetaTxn() internal pure virtual returns (bool);\n\n    function _dispatch(uint256 i, bytes4 action, bytes calldata data) internal virtual returns (bool);\n}\n\n// src/core/UniswapV2.sol\n\ninterface IUniV2Pair {\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves() external view returns (uint112, uint112, uint32);\n\n    function swap(uint256, uint256, address, bytes calldata) external;\n}\n\nabstract contract UniswapV2 {\n    using UnsafeMath for uint256;\n\n    // bytes4(keccak256(\"getReserves()\"))\n    uint32 private constant UNI_PAIR_RESERVES_SELECTOR = 0x0902f1ac;\n    // bytes4(keccak256(\"swap(uint256,uint256,address,bytes)\"))\n    uint32 private constant UNI_PAIR_SWAP_SELECTOR = 0x022c0d9f;\n    // bytes4(keccak256(\"transfer(address,uint256)\"))\n    uint32 private constant ERC20_TRANSFER_SELECTOR = 0xa9059cbb;\n    // bytes4(keccak256(\"balanceOf(address)\"))\n    uint32 private constant ERC20_BALANCEOF_SELECTOR = 0x70a08231;\n\n    /// @dev Sell a token for another token using UniswapV2.\n    function sellToUniswapV2(\n        address recipient,\n        address sellToken,\n        uint256 bps,\n        address pool,\n        uint24 swapInfo,\n        uint256 minBuyAmount\n    ) internal {\n        // Preventing calls to Permit2 or AH is not explicitly required as neither of these contracts implement the `swap` nor `transfer` selector\n\n        // |7|6|5|4|3|2|1|0| - bit positions in swapInfo (uint8)\n        // |0|0|0|0|0|0|F|Z| - Z: zeroForOne flag, F: sellTokenHasFee flag\n        bool zeroForOne = (swapInfo & 1) == 1; // Extract the least significant bit (bit 0)\n        bool sellTokenHasFee = (swapInfo & 2) >> 1 == 1; // Extract the second least significant bit (bit 1) and shift it right\n        uint256 feeBps = swapInfo >> 8;\n\n        uint256 sellAmount;\n        uint256 buyAmount;\n        // If bps is zero we assume there are no funds within this contract, skip the updating sellAmount.\n        // This case occurs if the pool is being chained, in which the funds have been sent directly to the pool\n        if (bps != 0) {\n            // We don't care about phantom overflow here because reserves are\n            // limited to 112 bits. Any token balance that would overflow here would\n            // also break UniV2.\n            // It is *possible* to set `bps` above the basis and therefore\n            // cause an overflow on this multiplication. However, `bps` is\n            // passed as authenticated calldata, so this is a GIGO error that we\n            // do not attempt to fix.\n            unchecked {\n                sellAmount = (IERC20(sellToken).balanceOf(address(this)) * bps).unsafeDiv(10_000);\n            }\n        }\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n\n            // transfer sellAmount (a non zero amount) of sellToken to the pool\n            if sellAmount {\n                mstore(ptr, ERC20_TRANSFER_SELECTOR)\n                mstore(add(ptr, 0x20), pool)\n                mstore(add(ptr, 0x40), sellAmount)\n                // ...||ERC20_TRANSFER_SELECTOR|pool|sellAmount|\n                if iszero(call(gas(), sellToken, 0, add(ptr, 0x1c), 0x44, 0x00, 0x20)) { bubbleRevert(ptr) }\n                if iszero(or(iszero(returndatasize()), and(iszero(lt(returndatasize(), 0x20)), eq(mload(0x00), 1)))) {\n                    revert(0, 0)\n                }\n            }\n\n            // get pool reserves\n            let sellReserve\n            let buyReserve\n            mstore(0x00, UNI_PAIR_RESERVES_SELECTOR)\n            // ||UNI_PAIR_RESERVES_SELECTOR|\n            if iszero(staticcall(gas(), pool, 0x1c, 0x04, 0x00, 0x40)) { bubbleRevert(ptr) }\n            if lt(returndatasize(), 0x40) { revert(0, 0) }\n            {\n                let r := shl(5, zeroForOne)\n                buyReserve := mload(r)\n                sellReserve := mload(xor(0x20, r))\n            }\n\n            // Update the sell amount in the following cases:\n            //   the funds are in the pool already (flagged by sellAmount being 0)\n            //   the sell token has a fee (flagged by sellTokenHasFee)\n            if or(iszero(sellAmount), sellTokenHasFee) {\n                // retrieve the sellToken balance of the pool\n                mstore(0x00, ERC20_BALANCEOF_SELECTOR)\n                mstore(0x20, and(0xffffffffffffffffffffffffffffffffffffffff, pool))\n                // ||ERC20_BALANCEOF_SELECTOR|pool|\n                if iszero(staticcall(gas(), sellToken, 0x1c, 0x24, 0x00, 0x20)) { bubbleRevert(ptr) }\n                if lt(returndatasize(), 0x20) { revert(0, 0) }\n                let bal := mload(0x00)\n\n                // determine real sellAmount by comparing pool's sellToken balance to reserve amount\n                if lt(bal, sellReserve) {\n                    mstore(0x00, 0x4e487b71) // selector for `Panic(uint256)`\n                    mstore(0x20, 0x11) // panic code for arithmetic underflow\n                    revert(0x1c, 0x24)\n                }\n                sellAmount := sub(bal, sellReserve)\n            }\n\n            // compute buyAmount based on sellAmount and reserves\n            let sellAmountWithFee := mul(sellAmount, sub(10000, feeBps))\n            buyAmount := div(mul(sellAmountWithFee, buyReserve), add(sellAmountWithFee, mul(sellReserve, 10000)))\n            let swapCalldata := add(ptr, 0x1c)\n            // set up swap call selector and empty callback data\n            mstore(ptr, UNI_PAIR_SWAP_SELECTOR)\n            mstore(add(ptr, 0x80), 0x80) // offset to length of data\n            mstore(add(ptr, 0xa0), 0) // length of data\n\n            // set amount0Out and amount1Out\n            {\n                // If `zeroForOne`, offset is 0x24, else 0x04\n                let offset := add(0x04, shl(5, zeroForOne))\n                mstore(add(swapCalldata, offset), buyAmount)\n                mstore(add(swapCalldata, xor(0x20, offset)), 0)\n            }\n\n            mstore(add(swapCalldata, 0x44), and(0xffffffffffffffffffffffffffffffffffffffff, recipient))\n            // ...||UNI_PAIR_SWAP_SELECTOR|amount0Out|amount1Out|recipient|data|\n\n            // perform swap at the pool sending bought tokens to the recipient\n            if iszero(call(gas(), pool, 0, swapCalldata, 0xa4, 0, 0)) { bubbleRevert(swapCalldata) }\n\n            // revert with the return data from the most recent call\n            function bubbleRevert(p) {\n                returndatacopy(p, 0, returndatasize())\n                revert(p, returndatasize())\n            }\n        }\n        if (buyAmount < minBuyAmount) {\n            revert TooMuchSlippage(\n                IERC20(zeroForOne ? IUniV2Pair(pool).token1() : IUniV2Pair(pool).token0()), minBuyAmount, buyAmount\n            );\n        }\n    }\n}\n\n// src/core/Velodrome.sol\n\ninterface IVelodromePair {\n    function metadata()\n        external\n        view\n        returns (\n            uint256 basis0,\n            uint256 basis1,\n            uint256 reserve0,\n            uint256 reserve1,\n            bool stable,\n            IERC20 token0,\n            IERC20 token1\n        );\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;\n}\n\nabstract contract Velodrome {\n    using UnsafeMath for uint256;\n    using SafeTransferLib for IERC20;\n\n    uint256 private constant _BASIS = 1 ether;\n\n    // This is the `k = x^3 * y + y^3 * x` constant function\n    function _k(uint256 x, uint256 y) private pure returns (uint256) {\n        unchecked {\n            return _k(x, y, x * x / _BASIS);\n        }\n    }\n\n    function _k(uint256 x, uint256 y, uint256 x_squared) private pure returns (uint256) {\n        unchecked {\n            return x * y / _BASIS * (x_squared + y * y / _BASIS) / _BASIS;\n        }\n    }\n\n    // For numerically approximating a solution to the `k = x^3 * y + y^3 * x` constant function\n    // using Newton-Raphson, this is `\u2202k/\u2202y = 3 * x * y^2 + x^3`.\n    function _d(uint256 y, uint256 three_x0, uint256 x0_cubed) private pure returns (uint256) {\n        unchecked {\n            return y * y / _BASIS * three_x0 / _BASIS + x0_cubed;\n        }\n    }\n\n    error NotConverged();\n\n    // Using Newton-Raphson iterations, compute the smallest `new_y` such that `_k(x0, new_y) >=\n    // xy`. As a function of `y`, we find the root of `_k(x0, y) - xy`.\n    function _get_y(uint256 x0, uint256 xy, uint256 y) private pure returns (uint256) {\n        unchecked {\n            uint256 three_x0 = 3 * x0;\n            uint256 x0_squared = x0 * x0 / _BASIS;\n            uint256 x0_cubed = x0_squared * x0 / _BASIS;\n            for (uint256 i; i < 255; i++) {\n                uint256 k = _k(x0, y, x0_squared);\n                if (k < xy) {\n                    // there are two cases where dy == 0\n                    // case 1: The y is converged and we find the correct answer\n                    // case 2: _d(x0, y) is too large compare to (xy - k) and the rounding error\n                    //         screwed us.\n                    //         In this case, we need to increase y by 1\n                    uint256 dy = ((xy - k) * _BASIS).unsafeDiv(_d(y, three_x0, x0_cubed));\n                    if (dy == 0) {\n                        if (k == xy) {\n                            // We found the correct answer. Return y\n                            return y;\n                        }\n                        if (_k(x0, y + 1, x0_squared) > xy) {\n                            // If _k(x0, y + 1) > xy, then we are close to the correct answer.\n                            // There's no closer answer than y + 1\n                            return y + 1;\n                        }\n                        dy = 1;\n                    }\n                    y += dy;\n                } else {\n                    uint256 dy = ((k - xy) * _BASIS).unsafeDiv(_d(y, three_x0, x0_cubed));\n                    if (dy == 0) {\n                        if (k == xy || _k(x0, y - 1, x0_squared) < xy) {\n                            // Likewise, if k == xy, we found the correct answer.\n                            // If _k(x0, y - 1) < xy, then we are close to the correct answer.\n                            // There's no closer answer than \"y\"\n                            // It's worth mentioning that we need to find y where _k(x0, y) >= xy\n                            // As a result, we can't return y - 1 even it's closer to the correct answer\n                            return y;\n                        }\n                        dy = 1;\n                    }\n                    y -= dy;\n                }\n            }\n            revert NotConverged();\n        }\n    }\n\n    function sellToVelodrome(address recipient, uint256 bps, IVelodromePair pair, uint24 swapInfo, uint256 minAmountOut)\n        internal\n    {\n        // Preventing calls to Permit2 or AH is not explicitly required as neither of these contracts implement the `swap` nor `transfer` selector\n\n        // |7|6|5|4|3|2|1|0| - bit positions in swapInfo (uint8)\n        // |0|0|0|0|0|0|F|Z| - Z: zeroForOne flag, F: sellTokenHasFee flag\n        bool zeroForOne = (swapInfo & 1) == 1; // Extract the least significant bit (bit 0)\n        bool sellTokenHasFee = (swapInfo & 2) >> 1 == 1; // Extract the second least significant bit (bit 1) and shift it right\n        uint256 feeBps = swapInfo >> 8;\n\n        (\n            uint256 sellBasis,\n            uint256 buyBasis,\n            uint256 sellReserve,\n            uint256 buyReserve,\n            bool stable,\n            IERC20 sellToken,\n            IERC20 buyToken\n        ) = pair.metadata();\n        assert(stable);\n        if (!zeroForOne) {\n            (sellBasis, buyBasis, sellReserve, buyReserve, sellToken, buyToken) =\n                (buyBasis, sellBasis, buyReserve, sellReserve, buyToken, sellToken);\n        }\n\n        uint256 buyAmount;\n        unchecked {\n            // Compute sell amount in native units\n            uint256 sellAmount;\n            if (bps != 0) {\n                // It must be possible to square the sell token balance of the pool, otherwise it\n                // will revert with an overflow. Therefore, it can't be so large that multiplying by\n                // a \"reasonable\" `bps` value could overflow. We don't care to protect against\n                // unreasonable `bps` values because that just means the taker is griefing themself.\n                sellAmount = sellToken.balanceOf(address(this)) * bps / 10_000;\n            }\n            if (sellAmount != 0) {\n                sellToken.safeTransfer(address(pair), sellAmount);\n            }\n            if (sellAmount == 0 || sellTokenHasFee) {\n                sellAmount = sellToken.balanceOf(address(pair)) - sellReserve;\n            }\n            // Apply the fee\n            sellAmount -= sellAmount * feeBps / 10_000; // can't overflow\n\n            // Convert everything from native units to `_BASIS`\n            sellReserve = (sellReserve * _BASIS).unsafeDiv(sellBasis);\n            buyReserve = (buyReserve * _BASIS).unsafeDiv(buyBasis);\n            sellAmount = (sellAmount * _BASIS).unsafeDiv(sellBasis);\n\n            // Solve the constant function numerically to get `buyAmount` from `sellAmount`\n            buyAmount = buyReserve - _get_y(sellAmount + sellReserve, _k(sellReserve, buyReserve), buyReserve);\n\n            // Convert `buyAmount` from `_BASIS` to native units\n            buyAmount = buyAmount * buyBasis / _BASIS;\n        }\n        if (buyAmount < minAmountOut) {\n            revert TooMuchSlippage(sellToken, minAmountOut, buyAmount);\n        }\n\n        {\n            (uint256 buyAmount0, uint256 buyAmount1) = zeroForOne ? (uint256(0), buyAmount) : (buyAmount, uint256(0));\n            pair.swap(buyAmount0, buyAmount1, recipient, new bytes(0));\n        }\n    }\n}\n\n// src/core/RfqOrderSettlement.sol\n\nabstract contract RfqOrderSettlement is SettlerAbstract {\n    using SafeTransferLib for IERC20;\n    using FullMath for uint256;\n\n    struct Consideration {\n        address token;\n        uint256 amount;\n        address counterparty;\n        bool partialFillAllowed;\n    }\n\n    string internal constant CONSIDERATION_TYPE =\n        \"Consideration(address token,uint256 amount,address counterparty,bool partialFillAllowed)\";\n    // `string.concat` isn't recognized by solc as compile-time constant, but `abi.encodePacked` is\n    string internal constant CONSIDERATION_WITNESS =\n        string(abi.encodePacked(\"Consideration consideration)\", CONSIDERATION_TYPE, TOKEN_PERMISSIONS_TYPE));\n    bytes32 internal constant CONSIDERATION_TYPEHASH =\n        0x7d806873084f389a66fd0315dead7adaad8ae6e8b6cf9fb0d3db61e5a91c3ffa;\n\n    string internal constant RFQ_ORDER_TYPE =\n        \"RfqOrder(Consideration makerConsideration,Consideration takerConsideration)\";\n    string internal constant RFQ_ORDER_TYPE_RECURSIVE = string(abi.encodePacked(RFQ_ORDER_TYPE, CONSIDERATION_TYPE));\n    bytes32 internal constant RFQ_ORDER_TYPEHASH = 0x49fa719b76f0f6b7e76be94b56c26671a548e1c712d5b13dc2874f70a7598276;\n\n    function _hashConsideration(Consideration memory consideration) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            let ptr := sub(consideration, 0x20)\n            let oldValue := mload(ptr)\n            mstore(ptr, CONSIDERATION_TYPEHASH)\n            result := keccak256(ptr, 0xa0)\n            mstore(ptr, oldValue)\n        }\n    }\n\n    function _logRfqOrder(bytes32 makerConsiderationHash, bytes32 takerConsiderationHash, uint128 makerFilledAmount)\n        private\n    {\n        assembly (\"memory-safe\") {\n            mstore(0x00, RFQ_ORDER_TYPEHASH)\n            mstore(0x20, makerConsiderationHash)\n            let ptr := mload(0x40)\n            mstore(0x40, takerConsiderationHash)\n            let orderHash := keccak256(0x00, 0x60)\n            mstore(0x40, ptr)\n            mstore(0x10, makerFilledAmount)\n            mstore(0x00, orderHash)\n            log0(0x00, 0x30)\n        }\n    }\n\n    constructor() {\n        assert(CONSIDERATION_TYPEHASH == keccak256(bytes(CONSIDERATION_TYPE)));\n        assert(RFQ_ORDER_TYPEHASH == keccak256(bytes(RFQ_ORDER_TYPE_RECURSIVE)));\n    }\n\n    /// @dev Settle an RfqOrder between maker and taker transfering funds directly between the counterparties. Either\n    ///      two Permit2 signatures are consumed, with the maker Permit2 containing a witness of the RfqOrder, or\n    ///      AllowanceHolder is supported for the taker payment. The Maker has signed the same order as the\n    ///      Taker. Submission may be directly by the taker or via a third party with the Taker signing a witness.\n    /// @dev if used, the taker's witness is not calculated nor verified here as calling function is trusted\n    function fillRfqOrderVIP(\n        address recipient,\n        ISignatureTransfer.PermitTransferFrom memory makerPermit,\n        address maker,\n        bytes memory makerSig,\n        ISignatureTransfer.PermitTransferFrom memory takerPermit,\n        bytes memory takerSig\n    ) internal {\n        (\n            ISignatureTransfer.SignatureTransferDetails memory makerTransferDetails,\n            address makerToken,\n            uint256 makerAmount\n        ) = _permitToTransferDetails(makerPermit, recipient);\n        (\n            ISignatureTransfer.SignatureTransferDetails memory takerTransferDetails,\n            address takerToken,\n            uint256 takerAmount\n        ) = _permitToTransferDetails(takerPermit, maker);\n\n        bytes32 witness = _hashConsideration(\n            Consideration({\n                token: takerToken,\n                amount: takerAmount,\n                counterparty: _msgSender(),\n                partialFillAllowed: false\n            })\n        );\n        _transferFrom(takerPermit, takerTransferDetails, takerSig);\n        _transferFromIKnowWhatImDoing(\n            makerPermit, makerTransferDetails, maker, witness, CONSIDERATION_WITNESS, makerSig, false\n        );\n\n        _logRfqOrder(\n            witness,\n            _hashConsideration(\n                Consideration({token: makerToken, amount: makerAmount, counterparty: maker, partialFillAllowed: false})\n            ),\n            uint128(makerAmount)\n        );\n    }\n\n    /// @dev Settle an RfqOrder between maker and Settler retaining funds in this contract.\n    /// @dev pre-condition: msgSender has been authenticated against the requestor\n    /// One Permit2 signature is consumed, with the maker Permit2 containing a witness of the RfqOrder.\n    // In this variant, Maker pays recipient and Settler pays Maker\n    function fillRfqOrderSelfFunded(\n        address recipient,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        address maker,\n        bytes memory makerSig,\n        IERC20 takerToken,\n        uint256 maxTakerAmount\n    ) internal {\n        // Compute witnesses. These are based on the quoted maximum amounts. We will modify them\n        // later to adjust for the actual settled amount, which may be modified by encountered\n        // slippage.\n        (ISignatureTransfer.SignatureTransferDetails memory transferDetails, address makerToken, uint256 makerAmount) =\n            _permitToTransferDetails(permit, recipient);\n        bytes32 takerWitness = _hashConsideration(\n            Consideration({token: makerToken, amount: makerAmount, counterparty: maker, partialFillAllowed: true})\n        );\n        bytes32 makerWitness = _hashConsideration(\n            Consideration({\n                token: address(takerToken),\n                amount: maxTakerAmount,\n                counterparty: _msgSender(),\n                partialFillAllowed: true\n            })\n        );\n\n        // Now we adjust the transfer amounts to compensate for encountered slippage. Rounding is\n        // performed in the maker's favor.\n        uint256 takerAmount = takerToken.balanceOf(address(this));\n        if (takerAmount > maxTakerAmount) {\n            takerAmount = maxTakerAmount;\n        }\n        transferDetails.requestedAmount = makerAmount = makerAmount.unsafeMulDiv(takerAmount, maxTakerAmount);\n\n        // Now that we have all the relevant information, make the transfers and log the order.\n        takerToken.safeTransfer(maker, takerAmount);\n        _transferFromIKnowWhatImDoing(\n            permit, transferDetails, maker, makerWitness, CONSIDERATION_WITNESS, makerSig, false\n        );\n\n        _logRfqOrder(makerWitness, takerWitness, uint128(makerAmount));\n    }\n}\n\n// src/core/CurveTricrypto.sol\n\ninterface ICurveTricrypto {\n    function exchange_extended(\n        uint256 sellIndex,\n        uint256 buyIndex,\n        uint256 sellAmount,\n        uint256 minBuyAmount,\n        bool useEth,\n        address payer,\n        address receiver,\n        bytes32 callbackSelector\n    ) external returns (uint256 buyAmount);\n}\n\ninterface ICurveTricryptoCallback {\n    // The function name/selector is arbitrary, but the arguments are controlled by the pool\n    function curveTricryptoSwapCallback(\n        address payer,\n        address receiver,\n        IERC20 sellToken,\n        uint256 sellAmount,\n        uint256 buyAmount\n    ) external;\n}\n\nabstract contract CurveTricrypto is SettlerAbstract {\n    using UnsafeMath for uint256;\n    using SafeTransferLib for IERC20;\n    using AddressDerivation for address;\n\n    function _curveFactory() internal virtual returns (address);\n    // uint256 private constant codePrefixLen = 0x539d;\n    // bytes32 private constant codePrefixHash = 0xec96085e693058e09a27755c07882ced27117a3161b1fdaf131a14c7db9978b7;\n\n    function sellToCurveTricryptoVIP(\n        address recipient,\n        uint80 poolInfo,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        bytes memory sig,\n        uint256 minBuyAmount\n    ) internal {\n        uint64 factoryNonce = uint64(poolInfo >> 16);\n        uint8 sellIndex = uint8(poolInfo >> 8);\n        uint8 buyIndex = uint8(poolInfo);\n        address pool = _curveFactory().deriveContract(factoryNonce);\n        /*\n        bytes32 codePrefixHashActual;\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            extcodecopy(pool, ptr, 0x00, codePrefixLen)\n            codePrefixHashActual := keccak256(ptr, codePrefixLen)\n        }\n        if (codePrefixHashActual != codePrefixHash) {\n            revert ConfusedDeputy();\n        }\n        */\n        bool isForwarded = _isForwarded();\n        assembly (\"memory-safe\") {\n            tstore(0x00, isForwarded)\n            tstore(0x01, mload(add(0x20, permit))) // nonce\n            tstore(0x02, mload(add(0x40, permit))) // deadline\n            for {\n                let src := add(0x20, sig)\n                let end\n                {\n                    let len := mload(sig)\n                    end := add(len, src)\n                    tstore(0x03, len)\n                }\n                let dst := 0x04\n            } lt(src, end) {\n                src := add(0x20, src)\n                dst := add(0x01, dst)\n            } { tstore(dst, mload(src)) }\n        }\n        _setOperatorAndCall(\n            pool,\n            abi.encodeCall(\n                ICurveTricrypto.exchange_extended,\n                (\n                    sellIndex,\n                    buyIndex,\n                    permit.permitted.amount,\n                    minBuyAmount,\n                    false,\n                    address(0), // payer\n                    recipient,\n                    bytes32(ICurveTricryptoCallback.curveTricryptoSwapCallback.selector)\n                )\n            ),\n            uint32(ICurveTricryptoCallback.curveTricryptoSwapCallback.selector),\n            _curveTricryptoSwapCallback\n        );\n    }\n\n    function _curveTricryptoSwapCallback(bytes calldata data) private returns (bytes memory) {\n        require(data.length == 0xa0);\n        address payer;\n        IERC20 sellToken;\n        uint256 sellAmount;\n        assembly (\"memory-safe\") {\n            payer := calldataload(data.offset)\n            let err := shr(0xa0, payer)\n            sellToken := calldataload(add(0x40, data.offset))\n            err := or(shr(0xa0, sellToken), err)\n            sellAmount := calldataload(add(0x60, data.offset))\n            if err { revert(0x00, 0x00) }\n        }\n        curveTricryptoSwapCallback(payer, address(0), sellToken, sellAmount, 0);\n        return new bytes(0);\n    }\n\n    function curveTricryptoSwapCallback(address payer, address, IERC20 sellToken, uint256 sellAmount, uint256)\n        private\n    {\n        assert(payer == address(0));\n        bool isForwarded;\n        uint256 nonce;\n        uint256 deadline;\n        bytes memory sig;\n        assembly (\"memory-safe\") {\n            isForwarded := tload(0x00)\n            tstore(0x00, 0x00)\n            nonce := tload(0x01)\n            tstore(0x01, 0x00)\n            deadline := tload(0x02)\n            tstore(0x02, 0x00)\n            sig := mload(0x40)\n            for {\n                let dst := add(0x20, sig)\n                let end\n                {\n                    let len := tload(0x03)\n                    end := add(dst, len)\n                    mstore(sig, len)\n                    mstore(0x40, end)\n                }\n                let src := 0x04\n            } lt(dst, end) {\n                src := add(0x01, src)\n                dst := add(0x20, dst)\n            } {\n                mstore(dst, tload(src))\n                tstore(src, 0x00)\n            }\n        }\n        ISignatureTransfer.PermitTransferFrom memory permit = ISignatureTransfer.PermitTransferFrom({\n            permitted: ISignatureTransfer.TokenPermissions({token: address(sellToken), amount: sellAmount}),\n            nonce: nonce,\n            deadline: deadline\n        });\n        (ISignatureTransfer.SignatureTransferDetails memory transferDetails,,) =\n            _permitToTransferDetails(permit, msg.sender);\n        _transferFrom(permit, transferDetails, sig, isForwarded);\n    }\n}\n\n// src/core/DodoV1.sol\n\ninterface IDodo {\n    function sellBaseToken(uint256 amount, uint256 minReceiveQuote, bytes calldata data) external returns (uint256);\n\n    function buyBaseToken(uint256 amount, uint256 maxPayQuote, bytes calldata data) external returns (uint256);\n\n    function _R_STATUS_() external view returns (uint8);\n\n    function _QUOTE_BALANCE_() external view returns (uint256);\n\n    function _BASE_BALANCE_() external view returns (uint256);\n\n    function _K_() external view returns (uint256);\n\n    function _MT_FEE_RATE_() external view returns (uint256);\n\n    function _LP_FEE_RATE_() external view returns (uint256);\n\n    function getExpectedTarget() external view returns (uint256 baseTarget, uint256 quoteTarget);\n\n    function getOraclePrice() external view returns (uint256);\n}\n\nlibrary Math {\n    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 quotient = a / b;\n        unchecked {\n            uint256 remainder = a - quotient * b;\n            if (remainder > 0) {\n                return quotient + 1;\n            } else {\n                return quotient;\n            }\n        }\n    }\n\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\n        unchecked {\n            uint256 z = x / 2 + 1;\n            y = x;\n            while (z < y) {\n                y = z;\n                z = (x / z + z) / 2;\n            }\n        }\n    }\n}\n\nlibrary DecimalMath {\n    using Math for uint256;\n\n    uint256 constant ONE = 10 ** 18;\n\n    function mul(uint256 target, uint256 d) internal pure returns (uint256) {\n        unchecked {\n            return target * d / ONE;\n        }\n    }\n\n    function mulCeil(uint256 target, uint256 d) internal pure returns (uint256) {\n        unchecked {\n            return (target * d).divCeil(ONE);\n        }\n    }\n\n    function divFloor(uint256 target, uint256 d) internal pure returns (uint256) {\n        unchecked {\n            return target * ONE / d;\n        }\n    }\n\n    function divCeil(uint256 target, uint256 d) internal pure returns (uint256) {\n        unchecked {\n            return (target * ONE).divCeil(d);\n        }\n    }\n}\n\nlibrary DodoMath {\n    using Math for uint256;\n\n    /*\n        Integrate dodo curve fron V1 to V2\n        require V0>=V1>=V2>0\n        res = (1-k)i(V1-V2)+ikV0*V0(1/V2-1/V1)\n        let V1-V2=delta\n        res = i*delta*(1-k+k(V0^2/V1/V2))\n    */\n    function _GeneralIntegrate(uint256 V0, uint256 V1, uint256 V2, uint256 i, uint256 k)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            uint256 fairAmount = DecimalMath.mul(i, V1 - V2); // i*delta\n            uint256 V0V0V1V2 = DecimalMath.divCeil(V0 * V0 / V1, V2);\n            uint256 penalty = DecimalMath.mul(k, V0V0V1V2); // k(V0^2/V1/V2)\n            return DecimalMath.mul(fairAmount, DecimalMath.ONE - k + penalty);\n        }\n    }\n\n    /*\n        The same with integration expression above, we have:\n        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\n        Given Q1 and deltaB, solve Q2\n        This is a quadratic function and the standard version is\n        aQ2^2 + bQ2 + c = 0, where\n        a=1-k\n        -b=(1-k)Q1-kQ0^2/Q1+i*deltaB\n        c=-kQ0^2\n        and Q2=(-b+sqrt(b^2+4(1-k)kQ0^2))/2(1-k)\n        note: another root is negative, abondan\n        if deltaBSig=true, then Q2>Q1\n        if deltaBSig=false, then Q2<Q1\n    */\n    function _SolveQuadraticFunctionForTrade(uint256 Q0, uint256 Q1, uint256 ideltaB, bool deltaBSig, uint256 k)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            // calculate -b value and sig\n            // -b = (1-k)Q1-kQ0^2/Q1+i*deltaB\n            uint256 kQ02Q1 = DecimalMath.mul(k, Q0) * Q0 / Q1; // kQ0^2/Q1\n            uint256 b = DecimalMath.mul(DecimalMath.ONE - k, Q1); // (1-k)Q1\n            bool minusbSig = true;\n            if (deltaBSig) {\n                b += ideltaB; // (1-k)Q1+i*deltaB\n            } else {\n                kQ02Q1 += ideltaB; // i*deltaB+kQ0^2/Q1\n            }\n            if (b >= kQ02Q1) {\n                b -= kQ02Q1;\n                minusbSig = true;\n            } else {\n                b = kQ02Q1 - b;\n                minusbSig = false;\n            }\n\n            // calculate sqrt\n            uint256 squareRoot = DecimalMath.mul((DecimalMath.ONE - k) * 4, DecimalMath.mul(k, Q0) * Q0); // 4(1-k)kQ0^2\n            squareRoot = (b * b + squareRoot).sqrt(); // sqrt(b*b+4(1-k)kQ0*Q0)\n\n            // final res\n            uint256 denominator = (DecimalMath.ONE - k) * 2; // 2(1-k)\n            uint256 numerator;\n            if (minusbSig) {\n                numerator = b + squareRoot;\n            } else {\n                numerator = squareRoot - b;\n            }\n\n            if (deltaBSig) {\n                return DecimalMath.divFloor(numerator, denominator);\n            } else {\n                return DecimalMath.divCeil(numerator, denominator);\n            }\n        }\n    }\n\n    /*\n        Start from the integration function\n        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\n        Assume Q2=Q0, Given Q1 and deltaB, solve Q0\n        let fairAmount = i*deltaB\n    */\n    function _SolveQuadraticFunctionForTarget(uint256 V1, uint256 k, uint256 fairAmount)\n        internal\n        pure\n        returns (uint256 V0)\n    {\n        unchecked {\n            // V0 = V1+V1*(sqrt-1)/2k\n            uint256 sqrt = DecimalMath.divCeil(DecimalMath.mul(k, fairAmount) * 4, V1);\n            sqrt = ((sqrt + DecimalMath.ONE) * DecimalMath.ONE).sqrt();\n            uint256 premium = DecimalMath.divCeil(sqrt - DecimalMath.ONE, k * 2);\n            // V0 is greater than or equal to V1 according to the solution\n            return DecimalMath.mul(V1, DecimalMath.ONE + premium);\n        }\n    }\n}\n\nabstract contract DodoSellHelper {\n    using Math for uint256;\n\n    enum RStatus {\n        ONE,\n        ABOVE_ONE,\n        BELOW_ONE\n    }\n\n    struct DodoState {\n        uint256 oraclePrice;\n        uint256 K;\n        uint256 B;\n        uint256 Q;\n        uint256 baseTarget;\n        uint256 quoteTarget;\n        RStatus rStatus;\n    }\n\n    function dodoQuerySellQuoteToken(IDodo dodo, uint256 amount) internal view returns (uint256) {\n        DodoState memory state;\n        (state.baseTarget, state.quoteTarget) = dodo.getExpectedTarget();\n        state.rStatus = RStatus(dodo._R_STATUS_());\n        state.oraclePrice = dodo.getOraclePrice();\n        state.Q = dodo._QUOTE_BALANCE_();\n        state.B = dodo._BASE_BALANCE_();\n        state.K = dodo._K_();\n\n        unchecked {\n            uint256 boughtAmount;\n            // Determine the status (RStatus) and calculate the amount based on the\n            // state\n            if (state.rStatus == RStatus.ONE) {\n                boughtAmount = _ROneSellQuoteToken(amount, state);\n            } else if (state.rStatus == RStatus.ABOVE_ONE) {\n                boughtAmount = _RAboveSellQuoteToken(amount, state);\n            } else {\n                uint256 backOneBase = state.B - state.baseTarget;\n                uint256 backOneQuote = state.quoteTarget - state.Q;\n                if (amount <= backOneQuote) {\n                    boughtAmount = _RBelowSellQuoteToken(amount, state);\n                } else {\n                    boughtAmount = backOneBase + _ROneSellQuoteToken(amount - backOneQuote, state);\n                }\n            }\n            // Calculate fees\n            return DecimalMath.divFloor(boughtAmount, DecimalMath.ONE + dodo._MT_FEE_RATE_() + dodo._LP_FEE_RATE_());\n        }\n    }\n\n    function _ROneSellQuoteToken(uint256 amount, DodoState memory state)\n        private\n        pure\n        returns (uint256 receiveBaseToken)\n    {\n        unchecked {\n            uint256 i = DecimalMath.divFloor(DecimalMath.ONE, state.oraclePrice);\n            uint256 B2 = DodoMath._SolveQuadraticFunctionForTrade(\n                state.baseTarget, state.baseTarget, DecimalMath.mul(i, amount), false, state.K\n            );\n            return state.baseTarget - B2;\n        }\n    }\n\n    function _RAboveSellQuoteToken(uint256 amount, DodoState memory state)\n        private\n        pure\n        returns (uint256 receieBaseToken)\n    {\n        unchecked {\n            uint256 i = DecimalMath.divFloor(DecimalMath.ONE, state.oraclePrice);\n            uint256 B2 = DodoMath._SolveQuadraticFunctionForTrade(\n                state.baseTarget, state.B, DecimalMath.mul(i, amount), false, state.K\n            );\n            return state.B - B2;\n        }\n    }\n\n    function _RBelowSellQuoteToken(uint256 amount, DodoState memory state)\n        private\n        pure\n        returns (uint256 receiveBaseToken)\n    {\n        unchecked {\n            uint256 Q1 = state.Q + amount;\n            uint256 i = DecimalMath.divFloor(DecimalMath.ONE, state.oraclePrice);\n            return DodoMath._GeneralIntegrate(state.quoteTarget, Q1, state.Q, i, state.K);\n        }\n    }\n}\n\nabstract contract DodoV1 is SettlerAbstract, DodoSellHelper {\n    using FullMath for uint256;\n    using SafeTransferLib for IERC20;\n\n    function sellToDodoV1(IERC20 sellToken, uint256 bps, address dodo, bool quoteForBase, uint256 minBuyAmount)\n        internal\n    {\n        uint256 sellAmount = sellToken.balanceOf(address(this)).mulDiv(bps, 10_000);\n        sellToken.safeApproveIfBelow(dodo, sellAmount);\n        if (quoteForBase) {\n            uint256 buyAmount = dodoQuerySellQuoteToken(IDodo(dodo), sellAmount);\n            if (buyAmount < minBuyAmount) {\n                revert TooMuchSlippage(sellToken, minBuyAmount, buyAmount);\n            }\n            IDodo(dodo).buyBaseToken(buyAmount, sellAmount, new bytes(0));\n        } else {\n            IDodo(dodo).sellBaseToken(sellAmount, minBuyAmount, new bytes(0));\n        }\n    }\n}\n\n// src/core/Permit2Payment.sol\n\nlibrary TransientStorage {\n    // bytes32(uint256(keccak256(\"operator slot\")) - 1)\n    bytes32 private constant _OPERATOR_SLOT = 0x009355806b743562f351db2e3726091207f49fa1cdccd5c65a7d4860ce3abbe9;\n    // bytes32(uint256(keccak256(\"witness slot\")) - 1)\n    bytes32 private constant _WITNESS_SLOT = 0x1643bf8e9fdaef48c4abf5a998de359be44a235ac7aebfbc05485e093720deaa;\n    // bytes32(uint256(keccak256(\"payer slot\")) - 1)\n    bytes32 private constant _PAYER_SLOT = 0x46bacb9b87ba1d2910347e4a3e052d06c824a45acd1e9517bb0cb8d0d5cde893;\n\n    // We assume (and our CI enforces) that internal function pointers cannot be\n    // greater than 2 bytes. On chains not supporting the ViaIR pipeline, not\n    // supporting EOF, and where the Spurious Dragon size limit is not enforced,\n    // it might be possible to violate this assumption. However, our\n    // `foundry.toml` enforces the use of the IR pipeline, so the point is moot.\n    //\n    // `operator` must not be `address(0)`. This is not checked.\n    // `callback` must not be zero. This is checked in `_invokeCallback`.\n    function setOperatorAndCallback(\n        address operator,\n        uint32 selector,\n        function (bytes calldata) internal returns (bytes memory) callback\n    ) internal {\n        address currentSigner;\n        assembly (\"memory-safe\") {\n            currentSigner := tload(_PAYER_SLOT)\n        }\n        if (operator == currentSigner) {\n            revert ConfusedDeputy();\n        }\n        uint256 callbackInt;\n        assembly (\"memory-safe\") {\n            callbackInt := tload(_OPERATOR_SLOT)\n        }\n        if (callbackInt != 0) {\n            // It should be impossible to reach this error because the first thing the fallback does\n            // is clear the operator. It's also not possible to reenter the entrypoint function\n            // because `_PAYER_SLOT` is an implicit reentrancy guard.\n            revert ReentrantCallback(callbackInt);\n        }\n        assembly (\"memory-safe\") {\n            tstore(\n                _OPERATOR_SLOT,\n                or(\n                    shl(0xe0, selector),\n                    or(shl(0xa0, and(0xffff, callback)), and(0xffffffffffffffffffffffffffffffffffffffff, operator))\n                )\n            )\n        }\n    }\n\n    function checkSpentOperatorAndCallback() internal view {\n        uint256 callbackInt;\n        assembly (\"memory-safe\") {\n            callbackInt := tload(_OPERATOR_SLOT)\n        }\n        if (callbackInt != 0) {\n            revert CallbackNotSpent(callbackInt);\n        }\n    }\n\n    function getAndClearOperatorAndCallback()\n        internal\n        returns (bytes4 selector, function (bytes calldata) internal returns (bytes memory) callback, address operator)\n    {\n        assembly (\"memory-safe\") {\n            selector := tload(_OPERATOR_SLOT)\n            callback := and(0xffff, shr(0xa0, selector))\n            operator := selector\n            tstore(_OPERATOR_SLOT, 0x00)\n        }\n    }\n\n    // `newWitness` must not be `bytes32(0)`. This is not checked.\n    function setWitness(bytes32 newWitness) internal {\n        bytes32 currentWitness;\n        assembly (\"memory-safe\") {\n            currentWitness := tload(_WITNESS_SLOT)\n        }\n        if (currentWitness != bytes32(0)) {\n            // It should be impossible to reach this error because the first thing a metatransaction\n            // does on entry is to spend the `witness` (either directly or via a callback)\n            revert ReentrantMetatransaction(currentWitness);\n        }\n        assembly (\"memory-safe\") {\n            tstore(_WITNESS_SLOT, newWitness)\n        }\n    }\n\n    function checkSpentWitness() internal view {\n        bytes32 currentWitness;\n        assembly (\"memory-safe\") {\n            currentWitness := tload(_WITNESS_SLOT)\n        }\n        if (currentWitness != bytes32(0)) {\n            revert WitnessNotSpent(currentWitness);\n        }\n    }\n\n    function getAndClearWitness() internal returns (bytes32 witness) {\n        assembly (\"memory-safe\") {\n            witness := tload(_WITNESS_SLOT)\n            tstore(_WITNESS_SLOT, 0x00)\n        }\n    }\n\n    function setPayer(address payer) internal {\n        if (payer == address(0)) {\n            revert ConfusedDeputy();\n        }\n        address oldPayer;\n        assembly (\"memory-safe\") {\n            oldPayer := tload(_PAYER_SLOT)\n        }\n        if (oldPayer != address(0)) {\n            revert ReentrantPayer(oldPayer);\n        }\n        assembly (\"memory-safe\") {\n            tstore(_PAYER_SLOT, and(0xffffffffffffffffffffffffffffffffffffffff, payer))\n        }\n    }\n\n    function getPayer() internal view returns (address payer) {\n        assembly (\"memory-safe\") {\n            payer := tload(_PAYER_SLOT)\n        }\n    }\n\n    function clearPayer(address expectedOldPayer) internal {\n        address oldPayer;\n        assembly (\"memory-safe\") {\n            oldPayer := tload(_PAYER_SLOT)\n        }\n        if (oldPayer != expectedOldPayer) {\n            revert PayerSpent();\n        }\n        assembly (\"memory-safe\") {\n            tstore(_PAYER_SLOT, 0x00)\n        }\n    }\n}\n\nabstract contract Permit2PaymentBase is SettlerAbstract {\n    using Revert for bool;\n\n    /// @dev Permit2 address\n    ISignatureTransfer internal constant _PERMIT2 = ISignatureTransfer(0x000000000022D473030F116dDEE9F6B43aC78BA3);\n\n    function _isRestrictedTarget(address target) internal pure virtual override returns (bool) {\n        return target == address(_PERMIT2);\n    }\n\n    function _msgSender() internal view virtual override returns (address) {\n        return TransientStorage.getPayer();\n    }\n\n    /// @dev You must ensure that `target` is derived by hashing trusted initcode or another\n    ///      equivalent mechanism that guarantees \"reasonable\"ness. `target` must not be\n    ///      user-supplied or attacker-controlled. This is required for security and is not checked\n    ///      here. For example, it must not do something weird like modifying the spender (possibly\n    ///      setting it to itself). If the callback is expected to relay a\n    ///      `ISignatureTransfer.PermitTransferFrom` struct, then the computation of `target` using\n    ///      the trusted initcode (or equivalent) must ensure that that calldata is relayed\n    ///      unmodified. The library function `AddressDerivation.deriveDeterministicContract` is\n    ///      recommended.\n    function _setOperatorAndCall(\n        address payable target,\n        uint256 value,\n        bytes memory data,\n        uint32 selector,\n        function (bytes calldata) internal returns (bytes memory) callback\n    ) internal returns (bytes memory) {\n        TransientStorage.setOperatorAndCallback(target, selector, callback);\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        success.maybeRevert(returndata);\n        TransientStorage.checkSpentOperatorAndCallback();\n        return returndata;\n    }\n\n    function _setOperatorAndCall(\n        address target,\n        bytes memory data,\n        uint32 selector,\n        function (bytes calldata) internal returns (bytes memory) callback\n    ) internal override returns (bytes memory) {\n        return _setOperatorAndCall(payable(target), 0, data, selector, callback);\n    }\n\n    function _invokeCallback(bytes calldata data) internal returns (bytes memory) {\n        // Retrieve callback and perform call with untrusted calldata\n        (bytes4 selector, function (bytes calldata) internal returns (bytes memory) callback, address operator) =\n            TransientStorage.getAndClearOperatorAndCallback();\n        require(bytes4(data) == selector);\n        require(msg.sender == operator);\n        return callback(data[4:]);\n    }\n}\n\nabstract contract Permit2Payment is Permit2PaymentBase {\n    fallback(bytes calldata data) external virtual returns (bytes memory) {\n        return _invokeCallback(data);\n    }\n\n    function _permitToTransferDetails(ISignatureTransfer.PermitTransferFrom memory permit, address recipient)\n        internal\n        pure\n        override\n        returns (ISignatureTransfer.SignatureTransferDetails memory transferDetails, address token, uint256 amount)\n    {\n        transferDetails.to = recipient;\n        transferDetails.requestedAmount = amount = permit.permitted.amount;\n        token = permit.permitted.token;\n    }\n\n    // This function is provided *EXCLUSIVELY* for use here and in RfqOrderSettlement. Any other use\n    // of this function is forbidden. You must use the version that does *NOT* take a `from` or\n    // `witness` argument.\n    function _transferFromIKnowWhatImDoing(\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        ISignatureTransfer.SignatureTransferDetails memory transferDetails,\n        address from,\n        bytes32 witness,\n        string memory witnessTypeString,\n        bytes memory sig,\n        bool isForwarded\n    ) internal override {\n        if (isForwarded) revert ForwarderNotAllowed();\n        _PERMIT2.permitWitnessTransferFrom(permit, transferDetails, from, witness, witnessTypeString, sig);\n    }\n\n    // See comment in above overload; don't use this function\n    function _transferFromIKnowWhatImDoing(\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        ISignatureTransfer.SignatureTransferDetails memory transferDetails,\n        address from,\n        bytes32 witness,\n        string memory witnessTypeString,\n        bytes memory sig\n    ) internal override {\n        _transferFromIKnowWhatImDoing(permit, transferDetails, from, witness, witnessTypeString, sig, _isForwarded());\n    }\n\n    function _transferFrom(\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        ISignatureTransfer.SignatureTransferDetails memory transferDetails,\n        bytes memory sig\n    ) internal override {\n        _transferFrom(permit, transferDetails, sig, _isForwarded());\n    }\n}\n\nabstract contract Permit2PaymentTakerSubmitted is AllowanceHolderContext, Permit2Payment {\n    constructor() {\n        assert(!_hasMetaTxn());\n    }\n\n    function _isRestrictedTarget(address target) internal pure virtual override returns (bool) {\n        return target == address(_ALLOWANCE_HOLDER) || super._isRestrictedTarget(target);\n    }\n\n    function _operator() internal view override returns (address) {\n        return AllowanceHolderContext._msgSender();\n    }\n\n    function _msgSender()\n        internal\n        view\n        virtual\n        override(Permit2PaymentBase, AllowanceHolderContext)\n        returns (address)\n    {\n        return Permit2PaymentBase._msgSender();\n    }\n\n    function _transferFrom(\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        ISignatureTransfer.SignatureTransferDetails memory transferDetails,\n        bytes memory sig,\n        bool isForwarded\n    ) internal override {\n        if (isForwarded) {\n            if (sig.length != 0) revert InvalidSignatureLen();\n            if (permit.nonce != 0) Panic.panic(Panic.ARITHMETIC_OVERFLOW);\n            if (block.timestamp > permit.deadline) revert SignatureExpired(permit.deadline);\n            // we don't check `requestedAmount` because it's checked by AllowanceHolder itself\n            _allowanceHolderTransferFrom(\n                permit.permitted.token, _msgSender(), transferDetails.to, transferDetails.requestedAmount\n            );\n        } else {\n            _PERMIT2.permitTransferFrom(permit, transferDetails, _msgSender(), sig);\n        }\n    }\n\n    function _allowanceHolderTransferFrom(address token, address owner, address recipient, uint256 amount)\n        internal\n        override\n    {\n        // `owner` is always `_msgSender()`\n        _ALLOWANCE_HOLDER.transferFrom(token, owner, recipient, amount);\n    }\n\n    modifier takerSubmitted() override {\n        address msgSender = _operator();\n        TransientStorage.setPayer(msgSender);\n        _;\n        TransientStorage.clearPayer(msgSender);\n    }\n\n    modifier metaTx(address, bytes32) override {\n        revert();\n        _;\n    }\n}\n\nabstract contract Permit2PaymentMetaTxn is Context, Permit2Payment {\n    constructor() {\n        assert(_hasMetaTxn());\n    }\n\n    function _operator() internal view override returns (address) {\n        return Context._msgSender();\n    }\n\n    function _msgSender() internal view virtual override(Permit2PaymentBase, Context) returns (address) {\n        return Permit2PaymentBase._msgSender();\n    }\n\n    // `string.concat` isn't recognized by solc as compile-time constant, but `abi.encodePacked` is\n    // This is defined here as `private` and not in `SettlerAbstract` as `internal` because no other\n    // contract/file should reference it. The *ONLY* approved way to make a transfer using this\n    // witness string is by setting the witness with modifier `metaTx`\n    string private constant _SLIPPAGE_AND_ACTIONS_WITNESS = string(\n        abi.encodePacked(\"SlippageAndActions slippageAndActions)\", SLIPPAGE_AND_ACTIONS_TYPE, TOKEN_PERMISSIONS_TYPE)\n    );\n\n    function _transferFrom(\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        ISignatureTransfer.SignatureTransferDetails memory transferDetails,\n        bytes memory sig,\n        bool isForwarded // must be false\n    ) internal override {\n        bytes32 witness = TransientStorage.getAndClearWitness();\n        if (witness == bytes32(0)) {\n            revert ConfusedDeputy();\n        }\n        _transferFromIKnowWhatImDoing(\n            permit, transferDetails, _msgSender(), witness, _SLIPPAGE_AND_ACTIONS_WITNESS, sig, isForwarded\n        );\n    }\n\n    function _allowanceHolderTransferFrom(address, address, address, uint256) internal pure override {\n        revert ConfusedDeputy();\n    }\n\n    modifier takerSubmitted() override {\n        revert();\n        _;\n    }\n\n    modifier metaTx(address msgSender, bytes32 witness) override {\n        if (_isForwarded()) {\n            revert ForwarderNotAllowed();\n        }\n        TransientStorage.setWitness(witness);\n        TransientStorage.setPayer(msgSender);\n        _;\n        TransientStorage.clearPayer(msgSender);\n        // It should not be possible for this check to revert because the very first thing that a\n        // metatransaction does is spend the witness.\n        TransientStorage.checkSpentWitness();\n    }\n}\n\n// src/core/UniswapV3Fork.sol\n\ninterface IUniswapV3Pool {\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive),\n    /// or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n}\n\nabstract contract UniswapV3Fork is SettlerAbstract {\n    using UnsafeMath for uint256;\n    using SafeTransferLib for IERC20;\n\n    /// @dev Minimum size of an encoded swap path:\n    ///      sizeof(address(inputToken) | uint8(forkId) | uint24(poolId) | address(outputToken))\n    uint256 private constant SINGLE_HOP_PATH_SIZE = 0x2c;\n    /// @dev How many bytes to skip ahead in an encoded path to start at the next hop:\n    ///      sizeof(address(inputToken) | uint8(forkId) | uint24(poolId))\n    uint256 private constant PATH_SKIP_HOP_SIZE = 0x18;\n    /// @dev The size of the swap callback prefix data before the Permit2 data.\n    uint256 private constant SWAP_CALLBACK_PREFIX_DATA_SIZE = 0x28;\n    /// @dev The offset from the pointer to the length of the swap callback prefix data to the start of the Permit2 data.\n    uint256 private constant SWAP_CALLBACK_PERMIT2DATA_OFFSET = 0x48;\n    uint256 private constant PERMIT_DATA_SIZE = 0x60;\n    uint256 private constant ISFORWARDED_DATA_SIZE = 0x01;\n    /// @dev Minimum tick price sqrt ratio.\n    uint160 private constant MIN_PRICE_SQRT_RATIO = 4295128739;\n    /// @dev Minimum tick price sqrt ratio.\n    uint160 private constant MAX_PRICE_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n    /// @dev Mask of lower 20 bytes.\n    uint256 private constant ADDRESS_MASK = 0x00ffffffffffffffffffffffffffffffffffffffff;\n    /// @dev Mask of lower 3 bytes.\n    uint256 private constant UINT24_MASK = 0xffffff;\n\n    /// @dev Sell a token for another token directly against uniswap v3.\n    /// @param encodedPath Uniswap-encoded path.\n    /// @param bps proportion of current balance of the first token in the path to sell.\n    /// @param minBuyAmount Minimum amount of the last token in the path to buy.\n    /// @param recipient The recipient of the bought tokens.\n    /// @return buyAmount Amount of the last token in the path bought.\n    function sellToUniswapV3(address recipient, uint256 bps, bytes memory encodedPath, uint256 minBuyAmount)\n        internal\n        returns (uint256 buyAmount)\n    {\n        buyAmount = _uniV3ForkSwap(\n            recipient,\n            encodedPath,\n            // We don't care about phantom overflow here because reserves are\n            // limited to 128 bits. Any token balance that would overflow here\n            // would also break UniV3.\n            (IERC20(address(bytes20(encodedPath))).balanceOf(address(this)) * bps).unsafeDiv(10_000),\n            minBuyAmount,\n            address(this), // payer\n            new bytes(SWAP_CALLBACK_PREFIX_DATA_SIZE)\n        );\n    }\n\n    /// @dev Sell a token for another token directly against uniswap v3. Payment is using a Permit2 signature (or AllowanceHolder).\n    /// @param encodedPath Uniswap-encoded path.\n    /// @param minBuyAmount Minimum amount of the last token in the path to buy.\n    /// @param recipient The recipient of the bought tokens.\n    /// @param permit The PermitTransferFrom allowing this contract to spend the taker's tokens\n    /// @param sig The taker's signature for Permit2\n    /// @return buyAmount Amount of the last token in the path bought.\n    function sellToUniswapV3VIP(\n        address recipient,\n        bytes memory encodedPath,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        bytes memory sig,\n        uint256 minBuyAmount\n    ) internal returns (uint256 buyAmount) {\n        bytes memory swapCallbackData =\n            new bytes(SWAP_CALLBACK_PREFIX_DATA_SIZE + PERMIT_DATA_SIZE + ISFORWARDED_DATA_SIZE + sig.length);\n        _encodePermit2Data(swapCallbackData, permit, sig, _isForwarded());\n\n        buyAmount = _uniV3ForkSwap(\n            recipient,\n            encodedPath,\n            permit.permitted.amount,\n            minBuyAmount,\n            address(0), // payer\n            swapCallbackData\n        );\n    }\n\n    // Executes successive swaps along an encoded uniswap path.\n    function _uniV3ForkSwap(\n        address recipient,\n        bytes memory encodedPath,\n        uint256 sellAmount,\n        uint256 minBuyAmount,\n        address payer,\n        bytes memory swapCallbackData\n    ) internal returns (uint256 buyAmount) {\n        if (sellAmount > uint256(type(int256).max)) {\n            Panic.panic(Panic.ARITHMETIC_OVERFLOW);\n        }\n\n        IERC20 outputToken;\n        while (true) {\n            bool isPathMultiHop = _isPathMultiHop(encodedPath);\n            bool zeroForOne;\n            IUniswapV3Pool pool;\n            uint32 callbackSelector;\n            {\n                (IERC20 token0, uint8 forkId, uint24 poolId, IERC20 token1) = _decodeFirstPoolInfoFromPath(encodedPath);\n                IERC20 sellToken = token0;\n                outputToken = token1;\n                if (!(zeroForOne = token0 < token1)) {\n                    (token0, token1) = (token1, token0);\n                }\n                address factory;\n                bytes32 initHash;\n                (factory, initHash, callbackSelector) = _uniV3ForkInfo(forkId);\n                pool = _toPool(factory, initHash, token0, token1, poolId);\n                _updateSwapCallbackData(swapCallbackData, sellToken, payer);\n            }\n\n            int256 amount0;\n            int256 amount1;\n            if (isPathMultiHop) {\n                uint256 freeMemPtr;\n                assembly (\"memory-safe\") {\n                    freeMemPtr := mload(0x40)\n                }\n                (amount0, amount1) = abi.decode(\n                    _setOperatorAndCall(\n                        address(pool),\n                        abi.encodeCall(\n                            pool.swap,\n                            (\n                                // Intermediate tokens go to this contract.\n                                address(this),\n                                zeroForOne,\n                                int256(sellAmount),\n                                zeroForOne ? MIN_PRICE_SQRT_RATIO + 1 : MAX_PRICE_SQRT_RATIO - 1,\n                                swapCallbackData\n                            )\n                        ),\n                        callbackSelector,\n                        _uniV3ForkCallback\n                    ),\n                    (int256, int256)\n                );\n                assembly (\"memory-safe\") {\n                    mstore(0x40, freeMemPtr)\n                }\n            } else {\n                (amount0, amount1) = abi.decode(\n                    _setOperatorAndCall(\n                        address(pool),\n                        abi.encodeCall(\n                            pool.swap,\n                            (\n                                recipient,\n                                zeroForOne,\n                                int256(sellAmount),\n                                zeroForOne ? MIN_PRICE_SQRT_RATIO + 1 : MAX_PRICE_SQRT_RATIO - 1,\n                                swapCallbackData\n                            )\n                        ),\n                        callbackSelector,\n                        _uniV3ForkCallback\n                    ),\n                    (int256, int256)\n                );\n            }\n\n            {\n                int256 _buyAmount = -(zeroForOne ? amount1 : amount0);\n                if (_buyAmount < 0) {\n                    Panic.panic(Panic.ARITHMETIC_OVERFLOW);\n                }\n                buyAmount = uint256(_buyAmount);\n            }\n            if (!isPathMultiHop) {\n                // Done.\n                break;\n            }\n            // Continue with next hop.\n            payer = address(this); // Subsequent hops are paid for by us.\n            sellAmount = buyAmount;\n            // Skip to next hop along path.\n            encodedPath = _shiftHopFromPathInPlace(encodedPath);\n            assembly (\"memory-safe\") {\n                mstore(swapCallbackData, SWAP_CALLBACK_PREFIX_DATA_SIZE)\n            }\n        }\n        if (buyAmount < minBuyAmount) {\n            revert TooMuchSlippage(outputToken, minBuyAmount, buyAmount);\n        }\n    }\n\n    // Return whether or not an encoded uniswap path contains more than one hop.\n    function _isPathMultiHop(bytes memory encodedPath) private pure returns (bool) {\n        return encodedPath.length > SINGLE_HOP_PATH_SIZE;\n    }\n\n    function _decodeFirstPoolInfoFromPath(bytes memory encodedPath)\n        private\n        pure\n        returns (IERC20 inputToken, uint8 forkId, uint24 poolId, IERC20 outputToken)\n    {\n        if (encodedPath.length < SINGLE_HOP_PATH_SIZE) {\n            Panic.panic(Panic.ARRAY_OUT_OF_BOUNDS);\n        }\n        assembly (\"memory-safe\") {\n            // Solidity cleans dirty bits automatically\n            inputToken := mload(add(encodedPath, 0x14))\n            forkId := mload(add(encodedPath, 0x15))\n            poolId := mload(add(encodedPath, 0x18))\n            outputToken := mload(add(encodedPath, SINGLE_HOP_PATH_SIZE))\n        }\n    }\n\n    // Skip past the first hop of an encoded uniswap path in-place.\n    function _shiftHopFromPathInPlace(bytes memory encodedPath) private pure returns (bytes memory) {\n        if (encodedPath.length < PATH_SKIP_HOP_SIZE) {\n            Panic.panic(Panic.ARRAY_OUT_OF_BOUNDS);\n        }\n        assembly (\"memory-safe\") {\n            let length := sub(mload(encodedPath), PATH_SKIP_HOP_SIZE)\n            encodedPath := add(encodedPath, PATH_SKIP_HOP_SIZE)\n            mstore(encodedPath, length)\n        }\n        return encodedPath;\n    }\n\n    function _encodePermit2Data(\n        bytes memory swapCallbackData,\n        ISignatureTransfer.PermitTransferFrom memory permit,\n        bytes memory sig,\n        bool isForwarded\n    ) private pure {\n        assembly (\"memory-safe\") {\n            mstore(add(SWAP_CALLBACK_PERMIT2DATA_OFFSET, swapCallbackData), mload(add(0x20, mload(permit))))\n            mcopy(add(add(SWAP_CALLBACK_PERMIT2DATA_OFFSET, 0x20), swapCallbackData), add(0x20, permit), 0x40)\n            mstore8(add(add(SWAP_CALLBACK_PERMIT2DATA_OFFSET, PERMIT_DATA_SIZE), swapCallbackData), isForwarded)\n            mcopy(\n                add(\n                    add(add(SWAP_CALLBACK_PERMIT2DATA_OFFSET, PERMIT_DATA_SIZE), ISFORWARDED_DATA_SIZE),\n                    swapCallbackData\n                ),\n                add(0x20, sig),\n                mload(sig)\n            )\n        }\n    }\n\n    // Update `swapCallbackData` in place with new values.\n    function _updateSwapCallbackData(bytes memory swapCallbackData, IERC20 sellToken, address payer) private pure {\n        assembly (\"memory-safe\") {\n            let length := mload(swapCallbackData)\n            mstore(add(0x28, swapCallbackData), sellToken)\n            mstore(add(0x14, swapCallbackData), payer)\n            mstore(swapCallbackData, length)\n        }\n    }\n\n    // Compute the pool address given two tokens and a poolId.\n    function _toPool(address factory, bytes32 initHash, IERC20 token0, IERC20 token1, uint24 poolId)\n        private\n        pure\n        returns (IUniswapV3Pool)\n    {\n        // address(keccak256(abi.encodePacked(\n        //     hex\"ff\",\n        //     factory,\n        //     keccak256(abi.encode(token0, token1, poolId)),\n        //     initHash\n        // )))\n        bytes32 salt;\n        assembly (\"memory-safe\") {\n            token0 := and(ADDRESS_MASK, token0)\n            token1 := and(ADDRESS_MASK, token1)\n            poolId := and(UINT24_MASK, poolId)\n            let ptr := mload(0x40)\n            mstore(0x00, token0)\n            mstore(0x20, token1)\n            mstore(0x40, poolId)\n            salt := keccak256(0x00, sub(0x60, shl(0x05, iszero(poolId))))\n            mstore(0x40, ptr)\n        }\n        return IUniswapV3Pool(AddressDerivation.deriveDeterministicContract(factory, salt, initHash));\n    }\n\n    function _uniV3ForkInfo(uint8 forkId) internal view virtual returns (address, bytes32, uint32);\n\n    function _uniV3ForkCallback(bytes calldata data) private returns (bytes memory) {\n        require(data.length >= 0x80);\n        int256 amount0Delta;\n        int256 amount1Delta;\n        assembly (\"memory-safe\") {\n            amount0Delta := calldataload(data.offset)\n            amount1Delta := calldataload(add(0x20, data.offset))\n            data.offset := add(data.offset, calldataload(add(0x40, data.offset)))\n            data.length := calldataload(data.offset)\n            data.offset := add(0x20, data.offset)\n        }\n        uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n        return new bytes(0);\n    }\n\n    /// @dev The UniswapV3 pool swap callback which pays the funds requested\n    ///      by the caller/pool to the pool. Can only be called by a valid\n    ///      UniswapV3 pool.\n    /// @param amount0Delta Token0 amount owed.\n    /// @param amount1Delta Token1 amount owed.\n    /// @param data Arbitrary data forwarded from swap() caller. A packed encoding of: payer, sellToken, (optionally: permit[0x20:], isForwarded, sig)\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) private {\n        address payer = address(uint160(bytes20(data)));\n        data = data[0x14:];\n        uint256 sellAmount = amount0Delta > 0 ? uint256(amount0Delta) : uint256(amount1Delta);\n        _pay(payer, sellAmount, data);\n    }\n\n    function _pay(address payer, uint256 amount, bytes calldata permit2Data) private {\n        if (payer == address(this)) {\n            IERC20(address(uint160(bytes20(permit2Data)))).safeTransfer(msg.sender, amount);\n        } else {\n            assert(payer == address(0));\n            ISignatureTransfer.PermitTransferFrom calldata permit;\n            bool isForwarded;\n            bytes calldata sig;\n            assembly (\"memory-safe\") {\n                // this is super dirty, but it works because although `permit` is aliasing in the\n                // middle of `payer`, because `payer` is all zeroes, it's treated as padding for the\n                // first word of `permit`, which is the sell token\n                permit := sub(permit2Data.offset, 0x0c)\n                isForwarded := and(0x01, calldataload(add(0x55, permit2Data.offset)))\n                sig.offset := add(0x75, permit2Data.offset)\n                sig.length := sub(permit2Data.length, 0x75)\n            }\n            _transferFrom(\n                permit,\n                ISignatureTransfer.SignatureTransferDetails({to: msg.sender, requestedAmount: amount}),\n                sig,\n                isForwarded\n            );\n        }\n    }\n}\n\n// src/core/Basic.sol\n\nabstract contract Basic is SettlerAbstract {\n    using SafeTransferLib for IERC20;\n    using FullMath for uint256;\n    using Revert for bool;\n\n    IERC20 internal constant ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    /// @dev Sell to a pool with a generic approval, transferFrom interaction.\n    /// offset in the calldata is used to update the sellAmount given a proportion of the sellToken balance\n    function basicSellToPool(IERC20 sellToken, uint256 bps, address pool, uint256 offset, bytes memory data) internal {\n        if (_isRestrictedTarget(pool)) {\n            revert ConfusedDeputy();\n        }\n\n        bool success;\n        bytes memory returnData;\n        uint256 value;\n        if (sellToken == IERC20(ETH_ADDRESS)) {\n            value = address(this).balance.mulDiv(bps, 10_000);\n            if (data.length == 0) {\n                if (offset != 0) revert InvalidOffset();\n                (success, returnData) = payable(pool).call{value: value}(\"\");\n                success.maybeRevert(returnData);\n                return;\n            } else {\n                if ((offset += 32) > data.length) {\n                    Panic.panic(Panic.ARRAY_OUT_OF_BOUNDS);\n                }\n                assembly (\"memory-safe\") {\n                    mstore(add(data, offset), value)\n                }\n            }\n        } else if (address(sellToken) == address(0)) {\n            // TODO: check for zero `bps`\n            if (offset != 0) revert InvalidOffset();\n        } else {\n            uint256 amount = sellToken.balanceOf(address(this)).mulDiv(bps, 10_000);\n            if ((offset += 32) > data.length) {\n                Panic.panic(Panic.ARRAY_OUT_OF_BOUNDS);\n            }\n            assembly (\"memory-safe\") {\n                mstore(add(data, offset), amount)\n            }\n            if (address(sellToken) != pool) {\n                sellToken.safeApproveIfBelow(pool, amount);\n            }\n        }\n        (success, returnData) = payable(pool).call{value: value}(data);\n        success.maybeRevert(returnData);\n        // forbid sending data to EOAs\n        if (returnData.length == 0 && pool.code.length == 0) revert InvalidTarget();\n    }\n}\n\n// src/SettlerBase.sol\n\n/// @dev This library's ABIDeocding is more lax than the Solidity ABIDecoder. This library omits index bounds/overflow\n/// checking when accessing calldata arrays for gas efficiency. It also omits checks against `calldatasize()`. This\n/// means that it is possible that `args` will run off the end of calldata and be implicitly padded with zeroes. That we\n/// don't check for overflow means that offsets can be negative. This can also result in `args` that alias other parts\n/// of calldata, or even the `actions` array itself.\nlibrary CalldataDecoder {\n    function decodeCall(bytes[] calldata data, uint256 i)\n        internal\n        pure\n        returns (bytes4 selector, bytes calldata args)\n    {\n        assembly (\"memory-safe\") {\n            // initially, we set `args.offset` to the pointer to the length. this is 32 bytes before the actual start of data\n            args.offset :=\n                add(\n                    data.offset,\n                    // We allow the indirection/offset to `calls[i]` to be negative\n                    calldataload(\n                        add(shl(5, i), data.offset) // can't overflow; we assume `i` is in-bounds\n                    )\n                )\n            // now we load `args.length` and set `args.offset` to the start of data\n            args.length := calldataload(args.offset)\n            args.offset := add(args.offset, 0x20)\n\n            // slice off the first 4 bytes of `args` as the selector\n            selector := calldataload(args.offset) // solidity cleans dirty bits automatically\n            args.length := sub(args.length, 0x04)\n            args.offset := add(args.offset, 0x04)\n        }\n    }\n}\n\nabstract contract SettlerBase is Basic, RfqOrderSettlement, UniswapV3Fork, UniswapV2, DodoV1, Velodrome {\n    using SafeTransferLib for IERC20;\n    using SafeTransferLib for address payable;\n\n    receive() external payable {}\n\n    event GitCommit(bytes20 indexed);\n\n    constructor(bytes20 gitCommit, uint256 tokenId) {\n        if (block.chainid != 31337) {\n            emit GitCommit(gitCommit);\n            assert(IERC721Owner(0x00000000000004533Fe15556B1E086BB1A72cEae).ownerOf(tokenId) == address(this));\n        } else {\n            assert(gitCommit == bytes20(0));\n        }\n    }\n\n    struct AllowedSlippage {\n        address recipient;\n        IERC20 buyToken;\n        uint256 minAmountOut;\n    }\n\n    function _checkSlippageAndTransfer(AllowedSlippage calldata slippage) internal {\n        // This final slippage check effectively prohibits custody optimization on the\n        // final hop of every swap. This is gas-inefficient. This is on purpose. Because\n        // ISettlerActions.BASIC could interact with an intents-based settlement\n        // mechanism, we must ensure that the user's want token increase is coming\n        // directly from us instead of from some other form of exchange of value.\n        (address recipient, IERC20 buyToken, uint256 minAmountOut) =\n            (slippage.recipient, slippage.buyToken, slippage.minAmountOut);\n        if (minAmountOut != 0 || address(buyToken) != address(0)) {\n            if (buyToken == ETH_ADDRESS) {\n                uint256 amountOut = address(this).balance;\n                if (amountOut < minAmountOut) {\n                    revert TooMuchSlippage(buyToken, minAmountOut, amountOut);\n                }\n                payable(recipient).safeTransferETH(amountOut);\n            } else {\n                uint256 amountOut = buyToken.balanceOf(address(this));\n                if (amountOut < minAmountOut) {\n                    revert TooMuchSlippage(buyToken, minAmountOut, amountOut);\n                }\n                buyToken.safeTransfer(recipient, amountOut);\n            }\n        }\n    }\n\n    function _dispatch(uint256, bytes4 action, bytes calldata data) internal virtual override returns (bool) {\n        if (action == ISettlerActions.TRANSFER_FROM.selector) {\n            (address recipient, ISignatureTransfer.PermitTransferFrom memory permit, bytes memory sig) =\n                abi.decode(data, (address, ISignatureTransfer.PermitTransferFrom, bytes));\n            (ISignatureTransfer.SignatureTransferDetails memory transferDetails,,) =\n                _permitToTransferDetails(permit, recipient);\n            _transferFrom(permit, transferDetails, sig);\n        } else if (action == ISettlerActions.RFQ.selector) {\n            (\n                address recipient,\n                ISignatureTransfer.PermitTransferFrom memory permit,\n                address maker,\n                bytes memory makerSig,\n                IERC20 takerToken,\n                uint256 maxTakerAmount\n            ) = abi.decode(data, (address, ISignatureTransfer.PermitTransferFrom, address, bytes, IERC20, uint256));\n\n            fillRfqOrderSelfFunded(recipient, permit, maker, makerSig, takerToken, maxTakerAmount);\n        } else if (action == ISettlerActions.UNISWAPV3.selector) {\n            (address recipient, uint256 bps, bytes memory path, uint256 amountOutMin) =\n                abi.decode(data, (address, uint256, bytes, uint256));\n\n            sellToUniswapV3(recipient, bps, path, amountOutMin);\n        } else if (action == ISettlerActions.UNISWAPV2.selector) {\n            (address recipient, address sellToken, uint256 bps, address pool, uint24 swapInfo, uint256 amountOutMin) =\n                abi.decode(data, (address, address, uint256, address, uint24, uint256));\n\n            sellToUniswapV2(recipient, sellToken, bps, pool, swapInfo, amountOutMin);\n        } else if (action == ISettlerActions.BASIC.selector) {\n            (IERC20 sellToken, uint256 bps, address pool, uint256 offset, bytes memory _data) =\n                abi.decode(data, (IERC20, uint256, address, uint256, bytes));\n\n            basicSellToPool(sellToken, bps, pool, offset, _data);\n        } else if (action == ISettlerActions.DODOV1.selector) {\n            (IERC20 sellToken, uint256 bps, address dodo, bool quoteForBase, uint256 minBuyAmount) =\n                abi.decode(data, (IERC20, uint256, address, bool, uint256));\n\n            sellToDodoV1(sellToken, bps, dodo, quoteForBase, minBuyAmount);\n        } else if (action == ISettlerActions.VELODROME.selector) {\n            (address recipient, uint256 bps, IVelodromePair pool, uint24 swapInfo, uint256 minAmountOut) =\n                abi.decode(data, (address, uint256, IVelodromePair, uint24, uint256));\n\n            sellToVelodrome(recipient, bps, pool, swapInfo, minAmountOut);\n        } else if (action == ISettlerActions.POSITIVE_SLIPPAGE.selector) {\n            (address recipient, IERC20 token, uint256 expectedAmount) = abi.decode(data, (address, IERC20, uint256));\n            if (token == IERC20(ETH_ADDRESS)) {\n                uint256 balance = address(this).balance;\n                if (balance > expectedAmount) {\n                    unchecked {\n                        payable(recipient).safeTransferETH(balance - expectedAmount);\n                    }\n                }\n            } else {\n                uint256 balance = token.balanceOf(address(this));\n                if (balance > expectedAmount) {\n                    unchecked {\n                        token.safeTransfer(recipient, balance - expectedAmount);\n                    }\n                }\n            }\n        } else {\n            return false;\n        }\n        return true;\n    }\n}\n\n// src/Settler.sol\n\nabstract contract Settler is Permit2PaymentTakerSubmitted, SettlerBase {\n    using UnsafeMath for uint256;\n    using CalldataDecoder for bytes[];\n\n    // When/if you change this, you must make corresponding changes to\n    // `sh/deploy_new_chain.sh` and 'sh/common_deploy_settler.sh' to set\n    // `constructor_args`.\n    constructor(bytes20 gitCommit) SettlerBase(gitCommit, 2) {}\n\n    function _hasMetaTxn() internal pure override returns (bool) {\n        return false;\n    }\n\n    function _msgSender()\n        internal\n        view\n        virtual\n        // Solidity inheritance is so stupid\n        override(Permit2PaymentTakerSubmitted, AbstractContext)\n        returns (address)\n    {\n        return super._msgSender();\n    }\n\n    function _isRestrictedTarget(address target)\n        internal\n        pure\n        virtual\n        // Solidity inheritance is so stupid\n        override(Permit2PaymentTakerSubmitted, Permit2PaymentAbstract)\n        returns (bool)\n    {\n        return super._isRestrictedTarget(target);\n    }\n\n    function _dispatchVIP(bytes4 action, bytes calldata data) internal virtual returns (bool) {\n        if (action == ISettlerActions.RFQ_VIP.selector) {\n            (\n                address recipient,\n                ISignatureTransfer.PermitTransferFrom memory makerPermit,\n                address maker,\n                bytes memory makerSig,\n                ISignatureTransfer.PermitTransferFrom memory takerPermit,\n                bytes memory takerSig\n            ) = abi.decode(\n                data,\n                (\n                    address,\n                    ISignatureTransfer.PermitTransferFrom,\n                    address,\n                    bytes,\n                    ISignatureTransfer.PermitTransferFrom,\n                    bytes\n                )\n            );\n\n            fillRfqOrderVIP(recipient, makerPermit, maker, makerSig, takerPermit, takerSig);\n        } else if (action == ISettlerActions.UNISWAPV3_VIP.selector) {\n            (\n                address recipient,\n                bytes memory path,\n                ISignatureTransfer.PermitTransferFrom memory permit,\n                bytes memory sig,\n                uint256 amountOutMin\n            ) = abi.decode(data, (address, bytes, ISignatureTransfer.PermitTransferFrom, bytes, uint256));\n\n            sellToUniswapV3VIP(recipient, path, permit, sig, amountOutMin);\n        } else {\n            return false;\n        }\n        return true;\n    }\n\n    function execute(AllowedSlippage calldata slippage, bytes[] calldata actions, bytes32 /* zid & affiliate */ )\n        public\n        payable\n        takerSubmitted\n        returns (bool)\n    {\n        for (uint256 i; i < actions.length; i = i.unsafeInc()) {\n            (bytes4 action, bytes calldata data) = actions.decodeCall(i);\n            if (!((i == 0 && _dispatchVIP(action, data)) || _dispatch(i, action, data))) {\n                revert ActionInvalid(i, action, data);\n            }\n        }\n\n        _checkSlippageAndTransfer(slippage);\n        return true;\n    }\n}\n\n// src/SettlerMetaTxn.sol\n\nabstract contract SettlerMetaTxn is Permit2PaymentMetaTxn, SettlerBase {\n    using UnsafeMath for uint256;\n    using CalldataDecoder for bytes[];\n\n    // When/if you change this, you must make corresponding changes to\n    // `sh/deploy_new_chain.sh` and 'sh/common_deploy_settler.sh' to set\n    // `constructor_args`.\n    constructor(bytes20 gitCommit) SettlerBase(gitCommit, 3) {}\n\n    function _hasMetaTxn() internal pure override returns (bool) {\n        return true;\n    }\n\n    function _msgSender()\n        internal\n        view\n        virtual\n        // Solidity inheritance is so stupid\n        override(Permit2PaymentMetaTxn, AbstractContext)\n        returns (address)\n    {\n        return super._msgSender();\n    }\n\n    function _hashArrayOfBytes(bytes[] calldata actions) internal pure returns (bytes32 result) {\n        // This function deliberately does no bounds checking on `actions` for\n        // gas efficiency. We assume that `actions` will get used elsewhere in\n        // this context and any OOB or other malformed calldata will result in a\n        // revert later.\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            let hashesLength := shl(5, actions.length)\n            for {\n                let i := actions.offset\n                let dst := ptr\n                let end := add(i, hashesLength)\n            } lt(i, end) {\n                i := add(i, 0x20)\n                dst := add(dst, 0x20)\n            } {\n                let src := add(actions.offset, calldataload(i))\n                let length := calldataload(src)\n                calldatacopy(dst, add(src, 0x20), length)\n                mstore(dst, keccak256(dst, length))\n            }\n            result := keccak256(ptr, hashesLength)\n        }\n    }\n\n    function _hashActionsAndSlippage(bytes[] calldata actions, AllowedSlippage calldata slippage)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        // This function does not check for or clean any dirty bits that might\n        // exist in `slippage`. We assume that `slippage` will be used elsewhere\n        // in this context and that if there are dirty bits it will result in a\n        // revert later.\n        bytes32 arrayOfBytesHash = _hashArrayOfBytes(actions);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(ptr, SLIPPAGE_AND_ACTIONS_TYPEHASH)\n            calldatacopy(add(ptr, 0x20), slippage, 0x60)\n            mstore(add(ptr, 0x80), arrayOfBytesHash)\n            result := keccak256(ptr, 0xa0)\n        }\n    }\n\n    function _dispatchVIP(bytes4 action, bytes calldata data, bytes calldata sig) internal virtual returns (bool) {\n        if (action == ISettlerActions.METATXN_RFQ_VIP.selector) {\n            // An optimized path involving a maker/taker in a single trade\n            // The RFQ order is signed by both maker and taker, validation is\n            // performed inside the RfqOrderSettlement so there is no need to\n            // validate `sig` against `actions` here\n            (\n                address recipient,\n                ISignatureTransfer.PermitTransferFrom memory makerPermit,\n                address maker,\n                bytes memory makerSig,\n                ISignatureTransfer.PermitTransferFrom memory takerPermit\n            ) = abi.decode(\n                data,\n                (address, ISignatureTransfer.PermitTransferFrom, address, bytes, ISignatureTransfer.PermitTransferFrom)\n            );\n\n            fillRfqOrderVIP(recipient, makerPermit, maker, makerSig, takerPermit, sig);\n        } else if (action == ISettlerActions.METATXN_TRANSFER_FROM.selector) {\n            (address recipient, ISignatureTransfer.PermitTransferFrom memory permit) =\n                abi.decode(data, (address, ISignatureTransfer.PermitTransferFrom));\n            (ISignatureTransfer.SignatureTransferDetails memory transferDetails,,) =\n                _permitToTransferDetails(permit, recipient);\n\n            // We simultaneously transfer-in the taker's tokens and authenticate the\n            // metatransaction.\n            _transferFrom(permit, transferDetails, sig);\n        } else if (action == ISettlerActions.METATXN_UNISWAPV3_VIP.selector) {\n            (\n                address recipient,\n                bytes memory path,\n                ISignatureTransfer.PermitTransferFrom memory permit,\n                uint256 amountOutMin\n            ) = abi.decode(data, (address, bytes, ISignatureTransfer.PermitTransferFrom, uint256));\n\n            sellToUniswapV3VIP(recipient, path, permit, sig, amountOutMin);\n        } else {\n            return false;\n        }\n        return true;\n    }\n\n    function executeMetaTxn(\n        AllowedSlippage calldata slippage,\n        bytes[] calldata actions,\n        bytes32, /* zid & affiliate */\n        address msgSender,\n        bytes calldata sig\n    ) public metaTx(msgSender, _hashActionsAndSlippage(actions, slippage)) returns (bool) {\n        require(actions.length != 0);\n        {\n            (bytes4 action, bytes calldata data) = actions.decodeCall(0);\n\n            // By forcing the first action to be one of the witness-aware\n            // actions, we ensure that the entire sequence of actions is\n            // authorized. `msgSender` is the signer of the metatransaction.\n            if (!_dispatchVIP(action, data, sig)) {\n                revert ActionInvalid(0, action, data);\n            }\n        }\n\n        for (uint256 i = 1; i < actions.length; i = i.unsafeInc()) {\n            (bytes4 action, bytes calldata data) = actions.decodeCall(i);\n            if (!_dispatch(i, action, data)) {\n                revert ActionInvalid(i, action, data);\n            }\n        }\n\n        _checkSlippageAndTransfer(slippage);\n        return true;\n    }\n}\n\n// src/chains/Mainnet.sol\n\n// Solidity inheritance is stupid\n\nabstract contract MainnetMixin is FreeMemory, SettlerBase, MakerPSM, CurveTricrypto {\n    constructor() {\n        assert(block.chainid == 1 || block.chainid == 31337);\n    }\n\n    function _dispatch(uint256 i, bytes4 action, bytes calldata data)\n        internal\n        virtual\n        override(SettlerAbstract, SettlerBase)\n        DANGEROUS_freeMemory\n        returns (bool)\n    {\n        if (super._dispatch(i, action, data)) {\n            return true;\n        } else if (action == ISettlerActions.MAKERPSM.selector) {\n            (address recipient, IERC20 gemToken, uint256 bps, IPSM psm, bool buyGem) =\n                abi.decode(data, (address, IERC20, uint256, IPSM, bool));\n\n            sellToMakerPsm(recipient, gemToken, bps, psm, buyGem);\n        } else {\n            return false;\n        }\n        return true;\n    }\n\n    function _uniV3ForkInfo(uint8 forkId)\n        internal\n        pure\n        override\n        returns (address factory, bytes32 initHash, uint32 callbackSelector)\n    {\n        if (forkId == uniswapV3ForkId) {\n            factory = uniswapV3MainnetFactory;\n            initHash = uniswapV3InitHash;\n            callbackSelector = uint32(IUniswapV3Callback.uniswapV3SwapCallback.selector);\n        } else if (forkId == pancakeSwapV3ForkId) {\n            factory = pancakeSwapV3Factory;\n            initHash = pancakeSwapV3InitHash;\n            callbackSelector = uint32(IPancakeSwapV3Callback.pancakeV3SwapCallback.selector);\n        } else if (forkId == solidlyV3ForkId) {\n            factory = solidlyV3Factory;\n            initHash = solidlyV3InitHash;\n            callbackSelector = uint32(ISolidlyV3Callback.solidlyV3SwapCallback.selector);\n        } else {\n            revert UnknownForkId(forkId);\n        }\n    }\n\n    function _curveFactory() internal pure override returns (address) {\n        return 0x0c0e5f2fF0ff18a3be9b835635039256dC4B4963;\n    }\n}\n\n/// @custom:security-contact security@0x.org\ncontract MainnetSettler is Settler, MainnetMixin {\n    constructor(bytes20 gitCommit) Settler(gitCommit) {}\n\n    function _dispatchVIP(bytes4 action, bytes calldata data) internal override DANGEROUS_freeMemory returns (bool) {\n        if (super._dispatchVIP(action, data)) {\n            return true;\n        } else if (action == ISettlerActions.CURVE_TRICRYPTO_VIP.selector) {\n            (\n                address recipient,\n                uint80 poolInfo,\n                ISignatureTransfer.PermitTransferFrom memory permit,\n                bytes memory sig,\n                uint256 minBuyAmount\n            ) = abi.decode(data, (address, uint80, ISignatureTransfer.PermitTransferFrom, bytes, uint256));\n\n            sellToCurveTricryptoVIP(recipient, poolInfo, permit, sig, minBuyAmount);\n        } else {\n            return false;\n        }\n        return true;\n    }\n\n    // Solidity inheritance is stupid\n    function _isRestrictedTarget(address target)\n        internal\n        pure\n        override(Settler, Permit2PaymentAbstract)\n        returns (bool)\n    {\n        return super._isRestrictedTarget(target);\n    }\n\n    function _dispatch(uint256 i, bytes4 action, bytes calldata data)\n        internal\n        override(SettlerAbstract, SettlerBase, MainnetMixin)\n        returns (bool)\n    {\n        return super._dispatch(i, action, data);\n    }\n\n    function _msgSender() internal view override(Settler, AbstractContext) returns (address) {\n        return super._msgSender();\n    }\n}\n\n/// @custom:security-contact security@0x.org\ncontract MainnetSettlerMetaTxn is SettlerMetaTxn, MainnetMixin {\n    constructor(bytes20 gitCommit) SettlerMetaTxn(gitCommit) {}\n\n    function _dispatchVIP(bytes4 action, bytes calldata data, bytes calldata sig)\n        internal\n        override\n        DANGEROUS_freeMemory\n        returns (bool)\n    {\n        if (super._dispatchVIP(action, data, sig)) {\n            return true;\n        } else if (action == ISettlerActions.METATXN_CURVE_TRICRYPTO_VIP.selector) {\n            (\n                address recipient,\n                uint80 poolInfo,\n                ISignatureTransfer.PermitTransferFrom memory permit,\n                uint256 minBuyAmount\n            ) = abi.decode(data, (address, uint80, ISignatureTransfer.PermitTransferFrom, uint256));\n\n            sellToCurveTricryptoVIP(recipient, poolInfo, permit, sig, minBuyAmount);\n        } else {\n            return false;\n        }\n        return true;\n    }\n\n    // Solidity inheritance is stupid\n    function _dispatch(uint256 i, bytes4 action, bytes calldata data)\n        internal\n        override(SettlerAbstract, SettlerBase, MainnetMixin)\n        returns (bool)\n    {\n        return super._dispatch(i, action, data);\n    }\n\n    function _msgSender() internal view override(SettlerMetaTxn, AbstractContext) returns (address) {\n        return super._msgSender();\n    }\n}\n"}}, "settings": {"remappings": ["solmate/=lib/solmate/", "permit2/=lib/permit2/", "forge-std/=lib/forge-std/src/", "forge-gas-snapshot/=lib/forge-gas-snapshot/src/", "ds-test/=lib/forge-std/lib/ds-test/src/"], "optimizer": {"enabled": false, "runs": 200}, "metadata": {"appendCBOR": false}, "outputSelection": {"*": {"*": ["abi", "metadata", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers", "evm.legacyAssembly", "evm.bytecode.opcodes"]}}, "evmVersion": "cancun", "viaIR": true, "libraries": {}}}