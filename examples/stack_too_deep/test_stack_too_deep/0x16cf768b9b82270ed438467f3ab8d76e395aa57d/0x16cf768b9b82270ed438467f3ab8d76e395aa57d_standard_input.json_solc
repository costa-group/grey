{"language": "Solidity", "sources": {"src/Staking.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\ncontract StakingManager is ReentrancyGuard, Ownable, Pausable {\n    using SafeERC20 for IERC20; // Wrappers around ERC20 operations that throw on failure\n\n    // Digest\n    string private constant DIGEST = \"2025-01-30\"; // Compile version\n\n    // Main\n    bool public isMainNetwork; // Set true if its the main network where the coin will be deployed\n    IERC20 public saleToken; // Token to be staked and rewarded\n    uint256 public saleTokenTotalMinted; // Total sale tokens minted;\n    address public presaleContract; // Presale contract address\n    address public admin; // Admin address\n\n    // Sum\n    uint256 public tokensStakedByPresale; // Total tokens staked by presale\n    uint256 public tokensStakedByNetwork; // Total tokens staked by this network\n    uint256 public tokensStakedTotal; // Total tokens staked in all networks\n    uint256 public tokensStakedTotalLastUpdateTime; // Time the tokens staked total was updated\n\n    // Pool\n    uint256 public poolLastDayReward; // Pool last day the pool had their rewards calculated\n    uint256 public poolAccumulatedRewardsPerShare; // Pool accumulated rewards per share times REWARDS PRECISION, it saves the total rewards generated in the pool until the last processment, per share means the value is relative to all coins stake\n\n    // Claim\n    uint256 public claimStartTime; // Users are allowed to claim after this time in epoch\n    uint256 public claimLockDays; // To lock the tokens in contract for a definite time IN SECONDS, this is the min time needed to keep in stake before can claim again.\n\n    // Stake\n    uint256 public stakeStartTime; // At this time the stake will be started - 1 July 2024 15:00:00 - 1719846000\n    uint256 public stakeEndTime; // At this time the stake will be stopped - 1 July 2025 15:00:00 - 1751382000.   --- DIFF 31536000\n    uint256 public stakeRewardsTokensPerDay; // Number of reward tokens minted per day\n\n    // Constants\n    uint256 private constant REWARDS_PRECISION = 1e12; // A big number to perform mul and div operations\n    uint256 private constant DAY_SECONDS = 86400; // Number of seconds of a day\n\n    // Staking user for a pool\n    struct PoolStaker {\n        uint256 stakerAmount; // The amount of tokens the user has staked\n        uint256 stakerStakedTime; // The time the tokens was staked\n        uint256 stakerRewardsHarvested; // Total amount of tokens rewards the user harvested\n        uint256 stakerRewardsDebt; // Total amount the user cant get as reward (relative to poolAccumulatedRewardsPerShare)\n        uint256 stakerRewardsLocked; // Total amount of locked rewards\n        bool stakerIsBlacklisted; // Mark if user is blacklisted\n    }\n\n    // Staker address => PoolStaker\n    mapping(address => PoolStaker) public poolStakers; // Save data of all stakers\n    mapping(address => bool) public imported;\n    address[] private addressStakersPresale; // Save address of stakers that join in the presale\n    bool public isImportDone;\n\n    // Events\n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n    event HarvestRewards(address indexed user, uint256 amount);\n    event TokensStakedTotalUpdated(uint256 amount);\n    event TokensStakedTotalUpdated(uint256 amount, uint256 updateTime);\n    event TokensStakedTotalLastUpdateTimeUpdated(uint256 updateTime);\n    event AdminUpdated(address indexed pAdmin);\n    event PresaleContractUpdated(address indexed pPresaleContract);\n    event ClaimStartTimeUpdated(uint256 pClaimStartTime);\n    event StakeEndTimeUpdated(uint256 pStakeEndTime);\n    event StakeRewardsTokensPerDayUpdated(uint256 pStakeRewardsTokensPerDay);\n    event PoolLastDayRewardUpdated(uint256 pPoolLastDayReward);\n    event PoolAccumulatedRewardsPerShareUpdated(uint256 poolAccumulatedRewardsPerShare);\n\n    // Modifiers\n    modifier onlyPresale() {\n        require(msg.sender == presaleContract, \"This method is only for presale contract\");\n        _;\n    }\n\n    modifier onlyOwnerOrAdmin() {\n        require(msg.sender == admin || msg.sender == owner(), \"Only owner or admin\");\n        _;\n    }\n\n    /**\n     * @dev Initializes the contract and sets initial parameters\n     *\n     * @param _isMainNetwork True if this is the network where the presale token will be deployed\n     * @param _saleToken Address of the token\n     * @param _presaleContract Address of the presale\n     * @param _admin Address of admin\n     * @param _stakeStartTime Time the stake will be started\n     * @param _stakeEndTime Time the stake will be stopped\n     * @param _stakeRewardsTokensPerDay Number of reward tokens minted per day\n     * @param _claimStartTime Time where the claim will be available\n     * @param _claimLockDays To lock the tokens in contract for a definite time IN DAYS, this is the min time needed to keep in stake before can claim again\n     * @param _saleTokenTotalMinted Total of sale tokens minted\n     */\n    constructor(\n        bool _isMainNetwork,\n        address _saleToken,\n        address _presaleContract,\n        address _admin,\n        uint256 _stakeStartTime,\n        uint256 _stakeEndTime,\n        uint256 _stakeRewardsTokensPerDay,\n        uint256 _claimStartTime,\n        uint256 _claimLockDays,\n        uint256 _saleTokenTotalMinted\n    ) Ownable(msg.sender) {\n        require(_presaleContract != address(0), \"Presale contract is required\");\n        require(_admin != address(0), \"Admin address is required\");\n        require(_stakeStartTime < _stakeEndTime, \"Presale end time must be greater than start time\");\n        require(_stakeEndTime > block.timestamp, \"Presale end time must be in the future\");\n        require(_stakeRewardsTokensPerDay > 0, \"Stake rewards per day should be bigger than ZERO\");\n\n        isMainNetwork = _isMainNetwork;\n        if (_isMainNetwork) saleToken = IERC20(_saleToken);\n        presaleContract = _presaleContract;\n        admin = _admin;\n        stakeStartTime = _stakeStartTime;\n        stakeEndTime = _stakeEndTime;\n        stakeRewardsTokensPerDay = _stakeRewardsTokensPerDay;\n        claimStartTime = _claimStartTime;\n        claimLockDays = _claimLockDays;\n        poolLastDayReward = stakeStartTime; // Initialize\n        tokensStakedTotalLastUpdateTime = stakeStartTime; // Initialize\n        saleTokenTotalMinted = _saleTokenTotalMinted;\n    }\n\n    /**\n     * @dev Deposit tokens to the pool from outside the presale\n     *\n     * This function allows users to deposit tokens they already have to the staking pool,\n     * when the presale already finished.\n     * It moves the deposited tokens to the staking pool.\n     *\n     * @param pAmount The amount of tokens to deposit\n     *\n     * Requirements:\n     * - Contract must be on the main network\n     * - Staking must have started\n     * - Staking must not have ended\n     * - Deposit amount cannot be zero\n     * - User must not be blacklisted\n     *\n     * Effects:\n     * - Updates the pool stakers' information\n     * - Updates the current staker's information\n     * - Updates the total tokens staked by the network\n     * - Transfers the deposited tokens from the user to the contract\n     *\n     * Emits a Deposit event with the user's address and the amount deposited\n     */\n    function deposit(address pUserAddress, uint256 pAmount) external nonReentrant whenNotPaused {\n        require(isMainNetwork, \"This is not the main network\");\n        require(msg.sender == presaleContract || msg.sender == pUserAddress, \"Only user or presale allowed\");\n        require(block.timestamp >= stakeStartTime, \"Staking hasn't started\");\n        require(block.timestamp < stakeEndTime, \"Staking has been ended\");\n        require(block.timestamp >= claimStartTime, \"Claim is not available\");\n        require(pAmount > 0, \"Deposit amount can't be zero\");\n\n        PoolStaker storage staker = poolStakers[pUserAddress];\n\n        updatePoolRewards();\n\n        // Update pool stakers\n        harvestRewards(pUserAddress, false);\n\n        // Update current staker\n        staker.stakerAmount += pAmount;\n        staker.stakerRewardsDebt = (staker.stakerAmount * poolAccumulatedRewardsPerShare) / REWARDS_PRECISION;\n        staker.stakerStakedTime = block.timestamp;\n\n        // Update pool\n        tokensStakedByNetwork += pAmount;\n        tokensStakedTotal += pAmount;\n\n        // Deposit tokens\n        emit Deposit(pUserAddress, pAmount);\n\n        // Receive a deposit of coins to this address\n        saleToken.safeTransferFrom(msg.sender, address(this), pAmount);\n    }\n\n    /**\n     * @dev Deposit tokens to the pool by the presale contract\n     *\n     * Do not move the coins in the presale stage.\n     * At the end of the presale, the total amount sold in all networks with the total supply of staking coins is moved here so it can be withdraw.\n     * Do not move the coins in the presale stage\n     *\n     * @param pUserAddress The address of the user who is depositing tokens\n     * @param pAmount The amount of tokens to deposit\n     *\n     * Requirements:\n     * - Staking must have started\n     * - Staking must not have ended\n     * - Deposit amount cannot be zero\n     * - User must not be blacklisted\n     *\n     * Effects:\n     * - Updates the pool stakers' information\n     * - Updates the current staker's information\n     * - Updates the total tokens staked by the network\n     *\n     * Emits a Deposit event with the user's address and the amount deposited\n     */\n    function depositByPresale(address pUserAddress, uint256 pAmount) external nonReentrant whenNotPaused onlyPresale {\n        require(block.timestamp >= stakeStartTime, \"Staking hasn't started\");\n        require(block.timestamp < stakeEndTime, \"Staking has been ended\");\n        require(block.timestamp < claimStartTime, \"Claim is available\");\n        require(pAmount > 0, \"Deposit amount can't be zero\");\n\n        PoolStaker storage staker = poolStakers[pUserAddress];\n\n        //Add user if its his first interaction\n        if (staker.stakerAmount == 0) addressStakersPresale.push(pUserAddress);\n\n        // Update pool stakers\n        harvestRewards(pUserAddress, false);\n\n        // Update current staker\n        staker.stakerAmount += pAmount;\n        staker.stakerRewardsDebt = (staker.stakerAmount * poolAccumulatedRewardsPerShare) / REWARDS_PRECISION;\n        staker.stakerStakedTime = block.timestamp;\n\n        // Update pool\n        tokensStakedByNetwork += pAmount;\n        tokensStakedByPresale += pAmount;\n\n        // Deposit tokens\n        emit Deposit(pUserAddress, pAmount);\n    }\n\n    /**\n     * @dev Withdraw all staked tokens from the pool\n     *\n     * Requirements:\n     * - Contract must be on the main network\n     * - Staking must have started\n     * - Staking must not have ended\n     * - Claim must have started\n     * - User withdraw amount cannot be zero\n     * - User claim lock time should have expired\n     * - User must not be blacklisted\n     *\n     * Effects:\n     * - Pool staker's information is deleted\n     * - Total tokens staked by the network is updated\n     * - Withdraw tokens are transferred back to the user\n     *\n     * Emits a Withdraw event with the user's address and the amount of the withdraw\n     */\n    function withdraw() external nonReentrant whenNotPaused {\n        require(isMainNetwork, \"This is not the main network\");\n        require(block.timestamp >= stakeStartTime, \"Staking hasn't started\");\n        require(block.timestamp >= claimStartTime, \"Claim is not available\");\n\n        PoolStaker memory staker = poolStakers[msg.sender];\n        require(\n            staker.stakerStakedTime + (claimLockDays * DAY_SECONDS) <= block.timestamp && claimStartTime + (claimLockDays * DAY_SECONDS) <= block.timestamp,\n            \"You are not allowed to withdraw before locked time\"\n        );\n        require(staker.stakerAmount > 0, \"Amount staked can't be zero\");\n        require(saleToken.balanceOf(address(this)) >= staker.stakerAmount, \"Balance not enough\");\n\n        updatePoolRewards();\n\n        // Pay rewards\n        uint256 _rewardsToHarvest = harvestRewards(msg.sender, true);\n\n        // Delete staker\n        delete poolStakers[msg.sender];\n\n        // Update pool\n        tokensStakedByNetwork -= staker.stakerAmount;\n        tokensStakedTotal -= staker.stakerAmount;\n\n        // If there are rewards to harvest send it to the user\n        if (_rewardsToHarvest > 0) {\n            emit HarvestRewards(msg.sender, _rewardsToHarvest);\n            saleToken.safeTransfer(msg.sender, _rewardsToHarvest);\n        }\n\n        // Withdraw tokens\n        emit Withdraw(msg.sender, staker.stakerAmount);\n        saleToken.safeTransfer(msg.sender, staker.stakerAmount);\n    }\n\n    /**\n     * @dev Harvests the rewards for the user\n     *\n     * This function allows the user to harvest their accumulated rewards from staking in the pool.\n     * It calculates the rewards that the user has earned since the last update,\n     * records the amount as harvested rewards, updates the user's rewards debt, and optionally transfers the rewards to the user.\n     *\n     * Requirements:\n     * - Contract must be on the main network\n     * - Staking must have started\n     * - Staking must not have ended\n     * - Claim must have started\n     * - User staked amount cannot be zero\n     * - User claim lock time should have expired\n     * - User must not be blacklisted\n     *\n     * Effects:\n     * - Calculates and transfers the user's rewards\n     * - Updates the user's harvested rewards, rewards debt, and locked rewards\n     *\n     * Emits a HarvestRewards event with the user's address and the amount of rewards harvested\n     */\n    function harvestRewards() external nonReentrant whenNotPaused {\n        require(isMainNetwork, \"This is not the main network\");\n        require(block.timestamp >= stakeStartTime, \"Staking hasn't started\");\n        require(block.timestamp >= claimStartTime, \"Claim is not available\");\n\n        PoolStaker memory staker = poolStakers[msg.sender];\n        require(\n            staker.stakerStakedTime + (claimLockDays * DAY_SECONDS) <= block.timestamp && claimStartTime + (claimLockDays * DAY_SECONDS) <= block.timestamp,\n            \"You are not allowed to harvest before locked time\"\n        );\n        require(staker.stakerAmount > 0, \"Amount staked can't be zero\");\n\n        updatePoolRewards();\n\n        uint256 _rewardsToHarvest = harvestRewards(msg.sender, true);\n\n        // If there are rewards to harvest send it to the user\n        if (_rewardsToHarvest > 0) {\n            emit HarvestRewards(msg.sender, _rewardsToHarvest);\n            saleToken.safeTransfer(msg.sender, _rewardsToHarvest);\n        }\n    }\n\n    function harvestRewards(address pUserAddress, bool pHarvestNow) private returns (uint256) {\n        PoolStaker storage staker = poolStakers[pUserAddress];\n        require(!staker.stakerIsBlacklisted, \"This address is blacklisted\");\n\n        uint256 _rewardsDebtUpdate = (staker.stakerAmount * poolAccumulatedRewardsPerShare) / REWARDS_PRECISION;\n        uint256 _rewardsToHarvest = _rewardsDebtUpdate - staker.stakerRewardsDebt;\n\n        if (_rewardsToHarvest > 0) {\n            staker.stakerRewardsHarvested += _rewardsToHarvest;\n            staker.stakerRewardsDebt = _rewardsDebtUpdate;\n\n            // If claim is available and harvest now flag is true\n            if (block.timestamp >= claimStartTime && pHarvestNow) {\n                if (staker.stakerRewardsLocked > 0) {\n                    _rewardsToHarvest += staker.stakerRewardsLocked;\n                    staker.stakerRewardsLocked = 0;\n                }\n\n                // Return the value of the rewards to harvest that will be sent to the user\n                return _rewardsToHarvest;\n\n                // Sum the rewards\n            } else {\n                staker.stakerRewardsLocked += _rewardsToHarvest;\n            }\n        }\n\n        return 0;\n    }\n\n    /**\n     * @dev Checks if the tokensStakedTotalLastUpdateTime has expired\n     *\n     * This function checks if the difference between the current block timestamp and the tokensStakedTotalLastUpdateTime\n     * is greater than or equal to one day, indicating that the tokensStakedTotalLastUpdateTime has expired.\n     *\n     * @return A boolean value indicating whether the tokensStakedTotalLastUpdateTime has expired (true) or not (false)\n     */\n    function isTokensStakedTotalLastUpdateTimeExpired() private view returns (bool) {\n        if (block.timestamp >= claimStartTime) return false; // If the claim is active\n        if (tokensStakedTotalLastUpdateTime > block.timestamp) return false;\n        return (block.timestamp - tokensStakedTotalLastUpdateTime) >= DAY_SECONDS;\n    }\n\n    /**\n     * @dev Calculates the number of days that have passed since the last reward was processed in the pool.\n     *\n     * This function determines the number of days that have elapsed between the current timestamp and the\n     * timestamp when the last reward was processed in the pool. If the tokensStakedTotalLastUpdateTime has expired,\n     * the number of days passed is calculated up to the current block timestamp. Otherwise, it returns 0.\n     *\n     * @param pTimestamp The timestamp for which the number of days passed since the last reward is being calculated\n     *\n     * @return The number of days that have passed since the last reward was processed in the pool\n     */\n    function calcDaysPassedSinceLastReward(uint256 pTimestamp) private view returns (uint256) {\n        if (isTokensStakedTotalLastUpdateTimeExpired()) return 0;\n        if (poolLastDayReward > pTimestamp) return 0;\n        return (pTimestamp - poolLastDayReward) / DAY_SECONDS;\n    }\n\n    /**\n     * @dev Updates the pool rewards based on the current timestamp and the tokens staked in the pool\n     *\n     * If the tokensStakedTotal is zero, the function increments the poolLastDayReward by the number of days passed\n     * since the last reward was processed.\n     *\n     * If tokensStakedTotalLastUpdateTime is not expired updates the poolAccumulatedRewardsPerShare by incrementing\n     * the total of rewards that was generated until this moment in the pool based on the total of coins staked and\n     * updates the poolLastDayReward checking if the stakeEndTime or adding the number of days that passed.\n     *\n     * Effects:\n     * - Updates the pool accumulated rewards per share\n     * - Updates the last day the pool had their rewards calculated\n     *\n     */\n    function updatePoolRewards() private {\n        if (tokensStakedTotal == 0) {\n            poolLastDayReward += (calcDaysPassedSinceLastReward(block.timestamp) * DAY_SECONDS); // Increment with the days passed that didnt generate any reward\n            return;\n        }\n\n        if (!isTokensStakedTotalLastUpdateTimeExpired()) {\n            poolAccumulatedRewardsPerShare += getPoolAccumulatedRewardsPerShare(); // This increments the total of rewards that was generated until this moment in the pool based on the total of coins staked\n            poolLastDayReward = block.timestamp > stakeEndTime ? stakeEndTime : poolLastDayReward + (calcDaysPassedSinceLastReward(block.timestamp) * DAY_SECONDS); // Update last day a reward was generated\n        }\n    }\n\n    /**\n     * @dev Calculates the rewards accumulated in the pool since the last update\n     * by multiplying the number of blocks since the last update with the rewards tokens per block\n     *\n     * The REWARDS_PRECISION is needed to generate more precision on smaller numbers\n     *\n     * @return The accumulated rewards in the pool since the last update\n     */\n    function getPoolAccumulatedRewardsPerShare() private view returns (uint256) {\n        uint256 _poolDaysSinceLastUpdate = block.timestamp > stakeEndTime ? calcDaysPassedSinceLastReward(stakeEndTime) : calcDaysPassedSinceLastReward(block.timestamp);\n        uint256 _poolRewardsSinceLastUpdate = _poolDaysSinceLastUpdate * stakeRewardsTokensPerDay;\n        return (_poolRewardsSinceLastUpdate * REWARDS_PRECISION) / tokensStakedTotal;\n    }\n\n    /**\n     * @dev Calculates the rewards available for the user based on the amount staked,\n     * accumulated rewards in the pool, and rewards debt.\n     *\n     * This function calculates the rewards available for the user by multiplying the\n     * amount staked by the accumulated rewards per share, adjusting for the rewards debt\n     * that the user already claimed. It also considers any rewards that are currently locked\n     * and not available for withdraw.\n     *\n     * @param pUserAddress The address of the user for whom rewards are being calculated\n     *\n     * @return The total amount of rewards available for the user\n     */\n    function getRewards(address pUserAddress) external view returns (uint256) {\n        if (tokensStakedTotal == 0) {\n            return 0;\n        }\n\n        uint256 _accCalc = poolAccumulatedRewardsPerShare + getPoolAccumulatedRewardsPerShare();\n        PoolStaker memory staker = poolStakers[pUserAddress];\n        return ((staker.stakerAmount * _accCalc) / REWARDS_PRECISION) - staker.stakerRewardsDebt + staker.stakerRewardsLocked;\n    }\n\n    /**\n     * @dev Get current total tokens staked details\n     // Array of details \n     [0] -> TOTAL_TOKENS_STAKED_BY_PRESALE, \n     [1] -> TOTAL_TOKENS_STAKED_BY_NETWORK, \n     [2] -> TOTAL_TOKENS_STAKED_TOTAL, \n     [3] -> TOTAL_TOKENS_STAKED_TOTAL_LAST_UPDATE_TIME), \n     [4] -> CLAIM_START_TIME, \n     [5] -> STAKERS_LENGTH,\n     [6] -> IS_IMPORT_DONE\n     */\n    function getTokensStakedDetails() external view returns (uint256[7] memory) {\n        return [tokensStakedByPresale, tokensStakedByNetwork, tokensStakedTotal, tokensStakedTotalLastUpdateTime, claimStartTime, addressStakersPresale.length, isImportDone ? 1 : 0];\n    }\n\n    /**\n     * @dev Set is main network on/off\n     */\n    function setIsMainNetwork(bool pIsMainNetwork) external onlyOwner {\n        isMainNetwork = pIsMainNetwork;\n    }\n\n    /**\n     * @dev Set sale token address\n     */\n    function setSaleToken(address pSaleToken) external onlyOwner {\n        require((isMainNetwork && pSaleToken != address(0)) || !isMainNetwork, \"Invalid address\");\n        saleToken = IERC20(pSaleToken);\n    }\n\n    /**\n     * @dev Set sale token total minted\n     */\n    function setSaleTokenTotalMinted(uint256 pSaleTokenTotalMinted) external onlyOwner {\n        saleTokenTotalMinted = pSaleTokenTotalMinted;\n    }\n\n    /**\n     * @dev Set presale contract address\n     */\n    function setPresaleContract(address pPresaleContract) external onlyOwner {\n        require(pPresaleContract != address(0), \"Invalid address\");\n        presaleContract = pPresaleContract;\n        emit PresaleContractUpdated(pPresaleContract);\n    }\n\n    /**\n     * @dev Set admin address\n     */\n    function setAdmin(address pAdmin) external onlyOwner {\n        require(pAdmin != address(0), \"Invalid address\");\n        admin = pAdmin;\n        emit AdminUpdated(pAdmin);\n    }\n\n    /**\n     * @dev Set claim start time\n     */\n    function setClaimStartTime(uint256 pClaimStartTime) external onlyOwner {\n        claimStartTime = pClaimStartTime;\n        emit ClaimStartTimeUpdated(pClaimStartTime);\n    }\n\n    /**\n     * @dev Set claim lock days\n     */\n    function setClaimLockDays(uint256 pClaimLockDays) external onlyOwner {\n        claimLockDays = pClaimLockDays;\n    }\n\n    /**\n     * @dev Set stake start time\n     */\n    function setStakeStartTime(uint256 pStakeStartTime) external onlyOwner {\n        stakeStartTime = pStakeStartTime;\n    }\n\n    /**\n     * @dev Set stake end time\n     */\n    function setStakeEndTime(uint256 pStakeEndTime) external onlyOwner {\n        stakeEndTime = pStakeEndTime;\n        emit StakeEndTimeUpdated(pStakeEndTime);\n    }\n\n    /**\n     * @dev Set stake rewards tokens per day\n     */\n    function setStakeRewardsTokensPerDay(uint256 pStakeRewardsTokensPerDay) external onlyOwner {\n        stakeRewardsTokensPerDay = pStakeRewardsTokensPerDay;\n        emit StakeRewardsTokensPerDayUpdated(pStakeRewardsTokensPerDay);\n    }\n\n    /**\n     * @dev Set tokens staked total\n     */\n    function setTokensStakedTotal(uint256 pAmount, uint256 pUpdateTime) external onlyOwnerOrAdmin {\n        require(pUpdateTime >= tokensStakedTotalLastUpdateTime && pUpdateTime > stakeStartTime && pUpdateTime < stakeEndTime && pUpdateTime < claimStartTime, \"Update time is invalid\");\n        require(pAmount <= saleTokenTotalMinted && pAmount >= tokensStakedTotal, \"Invalid amount\");\n        uint256 tokensStakedTotalDiff = pAmount - tokensStakedTotal;\n        tokensStakedTotal = pAmount;\n        tokensStakedTotalLastUpdateTime = pUpdateTime; // Need to use a fixed time for everyday control.\n        updatePoolRewards(); // Sincronize all networks pool rewards\n        emit TokensStakedTotalUpdated(pAmount, pUpdateTime);\n        if (isMainNetwork && tokensStakedTotalDiff > 0) {\n            require(saleToken.balanceOf(presaleContract) >= tokensStakedTotalDiff, \"Balance not enough\");\n            saleToken.safeTransferFrom(presaleContract, address(this), tokensStakedTotalDiff);\n        }\n    }\n\n    /**\n     * @dev Set tokens staked total\n     */\n    function setTokensStakedTotal(uint256 pAmount) external onlyOwner {\n        tokensStakedTotal = pAmount;\n        emit TokensStakedTotalUpdated(pAmount);\n    }\n\n    /**\n     * @dev Set tokens staked total last update time\n     */\n    function setTokensStakedTotalLastUpdateTime(uint256 pUpdateTime) external onlyOwner {\n        tokensStakedTotalLastUpdateTime = pUpdateTime;\n        emit TokensStakedTotalLastUpdateTimeUpdated(pUpdateTime);\n    }\n\n    /**\n     * @dev Set pool last day reward\n     */\n    function setPoolLastDayReward(uint256 pPoolLastDayReward) external onlyOwner {\n        poolLastDayReward = pPoolLastDayReward;\n        emit PoolLastDayRewardUpdated(pPoolLastDayReward);\n    }\n\n    /**\n     * @dev Set pool accumulated rewards per share\n     */\n    function setPoolAccumulatedRewardsPerShare(uint256 pPoolAccumulatedRewardsPerShare) external onlyOwner {\n        poolAccumulatedRewardsPerShare = pPoolAccumulatedRewardsPerShare;\n        emit PoolAccumulatedRewardsPerShareUpdated(pPoolAccumulatedRewardsPerShare);\n    }\n\n    /**\n     * @dev Pause the presale\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @dev Unpause the presale\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @dev Adds the specified users to the blacklist\n     *\n     * This function allows the contract owner to add the specified users to the blacklist, preventing them from participating in staking and claiming rewards.\n     * Any user added to the blacklist will not be able to deposit, withdraw, or harvest rewards.\n     *\n     * @param pUsersList An array of addresses representing the users to be added to the blacklist\n     *\n     * Requirements:\n     * - The function can only be called by the contract owner\n     *\n     * Effects:\n     * - Updates the isBlacklisted flag for the specified users to true\n     *\n     */\n    function usersBlacklistAdd(address[] calldata pUsersList) external onlyOwner {\n        uint256 size = pUsersList.length;\n        for (uint256 i = 0; i < size; i++) {\n            PoolStaker storage staker = poolStakers[pUsersList[i]];\n            staker.stakerIsBlacklisted = true;\n        }\n    }\n\n    /**\n     * @dev Removes the specified users from the blacklist\n     *\n     * This function allows the contract owner to remove the specified users from the blacklist, enabling them to participate in staking and claiming rewards again.\n     * Any user removed from the blacklist will regain the ability to deposit, withdraw, and harvest rewards.\n     *\n     * @param pUsersList An array of addresses representing the users to be removed from the blacklist\n     *\n     * Requirements:\n     * - The function can only be called by the contract owner\n     *\n     * Effects:\n     * - Updates the isBlacklisted flag for the specified users to false\n     */\n    function usersBlacklistRemove(address[] calldata pUsersList) external onlyOwner {\n        uint256 size = pUsersList.length;\n        for (uint256 i = 0; i < size; i++) {\n            PoolStaker storage staker = poolStakers[pUsersList[i]];\n            staker.stakerIsBlacklisted = false;\n        }\n    }\n\n    /**\n     * @dev This function allows the contract owner or admin to retrieve the address of a staker from the list of stakers that joined during the presale\n     *\n     * @param pIndex The index of the staker's address in the array\n     *\n     * Requirements:\n     * - Only the contract owner or admin can call this function\n     *\n     * @return The address of the staker at the specified index\n     *\n     */\n    function getAddressStakersPresale(uint256 pIndex) external view returns (address) {\n        return addressStakersPresale[pIndex];\n    }\n\n    /**\n     * @dev Set imported value for a given address\n     *\n     * @param pAddresses address\n     * @param pValues flag to indicate if address was imported or not\n     */\n    function setImported(address[] calldata pAddresses, bool[] calldata pValues) external onlyOwner {\n        require(pAddresses.length == pValues.length, \"Parameters length mismatch\");\n\n        uint256 size = pAddresses.length;\n        for (uint256 i = 0; i < size; i++) {\n            imported[pAddresses[i]] = pValues[i];\n        }\n    }\n\n    /**\n     * @dev Set is import done\n     */\n    function setIsImportDone(bool pIsImportDone) external onlyOwner {\n        isImportDone = pIsImportDone;\n    }\n\n    /**\n     * @dev Imports the staking data for multiple stakers into the pool\n     *\n     * This function allows the contract owner to import staking data for multiple stakers into the pool.\n     * The function takes two arrays as inputs - one containing the addresses of the stakers and the\n     * other containing the staking data for each staker. It then updates the staking information for\n     * each staker in the pool based on the provided data.\n     *\n     * @param pStakersAddress An array of addresses representing the stakers for whom staking data is being imported\n     * @param pAmount An array of PoolStaker structs containing the staking data for each respective staker\n     * @param pStakedTime An array of PoolStaker structs containing the staking data for each respective staker\n     * @param pRewardsHarvested An array of PoolStaker structs containing the staking data for each respective staker\n     * @param pRewardsDebt An array of PoolStaker structs containing the staking data for each respective staker\n     * @param pRewardsLocked An array of PoolStaker structs containing the staking data for each respective staker\n     *\n     * Requirements:\n     * - The length of all arrays must be equal\n     * - The function can only be called by the contract owner\n     *\n     * Effects:\n     * - Updates the staking information for each staker in the pool based on the provided data\n     */\n    function poolStakersImport(\n        address[] calldata pStakersAddress,\n        uint256[] calldata pAmount,\n        uint256[] calldata pStakedTime,\n        uint256[] calldata pRewardsHarvested,\n        uint256[] calldata pRewardsDebt,\n        uint256[] calldata pRewardsLocked\n    ) external onlyOwner {\n        require(isMainNetwork, \"This is not the main network\");\n        require(\n            pStakersAddress.length == pAmount.length &&\n                pStakersAddress.length == pStakedTime.length &&\n                pStakersAddress.length == pRewardsHarvested.length &&\n                pStakersAddress.length == pRewardsDebt.length &&\n                pStakersAddress.length == pRewardsLocked.length,\n            \"Length mismatch\"\n        );\n\n        uint256 size = pStakersAddress.length;\n        for (uint256 i = 0; i < size; i++) {\n            require(!imported[pStakersAddress[i]], \"Staker already imported\");\n\n            PoolStaker storage staker = poolStakers[pStakersAddress[i]];\n            staker.stakerAmount += pAmount[i];\n            if (pStakedTime[i] > staker.stakerStakedTime) staker.stakerStakedTime = pStakedTime[i];\n            staker.stakerRewardsHarvested += pRewardsHarvested[i];\n            staker.stakerRewardsDebt += pRewardsDebt[i];\n            staker.stakerRewardsLocked += pRewardsLocked[i];\n            imported[pStakersAddress[i]] = true;\n\n            tokensStakedByNetwork += pAmount[i];\n        }\n\n        isImportDone = true;\n    }\n}\n"}, "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.30;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"}, "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"}, "lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"}, "lib/openzeppelin-contracts/contracts/utils/Pausable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.30;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"}, "lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"}, "lib/openzeppelin-contracts/contracts/utils/Context.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"}, "lib/openzeppelin-contracts/contracts/interfaces/IERC1363.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"}, "lib/openzeppelin-contracts/contracts/utils/Address.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Address.sol)\n\npragma solidity ^0.8.30;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert Errors.FailedCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"}, "lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"}, "lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.30;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"}, "lib/openzeppelin-contracts/contracts/utils/Errors.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"}, "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"}}, "settings": {"remappings": ["forge-std/=lib/forge-std/src/", "@openzeppelin/=lib/openzeppelin-contracts/", "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/", "ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/", "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/", "halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/", "openzeppelin-contracts/=lib/openzeppelin-contracts/"], "optimizer": {"enabled": false, "runs": 200}, "metadata": {"appendCBOR": false}, "outputSelection": {"*": {"*": ["abi", "metadata", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers", "evm.legacyAssembly", "evm.bytecode.opcodes"]}}, "evmVersion": "paris", "viaIR": true, "libraries": {}}}