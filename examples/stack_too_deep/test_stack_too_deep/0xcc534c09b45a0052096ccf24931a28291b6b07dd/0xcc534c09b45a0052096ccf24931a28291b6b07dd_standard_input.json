{"language": "Solidity", "sources": {"contracts/AssetsStore.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./libraries/TokenActions.sol\";\nimport \"./libraries/Errors.sol\";\nimport \"./interfaces/IProtocolDirectory.sol\";\nimport \"./interfaces/IMember.sol\";\nimport \"./interfaces/IMembership.sol\";\nimport \"./interfaces/IAssetStore.sol\";\nimport \"./interfaces/IAssetStoreFactory.sol\";\nimport \"./structs/MemberStruct.sol\";\nimport \"./structs/TokenStruct.sol\";\nimport \"./structs/ApprovalsStruct.sol\";\n\n//\n\n/**\n * @title AssetsStore\n * @notice This contract is deployed by the AssetsStoreFactory.sol\n * and is the contract that holds the approvals for a user's directives\n *\n * @dev The ownership of this contract is held by the deployer factory\n *\n */\n\ncontract AssetsStore is IAssetStore, Ownable, ReentrancyGuard {\n    // Returns token Approvals for specific UID\n    mapping(string => Approvals[]) private MemberApprovals;\n\n    // Mapping Beneficiaries to a specific Approval for Claiming\n    mapping(address => Approvals[]) private BeneficiaryClaimableAsset;\n\n    // Storing ApprovalId for different approvals stored\n    uint256 private _approvalsId;\n\n    // address for the protocol directory contract\n    address private directoryContract;\n\n    address private IMembershipAddress;\n\n    /**\n     * @notice Event used for querying approvals stored\n     * by this contract\n     *\n     * @param uid string of the central identifier within the dApp\n     * @param approvedWallet address for original holder of the asset\n     * @param beneficiaryName string associated with beneficiaryAddress wallet\n     * @param beneficiaryAddress address for the wallet receiving the assets\n     * @param tokenId uint256 of the ID of the token being transferred\n     * @param tokenAddress address for the contract of the asset\n     * @param tokenType string representing what ERC the token is\n     * @param tokensAllocated uint256 representing the % allocation of an asset\n     * @param dateApproved uint256 for the block number when the approval is acted on\n     * @param claimed bool for showing if the approval has been claimed by a beneficiary\n     * @param active bool for if the claiming period is currently active\n     * @param approvalId uint256 representing which approval the event is tied to\n     * @param claimExpiryTime uint256 of a block number when claiming can no longer happen\n     * @param approvedTokenAmount uint256 representing the magnitude of tokens to be transferred\n     * at the time of claiming.\n     *\n     */\n    event ApprovalsEvent(\n        string uid,\n        address approvedWallet,\n        string beneficiaryName,\n        address beneficiaryAddress,\n        uint256 tokenId,\n        address tokenAddress,\n        string tokenType,\n        uint256 tokensAllocated,\n        uint256 dateApproved,\n        bool claimed,\n        bool active,\n        uint256 approvalId,\n        uint256 claimExpiryTime,\n        uint256 approvedTokenAmount\n    );\n\n    /**\n     * @dev Modifier to ensure that the user exists within the ecosystem\n     * @param uid string of the central identifier used for this user within the dApp\n     *\n     */\n    modifier checkIfMember(string memory uid) {\n        address IMemberAddress = IProtocolDirectory(directoryContract)\n            .getMemberContract();\n        if (bytes(IMember(IMemberAddress).getMember(uid).uid).length == 0) {\n            revert(Errors.AS_USER_DNE);\n        }\n        _;\n    }\n\n    /**\n     * @dev Modifier checking that only the RelayerContract can invoke certain functions\n     *\n     */\n    modifier onlyRelayerContract() {\n        address relayerAddress = IProtocolDirectory(directoryContract)\n            .getRelayerContract();\n        if (msg.sender != relayerAddress) {\n            revert(Errors.AS_ONLY_RELAY);\n        }\n        _;\n    }\n\n    /**\n     * @dev Modifier to ensure a function can only be invoked by\n     * the ChainlinkOperationsContract\n     */\n    modifier onlyChainlinkOperationsContract() {\n        address linkOpsAddress = IProtocolDirectory(directoryContract)\n            .getChainlinkOperationsContract();\n        if (msg.sender != linkOpsAddress) {\n            revert(Errors.AS_ONLY_CHAINLINK_OPS);\n        }\n        _;\n    }\n\n    /**\n     * @dev initialize - Initializes the function for Ownable and Reentrancy.\n     * @param _directoryContract address of the ProtocolDirectory Contract\n     * @param _membershipAddress address of the Contract deployed for this\n     * user's membership\n     */\n    constructor(address _directoryContract, address _membershipAddress) {\n        directoryContract = _directoryContract;\n        IMembershipAddress = _membershipAddress;\n        _approvalsId = 0;\n    }\n\n    /**\n     * @notice Function to store All Types of Approvals and Backups by the user in one function\n     * @dev storeAssetsAndBackUpApprovals calls\n     *  storeBackupAssetsApprovals & storeAssetsApprovals\n     * \n     * sent to storeAssetsApprovals:\n     * @param _contractAddress address[] Ordered list of contracts for different assets\n     * @param _beneficiaries address[] Ordered list of addresses associated with addresses/wallets assets will be claimed by\n     * @param _beneficiaryNames string[] Ordered list of names associated with the _beneficiaries\n     * @param _beneficiaryIsCharity bool[] Ordered list of booleans representing if the beneficiary is charity, an EOA not able to claim assets independently\n     * @param _tokenTypes string[] Ordered list of strings for the token types (i.e. ERC20, ERC1155, ERC721)\n     * @param _tokenIds uint256[] Ordered list of tokenIds for the listed contractAddresses\n     * @param _tokenAmount uint256[] Ordered list of numbers represnting the %'s of assets to go to a beneficiary\n     \n     * sent to storeBackupAssetsApprovals:\n     * @param _backUpTokenIds uint256[] Ordered list of tokenIds to be in a backup plan\n     * @param _backupTokenAmount uint256[] Ordered list representing a magnitube of tokens to be in a backupPlan\n     * @param _backUpWallets address[] Ordered list of destination wallets for the backupPlan\n     * @param _backUpAddresses address[] Ordered list of contract addresses of assets for the backupPlan\n     * @param _backupTokenTypes string[] Ordered list of strings for the token types (i.e. ERC20, ERC1155, ERC721)\n     * @param uid string of the dApp identifier for the user\n     * \n     * \n     */\n    function storeAssetsAndBackUpApprovals(\n        address[] memory _contractAddress,\n        address[] memory _beneficiaries,\n        string[] memory _beneficiaryNames,\n        bool[] memory _beneficiaryIsCharity,\n        string[] memory _tokenTypes,\n        uint256[] memory _tokenIds,\n        uint256[] memory _tokenAmount,\n        uint256[] memory _backUpTokenIds,\n        uint256[] memory _backupTokenAmount,\n        address[] memory _backUpWallets,\n        address[] memory _backUpAddresses,\n        string[] memory _backupTokenTypes,\n        string memory uid\n    ) external {\n        address IMemberAddress = IProtocolDirectory(directoryContract)\n            .getMemberContract();\n        if ((IMember(IMemberAddress).checkIfUIDExists(msg.sender) == false)) {\n            IMember(IMemberAddress).createMember(uid, msg.sender);\n        }\n        checkUserHasMembership(uid);\n        IMember(IMemberAddress).checkUIDofSender(uid, msg.sender);\n        IMember(IMemberAddress).storeBackupAssetsApprovals(\n            _backUpAddresses,\n            _backUpTokenIds,\n            _backUpWallets,\n            _backupTokenAmount,\n            _backupTokenTypes,\n            uid,\n            msg.sender,\n            true\n        );\n\n        storeAssetsApprovals(\n            _contractAddress,\n            _tokenIds,\n            _beneficiaries,\n            _beneficiaryNames,\n            _beneficiaryIsCharity,\n            _tokenAmount,\n            _tokenTypes,\n            uid\n        );\n    }\n\n    /**\n     * @notice storeAssetsApprovals - Function to store All Types Approvals by the user\n     * @dev All of the arrays passed in need to be IN ORDER\n     * they will be accessed in a loop together\n     * @param _contractAddress address[] Ordered list of contracts for different assets\n     * @param _tokenIds uint256[] Ordered list of tokenIds for the listed contractAddresses\n     * @param _beneficiaries address[] Ordered list of addresses associated with addresses/wallets assets will be claimed by\n     * @param _beneficiaryNames string[] Ordered list of names associated with the _beneficiaries\n     * @param _beneficiaryIsCharity bool[] Ordered list of booleans representing if the beneficiary is charity, an EOA not able to claim assets independently\n     * @param _tokenAmount uint256[] Ordered list of numbers represnting the %'s of assets to go to a beneficiary\n     * @param _tokenTypes string[] Ordered list of strings for the token types (i.e. ERC20, ERC1155, ERC721)\n     * @param _memberUID string of the dApp identifier for the user\n     *\n     */\n    function storeAssetsApprovals(\n        address[] memory _contractAddress,\n        uint256[] memory _tokenIds,\n        address[] memory _beneficiaries,\n        string[] memory _beneficiaryNames,\n        bool[] memory _beneficiaryIsCharity,\n        uint256[] memory _tokenAmount,\n        string[] memory _tokenTypes,\n        string memory _memberUID\n    ) public {\n        if (\n            _tokenIds.length != _contractAddress.length ||\n            _beneficiaryNames.length != _beneficiaries.length ||\n            _tokenIds.length != _beneficiaries.length\n        ) {\n            revert(Errors.AS_DIFF_LENGTHS);\n        }\n\n        address IMemberAddress = IProtocolDirectory(directoryContract)\n            .getMemberContract();\n        if ((IMember(IMemberAddress).checkIfUIDExists(msg.sender) == false)) {\n            IMember(IMemberAddress).createMember(_memberUID, msg.sender);\n        }\n        checkUserHasMembership(_memberUID);\n\n        member memory _member = IMember(IMemberAddress).getMember(_memberUID);\n        if (\n            msg.sender != IMember(IMemberAddress).getPrimaryWallet(_memberUID)\n        ) {\n            revert(Errors.AS_ONLY_PRIMARY_WALLET);\n        }\n\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n            address contractAddress = _contractAddress[i];\n            uint256 tokenId_ = _tokenIds[i];\n            address beneficiary_ = _beneficiaries[i];\n            string memory beneficiaryName_ = _beneficiaryNames[i];\n            string memory tokenType = _tokenTypes[i];\n            bool isCharity = _beneficiaryIsCharity[i];\n            uint256 tokenAmount = _tokenAmount[i];\n\n            TokenActions.checkAssetContract(contractAddress, tokenType);\n            if (tokenAmount > 100 || tokenAmount < 0) {\n                revert(Errors.AS_INVALID_TOKEN_RANGE);\n            }\n            Beneficiary memory beneficiary = Beneficiary(\n                beneficiary_,\n                beneficiaryName_,\n                isCharity\n            );\n            Token memory _token = Token(\n                tokenId_,\n                contractAddress,\n                tokenType,\n                tokenAmount\n            );\n\n            uint256 _dateApproved = block.timestamp;\n            _storeAssets(\n                _memberUID,\n                _member,\n                msg.sender,\n                beneficiary,\n                _token,\n                _dateApproved\n            );\n            emit ApprovalsEvent(\n                _member.uid,\n                msg.sender,\n                beneficiary.beneficiaryName,\n                beneficiary.beneficiaryAddress,\n                _token.tokenId,\n                _token.tokenAddress,\n                _token.tokenType,\n                _token.tokensAllocated,\n                _dateApproved,\n                false,\n                false,\n                _approvalsId,\n                0,\n                0\n            );\n        }\n        IMembership(IMembershipAddress).redeemUpdate(_memberUID);\n    }\n\n    /**\n     * @dev _storeAssets - Internal function to store assets\n     * @param uid string string of the dApp identifier for the user\n     * @param _member member struct storing relevant data for the user\n     * @param user address address of the user\n     * @param _beneificiary Beneficiary struct storing data representing the beneficiary\n     * @param _token Token struct containing information of the asset in the will\n     * @param _dateApproved uint256 block timestamp when this function is called\n     *\n     */\n    function _storeAssets(\n        string memory uid,\n        member memory _member,\n        address user,\n        Beneficiary memory _beneificiary,\n        Token memory _token,\n        uint256 _dateApproved\n    ) internal {\n        Approvals memory approval = Approvals(\n            _member,\n            user,\n            _beneificiary,\n            _token,\n            _dateApproved,\n            false,\n            false,\n            ++_approvalsId,\n            0,\n            0\n        );\n\n        BeneficiaryClaimableAsset[_beneificiary.beneficiaryAddress].push(\n            approval\n        );\n        MemberApprovals[uid].push(approval);\n    }\n\n    /**\n     * @notice getApproval - Function to get a specific token Approval for the user passing in UID and ApprovalID\n     * @dev searches state for a match by uid and approvalId for a given user\n     *\n     * @param uid string of the dApp identifier for the user\n     * @param approvalId number of the individual approval to lookup\n     *\n     * @return approval_ struct storing information for an Approval\n     */\n    function getApproval(string memory uid, uint256 approvalId)\n        external\n        view\n        returns (Approvals memory approval_)\n    {\n        Approvals[] memory _approvals = MemberApprovals[uid];\n        for (uint256 i = 0; i < _approvals.length; i++) {\n            if (_approvals[i].approvalId == approvalId) {\n                approval_ = _approvals[i];\n            }\n        }\n    }\n\n    /**\n     * @notice getBeneficiaryApproval - Function to get a token Approval for the beneficiaries - Admin function\n     * @param _benAddress address to lookup a specific list of approvals for given beneficiary address\n     * @return approval_ a list of approval structs for a specific address\n     */\n    function getBeneficiaryApproval(address _benAddress)\n        external\n        view\n        onlyOwner\n        returns (Approvals[] memory approval_)\n    {\n        approval_ = BeneficiaryClaimableAsset[_benAddress];\n    }\n\n    /**\n     * @notice getApprovals - Function to get all token Approvals for the user\n     * @param uid string of the dApp identifier for the user\n     * @return Approvals[] a list of all the approval structs associated with a user\n     */\n    function getApprovals(string memory uid)\n        external\n        view\n        returns (Approvals[] memory)\n    {\n        return MemberApprovals[uid];\n    }\n\n    /**\n     * @notice setApprovalClaimed - Function to set approval claimed for a specific apprival id\n     * @param uid string of the dApp identifier for the user\n     * @param _id uint256 the id of the approval claimed\n     *\n     * emits an event to indicate state change of an approval as well\n     * as changing the state inside of the MemberApprovals list\n     */\n    function setApprovalClaimed(string memory uid, uint256 _id) internal {\n        Approvals[] storage _approvals = MemberApprovals[uid];\n        for (uint256 i = 0; i < _approvals.length; i++) {\n            if (_approvals[i].approvalId == _id) {\n                _approvals[i].claimed = true;\n                _approvals[i].active = false;\n                emit ApprovalsEvent(\n                    _approvals[i].Member.uid,\n                    _approvals[i].approvedWallet,\n                    _approvals[i].beneficiary.beneficiaryName,\n                    _approvals[i].beneficiary.beneficiaryAddress,\n                    // _approvals[i].beneficiary.isCharity,\n                    _approvals[i].token.tokenId,\n                    _approvals[i].token.tokenAddress,\n                    _approvals[i].token.tokenType,\n                    _approvals[i].token.tokensAllocated,\n                    _approvals[i].dateApproved,\n                    _approvals[i].claimed,\n                    _approvals[i].active,\n                    _approvals[i].approvalId,\n                    _approvals[i].claimExpiryTime,\n                    _approvals[i].approvedTokenAmount\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev setBenApprovalClaimed - Function to set approval claimed for a specific apprival id for ben\n     * @param _user address of the dApp identifier for the user\n     * @param _id uint256 the id of the approval claimed\n     *\n     * emits an event to indicate state change of an approval as well\n     * as changing the state inside of the BeneficiaryClaimableAsset list\n     */\n    function setBenApprovalClaimed(address _user, uint256 _id) internal {\n        Approvals[] storage _approvals = BeneficiaryClaimableAsset[_user];\n        for (uint256 i = 0; i < _approvals.length; i++) {\n            if (_approvals[i].approvalId == _id) {\n                _approvals[i].claimed = true;\n                _approvals[i].active = false;\n                emit ApprovalsEvent(\n                    _approvals[i].Member.uid,\n                    _approvals[i].approvedWallet,\n                    _approvals[i].beneficiary.beneficiaryName,\n                    _approvals[i].beneficiary.beneficiaryAddress,\n                    // _approvals[i].beneficiary.isCharity,\n                    _approvals[i].token.tokenId,\n                    _approvals[i].token.tokenAddress,\n                    _approvals[i].token.tokenType,\n                    _approvals[i].token.tokensAllocated,\n                    _approvals[i].dateApproved,\n                    _approvals[i].claimed,\n                    _approvals[i].active,\n                    _approvals[i].approvalId,\n                    _approvals[i].claimExpiryTime,\n                    _approvals[i].approvedTokenAmount\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice transferUnclaimedAsset - Function to claim Unclaimed Assets passed the claimable expiry time\n     * @param uid string of the dApp identifier for the user\n     */\n    function transferUnclaimedAssets(string memory uid)\n        external\n        onlyRelayerContract\n        nonReentrant\n    {\n        address TransferPool = IProtocolDirectory(directoryContract)\n            .getTransferPool();\n        Approvals[] storage _approval = MemberApprovals[uid];\n        for (uint256 i = 0; i < _approval.length; i++) {\n            if (\n                block.timestamp >= _approval[i].claimExpiryTime &&\n                _approval[i].active == true &&\n                _approval[i].claimed == false\n            ) {\n                if (\n                    keccak256(\n                        abi.encodePacked((_approval[i].token.tokenType))\n                    ) == keccak256(abi.encodePacked((\"ERC20\")))\n                ) {\n                    IERC20 ERC20 = IERC20(_approval[i].token.tokenAddress);\n\n                    // Percentage approach for storing erc20\n                    uint256 _tokenAmount = (_approval[i].token.tokensAllocated *\n                        ERC20.balanceOf(_approval[i].approvedWallet)) / 100;\n\n                    setApprovalClaimed(uid, _approval[i].approvalId);\n                    setBenApprovalClaimed(\n                        _approval[i].beneficiary.beneficiaryAddress,\n                        _approval[i].approvalId\n                    );\n                    bool sent = ERC20.transferFrom(\n                        _approval[i].approvedWallet,\n                        TransferPool,\n                        _tokenAmount\n                    );\n                }\n\n                // transfer erc721\n                if (\n                    keccak256(\n                        abi.encodePacked((_approval[i].token.tokenType))\n                    ) == keccak256(abi.encodePacked((\"ERC721\")))\n                ) {\n                    IERC721 ERC721 = IERC721(_approval[i].token.tokenAddress);\n\n                    setApprovalClaimed(uid, _approval[i].approvalId);\n                    setBenApprovalClaimed(\n                        _approval[i].beneficiary.beneficiaryAddress,\n                        _approval[i].approvalId\n                    );\n                    ERC721.safeTransferFrom(\n                        _approval[i].approvedWallet,\n                        TransferPool,\n                        _approval[i].token.tokenId\n                    );\n                }\n\n                // transfer erc1155\n                if (\n                    keccak256(\n                        abi.encodePacked((_approval[i].token.tokenType))\n                    ) == keccak256(abi.encodePacked((\"ERC1155\")))\n                ) {\n                    IERC1155 ERC1155 = IERC1155(\n                        _approval[i].token.tokenAddress\n                    );\n                    uint256 _tokenAmount = (_approval[i].token.tokensAllocated *\n                        ERC1155.balanceOf(\n                            _approval[i].approvedWallet,\n                            _approval[i].token.tokenId\n                        )) / 100;\n\n                    bytes memory data;\n                    setApprovalClaimed(uid, _approval[i].approvalId);\n                    setBenApprovalClaimed(\n                        _approval[i].beneficiary.beneficiaryAddress,\n                        _approval[i].approvalId\n                    );\n                    ERC1155.safeTransferFrom(\n                        _approval[i].approvedWallet,\n                        TransferPool,\n                        _approval[i].token.tokenId,\n                        _tokenAmount,\n                        data\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev claimAsset - Function to claim Asset from a specific UID\n     * @param uid string of the dApp identifier for the user\n     * @param approvalId_ uint256 id of the specific approval being claimed\n     * @param benUID string of the dApp identifier for the beneficiary claiming the asset\n     *\n     */\n    function claimAsset(\n        string memory uid,\n        uint256 approvalId_,\n        string memory benUID\n    ) external nonReentrant {\n        address IMemberAddress = IProtocolDirectory(directoryContract)\n            .getMemberContract();\n        if ((IMember(IMemberAddress).checkIfUIDExists(msg.sender) == false)) {\n            IMember(IMemberAddress).createMember(benUID, msg.sender);\n        }\n        Approvals[] storage _approval = BeneficiaryClaimableAsset[msg.sender];\n        for (uint256 i = 0; i < _approval.length; i++) {\n            if (\n                keccak256(abi.encodePacked((_approval[i].Member.uid))) ==\n                keccak256(abi.encodePacked((uid)))\n            ) {\n                if (_approval[i].beneficiary.beneficiaryAddress != msg.sender) {\n                    revert(Errors.AS_ONLY_BENEFICIARY);\n                }\n                if (\n                    _approval[i].active == true && _approval[i].claimed == false\n                ) {\n                    if (_approval[i].approvalId == approvalId_) {\n                        // transfer erc20\n                        if (\n                            keccak256(\n                                abi.encodePacked((_approval[i].token.tokenType))\n                            ) == keccak256(abi.encodePacked((\"ERC20\")))\n                        ) {\n                            setApprovalClaimed(uid, _approval[i].approvalId);\n                            TokenActions.sendERC20(_approval[i]);\n                        }\n\n                        // transfer erc721\n                        if (\n                            keccak256(\n                                abi.encodePacked((_approval[i].token.tokenType))\n                            ) == keccak256(abi.encodePacked((\"ERC721\")))\n                        ) {\n                            IERC721 ERC721 = IERC721(\n                                _approval[i].token.tokenAddress\n                            );\n                            _approval[i].claimed = true;\n                            setApprovalClaimed(uid, _approval[i].approvalId);\n\n                            ERC721.safeTransferFrom(\n                                _approval[i].approvedWallet,\n                                _approval[i].beneficiary.beneficiaryAddress,\n                                _approval[i].token.tokenId\n                            );\n                        }\n\n                        // transfer erc1155\n                        if (\n                            keccak256(\n                                abi.encodePacked((_approval[i].token.tokenType))\n                            ) == keccak256(abi.encodePacked((\"ERC1155\")))\n                        ) {\n                            IERC1155 ERC1155 = IERC1155(\n                                _approval[i].token.tokenAddress\n                            );\n                            uint256 _tokenAmount = (\n                                _approval[i].approvedTokenAmount\n                            );\n\n                            bytes memory data;\n                            _approval[i].claimed = true;\n                            setApprovalClaimed(uid, _approval[i].approvalId);\n\n                            ERC1155.safeTransferFrom(\n                                _approval[i].approvedWallet,\n                                _approval[i].beneficiary.beneficiaryAddress,\n                                _approval[i].token.tokenId,\n                                _tokenAmount,\n                                data\n                            );\n                        }\n\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev sendAssetsToCharity\n     * @param _charityBeneficiaryAddress address of the charity beneficiary\n     * @param _uid the uid stored for the user\n     *\n     * Send assets to the charity beneficiary if they exist;\n     *\n     */\n    function sendAssetsToCharity(\n        address _charityBeneficiaryAddress,\n        string memory _uid\n    ) external onlyRelayerContract nonReentrant {\n        // look to see if this address is a charity\n        Approvals[]\n            storage charityBeneficiaryApprovals = BeneficiaryClaimableAsset[\n                _charityBeneficiaryAddress\n            ];\n        if (charityBeneficiaryApprovals.length == 0) {\n            revert(Errors.AS_NO_APPROVALS);\n        }\n        for (uint256 i = 0; i < charityBeneficiaryApprovals.length; i++) {\n            if (!charityBeneficiaryApprovals[i].beneficiary.isCharity) {\n                revert(Errors.AS_NOT_CHARITY);\n            }\n            if (\n                charityBeneficiaryApprovals[i].active == true &&\n                charityBeneficiaryApprovals[i].claimed == false &&\n                (keccak256(\n                    abi.encodePacked(\n                        (charityBeneficiaryApprovals[i].token.tokenType)\n                    )\n                ) == keccak256(abi.encodePacked((\"ERC20\"))))\n            ) {\n                setApprovalClaimed(\n                    _uid,\n                    charityBeneficiaryApprovals[i].approvalId\n                );\n                setBenApprovalClaimed(\n                    _charityBeneficiaryAddress,\n                    charityBeneficiaryApprovals[i].approvalId\n                );\n                TokenActions.sendERC20(charityBeneficiaryApprovals[i]);\n            }\n        }\n    }\n\n    /**\n     * @dev getClaimableAssets allows users to get all claimable assets for a specific user.\n     * @return return a list of assets being protected by this contract\n     */\n    function getClaimableAssets() external view returns (Token[] memory) {\n        Approvals[] memory _approval = BeneficiaryClaimableAsset[msg.sender];\n        uint256 _tokensCount = 0;\n        uint256 _index = 0;\n\n        for (uint256 k = 0; k < _approval.length; k++) {\n            if (_approval[k].claimed == false && _approval[k].active == true) {\n                _tokensCount++;\n            }\n        }\n        Token[] memory _tokens = new Token[](_tokensCount);\n        for (uint256 i = 0; i < _approval.length; i++) {\n            if (_approval[i].claimed == false && _approval[i].active == true) {\n                _tokens[_index] = _approval[i].token;\n                _index++;\n            }\n        }\n        return _tokens;\n    }\n\n    /**\n     *  @notice setApprovalActive called by external actor to mark claiming period\n     *  is active and ready\n     *  @param uid string of the dApp identifier for the user\n     *\n     */\n    function setApprovalActive(string memory uid)\n        external\n        onlyChainlinkOperationsContract\n    {\n        Approvals[] storage _approvals = MemberApprovals[uid];\n        for (uint256 i = 0; i < _approvals.length; i++) {\n            _approvals[i].active = true;\n            _approvals[i].claimExpiryTime = block.timestamp + 31536000;\n            Approvals[] storage approvals = BeneficiaryClaimableAsset[\n                _approvals[i].beneficiary.beneficiaryAddress\n            ];\n            for (uint256 j = 0; j < approvals.length; j++) {\n                if (\n                    keccak256(abi.encodePacked((approvals[j].Member.uid))) ==\n                    keccak256(abi.encodePacked((uid)))\n                ) {\n                    /// @notice check if is ERC20 for preAllocating then claiming\n                    if (\n                        keccak256(\n                            abi.encodePacked((approvals[j].token.tokenType))\n                        ) == keccak256(abi.encodePacked((\"ERC20\")))\n                    ) {\n                        IERC20 claimingERC20 = IERC20(\n                            approvals[j].token.tokenAddress\n                        );\n                        /// @notice setting fixed tokenAmount to claim later\n                        approvals[j].approvedTokenAmount =\n                            (approvals[j].token.tokensAllocated *\n                                claimingERC20.balanceOf(\n                                    approvals[j].approvedWallet\n                                )) /\n                            100;\n                    }\n\n                    if (\n                        keccak256(\n                            abi.encodePacked((approvals[j].token.tokenType))\n                        ) == keccak256(abi.encodePacked((\"ERC1155\")))\n                    ) {\n                        IERC1155 claimingERC1155 = IERC1155(\n                            approvals[j].token.tokenAddress\n                        );\n                        approvals[j].approvedTokenAmount =\n                            (approvals[j].token.tokensAllocated *\n                                claimingERC1155.balanceOf(\n                                    approvals[j].approvedWallet,\n                                    approvals[j].token.tokenId\n                                )) /\n                            100;\n                    }\n\n                    approvals[j].active = true;\n                    approvals[j].claimExpiryTime = block.timestamp + 31536000;\n\n                    emit ApprovalsEvent(\n                        approvals[j].Member.uid,\n                        approvals[j].approvedWallet,\n                        approvals[j].beneficiary.beneficiaryName,\n                        approvals[j].beneficiary.beneficiaryAddress,\n                        // approvals[j].beneficiary.isCharity,\n                        approvals[j].token.tokenId,\n                        approvals[j].token.tokenAddress,\n                        approvals[j].token.tokenType,\n                        approvals[j].token.tokensAllocated,\n                        approvals[j].dateApproved,\n                        approvals[j].claimed,\n                        approvals[j].active,\n                        approvals[j].approvalId,\n                        approvals[j].claimExpiryTime,\n                        approvals[j].approvedTokenAmount\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev deleteApprooval - Deletes the approval of the specific UID\n     * @param uid string of the dApp identifier for the user\n     * @param approvalId uint256 id of the approval struct to be deleted\n     *\n     */\n    function deleteApproval(string memory uid, uint256 approvalId) external {\n        Approvals[] storage approval_ = MemberApprovals[uid];\n        for (uint256 i = 0; i < approval_.length; i++) {\n            if (approval_[i].approvalId == approvalId) {\n                Approvals[] storage _approval_ = MemberApprovals[uid];\n                for (uint256 j = i; j < _approval_.length - 1; j++) {\n                    _approval_[j] = _approval_[j + 1];\n                }\n                _approval_.pop();\n                approval_ = _approval_;\n\n                Approvals[] storage _benApproval = BeneficiaryClaimableAsset[\n                    approval_[i].beneficiary.beneficiaryAddress\n                ];\n                for (uint256 k = 0; k < _benApproval.length; k++) {\n                    if (_benApproval[k].approvalId == approvalId) {\n                        Approvals[]\n                            storage _benapproval_ = BeneficiaryClaimableAsset[\n                                _benApproval[k].beneficiary.beneficiaryAddress\n                            ];\n                        for (uint256 l = k; k < _benapproval_.length - 1; k++) {\n                            _benapproval_[l] = _benapproval_[l + 1];\n                        }\n                        _benapproval_.pop();\n                        _benApproval = _benapproval_;\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n    }\n\n    /**\n     * @dev editApproval - Edits the token information of the approval\n     * @param uid string of the dApp identifier for the user\n     * @param approvalId uint256 ID of the approval struct to modify\n     * @param _contractAddress address being set for the approval\n     * @param _tokenId uint256 tokenId being set of the approval\n     * @param _tokenAmount uint256 amount of tokens in the approval\n     * @param _tokenType string (ERC20 | ERC1155 | ERC721)\n     *\n     */\n    function editApproval(\n        string memory uid,\n        uint256 approvalId,\n        address _contractAddress,\n        uint256 _tokenId,\n        uint256 _tokenAmount,\n        string memory _tokenType\n    ) external checkIfMember(uid) {\n        IMember(IProtocolDirectory(directoryContract).getMemberContract())\n            .checkUIDofSender(uid, msg.sender);\n        Approvals[] storage approval_ = MemberApprovals[uid];\n        for (uint256 i = 0; i < approval_.length; i++) {\n            if (approval_[i].approvalId == approvalId) {\n                if (approval_[i].active || approval_[i].claimed) {\n                    revert(Errors.AS_INVALID_APPROVAL);\n                }\n\n                TokenActions.checkAssetContract(_contractAddress, _tokenType);\n                if (_tokenAmount > 100 || _tokenAmount < 0) {\n                    revert(Errors.AS_INVALID_TOKEN_RANGE);\n                }\n                approval_[i].token.tokenAddress = _contractAddress;\n                approval_[i].token.tokenId = _tokenId;\n                approval_[i].token.tokensAllocated = _tokenAmount;\n                approval_[i].token.tokenType = _tokenType;\n\n                emit ApprovalsEvent(\n                    approval_[i].Member.uid,\n                    approval_[i].approvedWallet,\n                    approval_[i].beneficiary.beneficiaryName,\n                    approval_[i].beneficiary.beneficiaryAddress,\n                    // approval_[i].beneficiary.isCharity,\n                    _tokenId,\n                    _contractAddress,\n                    _tokenType,\n                    _tokenAmount,\n                    approval_[i].dateApproved,\n                    approval_[i].claimed,\n                    approval_[i].active,\n                    approvalId,\n                    approval_[i].claimExpiryTime,\n                    0\n                );\n\n                Approvals[]\n                    storage _beneficiaryApproval = BeneficiaryClaimableAsset[\n                        approval_[i].beneficiary.beneficiaryAddress\n                    ];\n                for (uint256 j = 0; j < _beneficiaryApproval.length; j++) {\n                    if (_beneficiaryApproval[j].approvalId == approvalId) {\n                        if (\n                            _beneficiaryApproval[j].active ||\n                            _beneficiaryApproval[j].claimed\n                        ) {\n                            revert(Errors.AS_INVALID_APPROVAL);\n                        }\n                        _beneficiaryApproval[j]\n                            .token\n                            .tokenAddress = _contractAddress;\n                        _beneficiaryApproval[j].token.tokenId = _tokenId;\n                        _beneficiaryApproval[j]\n                            .token\n                            .tokensAllocated = _tokenAmount;\n                        _beneficiaryApproval[j].token.tokenType = _tokenType;\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n        IMembership(IMembershipAddress).redeemUpdate(uid);\n    }\n\n    /**\n     * @notice Function to check if user has membership\n     * @param _uid string of the dApp identifier for the user\n     *\n     */\n\n    function checkUserHasMembership(string memory _uid) public view {\n        IMembership _membership = IMembership(IMembershipAddress);\n        bool _MembershipActive = _membership.checkIfMembershipActive(_uid);\n        if (_MembershipActive == false) {\n            revert(Errors.AS_NO_MEMBERSHIP);\n        } else {\n            MembershipStruct memory Membership = IMembership(IMembershipAddress)\n                .getMembership(_uid);\n            if (Membership.updatesPerYear <= 0) {\n                revert(Errors.AS_NEED_TOP);\n            }\n        }\n    }\n}\n"}, "contracts/libraries/TokenActions.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../structs/ApprovalsStruct.sol\";\n\n/**\n * @title TokenActions Library\n *\n * Here contains the common functions for interacting with\n * tokens for importing in different parts of the ecosystem\n * to save space hopefully in other places\n */\nlibrary TokenActions {\n    /**\n     * @notice internal function for sending erc20s\n     *\n     * creating this function to save space while sending coins\n     * to charities and for beneficiaries\n     *\n     * @param _approval of the Approvals type in storage\n     */\n    function sendERC20(Approvals storage _approval) internal {\n        IERC20 ERC20 = IERC20(_approval.token.tokenAddress);\n\n        /// @notice gather the preset approved token amount for this beneficiary\n        uint256 _tokenAmount = (_approval.approvedTokenAmount);\n\n        /// @notice If the allowance for the member by claimer is greater than the _tokenAmount\n        /// take the allowance for the beneficiary that called this function: why ?\n        if (\n            ERC20.allowance(_approval.approvedWallet, msg.sender) > _tokenAmount\n        ) {\n            _tokenAmount = ERC20.allowance(\n                _approval.approvedWallet,\n                msg.sender\n            );\n        }\n        _approval.claimed = true;\n        bool send = ERC20.transferFrom(\n            _approval.approvedWallet,\n            _approval.beneficiary.beneficiaryAddress,\n            _tokenAmount\n        );\n    }\n\n    /**\n     *\n     * @dev checkAssetContract\n     * @param _contractAddress contract of the token we are checking\n     * @param _tokenType the given tokentype as a string ERC721 etc...\n     *\n     * Checks if the assets passed through are assets of the determined type or not.\n     * it can handle upgradable versions as well if needed\n     *\n     */\n    function checkAssetContract(\n        address _contractAddress,\n        string memory _tokenType\n    ) external view {\n        if (\n            (keccak256(abi.encodePacked((_tokenType))) ==\n                keccak256(abi.encodePacked((\"ERC721\"))))\n        ) {\n            require(\n                (IERC721Upgradeable(_contractAddress).supportsInterface(\n                    type(IERC721Upgradeable).interfaceId\n                ) ||\n                    IERC721(_contractAddress).supportsInterface(\n                        type(IERC721).interfaceId\n                    )),\n                \"Does not support a Supported ERC721 Interface\"\n            );\n        } else if (\n            keccak256(abi.encodePacked((_tokenType))) ==\n            keccak256(abi.encodePacked((\"ERC20\")))\n        ) {\n            require(\n                (IERC20(_contractAddress).totalSupply() >= 0 ||\n                    IERC20Upgradeable(_contractAddress).totalSupply() >= 0),\n                \"Is not an ERC20 Contract Address\"\n            );\n        } else if (\n            keccak256(abi.encodePacked((_tokenType))) ==\n            keccak256(abi.encodePacked((\"ERC1155\")))\n        ) {\n            require(\n                (IERC1155Upgradeable(_contractAddress).supportsInterface(\n                    type(IERC1155Upgradeable).interfaceId\n                ) ||\n                    IERC1155(_contractAddress).supportsInterface(\n                        type(IERC1155).interfaceId\n                    )),\n                \"Does not support a Supported ERC1155 Interface\"\n            );\n        } else {\n            revert(\"Invalid token type\");\n        }\n    }\n}\n"}, "contracts/libraries/Errors.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @title Errors library\n * @notice Defines the error messages emitted by the different contracts of the Webacy\n * @dev inspired by Aave's https://github.com/aave/protocol-v2/blob/master/contracts/protocol/libraries/helpers/Errors.sol\n * @dev Error messages prefix glossary:\n *  - ASF = AssetStoreFactory\n *  - MF = MembershipFactory\n *  - BL = Blacklist\n *  - WL = Whitelist\n *  - AS = AssetStore\n *  - CO = ChainlinkOperations\n *  - M = Member\n *  - MS = Membership\n *  - PD = ProtocolDirectory\n *  - RC = RelayerContract\n */\nlibrary Errors {\n    // AssetStoreFactory Errors\n    string public constant ASF_NO_MEMBERSHIP_CONTRACT = \"1\"; // \"User does not have a membership contract deployed\"\n    string public constant ASF_HAS_AS = \"2\"; // \"User has an AssetStore\"\n\n    // MembershipFactory Errors\n    string public constant MF_HAS_MEMBERSHIP_CONTRACT = \"3\"; //  \"User already has a membership contract\"\n    string public constant MF_INACTIVE_PLAN = \"4\"; //  \"Membership plan is no longer active\"\n    string public constant MF_NEED_MORE_DOUGH = \"5\"; //  \"Membership cost send is not sufficient\"\n\n    // Blacklist Errors\n    string public constant BL_BLACKLISTED = \"6\"; //  \"Address is blacklisted\"\n\n    // AssetStore Errors\n    string public constant AS_NO_MEMBERSHIP = \"7\"; //  \"AssetsStore: User does not have a membership\"\n    string public constant AS_USER_DNE = \"8\"; //  \"User does not exist\"\n    string public constant AS_ONLY_RELAY = \"9\"; //  \"Only relayer contract can call this\"\n    string public constant AS_ONLY_CHAINLINK_OPS = \"10\"; //  \"Only chainlink operations contract can call this\"\n    string public constant AS_DIFF_LENGTHS = \"11\"; // \"Lengths of parameters need to be equal\"\n    string public constant AS_ONLY_PRIMARY_WALLET = \"12\"; // \"Only the primary wallet can approve to store assets\"\n    string public constant AS_INVALID_TOKEN_RANGE = \"13\"; // \"tokenAmount can only range from 0-100 percentage\"\n    string public constant AS_ONLY_BENEFICIARY = \"14\"; // \"Only the designated beneficiary can claim assets\"\n    string public constant AS_NO_APPROVALS = \"15\"; // \"No Approvals found\"\n    string public constant AS_NOT_CHARITY = \"16\"; // \"is not charity\"\n    string public constant AS_INVALID_APPROVAL = \"17\"; // \"Approval should not be active and should not be claimed in order to make changes\"\n    string public constant AS_NEED_TOP = \"18\"; // \"User does not have sufficient topUp Updates in order to store approvals\"\n\n    // Member Errors\n    string public constant M_NOT_OWNER = \"19\"; // \"Member UID does not own this wallet Address\"\n    string public constant M_NOT_HOLDER = \"20\"; // \"The user does not own a token of the supporting NFT Collection\"\n    string public constant M_USER_DNE = \"21\"; // \"No user exists\"\n    string public constant M_UID_DNE = \"22\"; // \"No UID found\"\n    string public constant M_INVALID_BACKUP = \"23\"; // \"BackUp Wallet specified is not the users backup Wallet\"\n    string public constant M_NOT_MEMBER = \"24\"; // \"Member: User does not have a membership\"\n    string public constant M_EMPTY_UID = \"25\"; // \"UID is empty\"\n    string public constant M_PRIM_WALLET = \"26\"; // \"You cannot delete your primary wallet\"\n    string public constant M_ALREADY_PRIM = \"27\"; // \"Current Wallet is already the primary Wallet\"\n    string public constant M_DIFF_LENGTHS = \"28\"; // \"Lengths of parameters need to be equal\"\n    string public constant M_BACKUP_FIRST = \"29\"; // \"User should backup assets prior to executing panic button\"\n    string public constant M_NEED_TOP = \"30\"; // \"User does not have sufficient topUp Updates in order to store approvals\"\n    string public constant M_INVALID_ADDRESS = \"31\"; // \"Membership Error: User should have its deployed Membership Address\"\n    string public constant M_USER_MUST_WALLET = \"32\"; //\"User should have a primary wallet prior to adding a backup wallet\"\n    string public constant M_USER_EXISTS = \"33\"; // User with UID already exists\n\n    // Membership Errors\n    string public constant MS_NEED_MORE_DOUGH = \"34\"; // \"User needs to send sufficient amount to topUp\"\n    string public constant MS_INACTIVE = \"35\"; // \"Membership inactive\"\n\n    // RelayerContract Errors\n    string public constant RC_UNAUTHORIZED = \"36\"; // \"Only relayer can invoke this function\"\n}\n"}, "contracts/interfaces/IProtocolDirectory.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @title Protocol Directory interface\n *\n * Use this interface in any contract that needs to find\n * the contract location for commonly used Webacy contracts\n *\n */\n\ninterface IProtocolDirectory {\n    /**\n     * @notice event for recording changes of contracts\n     *\n     */\n    event AddressSet(bytes32 contractName, address indexed newContractAddress);\n\n    /**\n     * @notice get the address by a bytes32 location id\n     * @param _contractName a bytes32 string\n     *\n     */\n    function getAddress(bytes32 _contractName) external returns (address);\n\n    /**\n     * @notice setAddress\n     * @param _contractName a bytes32 string\n     * @param _contractLocation an address of to entrypoint of protocol contract\n     *\n     */\n    function setAddress(bytes32 _contractName, address _contractLocation)\n        external\n        returns (address);\n\n    /**\n     * @notice ssetStoreFactory\n     * @return address of protocol contract matching ASSET_STORE_FACTORY value\n     *\n     */\n    function getAssetStoreFactory() external view returns (address);\n\n    /**\n     * @notice getMembershipFactory\n     * @return address of protocol contract matching MEMBERSHIP_FACTORY value\n     *\n     */\n    function getMembershipFactory() external view returns (address);\n\n    /**\n     * @notice getRelayerContract\n     * @return address of protocol contract matching RELAYER_CONTRACT value\n     *\n     */\n    function getRelayerContract() external view returns (address);\n\n    /**\n     * @notice getMemberContract\n     * @return address of protocol contract matching MEMBER_CONTRACT value\n     *\n     */\n    function getMemberContract() external view returns (address);\n\n    /**\n     * @notice getBlacklistContract\n     * @return address of protocol contract matching BLACKLIST_CONTRACT value\n     *\n     */\n    function getBlacklistContract() external view returns (address);\n\n    /**\n     * @notice getWhitelistContract\n     * @return address of protocol contract matching WHITELIST_CONTRACT value\n     *\n     */\n    function getWhitelistContract() external view returns (address);\n\n    /**\n     * @notice getTransferPool\n     * @return address of protocol contract matching TRANSFER_POOL value\n     *\n     */\n    function getTransferPool() external view returns (address);\n\n    /**\n     * @notice getChainlinkOperationsContract\n     * @return address of protocol contract matching CHAINLINK_OPERATIONS_CON value\n     *\n     */\n    function getChainlinkOperationsContract() external view returns (address);\n\n    /**\n     * @dev setAssetStoreFactory\n     * @param _contractLocation address of the new contract location\n     * @return address of the updated item as a confirmation\n     */\n\n    function setAssetStoreFactory(address _contractLocation)\n        external\n        returns (address);\n\n    /**\n     * @dev setMembershipFactory\n     * @param _contractLocation address of the new contract location\n     * @return address of the updated item as a confirmation\n     */\n\n    function setMembershipFactory(address _contractLocation)\n        external\n        returns (address);\n\n    /**\n     * @dev setRelayerContract\n     * @param _contractLocation address of the new contract location\n     * @return address of the updated item as a confirmation\n     */\n\n    function setRelayerContract(address _contractLocation)\n        external\n        returns (address);\n\n    /**\n     * @dev setMemberContract\n     * @param _contractLocation address of the new contract location\n     * @return address of the updated item as a confirmation\n     */\n\n    function setMemberContract(address _contractLocation)\n        external\n        returns (address);\n\n    /**\n     * @dev setBlacklistContract\n     * @param _contractLocation address of the new contract location\n     * @return address of the updated item as a confirmation\n     */\n\n    function setBlacklistContract(address _contractLocation)\n        external\n        returns (address);\n\n    /**\n     * @dev setWhitelistContract\n     * @param _contractLocation address of the new contract location\n     * @return address of the updated item as a confirmation\n     */\n\n    function setWhitelistContract(address _contractLocation)\n        external\n        returns (address);\n\n    /**\n     * @dev setTransferPool\n     * @param _contractLocation address of the new contract location\n     * @return address of the updated item as a confirmation\n     */\n\n    function setTransferPool(address _contractLocation)\n        external\n        returns (address);\n\n    /**\n     * @dev setChainlinkOperationsContract\n     * @param _contractLocation address of the new contract location\n     * @return address of the updated item as a confirmation\n     */\n\n    function setChainlinkOperationsContract(address _contractLocation)\n        external\n        returns (address);\n}\n"}, "contracts/interfaces/IMember.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"../structs/MemberStruct.sol\";\nimport \"../structs/BackupApprovalStruct.sol\";\n\n/**\n * @title Interface for IMember\n * @dev to interact with Member Contracts\n *\n */\ninterface IMember {\n    /**\n     * @dev createMember\n     * @param  uid centrally stored id for user\n     * @param _walletAddress walletAddress to add wallet and check blacklist\n     *\n     * Allows to create a member onChain with a unique UID passed.\n     * Will revert if the _walletAddress passed in is blacklisted\n     *\n     */\n    function createMember(string calldata uid, address _walletAddress) external;\n\n    /**\n     * @dev getMember\n     * @param uid string for centrally located identifier\n     * Allows to get member information stored onChain with a unique UID passed.\n     * @return member struct for a given uid\n     *\n     */\n    function getMember(string memory uid) external view returns (member memory);\n\n    /**\n     * @dev getAllMembers\n     * Allows to get all member information stored onChain\n     * @return allMembers a list of member structs\n     *\n     */\n    function getAllMembers() external view returns (member[] memory);\n\n    /**\n     * @dev addWallet - Allows to add Wallet to the user\n     * @param uid string for dApp user identifier\n     * @param _wallet address wallet being added for given user\n     * @param _primary bool whether or not this new wallet is the primary wallet\n     *\n     *\n     */\n    function addWallet(\n        string calldata uid,\n        address _wallet,\n        bool _primary\n    ) external;\n\n    /**\n     * @dev getWallets\n     * Allows to get all wallets of the user\n     * @param uid string for dApp user identifier\n     * @return address[] list of wallets\n     *\n     */\n    function getWallets(string calldata uid)\n        external\n        view\n        returns (address[] memory);\n\n    /**\n     * @dev deleteWallet - Allows to delete  wallets of a specific user\n     * @param uid string for dApp user identifier\n     * @param _walletIndex uint256 which index does the wallet exist in the member wallet list\n     *\n     */\n    function deleteWallet(string calldata uid, uint256 _walletIndex) external;\n\n    /**\n     * @dev getPrimaryWallets\n     * Allows to get primary wallet of the user\n     * @param uid string for dApp user identifier\n     * @return address of the primary wallet per user\n     *\n     */\n    function getPrimaryWallet(string memory uid)\n        external\n        view\n        returns (address);\n\n    /**\n     * @dev setPrimaryWallet\n     * Allows to set a specific wallet as the primary wallet\n     * @param uid string for dApp user identifier\n     * @param _walletIndex uint256 which index does the wallet exist in the member wallet list\n     *\n     */\n    function setPrimaryWallet(string calldata uid, uint256 _walletIndex)\n        external;\n\n    /**\n     * @notice Function to check if wallet exists in the UID\n     * @param _uid string of dApp identifier for a user\n     * @param _user address of the user checking exists\n     * Fails if not owner uid and user address do not return a wallet\n     *\n     */\n    function checkUIDofSender(string memory _uid, address _user) external view;\n\n    /**\n     * @dev checkIfUIDExists\n     * Check if user exists for specific wallet address already internal function\n     * @param _walletAddress wallet address of the user\n     * @return _exists - A boolean if user exists or not\n     *\n     */\n    function checkIfUIDExists(address _walletAddress)\n        external\n        view\n        returns (bool _exists);\n\n    /**\n     * @dev getUID\n     * Allows user to pass walletAddress and return UID\n     * @param _walletAddress get the UID of the user's if their wallet address is present\n     * @return string of the ID used in the dApp to identify they user\n     *\n     */\n    function getUID(address _walletAddress)\n        external\n        view\n        returns (string memory);\n\n    /**\n     * @dev getBackupApprovals - function to return all backupapprovals for a specific UID\n     * @param uid string of identifier for user in dApp\n     * @return BackUpApprovals[] list of BackUpApprovals struct\n     *\n     */\n    function getBackupApprovals(string memory uid)\n        external\n        view\n        returns (BackUpApprovals[] memory);\n\n    /**\n     * @dev storeBackupAssetsApprovals - Function to store All Types Approvals by the user for backup\n     *\n     * @param _contractAddress address[] Ordered list of contract addresses for assets\n     * @param _tokenIds uint256[] Ordered list of tokenIds associated with contract addresses\n     * @param _backUpWallets address[] Ordered list of wallet addresses to backup assets\n     * @param _tokenAmount uint256[] Ordered list of amounts per asset contract and token id to protext\n     * @param _tokenTypes string[] Ordered list of strings i.e. ERC20 | ERC721 | ERC1155\n     * @param _memberUID string for dApp user identifier\n     * @param _userAddress address of the user\n     * @param _super bool true if function is being called from a parent function. false if directly\n     *\n     */\n    function storeBackupAssetsApprovals(\n        address[] calldata _contractAddress,\n        uint256[] calldata _tokenIds,\n        address[] calldata _backUpWallets,\n        uint256[] calldata _tokenAmount,\n        string[] calldata _tokenTypes,\n        string calldata _memberUID,\n        address _userAddress,\n        bool _super\n    ) external;\n\n    /**\n     * @dev executePanic - Public function to transfer assets from one user to another\n     * @param _backUpWallet wallet to panic send assets to\n     * @param _memberUID uid of the user's assets being moved\n     *\n     */\n    function executePanic(address _backUpWallet, string memory _memberUID)\n        external;\n\n    /**\n     * @dev editBackup - Function to edit individual backup approvals\n     * @param approvalId_ uint256 id to lookup Approval and edit\n     * @param _contractAddress address contractAddress of asset to save\n     * @param _tokenIds uint256 tokenId of asset\n     * @param _tokenAmount uint256 amount of specific token\n     * @param _tokenType string type of the token i.e. ERC20 | ERC721 | ERC1155\n     * @param _uid string of identifier for user in dApp\n     * @param _user address of the user of the dApp\n     *\n     */\n    function editBackUp(\n        uint256 approvalId_,\n        address _contractAddress,\n        uint256 _tokenIds,\n        uint256 _tokenAmount,\n        string calldata _tokenType,\n        string memory _uid,\n        address _user\n    ) external;\n\n    /**\n     * @dev editAllBackUp - Function to delete and add new approvals for backup\n     * @param _contractAddress address[] Ordered list of addresses for asset contracts\n     * @param _tokenIds uint256[] Ordered list of tokenIds to backup\n     * @param _backUpWallets address[] Ordered list of wallets that can be backups\n     * @param _tokenAmount uint256[] Ordered list of amounts of tokens to backup\n     * @param _tokenTypes string[] Ordered list of string tokenTypes i.e. ERC20 | ERC721 | ERC1155\n     * @param _memberUID string of identifier for user in dApp\n     * @param _user address of the user of the dApp\n     *\n     *\n     */\n    function editAllBackUp(\n        address[] calldata _contractAddress,\n        uint256[] calldata _tokenIds,\n        address[] calldata _backUpWallets,\n        uint256[] calldata _tokenAmount,\n        string[] calldata _tokenTypes,\n        string calldata _memberUID,\n        address _user\n    ) external;\n\n    /**\n     * @dev deleteAllBackUp - Function to delete all backup approvals\n     * @param _uid string of identifier for user in dApp\n     *\n     */\n    function deleteAllBackUp(string memory _uid) external;\n\n    /**\n     * @notice checkUserHasMembership - Function to check if user has membership\n     * @param _uid string of identifier for user in dApp\n     * @param _user address of the user of the dApp\n     *\n     */\n    function checkUserHasMembership(string memory _uid, address _user)\n        external\n        view;\n\n    /**\n     * @dev Function set MembershipAddress for a Uid\n     * @param _uid string of identifier for user in dApp\n     * @param _Membership address of the user's associated membership contract\n     *\n     */\n    function setIMembershipAddress(string memory _uid, address _Membership)\n        external;\n\n    /**\n     * @dev Function to get MembershipAddress for a given Uid\n     * @param _uid string of identifier for user in dApp\n     *\n     */\n    function getIMembershipAddress(string memory _uid)\n        external\n        view\n        returns (address);\n\n    /**\n     * @notice checkIfWalletHasNFT\n     * verify if the user has specific nft 1155 or 721\n     * @param _contractAddress address of asset contract\n     * @param _NFTType string i.e. ERC721 | ERC1155\n     * @param tokenId uint256 tokenId checking for ownership\n     * @param userAddress address address to verify ownership of\n     * Fails if not owner\n     */\n    function checkIfWalletHasNFT(\n        address _contractAddress,\n        string memory _NFTType,\n        uint256 tokenId,\n        address userAddress\n    ) external view;\n\n    /**\n     * @dev addBackUpWallet - Allows to add backUp Wallets to the user\n     * @param uid string for dApp user identifier\n     * @param _wallets addresses of wallets being added for given user\n     *\n     *\n     */\n    function addBackupWallet(\n        string calldata uid,\n        address[] memory _wallets,\n        address _user\n    ) external;\n\n    /**\n     * @dev getBackupWallets - Returns backup Wallets for the specific UID\n     * @param uid string for dApp user identifier\n     *\n     */\n    function getBackupWallets(string calldata uid)\n        external\n        view\n        returns (address[] memory);\n}\n"}, "contracts/interfaces/IMembership.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"../structs/MembershipPlansStruct.sol\";\nimport \"../structs/MembershipStruct.sol\";\n\n/**\n * @title Interface for IMembership\n * @dev to interact with Membership\n */\ninterface IMembership {\n    /**\n     * @dev Function to check of membership is active for the user\n     * @param _uid string identifier of user across dApp\n     * @return bool boolean representing if the membership has expired\n     *\n     */\n    function checkIfMembershipActive(string memory _uid)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @dev renewmembership Function to renew membership of the user\n     * @param _uid string identifier of the user renewing membership\n     *\n     *\n     */\n    function renewMembership(string memory _uid) external payable;\n\n    /**\n     * @dev renewmembershipNFT - Function to renew membership for users that have NFTs\n     * @param _contractAddress address of nft to approve renewing\n     * @param _NFTType string type of NFT i.e. ERC20 | ERC1155 | ERC721\n     * @param tokenId uint256 tokenId being protected\n     * @param _uid string identifier of the user renewing membership\n     *\n     */\n    function renewMembershipNFT(\n        address _contractAddress,\n        string memory _NFTType,\n        uint256 tokenId,\n        string memory _uid\n    ) external payable;\n\n    /**\n     * @dev Function to top up updates\n     * @param _uid string identifier of the user across the dApp\n     *\n     */\n    function topUpUpdates(string memory _uid) external payable;\n\n    /**\n     * @notice changeMembershipPlan\n     * Ability to change membership plan for a member given a membership ID and member UID.\n     * It is a payable function given the membership cost for the membership plan.\n     *\n     * @param membershipId uint256 id of membership plan changing to\n     * @param _uid string identifier of the user\n     */\n    function changeMembershipPlan(uint256 membershipId, string memory _uid)\n        external\n        payable;\n\n    /**\n     * @notice changeMembershipPlanNFT - Function to change membership plan to an NFT based plan\n     * @param membershipId uint256 id of the membershipPlan changing to\n     * @param _contractAddress address of the NFT granting the membership\n     * @param _NFTType string type of NFT i.e. ERC721 | ERC1155\n     * @param tokenId uint256 tokenId of the nft to verify ownership\n     * @param _uid string identifier of the user across the dApp\n     *\n     */\n    function changeMembershipPlanNFT(\n        uint256 membershipId,\n        address _contractAddress,\n        string memory _NFTType,\n        uint256 tokenId,\n        string memory _uid\n    ) external payable;\n\n    /**\n     * @notice redeemUpdate\n     * @param _uid string identifier of the user across the dApp\n     *\n     * Function to claim that a membership has been updated\n     */\n    function redeemUpdate(string memory _uid) external;\n\n    /**\n     * @notice Function to return membership information of the user\n     * @param _uid string identifier of user across dApp\n     * @return MembershipStruct containing information of the specific user's membership\n     *\n     */\n    function getMembership(string memory _uid)\n        external\n        view\n        returns (MembershipStruct memory);\n}\n"}, "contracts/interfaces/IAssetStore.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"../structs/ApprovalsStruct.sol\";\n\n/**\n *  @title IAssetStore\n *  @dev Interface for IAssetStore to interact with AssetStore Contracts\n *\n */\ninterface IAssetStore {\n    /**\n     * @notice storeAssetsApprovals - Function to store All Types Approvals by the user\n     * @dev All of the arrays passed in need to be IN ORDER\n     * they will be accessed in a loop together\n     * @param _contractAddress address[] Ordered list of contracts for different assets\n     * @param _tokenIds uint256[] Ordered list of tokenIds for the listed contractAddresses\n     * @param _beneficiaries address[] Ordered list of addresses associated with addresses/wallets assets will be claimed by\n     * @param _beneficiaryNames string[] Ordered list of names associated with the _beneficiaries\n     * @param _beneficiaryIsCharity bool[] Ordered list of booleans representing if the beneficiary is charity, an EOA not able to claim assets independently\n     * @param _tokenAmount uint256[] Ordered list of numbers represnting the %'s of assets to go to a beneficiary\n     * @param _tokenTypes string[] Ordered list of strings for the token types (i.e. ERC20, ERC1155, ERC721)\n     * @param _memberUID string of the dApp identifier for the user\n     *\n     */\n    function storeAssetsApprovals(\n        address[] memory _contractAddress,\n        uint256[] memory _tokenIds,\n        address[] memory _beneficiaries,\n        string[] memory _beneficiaryNames,\n        bool[] memory _beneficiaryIsCharity,\n        uint256[] memory _tokenAmount,\n        string[] memory _tokenTypes,\n        string memory _memberUID\n    ) external;\n\n    /**\n     * @notice getApproval - Function to get a specific token Approval for the user passing in UID and ApprovalID\n     * @dev searches state for a match by uid and approvalId for a given user\n     *\n     * @param uid string of the dApp identifier for the user\n     * @param approvalId number of the individual approval to lookup\n     *\n     * @return approval_ struct storing information for an Approval\n     */\n    function getApproval(string memory uid, uint256 approvalId)\n        external\n        view\n        returns (Approvals memory approval_);\n\n    /**\n     * @notice getBeneficiaryApproval - Function to get a token Approval for the beneficiaries - Admin function\n     * @param _benAddress address to lookup a specific list of approvals for given beneficiary address\n     * @return approval_ a list of approval structs for a specific address\n     */\n    function getBeneficiaryApproval(address _benAddress)\n        external\n        view\n        returns (Approvals[] memory approval_);\n\n    /**\n     * @notice getApprovals - Function to get all token Approvals for the user\n     * @param uid string of the dApp identifier for the user\n     * @return Approvals[] a list of all the approval structs associated with a user\n     */\n    function getApprovals(string memory uid)\n        external\n        view\n        returns (Approvals[] memory);\n\n    /**\n     *  @notice setApprovalActive called by external actor to mark claiming period\n     *  is active and ready\n     *  @param uid string of the dApp identifier for the user\n     *\n     */\n    function setApprovalActive(string memory uid) external;\n\n    /**\n     * @dev claimAsset - Function to claim Asset from a specific UID\n     * @param uid string of the dApp identifier for the user\n     * @param approvalId_ uint256 id of the specific approval being claimed\n     * @param benUID string of the dApp identifier for the beneficiary claiming the asset\n     *\n     */\n    function claimAsset(\n        string memory uid,\n        uint256 approvalId_,\n        string memory benUID\n    ) external;\n\n    /**\n     * @dev getClaimableAssets allows users to get all claimable assets for a specific user.\n     * @return return a list of assets being protected by this contract\n     */\n    function getClaimableAssets() external view returns (Token[] memory);\n\n    /**\n     * @dev deleteApprooval - Deletes the approval of the specific UID\n     * @param uid string of the dApp identifier for the user\n     * @param approvalId uint256 id of the approval struct to be deleted\n     *\n     */\n    function deleteApproval(string memory uid, uint256 approvalId) external;\n\n    /**\n     * @dev editApproval - Edits the token information of the approval\n     * @param uid string of the dApp identifier for the user\n     * @param approvalId uint256 ID of the approval struct to modify\n     * @param _contractAddress address being set for the approval\n     * @param _tokenId uint256 tokenId being set of the approval\n     * @param _tokenAmount uint256 amount of tokens in the approval\n     * @param _tokenType string (ERC20 | ERC1155 | ERC721)\n     *\n     */\n    function editApproval(\n        string memory uid,\n        uint256 approvalId,\n        address _contractAddress,\n        uint256 _tokenId,\n        uint256 _tokenAmount,\n        string memory _tokenType\n    ) external;\n\n    /**\n     * @notice Function to store All Types of Approvals and Backups by the user in one function\n     * @dev storeAssetsAndBackUpApprovals calls\n     *  storeBackupAssetsApprovals & storeAssetsApprovals\n     * \n     * sent to storeAssetsApprovals:\n     * @param _contractAddress address[] Ordered list of contracts for different assets\n     * @param _beneficiaries address[] Ordered list of addresses associated with addresses/wallets assets will be claimed by\n     * @param _beneficiaryNames string[] Ordered list of names associated with the _beneficiaries\n     * @param _beneficiaryIsCharity bool[] Ordered list of booleans representing if the beneficiary is charity, an EOA not able to claim assets independently\n     * @param _tokenTypes string[] Ordered list of strings for the token types (i.e. ERC20, ERC1155, ERC721)\n     * @param _tokenIds uint256[] Ordered list of tokenIds for the listed contractAddresses\n     * @param _tokenAmount uint256[] Ordered list of numbers represnting the %'s of assets to go to a beneficiary\n     \n     * sent to storeBackupAssetsApprovals:\n     * @param _backUpTokenIds uint256[] Ordered list of tokenIds to be in a backup plan\n     * @param _backupTokenAmount uint256[] Ordered list representing a magnitube of tokens to be in a backupPlan\n     * @param _backUpWallets address[] Ordered list of destination wallets for the backupPlan\n     * @param _backUpAddresses address[] Ordered list of contract addresses of assets for the backupPlan\n     * @param _backupTokenTypes string[] Ordered list of strings for the token types (i.e. ERC20, ERC1155, ERC721)\n     * @param uid string of the dApp identifier for the user\n     * \n     * \n     */\n    function storeAssetsAndBackUpApprovals(\n        address[] memory _contractAddress,\n        address[] memory _beneficiaries,\n        string[] memory _beneficiaryNames,\n        bool[] memory _beneficiaryIsCharity,\n        string[] memory _tokenTypes,\n        uint256[] memory _tokenIds,\n        uint256[] memory _tokenAmount,\n        uint256[] memory _backUpTokenIds,\n        uint256[] memory _backupTokenAmount,\n        address[] memory _backUpWallets,\n        address[] memory _backUpAddresses,\n        string[] memory _backupTokenTypes,\n        string memory uid\n    ) external;\n\n    /**\n     * @notice transferUnclaimedAsset - Function to claim Unclaimed Assets passed the claimable expiry time\n     * @param uid string of the dApp identifier for the user\n     */\n    function transferUnclaimedAssets(string memory uid) external;\n\n    /**\n     * @dev sendAssetsToCharity\n     * @param _charityBeneficiaryAddress address of the charity beneficiary\n     * @param _uid the uid stored for the user\n     *\n     * Send assets to the charity beneficiary if they exist;\n     *\n     */\n    function sendAssetsToCharity(\n        address _charityBeneficiaryAddress,\n        string memory _uid\n    ) external;\n}\n"}, "contracts/interfaces/IAssetStoreFactory.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"../structs/MembershipPlansStruct.sol\";\n\n/**\n * @title IMembershipFactory\n * @dev Interface to interact with Membership Factory\n *\n */\ninterface IAssetStoreFactory {\n    /**\n     * @dev Function to deployAssetStore for each user\n     * @param _uid string identifier of the user across the dApp\n     * @param _user address of the user deploying the AssetStore\n     *\n     */\n    function deployAssetStore(string memory _uid, address _user) external;\n\n    /**\n     * @dev Function to return assetStore Address of a specific user\n     * @param _uid string identifier for the user across the dApp\n     * @return address of the AssetStore for given user\n     *\n     */\n    function getAssetStoreAddress(string memory _uid)\n        external\n        view\n        returns (address);\n}\n"}, "contracts/structs/MemberStruct.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @dev Member Structure stores all member information\n * @param uid string For storing UID that cross references UID from DB for loading off-chain data\n * @param dateCreated uint256 timestamp of creation of User\n * @param wallets address[] Maintains an array of backUpWallets of the User\n * @param primaryWallet uint256 index of where in the wallets array the primary wallet exists\n */\nstruct member {\n    string uid;\n    uint256 dateCreated;\n    address[] wallets;\n    address[] backUpWallets;\n    uint256 primaryWallet;\n}\n"}, "contracts/structs/TokenStruct.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @dev Token struct\n *\n * @param tokenId uint256 specific tokenId for the asset\n * @param tokenAddress address of the contract for this asset\n * @param tokenType string representing asset type i.e. ERC721 | ERC20 | ERC1155\n * @param tokensAllocated uint256 number representing how many tokens as a %'s to\n * attach to a given approval or other directive\n */\nstruct Token {\n    uint256 tokenId;\n    address tokenAddress;\n    string tokenType;\n    uint256 tokensAllocated;\n}\n"}, "contracts/structs/ApprovalsStruct.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"./MemberStruct.sol\";\nimport \"./TokenStruct.sol\";\nimport \"./BeneficiaryStruct.sol\";\n\n/**\n * @dev Approvals Struct\n * @param Member member struct with information on the user\n * @param approvedWallet address of wallet approved\n * @param beneficiary Beneficiary struct holding recipient info\n * @param token Token struct holding specific info on the asset\n * @param dateApproved uint256 timestamp of the approval creation\n * @param claimed bool representing status if asset was claimed\n * @param active bool representing if the claim period has begun\n * @param approvalId uint256 id of the specific approval in the assetstore\n * @param claimExpiryTime uint256 timestamp of when claim period ends\n * @param approvedTokenAmount uint256 magnitude of tokens to claim by this approval\n *\n */\nstruct Approvals {\n    member Member;\n    address approvedWallet;\n    Beneficiary beneficiary;\n    Token token;\n    uint256 dateApproved;\n    bool claimed;\n    bool active;\n    uint256 approvalId;\n    uint256 claimExpiryTime;\n    uint256 approvedTokenAmount;\n}\n"}, "@openzeppelin/contracts/access/Ownable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"}, "@openzeppelin/contracts/security/ReentrancyGuard.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"}, "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"}, "@openzeppelin/contracts/token/ERC721/IERC721.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"}, "@openzeppelin/contracts/token/ERC20/IERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"}, "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.30;\n\nimport \"./IERC1155Upgradeable.sol\";\nimport \"./IERC1155ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC1155MetadataURIUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155Upgradeable, IERC1155MetadataURIUpgradeable {\n    using AddressUpgradeable for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    function __ERC1155_init(string memory uri_) internal onlyInitializing {\n        __ERC1155_init_unchained(uri_);\n    }\n\n    function __ERC1155_init_unchained(string memory uri_) internal onlyInitializing {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC1155Upgradeable).interfaceId ||\n            interfaceId == type(IERC1155MetadataURIUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155ReceiverUpgradeable(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155ReceiverUpgradeable.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[47] private __gap;\n}\n"}, "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"}, "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"}, "contracts/structs/BeneficiaryStruct.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @dev Structure to store different types of Beneficiary\n * (ERC721, ERC1155, ERC20)\n * @param beneficiaryAddress address for assets to go to\n * @param beneficiaryName name of entity recieveing the assets\n * @param isCharity boolean representing if Beneficiary is a charity\n * because charities will be a recieve only address and cannot be\n * expected to call a function to claim assets\n *\n */\nstruct Beneficiary {\n    address beneficiaryAddress;\n    string beneficiaryName;\n    bool isCharity;\n}\n"}, "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"}, "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"}, "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.30;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"}, "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"}, "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"}, "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.30;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"}, "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../IERC1155Upgradeable.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURIUpgradeable is IERC1155Upgradeable {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"}, "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"}, "@openzeppelin/contracts/utils/introspection/IERC165.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"}, "contracts/structs/BackupApprovalStruct.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"./MemberStruct.sol\";\nimport \"./TokenStruct.sol\";\nimport \"./BeneficiaryStruct.sol\";\n\n/**\n * @dev BackUpApprovals struct\n *\n * @param Member member struct of information for the user\n * @param approvedWallet address wallet approving the assets\n * @param backUpWallet address[] wallet approved to recieve assets\n * @param token Token struct with information about the asset backed up\n * @param dateApproved uint256 timestamp of when the approval came in\n * @param claimed bool status of the approval if it was claimed\n * @param approvalId uint256 id of the specific approval for this asset\n */\nstruct BackUpApprovals {\n    member Member;\n    address approvedWallet;\n    address[] backUpWallet;\n    Token token;\n    uint256 dateApproved;\n    bool claimed;\n    uint256 approvalId;\n}\n"}, "contracts/structs/MembershipPlansStruct.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @dev membershipPlan struct\n *\n * @param membershipDuration uint256 length of time membership is good for\n * @param costOfMembership uint256 cost in wei of gaining membership\n * @param updatesPerYear uint256 how many updates can the membership be updated in a year by user\n * @param nftCollection address pass as null address if it is not for creating specific\n * membership plan for a specific NFT Collection\n * @param membershipId uint256 id for the new membership to lookup by\n * @param active bool status if the membership can be used to create new contracts\n */\nstruct membershipPlan {\n    uint256 membershipDuration;\n    uint256 costOfMembership;\n    uint256 updatesPerYear;\n    address nftCollection;\n    uint256 membershipId;\n    bool active;\n}\n"}, "contracts/structs/MembershipStruct.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @dev Membership Structure stores membership data of a member\n * @param user address of the user who has a membership\n * @param membershipStarted uint256 timestamp of when the membership began\n * @param membershipEnded uint256 timestamp of when membership expires\n * @param payedAmount uint256 amount in wei paid for the membership\n * @param active bool status of the user's membership\n * @param membershipId uint256 id of the membershipPlan this was created for\n * @param updatesPerYear uint256 how many updates per year left for the user\n * @param nftCollection address of the nft collection granting a membership or address(0)\n * @param uid string of the identifier of the user across the dApp\n *\n */\nstruct MembershipStruct {\n    address user;\n    uint256 membershipStarted;\n    uint256 membershipEnded;\n    uint256 payedAmount;\n    bool active;\n    uint256 membershipId;\n    uint256 updatesPerYear;\n    address nftCollection;\n    string uid;\n}\n"}, "@openzeppelin/contracts/utils/Context.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"}, "contracts/factories/AssetStoreFactory.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"../interfaces/IBlacklist.sol\";\nimport \"../interfaces/IMembershipFactory.sol\";\nimport \"../interfaces/IProtocolDirectory.sol\";\nimport \"../structs/MembershipPlansStruct.sol\";\nimport \"../AssetsStore.sol\";\nimport \"../libraries/Errors.sol\";\n\n//DEV\n//\n\n/**\n * @title AssetStoreFactory\n * This contract will deploy AssetStore contracts for users.\n * Users will pass approvals to that contract and this\n * contract will update state with details and track who has\n * which contracts\n *\n *\n */\ncontract AssetStoreFactory is\n    IAssetStoreFactory,\n    Initializable,\n    OwnableUpgradeable\n{\n    /// @dev Storing all AssetStore Contract Addresses\n    address[] private AssetStoreContractAddresses;\n\n    /// @dev ProtocolDirectory location\n    address private directoryContract;\n\n    /// @dev Mapping User to a Specific Contract Address\n    mapping(string => address) private UserToAssetStoreContract;\n\n    /**\n     * @dev event AssetStoreCreated\n     * @param user address the AssetStore was deployed on behalf of\n     * @param assetStoreAddress address of the dpeloyed contract\n     * @param uid string identifier for the user across the dApp\n     *\n     */\n    event AssetStoreCreated(\n        address user,\n        address assetStoreAddress,\n        string uid\n    );\n\n    /**\n     * @dev initialize - Initializes the function for Ownable and Reentrancy.\n     * @param _directoryContract - to the protocol directory contract\n     *\n     */\n    function initialize(address _directoryContract) external initializer {\n        __Context_init_unchained();\n        __Ownable_init();\n        directoryContract = _directoryContract;\n    }\n\n    /**\n     * @dev Function to deployAssetStore for each user\n     * @param _uid string identifier of the user across the dApp\n     * @param _user address of the user deploying the AssetStore\n     *\n     */\n    function deployAssetStore(string memory _uid, address _user) external {\n        address IBlacklistUsersAddress = IProtocolDirectory(directoryContract)\n            .getBlacklistContract();\n        IBlacklist(IBlacklistUsersAddress).checkIfAddressIsBlacklisted(_user);\n        address _userAddress = UserToAssetStoreContract[_uid];\n        if (_userAddress != address(0)) {\n            revert(Errors.ASF_HAS_AS);\n        }\n\n        IMember(IProtocolDirectory(directoryContract).getMemberContract())\n            .checkUIDofSender(_uid, _user);\n        address IMembershipFactoryAddress = IProtocolDirectory(\n            directoryContract\n        ).getMembershipFactory();\n        IMembershipFactory _membershipFactory = IMembershipFactory(\n            IMembershipFactoryAddress\n        );\n        if (_membershipFactory.getUserMembershipAddress(_uid) == address(0)) {\n            revert(Errors.ASF_NO_MEMBERSHIP_CONTRACT);\n        }\n        address _membershipAddress = _membershipFactory\n            .getUserMembershipAddress(_uid);\n        AssetsStore assetStore = new AssetsStore(\n            directoryContract,\n            _membershipAddress\n        );\n        AssetStoreContractAddresses.push(address(assetStore));\n        UserToAssetStoreContract[_uid] = address(assetStore);\n\n        emit AssetStoreCreated(_user, address(assetStore), _uid);\n    }\n\n    /**\n     * @dev Function to return assetStore Address of a specific user\n     * @param _uid string identifier for the user across the dApp\n     * @return address of the AssetStore for given user\n     */\n    function getAssetStoreAddress(string memory _uid)\n        external\n        view\n        returns (address)\n    {\n        return UserToAssetStoreContract[_uid];\n    }\n}\n"}, "contracts/interfaces/IBlacklist.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @title IBlacklist\n * @dev To interact with Blacklist Users Contracts\n */\ninterface IBlacklist {\n    /**\n     * @dev checkIfAddressIsBlacklisted\n     * @param _user address of wallet to check is blacklisted\n     *\n     */\n    function checkIfAddressIsBlacklisted(address _user) external view;\n\n    /**\n     * @dev Function to get blacklisted addresses\n     * @return blackListAddresses address[]\n     *\n     */\n    function getBlacklistedAddresses() external view returns (address[] memory);\n}\n"}, "contracts/interfaces/IMembershipFactory.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"../structs/MembershipPlansStruct.sol\";\n\n/**\n * @title Interface for IMembershipFactory to interact with Membership Factory\n *\n */\ninterface IMembershipFactory {\n    /**\n     * @dev Function to createMembership by deploying membership contract for a specific member\n     * @param uid string identifier of a user across the dApp\n     * @param _membershipId uint256 id of the chosen membership plan\n     * @param _walletAddress address of the user creating the membership\n     *\n     */\n    function createMembership(\n        string calldata uid,\n        uint256 _membershipId,\n        address _walletAddress\n    ) external payable;\n\n    /**\n     * @dev Function to create Membership for a member with supporting NFTs\n     * @param uid string identifier of the user across the dApp\n     * @param _contractAddress address of the NFT granting membership\n     * @param _NFTType string type of NFT for granting membership i.e. ERC721 | ERC1155\n     * @param tokenId uint256 tokenId of the owned nft to verify ownership\n     * @param _walletAddress address of the user creating a membership with their nft\n     *\n     */\n    function createMembershipSupportingNFT(\n        string calldata uid,\n        address _contractAddress,\n        string memory _NFTType,\n        uint256 tokenId,\n        address _walletAddress\n    ) external payable;\n\n    /**\n     * @dev function to get all membership plans\n     * @return membershipPlan[] a list of all membershipPlans on the contract\n     *\n     */\n    function getAllMembershipPlans()\n        external\n        view\n        returns (membershipPlan[] memory);\n\n    /**\n     * @dev function to getCostOfMembershipPlan\n     * @param _membershipId uint256 id of specific plan to retrieve\n     * @return membershipPlan struct\n     *\n     */\n    function getMembershipPlan(uint256 _membershipId)\n        external\n        view\n        returns (membershipPlan memory);\n\n    /**\n     * @dev Function to get updates per year cost\n     * @return uint256 cost of updating membership in wei\n     *\n     */\n    function getUpdatesPerYearCost() external view returns (uint256);\n\n    /**\n     * @dev Function to set new membership plan for user\n     * @param _uid string identifing the user across the dApp\n     * @param _membershipId uint256 id of the membership for the user\n     *\n     */\n    function setUserForMembershipPlan(string memory _uid, uint256 _membershipId)\n        external;\n\n    /**\n     * @dev Function to transfer eth to specific pool\n     *\n     */\n    function transferToPool() external payable;\n\n    /**\n     * @dev Function to return users membership contract address\n     * @param _uid string identifier of a user across the dApp\n     * @return address of the membership contract if exists for the _uid\n     *\n     */\n    function getUserMembershipAddress(string memory _uid)\n        external\n        view\n        returns (address);\n}\n"}, "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"}, "contracts/utils/WhitelistUsers.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../interfaces/IWhitelist.sol\";\n\n/**\n * @title WhitelistUsers Contract\n * This contract contains information of which users are whitelisted\n * to interact with factory contracts and the rest of the protocol\n *\n *\n */\ncontract WhitelistUsers is\n    IWhitelist,\n    Initializable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    /**\n     * @dev initialize - Initializes the function for Ownable and Reentrancy.\n     * @param _duration uint256 how long the membership is for whitelisted users\n     * @param _updates uint256 representing how many updates whitelist users get\n     *\n     */\n    function initialize(uint256 _duration, uint256 _updates)\n        public\n        initializer\n    {\n        __Context_init_unchained();\n        __Ownable_init();\n        __ReentrancyGuard_init();\n\n        whiteListUpdatesPerYear = _updates;\n        whiteListDuration = _duration;\n    }\n\n    /// @dev whitelisted addresses\n    address[] private whiteListAddresses;\n\n    /// @dev whiteList duration\n    uint256 whiteListDuration;\n\n    /// @dev whiteList UpdatesPerYear given\n    uint256 whiteListUpdatesPerYear;\n\n    /**\n     * @dev Function to get whitelisted addresses\n     * @return list of addresses on the whitelist\n     *\n     */\n    function getWhitelistAddress() external view returns (address[] memory) {\n        return whiteListAddresses;\n    }\n\n    /**\n     * @dev checkIfAddressIsWhitelisted\n     * @param _user address of the user to verify is on the list\n     * @return whitelisted boolean representing if the input is whitelisted\n     *\n     */\n    function checkIfAddressIsWhitelisted(address _user)\n        external\n        view\n        returns (bool whitelisted)\n    {\n        for (uint256 i = 0; i < whiteListAddresses.length; i++) {\n            if (whiteListAddresses[i] == _user) {\n                return whitelisted = true;\n            }\n        }\n        whitelisted = false;\n    }\n\n    /**\n     * @dev addWhiteList\n     * @param _user address of the wallet to whitelist\n     *\n     */\n    function addWhiteList(address _user) external onlyOwner {\n        whiteListAddresses.push(_user);\n    }\n\n    /**\n     * @dev removeWhiteList\n     * @param _user address of the wallet to remove from the whitelist\n     *\n     */\n    function removeWhiteList(address _user) external onlyOwner {\n        for (uint256 i; i < whiteListAddresses.length; i++) {\n            if (whiteListAddresses[i] == _user) {\n                whiteListAddresses[i] = whiteListAddresses[\n                    whiteListAddresses.length - 1\n                ];\n                whiteListAddresses.pop();\n                break;\n            }\n        }\n    }\n\n    /**\n     * @dev getWhitelistUpdatesPerYear\n     * @return whiteListUpdatesPerYear uint256 for how many updates the whitelisted gets\n     *\n     */\n    function getWhitelistUpdatesPerYear() external view returns (uint256) {\n        return whiteListUpdatesPerYear;\n    }\n\n    /**\n     * @dev getWhitelistDuration\n     * @return whiteListDuration uint256 of how long the membership is for whitelisted users\n     */\n    function getWhitelistDuration() external view returns (uint256) {\n        return whiteListDuration;\n    }\n\n    /**\n     * @dev setWhitelistUpdatesPerYear\n     * @param _updatesPerYear uint256 set how many updates a whitelisted user gets within a year\n     *\n     */\n    function setWhitelistUpdatesPerYear(uint256 _updatesPerYear)\n        external\n        onlyOwner\n    {\n        whiteListUpdatesPerYear = _updatesPerYear;\n    }\n\n    /**\n     * @dev setWhitelistDuration\n     * @param _duration uint256 change the value of how long whitelisted memberships are\n     */\n    function setWhitelistDuration(uint256 _duration) external onlyOwner {\n        whiteListDuration = _duration;\n    }\n}\n"}, "contracts/interfaces/IWhitelist.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @title Interface for IWhitelist to interact with Whitelist Users Contracts\n *\n */\ninterface IWhitelist {\n    /**\n     * @dev getWhitelistUpdatesPerYear\n     * @return whiteListUpdatesPerYear uint256 for how many updates the whitelisted gets\n     *\n     */\n    function getWhitelistUpdatesPerYear() external view returns (uint256);\n\n    /**\n     * @dev getWhitelistDuration\n     * @return whiteListDuration uint256 of how long the membership is for whitelisted users\n     */\n    function getWhitelistDuration() external view returns (uint256);\n\n    /**\n     * @dev checkIfAddressIsWhitelisted\n     * @param _user address of the user to verify is on the list\n     * @return whitelisted boolean representing if the input is whitelisted\n     *\n     */\n    function checkIfAddressIsWhitelisted(address _user)\n        external\n        view\n        returns (bool whitelisted);\n\n    /**\n     * @dev Function to get whitelisted addresses\n     * @return list of addresses on the whitelist\n     *\n     */\n    function getWhitelistAddress() external view returns (address[] memory);\n}\n"}, "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.30;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"}, "contracts/utils/BlacklistUsers.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../interfaces/IBlacklist.sol\";\nimport \"../libraries/Errors.sol\";\n\n/**\n * @title Blacklist\n * Contract storing addresses of users who are not able\n * to interact with the ecosystem at certain points\n *\n */\ncontract Blacklist is\n    IBlacklist,\n    Initializable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    /**\n     * @dev initialize - Initializes the function for Ownable and Reentrancy.\n     */\n    function initialize() public initializer {\n        __Context_init_unchained();\n        __Ownable_init();\n        __ReentrancyGuard_init();\n    }\n\n    /// @dev blacklisted addresses list\n    address[] private blackListAddresses;\n\n    /**\n     * @dev Function to get blacklisted addresses\n     * @return blackListAddresses address[]\n     *\n     */\n    function getBlacklistedAddresses()\n        external\n        view\n        returns (address[] memory)\n    {\n        return blackListAddresses;\n    }\n\n    /**\n     * @dev checkIfAddressIsBlacklisted\n     * @param _user address of wallet to check is blacklisted\n     *\n     */\n    function checkIfAddressIsBlacklisted(address _user) external view {\n        for (uint256 i = 0; i < blackListAddresses.length; i++) {\n            if (blackListAddresses[i] == _user) {\n                revert(Errors.BL_BLACKLISTED);\n            }\n        }\n    }\n\n    /**\n     * @dev Function to add new wallet to blacklist\n     * @param _user address of new blacklisted wallet\n     *\n     */\n    function addBlacklist(address _user) external onlyOwner {\n        blackListAddresses.push(_user);\n    }\n\n    /**\n     * @dev Function to remove blacklist\n     * @param _user address of user to remove from the list\n     *\n     */\n    function removeBlacklist(address _user) external onlyOwner {\n        for (uint256 i; i < blackListAddresses.length; i++) {\n            if (blackListAddresses[i] == _user) {\n                blackListAddresses[i] = blackListAddresses[\n                    blackListAddresses.length - 1\n                ];\n                blackListAddresses.pop();\n                break;\n            }\n        }\n    }\n}\n"}, "contracts/factories/MembershipFactory.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../Membership.sol\";\nimport \"../interfaces/IMembershipFactory.sol\";\nimport \"../interfaces/IProtocolDirectory.sol\";\nimport \"../interfaces/IWhitelist.sol\";\nimport \"../structs/MembershipPlansStruct.sol\";\nimport \"../libraries/Errors.sol\";\n\n//DEV\n//\n\n/**\n * @title MembershipFactory\n * This contract is responsible for deploying Membership contracts\n * on behalf of users within the ecosystem. This contract also contains\n * information to keep track of deployed contracts and versions/ status\n *\n */\ncontract MembershipFactory is\n    IMembershipFactory,\n    Initializable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    /// @dev storing all addresses of membership plans\n    address[] private membershipPlanAddresses;\n\n    /// @dev Directory contract address\n    address private directoryContract;\n\n    /// @dev Variable to provide membershipId for user\n    uint256 private membershipId;\n\n    /// @dev Fixed cost for updatesPerYear\n    uint256 private updatesPerYearCost;\n\n    /// @dev Storing all membership factory states\n    Membership[] private memberships;\n\n    /// @dev storing all membership plans\n    membershipPlan[] private membershipPlans;\n\n    /// @dev  Mapping specific user to a membership plan id ; each user can have only one membership plan\n    mapping(string => uint256) private UserToMembershipPlan;\n\n    /// @dev Mapping specific plan to a membershipID\n    mapping(uint256 => membershipPlan) private membershipIdtoPlan;\n\n    /// @dev Mapping user to factory address of membership\n    mapping(string => address) private UserToMembershipContract;\n\n    /**\n     * @dev event MembershipContractCreated\n     *\n     * @param membershipContractAddress address of the deployed membership contract\n     * @param user address of the user the membership belongs to\n     * @param uid string identifier of the user across the dApp\n     * @param membershipCreatedDate uint256 timestamp of when the contract was deployed\n     * @param membershipEndDate uint256 timestamp of when the membership expires\n     * @param membershipId uint256 identifier of the specific membership the user got\n     * @param updatesPerYear uint256 how many updates the user can use in a year\n     * @param collectionAddress address of the nft membership contract if any or address(0)\n     *\n     */\n    event MembershipContractCreated(\n        address membershipContractAddress,\n        address user,\n        string uid,\n        uint256 membershipCreatedDate,\n        uint256 membershipEndDate,\n        uint256 membershipId,\n        uint256 updatesPerYear,\n        address collectionAddress\n    );\n\n    /**\n     * @dev initialize - Initializes the function for Ownable and Reentrancy.\n     * @param _directoryContract address of the protocol directory\n     *\n     */\n    function initialize(address _directoryContract) public initializer {\n        __Context_init_unchained();\n        __Ownable_init();\n        __ReentrancyGuard_init();\n        directoryContract = _directoryContract;\n        membershipId = 0;\n        updatesPerYearCost = 3e17;\n    }\n\n    /**\n     * @dev Function to return users membership contract address\n     * @param _uid string identifier of a user across the dApp\n     * @return address of the membership contract if exists for the _uid\n     *\n     */\n    function getUserMembershipAddress(string memory _uid)\n        external\n        view\n        returns (address)\n    {\n        return UserToMembershipContract[_uid];\n    }\n\n    /**\n     * @dev Function to createMembership by deploying membership contract for a specific member\n     * @param uid string identifier of a user across the dApp\n     * @param _membershipId uint256 id of the chosen membership plan\n     * @param _walletAddress address of the user creating the membership\n     *\n     */\n    function createMembership(\n        string calldata uid,\n        uint256 _membershipId,\n        address _walletAddress\n    ) external payable nonReentrant {\n        membershipPlan memory _membershipPlan = membershipIdtoPlan[\n            _membershipId\n        ];\n        address IMemberAddress = IProtocolDirectory(directoryContract)\n            .getMemberContract();\n        address _whitelistaddress = IProtocolDirectory(directoryContract)\n            .getWhitelistContract();\n\n        uint256 _createdDate = block.timestamp;\n        uint256 _endedDate = block.timestamp +\n            _membershipPlan.membershipDuration;\n        bool _whitelistStatus = IWhitelist(_whitelistaddress)\n            .checkIfAddressIsWhitelisted(_walletAddress);\n        uint256 _updatesPerYear = _membershipPlan.updatesPerYear;\n        if (_whitelistStatus == true) {\n            _endedDate =\n                block.timestamp +\n                IWhitelist(_whitelistaddress).getWhitelistDuration();\n            _updatesPerYear = IWhitelist(_whitelistaddress)\n                .getWhitelistUpdatesPerYear();\n        } else {\n            if (msg.value != _membershipPlan.costOfMembership) {\n                revert(Errors.MF_NEED_MORE_DOUGH);\n            }\n        }\n\n        if (\n            (IMember(IMemberAddress).checkIfUIDExists(_walletAddress) == false)\n        ) {\n            IMember(IMemberAddress).createMember(uid, _walletAddress);\n        }\n        if (UserToMembershipContract[uid] != address(0)) {\n            revert(Errors.MF_HAS_MEMBERSHIP_CONTRACT);\n        }\n        if (!_membershipPlan.active) {\n            revert(Errors.MF_INACTIVE_PLAN);\n        }\n\n        Membership _membership = new Membership(\n            uid,\n            directoryContract,\n            _walletAddress,\n            _createdDate,\n            _endedDate,\n            _membershipPlan.membershipId,\n            _updatesPerYear,\n            msg.value,\n            _membershipPlan.nftCollection\n        );\n        memberships.push(_membership);\n        UserToMembershipPlan[uid] = membershipId;\n        UserToMembershipContract[uid] = address(_membership);\n        membershipPlanAddresses.push(address(_membership));\n\n        IMember(IMemberAddress).setIMembershipAddress(\n            uid,\n            address(_membership)\n        );\n\n        emit MembershipContractCreated(\n            address(_membership),\n            _walletAddress,\n            uid,\n            _createdDate,\n            _endedDate,\n            _membershipId,\n            _updatesPerYear,\n            address(0)\n        );\n        if (_whitelistStatus == false) {\n            payable(IProtocolDirectory(directoryContract).getTransferPool())\n                .transfer(msg.value);\n        }\n    }\n\n    /**\n     * @dev Function to create Membership for a member with supporting NFTs\n     * @param uid string identifier of the user across the dApp\n     * @param _contractAddress address of the NFT granting membership\n     * @param _NFTType string type of NFT for granting membership i.e. ERC721 | ERC1155\n     * @param tokenId uint256 tokenId of the owned nft to verify ownership\n     * @param _walletAddress address of the user creating a membership with their nft\n     *\n     */\n    function createMembershipSupportingNFT(\n        string calldata uid,\n        address _contractAddress,\n        string memory _NFTType,\n        uint256 tokenId,\n        address _walletAddress\n    ) external payable nonReentrant {\n        address IMemberAddress = IProtocolDirectory(directoryContract)\n            .getMemberContract();\n\n        if ((IMember(IMemberAddress).checkIfUIDExists(msg.sender) == false)) {\n            IMember(IMemberAddress).createMember(uid, _walletAddress);\n        }\n\n        if (UserToMembershipContract[uid] != address(0)) {\n            revert(Errors.MF_HAS_MEMBERSHIP_CONTRACT);\n        }\n\n        uint256 _amount = msg.value;\n\n        for (uint256 i = 0; i < membershipPlans.length; i++) {\n            if (membershipPlans[i].nftCollection == _contractAddress) {\n                IMember(IMemberAddress).checkIfWalletHasNFT(\n                    _contractAddress,\n                    _NFTType,\n                    tokenId,\n                    _walletAddress\n                );\n\n                membershipPlan memory _membershipPlan = membershipIdtoPlan[\n                    membershipPlans[i].membershipId\n                ];\n                if (!_membershipPlan.active) {\n                    revert(Errors.MF_INACTIVE_PLAN);\n                }\n                if (_amount != _membershipPlan.costOfMembership) {\n                    revert(Errors.MF_NEED_MORE_DOUGH);\n                }\n\n                uint256 _createdDate = block.timestamp;\n                uint256 _endedDate = block.timestamp +\n                    _membershipPlan.membershipDuration;\n\n                Membership _membership = new Membership(\n                    uid,\n                    directoryContract,\n                    _walletAddress,\n                    _createdDate,\n                    _endedDate,\n                    _membershipPlan.membershipId,\n                    _membershipPlan.updatesPerYear,\n                    _amount,\n                    _membershipPlan.nftCollection\n                );\n                memberships.push(_membership);\n                UserToMembershipPlan[uid] = _membershipPlan.membershipId;\n                UserToMembershipContract[uid] = address(_membership);\n                membershipPlanAddresses.push(address(_membership));\n                payable(IProtocolDirectory(directoryContract).getTransferPool())\n                    .transfer(_amount);\n                emit MembershipContractCreated(\n                    address(_membership),\n                    _walletAddress,\n                    uid,\n                    _createdDate,\n                    _endedDate,\n                    _membershipPlan.membershipId,\n                    _membershipPlan.updatesPerYear,\n                    _contractAddress\n                );\n                break;\n            }\n        }\n    }\n\n    /**\n     * @dev Function to create a membership plan with an NFT or without\n     * If no collection provide address(0) for _collection\n     * @param _duration uint256 value of how long the membership is valid\n     * @param _updatesPerYear uint256 how many times in a year can the membership be updated\n     * @param _cost uint256 cost in wei of the membership\n     * @param _collection address of the NFT to create a membershipPlan or address(0)\n     *\n     */\n    function createMembershipPlan(\n        uint256 _duration,\n        uint256 _updatesPerYear,\n        uint256 _cost,\n        address _collection\n    ) external onlyOwner {\n        if (_collection == address(0)) {\n            membershipPlan memory _membershipPlan = membershipPlan(\n                _duration,\n                _cost,\n                _updatesPerYear,\n                address(0),\n                ++membershipId,\n                true\n            );\n            membershipIdtoPlan[membershipId] = _membershipPlan;\n            membershipPlans.push(_membershipPlan);\n        } else {\n            membershipPlan memory _membershipPlan = membershipPlan(\n                _duration,\n                _cost,\n                _updatesPerYear,\n                _collection,\n                ++membershipId,\n                true\n            );\n            membershipIdtoPlan[membershipId] = _membershipPlan;\n            membershipPlans.push(_membershipPlan);\n        }\n    }\n\n    /**\n     * @dev function to make membership plan active/inactive\n     * @param _active bool representing if the membershipPlan can be used to create new contracts\n     * @param _membershipId uint256 id of the membershipPlan to activate\n     *\n     */\n    function setMembershipPlanActive(bool _active, uint256 _membershipId)\n        external\n        onlyOwner\n    {\n        for (uint256 i = 0; i < membershipPlans.length; i++) {\n            if (membershipPlans[i].membershipId == _membershipId) {\n                membershipPlans[i].active = _active;\n            }\n        }\n    }\n\n    /**\n     * @dev function to get active/inactive status of membershipplan\n     * @param _membershipId uint256 id of a membershipPlan\n     * @return isActive a bool describing its status\n     *\n     */\n    function getMembershipPlanActive(uint256 _membershipId)\n        external\n        view\n        returns (bool isActive)\n    {\n        for (uint256 i = 0; i < membershipPlans.length; i++) {\n            if (membershipPlans[i].membershipId == _membershipId) {\n                isActive = membershipPlans[i].active;\n            }\n        }\n    }\n\n    /**\n     * @dev function to get all membership plans\n     * @return membershipPlan[] a list of all membershipPlans on the contract\n     *\n     */\n    function getAllMembershipPlans()\n        external\n        view\n        returns (membershipPlan[] memory)\n    {\n        return membershipPlans;\n    }\n\n    /**\n     * @dev function to getCostOfMembershipPlan\n     * @param _membershipId uint256 id of specific plan to retrieve\n     * @return membershipPlan struct\n     *\n     */\n    function getMembershipPlan(uint256 _membershipId)\n        external\n        view\n        returns (membershipPlan memory)\n    {\n        return membershipIdtoPlan[_membershipId];\n    }\n\n    /**\n     * @dev Function to get updates per year cost\n     * @return uint256 cost of updating membership in wei\n     *\n     */\n    function getUpdatesPerYearCost() external view returns (uint256) {\n        return updatesPerYearCost;\n    }\n\n    /**\n     * @dev Function to set new updates per year cost\n     * @param _newCost uint256 in wei, how much updating the membership will be\n     *\n     */\n    function setUpdatesPerYearCost(uint256 _newCost) external onlyOwner {\n        updatesPerYearCost = _newCost;\n    }\n\n    /**\n     * @dev Function to set new membership plan for user\n     * @param _uid string identifing the user across the dApp\n     * @param _membershipId uint256 id of the membership for the user\n     *\n     */\n    function setUserForMembershipPlan(string memory _uid, uint256 _membershipId)\n        external\n    {\n        UserToMembershipPlan[_uid] = _membershipId;\n    }\n\n    /**\n     * @dev Function to transfer eth to specific pool\n     *\n     */\n    function transferToPool() external payable {\n        address transferPoolAddress = IProtocolDirectory(directoryContract)\n            .getTransferPool();\n        payable(transferPoolAddress).transfer(msg.value);\n    }\n}\n"}, "contracts/Membership.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"./interfaces/IMember.sol\";\nimport \"./interfaces/IMembership.sol\";\nimport \"./interfaces/IMembershipFactory.sol\";\nimport \"./interfaces/IProtocolDirectory.sol\";\nimport \"./interfaces/IBlacklist.sol\";\nimport \"./structs/MembershipStruct.sol\";\n\nimport \"./libraries/Errors.sol\";\n\n//DEV\n\n/**\n * @title Membership Contract\n * @notice contract deployed 1:1 per User wanting a membership with Webacy\n * contains data and information for interacting within the suite of products onchain\n *\n */\n\ncontract Membership is IMembership, ReentrancyGuard {\n    // Support multiple ERC20 tokens\n\n    // Membership Information of a specific user\n    mapping(string => MembershipStruct) private membershipInfoOfAddress;\n\n    address private directoryAddress;\n\n    /**\n     * @dev membershipUpdated event\n     * @param membershipContractAddress address of the membershipContract emitting event\n     * @param user address of user associated with this membership\n     * @param uid string identifier of user across dApp\n     * @param membershipCreatedDate uint256 timestamp of the membership being created\n     * @param membershipEndDate uint256 timestamp of the set time to expire membership\n     * @param membershipId uint256 id of the type of membership purchased\n     * @param updatesPerYear uint256 the number of updates a user may have within 1 year\n     * @param collectionAddress address of NFT granting membership to a user\n     *\n     */\n    event membershipUpdated(\n        address membershipContractAddress,\n        address user,\n        string uid,\n        uint256 membershipCreatedDate,\n        uint256 membershipEndDate,\n        uint256 membershipId,\n        uint256 updatesPerYear,\n        address collectionAddress\n    );\n\n    /**\n     * @dev initialize - Initializes the function for Ownable and Reentrancy.\n     * @param uid string identifier of user across dApp\n     * @param _directoryAddress address of protocol directory contract\n     * @param _userAddress address of the user attached to this membership contract\n     * @param _membershipStartDate uint256 beginning timestamp of the membership\n     * @param _membershipEndedDate uint256 expiry timestamp of the membership\n     * @param _membershipId uint256 id of the type of membership purchased\n     * @param updatesPerYear uint256 number of times within a year the membership can be updated\n     * @param _membershipPayedAmount uint256 cost of membership initally\n     * @param nftCollection address of asset for granting membership\n     *\n     */\n    constructor(\n        string memory uid,\n        address _directoryAddress,\n        address _userAddress,\n        uint256 _membershipStartDate,\n        uint256 _membershipEndedDate,\n        uint256 _membershipId,\n        uint256 updatesPerYear,\n        uint256 _membershipPayedAmount,\n        address nftCollection\n    ) {\n        directoryAddress = _directoryAddress;\n        address IMemberAddress = IProtocolDirectory(_directoryAddress)\n            .getMemberContract();\n        if ((IMember(IMemberAddress).checkIfUIDExists(_userAddress) == false)) {\n            IMember(IMemberAddress).createMember(uid, _userAddress);\n        }\n\n        MembershipStruct memory _membership = MembershipStruct(\n            _userAddress,\n            _membershipStartDate,\n            _membershipEndedDate,\n            _membershipPayedAmount,\n            true,\n            _membershipId,\n            updatesPerYear,\n            nftCollection,\n            uid\n        );\n        membershipInfoOfAddress[uid] = _membership;\n    }\n\n    /**\n     * @notice Function to return membership information of the user\n     * @param _uid string identifier of user across dApp\n     * @return MembershipStruct containing information of the specific user's membership\n     *\n     */\n    function getMembership(string memory _uid)\n        external\n        view\n        returns (MembershipStruct memory)\n    {\n        return membershipInfoOfAddress[_uid];\n    }\n\n    /**\n     * @dev Function to check of membership is active for the user\n     * @param _uid string identifier of user across dApp\n     * @return bool boolean representing if the membership has expired\n     *\n     */\n    function checkIfMembershipActive(string memory _uid)\n        public\n        view\n        returns (bool)\n    {\n        return membershipInfoOfAddress[_uid].membershipEnded > block.timestamp;\n    }\n\n    /**\n     * @dev renewmembership Function to renew membership of the user\n     * @param _uid string identifier of the user renewing membership\n     *\n     *\n     */\n    function renewMembership(string memory _uid) external payable nonReentrant {\n        IBlacklist(IProtocolDirectory(directoryAddress).getBlacklistContract())\n            .checkIfAddressIsBlacklisted(msg.sender);\n        MembershipStruct storage _membership = membershipInfoOfAddress[_uid];\n        IMember(IProtocolDirectory(directoryAddress).getMemberContract())\n            .checkUIDofSender(_uid, msg.sender);\n        address IMembershipFactoryAddress = IProtocolDirectory(directoryAddress)\n            .getMembershipFactory();\n        membershipPlan memory _membershipPlan = IMembershipFactory(\n            IMembershipFactoryAddress\n        ).getMembershipPlan(_membership.membershipId);\n\n        if (!_membershipPlan.active) {\n            revert(Errors.MS_INACTIVE);\n        }\n\n        if (msg.value != _membershipPlan.costOfMembership) {\n            revert(Errors.MS_NEED_MORE_DOUGH);\n        }\n\n        _membership.membershipEnded =\n            block.timestamp +\n            _membershipPlan.membershipDuration;\n        _membership.payedAmount = msg.value;\n        _membership.updatesPerYear =\n            _membership.updatesPerYear +\n            _membershipPlan.updatesPerYear;\n\n        IMembershipFactory(IMembershipFactoryAddress).transferToPool{\n            value: msg.value\n        }();\n        emit membershipUpdated(\n            address(this),\n            _membership.user,\n            _membership.uid,\n            _membership.membershipStarted,\n            _membership.membershipEnded,\n            _membership.membershipId,\n            _membership.updatesPerYear,\n            _membership.nftCollection\n        );\n    }\n\n    /**\n     * @dev renewmembershipNFT - Function to renew membership for users that have NFTs\n     * @param _contractAddress address of nft to approve renewing\n     * @param _NFTType string type of NFT i.e. ERC20 | ERC1155 | ERC721\n     * @param tokenId uint256 tokenId being protected\n     * @param _uid string identifier of the user renewing membership\n     *\n     */\n    function renewMembershipNFT(\n        address _contractAddress,\n        string memory _NFTType,\n        uint256 tokenId,\n        string memory _uid\n    ) external payable nonReentrant {\n        IBlacklist(IProtocolDirectory(directoryAddress).getBlacklistContract())\n            .checkIfAddressIsBlacklisted(msg.sender);\n        address IMemberAddress = IProtocolDirectory(directoryAddress)\n            .getMemberContract();\n        IMember(IProtocolDirectory(directoryAddress).getMemberContract())\n            .checkUIDofSender(_uid, msg.sender);\n        address IMembershipFactoryAddress = IProtocolDirectory(directoryAddress)\n            .getMembershipFactory();\n        IMember(IMemberAddress).checkIfWalletHasNFT(\n            _contractAddress,\n            _NFTType,\n            tokenId,\n            msg.sender\n        );\n        MembershipStruct storage _membership = membershipInfoOfAddress[_uid];\n        membershipPlan memory _membershipPlan = IMembershipFactory(\n            IMembershipFactoryAddress\n        ).getMembershipPlan(_membership.membershipId);\n\n        if (!_membershipPlan.active) {\n            revert(Errors.MS_INACTIVE);\n        }\n\n        if (msg.value != _membershipPlan.costOfMembership) {\n            revert(Errors.MS_NEED_MORE_DOUGH);\n        }\n\n        _membership.membershipEnded =\n            block.timestamp +\n            _membershipPlan.membershipDuration;\n        _membership.payedAmount = msg.value;\n        _membership.updatesPerYear =\n            _membership.updatesPerYear +\n            _membershipPlan.updatesPerYear;\n\n        IMembershipFactory(IMembershipFactoryAddress).transferToPool{\n            value: msg.value\n        }();\n\n        emit membershipUpdated(\n            address(this),\n            _membership.user,\n            _membership.uid,\n            _membership.membershipStarted,\n            _membership.membershipEnded,\n            _membership.membershipId,\n            _membership.updatesPerYear,\n            _membership.nftCollection\n        );\n    }\n\n    /**\n     * @dev Function to top up updates\n     * @param _uid string identifier of the user across the dApp\n     *\n     */\n    function topUpUpdates(string memory _uid) external payable nonReentrant {\n        IBlacklist(IProtocolDirectory(directoryAddress).getBlacklistContract())\n            .checkIfAddressIsBlacklisted(msg.sender);\n        address IMembershipFactoryAddress = IProtocolDirectory(directoryAddress)\n            .getMembershipFactory();\n        MembershipStruct storage _membership = membershipInfoOfAddress[_uid];\n        IMember(IProtocolDirectory(directoryAddress).getMemberContract())\n            .checkUIDofSender(_uid, msg.sender);\n        uint256 _updateCost = IMembershipFactory(IMembershipFactoryAddress)\n            .getUpdatesPerYearCost();\n\n        if (msg.value < _updateCost) {\n            revert(Errors.MS_NEED_MORE_DOUGH);\n        }\n\n        _membership.updatesPerYear = _membership.updatesPerYear + 1;\n\n        IMembershipFactory(IMembershipFactoryAddress).transferToPool{\n            value: msg.value\n        }();\n\n        emit membershipUpdated(\n            address(this),\n            _membership.user,\n            _membership.uid,\n            _membership.membershipStarted,\n            _membership.membershipEnded,\n            _membership.membershipId,\n            _membership.updatesPerYear,\n            _membership.nftCollection\n        );\n    }\n\n    /**\n     * @notice changeMembershipPlan\n     * Ability to change membership plan for a member given a membership ID and member UID.\n     * It is a payable function given the membership cost for the membership plan.\n     *\n     * @param membershipId uint256 id of membership plan changing to\n     * @param _uid string identifier of the user\n     */\n    function changeMembershipPlan(uint256 membershipId, string memory _uid)\n        external\n        payable\n        nonReentrant\n    {\n        IBlacklist(IProtocolDirectory(directoryAddress).getBlacklistContract())\n            .checkIfAddressIsBlacklisted(msg.sender);\n        address IMembershipFactoryAddress = IProtocolDirectory(directoryAddress)\n            .getMembershipFactory();\n        membershipPlan memory _membershipPlan = IMembershipFactory(\n            IMembershipFactoryAddress\n        ).getMembershipPlan(membershipId);\n        IMember(IProtocolDirectory(directoryAddress).getMemberContract())\n            .checkUIDofSender(_uid, msg.sender);\n        if (msg.value != _membershipPlan.costOfMembership) {\n            revert(Errors.MS_NEED_MORE_DOUGH);\n        }\n\n        if (!_membershipPlan.active) {\n            revert(Errors.MS_INACTIVE);\n        }\n\n        MembershipStruct storage _membership = membershipInfoOfAddress[_uid];\n\n        _membership.membershipId = _membershipPlan.membershipId;\n        _membership.membershipEnded =\n            block.timestamp +\n            _membershipPlan.membershipDuration;\n        _membership.updatesPerYear =\n            _membership.updatesPerYear +\n            _membershipPlan.updatesPerYear;\n        _membership.payedAmount = msg.value;\n\n        IMembershipFactory(IMembershipFactoryAddress).setUserForMembershipPlan(\n            _uid,\n            _membershipPlan.membershipId\n        );\n\n        IMembershipFactory(IMembershipFactoryAddress).transferToPool{\n            value: msg.value\n        }();\n        emit membershipUpdated(\n            address(this),\n            _membership.user,\n            _membership.uid,\n            _membership.membershipStarted,\n            _membership.membershipEnded,\n            _membership.membershipId,\n            _membership.updatesPerYear,\n            _membership.nftCollection\n        );\n    }\n\n    /**\n     * @notice changeMembershipPlanNFT - Function to change membership plan to an NFT based plan\n     * @param membershipId uint256 id of the membershipPlan changing to\n     * @param _contractAddress address of the NFT granting the membership\n     * @param _NFTType string type of NFT i.e. ERC721 | ERC1155\n     * @param tokenId uint256 tokenId of the nft to verify ownership\n     * @param _uid string identifier of the user across the dApp\n     *\n     */\n    function changeMembershipPlanNFT(\n        uint256 membershipId,\n        address _contractAddress,\n        string memory _NFTType,\n        uint256 tokenId,\n        string memory _uid\n    ) external payable {\n        IBlacklist(IProtocolDirectory(directoryAddress).getBlacklistContract())\n            .checkIfAddressIsBlacklisted(msg.sender);\n        address IMemberAddress = IProtocolDirectory(directoryAddress)\n            .getMemberContract();\n        address IMembershipFactoryAddress = IProtocolDirectory(directoryAddress)\n            .getMembershipFactory();\n        IMember(IProtocolDirectory(directoryAddress).getMemberContract())\n            .checkUIDofSender(_uid, msg.sender);\n        IMember(IMemberAddress).checkIfWalletHasNFT(\n            _contractAddress,\n            _NFTType,\n            tokenId,\n            msg.sender\n        );\n        membershipPlan memory _membershipPlan = IMembershipFactory(\n            IMembershipFactoryAddress\n        ).getMembershipPlan(membershipId);\n        if (msg.value != _membershipPlan.costOfMembership) {\n            revert(Errors.MS_NEED_MORE_DOUGH);\n        }\n\n        if (!_membershipPlan.active) {\n            revert(Errors.MS_INACTIVE);\n        }\n\n        MembershipStruct storage _membership = membershipInfoOfAddress[_uid];\n\n        _membership.membershipId = _membershipPlan.membershipId;\n        _membership.membershipEnded =\n            block.timestamp +\n            _membershipPlan.membershipDuration;\n        _membership.updatesPerYear =\n            _membership.updatesPerYear +\n            _membershipPlan.updatesPerYear;\n        _membership.payedAmount = msg.value;\n\n        IMembershipFactory(IMembershipFactoryAddress).setUserForMembershipPlan(\n            _uid,\n            _membershipPlan.membershipId\n        );\n\n        emit membershipUpdated(\n            address(this),\n            _membership.user,\n            _membership.uid,\n            _membership.membershipStarted,\n            _membership.membershipEnded,\n            _membership.membershipId,\n            _membership.updatesPerYear,\n            _membership.nftCollection\n        );\n\n        IMembershipFactory(IMembershipFactoryAddress).transferToPool{\n            value: msg.value\n        }();\n    }\n\n    /**\n     * @notice redeemUpdate\n     * @param _uid string identifier of the user across the dApp\n     *\n     * Function to claim that a membership has been updated\n     */\n    function redeemUpdate(string memory _uid) external {\n        checkIfMembershipActive(_uid);\n        MembershipStruct storage _membership = membershipInfoOfAddress[_uid];\n        _membership.updatesPerYear = _membership.updatesPerYear - 1;\n\n        emit membershipUpdated(\n            address(this),\n            _membership.user,\n            _membership.uid,\n            _membership.membershipStarted,\n            _membership.membershipEnded,\n            _membership.membershipId,\n            _membership.updatesPerYear,\n            _membership.nftCollection\n        );\n    }\n}\n"}, "contracts/Member.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/IProtocolDirectory.sol\";\nimport \"./interfaces/IMember.sol\";\nimport \"./interfaces/IMembership.sol\";\nimport \"./interfaces/IMembershipFactory.sol\";\nimport \"./interfaces/IBlacklist.sol\";\n\nimport \"./libraries/Errors.sol\";\nimport \"./libraries/TokenActions.sol\";\n\nimport \"./structs/MemberStruct.sol\";\nimport \"./structs/BackupApprovalStruct.sol\";\nimport \"./structs/MembershipStruct.sol\";\n\n/**\n * @title Member Contract\n * @notice This contract contains logic for interacting with the\n * ecosystem and verifying ownership as well as the panic button\n * functionality and backup information (BackupPlan)\n *\n */\n\ncontract Member is\n    IMember,\n    Initializable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    /**\n     * @notice memberCreated Event when creating member\n     * @param uid string of dApp identifier for a user\n     * @param dateCreated timestamp of event occurence\n     *\n     */\n    event memberCreated(string uid, uint256 dateCreated);\n\n    /**\n     * @notice Event when updating primary wallet\n     * @param uid string string of dApp identifier for a user\n     * @param dateCreated uint256 timestamap of event occuring\n     * @param wallets address[] list of wallets for the user\n     * @param primaryWallet uint256 primary wallet for assets\n     *\n     */\n    event walletUpdated(\n        string uid,\n        uint256 dateCreated,\n        address[] backUpWallets,\n        address[] wallets,\n        uint256 primaryWallet\n    );\n\n    /// @notice Mapping to return member when uid is passed\n    mapping(string => member) public members;\n\n    /// @notice Variable to store all member information\n    member[] public allMembers;\n\n    /// @notice UserMembershipAddress mapping for getting Membership contracts by user\n    mapping(string => address) private UserMembershipAddress;\n\n    /// @notice Storing ApprovalId for different approvals stored\n    uint256 private _approvalId;\n\n    /// @notice mapping for token backup Approvals for specific UID\n    mapping(string => BackUpApprovals[]) private MemberApprovals;\n\n    /**\n     * @notice Event for Querying Approvals\n     *\n     * @param uid string of dApp identifier for a user\n     * @param approvedWallet address of the wallet owning the asset\n     * @param backupaddress address[] list of addresses containing assets\n     * @param tokenId uint256 tokenId of asset being backed up\n     * @param tokenAddress address contract of the asset being protectd\n     * @param tokenType string i.e. ERC20 | ERC1155 | ERC721\n     * @param tokensAllocated uint256 number of tokens to be protected\n     * @param dateApproved uint256 timestamp of event happening\n     * @param claimed bool status of the backupApproval\n     * @param approvalId uint256 id of the approval being acted on\n     * @param claimedWallet address of receipient of assets\n     *\n     *\n     */\n    event BackUpApprovalsEvent(\n        string uid,\n        address approvedWallet,\n        address[] backupaddress,\n        uint256 tokenId,\n        address tokenAddress,\n        string tokenType,\n        uint256 tokensAllocated,\n        uint256 dateApproved,\n        bool claimed,\n        uint256 approvalId,\n        address claimedWallet\n    );\n\n    /// @dev address of the ProtocolDirectory\n    address public directoryContract;\n\n    /**\n     * @dev initialize - Initializes the function for Ownable and Reentrancy.\n     * @param _directoryContract address of protocol directory contract\n     */\n    function initialize(address _directoryContract) external initializer {\n        __Context_init_unchained();\n        __Ownable_init();\n        __ReentrancyGuard_init();\n        _approvalId = 0;\n        directoryContract = _directoryContract;\n    }\n\n    /**\n     * @notice Function to check if wallet exists in the UID\n     * @param _uid string of dApp identifier for a user\n     * @param _user address of the user checking exists\n     * Fails if not owner uid and user address do not return a wallet\n     *\n     */\n    function checkUIDofSender(string memory _uid, address _user) public view {\n        address[] memory wallets = members[_uid].wallets;\n        bool walletExists = false;\n        for (uint256 i = 0; i < wallets.length; i++) {\n            if (wallets[i] == _user) {\n                walletExists = true;\n            }\n        }\n\n        if (walletExists == false) {\n            revert(Errors.M_NOT_OWNER);\n        }\n    }\n\n    /**\n     * @dev checkIfUIDExists\n     * Check if user exists for specific wallet address already internal function\n     * @param _walletAddress wallet address of the user\n     * @return _exists - A boolean if user exists or not\n     *\n     */\n    function checkIfUIDExists(address _walletAddress)\n        public\n        view\n        returns (bool _exists)\n    {\n        address IBlacklistUsersAddress = IProtocolDirectory(directoryContract)\n            .getBlacklistContract();\n        IBlacklist(IBlacklistUsersAddress).checkIfAddressIsBlacklisted(\n            _walletAddress\n        );\n        for (uint256 i = 0; i < allMembers.length; i++) {\n            address[] memory _wallets = allMembers[i].wallets;\n            if (_wallets.length != 0) {\n                for (uint256 j = 0; j < _wallets.length; j++) {\n                    if (_wallets[j] == _walletAddress) {\n                        _exists = true;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice checkIfWalletHasNFT\n     * verify if the user has specific nft 1155 or 721\n     * @param _contractAddress address of asset contract\n     * @param _NFTType string i.e. ERC721 | ERC1155\n     * @param tokenId uint256 tokenId checking for ownership\n     * @param userAddress address address to verify ownership of\n     * Fails if not owner\n     */\n    function checkIfWalletHasNFT(\n        address _contractAddress,\n        string memory _NFTType,\n        uint256 tokenId,\n        address userAddress\n    ) external view {\n        // check if wallet has nft\n        bool status = false;\n        if (\n            keccak256(abi.encodePacked((_NFTType))) ==\n            keccak256(abi.encodePacked((\"ERC721\")))\n        ) {\n            if (IERC721(_contractAddress).ownerOf(tokenId) == userAddress) {\n                status = true;\n            } else if (\n                IERC721Upgradeable(_contractAddress).ownerOf(tokenId) ==\n                userAddress\n            ) {\n                status = true;\n            }\n        }\n\n        if (\n            keccak256(abi.encodePacked((_NFTType))) ==\n            keccak256(abi.encodePacked((\"ERC1155\")))\n        ) {\n            if (\n                IERC1155(_contractAddress).balanceOf(userAddress, tokenId) != 0\n            ) {\n                status = true;\n            } else if (\n                IERC1155Upgradeable(_contractAddress).balanceOf(\n                    userAddress,\n                    tokenId\n                ) != 0\n            ) {\n                status = true;\n            }\n        }\n\n        if (status == false) {\n            revert(Errors.M_NOT_HOLDER);\n        }\n    }\n\n    /**\n     * @dev createMember\n     * @param  uid centrally stored id for user\n     * @param _walletAddress walletAddress to add wallet and check blacklist\n     *\n     * Allows to create a member onChain with a unique UID passed.\n     * Will revert if the _walletAddress passed in is blacklisted\n     *\n     */\n    function createMember(string memory uid, address _walletAddress) public {\n        address IBlacklistUsersAddress = IProtocolDirectory(directoryContract)\n            .getBlacklistContract();\n        IBlacklist(IBlacklistUsersAddress).checkIfAddressIsBlacklisted(\n            _walletAddress\n        );\n        if (\n            (keccak256(abi.encodePacked((members[uid].uid))) !=\n                keccak256(abi.encodePacked((uid))) &&\n                (checkIfUIDExists(_walletAddress) == false))\n        ) {\n            if (bytes(uid).length == 0) {\n                revert(Errors.M_EMPTY_UID);\n            }\n            address[] memory _wallets;\n            member memory _member = member(\n                uid,\n                block.timestamp,\n                _wallets,\n                _wallets,\n                0\n            );\n            members[uid] = _member;\n            allMembers.push(_member);\n            addWallet(uid, _walletAddress, true);\n            emit memberCreated(_member.uid, _member.dateCreated);\n        } else {\n            revert(Errors.M_USER_EXISTS);\n        }\n    }\n\n    /**\n     * @dev getMember\n     * @param uid string for centrally located identifier\n     * Allows to get member information stored onChain with a unique UID passed.\n     * @return member struct for a given uid\n     *\n     */\n    function getMember(string memory uid)\n        public\n        view\n        override\n        returns (member memory)\n    {\n        member memory currentMember = members[uid];\n        if (currentMember.dateCreated == 0) {\n            revert(Errors.M_USER_DNE);\n        }\n        return currentMember;\n    }\n\n    /**\n     * @dev getAllMembers\n     * Allows to get all member information stored onChain\n     * @return allMembers a list of member structs\n     *\n     */\n    function getAllMembers() external view returns (member[] memory) {\n        return allMembers;\n    }\n\n    /**\n     * @dev addWallet - Allows to add Wallet to the user\n     * @param uid string for dApp user identifier\n     * @param _wallet address wallet being added for given user\n     * @param _primary bool whether or not this new wallet is the primary wallet\n     *\n     *\n     */\n    function addWallet(\n        string memory uid,\n        address _wallet,\n        bool _primary\n    ) public {\n        member storage _member = members[uid];\n        _member.wallets.push(_wallet);\n        if (_primary) {\n            _member.primaryWallet = _member.wallets.length - 1;\n        }\n\n        for (uint256 i = 0; i < allMembers.length; i++) {\n            member storage member_ = allMembers[i];\n            if (\n                keccak256(abi.encodePacked((member_.uid))) ==\n                keccak256(abi.encodePacked((uid)))\n            ) {\n                member_.wallets.push(_wallet);\n                if (_primary) {\n                    member_.primaryWallet = member_.wallets.length - 1;\n                }\n            }\n        }\n\n        emit walletUpdated(\n            _member.uid,\n            _member.dateCreated,\n            _member.backUpWallets,\n            _member.wallets,\n            _member.primaryWallet\n        );\n    }\n\n    /**\n     * @dev addBackUpWallet - Allows to add backUp Wallets to the user\n     * @param uid string for dApp user identifier\n     * @param _wallets addresses of wallets being added for given user\n     *\n     *\n     */\n    function addBackupWallet(\n        string calldata uid,\n        address[] memory _wallets,\n        address _user\n    ) public {\n        if ((checkIfUIDExists(_user) == false)) {\n            createMember(uid, _user);\n        }\n        member storage _member = members[uid];\n        if (_member.wallets.length == 0) {\n            revert(Errors.M_USER_MUST_WALLET);\n        }\n        for (uint256 i = 0; i < _wallets.length; i++) {\n            _member.backUpWallets.push(_wallets[i]);\n        }\n\n        for (uint256 i = 0; i < allMembers.length; i++) {\n            member storage member_ = allMembers[i];\n            if (\n                keccak256(abi.encodePacked((member_.uid))) ==\n                keccak256(abi.encodePacked((uid)))\n            ) {\n                for (uint256 j = 0; j < _wallets.length; j++) {\n                    member_.backUpWallets.push(_wallets[j]);\n                }\n            }\n        }\n        emit walletUpdated(\n            _member.uid,\n            _member.dateCreated,\n            _member.backUpWallets,\n            _member.wallets,\n            _member.primaryWallet\n        );\n    }\n\n    /**\n     * @dev getBackupWallets - Returns backup Wallets for the specific UID\n     * @param uid string for dApp user identifier\n     *\n     */\n    function getBackupWallets(string calldata uid)\n        external\n        view\n        returns (address[] memory)\n    {\n        return members[uid].backUpWallets;\n    }\n\n    /**\n     * @dev deleteWallet - Allows to delete  wallets of a specific user\n     * @param uid string for dApp user identifier\n     * @param _walletIndex uint256 which index does the wallet exist in the member wallet list\n     *\n     */\n    function deleteWallet(string calldata uid, uint256 _walletIndex) external {\n        checkUIDofSender(uid, msg.sender);\n        member storage _member = members[uid];\n        if (_walletIndex == _member.primaryWallet) {\n            revert(Errors.M_PRIM_WALLET);\n        }\n        delete members[uid].wallets[_walletIndex];\n        address[] storage wallets = members[uid].wallets;\n        for (uint256 i = _walletIndex; i < wallets.length - 1; i++) {\n            wallets[i] = wallets[i + 1];\n        }\n\n        if (members[uid].primaryWallet >= _walletIndex) {\n            members[uid].primaryWallet--;\n        }\n        wallets.pop();\n\n        for (uint256 i = 0; i < allMembers.length; i++) {\n            member storage member_ = allMembers[i];\n            if (\n                keccak256(abi.encodePacked((member_.uid))) ==\n                keccak256(abi.encodePacked((uid)))\n            ) {\n                address[] storage wallets_ = member_.wallets;\n                for (uint256 j = _walletIndex; j < wallets_.length - 1; j++) {\n                    wallets_[j] = wallets_[j + 1];\n                }\n                wallets_.pop();\n                if (member_.primaryWallet >= _walletIndex) {\n                    member_.primaryWallet--;\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev setPrimaryWallet\n     * Allows to set a specific wallet as the primary wallet\n     * @param uid string for dApp user identifier\n     * @param _walletIndex uint256 which index does the wallet exist in the member wallet list\n     *\n     */\n    function setPrimaryWallet(string calldata uid, uint256 _walletIndex)\n        external\n        override\n    {\n        checkUIDofSender(uid, msg.sender);\n        if (_walletIndex == members[uid].primaryWallet) {\n            revert(Errors.M_ALREADY_PRIM);\n        }\n        members[uid].primaryWallet = _walletIndex;\n        for (uint256 i = 0; i < allMembers.length; i++) {\n            member storage member_ = allMembers[i];\n            if (\n                keccak256(abi.encodePacked((member_.uid))) ==\n                keccak256(abi.encodePacked((uid)))\n            ) {\n                member_.primaryWallet = _walletIndex;\n            }\n        }\n    }\n\n    /**\n     * @dev getWallets\n     * Allows to get all wallets of the user\n     * @param uid string for dApp user identifier\n     * @return address[] list of wallets\n     *\n     */\n    function getWallets(string calldata uid)\n        external\n        view\n        override\n        returns (address[] memory)\n    {\n        return members[uid].wallets;\n    }\n\n    /**\n     * @dev getPrimaryWallets\n     * Allows to get primary wallet of the user\n     * @param uid string for dApp user identifier\n     * @return address of the primary wallet per user\n     *\n     */\n    function getPrimaryWallet(string memory uid)\n        external\n        view\n        override\n        returns (address)\n    {\n        return members[uid].wallets[members[uid].primaryWallet];\n    }\n\n    /**\n     * @dev getUID\n     * Allows user to pass walletAddress and return UID\n     * @param _walletAddress get the UID of the user's if their wallet address is present\n     * @return memberuid string of the ID used in the dApp to identify they user\n     *\n     */\n    function getUID(address _walletAddress)\n        external\n        view\n        override\n        returns (string memory memberuid)\n    {\n        for (uint256 i = 0; i < allMembers.length; i++) {\n            address[] memory _wallets = allMembers[i].wallets;\n            if (_wallets.length != 0) {\n                for (uint256 j = 0; j < _wallets.length; j++) {\n                    if (_wallets[j] == _walletAddress) {\n                        memberuid = allMembers[i].uid;\n                    }\n                }\n            }\n        }\n        if (bytes(memberuid).length == 0) {\n            revert(Errors.M_UID_DNE);\n        }\n        return memberuid;\n    }\n\n    /**\n     * @dev storeBackupAssetsApprovals - Function to store All Types Approvals by the user for backup\n     *\n     * @param _contractAddress address[] Ordered list of contract addresses for assets\n     * @param _tokenIds uint256[] Ordered list of tokenIds associated with contract addresses\n     * @param _backUpWallets address[] Ordered list of wallet addresses to backup assets\n     * @param _tokenAmount uint256[] Ordered list of amounts per asset contract and token id to protext\n     * @param _tokenTypes string[] Ordered list of strings i.e. ERC20 | ERC721 | ERC1155\n     * @param _memberUID string for dApp user identifier\n     * @param _userAddress address of the user\n     * @param _super bool true if function is being called from a parent function. false if directly\n     *\n     */\n    function storeBackupAssetsApprovals(\n        address[] calldata _contractAddress,\n        uint256[] calldata _tokenIds,\n        address[] calldata _backUpWallets,\n        uint256[] calldata _tokenAmount,\n        string[] calldata _tokenTypes,\n        string calldata _memberUID,\n        address _userAddress,\n        bool _super\n    ) public {\n        if (\n            _tokenIds.length != _contractAddress.length ||\n            _tokenAmount.length != _tokenTypes.length\n        ) {\n            revert(Errors.M_DIFF_LENGTHS);\n        }\n\n        if (_super == false) {\n            checkUIDofSender(_memberUID, msg.sender);\n        }\n\n        if ((checkIfUIDExists(_userAddress) == false)) {\n            createMember(_memberUID, _userAddress);\n        }\n        member memory _member = getMember(_memberUID);\n\n        checkUserHasMembership(_memberUID, _userAddress);\n        addBackupWallet(_memberUID, _backUpWallets, _userAddress);\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n            address contractAddress = _contractAddress[i];\n            uint256 tokenId_ = _tokenIds[i];\n            string memory tokenType = _tokenTypes[i];\n            uint256 tokenAmount = _tokenAmount[i];\n\n            TokenActions.checkAssetContract(contractAddress, tokenType);\n            Token memory _token = Token(\n                tokenId_,\n                contractAddress,\n                tokenType,\n                tokenAmount\n            );\n\n            _storeAssets(\n                _memberUID,\n                _member,\n                _userAddress,\n                _backUpWallets,\n                _token\n            );\n        }\n        IMembership(UserMembershipAddress[_memberUID]).redeemUpdate(_memberUID);\n    }\n\n    /**\n     * @dev _storeAssets - Internal function to store assets approvals for backup\n     * @param uid string identifier of user across dApp\n     * @param _member member struct of user storing assets for\n     * @param user address of the user of the dApp\n     * @param _backUpWallet address[] list of wallets protected\n     * @param _token Token struct containing token information\n     *\n     */\n    function _storeAssets(\n        string calldata uid,\n        member memory _member,\n        address user,\n        address[] calldata _backUpWallet,\n        Token memory _token\n    ) internal {\n        uint256 _dateApproved = block.timestamp;\n\n        BackUpApprovals memory approval = BackUpApprovals(\n            _member,\n            user,\n            _backUpWallet,\n            _token,\n            _dateApproved,\n            false,\n            ++_approvalId\n        );\n\n        MemberApprovals[uid].push(approval);\n        emit BackUpApprovalsEvent(\n            _member.uid,\n            user,\n            _backUpWallet,\n            _token.tokenId,\n            _token.tokenAddress,\n            _token.tokenType,\n            _token.tokensAllocated,\n            _dateApproved,\n            false,\n            _approvalId,\n            address(0)\n        );\n    }\n\n    /**\n     * @dev executePanic - Public function to transfer assets from one user to another\n     * @param _backUpWallet wallet to panic send assets to\n     * @param _memberUID uid of the user's assets being moved\n     *\n     */\n    function executePanic(address _backUpWallet, string memory _memberUID)\n        external\n    {\n        address IBlacklistUsersAddress = IProtocolDirectory(directoryContract)\n            .getBlacklistContract();\n        if (MemberApprovals[_memberUID].length <= 0) {\n            revert(Errors.M_BACKUP_FIRST);\n        }\n\n        IBlacklist(IBlacklistUsersAddress).checkIfAddressIsBlacklisted(\n            _backUpWallet\n        );\n        _panic(_memberUID, _backUpWallet);\n    }\n\n    /**\n     * @dev _checkBackUpExists - Internal function that checks backup approvals if the backup Wallet Exists\n     * @param _approvals BackUpApprovals struct with backup information\n     * @param _backUpWallet wallet to verify is inside of approval\n     *\n     */\n    function _checkBackUpExists(\n        BackUpApprovals memory _approvals,\n        address _backUpWallet\n    ) internal pure {\n        bool backUpExists = false;\n        for (uint256 j = 0; j < _approvals.backUpWallet.length; j++) {\n            if (_approvals.backUpWallet[j] == _backUpWallet) {\n                backUpExists = true;\n            }\n        }\n        if (!backUpExists) {\n            revert(Errors.M_INVALID_BACKUP);\n        }\n    }\n\n    /**\n     * @dev _panic - Private Function to test panic functionality in order to execute and transfer all assets from one user to another\n     * @param uid string of identifier for user in dApp\n     * @param _backUpWallet address where to send assets to\n     *\n     */\n    function _panic(string memory uid, address _backUpWallet)\n        internal\n        nonReentrant\n    {\n        BackUpApprovals[] storage _approvals = MemberApprovals[uid];\n        for (uint256 i = 0; i < _approvals.length; i++) {\n            if (_approvals[i].claimed == false) {\n                _checkBackUpExists(_approvals[i], _backUpWallet);\n                if (\n                    keccak256(\n                        abi.encodePacked((_approvals[i].token.tokenType))\n                    ) == keccak256(abi.encodePacked((\"ERC20\")))\n                ) {\n                    IERC20 ERC20 = IERC20(_approvals[i].token.tokenAddress);\n\n                    uint256 tokenAllowance = ERC20.allowance(\n                        _approvals[i].approvedWallet,\n                        address(this)\n                    );\n                    uint256 tokenBalance = ERC20.balanceOf(\n                        _approvals[i].approvedWallet\n                    );\n\n                    _approvals[i].claimed = true;\n\n                    if (tokenBalance <= tokenAllowance) {\n                        if (tokenBalance != 0) {\n                            bool sent = ERC20.transferFrom(\n                                _approvals[i].approvedWallet,\n                                _backUpWallet,\n                                tokenBalance\n                            );\n                        }\n                    } else {\n                        if (tokenBalance != 0) {\n                            bool sent = ERC20.transferFrom(\n                                _approvals[i].approvedWallet,\n                                _backUpWallet,\n                                tokenAllowance\n                            );\n                        }\n                    }\n\n                    emit BackUpApprovalsEvent(\n                        _approvals[i].Member.uid,\n                        _approvals[i].approvedWallet,\n                        _approvals[i].backUpWallet,\n                        _approvals[i].token.tokenId,\n                        _approvals[i].token.tokenAddress,\n                        _approvals[i].token.tokenType,\n                        _approvals[i].token.tokensAllocated,\n                        _approvals[i].dateApproved,\n                        _approvals[i].claimed,\n                        _approvals[i].approvalId,\n                        _backUpWallet\n                    );\n                }\n                if (\n                    keccak256(\n                        abi.encodePacked((_approvals[i].token.tokenType))\n                    ) == keccak256(abi.encodePacked((\"ERC721\")))\n                ) {\n                    IERC721 ERC721 = IERC721(_approvals[i].token.tokenAddress);\n\n                    address _tokenAddress = ERC721.ownerOf(\n                        _approvals[i].token.tokenId\n                    );\n\n                    if (_tokenAddress == _approvals[i].approvedWallet) {\n                        ERC721.safeTransferFrom(\n                            _approvals[i].approvedWallet,\n                            _backUpWallet,\n                            _approvals[i].token.tokenId\n                        );\n                    }\n\n                    _approvals[i].claimed = true;\n                    emit BackUpApprovalsEvent(\n                        _approvals[i].Member.uid,\n                        _approvals[i].approvedWallet,\n                        _approvals[i].backUpWallet,\n                        _approvals[i].token.tokenId,\n                        _approvals[i].token.tokenAddress,\n                        _approvals[i].token.tokenType,\n                        _approvals[i].token.tokensAllocated,\n                        _approvals[i].dateApproved,\n                        _approvals[i].claimed,\n                        _approvals[i].approvalId,\n                        _backUpWallet\n                    );\n                }\n                if (\n                    keccak256(\n                        abi.encodePacked((_approvals[i].token.tokenType))\n                    ) == keccak256(abi.encodePacked((\"ERC1155\")))\n                ) {\n                    IERC1155 ERC1155 = IERC1155(\n                        _approvals[i].token.tokenAddress\n                    );\n\n                    uint256 _balance = ERC1155.balanceOf(\n                        _approvals[i].approvedWallet,\n                        _approvals[i].token.tokenId\n                    );\n                    bytes memory data;\n\n                    if (_balance <= _approvals[i].token.tokensAllocated) {\n                        ERC1155.safeTransferFrom(\n                            _approvals[i].approvedWallet,\n                            _backUpWallet,\n                            _approvals[i].token.tokenId,\n                            _balance,\n                            data\n                        );\n                    } else {\n                        ERC1155.safeTransferFrom(\n                            _approvals[i].approvedWallet,\n                            _backUpWallet,\n                            _approvals[i].token.tokenId,\n                            _approvals[i].token.tokensAllocated,\n                            data\n                        );\n                    }\n\n                    _approvals[i].claimed = true;\n                    emit BackUpApprovalsEvent(\n                        _approvals[i].Member.uid,\n                        _approvals[i].approvedWallet,\n                        _approvals[i].backUpWallet,\n                        _approvals[i].token.tokenId,\n                        _approvals[i].token.tokenAddress,\n                        _approvals[i].token.tokenType,\n                        _approvals[i].token.tokensAllocated,\n                        _approvals[i].dateApproved,\n                        _approvals[i].claimed,\n                        _approvals[i].approvalId,\n                        _backUpWallet\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev getBackupApprovals - function to return all backupapprovals for a specific UID\n     * @param uid string of identifier for user in dApp\n     * @return BackUpApprovals[] list of BackUpApprovals struct\n     *\n     */\n    function getBackupApprovals(string memory uid)\n        external\n        view\n        returns (BackUpApprovals[] memory)\n    {\n        return MemberApprovals[uid];\n    }\n\n    /**\n     * @dev editBackup - Function to edit individual backup approvals\n     * @param approvalId_ uint256 id to lookup Approval and edit\n     * @param _contractAddress address contractAddress of asset to save\n     * @param _tokenIds uint256 tokenId of asset\n     * @param _tokenAmount uint256 amount of specific token\n     * @param _tokenType string type of the token i.e. ERC20 | ERC721 | ERC1155\n     * @param _uid string of identifier for user in dApp\n     * @param _user address of the user of the dApp\n     *\n     */\n    function editBackUp(\n        uint256 approvalId_,\n        address _contractAddress,\n        uint256 _tokenIds,\n        uint256 _tokenAmount,\n        string calldata _tokenType,\n        string memory _uid,\n        address _user\n    ) external {\n        member memory _member = getMember(_uid);\n        checkUserHasMembership(_uid, _user);\n\n        BackUpApprovals[] storage _approvals = MemberApprovals[_member.uid];\n        for (uint256 i = 0; i < _approvals.length; i++) {\n            if (_approvals[i].approvalId == approvalId_) {\n                _approvals[i].token.tokenAddress = _contractAddress;\n                _approvals[i].token.tokenId = _tokenIds;\n                _approvals[i].token.tokensAllocated = _tokenAmount;\n                _approvals[i].token.tokenType = _tokenType;\n            }\n        }\n        IMembership(UserMembershipAddress[_uid]).redeemUpdate(_uid);\n    }\n\n    /**\n     * @dev editAllBackUp - Function to delete and add new approvals for backup\n     * @param _contractAddress address[] Ordered list of addresses for asset contracts\n     * @param _tokenIds uint256[] Ordered list of tokenIds to backup\n     * @param _backUpWallets address[] Ordered list of wallets that can be backups\n     * @param _tokenAmount uint256[] Ordered list of amounts of tokens to backup\n     * @param _tokenTypes string[] Ordered list of string tokenTypes i.e. ERC20 | ERC721 | ERC1155\n     * @param _memberUID string of identifier for user in dApp\n     * @param _user address of the user of the dApp\n     *\n     *\n     */\n    function editAllBackUp(\n        address[] calldata _contractAddress,\n        uint256[] calldata _tokenIds,\n        address[] calldata _backUpWallets,\n        uint256[] calldata _tokenAmount,\n        string[] calldata _tokenTypes,\n        string calldata _memberUID,\n        address _user\n    ) external {\n        checkUserHasMembership(_memberUID, _user);\n        deleteAllBackUp(_memberUID);\n        storeBackupAssetsApprovals(\n            _contractAddress,\n            _tokenIds,\n            _backUpWallets,\n            _tokenAmount,\n            _tokenTypes,\n            _memberUID,\n            _user,\n            true\n        );\n    }\n\n    /**\n     * @dev deleteAllBackUp - Function to delete all backup approvals\n     * @param _uid string of identifier for user in dApp\n     *\n     */\n    function deleteAllBackUp(string memory _uid) public {\n        member memory _member = getMember(_uid);\n        delete MemberApprovals[_member.uid];\n    }\n\n    /**\n     * @notice checkUserHasMembership - Function to check if user has membership\n     * @param _uid string of identifier for user in dApp\n     * @param _user address of the user of the dApp\n     *\n     */\n    function checkUserHasMembership(string memory _uid, address _user)\n        public\n        view\n    {\n        IBlacklist(IProtocolDirectory(directoryContract).getBlacklistContract())\n            .checkIfAddressIsBlacklisted(_user);\n        IMembership _membership = IMembership(UserMembershipAddress[_uid]);\n        bool _MembershipActive = _membership.checkIfMembershipActive(_uid);\n        if (_MembershipActive == false) {\n            revert(Errors.M_NOT_MEMBER);\n        } else {\n            MembershipStruct memory Membership = IMembership(\n                UserMembershipAddress[_uid]\n            ).getMembership(_uid);\n            if (Membership.updatesPerYear <= 0) {\n                revert(Errors.M_NEED_TOP);\n            }\n        }\n    }\n\n    /**\n     * @dev Function set MembershipAddress for a Uid\n     * @param _uid string of identifier for user in dApp\n     * @param _Membership address of the user's associated membership contract\n     *\n     */\n    function setIMembershipAddress(string memory _uid, address _Membership)\n        external\n    {\n        address factoryAddress = IProtocolDirectory(directoryContract)\n            .getMembershipFactory();\n        if (factoryAddress != msg.sender) {\n            revert(Errors.M_INVALID_ADDRESS);\n        }\n        UserMembershipAddress[_uid] = _Membership;\n    }\n\n    /**\n     * @dev Function to get MembershipAddress for a given Uid\n     * @param _uid string of identifier for user in dApp\n     *\n     */\n    function getIMembershipAddress(string memory _uid)\n        external\n        view\n        returns (address)\n    {\n        return UserMembershipAddress[_uid];\n    }\n}\n"}, "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"}, "@openzeppelin/contracts/token/ERC721/ERC721.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.30;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"}, "@openzeppelin/contracts/utils/Address.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"}, "@openzeppelin/contracts/utils/Strings.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"}, "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"}, "@openzeppelin/contracts/utils/introspection/ERC165.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.30;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"}, "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"}, "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.30;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"}, "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"}, "@openzeppelin/contracts/token/ERC20/ERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.30;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"}, "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"}, "contracts/ChainlinkOperations.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"@chainlink/contracts/src/v0.8/ChainlinkClient.sol\";\nimport \"@chainlink/contracts/src/v0.8/ConfirmedOwner.sol\";\n\nimport \"./structs/ApprovalsStruct.sol\";\nimport \"./interfaces/IAssetStoreFactory.sol\";\nimport \"./interfaces/IAssetStore.sol\";\nimport \"./interfaces/IMember.sol\";\nimport \"./interfaces/IProtocolDirectory.sol\";\n\n/**\n * @title RelayerContract\n *\n * Logic for communicatiing with the relayer and contract state\n *\n */\n\ncontract ChainlinkOperations is\n    Initializable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    ChainlinkClient\n{\n    /// @dev ProtocolDirectory location\n    address public directoryContract;\n\n    /// @dev allows us to use Chainlink methods for requesting data\n    using Chainlink for Chainlink.Request;\n\n    /// @dev job ID that the node provider sets up\n    bytes32 private jobId;\n\n    /// @dev amount in link to pay oracle for data\n    uint256 private constant ORACLE_PAYMENT = 0;\n\n    /// @dev URL of our API that will be requested\n    string private WEBACY_API_URL;\n\n    /// @dev What field(s) in the JSON response we want\n    string private PATH;\n\n    /// @dev LINK token\n    IERC20 public LINK_TOKEN;\n\n    /**\n     * @dev initialize - Initializes the function for Ownable and Reentrancy.\n     * @param _directoryContract - address of the ProtocolDirectory contract\n     * @param _webacyUrl - URL of our API that will be requested\n     * @param _linkToken - address of the LINK token\n     * @param _oracle - address of the oracle\n     * @param _jobId - job ID that the node provider sets up\n     */\n    function initialize(\n        address _directoryContract,\n        string calldata _webacyUrl,\n        string calldata _path,\n        address _linkToken,\n        address _oracle,\n        bytes32 _jobId\n    ) public initializer {\n        __Context_init_unchained();\n        __Ownable_init();\n        __ReentrancyGuard_init();\n        directoryContract = _directoryContract;\n        WEBACY_API_URL = _webacyUrl;\n        PATH = _path;\n        setChainlinkToken(_linkToken);\n        LINK_TOKEN = IERC20(_linkToken);\n        setChainlinkOracle(_oracle);\n        jobId = _jobId;\n    }\n\n    /**\n     * @dev setWebacyUrl updates the API URL we're requesting\n     * @param _webacyUrl - new url\n     */\n    function setWebacyUrl(string calldata _webacyUrl) external onlyOwner {\n        WEBACY_API_URL = _webacyUrl;\n    }\n\n    /**\n     * @dev setPath updates the path to fetch from response. If an empty string then the entire response is returned\n     * @param _path - new path\n     */\n    function setPath(string calldata _path) external onlyOwner {\n        PATH = _path;\n    }\n\n    /**\n     * @dev setOracle updates oracle address in the event we're changing node providers\n     * @param _addr - new oracle address\n     */\n    function setOracle(address _addr) external onlyOwner {\n        setChainlinkOracle(_addr);\n    }\n\n    /**\n     * @dev setLinkToken updates linkTokenAddress\n     * @param _addr - new token address\n     */\n    function setLinkToken(address _addr) external onlyOwner {\n        setChainlinkToken(_addr);\n        LINK_TOKEN = IERC20(_addr);\n    }\n\n    /**\n     * @dev setJobId\n     * @param _id - id of the job\n     */\n    function setJobId(bytes32 _id) external onlyOwner {\n        jobId = _id;\n    }\n\n    /**\n     * @dev withdrawLInk - withdraws LINK from the contract\n     */\n    function withdrawLink() external onlyOwner {\n        bool sent = LINK_TOKEN.transfer(\n            msg.sender,\n            LINK_TOKEN.balanceOf(address(this))\n        );\n        require(sent, \"Transfer Failed\");\n    }\n\n    /**\n     * @dev requestBytes - this is the \"main\" function that calls our API\n     */\n    function requestBytes() public {\n        Chainlink.Request memory req = buildChainlinkRequest(\n            jobId,\n            address(this),\n            this.fulfillArray.selector\n        );\n        req.add(\"get\", WEBACY_API_URL);\n        // if PATH is not an empty string add it to the request\n        if (bytes(PATH).length > 0) {\n            req.add(\"path\", PATH);\n        }\n        sendOperatorRequest(req, ORACLE_PAYMENT);\n    }\n\n    /// @dev this event indicated the API request has been relayed successfully\n    event RequestFulfilled(bytes32 indexed requestId);\n\n    /**\n     * @dev fulfillArray is our callback function - i.e., what to do with the data when it is recieved by our conract\n     * @dev we're turning the bytes into an address and then setting the approvals active for that address\n     * @param requestId - id of the request\n     * @param _arrayOfBytes - data returned from the API\n     */\n    function fulfillArray(bytes32 requestId, bytes[] memory _arrayOfBytes)\n        public\n        recordChainlinkFulfillment(requestId)\n    {\n        for (uint8 i = 0; i < _arrayOfBytes.length; i++) {\n            _setApprovalActiveForUID(string(_arrayOfBytes[i]));\n        }\n\n        emit RequestFulfilled(requestId);\n    }\n\n    /**\n     * @dev setApprovalActiveForUID - allows beneficiaries to claim on behalf of a given uid\n     * @param _uid - uid to activate\n     */\n    function setApprovalActiveForUID(string memory _uid) external onlyOwner {\n        _setApprovalActiveForUID(_uid);\n    }\n\n    /**\n     * @dev _setApprovalActiveForUID - internal version called by fulfillArray\n     * @param _uid - uid to activate\n     */\n    function _setApprovalActiveForUID(string memory _uid) internal {\n        address IAssetStoreFactoryAddress = IProtocolDirectory(\n            directoryContract\n        ).getAssetStoreFactory();\n\n        address usersAssetStoreAddress = IAssetStoreFactory(\n            IAssetStoreFactoryAddress\n        ).getAssetStoreAddress(_uid);\n        IAssetStore(usersAssetStoreAddress).setApprovalActive(_uid);\n    }\n}\n"}, "@chainlink/contracts/src/v0.8/ConfirmedOwner.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"./ConfirmedOwnerWithProposal.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\n}\n"}, "@chainlink/contracts/src/v0.8/ChainlinkClient.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"./Chainlink.sol\";\nimport \"./interfaces/ENSInterface.sol\";\nimport \"./interfaces/LinkTokenInterface.sol\";\nimport \"./interfaces/ChainlinkRequestInterface.sol\";\nimport \"./interfaces/OperatorInterface.sol\";\nimport \"./interfaces/PointerInterface.sol\";\nimport {ENSResolver as ENSResolver_Chainlink} from \"./vendor/ENSResolver.sol\";\n\n/**\n * @title The ChainlinkClient contract\n * @notice Contract writers can inherit this contract in order to create requests for the\n * Chainlink network\n */\nabstract contract ChainlinkClient {\n  using Chainlink for Chainlink.Request;\n\n  uint256 internal constant LINK_DIVISIBILITY = 10**18;\n  uint256 private constant AMOUNT_OVERRIDE = 0;\n  address private constant SENDER_OVERRIDE = address(0);\n  uint256 private constant ORACLE_ARGS_VERSION = 1;\n  uint256 private constant OPERATOR_ARGS_VERSION = 2;\n  bytes32 private constant ENS_TOKEN_SUBNAME = keccak256(\"link\");\n  bytes32 private constant ENS_ORACLE_SUBNAME = keccak256(\"oracle\");\n  address private constant LINK_TOKEN_POINTER = 0xC89bD4E1632D3A43CB03AAAd5262cbe4038Bc571;\n\n  ENSInterface private s_ens;\n  bytes32 private s_ensNode;\n  LinkTokenInterface private s_link;\n  OperatorInterface private s_oracle;\n  uint256 private s_requestCount = 1;\n  mapping(bytes32 => address) private s_pendingRequests;\n\n  event ChainlinkRequested(bytes32 indexed id);\n  event ChainlinkFulfilled(bytes32 indexed id);\n  event ChainlinkCancelled(bytes32 indexed id);\n\n  /**\n   * @notice Creates a request that can hold additional parameters\n   * @param specId The Job Specification ID that the request will be created for\n   * @param callbackAddr address to operate the callback on\n   * @param callbackFunctionSignature function signature to use for the callback\n   * @return A Chainlink Request struct in memory\n   */\n  function buildChainlinkRequest(\n    bytes32 specId,\n    address callbackAddr,\n    bytes4 callbackFunctionSignature\n  ) internal pure returns (Chainlink.Request memory) {\n    Chainlink.Request memory req;\n    return req.initialize(specId, callbackAddr, callbackFunctionSignature);\n  }\n\n  /**\n   * @notice Creates a request that can hold additional parameters\n   * @param specId The Job Specification ID that the request will be created for\n   * @param callbackFunctionSignature function signature to use for the callback\n   * @return A Chainlink Request struct in memory\n   */\n  function buildOperatorRequest(bytes32 specId, bytes4 callbackFunctionSignature)\n    internal\n    view\n    returns (Chainlink.Request memory)\n  {\n    Chainlink.Request memory req;\n    return req.initialize(specId, address(this), callbackFunctionSignature);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the stored oracle address\n   * @dev Calls `chainlinkRequestTo` with the stored oracle address\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendChainlinkRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\n    return sendChainlinkRequestTo(address(s_oracle), req, payment);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the specified oracle address\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\n   * send LINK which creates a request on the target oracle contract.\n   * Emits ChainlinkRequested event.\n   * @param oracleAddress The address of the oracle for the request\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendChainlinkRequestTo(\n    address oracleAddress,\n    Chainlink.Request memory req,\n    uint256 payment\n  ) internal returns (bytes32 requestId) {\n    uint256 nonce = s_requestCount;\n    s_requestCount = nonce + 1;\n    bytes memory encodedRequest = abi.encodeWithSelector(\n      ChainlinkRequestInterface.oracleRequest.selector,\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\n      req.id,\n      address(this),\n      req.callbackFunctionId,\n      nonce,\n      ORACLE_ARGS_VERSION,\n      req.buf.buf\n    );\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the stored oracle address\n   * @dev This function supports multi-word response\n   * @dev Calls `sendOperatorRequestTo` with the stored oracle address\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendOperatorRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\n    return sendOperatorRequestTo(address(s_oracle), req, payment);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the specified oracle address\n   * @dev This function supports multi-word response\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\n   * send LINK which creates a request on the target oracle contract.\n   * Emits ChainlinkRequested event.\n   * @param oracleAddress The address of the oracle for the request\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendOperatorRequestTo(\n    address oracleAddress,\n    Chainlink.Request memory req,\n    uint256 payment\n  ) internal returns (bytes32 requestId) {\n    uint256 nonce = s_requestCount;\n    s_requestCount = nonce + 1;\n    bytes memory encodedRequest = abi.encodeWithSelector(\n      OperatorInterface.operatorRequest.selector,\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\n      req.id,\n      req.callbackFunctionId,\n      nonce,\n      OPERATOR_ARGS_VERSION,\n      req.buf.buf\n    );\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\n  }\n\n  /**\n   * @notice Make a request to an oracle\n   * @param oracleAddress The address of the oracle for the request\n   * @param nonce used to generate the request ID\n   * @param payment The amount of LINK to send for the request\n   * @param encodedRequest data encoded for request type specific format\n   * @return requestId The request ID\n   */\n  function _rawRequest(\n    address oracleAddress,\n    uint256 nonce,\n    uint256 payment,\n    bytes memory encodedRequest\n  ) private returns (bytes32 requestId) {\n    requestId = keccak256(abi.encodePacked(this, nonce));\n    s_pendingRequests[requestId] = oracleAddress;\n    emit ChainlinkRequested(requestId);\n    require(s_link.transferAndCall(oracleAddress, payment, encodedRequest), \"unable to transferAndCall to oracle\");\n  }\n\n  /**\n   * @notice Allows a request to be cancelled if it has not been fulfilled\n   * @dev Requires keeping track of the expiration value emitted from the oracle contract.\n   * Deletes the request from the `pendingRequests` mapping.\n   * Emits ChainlinkCancelled event.\n   * @param requestId The request ID\n   * @param payment The amount of LINK sent for the request\n   * @param callbackFunc The callback function specified for the request\n   * @param expiration The time of the expiration for the request\n   */\n  function cancelChainlinkRequest(\n    bytes32 requestId,\n    uint256 payment,\n    bytes4 callbackFunc,\n    uint256 expiration\n  ) internal {\n    OperatorInterface requested = OperatorInterface(s_pendingRequests[requestId]);\n    delete s_pendingRequests[requestId];\n    emit ChainlinkCancelled(requestId);\n    requested.cancelOracleRequest(requestId, payment, callbackFunc, expiration);\n  }\n\n  /**\n   * @notice the next request count to be used in generating a nonce\n   * @dev starts at 1 in order to ensure consistent gas cost\n   * @return returns the next request count to be used in a nonce\n   */\n  function getNextRequestCount() internal view returns (uint256) {\n    return s_requestCount;\n  }\n\n  /**\n   * @notice Sets the stored oracle address\n   * @param oracleAddress The address of the oracle contract\n   */\n  function setChainlinkOracle(address oracleAddress) internal {\n    s_oracle = OperatorInterface(oracleAddress);\n  }\n\n  /**\n   * @notice Sets the LINK token address\n   * @param linkAddress The address of the LINK token contract\n   */\n  function setChainlinkToken(address linkAddress) internal {\n    s_link = LinkTokenInterface(linkAddress);\n  }\n\n  /**\n   * @notice Sets the Chainlink token address for the public\n   * network as given by the Pointer contract\n   */\n  function setPublicChainlinkToken() internal {\n    setChainlinkToken(PointerInterface(LINK_TOKEN_POINTER).getAddress());\n  }\n\n  /**\n   * @notice Retrieves the stored address of the LINK token\n   * @return The address of the LINK token\n   */\n  function chainlinkTokenAddress() internal view returns (address) {\n    return address(s_link);\n  }\n\n  /**\n   * @notice Retrieves the stored address of the oracle contract\n   * @return The address of the oracle contract\n   */\n  function chainlinkOracleAddress() internal view returns (address) {\n    return address(s_oracle);\n  }\n\n  /**\n   * @notice Allows for a request which was created on another contract to be fulfilled\n   * on this contract\n   * @param oracleAddress The address of the oracle contract that will fulfill the request\n   * @param requestId The request ID used for the response\n   */\n  function addChainlinkExternalRequest(address oracleAddress, bytes32 requestId) internal notPendingRequest(requestId) {\n    s_pendingRequests[requestId] = oracleAddress;\n  }\n\n  /**\n   * @notice Sets the stored oracle and LINK token contracts with the addresses resolved by ENS\n   * @dev Accounts for subnodes having different resolvers\n   * @param ensAddress The address of the ENS contract\n   * @param node The ENS node hash\n   */\n  function useChainlinkWithENS(address ensAddress, bytes32 node) internal {\n    s_ens = ENSInterface(ensAddress);\n    s_ensNode = node;\n    bytes32 linkSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_TOKEN_SUBNAME));\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(linkSubnode));\n    setChainlinkToken(resolver.addr(linkSubnode));\n    updateChainlinkOracleWithENS();\n  }\n\n  /**\n   * @notice Sets the stored oracle contract with the address resolved by ENS\n   * @dev This may be called on its own as long as `useChainlinkWithENS` has been called previously\n   */\n  function updateChainlinkOracleWithENS() internal {\n    bytes32 oracleSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_ORACLE_SUBNAME));\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(oracleSubnode));\n    setChainlinkOracle(resolver.addr(oracleSubnode));\n  }\n\n  /**\n   * @notice Ensures that the fulfillment is valid for this contract\n   * @dev Use if the contract developer prefers methods instead of modifiers for validation\n   * @param requestId The request ID for fulfillment\n   */\n  function validateChainlinkCallback(bytes32 requestId)\n    internal\n    recordChainlinkFulfillment(requestId)\n  // solhint-disable-next-line no-empty-blocks\n  {\n\n  }\n\n  /**\n   * @dev Reverts if the sender is not the oracle of the request.\n   * Emits ChainlinkFulfilled event.\n   * @param requestId The request ID for fulfillment\n   */\n  modifier recordChainlinkFulfillment(bytes32 requestId) {\n    require(msg.sender == s_pendingRequests[requestId], \"Source must be the oracle of the request\");\n    delete s_pendingRequests[requestId];\n    emit ChainlinkFulfilled(requestId);\n    _;\n  }\n\n  /**\n   * @dev Reverts if the request is already pending\n   * @param requestId The request ID for fulfillment\n   */\n  modifier notPendingRequest(bytes32 requestId) {\n    require(s_pendingRequests[requestId] == address(0), \"Request is already pending\");\n    _;\n  }\n}\n"}, "@chainlink/contracts/src/v0.8/ConfirmedOwnerWithProposal.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"./interfaces/OwnableInterface.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    require(newOwner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /**\n   * @notice Allows an owner to begin transferring ownership to a new address,\n   * pending.\n   */\n  function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /**\n   * @notice Allows an ownership transfer to be completed by the recipient.\n   */\n  function acceptOwnership() external override {\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /**\n   * @notice Get the current owner\n   */\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /**\n   * @notice validate, transfer ownership, and emit relevant events\n   */\n  function _transferOwnership(address to) private {\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /**\n   * @notice validate access\n   */\n  function _validateOwnership() internal view {\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /**\n   * @notice Reverts if called by anyone other than the contract owner.\n   */\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"}, "@chainlink/contracts/src/v0.8/interfaces/OwnableInterface.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface OwnableInterface {\n  function owner() external returns (address);\n\n  function transferOwnership(address recipient) external;\n\n  function acceptOwnership() external;\n}\n"}, "@chainlink/contracts/src/v0.8/Chainlink.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {CBORChainlink} from \"./vendor/CBORChainlink.sol\";\nimport {BufferChainlink} from \"./vendor/BufferChainlink.sol\";\n\n/**\n * @title Library for common Chainlink functions\n * @dev Uses imported CBOR library for encoding to buffer\n */\nlibrary Chainlink {\n  uint256 internal constant defaultBufferSize = 256; // solhint-disable-line const-name-snakecase\n\n  using CBORChainlink for BufferChainlink.buffer;\n\n  struct Request {\n    bytes32 id;\n    address callbackAddress;\n    bytes4 callbackFunctionId;\n    uint256 nonce;\n    BufferChainlink.buffer buf;\n  }\n\n  /**\n   * @notice Initializes a Chainlink request\n   * @dev Sets the ID, callback address, and callback function signature on the request\n   * @param self The uninitialized request\n   * @param jobId The Job Specification ID\n   * @param callbackAddr The callback address\n   * @param callbackFunc The callback function signature\n   * @return The initialized request\n   */\n  function initialize(\n    Request memory self,\n    bytes32 jobId,\n    address callbackAddr,\n    bytes4 callbackFunc\n  ) internal pure returns (Chainlink.Request memory) {\n    BufferChainlink.init(self.buf, defaultBufferSize);\n    self.id = jobId;\n    self.callbackAddress = callbackAddr;\n    self.callbackFunctionId = callbackFunc;\n    return self;\n  }\n\n  /**\n   * @notice Sets the data for the buffer without encoding CBOR on-chain\n   * @dev CBOR can be closed with curly-brackets {} or they can be left off\n   * @param self The initialized request\n   * @param data The CBOR data\n   */\n  function setBuffer(Request memory self, bytes memory data) internal pure {\n    BufferChainlink.init(self.buf, data.length);\n    BufferChainlink.append(self.buf, data);\n  }\n\n  /**\n   * @notice Adds a string value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The string value to add\n   */\n  function add(\n    Request memory self,\n    string memory key,\n    string memory value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeString(value);\n  }\n\n  /**\n   * @notice Adds a bytes value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The bytes value to add\n   */\n  function addBytes(\n    Request memory self,\n    string memory key,\n    bytes memory value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeBytes(value);\n  }\n\n  /**\n   * @notice Adds a int256 value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The int256 value to add\n   */\n  function addInt(\n    Request memory self,\n    string memory key,\n    int256 value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeInt(value);\n  }\n\n  /**\n   * @notice Adds a uint256 value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The uint256 value to add\n   */\n  function addUint(\n    Request memory self,\n    string memory key,\n    uint256 value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeUInt(value);\n  }\n\n  /**\n   * @notice Adds an array of strings to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param values The array of string values to add\n   */\n  function addStringArray(\n    Request memory self,\n    string memory key,\n    string[] memory values\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.startArray();\n    for (uint256 i = 0; i < values.length; i++) {\n      self.buf.encodeString(values[i]);\n    }\n    self.buf.endSequence();\n  }\n}\n"}, "@chainlink/contracts/src/v0.8/interfaces/ChainlinkRequestInterface.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface ChainlinkRequestInterface {\n  function oracleRequest(\n    address sender,\n    uint256 requestPrice,\n    bytes32 serviceAgreementID,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 nonce,\n    uint256 dataVersion,\n    bytes calldata data\n  ) external;\n\n  function cancelOracleRequest(\n    bytes32 requestId,\n    uint256 payment,\n    bytes4 callbackFunctionId,\n    uint256 expiration\n  ) external;\n}\n"}, "@chainlink/contracts/src/v0.8/interfaces/OperatorInterface.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"./OracleInterface.sol\";\nimport \"./ChainlinkRequestInterface.sol\";\n\ninterface OperatorInterface is OracleInterface, ChainlinkRequestInterface {\n  function operatorRequest(\n    address sender,\n    uint256 payment,\n    bytes32 specId,\n    bytes4 callbackFunctionId,\n    uint256 nonce,\n    uint256 dataVersion,\n    bytes calldata data\n  ) external;\n\n  function fulfillOracleRequest2(\n    bytes32 requestId,\n    uint256 payment,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 expiration,\n    bytes calldata data\n  ) external returns (bool);\n\n  function ownerTransferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function distributeFunds(address payable[] calldata receivers, uint256[] calldata amounts) external payable;\n\n  function getAuthorizedSenders() external returns (address[] memory);\n\n  function setAuthorizedSenders(address[] calldata senders) external;\n\n  function getForwarder() external returns (address);\n}\n"}, "@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool success);\n}\n"}, "@chainlink/contracts/src/v0.8/vendor/ENSResolver.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nabstract contract ENSResolver {\n  function addr(bytes32 node) public view virtual returns (address);\n}\n"}, "@chainlink/contracts/src/v0.8/interfaces/ENSInterface.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface ENSInterface {\n  // Logged when the owner of a node assigns a new owner to a subnode.\n  event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n  // Logged when the owner of a node transfers ownership to a new account.\n  event Transfer(bytes32 indexed node, address owner);\n\n  // Logged when the resolver for a node changes.\n  event NewResolver(bytes32 indexed node, address resolver);\n\n  // Logged when the TTL of a node changes\n  event NewTTL(bytes32 indexed node, uint64 ttl);\n\n  function setSubnodeOwner(\n    bytes32 node,\n    bytes32 label,\n    address owner\n  ) external;\n\n  function setResolver(bytes32 node, address resolver) external;\n\n  function setOwner(bytes32 node, address owner) external;\n\n  function setTTL(bytes32 node, uint64 ttl) external;\n\n  function owner(bytes32 node) external view returns (address);\n\n  function resolver(bytes32 node) external view returns (address);\n\n  function ttl(bytes32 node) external view returns (uint64);\n}\n"}, "@chainlink/contracts/src/v0.8/interfaces/PointerInterface.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface PointerInterface {\n  function getAddress() external view returns (address);\n}\n"}, "@chainlink/contracts/src/v0.8/vendor/BufferChainlink.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @dev A library for working with mutable byte buffers in Solidity.\n *\n * Byte buffers are mutable and expandable, and provide a variety of primitives\n * for writing to them. At any time you can fetch a bytes object containing the\n * current contents of the buffer. The bytes object should not be stored between\n * operations, as it may change due to resizing of the buffer.\n */\nlibrary BufferChainlink {\n  /**\n   * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n   *      a capacity. The capacity may be longer than the current value, in\n   *      which case it can be extended without the need to allocate more memory.\n   */\n  struct buffer {\n    bytes buf;\n    uint256 capacity;\n  }\n\n  /**\n   * @dev Initializes a buffer with an initial capacity.\n   * @param buf The buffer to initialize.\n   * @param capacity The number of bytes of space to allocate the buffer.\n   * @return The buffer, for chaining.\n   */\n  function init(buffer memory buf, uint256 capacity) internal pure returns (buffer memory) {\n    if (capacity % 32 != 0) {\n      capacity += 32 - (capacity % 32);\n    }\n    // Allocate space for the buffer data\n    buf.capacity = capacity;\n    assembly {\n      let ptr := mload(0x40)\n      mstore(buf, ptr)\n      mstore(ptr, 0)\n      mstore(0x40, add(32, add(ptr, capacity)))\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Initializes a new buffer from an existing bytes object.\n   *      Changes to the buffer may mutate the original value.\n   * @param b The bytes object to initialize the buffer with.\n   * @return A new buffer.\n   */\n  function fromBytes(bytes memory b) internal pure returns (buffer memory) {\n    buffer memory buf;\n    buf.buf = b;\n    buf.capacity = b.length;\n    return buf;\n  }\n\n  function resize(buffer memory buf, uint256 capacity) private pure {\n    bytes memory oldbuf = buf.buf;\n    init(buf, capacity);\n    append(buf, oldbuf);\n  }\n\n  function max(uint256 a, uint256 b) private pure returns (uint256) {\n    if (a > b) {\n      return a;\n    }\n    return b;\n  }\n\n  /**\n   * @dev Sets buffer length to 0.\n   * @param buf The buffer to truncate.\n   * @return The original buffer, for chaining..\n   */\n  function truncate(buffer memory buf) internal pure returns (buffer memory) {\n    assembly {\n      let bufptr := mload(buf)\n      mstore(bufptr, 0)\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The start offset to write to.\n   * @param data The data to append.\n   * @param len The number of bytes to copy.\n   * @return The original buffer, for chaining.\n   */\n  function write(\n    buffer memory buf,\n    uint256 off,\n    bytes memory data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    require(len <= data.length);\n\n    if (off + len > buf.capacity) {\n      resize(buf, max(buf.capacity, len + off) * 2);\n    }\n\n    uint256 dest;\n    uint256 src;\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Length of existing buffer data\n      let buflen := mload(bufptr)\n      // Start address = buffer address + offset + sizeof(buffer length)\n      dest := add(add(bufptr, 32), off)\n      // Update buffer length if we're extending it\n      if gt(add(len, off), buflen) {\n        mstore(bufptr, add(len, off))\n      }\n      src := add(data, 32)\n    }\n\n    // Copy word-length chunks while possible\n    for (; len >= 32; len -= 32) {\n      assembly {\n        mstore(dest, mload(src))\n      }\n      dest += 32;\n      src += 32;\n    }\n\n    // Copy remaining bytes\n    unchecked {\n      uint256 mask = (256**(32 - len)) - 1;\n      assembly {\n        let srcpart := and(mload(src), not(mask))\n        let destpart := and(mload(dest), mask)\n        mstore(dest, or(destpart, srcpart))\n      }\n    }\n\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @param len The number of bytes to copy.\n   * @return The original buffer, for chaining.\n   */\n  function append(\n    buffer memory buf,\n    bytes memory data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, len);\n  }\n\n  /**\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, data.length);\n  }\n\n  /**\n   * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write the byte at.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function writeUint8(\n    buffer memory buf,\n    uint256 off,\n    uint8 data\n  ) internal pure returns (buffer memory) {\n    if (off >= buf.capacity) {\n      resize(buf, buf.capacity * 2);\n    }\n\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Length of existing buffer data\n      let buflen := mload(bufptr)\n      // Address = buffer address + sizeof(buffer length) + off\n      let dest := add(add(bufptr, off), 32)\n      mstore8(dest, data)\n      // Update buffer length if we extended it\n      if eq(off, buflen) {\n        mstore(bufptr, add(buflen, 1))\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function appendUint8(buffer memory buf, uint8 data) internal pure returns (buffer memory) {\n    return writeUint8(buf, buf.buf.length, data);\n  }\n\n  /**\n   * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\n   *      exceed the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @param len The number of bytes to write (left-aligned).\n   * @return The original buffer, for chaining.\n   */\n  function write(\n    buffer memory buf,\n    uint256 off,\n    bytes32 data,\n    uint256 len\n  ) private pure returns (buffer memory) {\n    if (len + off > buf.capacity) {\n      resize(buf, (len + off) * 2);\n    }\n\n    unchecked {\n      uint256 mask = (256**len) - 1;\n      // Right-align data\n      data = data >> (8 * (32 - len));\n      assembly {\n        // Memory address of the buffer data\n        let bufptr := mload(buf)\n        // Address = buffer address + sizeof(buffer length) + off + len\n        let dest := add(add(bufptr, off), len)\n        mstore(dest, or(and(mload(dest), not(mask)), data))\n        // Update buffer length if we extended it\n        if gt(add(off, len), mload(bufptr)) {\n          mstore(bufptr, add(off, len))\n        }\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function writeBytes20(\n    buffer memory buf,\n    uint256 off,\n    bytes20 data\n  ) internal pure returns (buffer memory) {\n    return write(buf, off, bytes32(data), 20);\n  }\n\n  /**\n   * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chhaining.\n   */\n  function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, bytes32(data), 20);\n  }\n\n  /**\n   * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, 32);\n  }\n\n  /**\n   * @dev Writes an integer to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @param len The number of bytes to write (right-aligned).\n   * @return The original buffer, for chaining.\n   */\n  function writeInt(\n    buffer memory buf,\n    uint256 off,\n    uint256 data,\n    uint256 len\n  ) private pure returns (buffer memory) {\n    if (len + off > buf.capacity) {\n      resize(buf, (len + off) * 2);\n    }\n\n    uint256 mask = (256**len) - 1;\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Address = buffer address + off + sizeof(buffer length) + len\n      let dest := add(add(bufptr, off), len)\n      mstore(dest, or(and(mload(dest), not(mask)), data))\n      // Update buffer length if we extended it\n      if gt(add(off, len), mload(bufptr)) {\n        mstore(bufptr, add(off, len))\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n   * exceed the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer.\n   */\n  function appendInt(\n    buffer memory buf,\n    uint256 data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    return writeInt(buf, buf.buf.length, data, len);\n  }\n}\n"}, "@chainlink/contracts/src/v0.8/vendor/CBORChainlink.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {BufferChainlink} from \"./BufferChainlink.sol\";\n\nlibrary CBORChainlink {\n  using BufferChainlink for BufferChainlink.buffer;\n\n  uint8 private constant MAJOR_TYPE_INT = 0;\n  uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n  uint8 private constant MAJOR_TYPE_BYTES = 2;\n  uint8 private constant MAJOR_TYPE_STRING = 3;\n  uint8 private constant MAJOR_TYPE_ARRAY = 4;\n  uint8 private constant MAJOR_TYPE_MAP = 5;\n  uint8 private constant MAJOR_TYPE_TAG = 6;\n  uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n  uint8 private constant TAG_TYPE_BIGNUM = 2;\n  uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n  function encodeFixedNumeric(BufferChainlink.buffer memory buf, uint8 major, uint64 value) private pure {\n    if(value <= 23) {\n      buf.appendUint8(uint8((major << 5) | value));\n    } else if (value <= 0xFF) {\n      buf.appendUint8(uint8((major << 5) | 24));\n      buf.appendInt(value, 1);\n    } else if (value <= 0xFFFF) {\n      buf.appendUint8(uint8((major << 5) | 25));\n      buf.appendInt(value, 2);\n    } else if (value <= 0xFFFFFFFF) {\n      buf.appendUint8(uint8((major << 5) | 26));\n      buf.appendInt(value, 4);\n    } else {\n      buf.appendUint8(uint8((major << 5) | 27));\n      buf.appendInt(value, 8);\n    }\n  }\n\n  function encodeIndefiniteLengthType(BufferChainlink.buffer memory buf, uint8 major) private pure {\n    buf.appendUint8(uint8((major << 5) | 31));\n  }\n\n  function encodeUInt(BufferChainlink.buffer memory buf, uint value) internal pure {\n    if(value > 0xFFFFFFFFFFFFFFFF) {\n      encodeBigNum(buf, value);\n    } else {\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n    }\n  }\n\n  function encodeInt(BufferChainlink.buffer memory buf, int value) internal pure {\n    if(value < -0x10000000000000000) {\n      encodeSignedBigNum(buf, value);\n    } else if(value > 0xFFFFFFFFFFFFFFFF) {\n      encodeBigNum(buf, uint(value));\n    } else if(value >= 0) {\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(uint256(value)));\n    } else {\n      encodeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(uint256(-1 - value)));\n    }\n  }\n\n  function encodeBytes(BufferChainlink.buffer memory buf, bytes memory value) internal pure {\n    encodeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n    buf.append(value);\n  }\n\n  function encodeBigNum(BufferChainlink.buffer memory buf, uint value) internal pure {\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n    encodeBytes(buf, abi.encode(value));\n  }\n\n  function encodeSignedBigNum(BufferChainlink.buffer memory buf, int input) internal pure {\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM));\n    encodeBytes(buf, abi.encode(uint256(-1 - input)));\n  }\n\n  function encodeString(BufferChainlink.buffer memory buf, string memory value) internal pure {\n    encodeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n    buf.append(bytes(value));\n  }\n\n  function startArray(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n  }\n\n  function startMap(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n  }\n\n  function endSequence(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n  }\n}\n"}, "@chainlink/contracts/src/v0.8/interfaces/OracleInterface.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface OracleInterface {\n  function fulfillOracleRequest(\n    bytes32 requestId,\n    uint256 payment,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 expiration,\n    bytes32 data\n  ) external returns (bool);\n\n  function isAuthorizedSender(address node) external view returns (bool);\n\n  function withdraw(address recipient, uint256 amount) external;\n\n  function withdrawable() external view returns (uint256);\n}\n"}, "contracts/RelayerContract.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"./structs/ApprovalsStruct.sol\";\nimport \"./interfaces/IAssetStoreFactory.sol\";\nimport \"./interfaces/IAssetStore.sol\";\nimport \"./interfaces/IMember.sol\";\nimport \"./interfaces/IProtocolDirectory.sol\";\nimport \"./libraries/Errors.sol\";\n\n/**\n * @title RelayerContract\n *\n * Logic for communicatiing with the relayer and contract state\n *\n */\n\ncontract RelayerContract is\n    Initializable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    /// @dev address of the relayer account\n    address public relayerAddress;\n\n    /// @dev address ProtocolDirectory location\n    address public directoryContract;\n\n    /**\n     * @notice onlyRelayer\n     * modifier to ensure only the relayer account can make changes\n     *\n     */\n    modifier onlyRelayer() {\n        if (msg.sender != relayerAddress) {\n            revert(Errors.RC_UNAUTHORIZED);\n        }\n        _;\n    }\n\n    /**\n     * @dev initialize - Initializes the function for Ownable and Reentrancy.\n     * @param _directoryContract address of the directory contract\n     *\n     */\n    function initialize(address _directoryContract) public initializer {\n        __Context_init_unchained();\n        __Ownable_init();\n        __ReentrancyGuard_init();\n\n        directoryContract = _directoryContract;\n    }\n\n    /**\n     * @dev Set Approval Active for a Specific UID\n     * @param _uid string identifier of a user on the dApp\n     * This function is called by the predetermined relayer account\n     * to trigger that a user's will claim period is now active\n     *\n     */\n    function setApprovalActiveForUID(string memory _uid) external onlyRelayer {\n        address IAssetStoreFactoryAddress = IProtocolDirectory(\n            directoryContract\n        ).getAssetStoreFactory();\n\n        address usersAssetStoreAddress = IAssetStoreFactory(\n            IAssetStoreFactoryAddress\n        ).getAssetStoreAddress(_uid);\n        IAssetStore(usersAssetStoreAddress).setApprovalActive(_uid);\n    }\n\n    /**\n     * @dev transferUnclaimedAssets\n     * @param _userUID string identifier of a user across the dApp\n     * Triggered by the relayer once it is too late for the beneficiaries to claim\n     *\n     */\n    function transferUnclaimedAssets(string memory _userUID)\n        external\n        onlyRelayer\n    {\n        address IAssetStoreFactoryAddress = IProtocolDirectory(\n            directoryContract\n        ).getAssetStoreFactory();\n\n        address usersAssetStoreAddress = IAssetStoreFactory(\n            IAssetStoreFactoryAddress\n        ).getAssetStoreAddress(_userUID);\n\n        IAssetStore(usersAssetStoreAddress).transferUnclaimedAssets(_userUID);\n    }\n\n    /**\n     * @dev setRelayerAddress\n     * @param _relayerAddress the new address of the relayerAccount\n     * Update the relayerAccount by the owner as needed\n     *\n     */\n    function setRelayerAddress(address _relayerAddress) external onlyOwner {\n        relayerAddress = _relayerAddress;\n    }\n\n    /**\n     * @dev triggerAssetsForCharity\n     * since charities cannot claim assets, the relayer will\n     * call this function which will allocate assets per the user's\n     * will\n     * @param _userUID of the user on the dApp\n     *\n     */\n    function triggerAssetsForCharity(string memory _userUID)\n        external\n        onlyRelayer\n    {\n        address IAssetStoreFactoryAddress = IProtocolDirectory(\n            directoryContract\n        ).getAssetStoreFactory();\n\n        address usersAssetStoreAddress = IAssetStoreFactory(\n            IAssetStoreFactoryAddress\n        ).getAssetStoreAddress(_userUID);\n\n        Approvals[] memory userApprovals = IAssetStore(usersAssetStoreAddress)\n            .getApprovals(_userUID);\n\n        for (uint256 i = 0; i < userApprovals.length; i++) {\n            if (userApprovals[i].beneficiary.isCharity) {\n                IAssetStore(usersAssetStoreAddress).sendAssetsToCharity(\n                    userApprovals[i].beneficiary.beneficiaryAddress,\n                    _userUID\n                );\n            }\n        }\n    }\n}\n"}, "contracts/ProtocolDirectory.sol": {"content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"./interfaces/IProtocolDirectory.sol\";\n\n/**\n * @title ProtocolDirectory\n *\n * This contract will serve as the global store of\n * addresses related to the Webacy smart contract suite.\n * With this Directory we can upgrade/change references to contracts\n * and ensure the rest of the suite will be upgraded at the same time.\n *\n *\n */\n\ncontract ProtocolDirectory is\n    Initializable,\n    OwnableUpgradeable,\n    IProtocolDirectory\n{\n    mapping(bytes32 => address) private _addresses;\n\n    bytes32 private constant ASSET_STORE_FACTORY = \"ASSET_STORE_FACTORY\";\n    bytes32 private constant MEMBERSHIP_FACTORY = \"MEMBERSHIP_FACTORY\";\n    bytes32 private constant RELAYER_CONTRACT = \"RELAYER_CONTRACT\";\n    bytes32 private constant MEMBER_CONTRACT = \"MEMBER_CONTRACT\";\n    bytes32 private constant BLACKLIST_CONTRACT = \"BLACKLIST_CONTRACT\";\n    bytes32 private constant WHITELIST_CONTRACT = \"WHITELIST_CONTRACT\";\n    bytes32 private constant TRANSFER_POOL = \"TRANSFER_POOL\";\n    bytes32 private constant CHAINLINK_OPERATIONS_CONTRACT =\n        \"CHAINLINK_OPERATIONS_CONTRACT\";\n\n    /**\n     * @notice initialize function\n     *\n     * Keeping within the design pattern of the rest of the protocol\n     * this contract will also be upgradable and initializable\n     *\n     */\n    function initialize() public initializer {\n        __Context_init_unchained();\n        __Ownable_init();\n    }\n\n    /**\n     * @notice getAddress\n     * @param _contractName string representing the contract you are looking for\n     *\n     * Use this function to get the locations of the deployed addresses;\n     */\n    function getAddress(bytes32 _contractName) public view returns (address) {\n        return _addresses[_contractName];\n    }\n\n    /**\n     * @notice setAddress\n     * @param _contractName bytes32 name to lookup the contract\n     * @param _contractLocation address of the deployment being referenced\n     *\n     *\n     */\n    function setAddress(bytes32 _contractName, address _contractLocation)\n        public\n        onlyOwner\n        returns (address)\n    {\n        _addresses[_contractName] = _contractLocation;\n        return _contractLocation;\n    }\n\n    //////////////////////////\n    //////Get Functions//////\n    /////////////////////////\n\n    /**\n     * @notice ssetStoreFactory\n     * @return address of protocol contract matching ASSET_STORE_FACTORY value\n     *\n     */\n    function getAssetStoreFactory() external view returns (address) {\n        return getAddress(ASSET_STORE_FACTORY);\n    }\n\n    /**\n     * @notice getMembershipFactory\n     * @return address of protocol contract matching MEMBERSHIP_FACTORY value\n     *\n     */\n    function getMembershipFactory() external view returns (address) {\n        return getAddress(MEMBERSHIP_FACTORY);\n    }\n\n    /**\n     * @notice getRelayerContract\n     * @return address of protocol contract matching RELAYER_CONTRACT value\n     *\n     */\n    function getRelayerContract() external view returns (address) {\n        return getAddress(RELAYER_CONTRACT);\n    }\n\n    /**\n     * @notice getMemberContract\n     * @return address of protocol contract matching MEMBER_CONTRACT value\n     *\n     */\n    function getMemberContract() external view returns (address) {\n        return getAddress(MEMBER_CONTRACT);\n    }\n\n    /**\n     * @notice getBlacklistContract\n     * @return address of protocol contract matching BLACKLIST_CONTRACT value\n     *\n     */\n    function getBlacklistContract() external view returns (address) {\n        return getAddress(BLACKLIST_CONTRACT);\n    }\n\n    /**\n     * @notice getWhitelistContract\n     * @return address of protocol contract matching WHITELIST_CONTRACT value\n     *\n     */\n    function getWhitelistContract() external view returns (address) {\n        return getAddress(WHITELIST_CONTRACT);\n    }\n\n    /**\n     * @notice getTransferPool\n     * @return address of protocol contract matching TRANSFER_POOL value\n     *\n     */\n    function getTransferPool() external view returns (address) {\n        return getAddress(TRANSFER_POOL);\n    }\n\n    /**\n     * @notice getChainlinkOperationsContract\n     * @return address of protocol contract matching CHAINLINK_OPERATIONS_CON value\n     *\n     */\n    function getChainlinkOperationsContract() external view returns (address) {\n        return getAddress(CHAINLINK_OPERATIONS_CONTRACT);\n    }\n\n    //////////////////////////\n    //////Set Functions//////\n    /////////////////////////\n\n    /**\n     * @dev setAssetStoreFactory\n     * @param _contractLocation address of the new contract location\n     * @return address of the updated item as a confirmation\n     */\n    function setAssetStoreFactory(address _contractLocation)\n        external\n        onlyOwner\n        returns (address)\n    {\n        return setAddress(ASSET_STORE_FACTORY, _contractLocation);\n    }\n\n    /**\n     * @dev setMembershipFactory\n     * @param _contractLocation address of the new contract location\n     * @return address of the updated item as a confirmation\n     */\n    function setMembershipFactory(address _contractLocation)\n        external\n        onlyOwner\n        returns (address)\n    {\n        return setAddress(MEMBERSHIP_FACTORY, _contractLocation);\n    }\n\n    /**\n     * @dev setRelayerContract\n     * @param _contractLocation address of the new contract location\n     * @return address of the updated item as a confirmation\n     */\n    function setRelayerContract(address _contractLocation)\n        external\n        onlyOwner\n        returns (address)\n    {\n        return setAddress(RELAYER_CONTRACT, _contractLocation);\n    }\n\n    /**\n     * @dev setMemberContract\n     * @param _contractLocation address of the new contract location\n     * @return address of the updated item as a confirmation\n     */\n    function setMemberContract(address _contractLocation)\n        external\n        onlyOwner\n        returns (address)\n    {\n        return setAddress(MEMBER_CONTRACT, _contractLocation);\n    }\n\n    /**\n     * @dev setBlacklistContract\n     * @param _contractLocation address of the new contract location\n     * @return address of the updated item as a confirmation\n     */\n    function setBlacklistContract(address _contractLocation)\n        external\n        onlyOwner\n        returns (address)\n    {\n        return setAddress(BLACKLIST_CONTRACT, _contractLocation);\n    }\n\n    /**\n     * @dev setWhitelistContract\n     * @param _contractLocation address of the new contract location\n     * @return address of the updated item as a confirmation\n     */\n    function setWhitelistContract(address _contractLocation)\n        external\n        onlyOwner\n        returns (address)\n    {\n        return setAddress(WHITELIST_CONTRACT, _contractLocation);\n    }\n\n    /**\n     * @dev setTransferPool\n     * @param _contractLocation address of the new contract location\n     * @return address of the updated item as a confirmation\n     */\n    function setTransferPool(address _contractLocation)\n        external\n        onlyOwner\n        returns (address)\n    {\n        return setAddress(TRANSFER_POOL, _contractLocation);\n    }\n\n    /**\n     * @dev setChainlinkOperationsContract\n     * @param _contractLocation address of the new contract location\n     * @return address of the updated item as a confirmation\n     */\n    function setChainlinkOperationsContract(address _contractLocation)\n        external\n        onlyOwner\n        returns (address)\n    {\n        return setAddress(CHAINLINK_OPERATIONS_CONTRACT, _contractLocation);\n    }\n}\n"}, "contracts/utils/ERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title WebacyToken\n * Reference erc20 token for testing purposes\n */\ncontract WebacyToken is ERC20 {\n    constructor(\n        uint256 initialSupply,\n        string memory name,\n        string memory symbol\n    ) ERC20(name, symbol) {\n        _mint(msg.sender, initialSupply);\n    }\n}\n"}, "contracts/utils/ERC1155.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n\n/**\n * @title WebacyToken\n * Reference ERC1155 token for testing purposes\n * with easy method for creating many tokenIds\n *\n */\ncontract Webacy1155 is ERC1155 {\n    uint256 public tokenID = 0;\n    mapping(uint256 => uint256) public existence;\n    string public symbol;\n\n    constructor(string memory _symbol)\n        ERC1155(\"https://webacy.example/api/item/{id}.json\")\n    {\n        symbol = _symbol;\n    }\n\n    function selfMint(uint256 _amount) external {\n        privateMint(_amount, msg.sender);\n    }\n\n    function publicMint(uint256 _amount, address _address) external {\n        privateMint(_amount, _address);\n    }\n\n    function privateMint(uint256 _amount, address _address) private {\n        _mint(_address, tokenID, _amount, \"\");\n        existence[tokenID] = _amount;\n        tokenID++;\n    }\n}\n"}, "contracts/utils/ERC721.sol": {"content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\n/**\n * @title WebacyToken\n * Reference ERC721 token for testing purposes\n */\ncontract WebacyNFT is ERC721 {\n    mapping(string => uint8) public hashes;\n    uint256 _tokenIds = 0;\n\n    constructor(string memory name, string memory symbol)\n        ERC721(name, symbol)\n    {}\n\n    function mint(address recipient, string memory hash)\n        public\n        returns (uint256)\n    {\n        require(hashes[hash] != 1, \"Hash already minted\");\n\n        hashes[hash] = 1;\n\n        uint256 newItemId = _tokenIds;\n        _mint(recipient, newItemId);\n\n        _tokenIds++;\n\n        return newItemId;\n    }\n}\n"}, "@openzeppelin/contracts/utils/Counters.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"}}, "settings": {"optimizer": {"enabled": true, "runs": 200}, "viaIR": true, "outputSelection": {"*": {"*": ["abi", "metadata", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers", "evm.legacyAssembly", "evm.bytecode.opcodes"]}}, "libraries": {"contracts/libraries/TokenActions.sol": {"TokenActions": "0x3249e80783945d59867b44de8dca44c5af20bf8e"}}, "metadata": {"appendCBOR": false}}}