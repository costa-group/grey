{"language": "Solidity", "sources": {"@offchainlabs/upgrade-executor/src/IUpgradeExecutor.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\ninterface IUpgradeExecutor {\n    function initialize(address admin, address[] memory executors) external;\n    function execute(address upgrade, bytes memory upgradeCallData) external payable;\n    function executeCall(address target, bytes memory targetCallData) external payable;\n}\n"}, "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.30;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"}, "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"}, "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"}, "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"}, "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"}, "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"}, "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"}, "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.30;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"}, "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.30;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"}, "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"}, "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"}, "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"}, "@openzeppelin/contracts/access/Ownable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"}, "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"}, "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"}, "@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/UpgradeableBeacon.sol)\n\npragma solidity ^0.8.30;\n\nimport \"./IBeacon.sol\";\nimport \"../../access/Ownable.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\n * implementation contract, which is where they will delegate all function calls.\n *\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\n */\ncontract UpgradeableBeacon is IBeacon, Ownable {\n    address private _implementation;\n\n    /**\n     * @dev Emitted when the implementation returned by the beacon is changed.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\n     * beacon.\n     */\n    constructor(address implementation_) {\n        _setImplementation(implementation_);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function implementation() public view virtual override returns (address) {\n        return _implementation;\n    }\n\n    /**\n     * @dev Upgrades the beacon to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * Requirements:\n     *\n     * - msg.sender must be the owner of the contract.\n     * - `newImplementation` must be a contract.\n     */\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation contract address for this beacon\n     *\n     * Requirements:\n     *\n     * - `newImplementation` must be a contract.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"UpgradeableBeacon: implementation is not a contract\");\n        _implementation = newImplementation;\n    }\n}\n"}, "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"}, "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"}, "@openzeppelin/contracts/proxy/Proxy.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"}, "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.30;\n\nimport \"./TransparentUpgradeableProxy.sol\";\nimport \"../../access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"}, "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"}, "@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is IERC1822Proxiable, ERC1967Upgrade {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate that the this implementation remains valid after an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n}\n"}, "@openzeppelin/contracts/security/ReentrancyGuard.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"}, "@openzeppelin/contracts/token/ERC20/ERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.30;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"}, "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"}, "@openzeppelin/contracts/token/ERC20/IERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"}, "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"}, "@openzeppelin/contracts/utils/Address.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"}, "@openzeppelin/contracts/utils/Context.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"}, "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"}, "@openzeppelin/contracts/utils/StorageSlot.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"}, "@openzeppelin/contracts/utils/Strings.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"}, "solady/src/utils/MinHeapLib.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Library for managing a min-heap in storage or memory.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/MinHeapLib.sol)\nlibrary MinHeapLib {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The heap is empty.\n    error HeapIsEmpty();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          STRUCTS                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev A heap in storage.\n    struct Heap {\n        uint256[] data;\n    }\n\n    /// @dev A heap in memory.\n    struct MemHeap {\n        uint256[] data;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         OPERATIONS                         */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    // Tips:\n    // - To use as a max-heap, bitwise negate the input and output values (e.g. `heap.push(~x)`).\n    // - To use on tuples, pack the tuple values into a single integer.\n    // - To use on signed integers, convert the signed integers into\n    //   their ordered unsigned counterparts via `uint256(x) + (1 << 255)`.\n\n    /// @dev Returns the minimum value of the heap.\n    /// Reverts if the heap is empty.\n    function root(Heap storage heap) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(sload(heap.slot)) {\n                mstore(0x00, 0xa6ca772e) // `HeapIsEmpty()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, heap.slot)\n            result := sload(keccak256(0x00, 0x20))\n        }\n    }\n\n    /// @dev Returns the minimum value of the heap.\n    /// Reverts if the heap is empty.\n    function root(MemHeap memory heap) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(heap)\n            if iszero(mload(result)) {\n                mstore(0x00, 0xa6ca772e) // `HeapIsEmpty()`.\n                revert(0x1c, 0x04)\n            }\n            result := mload(add(0x20, result))\n        }\n    }\n\n    /// @dev Reserves at least `minimum` slots of memory for the heap.\n    /// Helps avoid reallocation if you already know the max size of the heap.\n    function reserve(MemHeap memory heap, uint256 minimum) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let prime := 5936628702318599\n            let cap := mload(add(mload(heap), w))\n            if gt(minimum, mul(iszero(mod(cap, prime)), div(cap, prime))) {\n                let data := mload(heap)\n                let n := mload(data)\n                let newCap := and(add(minimum, 0x1f), w) // Round up to multiple of 32.\n                mstore(mload(0x40), mul(newCap, prime))\n                let m := add(mload(0x40), 0x20)\n                mstore(m, n) // Store the length.\n                mstore(0x40, add(add(m, 0x20), shl(5, newCap))) // Allocate `heap.data` memory.\n                mstore(heap, m) // Update `heap.data`.\n                if n {\n                    for { let i := shl(5, n) } 1 {} {\n                        mstore(add(m, i), mload(add(data, i)))\n                        i := add(i, w)\n                        if iszero(i) { break }\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns an array of the `k` smallest items in the heap,\n    /// sorted in ascending order, without modifying the heap.\n    /// If the heap has less than `k` items, all items in the heap will be returned.\n    function smallest(Heap storage heap, uint256 k) internal view returns (uint256[] memory a) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function pIndex(h_, p_) -> _i {\n                _i := mload(add(0x20, add(h_, shl(6, p_))))\n            }\n            function pValue(h_, p_) -> _v {\n                _v := mload(add(h_, shl(6, p_)))\n            }\n            function pSet(h_, p_, i_, v_) {\n                mstore(add(h_, shl(6, p_)), v_)\n                mstore(add(0x20, add(h_, shl(6, p_))), i_)\n            }\n            function pSiftdown(h_, p_, i_, v_) {\n                for {} 1 {} {\n                    let u_ := shr(1, sub(p_, 1))\n                    if iszero(mul(p_, lt(v_, pValue(h_, u_)))) { break }\n                    pSet(h_, p_, pIndex(h_, u_), pValue(h_, u_))\n                    p_ := u_\n                }\n                pSet(h_, p_, i_, v_)\n            }\n            function pSiftup(h_, e_, i_, v_) {\n                let p_ := 0\n                for { let c_ := 1 } lt(c_, e_) { c_ := add(1, shl(1, p_)) } {\n                    c_ := add(c_, gt(pValue(h_, c_), pValue(h_, add(c_, lt(add(c_, 1), e_)))))\n                    pSet(h_, p_, pIndex(h_, c_), pValue(h_, c_))\n                    p_ := c_\n                }\n                pSiftdown(h_, p_, i_, v_)\n            }\n            a := mload(0x40)\n            mstore(0x00, heap.slot)\n            let sOffset := keccak256(0x00, 0x20)\n            let o := add(a, 0x20) // Offset into `a`.\n            let n := sload(heap.slot) // The number of items in the heap.\n            let m := xor(n, mul(xor(n, k), lt(k, n))) // `min(k, n)`.\n            let h := add(o, shl(5, m)) // Priority queue.\n            pSet(h, 0, 0, sload(sOffset)) // Store the root into the priority queue.\n            for { let e := iszero(eq(o, h)) } e {} {\n                mstore(o, pValue(h, 0))\n                o := add(0x20, o)\n                if eq(o, h) { break }\n                let childPos := add(shl(1, pIndex(h, 0)), 1)\n                if iszero(lt(childPos, n)) {\n                    e := sub(e, 1)\n                    pSiftup(h, e, pIndex(h, e), pValue(h, e))\n                    continue\n                }\n                pSiftup(h, e, childPos, sload(add(sOffset, childPos)))\n                childPos := add(1, childPos)\n                if iszero(eq(childPos, n)) {\n                    pSiftdown(h, e, childPos, sload(add(sOffset, childPos)))\n                    e := add(e, 1)\n                }\n            }\n            mstore(a, shr(5, sub(o, add(a, 0x20)))) // Store the length.\n            mstore(0x40, o) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns an array of the `k` smallest items in the heap,\n    /// sorted in ascending order, without modifying the heap.\n    /// If the heap has less than `k` items, all items in the heap will be returned.\n    function smallest(MemHeap memory heap, uint256 k) internal pure returns (uint256[] memory a) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function pIndex(h_, p_) -> _i {\n                _i := mload(add(0x20, add(h_, shl(6, p_))))\n            }\n            function pValue(h_, p_) -> _v {\n                _v := mload(add(h_, shl(6, p_)))\n            }\n            function pSet(h_, p_, i_, v_) {\n                mstore(add(h_, shl(6, p_)), v_)\n                mstore(add(0x20, add(h_, shl(6, p_))), i_)\n            }\n            function pSiftdown(h_, p_, i_, v_) {\n                for {} 1 {} {\n                    let u_ := shr(1, sub(p_, 1))\n                    if iszero(mul(p_, lt(v_, pValue(h_, u_)))) { break }\n                    pSet(h_, p_, pIndex(h_, u_), pValue(h_, u_))\n                    p_ := u_\n                }\n                pSet(h_, p_, i_, v_)\n            }\n            function pSiftup(h_, e_, i_, v_) {\n                let p_ := 0\n                for { let c_ := 1 } lt(c_, e_) { c_ := add(1, shl(1, p_)) } {\n                    c_ := add(c_, gt(pValue(h_, c_), pValue(h_, add(c_, lt(add(c_, 1), e_)))))\n                    pSet(h_, p_, pIndex(h_, c_), pValue(h_, c_))\n                    p_ := c_\n                }\n                pSiftdown(h_, p_, i_, v_)\n            }\n            a := mload(0x40)\n            let sOffset := add(mload(heap), 0x20)\n            let o := add(a, 0x20) // Offset into `a`.\n            let n := mload(mload(heap)) // The number of items in the heap.\n            let m := xor(n, mul(xor(n, k), lt(k, n))) // `min(k, n)`.\n            let h := add(o, shl(5, m)) // Priority queue.\n            pSet(h, 0, 0, mload(sOffset)) // Store the root into the priority queue.\n            for { let e := iszero(eq(o, h)) } e {} {\n                mstore(o, pValue(h, 0))\n                o := add(0x20, o)\n                if eq(o, h) { break }\n                let childPos := add(shl(1, pIndex(h, 0)), 1)\n                if iszero(lt(childPos, n)) {\n                    e := sub(e, 1)\n                    pSiftup(h, e, pIndex(h, e), pValue(h, e))\n                    continue\n                }\n                pSiftup(h, e, childPos, mload(add(sOffset, shl(5, childPos))))\n                childPos := add(1, childPos)\n                if iszero(eq(childPos, n)) {\n                    pSiftdown(h, e, childPos, mload(add(sOffset, shl(5, childPos))))\n                    e := add(e, 1)\n                }\n            }\n            mstore(a, shr(5, sub(o, add(a, 0x20)))) // Store the length.\n            mstore(0x40, o) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the number of items in the heap.\n    function length(Heap storage heap) internal view returns (uint256) {\n        return heap.data.length;\n    }\n\n    /// @dev Returns the number of items in the heap.\n    function length(MemHeap memory heap) internal pure returns (uint256) {\n        return heap.data.length;\n    }\n\n    /// @dev Pushes the `value` onto the min-heap.\n    function push(Heap storage heap, uint256 value) internal {\n        _set(heap, value, 0, 3);\n    }\n\n    /// @dev Pushes the `value` onto the min-heap.\n    function push(MemHeap memory heap, uint256 value) internal pure {\n        _set(heap, value, 0, 3);\n    }\n\n    /// @dev Pops the minimum value from the min-heap.\n    /// Reverts if the heap is empty.\n    function pop(Heap storage heap) internal returns (uint256 popped) {\n        (, popped) = _set(heap, 0, 0, 2);\n    }\n\n    /// @dev Pops the minimum value from the min-heap.\n    /// Reverts if the heap is empty.\n    function pop(MemHeap memory heap) internal pure returns (uint256 popped) {\n        (, popped) = _set(heap, 0, 0, 2);\n    }\n\n    /// @dev Pushes the `value` onto the min-heap, and pops the minimum value.\n    function pushPop(Heap storage heap, uint256 value) internal returns (uint256 popped) {\n        (, popped) = _set(heap, value, 0, 4);\n    }\n\n    /// @dev Pushes the `value` onto the min-heap, and pops the minimum value.\n    function pushPop(MemHeap memory heap, uint256 value) internal pure returns (uint256 popped) {\n        (, popped) = _set(heap, value, 0, 4);\n    }\n\n    /// @dev Pops the minimum value, and pushes the new `value` onto the min-heap.\n    /// Reverts if the heap is empty.\n    function replace(Heap storage heap, uint256 value) internal returns (uint256 popped) {\n        (, popped) = _set(heap, value, 0, 1);\n    }\n\n    /// @dev Pops the minimum value, and pushes the new `value` onto the min-heap.\n    /// Reverts if the heap is empty.\n    function replace(MemHeap memory heap, uint256 value) internal pure returns (uint256 popped) {\n        (, popped) = _set(heap, value, 0, 1);\n    }\n\n    /// @dev Pushes the `value` onto the min-heap, and pops the minimum value\n    /// if the length of the heap exceeds `maxLength`.\n    ///\n    /// Reverts if `maxLength` is zero.\n    ///\n    /// - If the queue is not full:\n    ///   (`success` = true, `hasPopped` = false, `popped` = 0)\n    /// - If the queue is full, and `value` is not greater than the minimum value:\n    ///   (`success` = false, `hasPopped` = false, `popped` = 0)\n    /// - If the queue is full, and `value` is greater than the minimum value:\n    ///   (`success` = true, `hasPopped` = true, `popped` = <minimum value>)\n    ///\n    /// Useful for implementing a bounded priority queue.\n    function enqueue(Heap storage heap, uint256 value, uint256 maxLength)\n        internal\n        returns (bool success, bool hasPopped, uint256 popped)\n    {\n        (value, popped) = _set(heap, value, maxLength, 0);\n        /// @solidity memory-safe-assembly\n        assembly {\n            hasPopped := eq(3, value)\n            success := value\n        }\n    }\n\n    /// @dev Pushes the `value` onto the min-heap, and pops the minimum value\n    /// if the length of the heap exceeds `maxLength`.\n    ///\n    /// Reverts if `maxLength` is zero.\n    ///\n    /// - If the queue is not full:\n    ///   (`success` = true, `hasPopped` = false, `popped` = 0)\n    /// - If the queue is full, and `value` is not greater than the minimum value:\n    ///   (`success` = false, `hasPopped` = false, `popped` = 0)\n    /// - If the queue is full, and `value` is greater than the minimum value:\n    ///   (`success` = true, `hasPopped` = true, `popped` = <minimum value>)\n    ///\n    /// Useful for implementing a bounded priority queue.\n    function enqueue(MemHeap memory heap, uint256 value, uint256 maxLength)\n        internal\n        pure\n        returns (bool success, bool hasPopped, uint256 popped)\n    {\n        (value, popped) = _set(heap, value, maxLength, 0);\n        /// @solidity memory-safe-assembly\n        assembly {\n            hasPopped := eq(3, value)\n            success := value\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Helper function for heap operations.\n    /// Designed for code conciseness, bytecode compactness, and decent performance.\n    function _set(Heap storage heap, uint256 value, uint256 maxLength, uint256 mode)\n        private\n        returns (uint256 status, uint256 popped)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := sload(heap.slot)\n            mstore(0x00, heap.slot)\n            let sOffset := keccak256(0x00, 0x20) // Array storage slot offset.\n            let pos := 0\n            let childPos := not(0)\n            // Operations are ordered from most likely usage to least likely usage.\n            for {} 1 {\n                mstore(0x00, 0xa6ca772e) // `HeapIsEmpty()`.\n                revert(0x1c, 0x04)\n            } {\n                // Mode: `enqueue`.\n                if iszero(mode) {\n                    if iszero(maxLength) { continue }\n                    // If queue is not full.\n                    if iszero(eq(n, maxLength)) {\n                        status := 1\n                        pos := n\n                        // Increment and update the length.\n                        sstore(heap.slot, add(pos, 1))\n                        childPos := sOffset\n                        break\n                    }\n                    let r := sload(sOffset)\n                    if iszero(lt(r, value)) { break }\n                    status := 3\n                    childPos := 1\n                    popped := r\n                    break\n                }\n                if iszero(gt(mode, 2)) {\n                    if iszero(n) { continue }\n                    // Mode: `pop`.\n                    if eq(mode, 2) {\n                        // Decrement and update the length.\n                        n := sub(n, 1)\n                        sstore(heap.slot, n)\n                        // Set the `value` to the last item.\n                        value := sload(add(sOffset, n))\n                        popped := value\n                        if iszero(n) { break }\n                    }\n                    // Mode: `replace`.\n                    popped := sload(sOffset)\n                    childPos := 1\n                    break\n                }\n                // Mode: `push`.\n                if eq(mode, 3) {\n                    // Increment and update the length.\n                    pos := n\n                    sstore(heap.slot, add(pos, 1))\n                    childPos := sOffset\n                    break\n                }\n                // Mode: `pushPop`.\n                popped := value\n                if iszero(n) { break }\n                let r := sload(sOffset)\n                if iszero(lt(r, value)) { break }\n                popped := r\n                childPos := 1\n                break\n            }\n            // Siftup.\n            for {} lt(childPos, n) {} {\n                let child := sload(add(sOffset, childPos))\n                let rightPos := add(childPos, 1)\n                let right := sload(add(sOffset, rightPos))\n                if iszero(gt(lt(rightPos, n), lt(child, right))) {\n                    right := child\n                    rightPos := childPos\n                }\n                sstore(add(sOffset, pos), right)\n                pos := rightPos\n                childPos := add(shl(1, pos), 1)\n            }\n            // Siftdown.\n            for {} pos {} {\n                let parentPos := shr(1, sub(pos, 1))\n                let parent := sload(add(sOffset, parentPos))\n                if iszero(lt(value, parent)) { break }\n                sstore(add(sOffset, pos), parent)\n                pos := parentPos\n            }\n            // If `childPos` has been changed from `not(0)`.\n            if add(childPos, 1) { sstore(add(sOffset, pos), value) }\n        }\n    }\n\n    /// @dev Helper function for heap operations.\n    /// Designed for code conciseness, bytecode compactness, and decent performance.\n    function _set(MemHeap memory heap, uint256 value, uint256 maxLength, uint256 mode)\n        private\n        pure\n        returns (uint256 status, uint256 popped)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let data := mload(heap)\n            let n := mload(data)\n            // Allocation / reallocation. Abuse `cap` being a multiple of 32 to early skip.\n            for {} iszero(and(n, 0x1f)) {} {\n                let cap := mload(sub(data, 0x20))\n                let prime := 5936628702318599\n                cap := mul(iszero(mod(cap, prime)), div(cap, prime))\n                if lt(n, cap) { break }\n                let newCap := add(shl(1, cap), shl(5, iszero(cap)))\n                mstore(mload(0x40), mul(newCap, prime)) // Update `heap.capacity`.\n                let m := add(mload(0x40), 0x20)\n                mstore(m, n) // Store the length.\n                mstore(0x40, add(add(m, 0x20), shl(5, newCap))) // Allocate `heap.data` memory.\n                if cap {\n                    let w := not(0x1f)\n                    for { let i := shl(5, cap) } 1 {} {\n                        mstore(add(m, i), mload(add(data, i)))\n                        i := add(i, w)\n                        if iszero(i) { break }\n                    }\n                }\n                mstore(heap, m) // Update `heap.data`.\n                data := m\n                break\n            }\n            let sOffset := add(data, 0x20) // Array memory offset.\n            let pos := 0\n            let childPos := not(0)\n            // Operations are ordered from most likely usage to least likely usage.\n            for {} 1 {\n                mstore(0x00, 0xa6ca772e) // `HeapIsEmpty()`.\n                revert(0x1c, 0x04)\n            } {\n                // Mode: `enqueue`.\n                if iszero(mode) {\n                    if iszero(maxLength) { continue }\n                    // If queue is not full.\n                    if iszero(eq(n, maxLength)) {\n                        status := 1\n                        pos := n\n                        // Increment and update the length.\n                        mstore(data, add(pos, 1))\n                        childPos := 0xff0000000000000000\n                        break\n                    }\n                    if iszero(lt(mload(sOffset), value)) { break }\n                    status := 3\n                    childPos := 1\n                    popped := mload(sOffset)\n                    break\n                }\n                if iszero(gt(mode, 2)) {\n                    if iszero(n) { continue }\n                    // Mode: `pop`.\n                    if eq(mode, 2) {\n                        // Decrement and update the length.\n                        n := sub(n, 1)\n                        mstore(data, n)\n                        // Set the `value` to the last item.\n                        value := mload(add(sOffset, shl(5, n)))\n                        popped := value\n                        if iszero(n) { break }\n                    }\n                    // Mode: `replace`.\n                    popped := mload(sOffset)\n                    childPos := 1\n                    break\n                }\n                // Mode: `push`.\n                if eq(mode, 3) {\n                    // Increment and update the length.\n                    pos := n\n                    mstore(data, add(pos, 1))\n                    childPos := 0xff0000000000000000\n                    break\n                }\n                // Mode: `pushPop`.\n                if iszero(mul(n, lt(mload(sOffset), value))) {\n                    popped := value\n                    break\n                }\n                popped := mload(sOffset)\n                childPos := 1\n                break\n            }\n            // Siftup.\n            for {} lt(childPos, n) {} {\n                let child := mload(add(sOffset, shl(5, childPos)))\n                let rightPos := add(childPos, 1)\n                let right := mload(add(sOffset, shl(5, rightPos)))\n                if iszero(gt(lt(rightPos, n), lt(child, right))) {\n                    mstore(add(sOffset, shl(5, pos)), child)\n                    pos := childPos\n                    childPos := add(shl(1, pos), 1)\n                    continue\n                }\n                mstore(add(sOffset, shl(5, pos)), right)\n                pos := rightPos\n                childPos := add(shl(1, pos), 1)\n            }\n            // Siftdown.\n            for {} pos {} {\n                let parentPos := shr(1, sub(pos, 1))\n                let parent := mload(add(sOffset, shl(5, parentPos)))\n                if iszero(lt(value, parent)) { break }\n                mstore(add(sOffset, shl(5, pos)), parent)\n                pos := parentPos\n            }\n            // If `childPos` has been changed from `not(0)`.\n            if iszero(shr(128, childPos)) { mstore(add(sOffset, shl(5, pos)), value) }\n        }\n    }\n}\n"}, "src/bridge/AbsBridge.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {L1MessageType_ethDeposit} from \"../libraries/MessageTypes.sol\";\n\nimport {\n    NotContract,\n    NotRollupOrOwner,\n    NotDelayedInbox,\n    NotSequencerInbox,\n    NotOutbox,\n    InvalidOutboxSet,\n    BadSequencerMessageNumber\n} from \"../libraries/Error.sol\";\nimport \"./IBridge.sol\";\nimport \"./Messages.sol\";\nimport \"../libraries/DelegateCallAware.sol\";\n\nimport {L1MessageType_batchPostingReport} from \"../libraries/MessageTypes.sol\";\n\n/**\n * @title Staging ground for incoming and outgoing messages\n * @notice Holds the inbox accumulator for sequenced and delayed messages.\n * Since the escrow is held here, this contract also contains a list of allowed\n * outboxes that can make calls from here and withdraw this escrow.\n */\nabstract contract AbsBridge is Initializable, DelegateCallAware, IBridge {\n    using AddressUpgradeable for address;\n\n    struct InOutInfo {\n        uint256 index;\n        bool allowed;\n    }\n\n    mapping(address => InOutInfo) private allowedDelayedInboxesMap;\n    mapping(address => InOutInfo) private allowedOutboxesMap;\n\n    address[] public allowedDelayedInboxList;\n    address[] public allowedOutboxList;\n\n    address internal _activeOutbox;\n\n    /// @inheritdoc IBridge\n    bytes32[] public delayedInboxAccs;\n\n    /// @inheritdoc IBridge\n    bytes32[] public sequencerInboxAccs;\n\n    IOwnable public rollup;\n    address public sequencerInbox;\n\n    uint256 public override sequencerReportedSubMessageCount;\n\n    address internal constant EMPTY_ACTIVEOUTBOX = address(type(uint160).max);\n\n    modifier onlyRollupOrOwner() {\n        if (msg.sender != address(rollup)) {\n            address rollupOwner = rollup.owner();\n            if (msg.sender != rollupOwner) {\n                revert NotRollupOrOwner(msg.sender, address(rollup), rollupOwner);\n            }\n        }\n        _;\n    }\n\n    /// @notice Allows the rollup owner to set another rollup address\n    function updateRollupAddress(IOwnable _rollup) external onlyRollupOrOwner {\n        rollup = _rollup;\n        emit RollupUpdated(address(_rollup));\n    }\n\n    /// @dev returns the address of current active Outbox, or zero if no outbox is active\n    function activeOutbox() public view returns (address) {\n        address outbox = _activeOutbox;\n        // address zero is returned if no outbox is set, but the value used in storage\n        // is non-zero to save users some gas (as storage refunds are usually maxed out)\n        // EIP-1153 would help here.\n        // we don't return `EMPTY_ACTIVEOUTBOX` to avoid a breaking change on the current api\n        if (outbox == EMPTY_ACTIVEOUTBOX) return address(0);\n        return outbox;\n    }\n\n    function allowedDelayedInboxes(address inbox) public view returns (bool) {\n        return allowedDelayedInboxesMap[inbox].allowed;\n    }\n\n    function allowedOutboxes(address outbox) public view returns (bool) {\n        return allowedOutboxesMap[outbox].allowed;\n    }\n\n    modifier onlySequencerInbox() {\n        if (msg.sender != sequencerInbox) revert NotSequencerInbox(msg.sender);\n        _;\n    }\n\n    function enqueueSequencerMessage(\n        bytes32 dataHash,\n        uint256 afterDelayedMessagesRead,\n        uint256 prevMessageCount,\n        uint256 newMessageCount\n    )\n        external\n        onlySequencerInbox\n        returns (\n            uint256 seqMessageIndex,\n            bytes32 beforeAcc,\n            bytes32 delayedAcc,\n            bytes32 acc\n        )\n    {\n        if (\n            sequencerReportedSubMessageCount != prevMessageCount &&\n            prevMessageCount != 0 &&\n            sequencerReportedSubMessageCount != 0\n        ) {\n            revert BadSequencerMessageNumber(sequencerReportedSubMessageCount, prevMessageCount);\n        }\n        sequencerReportedSubMessageCount = newMessageCount;\n        seqMessageIndex = sequencerInboxAccs.length;\n        if (sequencerInboxAccs.length > 0) {\n            beforeAcc = sequencerInboxAccs[sequencerInboxAccs.length - 1];\n        }\n        if (afterDelayedMessagesRead > 0) {\n            delayedAcc = delayedInboxAccs[afterDelayedMessagesRead - 1];\n        }\n        acc = keccak256(abi.encodePacked(beforeAcc, dataHash, delayedAcc));\n        sequencerInboxAccs.push(acc);\n    }\n\n    /// @inheritdoc IBridge\n    function submitBatchSpendingReport(address sender, bytes32 messageDataHash)\n        external\n        onlySequencerInbox\n        returns (uint256)\n    {\n        return\n            addMessageToDelayedAccumulator(\n                L1MessageType_batchPostingReport,\n                sender,\n                uint64(block.number),\n                uint64(block.timestamp), // solhint-disable-line not-rely-on-time,\n                block.basefee,\n                messageDataHash\n            );\n    }\n\n    function _enqueueDelayedMessage(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash,\n        uint256 amount\n    ) internal returns (uint256) {\n        if (!allowedDelayedInboxes(msg.sender)) revert NotDelayedInbox(msg.sender);\n\n        uint256 messageCount = addMessageToDelayedAccumulator(\n            kind,\n            sender,\n            uint64(block.number),\n            uint64(block.timestamp), // solhint-disable-line not-rely-on-time\n            _baseFeeToReport(),\n            messageDataHash\n        );\n\n        _transferFunds(amount);\n\n        return messageCount;\n    }\n\n    function addMessageToDelayedAccumulator(\n        uint8 kind,\n        address sender,\n        uint64 blockNumber,\n        uint64 blockTimestamp,\n        uint256 baseFeeL1,\n        bytes32 messageDataHash\n    ) internal returns (uint256) {\n        uint256 count = delayedInboxAccs.length;\n        bytes32 messageHash = Messages.messageHash(\n            kind,\n            sender,\n            blockNumber,\n            blockTimestamp,\n            count,\n            baseFeeL1,\n            messageDataHash\n        );\n        bytes32 prevAcc = 0;\n        if (count > 0) {\n            prevAcc = delayedInboxAccs[count - 1];\n        }\n        delayedInboxAccs.push(Messages.accumulateInboxMessage(prevAcc, messageHash));\n        emit MessageDelivered(\n            count,\n            prevAcc,\n            msg.sender,\n            kind,\n            sender,\n            messageDataHash,\n            baseFeeL1,\n            blockTimestamp\n        );\n        if (kind == L1MessageType_ethDeposit) {\n            emit DepositMessageDelivered(sender);\n        }\n        return count;\n    }\n\n    /// @inheritdoc IBridge\n    function executeCall(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bool success, bytes memory returnData) {\n        if (!allowedOutboxes(msg.sender)) revert NotOutbox(msg.sender);\n        if (data.length > 0 && !to.isContract()) revert NotContract(to);\n        address prevOutbox = _activeOutbox;\n        _activeOutbox = msg.sender;\n        // We set and reset active outbox around external call so activeOutbox remains valid during call\n\n        // We use a low level call here since we want to bubble up whether it succeeded or failed to the caller\n        // rather than reverting on failure as well as allow contract and non-contract calls\n        (success, returnData) = _executeLowLevelCall(to, value, data);\n\n        _activeOutbox = prevOutbox;\n        emit BridgeCallTriggered(msg.sender, to, value, data);\n    }\n\n    function setSequencerInbox(address _sequencerInbox) external onlyRollupOrOwner {\n        sequencerInbox = _sequencerInbox;\n        emit SequencerInboxUpdated(_sequencerInbox);\n    }\n\n    function setDelayedInbox(address inbox, bool enabled) external onlyRollupOrOwner {\n        InOutInfo storage info = allowedDelayedInboxesMap[inbox];\n        bool alreadyEnabled = info.allowed;\n        emit InboxToggle(inbox, enabled);\n        if (alreadyEnabled == enabled) {\n            return;\n        }\n        if (enabled) {\n            allowedDelayedInboxesMap[inbox] = InOutInfo(allowedDelayedInboxList.length, true);\n            allowedDelayedInboxList.push(inbox);\n        } else {\n            allowedDelayedInboxList[info.index] = allowedDelayedInboxList[\n                allowedDelayedInboxList.length - 1\n            ];\n            allowedDelayedInboxesMap[allowedDelayedInboxList[info.index]].index = info.index;\n            allowedDelayedInboxList.pop();\n            delete allowedDelayedInboxesMap[inbox];\n        }\n    }\n\n    function setOutbox(address outbox, bool enabled) external onlyRollupOrOwner {\n        if (outbox == EMPTY_ACTIVEOUTBOX) revert InvalidOutboxSet(outbox);\n\n        InOutInfo storage info = allowedOutboxesMap[outbox];\n        bool alreadyEnabled = info.allowed;\n        emit OutboxToggle(outbox, enabled);\n        if (alreadyEnabled == enabled) {\n            return;\n        }\n        if (enabled) {\n            allowedOutboxesMap[outbox] = InOutInfo(allowedOutboxList.length, true);\n            allowedOutboxList.push(outbox);\n        } else {\n            allowedOutboxList[info.index] = allowedOutboxList[allowedOutboxList.length - 1];\n            allowedOutboxesMap[allowedOutboxList[info.index]].index = info.index;\n            allowedOutboxList.pop();\n            delete allowedOutboxesMap[outbox];\n        }\n    }\n\n    function setSequencerReportedSubMessageCount(uint256 newMsgCount) external onlyRollupOrOwner {\n        sequencerReportedSubMessageCount = newMsgCount;\n    }\n\n    function delayedMessageCount() external view override returns (uint256) {\n        return delayedInboxAccs.length;\n    }\n\n    function sequencerMessageCount() external view returns (uint256) {\n        return sequencerInboxAccs.length;\n    }\n\n    /// @dev For the classic -> nitro migration. TODO: remove post-migration.\n    function acceptFundsFromOldBridge() external payable {}\n\n    /// @dev transfer funds provided to pay for crosschain msg\n    function _transferFunds(uint256 amount) internal virtual;\n\n    function _executeLowLevelCall(\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal virtual returns (bool success, bytes memory returnData);\n\n    /// @dev get base fee which is emitted in `MessageDelivered` event and then picked up and\n    /// used in ArbOs to calculate the submission fee for retryable ticket\n    function _baseFeeToReport() internal view virtual returns (uint256);\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[40] private __gap;\n}\n"}, "src/bridge/AbsInbox.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport {\n    DataTooLarge,\n    GasLimitTooLarge,\n    InsufficientValue,\n    InsufficientSubmissionCost,\n    L1Forked,\n    NotAllowedOrigin,\n    NotOrigin,\n    NotRollupOrOwner,\n    RetryableData\n} from \"../libraries/Error.sol\";\nimport \"./IInboxBase.sol\";\nimport \"./ISequencerInbox.sol\";\nimport \"./IBridge.sol\";\nimport \"../libraries/AddressAliasHelper.sol\";\nimport \"../libraries/DelegateCallAware.sol\";\nimport {\n    L1MessageType_submitRetryableTx,\n    L2MessageType_unsignedContractTx,\n    L2MessageType_unsignedEOATx,\n    L2_MSG\n} from \"../libraries/MessageTypes.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol\";\n\n/**\n * @title Inbox for user and contract originated messages\n * @notice Messages created via this inbox are enqueued in the delayed accumulator\n * to await inclusion in the SequencerInbox\n */\nabstract contract AbsInbox is DelegateCallAware, PausableUpgradeable, IInboxBase {\n    /// @dev Storage slot with the admin of the contract.\n    /// This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n    bytes32 internal constant _ADMIN_SLOT =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /// @inheritdoc IInboxBase\n    IBridge public bridge;\n    /// @inheritdoc IInboxBase\n    ISequencerInbox public sequencerInbox;\n\n    /// ------------------------------------ allow list start ------------------------------------ ///\n\n    /// @inheritdoc IInboxBase\n    bool public allowListEnabled;\n\n    /// @inheritdoc IInboxBase\n    mapping(address => bool) public isAllowed;\n\n    event AllowListAddressSet(address indexed user, bool val);\n    event AllowListEnabledUpdated(bool isEnabled);\n\n    /// @inheritdoc IInboxBase\n    function setAllowList(address[] memory user, bool[] memory val) external onlyRollupOrOwner {\n        require(user.length == val.length, \"INVALID_INPUT\");\n\n        for (uint256 i = 0; i < user.length; i++) {\n            isAllowed[user[i]] = val[i];\n            emit AllowListAddressSet(user[i], val[i]);\n        }\n    }\n\n    /// @inheritdoc IInboxBase\n    function setAllowListEnabled(bool _allowListEnabled) external onlyRollupOrOwner {\n        require(_allowListEnabled != allowListEnabled, \"ALREADY_SET\");\n        allowListEnabled = _allowListEnabled;\n        emit AllowListEnabledUpdated(_allowListEnabled);\n    }\n\n    /// @dev this modifier checks the tx.origin instead of msg.sender for convenience (ie it allows\n    /// allowed users to interact with the token bridge without needing the token bridge to be allowList aware).\n    /// this modifier is not intended to use to be used for security (since this opens the allowList to\n    /// a smart contract phishing risk).\n    modifier onlyAllowed() {\n        // solhint-disable-next-line avoid-tx-origin\n        if (allowListEnabled && !isAllowed[tx.origin]) revert NotAllowedOrigin(tx.origin);\n        _;\n    }\n\n    /// ------------------------------------ allow list end ------------------------------------ ///\n\n    modifier onlyRollupOrOwner() {\n        IOwnable rollup = bridge.rollup();\n        if (msg.sender != address(rollup)) {\n            address rollupOwner = rollup.owner();\n            if (msg.sender != rollupOwner) {\n                revert NotRollupOrOwner(msg.sender, address(rollup), rollupOwner);\n            }\n        }\n        _;\n    }\n\n    // On L1 this should be set to 117964: 90% of Geth's 128KB tx size limit, leaving ~13KB for proving\n    uint256 public immutable maxDataSize;\n    uint256 internal immutable deployTimeChainId = block.chainid;\n\n    constructor(uint256 _maxDataSize) {\n        maxDataSize = _maxDataSize;\n    }\n\n    function _chainIdChanged() internal view returns (bool) {\n        return deployTimeChainId != block.chainid;\n    }\n\n    /// @inheritdoc IInboxBase\n    function pause() external onlyRollupOrOwner {\n        _pause();\n    }\n\n    /// @inheritdoc IInboxBase\n    function unpause() external onlyRollupOrOwner {\n        _unpause();\n    }\n\n    /* solhint-disable func-name-mixedcase */\n    function __AbsInbox_init(IBridge _bridge, ISequencerInbox _sequencerInbox)\n        internal\n        onlyInitializing\n    {\n        bridge = _bridge;\n        sequencerInbox = _sequencerInbox;\n        allowListEnabled = false;\n        __Pausable_init();\n    }\n\n    /// @inheritdoc IInboxBase\n    function sendL2MessageFromOrigin(bytes calldata messageData)\n        external\n        whenNotPaused\n        onlyAllowed\n        returns (uint256)\n    {\n        if (_chainIdChanged()) revert L1Forked();\n        // solhint-disable-next-line avoid-tx-origin\n        if (msg.sender != tx.origin) revert NotOrigin();\n        if (messageData.length > maxDataSize) revert DataTooLarge(messageData.length, maxDataSize);\n        uint256 msgNum = _deliverToBridge(L2_MSG, msg.sender, keccak256(messageData), 0);\n        emit InboxMessageDeliveredFromOrigin(msgNum);\n        return msgNum;\n    }\n\n    /// @inheritdoc IInboxBase\n    function sendL2Message(bytes calldata messageData)\n        external\n        whenNotPaused\n        onlyAllowed\n        returns (uint256)\n    {\n        if (_chainIdChanged()) revert L1Forked();\n        return _deliverMessage(L2_MSG, msg.sender, messageData, 0);\n    }\n\n    /// @inheritdoc IInboxBase\n    function sendUnsignedTransaction(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external whenNotPaused onlyAllowed returns (uint256) {\n        // arbos will discard unsigned tx with gas limit too large\n        if (gasLimit > type(uint64).max) {\n            revert GasLimitTooLarge();\n        }\n        return\n            _deliverMessage(\n                L2_MSG,\n                msg.sender,\n                abi.encodePacked(\n                    L2MessageType_unsignedEOATx,\n                    gasLimit,\n                    maxFeePerGas,\n                    nonce,\n                    uint256(uint160(to)),\n                    value,\n                    data\n                ),\n                0\n            );\n    }\n\n    /// @inheritdoc IInboxBase\n    function sendContractTransaction(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external whenNotPaused onlyAllowed returns (uint256) {\n        // arbos will discard unsigned tx with gas limit too large\n        if (gasLimit > type(uint64).max) {\n            revert GasLimitTooLarge();\n        }\n        return\n            _deliverMessage(\n                L2_MSG,\n                msg.sender,\n                abi.encodePacked(\n                    L2MessageType_unsignedContractTx,\n                    gasLimit,\n                    maxFeePerGas,\n                    uint256(uint160(to)),\n                    value,\n                    data\n                ),\n                0\n            );\n    }\n\n    /// @inheritdoc IInboxBase\n    function getProxyAdmin() external view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    function _createRetryableTicket(\n        address to,\n        uint256 l2CallValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 amount,\n        bytes calldata data\n    ) internal returns (uint256) {\n        // Ensure the user's deposit alone will make submission succeed.\n        // In case of native token having non-18 decimals: 'amount' is denominated in native token's decimals. All other\n        // value params - l2CallValue, maxSubmissionCost and maxFeePerGas are denominated in child chain's native 18 decimals.\n        uint256 amountToBeMintedOnL2 = _fromNativeTo18Decimals(amount);\n        if (amountToBeMintedOnL2 < (maxSubmissionCost + l2CallValue + gasLimit * maxFeePerGas)) {\n            revert InsufficientValue(\n                maxSubmissionCost + l2CallValue + gasLimit * maxFeePerGas,\n                amountToBeMintedOnL2\n            );\n        }\n\n        // if a refund address is a contract, we apply the alias to it\n        // so that it can access its funds on the L2\n        // since the beneficiary and other refund addresses don't get rewritten by arb-os\n        if (AddressUpgradeable.isContract(excessFeeRefundAddress)) {\n            excessFeeRefundAddress = AddressAliasHelper.applyL1ToL2Alias(excessFeeRefundAddress);\n        }\n        if (AddressUpgradeable.isContract(callValueRefundAddress)) {\n            // this is the beneficiary. be careful since this is the address that can cancel the retryable in the L2\n            callValueRefundAddress = AddressAliasHelper.applyL1ToL2Alias(callValueRefundAddress);\n        }\n\n        // gas limit is validated to be within uint64 in unsafeCreateRetryableTicket\n        return\n            _unsafeCreateRetryableTicket(\n                to,\n                l2CallValue,\n                maxSubmissionCost,\n                excessFeeRefundAddress,\n                callValueRefundAddress,\n                gasLimit,\n                maxFeePerGas,\n                amount,\n                data\n            );\n    }\n\n    function _unsafeCreateRetryableTicket(\n        address to,\n        uint256 l2CallValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 amount,\n        bytes calldata data\n    ) internal returns (uint256) {\n        // gas price and limit of 1 should never be a valid input, so instead they are used as\n        // magic values to trigger a revert in eth calls that surface data without requiring a tx trace\n        if (gasLimit == 1 || maxFeePerGas == 1)\n            revert RetryableData(\n                msg.sender,\n                to,\n                l2CallValue,\n                amount,\n                maxSubmissionCost,\n                excessFeeRefundAddress,\n                callValueRefundAddress,\n                gasLimit,\n                maxFeePerGas,\n                data\n            );\n\n        // arbos will discard retryable with gas limit too large\n        if (gasLimit > type(uint64).max) {\n            revert GasLimitTooLarge();\n        }\n\n        uint256 submissionFee = calculateRetryableSubmissionFee(data.length, block.basefee);\n        if (maxSubmissionCost < submissionFee)\n            revert InsufficientSubmissionCost(submissionFee, maxSubmissionCost);\n\n        return\n            _deliverMessage(\n                L1MessageType_submitRetryableTx,\n                msg.sender,\n                abi.encodePacked(\n                    uint256(uint160(to)),\n                    l2CallValue,\n                    _fromNativeTo18Decimals(amount),\n                    maxSubmissionCost,\n                    uint256(uint160(excessFeeRefundAddress)),\n                    uint256(uint160(callValueRefundAddress)),\n                    gasLimit,\n                    maxFeePerGas,\n                    data.length,\n                    data\n                ),\n                amount\n            );\n    }\n\n    function _deliverMessage(\n        uint8 _kind,\n        address _sender,\n        bytes memory _messageData,\n        uint256 amount\n    ) internal returns (uint256) {\n        if (_messageData.length > maxDataSize)\n            revert DataTooLarge(_messageData.length, maxDataSize);\n        uint256 msgNum = _deliverToBridge(_kind, _sender, keccak256(_messageData), amount);\n        emit InboxMessageDelivered(msgNum, _messageData);\n        return msgNum;\n    }\n\n    function _deliverToBridge(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash,\n        uint256 amount\n    ) internal virtual returns (uint256);\n\n    function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee)\n        public\n        view\n        virtual\n        returns (uint256);\n\n    /// @notice get amount of ETH/token to mint on child chain based on provided value.\n    ///         In case of ETH-based rollup this amount will always equal the provided\n    ///         value. In case of ERC20-based rollup where native token has number of\n    ///         decimals different thatn 18, amount will be re-adjusted to reflect 18\n    ///         decimals used for native currency on child chain.\n    /// @dev    provided value has to be less than 'type(uint256).max/10**(18-decimalsIn)'\n    ///         or otherwise it will overflow.\n    function _fromNativeTo18Decimals(uint256 value) internal view virtual returns (uint256);\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[47] private __gap;\n}\n"}, "src/bridge/AbsOutbox.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport {\n    AlreadyInit,\n    NotRollup,\n    ProofTooLong,\n    PathNotMinimal,\n    UnknownRoot,\n    AlreadySpent,\n    BridgeCallFailed,\n    HadZeroInit,\n    BadPostUpgradeInit,\n    RollupNotChanged\n} from \"../libraries/Error.sol\";\nimport \"./IBridge.sol\";\nimport \"./IOutbox.sol\";\nimport \"../libraries/MerkleLib.sol\";\nimport \"../libraries/DelegateCallAware.sol\";\n\n/// @dev this error is thrown since certain functions are only expected to be used in simulations, not in actual txs\nerror SimulationOnlyEntrypoint();\n\nabstract contract AbsOutbox is DelegateCallAware, IOutbox {\n    address public rollup; // the rollup contract\n    IBridge public bridge; // the bridge contract\n\n    mapping(uint256 => bytes32) public spent; // packed spent bitmap\n    mapping(bytes32 => bytes32) public roots; // maps root hashes => L2 block hash\n\n    // we're packing this struct into 4 storage slots\n    // 1st slot: timestamp, l2Block (128 bits each, max ~3.4*10^38)\n    // 2nd slot: outputId (256 bits)\n    // 3rd slot: l1Block (96 bits, max ~7.9*10^28), sender (address 160 bits)\n    // 4th slot: withdrawalAmount (256 bits)\n    struct L2ToL1Context {\n        uint128 l2Block;\n        uint128 timestamp;\n        bytes32 outputId;\n        address sender;\n        uint96 l1Block;\n        uint256 withdrawalAmount;\n    }\n\n    // Note, these variables are set and then wiped during a single transaction.\n    // Therefore their values don't need to be maintained, and their slots will\n    // hold default values (which are interpreted as empty values) outside of transactions\n    L2ToL1Context internal context;\n\n    // default context values to be used in storage instead of zero, to save on storage refunds\n    // it is assumed that arb-os never assigns these values to a valid leaf to be redeemed\n    uint128 private constant L2BLOCK_DEFAULT_CONTEXT = type(uint128).max;\n    uint96 private constant L1BLOCK_DEFAULT_CONTEXT = type(uint96).max;\n    uint128 private constant TIMESTAMP_DEFAULT_CONTEXT = type(uint128).max;\n    bytes32 private constant OUTPUTID_DEFAULT_CONTEXT = bytes32(type(uint256).max);\n    address private constant SENDER_DEFAULT_CONTEXT = address(type(uint160).max);\n\n    uint128 public constant OUTBOX_VERSION = 2;\n\n    function initialize(IBridge _bridge) external onlyDelegated {\n        if (address(_bridge) == address(0)) revert HadZeroInit();\n        if (address(bridge) != address(0)) revert AlreadyInit();\n        // address zero is returned if no context is set, but the values used in storage\n        // are non-zero to save users some gas (as storage refunds are usually maxed out)\n        // EIP-1153 would help here\n        context = L2ToL1Context({\n            l2Block: L2BLOCK_DEFAULT_CONTEXT,\n            l1Block: L1BLOCK_DEFAULT_CONTEXT,\n            timestamp: TIMESTAMP_DEFAULT_CONTEXT,\n            outputId: OUTPUTID_DEFAULT_CONTEXT,\n            sender: SENDER_DEFAULT_CONTEXT,\n            withdrawalAmount: _defaultContextAmount()\n        });\n        bridge = _bridge;\n        rollup = address(_bridge.rollup());\n    }\n\n    function postUpgradeInit() external onlyDelegated onlyProxyOwner {\n        // prevent postUpgradeInit within a withdrawal\n        if (context.l2Block != L2BLOCK_DEFAULT_CONTEXT) revert BadPostUpgradeInit();\n        context = L2ToL1Context({\n            l2Block: L2BLOCK_DEFAULT_CONTEXT,\n            l1Block: L1BLOCK_DEFAULT_CONTEXT,\n            timestamp: TIMESTAMP_DEFAULT_CONTEXT,\n            outputId: OUTPUTID_DEFAULT_CONTEXT,\n            sender: SENDER_DEFAULT_CONTEXT,\n            withdrawalAmount: _defaultContextAmount()\n        });\n    }\n\n    /// @notice Allows the rollup owner to sync the rollup address\n    function updateRollupAddress() external {\n        if (msg.sender != IOwnable(rollup).owner())\n            revert NotOwner(msg.sender, IOwnable(rollup).owner());\n        address newRollup = address(bridge.rollup());\n        if (rollup == newRollup) revert RollupNotChanged();\n        rollup = newRollup;\n    }\n\n    function updateSendRoot(bytes32 root, bytes32 l2BlockHash) external {\n        if (msg.sender != rollup) revert NotRollup(msg.sender, rollup);\n        roots[root] = l2BlockHash;\n        emit SendRootUpdated(root, l2BlockHash);\n    }\n\n    /// @inheritdoc IOutbox\n    function l2ToL1Sender() external view returns (address) {\n        address sender = context.sender;\n        // we don't return the default context value to avoid a breaking change in the API\n        if (sender == SENDER_DEFAULT_CONTEXT) return address(0);\n        return sender;\n    }\n\n    /// @inheritdoc IOutbox\n    function l2ToL1Block() external view returns (uint256) {\n        uint128 l2Block = context.l2Block;\n        // we don't return the default context value to avoid a breaking change in the API\n        if (l2Block == L2BLOCK_DEFAULT_CONTEXT) return uint256(0);\n        return uint256(l2Block);\n    }\n\n    /// @inheritdoc IOutbox\n    function l2ToL1EthBlock() external view returns (uint256) {\n        uint96 l1Block = context.l1Block;\n        // we don't return the default context value to avoid a breaking change in the API\n        if (l1Block == L1BLOCK_DEFAULT_CONTEXT) return uint256(0);\n        return uint256(l1Block);\n    }\n\n    /// @inheritdoc IOutbox\n    function l2ToL1Timestamp() external view returns (uint256) {\n        uint128 timestamp = context.timestamp;\n        // we don't return the default context value to avoid a breaking change in the API\n        if (timestamp == TIMESTAMP_DEFAULT_CONTEXT) return uint256(0);\n        return uint256(timestamp);\n    }\n\n    /// @notice batch number is deprecated and now always returns 0\n    function l2ToL1BatchNum() external pure returns (uint256) {\n        return 0;\n    }\n\n    /// @inheritdoc IOutbox\n    function l2ToL1OutputId() external view returns (bytes32) {\n        bytes32 outputId = context.outputId;\n        // we don't return the default context value to avoid a breaking change in the API\n        if (outputId == OUTPUTID_DEFAULT_CONTEXT) return bytes32(0);\n        return outputId;\n    }\n\n    /// @inheritdoc IOutbox\n    function executeTransaction(\n        bytes32[] calldata proof,\n        uint256 index,\n        address l2Sender,\n        address to,\n        uint256 l2Block,\n        uint256 l1Block,\n        uint256 l2Timestamp,\n        uint256 value,\n        bytes calldata data\n    ) external {\n        bytes32 userTx = calculateItemHash(\n            l2Sender,\n            to,\n            l2Block,\n            l1Block,\n            l2Timestamp,\n            value,\n            data\n        );\n\n        recordOutputAsSpent(proof, index, userTx);\n\n        executeTransactionImpl(index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data);\n    }\n\n    /// @inheritdoc IOutbox\n    function executeTransactionSimulation(\n        uint256 index,\n        address l2Sender,\n        address to,\n        uint256 l2Block,\n        uint256 l1Block,\n        uint256 l2Timestamp,\n        uint256 value,\n        bytes calldata data\n    ) external {\n        if (msg.sender != address(0)) revert SimulationOnlyEntrypoint();\n        executeTransactionImpl(index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data);\n    }\n\n    function executeTransactionImpl(\n        uint256 outputId,\n        address l2Sender,\n        address to,\n        uint256 l2Block,\n        uint256 l1Block,\n        uint256 l2Timestamp,\n        uint256 value,\n        bytes calldata data\n    ) internal {\n        emit OutBoxTransactionExecuted(to, l2Sender, 0, outputId);\n\n        // get amount to unlock based on provided value. It might differ in case\n        // of native token which uses number of decimals different than 18\n        uint256 amountToUnlock = _getAmountToUnlock(value);\n\n        // we temporarily store the previous values so the outbox can naturally\n        // unwind itself when there are nested calls to `executeTransaction`\n        L2ToL1Context memory prevContext = context;\n\n        context = L2ToL1Context({\n            sender: l2Sender,\n            l2Block: uint128(l2Block),\n            l1Block: uint96(l1Block),\n            timestamp: uint128(l2Timestamp),\n            outputId: bytes32(outputId),\n            withdrawalAmount: _amountToSetInContext(amountToUnlock)\n        });\n\n        // set and reset vars around execution so they remain valid during call\n        executeBridgeCall(to, amountToUnlock, data);\n\n        context = prevContext;\n    }\n\n    function _calcSpentIndexOffset(uint256 index)\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            bytes32\n        )\n    {\n        uint256 spentIndex = index / 255; // Note: Reserves the MSB.\n        uint256 bitOffset = index % 255;\n        bytes32 replay = spent[spentIndex];\n        return (spentIndex, bitOffset, replay);\n    }\n\n    function _isSpent(uint256 bitOffset, bytes32 replay) internal pure returns (bool) {\n        return ((replay >> bitOffset) & bytes32(uint256(1))) != bytes32(0);\n    }\n\n    /// @inheritdoc IOutbox\n    function isSpent(uint256 index) external view returns (bool) {\n        (, uint256 bitOffset, bytes32 replay) = _calcSpentIndexOffset(index);\n        return _isSpent(bitOffset, replay);\n    }\n\n    function recordOutputAsSpent(\n        bytes32[] memory proof,\n        uint256 index,\n        bytes32 item\n    ) internal {\n        if (proof.length >= 256) revert ProofTooLong(proof.length);\n        if (index >= 2**proof.length) revert PathNotMinimal(index, 2**proof.length);\n\n        // Hash the leaf an extra time to prove it's a leaf\n        bytes32 calcRoot = calculateMerkleRoot(proof, index, item);\n        if (roots[calcRoot] == bytes32(0)) revert UnknownRoot(calcRoot);\n\n        (uint256 spentIndex, uint256 bitOffset, bytes32 replay) = _calcSpentIndexOffset(index);\n\n        if (_isSpent(bitOffset, replay)) revert AlreadySpent(index);\n        spent[spentIndex] = (replay | bytes32(1 << bitOffset));\n    }\n\n    function executeBridgeCall(\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        (bool success, bytes memory returndata) = bridge.executeCall(to, value, data);\n        if (!success) {\n            if (returndata.length > 0) {\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert BridgeCallFailed();\n            }\n        }\n    }\n\n    function calculateItemHash(\n        address l2Sender,\n        address to,\n        uint256 l2Block,\n        uint256 l1Block,\n        uint256 l2Timestamp,\n        uint256 value,\n        bytes calldata data\n    ) public pure returns (bytes32) {\n        return\n            keccak256(abi.encodePacked(l2Sender, to, l2Block, l1Block, l2Timestamp, value, data));\n    }\n\n    function calculateMerkleRoot(\n        bytes32[] memory proof,\n        uint256 path,\n        bytes32 item\n    ) public pure returns (bytes32) {\n        return MerkleLib.calculateRoot(proof, path, keccak256(abi.encodePacked(item)));\n    }\n\n    /// @notice default value to be used for 'amount' field in L2ToL1Context outside of transaction execution.\n    /// @return default 'amount' in case of ERC20-based rollup is type(uint256).max, or 0 in case of ETH-based rollup\n    function _defaultContextAmount() internal pure virtual returns (uint256);\n\n    /// @notice based on provided value, get amount of ETH/token to unlock. In case of ETH-based rollup this amount\n    ///         will always equal the provided value. In case of ERC20-based rollup, amount will be re-adjusted to\n    ///         reflect the number of decimals used by native token, in case it is different than 18.\n    function _getAmountToUnlock(uint256 value) internal view virtual returns (uint256);\n\n    /// @notice value to be set for 'amount' field in L2ToL1Context during L2 to L1 transaction execution.\n    ///         In case of ERC20-based rollup this is the amount of native token being withdrawn. In case of standard ETH-based\n    ///         rollup this amount shall always be 0, because amount of ETH being withdrawn can be read from msg.value.\n    /// @return amount of native token being withdrawn in case of ERC20-based rollup, or 0 in case of ETH-based rollup\n    function _amountToSetInContext(uint256 value) internal pure virtual returns (uint256);\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[42] private __gap;\n}\n"}, "src/bridge/Bridge.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"./AbsBridge.sol\";\nimport \"./IEthBridge.sol\";\nimport \"./Messages.sol\";\nimport \"../libraries/DelegateCallAware.sol\";\n\nimport {L1MessageType_batchPostingReport} from \"../libraries/MessageTypes.sol\";\n\n/**\n * @title Staging ground for incoming and outgoing messages\n * @notice It is also the ETH escrow for value sent with these messages.\n */\ncontract Bridge is AbsBridge, IEthBridge {\n    using AddressUpgradeable for address;\n\n    /// @inheritdoc IEthBridge\n    function initialize(IOwnable rollup_) external initializer onlyDelegated {\n        _activeOutbox = EMPTY_ACTIVEOUTBOX;\n        rollup = rollup_;\n    }\n\n    /// @inheritdoc IEthBridge\n    function enqueueDelayedMessage(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    ) external payable returns (uint256) {\n        return _enqueueDelayedMessage(kind, sender, messageDataHash, msg.value);\n    }\n\n    function _transferFunds(uint256) internal override {\n        // do nothing as Eth transfer is part of TX execution\n    }\n\n    function _executeLowLevelCall(\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal override returns (bool success, bytes memory returnData) {\n        // solhint-disable-next-line avoid-low-level-calls\n        (success, returnData) = to.call{value: value}(data);\n    }\n\n    function _baseFeeToReport() internal view override returns (uint256) {\n        return block.basefee;\n    }\n}\n"}, "src/bridge/ERC20Bridge.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./AbsBridge.sol\";\nimport \"./IERC20Bridge.sol\";\nimport \"../libraries/AddressAliasHelper.sol\";\nimport {\n    InvalidTokenSet,\n    CallTargetNotAllowed,\n    CallNotAllowed,\n    NativeTokenDecimalsTooLarge\n} from \"../libraries/Error.sol\";\nimport {DecimalsConverterHelper} from \"../libraries/DecimalsConverterHelper.sol\";\nimport {MAX_ALLOWED_NATIVE_TOKEN_DECIMALS} from \"../libraries/Constants.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title Staging ground for incoming and outgoing messages\n * @notice Unlike the standard Eth bridge, native token bridge escrows the custom ERC20 token which is\n * used as native currency on L2.\n * @dev Fees are paid in this token. There are certain restrictions on the native token:\n *       - The token can't be rebasing or have a transfer fee\n *       - The token must only be transferrable via a call to the token address itself\n *       - The token must only be able to set allowance via a call to the token address itself\n *       - The token must not have a callback on transfer, and more generally a user must not be able to make a transfer to themselves revert\n *       - The token must have a max of 2^256 - 1 wei total supply unscaled\n *       - The token must have a max of 2^256 - 1 wei total supply when scaled to 18 decimals\n */\ncontract ERC20Bridge is AbsBridge, IERC20Bridge {\n    using SafeERC20 for IERC20;\n\n    /// @inheritdoc IERC20Bridge\n    address public nativeToken;\n\n    /// @inheritdoc IERC20Bridge\n    uint8 public nativeTokenDecimals;\n\n    /// @inheritdoc IERC20Bridge\n    function initialize(IOwnable rollup_, address nativeToken_) external initializer onlyDelegated {\n        if (nativeToken_ == address(0)) revert InvalidTokenSet(nativeToken_);\n        nativeToken = nativeToken_;\n        _activeOutbox = EMPTY_ACTIVEOUTBOX;\n        rollup = rollup_;\n\n        // store number of decimals used by native token\n        try ERC20(nativeToken_).decimals() returns (uint8 decimals) {\n            if (decimals > MAX_ALLOWED_NATIVE_TOKEN_DECIMALS) {\n                revert NativeTokenDecimalsTooLarge(decimals);\n            }\n            nativeTokenDecimals = decimals;\n        } catch {\n            // decimal is not part of the ERC20 spec\n            // assume it have 0 decimals if it does not have decimals() method\n            // we do this to align with the token bridge behavior\n            nativeTokenDecimals = 0;\n        }\n    }\n\n    /// @inheritdoc IERC20Bridge\n    function enqueueDelayedMessage(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash,\n        uint256 tokenFeeAmount\n    ) external returns (uint256) {\n        return _enqueueDelayedMessage(kind, sender, messageDataHash, tokenFeeAmount);\n    }\n\n    function _transferFunds(uint256 amount) internal override {\n        // fetch native token from Inbox\n        IERC20(nativeToken).safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    function _executeLowLevelCall(\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal override returns (bool success, bytes memory returnData) {\n        address _nativeToken = nativeToken;\n\n        // we don't allow outgoing calls to native token contract because it could\n        // result in loss of native tokens which are escrowed by ERC20Bridge\n        if (to == _nativeToken) {\n            revert CallTargetNotAllowed(_nativeToken);\n        }\n\n        // first release native token\n        IERC20(_nativeToken).safeTransfer(to, value);\n        success = true;\n\n        // if there's data do additional contract call. Make sure that call is not used to\n        // decrease bridge contract's balance of the native token\n        if (data.length > 0) {\n            uint256 bridgeBalanceBefore = IERC20(_nativeToken).balanceOf(address(this));\n\n            // solhint-disable-next-line avoid-low-level-calls\n            (success, returnData) = to.call(data);\n\n            uint256 bridgeBalanceAfter = IERC20(_nativeToken).balanceOf(address(this));\n            if (bridgeBalanceAfter < bridgeBalanceBefore) {\n                revert CallNotAllowed();\n            }\n        }\n    }\n\n    function _baseFeeToReport() internal pure override returns (uint256) {\n        // ArbOs uses formula 'l1BaseFee * (1400 + 6 * calldataLengthInBytes)' to calculate retryable ticket's\n        // submission fee. When custom ERC20 token is used to pay for fees, submission fee shall be 0. That's\n        // why baseFee is reported as 0 here.\n        return 0;\n    }\n}\n"}, "src/bridge/ERC20Inbox.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./AbsInbox.sol\";\nimport \"./IERC20Inbox.sol\";\nimport \"./IERC20Bridge.sol\";\nimport \"../libraries/AddressAliasHelper.sol\";\nimport {L1MessageType_ethDeposit} from \"../libraries/MessageTypes.sol\";\nimport {AmountTooLarge} from \"../libraries/Error.sol\";\nimport {MAX_UPSCALE_AMOUNT} from \"../libraries/Constants.sol\";\n\nimport {DecimalsConverterHelper} from \"../libraries/DecimalsConverterHelper.sol\";\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title Inbox for user and contract originated messages\n * @notice Messages created via this inbox are enqueued in the delayed accumulator\n * to await inclusion in the SequencerInbox\n */\ncontract ERC20Inbox is AbsInbox, IERC20Inbox {\n    using SafeERC20 for IERC20;\n\n    constructor(uint256 _maxDataSize) AbsInbox(_maxDataSize) {}\n\n    /// @inheritdoc IInboxBase\n    function initialize(IBridge _bridge, ISequencerInbox _sequencerInbox)\n        external\n        initializer\n        onlyDelegated\n    {\n        __AbsInbox_init(_bridge, _sequencerInbox);\n\n        // inbox holds native token in transit used to pay for retryable tickets, approve bridge to use it\n        address nativeToken = IERC20Bridge(address(bridge)).nativeToken();\n        IERC20(nativeToken).safeApprove(address(bridge), type(uint256).max);\n    }\n\n    /// @inheritdoc IERC20Inbox\n    function depositERC20(uint256 amount) public whenNotPaused onlyAllowed returns (uint256) {\n        address dest = msg.sender;\n\n        // solhint-disable-next-line avoid-tx-origin\n        if (AddressUpgradeable.isContract(msg.sender) || tx.origin != msg.sender) {\n            // isContract check fails if this function is called during a contract's constructor.\n            dest = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n        }\n\n        uint256 amountToMintOnL2 = _fromNativeTo18Decimals(amount);\n        return\n            _deliverMessage(\n                L1MessageType_ethDeposit,\n                msg.sender,\n                abi.encodePacked(dest, amountToMintOnL2),\n                amount\n            );\n    }\n\n    /// @inheritdoc IERC20Inbox\n    function createRetryableTicket(\n        address to,\n        uint256 l2CallValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 tokenTotalFeeAmount,\n        bytes calldata data\n    ) external whenNotPaused onlyAllowed returns (uint256) {\n        return\n            _createRetryableTicket(\n                to,\n                l2CallValue,\n                maxSubmissionCost,\n                excessFeeRefundAddress,\n                callValueRefundAddress,\n                gasLimit,\n                maxFeePerGas,\n                tokenTotalFeeAmount,\n                data\n            );\n    }\n\n    /// @inheritdoc IERC20Inbox\n    function unsafeCreateRetryableTicket(\n        address to,\n        uint256 l2CallValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 tokenTotalFeeAmount,\n        bytes calldata data\n    ) public whenNotPaused onlyAllowed returns (uint256) {\n        return\n            _unsafeCreateRetryableTicket(\n                to,\n                l2CallValue,\n                maxSubmissionCost,\n                excessFeeRefundAddress,\n                callValueRefundAddress,\n                gasLimit,\n                maxFeePerGas,\n                tokenTotalFeeAmount,\n                data\n            );\n    }\n\n    /// @inheritdoc IInboxBase\n    function calculateRetryableSubmissionFee(uint256, uint256)\n        public\n        pure\n        override(AbsInbox, IInboxBase)\n        returns (uint256)\n    {\n        // retryable ticket's submission fee is not charged when ERC20 token is used to pay for fees\n        return 0;\n    }\n\n    function _deliverToBridge(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash,\n        uint256 tokenAmount\n    ) internal override returns (uint256) {\n        // Fetch native token from sender if inbox doesn't already hold enough tokens to pay for fees.\n        // Inbox might have been pre-funded in prior call, ie. as part of token bridging flow.\n        address nativeToken = IERC20Bridge(address(bridge)).nativeToken();\n        uint256 inboxNativeTokenBalance = IERC20(nativeToken).balanceOf(address(this));\n        if (inboxNativeTokenBalance < tokenAmount) {\n            uint256 diff = tokenAmount - inboxNativeTokenBalance;\n            IERC20(nativeToken).safeTransferFrom(msg.sender, address(this), diff);\n        }\n\n        return\n            IERC20Bridge(address(bridge)).enqueueDelayedMessage(\n                kind,\n                AddressAliasHelper.applyL1ToL2Alias(sender),\n                messageDataHash,\n                tokenAmount\n            );\n    }\n\n    /// @inheritdoc AbsInbox\n    function _fromNativeTo18Decimals(uint256 value) internal view override returns (uint256) {\n        // In order to keep compatibility of child chain's native currency with external 3rd party tooling we\n        // expect 18 decimals to be always used for native currency. If native token uses different number of\n        // decimals then here it will be normalized to 18. Keep in mind, when withdrawing from child chain back\n        // to parent chain then the amount has to match native token's granularity, otherwise it will be rounded\n        // down.\n        uint8 nativeTokenDecimals = IERC20Bridge(address(bridge)).nativeTokenDecimals();\n\n        // Also make sure that inflated amount does not overflow uint256\n        if (nativeTokenDecimals < 18) {\n            if (value > MAX_UPSCALE_AMOUNT) {\n                revert AmountTooLarge(value);\n            }\n        }\n        return DecimalsConverterHelper.adjustDecimals(value, nativeTokenDecimals, 18);\n    }\n}\n"}, "src/bridge/ERC20Outbox.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./AbsOutbox.sol\";\nimport {IERC20Bridge} from \"./IERC20Bridge.sol\";\nimport {DecimalsConverterHelper} from \"../libraries/DecimalsConverterHelper.sol\";\n\ncontract ERC20Outbox is AbsOutbox {\n    /// @dev it is assumed that arb-os never assigns this value to a valid leaf to be redeemed\n    uint256 private constant AMOUNT_DEFAULT_CONTEXT = type(uint256).max;\n\n    function l2ToL1WithdrawalAmount() external view returns (uint256) {\n        uint256 amount = context.withdrawalAmount;\n        if (amount == AMOUNT_DEFAULT_CONTEXT) return 0;\n        return amount;\n    }\n\n    /// @inheritdoc AbsOutbox\n    function _defaultContextAmount() internal pure override returns (uint256) {\n        // we use type(uint256).max as representation of 0 native token withdrawal amount\n        return AMOUNT_DEFAULT_CONTEXT;\n    }\n\n    /// @inheritdoc AbsOutbox\n    function _getAmountToUnlock(uint256 value) internal view override returns (uint256) {\n        uint8 nativeTokenDecimals = IERC20Bridge(address(bridge)).nativeTokenDecimals();\n        // this might revert due to overflow, but we assume the token supply is less than 2^256\n        return DecimalsConverterHelper.adjustDecimals(value, 18, nativeTokenDecimals);\n    }\n\n    /// @inheritdoc AbsOutbox\n    function _amountToSetInContext(uint256 value) internal pure override returns (uint256) {\n        // native token withdrawal amount which can be fetched from context\n        return value;\n    }\n}\n"}, "src/bridge/GasRefunder.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.30;\n\nimport \"../libraries/IGasRefunder.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @notice DEPRECATED - only for classic version, see new repo (https://github.com/OffchainLabs/nitro/tree/master/contracts)\n * for new updates\n */\ncontract GasRefunder is IGasRefunder, Ownable {\n    mapping(address => bool) public allowedContracts;\n    mapping(address => bool) public allowedRefundees;\n    address public disallower;\n\n    struct CommonParameters {\n        uint128 maxRefundeeBalance;\n        uint32 extraGasMargin;\n        uint8 calldataCost;\n        uint64 maxGasTip;\n        uint64 maxGasCost;\n        uint32 maxSingleGasUsage;\n    }\n\n    CommonParameters public commonParams;\n\n    enum CommonParameterKey {\n        MAX_REFUNDEE_BALANCE,\n        EXTRA_GAS_MARGIN,\n        CALLDATA_COST,\n        MAX_GAS_TIP,\n        MAX_GAS_COST,\n        MAX_SINGLE_GAS_USAGE\n    }\n\n    enum RefundDenyReason {\n        CONTRACT_NOT_ALLOWED,\n        REFUNDEE_NOT_ALLOWED,\n        REFUNDEE_ABOVE_MAX_BALANCE,\n        OUT_OF_FUNDS\n    }\n\n    event RefundedGasCosts(\n        address indexed refundee,\n        address indexed contractAddress,\n        bool indexed success,\n        uint256 gas,\n        uint256 gasPrice,\n        uint256 amountPaid\n    );\n    event RefundGasCostsDenied(\n        address indexed refundee,\n        address indexed contractAddress,\n        RefundDenyReason indexed reason,\n        uint256 gas\n    );\n    event Deposited(address sender, uint256 amount);\n    event Withdrawn(address initiator, address destination, uint256 amount);\n    event ContractAllowedSet(address indexed addr, bool indexed allowed);\n    event RefundeeAllowedSet(address indexed addr, bool indexed allowed);\n    event DisallowerSet(address indexed addr);\n    event CommonParameterSet(CommonParameterKey indexed parameter, uint256 value);\n\n    constructor() Ownable() {\n        commonParams = CommonParameters({\n            maxRefundeeBalance: 0, // no limit\n            extraGasMargin: 4000, // 4k gas\n            calldataCost: 12, // Between 4 for zero bytes and 16 for non-zero bytes\n            maxGasTip: 2 gwei,\n            maxGasCost: 120 gwei,\n            maxSingleGasUsage: 2e6 // 2 million gas\n        });\n    }\n\n    function setDisallower(address addr) external onlyOwner {\n        disallower = addr;\n        emit DisallowerSet(addr);\n    }\n\n    function allowContracts(address[] calldata addresses) external onlyOwner {\n        setContractsAllowedImpl(addresses, true);\n    }\n\n    function disallowContracts(address[] calldata addresses) external {\n        require(msg.sender == owner() || msg.sender == disallower, \"NOT_AUTHORIZED\");\n        setContractsAllowedImpl(addresses, false);\n    }\n\n    function setContractsAllowedImpl(address[] calldata addresses, bool allow) internal {\n        for (uint256 i = 0; i < addresses.length; i++) {\n            address addr = addresses[i];\n            allowedContracts[addr] = allow;\n            emit ContractAllowedSet(addr, allow);\n        }\n    }\n\n    function allowRefundees(address[] calldata addresses) external onlyOwner {\n        setRefundeesAllowedImpl(addresses, true);\n    }\n\n    function disallowRefundees(address[] calldata addresses) external {\n        require(msg.sender == owner() || msg.sender == disallower, \"NOT_AUTHORIZED\");\n        setRefundeesAllowedImpl(addresses, false);\n    }\n\n    function setRefundeesAllowedImpl(address[] calldata addresses, bool allow) internal {\n        for (uint256 i = 0; i < addresses.length; i++) {\n            address addr = addresses[i];\n            allowedRefundees[addr] = allow;\n            emit RefundeeAllowedSet(addr, allow);\n        }\n    }\n\n    function setMaxRefundeeBalance(uint128 newValue) external onlyOwner {\n        commonParams.maxRefundeeBalance = newValue;\n        emit CommonParameterSet(CommonParameterKey.MAX_REFUNDEE_BALANCE, newValue);\n    }\n\n    function setExtraGasMargin(uint32 newValue) external onlyOwner {\n        commonParams.extraGasMargin = newValue;\n        emit CommonParameterSet(CommonParameterKey.EXTRA_GAS_MARGIN, newValue);\n    }\n\n    function setCalldataCost(uint8 newValue) external onlyOwner {\n        commonParams.calldataCost = newValue;\n        emit CommonParameterSet(CommonParameterKey.CALLDATA_COST, newValue);\n    }\n\n    function setMaxGasTip(uint64 newValue) external onlyOwner {\n        commonParams.maxGasTip = newValue;\n        emit CommonParameterSet(CommonParameterKey.MAX_GAS_TIP, newValue);\n    }\n\n    function setMaxGasCost(uint64 newValue) external onlyOwner {\n        commonParams.maxGasCost = newValue;\n        emit CommonParameterSet(CommonParameterKey.MAX_GAS_COST, newValue);\n    }\n\n    function setMaxSingleGasUsage(uint32 newValue) external onlyOwner {\n        commonParams.maxSingleGasUsage = newValue;\n        emit CommonParameterSet(CommonParameterKey.MAX_SINGLE_GAS_USAGE, newValue);\n    }\n\n    receive() external payable {\n        emit Deposited(msg.sender, msg.value);\n    }\n\n    function withdraw(address payable destination, uint256 amount) external onlyOwner {\n        // It's expected that destination is an EOA\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = destination.call{value: amount}(\"\");\n        require(success, \"WITHDRAW_FAILED\");\n        emit Withdrawn(msg.sender, destination, amount);\n    }\n\n    function onGasSpent(\n        address payable refundee,\n        uint256 gasUsed,\n        uint256 calldataSize\n    ) external override returns (bool success) {\n        uint256 startGasLeft = gasleft();\n\n        uint256 ownBalance = address(this).balance;\n\n        if (ownBalance == 0) {\n            emit RefundGasCostsDenied(refundee, msg.sender, RefundDenyReason.OUT_OF_FUNDS, gasUsed);\n            return false;\n        }\n\n        if (!allowedContracts[msg.sender]) {\n            emit RefundGasCostsDenied(\n                refundee,\n                msg.sender,\n                RefundDenyReason.CONTRACT_NOT_ALLOWED,\n                gasUsed\n            );\n            return false;\n        }\n        if (!allowedRefundees[refundee]) {\n            emit RefundGasCostsDenied(\n                refundee,\n                msg.sender,\n                RefundDenyReason.REFUNDEE_NOT_ALLOWED,\n                gasUsed\n            );\n            return false;\n        }\n\n        uint256 estGasPrice = block.basefee + commonParams.maxGasTip;\n        if (tx.gasprice < estGasPrice) {\n            estGasPrice = tx.gasprice;\n        }\n        if (commonParams.maxGasCost != 0 && estGasPrice > commonParams.maxGasCost) {\n            estGasPrice = commonParams.maxGasCost;\n        }\n\n        // Retrieve these variables before measuring gasleft()\n        uint256 refundeeBalance = refundee.balance;\n        uint256 maxRefundeeBalance = commonParams.maxRefundeeBalance;\n        uint256 maxSingleGasUsage = commonParams.maxSingleGasUsage;\n\n        // Add in a bit of a buffer for the tx costs not measured with gasleft\n        gasUsed +=\n            startGasLeft +\n            commonParams.extraGasMargin +\n            (calldataSize * commonParams.calldataCost);\n        // Split this up into two statements so that gasleft() comes after the storage loads\n        gasUsed -= gasleft();\n\n        if (maxSingleGasUsage != 0 && gasUsed > maxSingleGasUsage) {\n            gasUsed = maxSingleGasUsage;\n        }\n\n        uint256 refundAmount = estGasPrice * gasUsed;\n        if (maxRefundeeBalance != 0 && refundeeBalance + refundAmount > maxRefundeeBalance) {\n            if (refundeeBalance > maxRefundeeBalance) {\n                // The refundee is already above their max balance\n                // emit RefundGasCostsDenied(\n                //     refundee,\n                //     msg.sender,\n                //     RefundDenyReason.REFUNDEE_ABOVE_MAX_BALANCE,\n                //     gasUsed\n                // );\n                return false;\n            } else {\n                refundAmount = maxRefundeeBalance - refundeeBalance;\n            }\n        }\n\n        if (refundAmount > ownBalance) {\n            refundAmount = ownBalance;\n        }\n\n        // It's expected that refundee is an EOA\n        // solhint-disable-next-line avoid-low-level-calls\n        (success, ) = refundee.call{value: refundAmount}(\"\");\n        emit RefundedGasCosts(refundee, msg.sender, success, gasUsed, estGasPrice, refundAmount);\n    }\n}\n"}, "src/bridge/IBridge.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.30;\n\nimport \"./IOwnable.sol\";\n\ninterface IBridge {\n    /// @dev This is an instruction to offchain readers to inform them where to look\n    ///      for sequencer inbox batch data. This is not the type of data (eg. das, brotli encoded, or blob versioned hash)\n    ///      and this enum is not used in the state transition function, rather it informs an offchain\n    ///      reader where to find the data so that they can supply it to the replay binary\n    enum BatchDataLocation {\n        /// @notice The data can be found in the transaction call data\n        TxInput,\n        /// @notice The data can be found in an event emitted during the transaction\n        SeparateBatchEvent,\n        /// @notice This batch contains no data\n        NoData,\n        /// @notice The data can be found in the 4844 data blobs on this transaction\n        Blob\n    }\n\n    struct TimeBounds {\n        uint64 minTimestamp;\n        uint64 maxTimestamp;\n        uint64 minBlockNumber;\n        uint64 maxBlockNumber;\n    }\n\n    event MessageDelivered(\n        uint256 indexed messageIndex,\n        bytes32 indexed beforeInboxAcc,\n        address inbox,\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash,\n        uint256 baseFeeL1,\n        uint64 timestamp\n    );\n\n    event DepositMessageDelivered(address indexed sender);\n\n    event BridgeCallTriggered(\n        address indexed outbox,\n        address indexed to,\n        uint256 value,\n        bytes data\n    );\n\n    event InboxToggle(address indexed inbox, bool enabled);\n\n    event OutboxToggle(address indexed outbox, bool enabled);\n\n    event SequencerInboxUpdated(address newSequencerInbox);\n\n    event RollupUpdated(address rollup);\n\n    function allowedDelayedInboxList(uint256) external returns (address);\n\n    function allowedOutboxList(uint256) external returns (address);\n\n    /// @dev Accumulator for delayed inbox messages; tail represents hash of the current state; each element represents the inclusion of a new message.\n    function delayedInboxAccs(uint256) external view returns (bytes32);\n\n    /// @dev Accumulator for sequencer inbox messages; tail represents hash of the current state; each element represents the inclusion of a new message.\n    function sequencerInboxAccs(uint256) external view returns (bytes32);\n\n    function rollup() external view returns (IOwnable);\n\n    function sequencerInbox() external view returns (address);\n\n    function activeOutbox() external view returns (address);\n\n    function allowedDelayedInboxes(address inbox) external view returns (bool);\n\n    function allowedOutboxes(address outbox) external view returns (bool);\n\n    function sequencerReportedSubMessageCount() external view returns (uint256);\n\n    function executeCall(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bool success, bytes memory returnData);\n\n    function delayedMessageCount() external view returns (uint256);\n\n    function sequencerMessageCount() external view returns (uint256);\n\n    // ---------- onlySequencerInbox functions ----------\n\n    function enqueueSequencerMessage(\n        bytes32 dataHash,\n        uint256 afterDelayedMessagesRead,\n        uint256 prevMessageCount,\n        uint256 newMessageCount\n    )\n        external\n        returns (\n            uint256 seqMessageIndex,\n            bytes32 beforeAcc,\n            bytes32 delayedAcc,\n            bytes32 acc\n        );\n\n    /**\n     * @dev Allows the sequencer inbox to submit a delayed message of the batchPostingReport type\n     *      This is done through a separate function entrypoint instead of allowing the sequencer inbox\n     *      to call `enqueueDelayedMessage` to avoid the gas overhead of an extra SLOAD in either\n     *      every delayed inbox or every sequencer inbox call.\n     */\n    function submitBatchSpendingReport(address batchPoster, bytes32 dataHash)\n        external\n        returns (uint256 msgNum);\n\n    // ---------- onlyRollupOrOwner functions ----------\n\n    function setSequencerInbox(address _sequencerInbox) external;\n\n    function setDelayedInbox(address inbox, bool enabled) external;\n\n    function setOutbox(address inbox, bool enabled) external;\n\n    function updateRollupAddress(IOwnable _rollup) external;\n}\n"}, "src/bridge/IDelayedMessageProvider.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.30;\n\ninterface IDelayedMessageProvider {\n    /// @dev event emitted when a inbox message is added to the Bridge's delayed accumulator\n    event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\n\n    /// @dev event emitted when a inbox message is added to the Bridge's delayed accumulator\n    /// same as InboxMessageDelivered but the batch data is available in tx.input\n    event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\n}\n"}, "src/bridge/IERC20Bridge.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.30;\n\nimport \"./IOwnable.sol\";\nimport \"./IBridge.sol\";\n\ninterface IERC20Bridge is IBridge {\n    /**\n     * @dev token that is escrowed in bridge on L1 side and minted on L2 as native currency.\n     * Fees are paid in this token. There are certain restrictions on the native token:\n     *  - The token can't be rebasing or have a transfer fee\n     *  - The token must only be transferrable via a call to the token address itself\n     *  - The token must only be able to set allowance via a call to the token address itself\n     *  - The token must not have a callback on transfer, and more generally a user must not be able to make a transfer to themselves revert\n     */\n    function nativeToken() external view returns (address);\n\n    /**\n     * @dev number of decimals used by the native token\n     *      This is set on bridge initialization using nativeToken.decimals()\n     *      If the token does not have decimals() method, we assume it have 0 decimals\n     */\n    function nativeTokenDecimals() external view returns (uint8);\n\n    /**\n     * @dev Enqueue a message in the delayed inbox accumulator.\n     *      These messages are later sequenced in the SequencerInbox, either\n     *      by the sequencer as part of a normal batch, or by force inclusion.\n     */\n    function enqueueDelayedMessage(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash,\n        uint256 tokenFeeAmount\n    ) external returns (uint256);\n\n    // ---------- initializer ----------\n\n    function initialize(IOwnable rollup_, address nativeToken_) external;\n}\n"}, "src/bridge/IERC20Inbox.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.30;\n\nimport \"./IInboxBase.sol\";\n\ninterface IERC20Inbox is IInboxBase {\n    /**\n     * @notice Deposit native token from L1 to L2 to address of the sender if sender is an EOA, and to its aliased address if the sender is a contract\n     * @dev This does not trigger the fallback function when receiving in the L2 side.\n     *      Look into retryable tickets if you are interested in this functionality.\n     * @dev This function should not be called inside contract constructors\n     */\n    function depositERC20(uint256 amount) external returns (uint256);\n\n    /**\n     * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\n     * @dev all tokenTotalFeeAmount will be deposited to callValueRefundAddress on L2\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\n     * @dev In case of native token having non-18 decimals: tokenTotalFeeAmount is denominated in native token's decimals. All other value params - l2CallValue, maxSubmissionCost and maxFeePerGas are denominated in child chain's native 18 decimals.\n     * @param to destination L2 contract address\n     * @param l2CallValue call value for retryable L2 message\n     * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\n     * @param excessFeeRefundAddress the address which receives the difference between execution fee paid and the actual execution cost. In case this address is a contract, funds will be received in its alias on L2.\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled. In case this address is a contract, funds will be received in its alias on L2.\n     * @param gasLimit Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param maxFeePerGas price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param tokenTotalFeeAmount amount of fees to be deposited in native token to cover for retryable ticket cost\n     * @param data ABI encoded data of L2 message\n     * @return unique message number of the retryable transaction\n     */\n    function createRetryableTicket(\n        address to,\n        uint256 l2CallValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 tokenTotalFeeAmount,\n        bytes calldata data\n    ) external returns (uint256);\n\n    /**\n     * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\n     * @dev Same as createRetryableTicket, but does not guarantee that submission will succeed by requiring the needed funds\n     * come from the deposit alone, rather than falling back on the user's L2 balance\n     * @dev Advanced usage only (does not rewrite aliases for excessFeeRefundAddress and callValueRefundAddress).\n     * createRetryableTicket method is the recommended standard.\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\n     * @param to destination L2 contract address\n     * @param l2CallValue call value for retryable L2 message\n     * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\n     * @param excessFeeRefundAddress the address which receives the difference between execution fee paid and the actual execution cost\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n     * @param gasLimit Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param maxFeePerGas price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param tokenTotalFeeAmount amount of fees to be deposited in native token to cover for retryable ticket cost\n     * @param data ABI encoded data of L2 message\n     * @return unique message number of the retryable transaction\n     */\n    function unsafeCreateRetryableTicket(\n        address to,\n        uint256 l2CallValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 tokenTotalFeeAmount,\n        bytes calldata data\n    ) external returns (uint256);\n}\n"}, "src/bridge/IEthBridge.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.30;\n\nimport \"./IOwnable.sol\";\nimport \"./IBridge.sol\";\n\ninterface IEthBridge is IBridge {\n    /**\n     * @dev Enqueue a message in the delayed inbox accumulator.\n     *      These messages are later sequenced in the SequencerInbox, either\n     *      by the sequencer as part of a normal batch, or by force inclusion.\n     */\n    function enqueueDelayedMessage(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    ) external payable returns (uint256);\n\n    // ---------- initializer ----------\n\n    function initialize(IOwnable rollup_) external;\n}\n"}, "src/bridge/IInbox.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.30;\n\nimport \"./IBridge.sol\";\nimport \"./IInboxBase.sol\";\n\ninterface IInbox is IInboxBase {\n    function sendL1FundedUnsignedTransaction(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 nonce,\n        address to,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function sendL1FundedContractTransaction(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        address to,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    /**\n     * @dev This method can only be called upon L1 fork and will not alias the caller\n     *      This method will revert if not called from origin\n     */\n    function sendL1FundedUnsignedTransactionToFork(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 nonce,\n        address to,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    /**\n     * @dev This method can only be called upon L1 fork and will not alias the caller\n     *      This method will revert if not called from origin\n     */\n    function sendUnsignedTransactionToFork(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external returns (uint256);\n\n    /**\n     * @notice Send a message to initiate L2 withdrawal\n     * @dev This method can only be called upon L1 fork and will not alias the caller\n     *      This method will revert if not called from origin\n     */\n    function sendWithdrawEthToFork(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 nonce,\n        uint256 value,\n        address withdrawTo\n    ) external returns (uint256);\n\n    /**\n     * @notice Deposit eth from L1 to L2 to address of the sender if sender is an EOA, and to its aliased address if the sender is a contract\n     * @dev This does not trigger the fallback function when receiving in the L2 side.\n     *      Look into retryable tickets if you are interested in this functionality.\n     * @dev This function should not be called inside contract constructors\n     */\n    function depositEth() external payable returns (uint256);\n\n    /**\n     * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\n     * @dev all msg.value will deposited to callValueRefundAddress on L2\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\n     * @param to destination L2 contract address\n     * @param l2CallValue call value for retryable L2 message\n     * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\n     * @param excessFeeRefundAddress the address which receives the difference between execution fee paid and the actual execution cost. In case this address is a contract, funds will be received in its alias on L2.\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled. In case this address is a contract, funds will be received in its alias on L2.\n     * @param gasLimit Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param maxFeePerGas price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param data ABI encoded data of L2 message\n     * @return unique message number of the retryable transaction\n     */\n    function createRetryableTicket(\n        address to,\n        uint256 l2CallValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    /**\n     * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\n     * @dev Same as createRetryableTicket, but does not guarantee that submission will succeed by requiring the needed funds\n     * come from the deposit alone, rather than falling back on the user's L2 balance\n     * @dev Advanced usage only (does not rewrite aliases for excessFeeRefundAddress and callValueRefundAddress).\n     * createRetryableTicket method is the recommended standard.\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\n     * @param to destination L2 contract address\n     * @param l2CallValue call value for retryable L2 message\n     * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\n     * @param excessFeeRefundAddress the address which receives the difference between execution fee paid and the actual execution cost\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n     * @param gasLimit Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param maxFeePerGas price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param data ABI encoded data of L2 message\n     * @return unique message number of the retryable transaction\n     */\n    function unsafeCreateRetryableTicket(\n        address to,\n        uint256 l2CallValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    // ---------- initializer ----------\n\n    /**\n     * @dev function to be called one time during the inbox upgrade process\n     *      this is used to fix the storage slots\n     */\n    function postUpgradeInit(IBridge _bridge) external;\n}\n"}, "src/bridge/IInboxBase.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.30;\n\nimport \"./IBridge.sol\";\nimport \"./IDelayedMessageProvider.sol\";\nimport \"./ISequencerInbox.sol\";\n\ninterface IInboxBase is IDelayedMessageProvider {\n    function bridge() external view returns (IBridge);\n\n    function sequencerInbox() external view returns (ISequencerInbox);\n\n    function maxDataSize() external view returns (uint256);\n\n    /**\n     * @notice Send a generic L2 message to the chain\n     * @dev This method is an optimization to avoid having to emit the entirety of the messageData in a log. Instead validators are expected to be able to parse the data from the transaction's input\n     * @param messageData Data of the message being sent\n     */\n    function sendL2MessageFromOrigin(bytes calldata messageData) external returns (uint256);\n\n    /**\n     * @notice Send a generic L2 message to the chain\n     * @dev This method can be used to send any type of message that doesn't require L1 validation\n     * @param messageData Data of the message being sent\n     */\n    function sendL2Message(bytes calldata messageData) external returns (uint256);\n\n    function sendUnsignedTransaction(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external returns (uint256);\n\n    function sendContractTransaction(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external returns (uint256);\n\n    /**\n     * @notice Get the L1 fee for submitting a retryable\n     * @dev This fee can be paid by funds already in the L2 aliased address or by the current message value\n     * @dev This formula may change in the future, to future proof your code query this method instead of inlining!!\n     * @param dataLength The length of the retryable's calldata, in bytes\n     * @param baseFee The block basefee when the retryable is included in the chain, if 0 current block.basefee will be used\n     */\n    function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee)\n        external\n        view\n        returns (uint256);\n\n    // ---------- onlyRollupOrOwner functions ----------\n\n    /// @notice pauses all inbox functionality\n    function pause() external;\n\n    /// @notice unpauses all inbox functionality\n    function unpause() external;\n\n    /// @notice add or remove users from allowList\n    function setAllowList(address[] memory user, bool[] memory val) external;\n\n    /// @notice enable or disable allowList\n    function setAllowListEnabled(bool _allowListEnabled) external;\n\n    /// @notice check if user is in allowList\n    function isAllowed(address user) external view returns (bool);\n\n    /// @notice check if allowList is enabled\n    function allowListEnabled() external view returns (bool);\n\n    function initialize(IBridge _bridge, ISequencerInbox _sequencerInbox) external;\n\n    /// @notice returns the current admin\n    function getProxyAdmin() external view returns (address);\n}\n"}, "src/bridge/Inbox.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport {\n    NotOrigin,\n    DataTooLarge,\n    InsufficientValue,\n    InsufficientSubmissionCost,\n    RetryableData,\n    L1Forked,\n    NotForked,\n    GasLimitTooLarge\n} from \"../libraries/Error.sol\";\nimport \"./AbsInbox.sol\";\nimport \"./IInbox.sol\";\nimport \"./IBridge.sol\";\nimport \"./IEthBridge.sol\";\nimport \"../libraries/AddressAliasHelper.sol\";\nimport {\n    L2_MSG,\n    L1MessageType_L2FundedByL1,\n    L1MessageType_submitRetryableTx,\n    L1MessageType_ethDeposit,\n    L2MessageType_unsignedEOATx,\n    L2MessageType_unsignedContractTx\n} from \"../libraries/MessageTypes.sol\";\nimport \"../precompiles/ArbSys.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\n/**\n * @title Inbox for user and contract originated messages\n * @notice Messages created via this inbox are enqueued in the delayed accumulator\n * to await inclusion in the SequencerInbox\n */\ncontract Inbox is AbsInbox, IInbox {\n    constructor(uint256 _maxDataSize) AbsInbox(_maxDataSize) {}\n\n    /// @inheritdoc IInboxBase\n    function initialize(IBridge _bridge, ISequencerInbox _sequencerInbox)\n        external\n        initializer\n        onlyDelegated\n    {\n        __AbsInbox_init(_bridge, _sequencerInbox);\n    }\n\n    /// @inheritdoc IInbox\n    function postUpgradeInit(IBridge) external onlyDelegated onlyProxyOwner {}\n\n    /// @inheritdoc IInbox\n    function sendL1FundedUnsignedTransaction(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 nonce,\n        address to,\n        bytes calldata data\n    ) external payable whenNotPaused onlyAllowed returns (uint256) {\n        // arbos will discard unsigned tx with gas limit too large\n        if (gasLimit > type(uint64).max) {\n            revert GasLimitTooLarge();\n        }\n        return\n            _deliverMessage(\n                L1MessageType_L2FundedByL1,\n                msg.sender,\n                abi.encodePacked(\n                    L2MessageType_unsignedEOATx,\n                    gasLimit,\n                    maxFeePerGas,\n                    nonce,\n                    uint256(uint160(to)),\n                    msg.value,\n                    data\n                ),\n                msg.value\n            );\n    }\n\n    /// @inheritdoc IInbox\n    function sendL1FundedContractTransaction(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        address to,\n        bytes calldata data\n    ) external payable whenNotPaused onlyAllowed returns (uint256) {\n        // arbos will discard unsigned tx with gas limit too large\n        if (gasLimit > type(uint64).max) {\n            revert GasLimitTooLarge();\n        }\n        return\n            _deliverMessage(\n                L1MessageType_L2FundedByL1,\n                msg.sender,\n                abi.encodePacked(\n                    L2MessageType_unsignedContractTx,\n                    gasLimit,\n                    maxFeePerGas,\n                    uint256(uint160(to)),\n                    msg.value,\n                    data\n                ),\n                msg.value\n            );\n    }\n\n    /// @inheritdoc IInbox\n    function sendL1FundedUnsignedTransactionToFork(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 nonce,\n        address to,\n        bytes calldata data\n    ) external payable whenNotPaused onlyAllowed returns (uint256) {\n        if (!_chainIdChanged()) revert NotForked();\n        // solhint-disable-next-line avoid-tx-origin\n        if (msg.sender != tx.origin) revert NotOrigin();\n        // arbos will discard unsigned tx with gas limit too large\n        if (gasLimit > type(uint64).max) {\n            revert GasLimitTooLarge();\n        }\n        return\n            _deliverMessage(\n                L1MessageType_L2FundedByL1,\n                // undoing sender alias here to cancel out the aliasing\n                AddressAliasHelper.undoL1ToL2Alias(msg.sender),\n                abi.encodePacked(\n                    L2MessageType_unsignedEOATx,\n                    gasLimit,\n                    maxFeePerGas,\n                    nonce,\n                    uint256(uint160(to)),\n                    msg.value,\n                    data\n                ),\n                msg.value\n            );\n    }\n\n    /// @inheritdoc IInbox\n    function sendUnsignedTransactionToFork(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external whenNotPaused onlyAllowed returns (uint256) {\n        if (!_chainIdChanged()) revert NotForked();\n        // solhint-disable-next-line avoid-tx-origin\n        if (msg.sender != tx.origin) revert NotOrigin();\n        // arbos will discard unsigned tx with gas limit too large\n        if (gasLimit > type(uint64).max) {\n            revert GasLimitTooLarge();\n        }\n        return\n            _deliverMessage(\n                L2_MSG,\n                // undoing sender alias here to cancel out the aliasing\n                AddressAliasHelper.undoL1ToL2Alias(msg.sender),\n                abi.encodePacked(\n                    L2MessageType_unsignedEOATx,\n                    gasLimit,\n                    maxFeePerGas,\n                    nonce,\n                    uint256(uint160(to)),\n                    value,\n                    data\n                ),\n                0\n            );\n    }\n\n    /// @inheritdoc IInbox\n    function sendWithdrawEthToFork(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 nonce,\n        uint256 value,\n        address withdrawTo\n    ) external whenNotPaused onlyAllowed returns (uint256) {\n        if (!_chainIdChanged()) revert NotForked();\n        // solhint-disable-next-line avoid-tx-origin\n        if (msg.sender != tx.origin) revert NotOrigin();\n        // arbos will discard unsigned tx with gas limit too large\n        if (gasLimit > type(uint64).max) {\n            revert GasLimitTooLarge();\n        }\n        return\n            _deliverMessage(\n                L2_MSG,\n                // undoing sender alias here to cancel out the aliasing\n                AddressAliasHelper.undoL1ToL2Alias(msg.sender),\n                abi.encodePacked(\n                    L2MessageType_unsignedEOATx,\n                    gasLimit,\n                    maxFeePerGas,\n                    nonce,\n                    uint256(uint160(address(100))), // ArbSys address\n                    value,\n                    abi.encodeWithSelector(ArbSys.withdrawEth.selector, withdrawTo)\n                ),\n                0\n            );\n    }\n\n    /// @inheritdoc IInbox\n    function depositEth() public payable whenNotPaused onlyAllowed returns (uint256) {\n        address dest = msg.sender;\n\n        // solhint-disable-next-line avoid-tx-origin\n        if (AddressUpgradeable.isContract(msg.sender) || tx.origin != msg.sender) {\n            // isContract check fails if this function is called during a contract's constructor.\n            dest = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n        }\n\n        return\n            _deliverMessage(\n                L1MessageType_ethDeposit,\n                msg.sender,\n                abi.encodePacked(dest, msg.value),\n                msg.value\n            );\n    }\n\n    /// @notice deprecated in favour of depositEth with no parameters\n    function depositEth(uint256) external payable whenNotPaused onlyAllowed returns (uint256) {\n        return depositEth();\n    }\n\n    /**\n     * @notice deprecated in favour of unsafeCreateRetryableTicket\n     * @dev deprecated in favour of unsafeCreateRetryableTicket\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\n     * @param to destination L2 contract address\n     * @param l2CallValue call value for retryable L2 message\n     * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\n     * @param excessFeeRefundAddress the address which receives the difference between execution fee paid and the actual execution cost\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n     * @param gasLimit Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param maxFeePerGas price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param data ABI encoded data of L2 message\n     * @return unique message number of the retryable transaction\n     */\n    function createRetryableTicketNoRefundAliasRewrite(\n        address to,\n        uint256 l2CallValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        bytes calldata data\n    ) external payable whenNotPaused onlyAllowed returns (uint256) {\n        // gas limit is validated to be within uint64 in unsafeCreateRetryableTicket\n        return\n            unsafeCreateRetryableTicket(\n                to,\n                l2CallValue,\n                maxSubmissionCost,\n                excessFeeRefundAddress,\n                callValueRefundAddress,\n                gasLimit,\n                maxFeePerGas,\n                data\n            );\n    }\n\n    /// @inheritdoc IInbox\n    function createRetryableTicket(\n        address to,\n        uint256 l2CallValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        bytes calldata data\n    ) external payable whenNotPaused onlyAllowed returns (uint256) {\n        return\n            _createRetryableTicket(\n                to,\n                l2CallValue,\n                maxSubmissionCost,\n                excessFeeRefundAddress,\n                callValueRefundAddress,\n                gasLimit,\n                maxFeePerGas,\n                msg.value,\n                data\n            );\n    }\n\n    /// @inheritdoc IInbox\n    function unsafeCreateRetryableTicket(\n        address to,\n        uint256 l2CallValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        bytes calldata data\n    ) public payable whenNotPaused onlyAllowed returns (uint256) {\n        return\n            _unsafeCreateRetryableTicket(\n                to,\n                l2CallValue,\n                maxSubmissionCost,\n                excessFeeRefundAddress,\n                callValueRefundAddress,\n                gasLimit,\n                maxFeePerGas,\n                msg.value,\n                data\n            );\n    }\n\n    /// @inheritdoc IInboxBase\n    function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee)\n        public\n        view\n        override(AbsInbox, IInboxBase)\n        returns (uint256)\n    {\n        // Use current block basefee if baseFee parameter is 0\n        return (1400 + 6 * dataLength) * (baseFee == 0 ? block.basefee : baseFee);\n    }\n\n    function _deliverToBridge(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash,\n        uint256 amount\n    ) internal override returns (uint256) {\n        return\n            IEthBridge(address(bridge)).enqueueDelayedMessage{value: amount}(\n                kind,\n                AddressAliasHelper.applyL1ToL2Alias(sender),\n                messageDataHash\n            );\n    }\n\n    /// @inheritdoc AbsInbox\n    function _fromNativeTo18Decimals(uint256 value) internal pure override returns (uint256) {\n        return value;\n    }\n}\n"}, "src/bridge/IOutbox.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.30;\n\nimport \"./IBridge.sol\";\n\ninterface IOutbox {\n    event SendRootUpdated(bytes32 indexed outputRoot, bytes32 indexed l2BlockHash);\n    event OutBoxTransactionExecuted(\n        address indexed to,\n        address indexed l2Sender,\n        uint256 indexed zero,\n        uint256 transactionIndex\n    );\n\n    function initialize(IBridge _bridge) external;\n\n    function rollup() external view returns (address); // the rollup contract\n\n    function bridge() external view returns (IBridge); // the bridge contract\n\n    function spent(uint256) external view returns (bytes32); // packed spent bitmap\n\n    function roots(bytes32) external view returns (bytes32); // maps root hashes => L2 block hash\n\n    // solhint-disable-next-line func-name-mixedcase\n    function OUTBOX_VERSION() external view returns (uint128); // the outbox version\n\n    function updateSendRoot(bytes32 sendRoot, bytes32 l2BlockHash) external;\n\n    function updateRollupAddress() external;\n\n    /// @notice When l2ToL1Sender returns a nonzero address, the message was originated by an L2 account\n    ///         When the return value is zero, that means this is a system message\n    /// @dev the l2ToL1Sender behaves as the tx.origin, the msg.sender should be validated to protect against reentrancies\n    function l2ToL1Sender() external view returns (address);\n\n    /// @return l2Block return L2 block when the L2 tx was initiated or 0 if no L2 to L1 transaction is active\n    function l2ToL1Block() external view returns (uint256);\n\n    /// @return l1Block return L1 block when the L2 tx was initiated or 0 if no L2 to L1 transaction is active\n    function l2ToL1EthBlock() external view returns (uint256);\n\n    /// @return timestamp return L2 timestamp when the L2 tx was initiated or 0 if no L2 to L1 transaction is active\n    function l2ToL1Timestamp() external view returns (uint256);\n\n    /// @return outputId returns the unique output identifier of the L2 to L1 tx or 0 if no L2 to L1 transaction is active\n    function l2ToL1OutputId() external view returns (bytes32);\n\n    /**\n     * @notice Executes a messages in an Outbox entry.\n     * @dev Reverts if dispute period hasn't expired, since the outbox entry\n     *      is only created once the rollup confirms the respective assertion.\n     * @dev it is not possible to execute any L2-to-L1 transaction which contains data\n     *      to a contract address without any code (as enforced by the Bridge contract).\n     * @param proof Merkle proof of message inclusion in send root\n     * @param index Merkle path to message\n     * @param l2Sender sender if original message (i.e., caller of ArbSys.sendTxToL1)\n     * @param to destination address for L1 contract call\n     * @param l2Block l2 block number at which sendTxToL1 call was made\n     * @param l1Block l1 block number at which sendTxToL1 call was made\n     * @param l2Timestamp l2 Timestamp at which sendTxToL1 call was made\n     * @param value wei in L1 message\n     * @param data abi-encoded L1 message data\n     */\n    function executeTransaction(\n        bytes32[] calldata proof,\n        uint256 index,\n        address l2Sender,\n        address to,\n        uint256 l2Block,\n        uint256 l1Block,\n        uint256 l2Timestamp,\n        uint256 value,\n        bytes calldata data\n    ) external;\n\n    /**\n     *  @dev function used to simulate the result of a particular function call from the outbox\n     *       it is useful for things such as gas estimates. This function includes all costs except for\n     *       proof validation (which can be considered offchain as a somewhat of a fixed cost - it's\n     *       not really a fixed cost, but can be treated as so with a fixed overhead for gas estimation).\n     *       We can't include the cost of proof validation since this is intended to be used to simulate txs\n     *       that are included in yet-to-be confirmed merkle roots. The simulation entrypoint could instead pretend\n     *       to confirm a pending merkle root, but that would be less practical for integrating with tooling.\n     *       It is only possible to trigger it when the msg sender is address zero, which should be impossible\n     *       unless under simulation in an eth_call or eth_estimateGas\n     */\n    function executeTransactionSimulation(\n        uint256 index,\n        address l2Sender,\n        address to,\n        uint256 l2Block,\n        uint256 l1Block,\n        uint256 l2Timestamp,\n        uint256 value,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @param index Merkle path to message\n     * @return true if the message has been spent\n     */\n    function isSpent(uint256 index) external view returns (bool);\n\n    function calculateItemHash(\n        address l2Sender,\n        address to,\n        uint256 l2Block,\n        uint256 l1Block,\n        uint256 l2Timestamp,\n        uint256 value,\n        bytes calldata data\n    ) external pure returns (bytes32);\n\n    function calculateMerkleRoot(\n        bytes32[] memory proof,\n        uint256 path,\n        bytes32 item\n    ) external pure returns (bytes32);\n\n    /**\n     * @dev function to be called one time during the outbox upgrade process\n     *      this is used to fix the storage slots\n     */\n    function postUpgradeInit() external;\n}\n"}, "src/bridge/IOwnable.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.30;\n\ninterface IOwnable {\n    function owner() external view returns (address);\n}\n"}, "src/bridge/ISequencerInbox.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.30;\npragma experimental ABIEncoderV2;\n\nimport \"../libraries/IGasRefunder.sol\";\nimport \"./IDelayedMessageProvider.sol\";\nimport \"./IBridge.sol\";\n\ninterface ISequencerInbox is IDelayedMessageProvider {\n    struct MaxTimeVariation {\n        uint256 delayBlocks;\n        uint256 futureBlocks;\n        uint256 delaySeconds;\n        uint256 futureSeconds;\n    }\n\n    event SequencerBatchDelivered(\n        uint256 indexed batchSequenceNumber,\n        bytes32 indexed beforeAcc,\n        bytes32 indexed afterAcc,\n        bytes32 delayedAcc,\n        uint256 afterDelayedMessagesRead,\n        IBridge.TimeBounds timeBounds,\n        IBridge.BatchDataLocation dataLocation\n    );\n\n    event OwnerFunctionCalled(uint256 indexed id);\n\n    /// @dev a separate event that emits batch data when this isn't easily accessible in the tx.input\n    event SequencerBatchData(uint256 indexed batchSequenceNumber, bytes data);\n\n    /// @dev a valid keyset was added\n    event SetValidKeyset(bytes32 indexed keysetHash, bytes keysetBytes);\n\n    /// @dev a keyset was invalidated\n    event InvalidateKeyset(bytes32 indexed keysetHash);\n\n    function totalDelayedMessagesRead() external view returns (uint256);\n\n    function bridge() external view returns (IBridge);\n\n    /// @dev The size of the batch header\n    // solhint-disable-next-line func-name-mixedcase\n    function HEADER_LENGTH() external view returns (uint256);\n\n    /// @dev If the first batch data byte after the header has this bit set,\n    ///      the sequencer inbox has authenticated the data. Currently only used for 4844 blob support.\n    ///      See: https://github.com/OffchainLabs/nitro/blob/69de0603abf6f900a4128cab7933df60cad54ded/arbstate/das_reader.go\n    // solhint-disable-next-line func-name-mixedcase\n    function DATA_AUTHENTICATED_FLAG() external view returns (bytes1);\n\n    /// @dev If the first data byte after the header has this bit set,\n    ///      then the batch data is to be found in 4844 data blobs\n    ///      See: https://github.com/OffchainLabs/nitro/blob/69de0603abf6f900a4128cab7933df60cad54ded/arbstate/das_reader.go\n    // solhint-disable-next-line func-name-mixedcase\n    function DATA_BLOB_HEADER_FLAG() external view returns (bytes1);\n\n    /// @dev If the first data byte after the header has this bit set,\n    ///      then the batch data is a das message\n    ///      See: https://github.com/OffchainLabs/nitro/blob/69de0603abf6f900a4128cab7933df60cad54ded/arbstate/das_reader.go\n    // solhint-disable-next-line func-name-mixedcase\n    function DAS_MESSAGE_HEADER_FLAG() external view returns (bytes1);\n\n    /// @dev If the first data byte after the header has this bit set,\n    ///      then the batch data is a celestia message\n    ///      See: https://github.com/celestiaorg/nitro/blob/blobstream-v2.2.2/arbstate/das_reader.go\n    // solhint-disable-next-line func-name-mixedcase\n    function CELESTIA_MESSAGE_HEADER_FLAG() external view returns (bytes1);\n\n    /// @dev If the first data byte after the header has this bit set,\n    ///      then the batch data is a das message that employs a merklesization strategy\n    ///      See: https://github.com/OffchainLabs/nitro/blob/69de0603abf6f900a4128cab7933df60cad54ded/arbstate/das_reader.go\n    // solhint-disable-next-line func-name-mixedcase\n    function TREE_DAS_MESSAGE_HEADER_FLAG() external view returns (bytes1);\n\n    /// @dev If the first data byte after the header has this bit set,\n    ///      then the batch data has been brotli compressed\n    ///      See: https://github.com/OffchainLabs/nitro/blob/69de0603abf6f900a4128cab7933df60cad54ded/arbstate/das_reader.go\n    // solhint-disable-next-line func-name-mixedcase\n    function BROTLI_MESSAGE_HEADER_FLAG() external view returns (bytes1);\n\n    /// @dev If the first data byte after the header has this bit set,\n    ///      then the batch data uses a zero heavy encoding\n    ///      See: https://github.com/OffchainLabs/nitro/blob/69de0603abf6f900a4128cab7933df60cad54ded/arbstate/das_reader.go\n    // solhint-disable-next-line func-name-mixedcase\n    function ZERO_HEAVY_MESSAGE_HEADER_FLAG() external view returns (bytes1);\n\n    function rollup() external view returns (IOwnable);\n\n    function isBatchPoster(address) external view returns (bool);\n\n    function isSequencer(address) external view returns (bool);\n\n    function maxDataSize() external view returns (uint256);\n\n    /// @notice The batch poster manager has the ability to change the batch poster addresses\n    ///         This enables the batch poster to do key rotation\n    function batchPosterManager() external view returns (address);\n\n    struct DasKeySetInfo {\n        bool isValidKeyset;\n        uint64 creationBlock;\n    }\n\n    /// @dev returns 4 uint256 to be compatible with older version\n    function maxTimeVariation()\n        external\n        view\n        returns (\n            uint256 delayBlocks,\n            uint256 futureBlocks,\n            uint256 delaySeconds,\n            uint256 futureSeconds\n        );\n\n    function dasKeySetInfo(bytes32) external view returns (bool, uint64);\n\n    /// @notice Remove force inclusion delay after a L1 chainId fork\n    function removeDelayAfterFork() external;\n\n    /// @notice Force messages from the delayed inbox to be included in the chain\n    ///         Callable by any address, but message can only be force-included after maxTimeVariation.delayBlocks and\n    ///         maxTimeVariation.delaySeconds has elapsed. As part of normal behaviour the sequencer will include these\n    ///         messages so it's only necessary to call this if the sequencer is down, or not including any delayed messages.\n    /// @param _totalDelayedMessagesRead The total number of messages to read up to\n    /// @param kind The kind of the last message to be included\n    /// @param l1BlockAndTime The l1 block and the l1 timestamp of the last message to be included\n    /// @param baseFeeL1 The l1 gas price of the last message to be included\n    /// @param sender The sender of the last message to be included\n    /// @param messageDataHash The messageDataHash of the last message to be included\n    function forceInclusion(\n        uint256 _totalDelayedMessagesRead,\n        uint8 kind,\n        uint64[2] calldata l1BlockAndTime,\n        uint256 baseFeeL1,\n        address sender,\n        bytes32 messageDataHash\n    ) external;\n\n    function inboxAccs(uint256 index) external view returns (bytes32);\n\n    function batchCount() external view returns (uint256);\n\n    function isValidKeysetHash(bytes32 ksHash) external view returns (bool);\n\n    /// @notice the creation block is intended to still be available after a keyset is deleted\n    function getKeysetCreationBlock(bytes32 ksHash) external view returns (uint256);\n\n    // ---------- BatchPoster functions ----------\n\n    function addSequencerL2BatchFromOrigin(\n        uint256 sequenceNumber,\n        bytes calldata data,\n        uint256 afterDelayedMessagesRead,\n        IGasRefunder gasRefunder\n    ) external;\n\n    function addSequencerL2BatchFromOrigin(\n        uint256 sequenceNumber,\n        bytes calldata data,\n        uint256 afterDelayedMessagesRead,\n        IGasRefunder gasRefunder,\n        uint256 prevMessageCount,\n        uint256 newMessageCount\n    ) external;\n\n    function addSequencerL2Batch(\n        uint256 sequenceNumber,\n        bytes calldata data,\n        uint256 afterDelayedMessagesRead,\n        IGasRefunder gasRefunder,\n        uint256 prevMessageCount,\n        uint256 newMessageCount\n    ) external;\n\n    function addSequencerL2BatchFromBlobs(\n        uint256 sequenceNumber,\n        uint256 afterDelayedMessagesRead,\n        IGasRefunder gasRefunder,\n        uint256 prevMessageCount,\n        uint256 newMessageCount\n    ) external;\n\n    // ---------- onlyRollupOrOwner functions ----------\n\n    /**\n     * @notice Set max delay for sequencer inbox\n     * @param maxTimeVariation_ the maximum time variation parameters\n     */\n    function setMaxTimeVariation(MaxTimeVariation memory maxTimeVariation_) external;\n\n    /**\n     * @notice Updates whether an address is authorized to be a batch poster at the sequencer inbox\n     * @param addr the address\n     * @param isBatchPoster_ if the specified address should be authorized as a batch poster\n     */\n    function setIsBatchPoster(address addr, bool isBatchPoster_) external;\n\n    /**\n     * @notice Makes Data Availability Service keyset valid\n     * @param keysetBytes bytes of the serialized keyset\n     */\n    function setValidKeyset(bytes calldata keysetBytes) external;\n\n    /**\n     * @notice Invalidates a Data Availability Service keyset\n     * @param ksHash hash of the keyset\n     */\n    function invalidateKeysetHash(bytes32 ksHash) external;\n\n    /**\n     * @notice Updates whether an address is authorized to be a sequencer.\n     * @dev The IsSequencer information is used only off-chain by the nitro node to validate sequencer feed signer.\n     * @param addr the address\n     * @param isSequencer_ if the specified address should be authorized as a sequencer\n     */\n    function setIsSequencer(address addr, bool isSequencer_) external;\n\n    /**\n     * @notice Updates the batch poster manager, the address which has the ability to rotate batch poster keys\n     * @param newBatchPosterManager The new batch poster manager to be set\n     */\n    function setBatchPosterManager(address newBatchPosterManager) external;\n\n    /// @notice Allows the rollup owner to sync the rollup address\n    function updateRollupAddress() external;\n\n    // ---------- initializer ----------\n\n    function initialize(IBridge bridge_, MaxTimeVariation calldata maxTimeVariation_) external;\n}\n"}, "src/bridge/Messages.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nlibrary Messages {\n    function messageHash(\n        uint8 kind,\n        address sender,\n        uint64 blockNumber,\n        uint64 timestamp,\n        uint256 inboxSeqNum,\n        uint256 baseFeeL1,\n        bytes32 messageDataHash\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    kind,\n                    sender,\n                    blockNumber,\n                    timestamp,\n                    inboxSeqNum,\n                    baseFeeL1,\n                    messageDataHash\n                )\n            );\n    }\n\n    function accumulateInboxMessage(bytes32 prevAcc, bytes32 message)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(prevAcc, message));\n    }\n}\n"}, "src/bridge/Outbox.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./AbsOutbox.sol\";\n\ncontract Outbox is AbsOutbox {\n    /// @inheritdoc AbsOutbox\n    function _defaultContextAmount() internal pure override returns (uint256) {\n        // In ETH-based chains withdrawal amount can be read from msg.value. For that reason\n        // amount slot in context will never be accessed and it has 0 default value\n        return 0;\n    }\n\n    /// @inheritdoc AbsOutbox\n    function _getAmountToUnlock(uint256 value) internal pure override returns (uint256) {\n        return value;\n    }\n\n    /// @inheritdoc AbsOutbox\n    function _amountToSetInContext(uint256) internal pure override returns (uint256) {\n        // In ETH-based chains withdrawal amount can be read from msg.value. For that reason\n        // amount slot in context will never be accessed, we keep it as 0 all the time\n        return 0;\n    }\n}\n"}, "src/bridge/SequencerInbox.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport {\n    AlreadyInit,\n    HadZeroInit,\n    BadPostUpgradeInit,\n    NotOrigin,\n    DataTooLarge,\n    DelayedBackwards,\n    DelayedTooFar,\n    ForceIncludeBlockTooSoon,\n    ForceIncludeTimeTooSoon,\n    IncorrectMessagePreimage,\n    NotBatchPoster,\n    BadSequencerNumber,\n    AlreadyValidDASKeyset,\n    NoSuchKeyset,\n    NotForked,\n    NotBatchPosterManager,\n    RollupNotChanged,\n    DataBlobsNotSupported,\n    InitParamZero,\n    MissingDataHashes,\n    NotOwner,\n    InvalidHeaderFlag,\n    NativeTokenMismatch,\n    BadMaxTimeVariation,\n    Deprecated,\n    InvalidCelestiaBatch\n} from \"../libraries/Error.sol\";\nimport \"./IBridge.sol\";\nimport \"./IInboxBase.sol\";\nimport \"./ISequencerInbox.sol\";\nimport \"../rollup/IRollupLogic.sol\";\nimport \"./Messages.sol\";\nimport \"../precompiles/ArbGasInfo.sol\";\nimport \"../precompiles/ArbSys.sol\";\nimport \"../libraries/IReader4844.sol\";\n\nimport {L1MessageType_batchPostingReport} from \"../libraries/MessageTypes.sol\";\nimport \"../libraries/DelegateCallAware.sol\";\nimport {IGasRefunder} from \"../libraries/IGasRefunder.sol\";\nimport {GasRefundEnabled} from \"../libraries/GasRefundEnabled.sol\";\nimport \"../libraries/ArbitrumChecker.sol\";\nimport {IERC20Bridge} from \"./IERC20Bridge.sol\";\n\n/**\n * @title  Accepts batches from the sequencer and adds them to the rollup inbox.\n * @notice Contains the inbox accumulator which is the ordering of all data and transactions to be processed by the rollup.\n *         As part of submitting a batch the sequencer is also expected to include items enqueued\n *         in the delayed inbox (Bridge.sol). If items in the delayed inbox are not included by a\n *         sequencer within a time limit they can be force included into the rollup inbox by anyone.\n */\ncontract SequencerInbox is DelegateCallAware, GasRefundEnabled, ISequencerInbox {\n    uint256 public totalDelayedMessagesRead;\n\n    IBridge public bridge;\n\n    address public constant BLOBSTREAM = 0xa8973BDEf20fe4112C920582938EF2F022C911f5;\n\n    /// @inheritdoc ISequencerInbox\n    uint256 public constant HEADER_LENGTH = 40;\n\n    /// @inheritdoc ISequencerInbox\n    bytes1 public constant DATA_AUTHENTICATED_FLAG = 0x40;\n\n    /// @inheritdoc ISequencerInbox\n    bytes1 public constant DATA_BLOB_HEADER_FLAG = DATA_AUTHENTICATED_FLAG | 0x10;\n\n    /// @inheritdoc ISequencerInbox\n    bytes1 public constant DAS_MESSAGE_HEADER_FLAG = 0x80;\n\n    /// @inheritdoc ISequencerInbox\n    bytes1 public constant CELESTIA_MESSAGE_HEADER_FLAG = 0x63;\n\n    /// @inheritdoc ISequencerInbox\n    bytes1 public constant TREE_DAS_MESSAGE_HEADER_FLAG = 0x08;\n\n    /// @inheritdoc ISequencerInbox\n    bytes1 public constant BROTLI_MESSAGE_HEADER_FLAG = 0x00;\n\n    /// @inheritdoc ISequencerInbox\n    bytes1 public constant ZERO_HEAVY_MESSAGE_HEADER_FLAG = 0x20;\n\n    // GAS_PER_BLOB from EIP-4844\n    uint256 internal constant GAS_PER_BLOB = 1 << 17;\n\n    IOwnable public rollup;\n\n    mapping(address => bool) public isBatchPoster;\n\n    // we previously stored the max time variation in a (uint,uint,uint,uint) struct here\n    // solhint-disable-next-line var-name-mixedcase\n    ISequencerInbox.MaxTimeVariation private __LEGACY_MAX_TIME_VARIATION;\n\n    mapping(bytes32 => DasKeySetInfo) public dasKeySetInfo;\n\n    modifier onlyRollupOwner() {\n        if (msg.sender != rollup.owner()) revert NotOwner(msg.sender, rollup.owner());\n        _;\n    }\n\n    modifier onlyRollupOwnerOrBatchPosterManager() {\n        if (msg.sender != rollup.owner() && msg.sender != batchPosterManager) {\n            revert NotBatchPosterManager(msg.sender);\n        }\n        _;\n    }\n\n    mapping(address => bool) public isSequencer;\n    IReader4844 public immutable reader4844;\n\n    // see ISequencerInbox.MaxTimeVariation\n    uint64 internal delayBlocks;\n    uint64 internal futureBlocks;\n    uint64 internal delaySeconds;\n    uint64 internal futureSeconds;\n\n    /// @inheritdoc ISequencerInbox\n    address public batchPosterManager;\n\n    // On L1 this should be set to 117964: 90% of Geth's 128KB tx size limit, leaving ~13KB for proving\n    uint256 public immutable maxDataSize;\n    uint256 internal immutable deployTimeChainId = block.chainid;\n    // If the chain this SequencerInbox is deployed on is an Arbitrum chain.\n    bool internal immutable hostChainIsArbitrum = ArbitrumChecker.runningOnArbitrum();\n    // True if the chain this SequencerInbox is deployed on uses custom fee token\n    bool public immutable isUsingFeeToken;\n\n    constructor(uint256 _maxDataSize, IReader4844 reader4844_, bool _isUsingFeeToken) {\n        maxDataSize = _maxDataSize;\n        if (hostChainIsArbitrum) {\n            if (reader4844_ != IReader4844(address(0))) revert DataBlobsNotSupported();\n        } else {\n            if (reader4844_ == IReader4844(address(0))) revert InitParamZero(\"Reader4844\");\n        }\n        reader4844 = reader4844_;\n        isUsingFeeToken = _isUsingFeeToken;\n    }\n\n    function _chainIdChanged() internal view returns (bool) {\n        return deployTimeChainId != block.chainid;\n    }\n\n    function postUpgradeInit() external onlyDelegated onlyProxyOwner {\n        // Assuming we would not upgrade from a version that have MaxTimeVariation all set to zero\n        // If that is the case, postUpgradeInit do not need to be called\n        if (\n            __LEGACY_MAX_TIME_VARIATION.delayBlocks == 0 &&\n            __LEGACY_MAX_TIME_VARIATION.futureBlocks == 0 &&\n            __LEGACY_MAX_TIME_VARIATION.delaySeconds == 0 &&\n            __LEGACY_MAX_TIME_VARIATION.futureSeconds == 0\n        ) {\n            revert AlreadyInit();\n        }\n\n        if (\n            __LEGACY_MAX_TIME_VARIATION.delayBlocks > type(uint64).max ||\n            __LEGACY_MAX_TIME_VARIATION.futureBlocks > type(uint64).max ||\n            __LEGACY_MAX_TIME_VARIATION.delaySeconds > type(uint64).max ||\n            __LEGACY_MAX_TIME_VARIATION.futureSeconds > type(uint64).max\n        ) {\n            revert BadPostUpgradeInit();\n        }\n\n        delayBlocks = uint64(__LEGACY_MAX_TIME_VARIATION.delayBlocks);\n        futureBlocks = uint64(__LEGACY_MAX_TIME_VARIATION.futureBlocks);\n        delaySeconds = uint64(__LEGACY_MAX_TIME_VARIATION.delaySeconds);\n        futureSeconds = uint64(__LEGACY_MAX_TIME_VARIATION.futureSeconds);\n\n        __LEGACY_MAX_TIME_VARIATION.delayBlocks = 0;\n        __LEGACY_MAX_TIME_VARIATION.futureBlocks = 0;\n        __LEGACY_MAX_TIME_VARIATION.delaySeconds = 0;\n        __LEGACY_MAX_TIME_VARIATION.futureSeconds = 0;\n    }\n\n    function initialize(\n        IBridge bridge_,\n        ISequencerInbox.MaxTimeVariation calldata maxTimeVariation_\n    ) external onlyDelegated {\n        if (bridge != IBridge(address(0))) revert AlreadyInit();\n        if (bridge_ == IBridge(address(0))) revert HadZeroInit();\n\n        // Make sure logic contract was created by proper value for 'isUsingFeeToken'.\n        // Bridge in ETH based chains doesn't implement nativeToken(). In future it might implement it and return address(0)\n        bool actualIsUsingFeeToken = false;\n        try IERC20Bridge(address(bridge_)).nativeToken() returns (address feeToken) {\n            if (feeToken != address(0)) {\n                actualIsUsingFeeToken = true;\n            }\n        } catch {}\n        if (isUsingFeeToken != actualIsUsingFeeToken) {\n            revert NativeTokenMismatch();\n        }\n\n        bridge = bridge_;\n        rollup = bridge_.rollup();\n\n        _setMaxTimeVariation(maxTimeVariation_);\n    }\n\n    /// @notice Allows the rollup owner to sync the rollup address\n    function updateRollupAddress() external {\n        if (msg.sender != IOwnable(rollup).owner())\n            revert NotOwner(msg.sender, IOwnable(rollup).owner());\n        IOwnable newRollup = bridge.rollup();\n        if (rollup == newRollup) revert RollupNotChanged();\n        rollup = newRollup;\n    }\n\n    function getTimeBounds() internal view virtual returns (IBridge.TimeBounds memory) {\n        IBridge.TimeBounds memory bounds;\n        (\n            uint64 delayBlocks_,\n            uint64 futureBlocks_,\n            uint64 delaySeconds_,\n            uint64 futureSeconds_\n        ) = maxTimeVariationInternal();\n        if (block.timestamp > delaySeconds_) {\n            bounds.minTimestamp = uint64(block.timestamp) - delaySeconds_;\n        }\n        bounds.maxTimestamp = uint64(block.timestamp) + futureSeconds_;\n        if (block.number > delayBlocks_) {\n            bounds.minBlockNumber = uint64(block.number) - delayBlocks_;\n        }\n        bounds.maxBlockNumber = uint64(block.number) + futureBlocks_;\n        return bounds;\n    }\n\n    /// @inheritdoc ISequencerInbox\n    function removeDelayAfterFork() external {\n        if (!_chainIdChanged()) revert NotForked();\n        delayBlocks = 1;\n        futureBlocks = 1;\n        delaySeconds = 1;\n        futureSeconds = 1;\n    }\n\n    function maxTimeVariation() external view returns (uint256, uint256, uint256, uint256) {\n        (\n            uint64 delayBlocks_,\n            uint64 futureBlocks_,\n            uint64 delaySeconds_,\n            uint64 futureSeconds_\n        ) = maxTimeVariationInternal();\n\n        return (\n            uint256(delayBlocks_),\n            uint256(futureBlocks_),\n            uint256(delaySeconds_),\n            uint256(futureSeconds_)\n        );\n    }\n\n    function maxTimeVariationInternal() internal view returns (uint64, uint64, uint64, uint64) {\n        if (_chainIdChanged()) {\n            return (1, 1, 1, 1);\n        } else {\n            return (delayBlocks, futureBlocks, delaySeconds, futureSeconds);\n        }\n    }\n\n    /// @inheritdoc ISequencerInbox\n    function forceInclusion(\n        uint256 _totalDelayedMessagesRead,\n        uint8 kind,\n        uint64[2] calldata l1BlockAndTime,\n        uint256 baseFeeL1,\n        address sender,\n        bytes32 messageDataHash\n    ) external {\n        if (_totalDelayedMessagesRead <= totalDelayedMessagesRead) revert DelayedBackwards();\n        bytes32 messageHash = Messages.messageHash(\n            kind,\n            sender,\n            l1BlockAndTime[0],\n            l1BlockAndTime[1],\n            _totalDelayedMessagesRead - 1,\n            baseFeeL1,\n            messageDataHash\n        );\n        // Can only force-include after the Sequencer-only window has expired.\n        if (l1BlockAndTime[0] + delayBlocks >= block.number) revert ForceIncludeBlockTooSoon();\n        if (l1BlockAndTime[1] + delaySeconds >= block.timestamp) revert ForceIncludeTimeTooSoon();\n\n        // Verify that message hash represents the last message sequence of delayed message to be included\n        bytes32 prevDelayedAcc = 0;\n        if (_totalDelayedMessagesRead > 1) {\n            prevDelayedAcc = bridge.delayedInboxAccs(_totalDelayedMessagesRead - 2);\n        }\n        if (\n            bridge.delayedInboxAccs(_totalDelayedMessagesRead - 1) !=\n            Messages.accumulateInboxMessage(prevDelayedAcc, messageHash)\n        ) revert IncorrectMessagePreimage();\n\n        (bytes32 dataHash, IBridge.TimeBounds memory timeBounds) = formEmptyDataHash(\n            _totalDelayedMessagesRead\n        );\n        uint256 __totalDelayedMessagesRead = _totalDelayedMessagesRead;\n        uint256 prevSeqMsgCount = bridge.sequencerReportedSubMessageCount();\n        uint256 newSeqMsgCount = prevSeqMsgCount; // force inclusion should not modify sequencer message count\n        (\n            uint256 seqMessageIndex,\n            bytes32 beforeAcc,\n            bytes32 delayedAcc,\n            bytes32 afterAcc\n        ) = addSequencerL2BatchImpl(\n                dataHash,\n                __totalDelayedMessagesRead,\n                0,\n                prevSeqMsgCount,\n                newSeqMsgCount\n            );\n        emit SequencerBatchDelivered(\n            seqMessageIndex,\n            beforeAcc,\n            afterAcc,\n            delayedAcc,\n            totalDelayedMessagesRead,\n            timeBounds,\n            IBridge.BatchDataLocation.NoData\n        );\n    }\n\n    /// @dev Deprecated, kept for abi generation and will be removed in the future\n    function addSequencerL2BatchFromOrigin(\n        uint256,\n        bytes calldata,\n        uint256,\n        IGasRefunder\n    ) external pure {\n        revert Deprecated();\n    }\n\n    function addSequencerL2BatchFromOrigin(\n        uint256 sequenceNumber,\n        bytes calldata data,\n        uint256 afterDelayedMessagesRead,\n        IGasRefunder gasRefunder,\n        uint256 prevMessageCount,\n        uint256 newMessageCount\n    ) external refundsGas(gasRefunder, IReader4844(address(0))) {\n        // solhint-disable-next-line avoid-tx-origin\n        if (msg.sender != tx.origin) revert NotOrigin();\n        if (!isBatchPoster[msg.sender]) revert NotBatchPoster();\n        (bytes32 dataHash, IBridge.TimeBounds memory timeBounds) = formCallDataHash(\n            data,\n            afterDelayedMessagesRead\n        );\n        // Reformat the stack to prevent \"Stack too deep\"\n        uint256 sequenceNumber_ = sequenceNumber;\n        IBridge.TimeBounds memory timeBounds_ = timeBounds;\n        bytes32 dataHash_ = dataHash;\n        uint256 dataLength = data.length;\n        uint256 afterDelayedMessagesRead_ = afterDelayedMessagesRead;\n        uint256 prevMessageCount_ = prevMessageCount;\n        uint256 newMessageCount_ = newMessageCount;\n        (\n            uint256 seqMessageIndex,\n            bytes32 beforeAcc,\n            bytes32 delayedAcc,\n            bytes32 afterAcc\n        ) = addSequencerL2BatchImpl(\n                dataHash_,\n                afterDelayedMessagesRead_,\n                dataLength,\n                prevMessageCount_,\n                newMessageCount_\n            );\n\n        // ~uint256(0) is type(uint256).max, but ever so slightly cheaper\n        if (seqMessageIndex != sequenceNumber_ && sequenceNumber_ != ~uint256(0)) {\n            revert BadSequencerNumber(seqMessageIndex, sequenceNumber_);\n        }\n\n        emit SequencerBatchDelivered(\n            seqMessageIndex,\n            beforeAcc,\n            afterAcc,\n            delayedAcc,\n            totalDelayedMessagesRead,\n            timeBounds_,\n            IBridge.BatchDataLocation.TxInput\n        );\n    }\n\n    function addSequencerL2BatchFromBlobs(\n        uint256 sequenceNumber,\n        uint256 afterDelayedMessagesRead,\n        IGasRefunder gasRefunder,\n        uint256 prevMessageCount,\n        uint256 newMessageCount\n    ) external refundsGas(gasRefunder, reader4844) {\n        if (!isBatchPoster[msg.sender]) revert NotBatchPoster();\n        (\n            bytes32 dataHash,\n            IBridge.TimeBounds memory timeBounds,\n            uint256 blobGas\n        ) = formBlobDataHash(afterDelayedMessagesRead);\n\n        // we use addSequencerL2BatchImpl for submitting the message\n        // normally this would also submit a batch spending report but that is skipped if we pass\n        // an empty call data size, then we submit a separate batch spending report later\n        (\n            uint256 seqMessageIndex,\n            bytes32 beforeAcc,\n            bytes32 delayedAcc,\n            bytes32 afterAcc\n        ) = addSequencerL2BatchImpl(\n                dataHash,\n                afterDelayedMessagesRead,\n                0,\n                prevMessageCount,\n                newMessageCount\n            );\n\n        uint256 _sequenceNumber = sequenceNumber; // stack workaround\n\n        // ~uint256(0) is type(uint256).max, but ever so slightly cheaper\n        if (seqMessageIndex != _sequenceNumber && _sequenceNumber != ~uint256(0)) {\n            revert BadSequencerNumber(seqMessageIndex, _sequenceNumber);\n        }\n\n        emit SequencerBatchDelivered(\n            _sequenceNumber,\n            beforeAcc,\n            afterAcc,\n            delayedAcc,\n            totalDelayedMessagesRead,\n            timeBounds,\n            IBridge.BatchDataLocation.Blob\n        );\n\n        // blobs are currently not supported on host arbitrum chains, when support is added it may\n        // consume gas in a different way to L1, so explicitly block host arb chains so that if support for blobs\n        // on arb is added it will need to explicitly turned on in the sequencer inbox\n        if (hostChainIsArbitrum) revert DataBlobsNotSupported();\n\n        // submit a batch spending report to refund the entity that produced the blob batch data\n        // same as using calldata, we only submit spending report if the caller is the origin of the tx\n        // such that one cannot \"double-claim\" batch posting refund in the same tx\n        // solhint-disable-next-line avoid-tx-origin\n        if (msg.sender == tx.origin && !isUsingFeeToken) {\n            submitBatchSpendingReport(dataHash, seqMessageIndex, block.basefee, blobGas);\n        }\n    }\n\n    function addSequencerL2Batch(\n        uint256 sequenceNumber,\n        bytes calldata data,\n        uint256 afterDelayedMessagesRead,\n        IGasRefunder gasRefunder,\n        uint256 prevMessageCount,\n        uint256 newMessageCount\n    ) external override refundsGas(gasRefunder, IReader4844(address(0))) {\n        if (!isBatchPoster[msg.sender] && msg.sender != address(rollup)) revert NotBatchPoster();\n        (bytes32 dataHash, IBridge.TimeBounds memory timeBounds) = formCallDataHash(\n            data,\n            afterDelayedMessagesRead\n        );\n        uint256 seqMessageIndex;\n        {\n            // Reformat the stack to prevent \"Stack too deep\"\n            uint256 sequenceNumber_ = sequenceNumber;\n            IBridge.TimeBounds memory timeBounds_ = timeBounds;\n            bytes32 dataHash_ = dataHash;\n            uint256 afterDelayedMessagesRead_ = afterDelayedMessagesRead;\n            uint256 prevMessageCount_ = prevMessageCount;\n            uint256 newMessageCount_ = newMessageCount;\n            // we set the calldata length posted to 0 here since the caller isn't the origin\n            // of the tx, so they might have not paid tx input cost for the calldata\n            bytes32 beforeAcc;\n            bytes32 delayedAcc;\n            bytes32 afterAcc;\n            (seqMessageIndex, beforeAcc, delayedAcc, afterAcc) = addSequencerL2BatchImpl(\n                dataHash_,\n                afterDelayedMessagesRead_,\n                0,\n                prevMessageCount_,\n                newMessageCount_\n            );\n\n            // ~uint256(0) is type(uint256).max, but ever so slightly cheaper\n            if (seqMessageIndex != sequenceNumber_ && sequenceNumber_ != ~uint256(0)) {\n                revert BadSequencerNumber(seqMessageIndex, sequenceNumber_);\n            }\n\n            emit SequencerBatchDelivered(\n                seqMessageIndex,\n                beforeAcc,\n                afterAcc,\n                delayedAcc,\n                totalDelayedMessagesRead,\n                timeBounds_,\n                IBridge.BatchDataLocation.SeparateBatchEvent\n            );\n        }\n        emit SequencerBatchData(seqMessageIndex, data);\n    }\n\n    function packHeader(\n        uint256 afterDelayedMessagesRead\n    ) internal view returns (bytes memory, IBridge.TimeBounds memory) {\n        IBridge.TimeBounds memory timeBounds = getTimeBounds();\n        bytes memory header = abi.encodePacked(\n            timeBounds.minTimestamp,\n            timeBounds.maxTimestamp,\n            timeBounds.minBlockNumber,\n            timeBounds.maxBlockNumber,\n            uint64(afterDelayedMessagesRead)\n        );\n        // This must always be true from the packed encoding\n        assert(header.length == HEADER_LENGTH);\n        return (header, timeBounds);\n    }\n\n    /// @dev    Form a hash for a sequencer message with no batch data\n    /// @param  afterDelayedMessagesRead The delayed messages count read up to\n    /// @return The data hash\n    /// @return The timebounds within which the message should be processed\n    function formEmptyDataHash(\n        uint256 afterDelayedMessagesRead\n    ) internal view returns (bytes32, IBridge.TimeBounds memory) {\n        (bytes memory header, IBridge.TimeBounds memory timeBounds) = packHeader(\n            afterDelayedMessagesRead\n        );\n        return (keccak256(header), timeBounds);\n    }\n\n    /// @dev    Since the data is supplied from calldata, the batch poster can choose the data type\n    ///         We need to ensure that this data cannot cause a collision with data supplied via another method (eg blobs)\n    ///         therefore we restrict which flags can be provided as a header in this field\n    ///         This also safe guards unused flags for future use, as we know they would have been disallowed up until this point\n    /// @param  headerByte The first byte in the calldata\n    function isValidCallDataFlag(bytes1 headerByte) internal pure returns (bool) {\n        return\n            headerByte == BROTLI_MESSAGE_HEADER_FLAG ||\n            headerByte == DAS_MESSAGE_HEADER_FLAG ||\n            headerByte == CELESTIA_MESSAGE_HEADER_FLAG ||\n            (headerByte == (DAS_MESSAGE_HEADER_FLAG | TREE_DAS_MESSAGE_HEADER_FLAG)) ||\n            headerByte == ZERO_HEAVY_MESSAGE_HEADER_FLAG;\n    }\n\n    /// @dev    Form a hash of the data taken from the calldata\n    /// @param  data The calldata to be hashed\n    /// @param  afterDelayedMessagesRead The delayed messages count read up to\n    /// @return The data hash\n    /// @return The timebounds within which the message should be processed\n    function formCallDataHash(\n        bytes calldata data,\n        uint256 afterDelayedMessagesRead\n    ) internal view returns (bytes32, IBridge.TimeBounds memory) {\n        uint256 fullDataLen = HEADER_LENGTH + data.length;\n        if (fullDataLen > maxDataSize) revert DataTooLarge(fullDataLen, maxDataSize);\n\n        (bytes memory header, IBridge.TimeBounds memory timeBounds) = packHeader(\n            afterDelayedMessagesRead\n        );\n\n        // the batch poster is allowed to submit an empty batch, they can use this to progress the\n        // delayed inbox without providing extra batch data\n        if (data.length > 0) {\n            // The first data byte cannot be the same as any that have been set via other methods (eg 4844 blob header) as this\n            // would allow the supplier of the data to spoof an incorrect 4844 data batch\n            if (!isValidCallDataFlag(data[0])) revert InvalidHeaderFlag(data[0]);\n\n            // the first byte is used to identify the type of batch data\n            // das batches expect to have the type byte set, followed by the keyset (so they should have at least 33 bytes)\n            // if invalid data is supplied here the state transition function will process it as an empty block\n            // however we can provide a nice additional check here for the batch poster\n            if (data[0] & DAS_MESSAGE_HEADER_FLAG != 0 && data.length >= 33) {\n                // we skip the first byte, then read the next 32 bytes for the keyset\n                bytes32 dasKeysetHash = bytes32(data[1:33]);\n                if (!dasKeySetInfo[dasKeysetHash].isValidKeyset) revert NoSuchKeyset(dasKeysetHash);\n            }\n\n            if (data[0] & CELESTIA_MESSAGE_HEADER_FLAG != 0 && data.length != 89) {\n                revert InvalidCelestiaBatch();\n            }\n        }\n        return (keccak256(bytes.concat(header, data)), timeBounds);\n    }\n\n    /// @dev    Form a hash of the data being provided in 4844 data blobs\n    /// @param  afterDelayedMessagesRead The delayed messages count read up to\n    /// @return The data hash\n    /// @return The timebounds within which the message should be processed\n    /// @return The normalized amount of gas used for blob posting\n    function formBlobDataHash(\n        uint256 afterDelayedMessagesRead\n    ) internal view returns (bytes32, IBridge.TimeBounds memory, uint256) {\n        bytes32[] memory dataHashes = reader4844.getDataHashes();\n        if (dataHashes.length == 0) revert MissingDataHashes();\n\n        (bytes memory header, IBridge.TimeBounds memory timeBounds) = packHeader(\n            afterDelayedMessagesRead\n        );\n\n        uint256 blobCost = reader4844.getBlobBaseFee() * GAS_PER_BLOB * dataHashes.length;\n        return (\n            keccak256(bytes.concat(header, DATA_BLOB_HEADER_FLAG, abi.encodePacked(dataHashes))),\n            timeBounds,\n            block.basefee > 0 ? blobCost / block.basefee : 0\n        );\n    }\n\n    /// @dev   Submit a batch spending report message so that the batch poster can be reimbursed on the rollup\n    ///        This function expect msg.sender is tx.origin, and will always record tx.origin as the spender\n    /// @param dataHash The hash of the message the spending report is being submitted for\n    /// @param seqMessageIndex The index of the message to submit the spending report for\n    /// @param gasPrice The gas price that was paid for the data (standard gas or data gas)\n    function submitBatchSpendingReport(\n        bytes32 dataHash,\n        uint256 seqMessageIndex,\n        uint256 gasPrice,\n        uint256 extraGas\n    ) internal {\n        // report the account who paid the gas (tx.origin) for the tx as batch poster\n        // if msg.sender is used and is a contract, it might not be able to spend the refund on l2\n        // solhint-disable-next-line avoid-tx-origin\n        address batchPoster = tx.origin;\n\n        // this msg isn't included in the current sequencer batch, but instead added to\n        // the delayed messages queue that is yet to be included\n        if (hostChainIsArbitrum) {\n            // Include extra gas for the host chain's L1 gas charging\n            uint256 l1Fees = ArbGasInfo(address(0x6c)).getCurrentTxL1GasFees();\n            extraGas += l1Fees / block.basefee;\n        }\n        require(extraGas <= type(uint64).max, \"EXTRA_GAS_NOT_UINT64\");\n        bytes memory spendingReportMsg = abi.encodePacked(\n            block.timestamp,\n            batchPoster,\n            dataHash,\n            seqMessageIndex,\n            gasPrice,\n            uint64(extraGas)\n        );\n\n        uint256 msgNum = bridge.submitBatchSpendingReport(\n            batchPoster,\n            keccak256(spendingReportMsg)\n        );\n        // this is the same event used by Inbox.sol after including a message to the delayed message accumulator\n        emit InboxMessageDelivered(msgNum, spendingReportMsg);\n    }\n\n    function addSequencerL2BatchImpl(\n        bytes32 dataHash,\n        uint256 afterDelayedMessagesRead,\n        uint256 calldataLengthPosted,\n        uint256 prevMessageCount,\n        uint256 newMessageCount\n    )\n        internal\n        returns (uint256 seqMessageIndex, bytes32 beforeAcc, bytes32 delayedAcc, bytes32 acc)\n    {\n        if (afterDelayedMessagesRead < totalDelayedMessagesRead) revert DelayedBackwards();\n        if (afterDelayedMessagesRead > bridge.delayedMessageCount()) revert DelayedTooFar();\n\n        (seqMessageIndex, beforeAcc, delayedAcc, acc) = bridge.enqueueSequencerMessage(\n            dataHash,\n            afterDelayedMessagesRead,\n            prevMessageCount,\n            newMessageCount\n        );\n\n        totalDelayedMessagesRead = afterDelayedMessagesRead;\n\n        if (calldataLengthPosted > 0 && !isUsingFeeToken) {\n            // only report batch poster spendings if chain is using ETH as native currency\n            submitBatchSpendingReport(dataHash, seqMessageIndex, block.basefee, 0);\n        }\n    }\n\n    function inboxAccs(uint256 index) external view returns (bytes32) {\n        return bridge.sequencerInboxAccs(index);\n    }\n\n    function batchCount() external view returns (uint256) {\n        return bridge.sequencerMessageCount();\n    }\n\n    function _setMaxTimeVariation(\n        ISequencerInbox.MaxTimeVariation memory maxTimeVariation_\n    ) internal {\n        if (\n            maxTimeVariation_.delayBlocks > type(uint64).max ||\n            maxTimeVariation_.futureBlocks > type(uint64).max ||\n            maxTimeVariation_.delaySeconds > type(uint64).max ||\n            maxTimeVariation_.futureSeconds > type(uint64).max\n        ) {\n            revert BadMaxTimeVariation();\n        }\n        delayBlocks = uint64(maxTimeVariation_.delayBlocks);\n        futureBlocks = uint64(maxTimeVariation_.futureBlocks);\n        delaySeconds = uint64(maxTimeVariation_.delaySeconds);\n        futureSeconds = uint64(maxTimeVariation_.futureSeconds);\n    }\n\n    /// @inheritdoc ISequencerInbox\n    function setMaxTimeVariation(\n        ISequencerInbox.MaxTimeVariation memory maxTimeVariation_\n    ) external onlyRollupOwner {\n        _setMaxTimeVariation(maxTimeVariation_);\n        emit OwnerFunctionCalled(0);\n    }\n\n    /// @inheritdoc ISequencerInbox\n    function setIsBatchPoster(\n        address addr,\n        bool isBatchPoster_\n    ) external onlyRollupOwnerOrBatchPosterManager {\n        isBatchPoster[addr] = isBatchPoster_;\n        emit OwnerFunctionCalled(1);\n    }\n\n    /// @inheritdoc ISequencerInbox\n    function setValidKeyset(bytes calldata keysetBytes) external onlyRollupOwner {\n        uint256 ksWord = uint256(keccak256(bytes.concat(hex\"fe\", keccak256(keysetBytes))));\n        bytes32 ksHash = bytes32(ksWord ^ (1 << 255));\n        require(keysetBytes.length < 64 * 1024, \"keyset is too large\");\n\n        if (dasKeySetInfo[ksHash].isValidKeyset) revert AlreadyValidDASKeyset(ksHash);\n        uint256 creationBlock = block.number;\n        if (hostChainIsArbitrum) {\n            creationBlock = ArbSys(address(100)).arbBlockNumber();\n        }\n        dasKeySetInfo[ksHash] = DasKeySetInfo({\n            isValidKeyset: true,\n            creationBlock: uint64(creationBlock)\n        });\n        emit SetValidKeyset(ksHash, keysetBytes);\n        emit OwnerFunctionCalled(2);\n    }\n\n    /// @inheritdoc ISequencerInbox\n    function invalidateKeysetHash(bytes32 ksHash) external onlyRollupOwner {\n        if (!dasKeySetInfo[ksHash].isValidKeyset) revert NoSuchKeyset(ksHash);\n        // we don't delete the block creation value since its used to fetch the SetValidKeyset\n        // event efficiently. The event provides the hash preimage of the key.\n        // this is still needed when syncing the chain after a keyset is invalidated.\n        dasKeySetInfo[ksHash].isValidKeyset = false;\n        emit InvalidateKeyset(ksHash);\n        emit OwnerFunctionCalled(3);\n    }\n\n    /// @inheritdoc ISequencerInbox\n    function setIsSequencer(\n        address addr,\n        bool isSequencer_\n    ) external onlyRollupOwnerOrBatchPosterManager {\n        isSequencer[addr] = isSequencer_;\n        emit OwnerFunctionCalled(4); // Owner in this context can also be batch poster manager\n    }\n\n    /// @inheritdoc ISequencerInbox\n    function setBatchPosterManager(address newBatchPosterManager) external onlyRollupOwner {\n        batchPosterManager = newBatchPosterManager;\n        emit OwnerFunctionCalled(5);\n    }\n\n    function isValidKeysetHash(bytes32 ksHash) external view returns (bool) {\n        return dasKeySetInfo[ksHash].isValidKeyset;\n    }\n\n    /// @inheritdoc ISequencerInbox\n    function getKeysetCreationBlock(bytes32 ksHash) external view returns (uint256) {\n        DasKeySetInfo memory ksInfo = dasKeySetInfo[ksHash];\n        if (ksInfo.creationBlock == 0) revert NoSuchKeyset(ksHash);\n        return uint256(ksInfo.creationBlock);\n    }\n}\n"}, "src/celestia/BlobstreamVerifier.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\nimport {IBlobstreamX} from \"./IBlobstreamX.sol\";\n\nimport \"./DAVerifier.sol\";\nimport \"./lib/Constants.sol\";\nimport \"./lib/DataRootTuple.sol\";\nimport \"./lib/tree/binary/BinaryMerkleProof.sol\";\nimport \"./lib/tree/binary/BinaryMerkleTree.sol\";\nimport \"./lib/tree/namespace/NamespaceMerkleTree.sol\";\nimport \"./lib/tree/Types.sol\";\n\n/**\n * @dev Go struct representation of batch data for a Celestia DA orbit chain\n *\n * @param BlockHeight The height of the block containing the blob.\n * @param Start The starting index of the blob within the block.\n * @param SharesLength The length of the shares in the blob.\n * @param DataRoot A 32-byte hash representing the root of the data.\n * @param TxCommitment A 32-byte hash representing the commitment to transactions.\n */\n// struct BlobPointer {\n//     uint64 BlockHeight;\n//     uint64 Start;\n//     uint64 SharesLength;\n//     bytes32 DataRoot;\n//     bytes32 TxCommitment;\n// }\n\n/// @title CelestiaBatchVerifier: Utility library to verify Nitro batches against Blobstream\n/// @dev The CelestiaBatchVerifier verifies batch data against Blobstream and returns either:\n/// - IN_BLOBSTREAM, meaning that the batch was found in Blobstream.\n/// - COUNTERFACTUAL_COMMITMENT, meaning that the commitment's Celestia block height has been\n/// proven in Blobstream not to contain the commitment\n/// - UNDECIDED meaning that the block height has not been proven yet in Blobstream\n/// If the proof data is invalid, it reverts\nlibrary CelestiaBatchVerifier {\n    /// @dev The heights in the batch data and proof do not match\n    error MismatchedHeights();\n\n    /// @dev The attestation and or row root proof was invalid\n    error InvalidProof();\n\n    /// @title Result\n    /// @notice Enumerates the possible outcomes for data verification processes.\n    /// @dev Provides a standardized way to represent the verification status of data.\n    enum Result {\n        /// @dev Indicates the data has been verified to exist within Blobstream.\n        IN_BLOBSTREAM,\n        /// @dev Represents a situation where the batch data has been proven to be incorrect. Or BlobstreamX was frozen\n        COUNTERFACTUAL_COMMITMENT,\n        /// @dev The height for the batch data has not been committed to by Blobstream yet.\n        UNDECIDED\n    }\n\n    /**\n     * @notice Given some batch data with the structre of `BlobPointer`, verifyBatch validates:\n     * 1. The Celestia Height for the batch data is in blobsream.\n     * 2. The user supplied proof's data root exists in Blobstream.\n     * 2. The the data root from the batch data and the valid user supplied proof match, and the\n     *    span of shares for the batch data is available (i.e the start + length of a blob does not\n     *    go outside the bounds of the origianal celestia data square for the given height)\n     *\n     * Rationale:\n     * Validators possess the preimages for the data root and row roots, making it necessary only to verify\n     * the existence and the length (span) of the index and blob length.\n     * This ensures the data published by the batch poster is available.\n     */\n    function verifyBatch(address _blobstream, bytes calldata _data) internal view returns (Result) {\n        IBlobstreamX blobstreamX = IBlobstreamX(_blobstream);\n\n        uint64 height = uint64(bytes8(_data[0:8]));\n\n        // If the height is to far into the future (1000 blocks), return COUNTERFACTUAL_COMMITMENT\n        // because the batch poster is trying to stall\n        if (height > (blobstreamX.latestBlock() + 1000)) return Result.COUNTERFACTUAL_COMMITMENT;\n\n        // Otherwise return undecided, as the commitment still needs to be relayed to Blobstream\n        if (height > blobstreamX.latestBlock()) return Result.UNDECIDED;\n\n        (\n            ,\n            NamespaceNode memory namespaceNode,\n            BinaryMerkleProof memory proof,\n            AttestationProof memory attestationProof\n        ) = abi.decode(_data[88:], (address, NamespaceNode, BinaryMerkleProof, AttestationProof));\n\n        (\n            bool valid,\n            uint256 proofHeight,\n            bytes32 proofDataRoot,\n            BinaryMerkleProof memory rowProof\n        ) = verifyProof(_blobstream, namespaceNode, proof, attestationProof);\n\n        // revert, because for a given height that has been confirmed to exist in Blobstream,\n        // there has to be a valid proof\n        // if (!valid) revert InvalidProof();\n        if (!valid) revert(\"INVALID_PROOF\");\n        // check height against the one in the batch data, if they do not match,\n        // revert, because the user supplied proof does not verify against\n        // the batch's celestia height.\n        // if (height != proofHeight) revert MismatchedHeights();\n        if (height != proofHeight) revert(\"MismatchedHeights\");\n\n        // check the data root in the proof against the one in the batch data.\n        // if they do not match, its a counterfactual commitment, because\n        // 1. the user supplied proof proves the height was relayed to Blobstream\n        //    (we know the height is valid because it's less than or equal to the latest block)\n        // 2. the data root from the batch data does not exist at the height the batch poster claimed\n        //    to have posted to.\n        // NOTE: a celestia batch has the data root (32 bytes) at index 56\n        if (bytes32(_data[56:88]) != proofDataRoot) return Result.COUNTERFACTUAL_COMMITMENT;\n\n        // Calculate size of the Original Data Square (ODS)\n        (uint256 squareSize, ) = DAVerifier.computeSquareSizeFromRowProof(rowProof);\n\n        if (squareSize == 0) return Result.COUNTERFACTUAL_COMMITMENT;\n        // Check that the start + length posted by the batch poster is not out of bounds\n        // otherwise return counterfactual commitment\n        // NOTE: a celestia batch has the start (8 bytes) and length (8 bytes) at index 8 - 24\n        // we also substract 1 to account for the shares length including the start share\n        // thus letting us correctly calculate the end index\n        if (\n            (uint64(bytes8(_data[8:16])) + uint64(bytes8(_data[16:24])) - 1) >=\n            squareSize * squareSize\n        ) return Result.COUNTERFACTUAL_COMMITMENT;\n\n        // At this point, there has been:\n        // 1. A succesfull proof that shows the height and data root the batch poster included\n        //    in the batch data exist in Blobstream.\n        // 2. A proof that the sequence the batch poster included in the batch data is inside\n        //    of the data square (remember, any valid row root proof can show this is true)\n        // 3. No deadlocks or incorrect counter factual commitments have been made, since:\n        //    - If the height in the batch is less than the latest height in blobstrea,\n        //      a valid attestation + row proof must exist for it\n        //    - we have shown that the batch poster did not lie about the data root and height,\n        //      nor about the span being in the bounds of the square. Thus, validators have\n        //      access to the data through the preimage oracle\n        return Result.IN_BLOBSTREAM;\n    }\n\n    function verifyProof(\n        address _blobstream,\n        NamespaceNode memory _rowRoot,\n        BinaryMerkleProof memory _rowProof,\n        AttestationProof memory _attestationProof\n    )\n        public\n        view\n        returns (\n            bool isValid,\n            uint256 proofHeight,\n            bytes32 proofDataRoot,\n            BinaryMerkleProof memory rowProof\n        )\n    {\n        (bool valid, DAVerifier.ErrorCodes errorCode) = DAVerifier.verifyRowRootToDataRootTupleRoot(\n            IDAOracle(_blobstream),\n            _rowRoot,\n            _rowProof,\n            _attestationProof\n        );\n\n        return (valid, _attestationProof.tuple.height, _attestationProof.tuple.dataRoot, _rowProof);\n    }\n}\n"}, "src/celestia/DAVerifier.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\nimport \"./lib/Constants.sol\";\nimport \"./lib/DataRootTuple.sol\";\nimport \"./lib/IDAOracle.sol\";\nimport \"./lib/tree/binary/BinaryMerkleProof.sol\";\nimport \"./lib/tree/binary/BinaryMerkleTree.sol\";\nimport \"./lib/tree/namespace/NamespaceMerkleTree.sol\";\nimport \"./lib/tree/Types.sol\";\n\n/// @notice Contains the necessary parameters to prove that some shares, which were posted to\n/// the Celestia network, were committed to by the Blobstream smart contract.\nstruct SharesProof {\n    // The shares that were committed to.\n    bytes[] data;\n    // The shares proof to the row roots. If the shares span multiple rows, we will have multiple nmt proofs.\n    NamespaceMerkleMultiproof[] shareProofs;\n    // The namespace of the shares.\n    Namespace namespace;\n    // The rows where the shares belong. If the shares span multiple rows, we will have multiple rows.\n    NamespaceNode[] rowRoots;\n    // The proofs of the rowRoots to the data root.\n    BinaryMerkleProof[] rowProofs;\n    // The proof of the data root tuple to the data root tuple root that was posted to the Blobstream contract.\n    AttestationProof attestationProof;\n}\n\n/// @notice Contains the necessary parameters needed to verify that a data root tuple\n/// was committed to, by the Blobstream smart contract, at some specif nonce.\nstruct AttestationProof {\n    // the attestation nonce that commits to the data root tuple.\n    uint256 tupleRootNonce;\n    // the data root tuple that was committed to.\n    DataRootTuple tuple;\n    // the binary merkle proof of the tuple to the commitment.\n    BinaryMerkleProof proof;\n}\n\n/// @title DAVerifier: Celestia -> EVM, Data Availability verifier.\n/// @dev The DAVerifier verifies that some shares, which were posted on Celestia, were committed to\n/// by the Blobstream smart contract.\nlibrary DAVerifier {\n    /////////////////\n    // Error codes //\n    /////////////////\n\n    enum ErrorCodes {\n        NoError,\n        /// @notice The shares to the rows proof is invalid.\n        InvalidSharesToRowsProof,\n        /// @notice The rows to the data root proof is invalid.\n        InvalidRowsToDataRootProof,\n        /// @notice The row to the data root proof is invalid.\n        InvalidRowToDataRootProof,\n        /// @notice The data root tuple to the data root tuple roof proof is invalid.\n        InvalidDataRootTupleToDataRootTupleRootProof,\n        /// @notice The number of share proofs isn't equal to the number of rows roots.\n        UnequalShareProofsAndRowRootsNumber,\n        /// @notice The number of rows proofs isn't equal to the number of rows roots.\n        UnequalRowProofsAndRowRootsNumber,\n        /// @notice The verifier data length isn't equal to the number of shares in the shares proofs.\n        UnequalDataLengthAndNumberOfSharesProofs,\n        /// @notice The number of leaves in the binary merkle proof is not divisible by 4.\n        InvalidNumberOfLeavesInProof,\n        /// @notice The provided range is invalid.\n        InvalidRange,\n        /// @notice The provided range is out of bounds.\n        OutOfBoundsRange\n    }\n\n    ///////////////\n    // Functions //\n    ///////////////\n\n    /// @notice Verifies that the shares, which were posted to Celestia, were committed to by the Blobstream smart contract.\n    /// @param _bridge The Blobstream smart contract instance.\n    /// @param _sharesProof The proof of the shares to the data root tuple root.\n    /// @return `true` if the proof is valid, `false` otherwise.\n    /// @return an error code if the proof is invalid, ErrorCodes.NoError otherwise.\n    function verifySharesToDataRootTupleRoot(\n        IDAOracle _bridge,\n        SharesProof memory _sharesProof\n    ) internal view returns (bool, ErrorCodes) {\n        // checking that the data root was committed to by the Blobstream smart contract.\n        (bool success, ErrorCodes errorCode) = verifyMultiRowRootsToDataRootTupleRoot(\n            _bridge,\n            _sharesProof.rowRoots,\n            _sharesProof.rowProofs,\n            _sharesProof.attestationProof\n        );\n        if (!success) {\n            return (false, errorCode);\n        }\n\n        (bool valid, ErrorCodes error) = verifySharesToDataRootTupleRootProof(\n            _sharesProof.data,\n            _sharesProof.shareProofs,\n            _sharesProof.namespace,\n            _sharesProof.rowRoots,\n            _sharesProof.rowProofs,\n            _sharesProof.attestationProof.tuple.dataRoot\n        );\n\n        return (valid, error);\n    }\n\n    /// @notice Verifies the shares to data root tuple root proof.\n    /// NOTE: This doesn't authenticate the proof to Blobstream. It only verifies if the proof is valid.\n    /// @param _data The data that needs to proven.\n    /// @param _shareProofs The share to the row roots proof.\n    /// @param _namespace The namespace of the shares.\n    /// @param _rowRoots The row roots where the shares belong.\n    /// @param _rowProofs The proofs of the rowRoots to the data root.\n    /// @param _root The data root of the block that contains the shares.\n    /// @return `true` if the proof is valid, `false` otherwise.\n    /// @return an error code if the proof is invalid, ErrorCodes.NoError otherwise.\n    function verifySharesToDataRootTupleRootProof(\n        bytes[] memory _data,\n        NamespaceMerkleMultiproof[] memory _shareProofs,\n        Namespace memory _namespace,\n        NamespaceNode[] memory _rowRoots,\n        BinaryMerkleProof[] memory _rowProofs,\n        bytes32 _root\n    ) internal pure returns (bool, ErrorCodes) {\n        // verifying the row root to data root tuple root proof.\n        (bool success, ErrorCodes errorCode) = verifyMultiRowRootsToDataRootTupleRootProof(\n            _rowRoots,\n            _rowProofs,\n            _root\n        );\n        if (!success) {\n            return (false, errorCode);\n        }\n\n        // checking that the shares were committed to by the rows roots.\n        if (_shareProofs.length != _rowRoots.length) {\n            return (false, ErrorCodes.UnequalShareProofsAndRowRootsNumber);\n        }\n\n        uint256 numberOfSharesInProofs = 0;\n        for (uint256 i = 0; i < _shareProofs.length; i++) {\n            numberOfSharesInProofs += _shareProofs[i].endKey - _shareProofs[i].beginKey;\n        }\n\n        if (_data.length != numberOfSharesInProofs) {\n            return (false, ErrorCodes.UnequalDataLengthAndNumberOfSharesProofs);\n        }\n\n        uint256 cursor = 0;\n        for (uint256 i = 0; i < _shareProofs.length; i++) {\n            uint256 sharesUsed = _shareProofs[i].endKey - _shareProofs[i].beginKey;\n            (bytes[] memory s, ErrorCodes err) = slice(_data, cursor, cursor + sharesUsed);\n            if (err != ErrorCodes.NoError) {\n                return (false, err);\n            }\n            if (!NamespaceMerkleTree.verifyMulti(_rowRoots[i], _shareProofs[i], _namespace, s)) {\n                return (false, ErrorCodes.InvalidSharesToRowsProof);\n            }\n            cursor += sharesUsed;\n        }\n\n        return (true, ErrorCodes.NoError);\n    }\n\n    /// @notice Verifies that a row/column root, from a Celestia block, was committed to by the Blobstream smart contract.\n    /// @param _bridge The Blobstream smart contract instance.\n    /// @param _rowRoot The row/column root to be proven.\n    /// @param _rowProof The proof of the row/column root to the data root.\n    /// @return `true` if the proof is valid, `false` otherwise.\n    /// @return an error code if the proof is invalid, ErrorCodes.NoError otherwise.\n    function verifyRowRootToDataRootTupleRoot(\n        IDAOracle _bridge,\n        NamespaceNode memory _rowRoot,\n        BinaryMerkleProof memory _rowProof,\n        AttestationProof memory _attestationProof\n    ) internal view returns (bool, ErrorCodes) {\n        // checking that the data root was committed to by the Blobstream smart contract\n        if (\n            !_bridge.verifyAttestation(\n                _attestationProof.tupleRootNonce,\n                _attestationProof.tuple,\n                _attestationProof.proof\n            )\n        ) {\n            return (false, ErrorCodes.InvalidDataRootTupleToDataRootTupleRootProof);\n        }\n\n        (bool valid, ErrorCodes error) = verifyRowRootToDataRootTupleRootProof(\n            _rowRoot,\n            _rowProof,\n            _attestationProof.tuple.dataRoot\n        );\n\n        return (valid, error);\n    }\n\n    /// @notice Verifies that a row/column root proof, from a Celestia block, to the data root tuple root.\n    /// NOTE: This doesn't authenticate the proof to Blobstream. It only verifies if the proof is valid.\n    /// @param _rowRoot The row/column root to be proven.\n    /// @param _rowProof The proof of the row/column root to the data root.\n    /// @param _root The data root of the block that contains the row.\n    /// @return `true` if the proof is valid, `false` otherwise.\n    /// @return an error code if the proof is invalid, ErrorCodes.NoError otherwise.\n    function verifyRowRootToDataRootTupleRootProof(\n        NamespaceNode memory _rowRoot,\n        BinaryMerkleProof memory _rowProof,\n        bytes32 _root\n    ) internal pure returns (bool, ErrorCodes) {\n        bytes memory rowRoot = abi.encodePacked(\n            _rowRoot.min.toBytes(),\n            _rowRoot.max.toBytes(),\n            _rowRoot.digest\n        );\n        (bool valid, ) = BinaryMerkleTree.verify(_root, _rowProof, rowRoot);\n        if (!valid) {\n            return (false, ErrorCodes.InvalidRowToDataRootProof);\n        }\n\n        return (true, ErrorCodes.NoError);\n    }\n\n    /// @notice Verifies that a set of rows/columns, from a Celestia block, were committed to by the Blobstream smart contract.\n    /// @param _bridge The Blobstream smart contract instance.\n    /// @param _rowRoots The set of row/column roots to be proved.\n    /// @param _rowProofs The set of proofs of the _rowRoots in the same order.\n    /// @return `true` if the proof is valid, `false` otherwise.\n    /// @return an error code if the proof is invalid, ErrorCodes.NoError otherwise.\n    function verifyMultiRowRootsToDataRootTupleRoot(\n        IDAOracle _bridge,\n        NamespaceNode[] memory _rowRoots,\n        BinaryMerkleProof[] memory _rowProofs,\n        AttestationProof memory _attestationProof\n    ) internal view returns (bool, ErrorCodes) {\n        // checking that the data root was committed to by the Blobstream smart contract\n        if (\n            !_bridge.verifyAttestation(\n                _attestationProof.tupleRootNonce,\n                _attestationProof.tuple,\n                _attestationProof.proof\n            )\n        ) {\n            return (false, ErrorCodes.InvalidDataRootTupleToDataRootTupleRootProof);\n        }\n\n        // checking that the rows roots commit to the data root.\n        (bool valid, ErrorCodes error) = verifyMultiRowRootsToDataRootTupleRootProof(\n            _rowRoots,\n            _rowProofs,\n            _attestationProof.tuple.dataRoot\n        );\n\n        return (valid, error);\n    }\n\n    /// @notice Verifies the proof a set of rows/columns, from a Celestia block, to their corresponding data root.\n    /// NOTE: This doesn't authenticate the proof to Blobstream. It only verifies if the proof is valid.\n    /// @param _rowRoots The set of row/column roots to be proved.\n    /// @param _rowProofs The set of proofs of the _rowRoots in the same order.\n    /// @param _root The data root of the block that contains the rows.\n    /// @return `true` if the proof is valid, `false` otherwise.\n    /// @return an error code if the proof is invalid, ErrorCodes.NoError otherwise.\n    function verifyMultiRowRootsToDataRootTupleRootProof(\n        NamespaceNode[] memory _rowRoots,\n        BinaryMerkleProof[] memory _rowProofs,\n        bytes32 _root\n    ) internal pure returns (bool, ErrorCodes) {\n        // checking that the rows roots commit to the data root.\n        if (_rowProofs.length != _rowRoots.length) {\n            return (false, ErrorCodes.UnequalRowProofsAndRowRootsNumber);\n        }\n\n        for (uint256 i = 0; i < _rowProofs.length; i++) {\n            bytes memory rowRoot = abi.encodePacked(\n                _rowRoots[i].min.toBytes(),\n                _rowRoots[i].max.toBytes(),\n                _rowRoots[i].digest\n            );\n            (bool valid, ) = BinaryMerkleTree.verify(_root, _rowProofs[i], rowRoot);\n            if (!valid) {\n                return (false, ErrorCodes.InvalidRowsToDataRootProof);\n            }\n        }\n\n        return (true, ErrorCodes.NoError);\n    }\n\n    /// @notice computes the Celestia block square size from a row/column root to data root binary merkle proof.\n    /// Note: the provided proof is not authenticated to the Blobstream smart contract. It is the user's responsibility\n    /// to verify that the proof is valid and was successfully committed to using\n    //  the `DAVerifier.verifyRowRootToDataRootTupleRoot()` method\n    /// Note: the minimum square size is 1. Thus, we don't expect the proof to have number of leaves equal to 0.\n    /// @param _proof The proof of the row/column root to the data root.\n    /// @return The square size of the corresponding block.\n    /// @return an error code if the _proof is invalid, Errors.NoError otherwise.\n    function computeSquareSizeFromRowProof(\n        BinaryMerkleProof memory _proof\n    ) internal pure returns (uint256, ErrorCodes) {\n        if (_proof.numLeaves % 4 != 0) {\n            return (0, ErrorCodes.InvalidNumberOfLeavesInProof);\n        }\n        // we divide the number of leaves of the proof by 4 because the rows/columns tree is constructed\n        // from the extended block row roots and column roots.\n        return (_proof.numLeaves / 4, ErrorCodes.NoError);\n    }\n\n    /// @notice computes the Celestia block square size from a shares to row/column root proof.\n    /// Note: the provided proof is not authenticated to the Blobstream smart contract. It is the user's responsibility\n    /// to verify that the proof is valid and that the shares were successfully committed to using\n    /// the `DAVerifier.verifySharesToDataRootTupleRoot()` method.\n    /// Note: the minimum square size is 1. Thus, we don't expect the proof not to contain any side node.\n    /// @param _proof The proof of the shares to the row/column root.\n    /// @return The square size of the corresponding block.\n    function computeSquareSizeFromShareProof(\n        NamespaceMerkleMultiproof memory _proof\n    ) internal pure returns (uint256) {\n        uint256 extendedSquareRowSize = 2 ** _proof.sideNodes.length;\n        // we divide the extended square row size by 2 because the square size is the\n        // the size of the row of the original square size.\n        return extendedSquareRowSize / 2;\n    }\n\n    /// @notice creates a slice of bytes from the data slice of bytes containing the elements\n    /// that correspond to the provided range.\n    /// It selects a half-open range which includes the begin element, but excludes the end one.\n    /// @param _data The slice that we want to select data from.\n    /// @param _begin The beginning of the range (inclusive).\n    /// @param _end The ending of the range (exclusive).\n    /// @return _ the sliced data.\n    function slice(\n        bytes[] memory _data,\n        uint256 _begin,\n        uint256 _end\n    ) internal pure returns (bytes[] memory, ErrorCodes) {\n        if (_begin > _end) {\n            return (_data, ErrorCodes.InvalidRange);\n        }\n        if (_begin > _data.length || _end > _data.length) {\n            return (_data, ErrorCodes.OutOfBoundsRange);\n        }\n        bytes[] memory out = new bytes[](_end - _begin);\n        for (uint256 i = _begin; i < _end; i++) {\n            out[i - _begin] = _data[i];\n        }\n        return (out, ErrorCodes.NoError);\n    }\n}\n"}, "src/celestia/IBlobstreamX.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"./lib/DataRootTuple.sol\";\nimport \"./lib/tree/binary/BinaryMerkleProof.sol\";\ninterface IBlobstreamX {\n    /// @notice Contract is frozen.\n    error ContractFrozen();\n\n    /// @notice Data commitment stored for the block range [startBlock, endBlock) with proof nonce.\n    /// @param proofNonce The nonce of the proof.\n    /// @param startBlock The start block of the block range.\n    /// @param endBlock The end block of the block range.\n    /// @param dataCommitment The data commitment for the block range.\n    event DataCommitmentStored(\n        uint256 proofNonce,\n        uint64 indexed startBlock,\n        uint64 indexed endBlock,\n        bytes32 indexed dataCommitment\n    );\n\n    /// @dev Latest height published to the BlobstreamX contract.\n    function latestBlock() external view returns (uint64);\n\n    /// @dev Nonce for proof events. Must be incremented sequentially.\n    function state_proofNonce() external view returns (uint256);\n\n    /// @dev Is the BlobstreamX contract forzen or not.\n    function frozen() external view returns (bool);\n\n    /// @dev fetches data commitment from BlobstreamX state.\n    function state_dataCommitments(uint256) external view returns (bytes32);\n\n    /// @notice Verify a Data Availability attestation.\n    /// @param _tupleRootNonce Nonce of the tuple root to prove against.\n    /// @param _tuple Data root tuple to prove inclusion of.\n    /// @param _proof Binary Merkle tree proof that `tuple` is in the root at `_tupleRootNonce`.\n    /// @return `true` is proof is valid, `false` otherwise.\n    function verifyAttestation(\n        uint256 _tupleRootNonce,\n        DataRootTuple memory _tuple,\n        BinaryMerkleProof memory _proof\n    ) external view returns (bool);\n}\n"}, "src/celestia/lib/Constants.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\n/// @dev bytes32 encoding of the string \"checkpoint\"\nbytes32 constant VALIDATOR_SET_HASH_DOMAIN_SEPARATOR = 0x636865636b706f696e7400000000000000000000000000000000000000000000;\n\n/// @dev bytes32 encoding of the string \"transactionBatch\"\nbytes32 constant DATA_ROOT_TUPLE_ROOT_DOMAIN_SEPARATOR = 0x7472616e73616374696f6e426174636800000000000000000000000000000000;\n"}, "src/celestia/lib/DataRootTuple.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\n/// @notice A tuple of data root with metadata. Each data root is associated\n///  with a Celestia block height.\n/// @dev `availableDataRoot` in\n///  https://github.com/celestiaorg/celestia-specs/blob/master/src/specs/data_structures.md#header\nstruct DataRootTuple {\n    // Celestia block height the data root was included in.\n    // Genesis block is height = 0.\n    // First queryable block is height = 1.\n    uint256 height;\n    // Data root.\n    bytes32 dataRoot;\n}\n"}, "src/celestia/lib/IDAOracle.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\nimport \"./DataRootTuple.sol\";\nimport \"./tree/binary/BinaryMerkleProof.sol\";\n\n/// @notice Data Availability Oracle interface.\ninterface IDAOracle {\n    /// @notice Verify a Data Availability attestation.\n    /// @param _tupleRootNonce Nonce of the tuple root to prove against.\n    /// @param _tuple Data root tuple to prove inclusion of.\n    /// @param _proof Binary Merkle tree proof that `tuple` is in the root at `_tupleRootNonce`.\n    /// @return `true` is proof is valid, `false` otherwise.\n    function verifyAttestation(\n        uint256 _tupleRootNonce,\n        DataRootTuple memory _tuple,\n        BinaryMerkleProof memory _proof\n    ) external view returns (bool);\n}\n"}, "src/celestia/lib/tree/binary/BinaryMerkleProof.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\n/// @notice Merkle Tree Proof structure.\nstruct BinaryMerkleProof {\n    // List of side nodes to verify and calculate tree.\n    bytes32[] sideNodes;\n    // The key of the leaf to verify.\n    uint256 key;\n    // The number of leaves in the tree\n    uint256 numLeaves;\n}\n"}, "src/celestia/lib/tree/binary/BinaryMerkleTree.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\nimport \"../Constants.sol\";\nimport \"../Utils.sol\";\nimport \"./TreeHasher.sol\";\nimport \"./BinaryMerkleProof.sol\";\n\n/// @title Binary Merkle Tree.\nlibrary BinaryMerkleTree {\n    /////////////////\n    // Error codes //\n    /////////////////\n\n    enum ErrorCodes {\n        NoError,\n        /// @notice The provided side nodes count is invalid for the proof.\n        InvalidNumberOfSideNodes,\n        /// @notice The provided proof key is not part of the tree.\n        KeyNotInTree,\n        /// @notice Invalid number of leaves in proof.\n        InvalidNumberOfLeavesInProof,\n        /// @notice The proof contains unexpected side nodes.\n        UnexpectedInnerHashes,\n        /// @notice The proof verification expected at least one inner hash.\n        ExpectedAtLeastOneInnerHash\n    }\n\n    ///////////////\n    // Functions //\n    ///////////////\n\n    /// @notice Verify if element exists in Merkle tree, given data, proof, and root.\n    /// @param root The root of the tree in which verify the given leaf.\n    /// @param proof Binary Merkle proof for the leaf.\n    /// @param data The data of the leaf to verify.\n    /// @return `true` is proof is valid, `false` otherwise.\n    /// @dev proof.numLeaves is necessary to determine height of subtree containing the data to prove.\n    function verify(\n        bytes32 root,\n        BinaryMerkleProof memory proof,\n        bytes memory data\n    ) internal pure returns (bool, ErrorCodes) {\n        // Check proof is correct length for the key it is proving\n        if (proof.numLeaves <= 1) {\n            if (proof.sideNodes.length != 0) {\n                return (false, ErrorCodes.InvalidNumberOfSideNodes);\n            }\n        } else if (\n            proof.sideNodes.length !=\n            pathLengthFromKey(proof.key, proof.numLeaves)\n        ) {\n            return (false, ErrorCodes.InvalidNumberOfSideNodes);\n        }\n\n        // Check key is in tree\n        if (proof.key >= proof.numLeaves) {\n            return (false, ErrorCodes.KeyNotInTree);\n        }\n\n        // A sibling at height 1 is created by getting the hash of the data to prove.\n        bytes32 digest = leafDigest(data);\n\n        // Null proof is only valid if numLeaves = 1\n        // If so, just verify hash(data) is root\n        if (proof.sideNodes.length == 0) {\n            if (proof.numLeaves == 1) {\n                return (root == digest, ErrorCodes.NoError);\n            } else {\n                return (false, ErrorCodes.NoError);\n            }\n        }\n\n        (bytes32 computedHash, ErrorCodes error) = computeRootHash(\n            proof.key,\n            proof.numLeaves,\n            digest,\n            proof.sideNodes\n        );\n\n        if (error != ErrorCodes.NoError) {\n            return (false, error);\n        }\n\n        return (computedHash == root, ErrorCodes.NoError);\n    }\n\n    /// @notice Use the leafHash and innerHashes to get the root merkle hash.\n    /// If the length of the innerHashes slice isn't exactly correct, the result is nil.\n    /// Recursive impl.\n    function computeRootHash(\n        uint256 key,\n        uint256 numLeaves,\n        bytes32 leafHash,\n        bytes32[] memory sideNodes\n    ) private pure returns (bytes32, ErrorCodes) {\n        if (numLeaves == 0) {\n            return (leafHash, ErrorCodes.InvalidNumberOfLeavesInProof);\n        }\n        if (numLeaves == 1) {\n            if (sideNodes.length != 0) {\n                return (leafHash, ErrorCodes.UnexpectedInnerHashes);\n            }\n            return (leafHash, ErrorCodes.NoError);\n        }\n        if (sideNodes.length == 0) {\n            return (leafHash, ErrorCodes.ExpectedAtLeastOneInnerHash);\n        }\n        uint256 numLeft = _getSplitPoint(numLeaves);\n        bytes32[] memory sideNodesLeft = slice(\n            sideNodes,\n            0,\n            sideNodes.length - 1\n        );\n        ErrorCodes error;\n        if (key < numLeft) {\n            bytes32 leftHash;\n            (leftHash, error) = computeRootHash(\n                key,\n                numLeft,\n                leafHash,\n                sideNodesLeft\n            );\n            if (error != ErrorCodes.NoError) {\n                return (leafHash, error);\n            }\n            return (\n                nodeDigest(leftHash, sideNodes[sideNodes.length - 1]),\n                ErrorCodes.NoError\n            );\n        }\n        bytes32 rightHash;\n        (rightHash, error) = computeRootHash(\n            key - numLeft,\n            numLeaves - numLeft,\n            leafHash,\n            sideNodesLeft\n        );\n        if (error != ErrorCodes.NoError) {\n            return (leafHash, error);\n        }\n        return (\n            nodeDigest(sideNodes[sideNodes.length - 1], rightHash),\n            ErrorCodes.NoError\n        );\n    }\n\n    /// @notice creates a slice of bytes32 from the data slice of bytes32 containing the elements\n    /// that correspond to the provided range.\n    /// It selects a half-open range which includes the begin element, but excludes the end one.\n    /// @param _data The slice that we want to select data from.\n    /// @param _begin The beginning of the range (inclusive).\n    /// @param _end The ending of the range (exclusive).\n    /// @return _ the sliced data.\n    function slice(\n        bytes32[] memory _data,\n        uint256 _begin,\n        uint256 _end\n    ) internal pure returns (bytes32[] memory) {\n        if (_begin > _end) {\n            revert(\"Invalid range: _begin is greater than _end\");\n        }\n        if (_begin > _data.length || _end > _data.length) {\n            revert(\"Invalid range: _begin or _end are out of bounds\");\n        }\n        bytes32[] memory out = new bytes32[](_end - _begin);\n        for (uint256 i = _begin; i < _end; i++) {\n            out[i - _begin] = _data[i];\n        }\n        return out;\n    }\n}\n"}, "src/celestia/lib/tree/binary/TreeHasher.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\nimport \"../Constants.sol\";\n\n/// @notice Calculate the digest of a node.\n/// @param left The left child.\n/// @param right The right child.\n/// @return digest The node digest.\n/// @dev More details in https://github.com/celestiaorg/celestia-specs/blob/master/src/specs/data_structures.md#binary-merkle-tree\n// solhint-disable-next-line func-visibility\nfunction nodeDigest(bytes32 left, bytes32 right) pure returns (bytes32 digest) {\n    digest = sha256(abi.encodePacked(Constants.NODE_PREFIX, left, right));\n}\n\n/// @notice Calculate the digest of a leaf.\n/// @param data The data of the leaf.\n/// @return digest The leaf digest.\n/// @dev More details in https://github.com/celestiaorg/celestia-specs/blob/master/src/specs/data_structures.md#binary-merkle-tree\n// solhint-disable-next-line func-visibility\nfunction leafDigest(bytes memory data) pure returns (bytes32 digest) {\n    digest = sha256(abi.encodePacked(Constants.LEAF_PREFIX, data));\n}\n"}, "src/celestia/lib/tree/Constants.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\nimport \"./Types.sol\";\n\nlibrary Constants {\n    ///////////////\n    // Constants //\n    ///////////////\n\n    /// @dev Maximum tree height\n    uint256 internal constant MAX_HEIGHT = 256;\n\n    /// @dev The prefixes of leaves and nodes\n    bytes1 internal constant LEAF_PREFIX = 0x00;\n    bytes1 internal constant NODE_PREFIX = 0x01;\n}\n\n/// @dev Parity share namespace.\n/// utility function to provide the parity share namespace as a Namespace struct.\nfunction PARITY_SHARE_NAMESPACE() pure returns (Namespace memory) {\n    return\n        Namespace(\n            0xFF,\n            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n        );\n}\n"}, "src/celestia/lib/tree/namespace/NamespaceMerkleMultiproof.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\nimport \"./NamespaceNode.sol\";\n\n/// @notice Namespace Merkle Tree Multiproof structure. Proves multiple leaves.\nstruct NamespaceMerkleMultiproof {\n    // The beginning key of the leaves to verify.\n    uint256 beginKey;\n    // The ending key of the leaves to verify.\n    uint256 endKey;\n    // List of side nodes to verify and calculate tree.\n    NamespaceNode[] sideNodes;\n}\n"}, "src/celestia/lib/tree/namespace/NamespaceMerkleProof.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\nimport \"./NamespaceNode.sol\";\n\n/// @notice Namespace Merkle Tree Proof structure.\nstruct NamespaceMerkleProof {\n    // List of side nodes to verify and calculate tree.\n    NamespaceNode[] sideNodes;\n    // The key of the leaf to verify.\n    uint256 key;\n    // The number of leaves in the tree\n    uint256 numLeaves;\n}\n"}, "src/celestia/lib/tree/namespace/NamespaceMerkleTree.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\nimport \"../Constants.sol\";\nimport \"../Types.sol\";\nimport \"../Utils.sol\";\nimport \"./NamespaceMerkleProof.sol\";\nimport \"./NamespaceMerkleMultiproof.sol\";\nimport \"./NamespaceNode.sol\";\nimport \"./TreeHasher.sol\";\n\n/// @title Namespace Merkle Tree.\nlibrary NamespaceMerkleTree {\n    /// @notice Verify if element exists in Merkle tree, given data, proof, and root.\n    /// @param root The root of the tree in which the given leaf is verified.\n    /// @param proof Namespace Merkle proof for the leaf.\n    /// @param namespace Namespace of the leaf.\n    /// @param data The data of the leaf to verify.\n    /// @return `true` if the proof is valid, `false` otherwise.\n    /// @dev proof.numLeaves is necessary to determine height of subtree containing the data to prove.\n    function verify(\n        NamespaceNode memory root,\n        NamespaceMerkleProof memory proof,\n        Namespace memory namespace,\n        bytes memory data\n    ) internal pure returns (bool) {\n        // A sibling at height 1 is created by getting the leafDigest of the original data.\n        NamespaceNode memory node = leafDigest(namespace, data);\n\n        // Since we're verifying a leaf, height parameter is 1.\n        return verifyInner(root, proof, node, 1);\n    }\n\n    /// @notice Verify if inner node exists in Merkle tree, given node, proof, and root.\n    /// @param root The root of the tree in which the given leaf is verified.\n    /// @param proof Namespace Merkle proof for the leaf.\n    /// proof.key is any key in the subtree rooted at the inner node.\n    /// @param node The inner node to verify.\n    /// @param startingHeight Starting height of the proof.\n    /// @return `true` if the proof is valid, `false` otherwise.\n    /// @dev proof.numLeaves is necessary to determine height of subtree containing the data to prove.\n    function verifyInner(\n        NamespaceNode memory root,\n        NamespaceMerkleProof memory proof,\n        NamespaceNode memory node,\n        uint256 startingHeight\n    ) internal pure returns (bool) {\n        // Check starting height is at least 1\n        if (startingHeight < 1) {\n            return false;\n        }\n        uint256 heightOffset = startingHeight - 1;\n\n        // Check proof is correct length for the key it is proving\n        if (proof.numLeaves <= 1) {\n            if (proof.sideNodes.length != 0) {\n                return false;\n            }\n        } else if (\n            proof.sideNodes.length + heightOffset !=\n            pathLengthFromKey(proof.key, proof.numLeaves)\n        ) {\n            return false;\n        }\n\n        // Check key is in tree\n        if (proof.key >= proof.numLeaves) {\n            return false;\n        }\n        // Handle case where proof is empty: i.e, only one leaf exists, so verify hash(data) is root\n        if (proof.sideNodes.length == 0) {\n            if (proof.numLeaves == 1) {\n                return namespaceNodeEquals(root, node);\n            } else {\n                return false;\n            }\n        }\n\n        // The case where inner node is actually the root of a tree with more than one node is not relevant\n        // to our use case, since the only case where an inner node is the root of the tree is when the tree\n        // has only one inner node. So, there is no need to handle that case.\n\n        uint256 height = startingHeight;\n        uint256 stableEnd = proof.key;\n\n        // While the current subtree (of height 'height') is complete, determine\n        // the position of the next sibling using the complete subtree algorithm.\n        // 'stableEnd' tells us the ending index of the last full subtree. It gets\n        // initialized to 'key' because the first full subtree was the\n        // subtree of height 1, created above (and had an ending index of\n        // 'key').\n\n        while (true) {\n            // Determine if the subtree is complete. This is accomplished by\n            // rounding down the key to the nearest 1 << 'height', adding 1\n            // << 'height', and comparing the result to the number of leaves in the\n            // Merkle tree.\n\n            uint256 subTreeStartIndex = (proof.key / (1 << height)) *\n                (1 << height);\n            uint256 subTreeEndIndex = subTreeStartIndex + (1 << height) - 1;\n\n            // If the Merkle tree does not have a leaf at index\n            // 'subTreeEndIndex', then the subtree of the current height is not\n            // a complete subtree.\n            if (subTreeEndIndex >= proof.numLeaves) {\n                break;\n            }\n            stableEnd = subTreeEndIndex;\n\n            // Determine if the key is in the first or the second half of\n            // the subtree.\n            if (proof.sideNodes.length + heightOffset <= height - 1) {\n                return false;\n            }\n            if (proof.key - subTreeStartIndex < (1 << (height - 1))) {\n                node = nodeDigest(\n                    node,\n                    proof.sideNodes[height - heightOffset - 1]\n                );\n            } else {\n                node = nodeDigest(\n                    proof.sideNodes[height - heightOffset - 1],\n                    node\n                );\n            }\n\n            height += 1;\n        }\n\n        // Determine if the next hash belongs to an orphan that was elevated. This\n        // is the case IFF 'stableEnd' (the last index of the largest full subtree)\n        // is equal to the number of leaves in the Merkle tree.\n        if (stableEnd != proof.numLeaves - 1) {\n            if (proof.sideNodes.length <= height - heightOffset - 1) {\n                return false;\n            }\n            node = nodeDigest(node, proof.sideNodes[height - heightOffset - 1]);\n            height += 1;\n        }\n        // All remaining elements in the proof set will belong to a left sibling.\n        while (height - heightOffset - 1 < proof.sideNodes.length) {\n            node = nodeDigest(proof.sideNodes[height - heightOffset - 1], node);\n            height += 1;\n        }\n\n        return namespaceNodeEquals(root, node);\n    }\n\n    /// @notice Verify if contiguous elements exists in Merkle tree, given leaves, mutliproof, and root.\n    /// @param root The root of the tree in which the given leaves are verified.\n    /// @param proof Namespace Merkle multiproof for the leaves.\n    /// @param namespace Namespace of the leaves. All leaves must have the same namespace.\n    /// @param data The leaves to verify. Note: leaf data must be the _entire_ share (including namespace prefixing).\n    /// @return `true` if the proof is valid, `false` otherwise.\n    function verifyMulti(\n        NamespaceNode memory root,\n        NamespaceMerkleMultiproof memory proof,\n        Namespace memory namespace,\n        bytes[] memory data\n    ) internal pure returns (bool) {\n        // Hash all the leaves to get leaf nodes.\n        NamespaceNode[] memory nodes = new NamespaceNode[](data.length);\n        for (uint256 i = 0; i < data.length; ++i) {\n            nodes[i] = leafDigest(namespace, data[i]);\n        }\n\n        // Verify inclusion of leaf nodes.\n        return verifyMultiHashes(root, proof, nodes);\n    }\n\n    /// @notice Verify if contiguous leaf hashes exists in Merkle tree, given leaf nodes, multiproof, and root.\n    /// @param root The root of the tree in which the given leaf nodes are verified.\n    /// @param proof Namespace Merkle multiproof for the leaves.\n    /// @param leafNodes The leaf nodes to verify.\n    /// @return `true` if the proof is valid, `false` otherwise.\n    function verifyMultiHashes(\n        NamespaceNode memory root,\n        NamespaceMerkleMultiproof memory proof,\n        NamespaceNode[] memory leafNodes\n    ) internal pure returns (bool) {\n        uint256 leafIndex = 0;\n        NamespaceNode[] memory leftSubtrees = new NamespaceNode[](\n            proof.sideNodes.length\n        );\n\n        for (\n            uint256 i = 0;\n            leafIndex != proof.beginKey && i < proof.sideNodes.length;\n            ++i\n        ) {\n            uint256 subtreeSize = _nextSubtreeSize(leafIndex, proof.beginKey);\n            leftSubtrees[i] = proof.sideNodes[i];\n            leafIndex += subtreeSize;\n        }\n\n        // estimate the leaf size of the subtree containing the proof range\n        uint256 proofRangeSubtreeEstimate = _getSplitPoint(proof.endKey) * 2;\n        if (proofRangeSubtreeEstimate < 1) {\n            proofRangeSubtreeEstimate = 1;\n        }\n\n        (NamespaceNode memory rootHash, uint256 proofHead, , ) = _computeRoot(\n            proof,\n            leafNodes,\n            0,\n            proofRangeSubtreeEstimate,\n            0,\n            0\n        );\n        for (uint256 i = proofHead; i < proof.sideNodes.length; ++i) {\n            rootHash = nodeDigest(rootHash, proof.sideNodes[i]);\n        }\n\n        return namespaceNodeEquals(rootHash, root);\n    }\n\n    /// @notice Returns the size of the subtree adjacent to `begin` that does\n    /// not overlap `end`.\n    /// @param begin Begin index, inclusive.\n    /// @param end End index, exclusive.\n    function _nextSubtreeSize(\n        uint256 begin,\n        uint256 end\n    ) private pure returns (uint256) {\n        uint256 ideal = _bitsTrailingZeroes(begin);\n        uint256 max = _bitsLen(end - begin) - 1;\n        if (ideal > max) {\n            return 1 << max;\n        }\n        return 1 << ideal;\n    }\n\n    /// @notice Returns the number of trailing zero bits in `x`; the result is\n    /// 256 for `x` == 0.\n    /// @param x Number.\n    function _bitsTrailingZeroes(uint256 x) private pure returns (uint256) {\n        uint256 mask = 1;\n        uint256 count = 0;\n\n        while (x != 0 && mask & x == 0) {\n            count++;\n            x >>= 1;\n        }\n\n        return count;\n    }\n\n    /// @notice Computes the NMT root recursively.\n    /// @param proof Namespace Merkle multiproof for the leaves.\n    /// @param leafNodes Leaf nodes for which inclusion is proven.\n    /// @param begin Begin index, inclusive.\n    /// @param end End index, exclusive.\n    /// @param headProof Internal detail: head of proof sidenodes array. Used for recursion. Set to `0` on first call.\n    /// @param headLeaves Internal detail: head of leaves array. Used for recursion. Set to `0` on first call.\n    /// @return _ Subtree root.\n    /// @return _ New proof sidenodes array head. Used for recursion.\n    /// @return _ New leaves array head. Used for recursion.\n    /// @return _ If the subtree root is \"nil.\"\n    function _computeRoot(\n        NamespaceMerkleMultiproof memory proof,\n        NamespaceNode[] memory leafNodes,\n        uint256 begin,\n        uint256 end,\n        uint256 headProof,\n        uint256 headLeaves\n    ) private pure returns (NamespaceNode memory, uint256, uint256, bool) {\n        // reached a leaf\n        if (end - begin == 1) {\n            // if current range overlaps with proof range, pop and return a leaf\n            if (proof.beginKey <= begin && begin < proof.endKey) {\n                // Note: second return value is guaranteed to be `false` by\n                // construction.\n                return\n                    _popLeavesIfNonEmpty(\n                        leafNodes,\n                        headLeaves,\n                        leafNodes.length,\n                        headProof\n                    );\n            }\n\n            // if current range does not overlap with proof range,\n            // pop and return a proof node (leaf) if present,\n            // else return nil because leaf doesn't exist\n            return\n                _popProofIfNonEmpty(\n                    proof.sideNodes,\n                    headProof,\n                    end,\n                    headLeaves\n                );\n        }\n\n        // if current range does not overlap with proof range,\n        // pop and return a proof node if present,\n        // else return nil because subtree doesn't exist\n        if (end <= proof.beginKey || begin >= proof.endKey) {\n            return\n                _popProofIfNonEmpty(\n                    proof.sideNodes,\n                    headProof,\n                    end,\n                    headLeaves\n                );\n        }\n\n        // Recursively get left and right subtree\n        uint256 k = _getSplitPoint(end - begin);\n        (\n            NamespaceNode memory left,\n            uint256 newHeadProofLeft,\n            uint256 newHeadLeavesLeft,\n\n        ) = _computeRoot(\n                proof,\n                leafNodes,\n                begin,\n                begin + k,\n                headProof,\n                headLeaves\n            );\n        (\n            NamespaceNode memory right,\n            uint256 newHeadProof,\n            uint256 newHeadLeaves,\n            bool rightIsNil\n        ) = _computeRoot(\n                proof,\n                leafNodes,\n                begin + k,\n                end,\n                newHeadProofLeft,\n                newHeadLeavesLeft\n            );\n\n        // only right leaf/subtree can be non-existent\n        if (rightIsNil == true) {\n            return (left, newHeadProof, newHeadLeaves, false);\n        }\n        NamespaceNode memory hash = nodeDigest(left, right);\n        return (hash, newHeadProof, newHeadLeaves, false);\n    }\n\n    /// @notice Pop from the leaf nodes array slice if it's not empty.\n    /// @param nodes Entire leaf nodes array.\n    /// @param headLeaves Head of leaf nodes array slice.\n    /// @param end End of leaf nodes array slice.\n    /// @param headProof Used only to return for recursion.\n    /// @return _ Popped node.\n    /// @return _ Head of proof sidenodes array slice (unchanged).\n    /// @return _ New head of leaf nodes array slice.\n    /// @return _ If the popped node is \"nil.\"\n    function _popLeavesIfNonEmpty(\n        NamespaceNode[] memory nodes,\n        uint256 headLeaves,\n        uint256 end,\n        uint256 headProof\n    ) private pure returns (NamespaceNode memory, uint256, uint256, bool) {\n        (\n            NamespaceNode memory node,\n            uint256 newHead,\n            bool isNil\n        ) = _popIfNonEmpty(nodes, headLeaves, end);\n        return (node, headProof, newHead, isNil);\n    }\n\n    /// @notice Pop from the proof sidenodes array slice if it's not empty.\n    /// @param nodes Entire proof sidenodes array.\n    /// @param headLeaves Head of proof sidenodes array slice.\n    /// @param end End of proof sidenodes array slice.\n    /// @param headProof Used only to return for recursion.\n    /// @return _ Popped node.\n    /// @return _ New head of proof sidenodes array slice.\n    /// @return _ Head of proof sidenodes array slice (unchanged).\n    /// @return _ If the popped node is \"nil.\"\n    function _popProofIfNonEmpty(\n        NamespaceNode[] memory nodes,\n        uint256 headProof,\n        uint256 end,\n        uint256 headLeaves\n    ) private pure returns (NamespaceNode memory, uint256, uint256, bool) {\n        (\n            NamespaceNode memory node,\n            uint256 newHead,\n            bool isNil\n        ) = _popIfNonEmpty(nodes, headProof, end);\n        return (node, newHead, headLeaves, isNil);\n    }\n\n    /// @notice Pop from an array slice if it's not empty.\n    /// @param nodes Entire array.\n    /// @param head Head of array slice.\n    /// @param end End of array slice.\n    /// @return _ Popped node.\n    /// @return _ New head of array slice.\n    /// @return _ If the popped node is \"nil.\"\n    function _popIfNonEmpty(\n        NamespaceNode[] memory nodes,\n        uint256 head,\n        uint256 end\n    ) private pure returns (NamespaceNode memory, uint256, bool) {\n        if (nodes.length == 0 || head >= nodes.length || head >= end) {\n            NamespaceNode memory node;\n            return (node, head, true);\n        }\n        return (nodes[head], head + 1, false);\n    }\n}\n"}, "src/celestia/lib/tree/namespace/NamespaceNode.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\nimport \"../Types.sol\";\n\n/// @notice Namespace Merkle Tree node.\nstruct NamespaceNode {\n    // Minimum namespace.\n    Namespace min;\n    // Maximum namespace.\n    Namespace max;\n    // Node value.\n    bytes32 digest;\n}\n\n/// @notice Compares two `NamespaceNode`s.\n/// @param first First node.\n/// @param second Second node.\n/// @return `true` is equal, `false otherwise.\n// solhint-disable-next-line func-visibility\nfunction namespaceNodeEquals(\n    NamespaceNode memory first,\n    NamespaceNode memory second\n) pure returns (bool) {\n    return\n        first.min.equalTo(second.min) &&\n        first.max.equalTo(second.max) &&\n        (first.digest == second.digest);\n}\n"}, "src/celestia/lib/tree/namespace/TreeHasher.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\nimport \"../Constants.sol\";\nimport \"../Types.sol\";\nimport \"./NamespaceNode.sol\";\n\n/// @notice Get the minimum namespace.\n// solhint-disable-next-line func-visibility\nfunction namespaceMin(\n    Namespace memory l,\n    Namespace memory r\n) pure returns (Namespace memory) {\n    if (l.lessThan(r)) {\n        return l;\n    } else {\n        return r;\n    }\n}\n\n/// @notice Get the maximum namespace.\n// solhint-disable-next-line func-visibility\nfunction namespaceMax(\n    Namespace memory l,\n    Namespace memory r\n) pure returns (Namespace memory) {\n    if (l.greaterThan(r)) {\n        return l;\n    } else {\n        return r;\n    }\n}\n\n/// @notice Hash a leaf node.\n/// @param namespace Namespace of the leaf.\n/// @param data Raw data of the leaf.\n/// @dev More details in https://github.com/celestiaorg/celestia-specs/blob/master/src/specs/data_structures.md#namespace-merkle-tree\n// solhint-disable-next-line func-visibility\nfunction leafDigest(\n    Namespace memory namespace,\n    bytes memory data\n) pure returns (NamespaceNode memory) {\n    bytes32 digest = sha256(\n        abi.encodePacked(Constants.LEAF_PREFIX, namespace.toBytes(), data)\n    );\n    NamespaceNode memory node = NamespaceNode(namespace, namespace, digest);\n    return node;\n}\n\n/// @notice Hash an internal node.\n/// @param l Left child.\n/// @param r Right child.\n/// @dev More details in https://github.com/celestiaorg/celestia-specs/blob/master/src/specs/data_structures.md#namespace-merkle-tree\n// solhint-disable-next-line func-visibility\nfunction nodeDigest(\n    NamespaceNode memory l,\n    NamespaceNode memory r\n) pure returns (NamespaceNode memory) {\n    Namespace memory min = namespaceMin(l.min, r.min);\n    Namespace memory max;\n    if (l.min.equalTo(PARITY_SHARE_NAMESPACE())) {\n        max = PARITY_SHARE_NAMESPACE();\n    } else if (r.min.equalTo(PARITY_SHARE_NAMESPACE())) {\n        max = l.max;\n    } else {\n        max = namespaceMax(l.max, r.max);\n    }\n\n    bytes32 digest = sha256(\n        abi.encodePacked(\n            Constants.NODE_PREFIX,\n            l.min.toBytes(),\n            l.max.toBytes(),\n            l.digest,\n            r.min.toBytes(),\n            r.max.toBytes(),\n            r.digest\n        )\n    );\n\n    NamespaceNode memory node = NamespaceNode(min, max, digest);\n    return node;\n}\n"}, "src/celestia/lib/tree/Types.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\n/// @notice A representation of the Celestia-app namespace ID and its version.\n/// See: https://celestiaorg.github.io/celestia-app/specs/namespace.html\nstruct Namespace {\n    // The namespace version.\n    bytes1 version;\n    // The namespace ID.\n    bytes28 id;\n}\n\nusing {equalTo, lessThan, greaterThan, toBytes} for Namespace global;\n\nfunction equalTo(Namespace memory l, Namespace memory r) pure returns (bool) {\n    return l.toBytes() == r.toBytes();\n}\n\nfunction lessThan(Namespace memory l, Namespace memory r) pure returns (bool) {\n    return l.toBytes() < r.toBytes();\n}\n\nfunction greaterThan(\n    Namespace memory l,\n    Namespace memory r\n) pure returns (bool) {\n    return l.toBytes() > r.toBytes();\n}\n\nfunction toBytes(Namespace memory n) pure returns (bytes29) {\n    return bytes29(abi.encodePacked(n.version, n.id));\n}\n\nfunction toNamespace(bytes29 n) pure returns (Namespace memory) {\n    bytes memory id = new bytes(28);\n    for (uint256 i = 1; i < 29; i++) {\n        id[i - 1] = n[i];\n    }\n    return Namespace(n[0], bytes28(id));\n}\n"}, "src/celestia/lib/tree/Utils.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\nimport \"./Constants.sol\";\n\n/// @notice Calculate the starting bit of the path to a leaf\n/// @param numLeaves : The total number of leaves in the tree\n/// @return startingBit : The starting bit of the path\n// solhint-disable-next-line func-visibility\nfunction getStartingBit(uint256 numLeaves) pure returns (uint256 startingBit) {\n    // Determine height of the left subtree. This is the maximum path length, so all paths start at this offset from the right-most bit\n    startingBit = 0;\n    while ((1 << startingBit) < numLeaves) {\n        startingBit += 1;\n    }\n    return Constants.MAX_HEIGHT - startingBit;\n}\n\n/// @notice Calculate the length of the path to a leaf\n/// @param key: The key of the leaf\n/// @param numLeaves: The total number of leaves in the tree\n/// @return pathLength : The length of the path to the leaf\n// solhint-disable-next-line func-visibility\nfunction pathLengthFromKey(\n    uint256 key,\n    uint256 numLeaves\n) pure returns (uint256 pathLength) {\n    if (numLeaves <= 1) {\n        // if the number of leaves of the tree is 1 or 0, the path always is 0.\n        return 0;\n    }\n    // Get the height of the left subtree. This is equal to the offset of the starting bit of the path\n    pathLength = Constants.MAX_HEIGHT - getStartingBit(numLeaves);\n\n    // Determine the number of leaves in the left subtree\n    uint256 numLeavesLeftSubTree = (1 << (pathLength - 1));\n\n    // If leaf is in left subtree, path length is full height of left subtree\n    if (key <= numLeavesLeftSubTree - 1) {\n        return pathLength;\n    }\n    // If left sub tree has only one leaf but key is not there, path has one additional step\n    else if (numLeavesLeftSubTree == 1) {\n        return 1;\n    }\n    // Otherwise, add 1 to height and recurse into right subtree\n    else {\n        return\n            1 +\n            pathLengthFromKey(\n                key - numLeavesLeftSubTree,\n                numLeaves - numLeavesLeftSubTree\n            );\n    }\n}\n\n/// @notice Returns the minimum number of bits required to represent `x`; the\n/// result is 0 for `x` == 0.\n/// @param x Number.\nfunction _bitsLen(uint256 x) pure returns (uint256) {\n    uint256 count = 0;\n\n    while (x != 0) {\n        count++;\n        x >>= 1;\n    }\n\n    return count;\n}\n\n/// @notice Returns the largest power of 2 less than `x`.\n/// @param x Number.\nfunction _getSplitPoint(uint256 x) pure returns (uint256) {\n    // Note: since `x` is always an unsigned int * 2, the only way for this\n    // to be violated is if the input == 0. Since the input is the end\n    // index exclusive, an input of 0 is guaranteed to be invalid (it would\n    // be a proof of inclusion of nothing, which is vacuous).\n    require(x >= 1);\n\n    uint256 bitLen = _bitsLen(x);\n    uint256 k = 1 << (bitLen - 1);\n    if (k == x) {\n        k >>= 1;\n    }\n    return k;\n}\n"}, "src/chain/CacheManager.sol": {"content": "// Copyright 2022-2024, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../precompiles/ArbOwnerPublic.sol\";\nimport \"../precompiles/ArbWasm.sol\";\nimport \"../precompiles/ArbWasmCache.sol\";\nimport \"../libraries/DelegateCallAware.sol\";\nimport \"solady/src/utils/MinHeapLib.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract CacheManager is Initializable, DelegateCallAware {\n    using MinHeapLib for MinHeapLib.Heap;\n\n    ArbOwnerPublic internal constant ARB_OWNER_PUBLIC = ArbOwnerPublic(address(0x6b));\n    ArbWasm internal constant ARB_WASM = ArbWasm(address(0x71));\n    ArbWasmCache internal constant ARB_WASM_CACHE = ArbWasmCache(address(0x72));\n    uint64 internal constant MAX_MAKE_SPACE = 5 * 1024 * 1024;\n    uint64 internal constant MIN_CODESIZE = 4096;\n\n    MinHeapLib.Heap internal bids;\n    Entry[] public entries;\n\n    uint64 public cacheSize;\n    uint64 public queueSize;\n    uint64 public decay;\n    bool public isPaused;\n\n    error NotChainOwner(address sender);\n    error AsmTooLarge(uint256 asm, uint256 queueSize, uint256 cacheSize);\n    error AlreadyCached(bytes32 codehash);\n    error BidTooLarge(uint256 bid);\n    error BidTooSmall(uint192 bid, uint192 min);\n    error BidsArePaused();\n    error MakeSpaceTooLarge(uint64 size, uint64 limit);\n\n    event InsertBid(bytes32 indexed codehash, address program, uint192 bid, uint64 size);\n    event DeleteBid(bytes32 indexed codehash, uint192 bid, uint64 size);\n    event SetCacheSize(uint64 size);\n    event SetDecayRate(uint64 decay);\n    event Pause();\n    event Unpause();\n\n    struct Entry {\n        bytes32 code;\n        uint64 size;\n        uint192 bid;\n    }\n\n    function initialize(uint64 initCacheSize, uint64 initDecay) external initializer onlyDelegated {\n        cacheSize = initCacheSize;\n        decay = initDecay;\n    }\n\n    modifier onlyOwner() {\n        if (!ARB_OWNER_PUBLIC.isChainOwner(msg.sender)) {\n            revert NotChainOwner(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Sets the intended cache size. Note that the queue may temporarily be larger.\n    function setCacheSize(uint64 newSize) external onlyOwner {\n        cacheSize = newSize;\n        emit SetCacheSize(newSize);\n    }\n\n    /// @notice Sets the intended decay factor. Does not modify existing bids.\n    function setDecayRate(uint64 newDecay) external onlyOwner {\n        decay = newDecay;\n        emit SetDecayRate(newDecay);\n    }\n\n    /// @notice Disable new bids.\n    function paused() external onlyOwner {\n        isPaused = true;\n        emit Pause();\n    }\n\n    /// @notice Enable new bids.\n    function unpause() external onlyOwner {\n        isPaused = false;\n        emit Unpause();\n    }\n\n    /// @notice Evicts all programs in the cache.\n    function evictAll() external onlyOwner {\n        evictPrograms(type(uint256).max);\n        delete entries;\n    }\n\n    /// @notice Evicts up to `count` programs from the cache.\n    function evictPrograms(uint256 count) public onlyOwner {\n        while (bids.length() != 0 && count > 0) {\n            (uint192 bid, uint64 index) = _getBid(bids.pop());\n            _deleteEntry(bid, index);\n            count -= 1;\n        }\n    }\n\n    /// @notice Returns all entries in the cache. Might revert if the cache is too large.\n    function getEntries() external view returns (Entry[] memory) {\n        return entries;\n    }\n\n    /// @notice Returns the `k` smallest entries in the cache sorted in ascending order.\n    ///         If the cache have less than `k` entries, returns all entries.\n    function getSmallestEntries(uint256 k) public view returns (Entry[] memory result) {\n        if (bids.length() < k) {\n            k = bids.length();\n        }\n        uint256[] memory kbids = bids.smallest(k);\n        result = new Entry[](kbids.length);\n        for (uint256 i = 0; i < kbids.length; i++) {\n            (, uint64 index) = _getBid(kbids[i]);\n            result[i] = entries[index];\n        }\n    }\n\n    /// @notice Returns the minimum bid required to cache a program of the given size.\n    ///         Value returned here is the minimum bid that you can send with msg.value\n    function getMinBid(uint64 size) public view returns (uint192 min) {\n        if (size > cacheSize) {\n            revert AsmTooLarge(size, 0, cacheSize);\n        }\n\n        size = size >= MIN_CODESIZE ? size : MIN_CODESIZE;\n        uint256 totalSize = queueSize + size;\n        if (totalSize <= cacheSize) {\n            return 0;\n        }\n        uint256 needToFree = totalSize - cacheSize;\n\n        // size is at least MIN_CODESIZE, and vary no more than 10x right now, so we can safely assume\n        // for a given size, we need at most need to clear roundUp(size/MIN_CODESIZE) entries to make space\n        uint256 k = (needToFree + MIN_CODESIZE - 1) / MIN_CODESIZE;\n        Entry[] memory smallest = getSmallestEntries(k);\n        for (uint256 i = 0; i < smallest.length; i++) {\n            if (needToFree <= smallest[i].size) {\n                min = smallest[i].bid;\n                break;\n            }\n            needToFree -= smallest[i].size;\n        }\n        uint256 currentDecay = _calcDecay();\n        if (min < currentDecay) {\n            return 0;\n        }\n        min = min - uint192(currentDecay);\n    }\n\n    /// @notice Returns the minimum bid required to cache the program with given codehash.\n    ///         Value returned here is the minimum bid that you can send with msg.value\n    function getMinBid(bytes32 codehash) public view returns (uint192 min) {\n        return getMinBid(_asmSize(codehash));\n    }\n\n    /// @notice Returns the minimum bid required to cache the program at given address.\n    ///         Value returned here is the minimum bid that you can send with msg.value\n    function getMinBid(address program) external view returns (uint192 min) {\n        return getMinBid(program.codehash);\n    }\n\n    /// @notice Sends all revenue to the network fee account.\n    function sweepFunds() external {\n        (bool success, bytes memory data) = ARB_OWNER_PUBLIC.getNetworkFeeAccount().call{\n            value: address(this).balance\n        }(\"\");\n        if (!success) {\n            assembly {\n                revert(add(data, 32), mload(data))\n            }\n        }\n    }\n\n    /// Places a bid, reverting if payment is insufficient.\n    function placeBid(address program) external payable {\n        if (isPaused) {\n            revert BidsArePaused();\n        }\n        bytes32 codehash = program.codehash;\n        if (_isCached(codehash)) {\n            revert AlreadyCached(codehash);\n        }\n\n        uint64 asm = _asmSize(codehash);\n        (uint192 bid, uint64 index) = _makeSpace(asm);\n        return _addBid(bid, program, codehash, asm, index);\n    }\n\n    /// @notice Evicts entries until enough space exists in the cache, reverting if payment is insufficient.\n    ///         Returns the new amount of space available on success.\n    /// @dev    Will revert for requests larger than 5Mb. Call repeatedly for more.\n    function makeSpace(uint64 size) external payable returns (uint64 space) {\n        if (isPaused) {\n            revert BidsArePaused();\n        }\n        if (size > MAX_MAKE_SPACE) {\n            revert MakeSpaceTooLarge(size, MAX_MAKE_SPACE);\n        }\n        _makeSpace(size);\n        return cacheSize - queueSize;\n    }\n\n    function _calcDecay() internal view returns (uint256) {\n        return block.timestamp * decay;\n    }\n\n    /// @dev Converts a value to a bid by adding the time decay term.\n    function _toBid(uint256 value) internal view returns (uint192 bid) {\n        uint256 _bid = value + _calcDecay();\n        if (_bid > type(uint192).max) {\n            revert BidTooLarge(_bid);\n        }\n        return uint192(_bid);\n    }\n\n    /// @dev Evicts entries until enough space exists in the cache, reverting if payment is insufficient.\n    ///      Returns the bid and the index to use for insertion.\n    function _makeSpace(uint64 size) internal returns (uint192 bid, uint64 index) {\n        // discount historical bids by the number of seconds\n        bid = _toBid(msg.value);\n        index = uint64(entries.length);\n\n        uint192 min;\n        uint64 limit = cacheSize;\n        while (queueSize + size > limit) {\n            (min, index) = _getBid(bids.pop());\n            _deleteEntry(min, index);\n        }\n        // if the new bid equals to the minimum bid, a random entry with minimum bid will be evicted\n        if (bid < min) {\n            revert BidTooSmall(bid, min);\n        }\n    }\n\n    /// @dev Adds a bid\n    function _addBid(\n        uint192 bid,\n        address program,\n        bytes32 code,\n        uint64 size,\n        uint64 index\n    ) internal {\n        if (queueSize + size > cacheSize) {\n            revert AsmTooLarge(size, queueSize, cacheSize);\n        }\n\n        Entry memory entry = Entry({size: size, code: code, bid: bid});\n        ARB_WASM_CACHE.cacheProgram(program);\n        bids.push(_packBid(bid, index));\n        queueSize += size;\n        if (index == entries.length) {\n            entries.push(entry);\n        } else {\n            entries[index] = entry;\n        }\n        emit InsertBid(code, program, bid, size);\n    }\n\n    /// @dev Clears the entry at the given index\n    function _deleteEntry(uint192 bid, uint64 index) internal {\n        Entry memory entry = entries[index];\n        ARB_WASM_CACHE.evictCodehash(entry.code);\n        queueSize -= entry.size;\n        emit DeleteBid(entry.code, bid, entry.size);\n        delete entries[index];\n    }\n\n    /// @dev Gets the bid and index from a packed bid item\n    function _getBid(uint256 info) internal pure returns (uint192 bid, uint64 index) {\n        bid = uint192(info >> 64);\n        index = uint64(info);\n    }\n\n    /// @dev Creates a packed bid item\n    function _packBid(uint192 bid, uint64 index) internal pure returns (uint256) {\n        return (uint256(bid) << 64) | uint256(index);\n    }\n\n    /// @dev Gets the size of the given program in bytes\n    function _asmSize(bytes32 codehash) internal view returns (uint64) {\n        uint32 size = ARB_WASM.codehashAsmSize(codehash);\n        return uint64(size >= MIN_CODESIZE ? size : MIN_CODESIZE); // pretend it's at least 4Kb\n    }\n\n    /// @dev Determines whether a program is cached\n    function _isCached(bytes32 codehash) internal view returns (bool) {\n        return ARB_WASM_CACHE.codehashIsCached(codehash);\n    }\n}\n"}, "src/challenge/ChallengeLib.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../state/Machine.sol\";\nimport \"../state/GlobalState.sol\";\n\nlibrary ChallengeLib {\n    using MachineLib for Machine;\n    using ChallengeLib for Challenge;\n\n    /// @dev It's assumed that that uninitialzed challenges have mode NONE\n    enum ChallengeMode {\n        NONE,\n        BLOCK,\n        EXECUTION\n    }\n\n    struct Participant {\n        address addr;\n        uint256 timeLeft;\n    }\n\n    struct Challenge {\n        Participant current;\n        Participant next;\n        uint256 lastMoveTimestamp;\n        bytes32 wasmModuleRoot;\n        bytes32 challengeStateHash;\n        uint64 maxInboxMessages;\n        ChallengeMode mode;\n    }\n\n    struct SegmentSelection {\n        uint256 oldSegmentsStart;\n        uint256 oldSegmentsLength;\n        bytes32[] oldSegments;\n        uint256 challengePosition;\n    }\n\n    function timeUsedSinceLastMove(Challenge storage challenge) internal view returns (uint256) {\n        return block.timestamp - challenge.lastMoveTimestamp;\n    }\n\n    function isTimedOut(Challenge storage challenge) internal view returns (bool) {\n        return challenge.timeUsedSinceLastMove() > challenge.current.timeLeft;\n    }\n\n    function extractChallengeSegment(SegmentSelection calldata selection)\n        internal\n        pure\n        returns (uint256 segmentStart, uint256 segmentLength)\n    {\n        uint256 oldChallengeDegree = selection.oldSegments.length - 1;\n        segmentLength = selection.oldSegmentsLength / oldChallengeDegree;\n        // Intentionally done before challengeLength is potentially added to for the final segment\n        segmentStart = selection.oldSegmentsStart + segmentLength * selection.challengePosition;\n        if (selection.challengePosition == selection.oldSegments.length - 2) {\n            segmentLength += selection.oldSegmentsLength % oldChallengeDegree;\n        }\n    }\n\n    function hashChallengeState(\n        uint256 segmentsStart,\n        uint256 segmentsLength,\n        bytes32[] memory segments\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(segmentsStart, segmentsLength, segments));\n    }\n\n    function blockStateHash(MachineStatus status, bytes32 globalStateHash)\n        internal\n        pure\n        returns (bytes32)\n    {\n        if (status == MachineStatus.FINISHED) {\n            return keccak256(abi.encodePacked(\"Block state:\", globalStateHash));\n        } else if (status == MachineStatus.ERRORED) {\n            return keccak256(abi.encodePacked(\"Block state, errored:\", globalStateHash));\n        } else if (status == MachineStatus.TOO_FAR) {\n            return keccak256(abi.encodePacked(\"Block state, too far:\"));\n        } else {\n            revert(\"BAD_BLOCK_STATUS\");\n        }\n    }\n}\n"}, "src/challenge/ChallengeManager.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../libraries/DelegateCallAware.sol\";\nimport \"../osp/IOneStepProofEntry.sol\";\nimport \"../state/GlobalState.sol\";\nimport \"./IChallengeResultReceiver.sol\";\nimport \"./ChallengeLib.sol\";\nimport \"./IChallengeManager.sol\";\n\nimport {NO_CHAL_INDEX} from \"../libraries/Constants.sol\";\n\ncontract ChallengeManager is DelegateCallAware, IChallengeManager {\n    using GlobalStateLib for GlobalState;\n    using MachineLib for Machine;\n    using ChallengeLib for ChallengeLib.Challenge;\n\n    enum ChallengeModeRequirement {\n        ANY,\n        BLOCK,\n        EXECUTION\n    }\n\n    string private constant NO_CHAL = \"NO_CHAL\";\n    uint256 private constant MAX_CHALLENGE_DEGREE = 40;\n\n    uint64 public totalChallengesCreated;\n    mapping(uint256 => ChallengeLib.Challenge) public challenges;\n\n    IChallengeResultReceiver public resultReceiver;\n\n    ISequencerInbox public sequencerInbox;\n    IBridge public bridge;\n    IOneStepProofEntry public osp;\n    mapping(bytes32 => IOneStepProofEntry) public ospCond;\n\n    function challengeInfo(uint64 challengeIndex)\n        external\n        view\n        override\n        returns (ChallengeLib.Challenge memory)\n    {\n        return challenges[challengeIndex];\n    }\n\n    modifier takeTurn(\n        uint64 challengeIndex,\n        ChallengeLib.SegmentSelection calldata selection,\n        ChallengeModeRequirement expectedMode\n    ) {\n        ChallengeLib.Challenge storage challenge = challenges[challengeIndex];\n        require(msg.sender == currentResponder(challengeIndex), \"CHAL_SENDER\");\n        require(!isTimedOut(challengeIndex), \"CHAL_DEADLINE\");\n\n        if (expectedMode == ChallengeModeRequirement.ANY) {\n            require(challenge.mode != ChallengeLib.ChallengeMode.NONE, NO_CHAL);\n        } else if (expectedMode == ChallengeModeRequirement.BLOCK) {\n            require(challenge.mode == ChallengeLib.ChallengeMode.BLOCK, \"CHAL_NOT_BLOCK\");\n        } else if (expectedMode == ChallengeModeRequirement.EXECUTION) {\n            require(challenge.mode == ChallengeLib.ChallengeMode.EXECUTION, \"CHAL_NOT_EXECUTION\");\n        } else {\n            assert(false);\n        }\n\n        require(\n            challenge.challengeStateHash ==\n                ChallengeLib.hashChallengeState(\n                    selection.oldSegmentsStart,\n                    selection.oldSegmentsLength,\n                    selection.oldSegments\n                ),\n            \"BIS_STATE\"\n        );\n        if (\n            selection.oldSegments.length < 2 ||\n            selection.challengePosition >= selection.oldSegments.length - 1\n        ) {\n            revert(\"BAD_CHALLENGE_POS\");\n        }\n\n        _;\n\n        if (challenge.mode == ChallengeLib.ChallengeMode.NONE) {\n            // Early return since challenge must have terminated\n            return;\n        }\n\n        ChallengeLib.Participant memory current = challenge.current;\n        current.timeLeft -= block.timestamp - challenge.lastMoveTimestamp;\n\n        challenge.current = challenge.next;\n        challenge.next = current;\n\n        challenge.lastMoveTimestamp = block.timestamp;\n    }\n\n    function initialize(\n        IChallengeResultReceiver resultReceiver_,\n        ISequencerInbox sequencerInbox_,\n        IBridge bridge_,\n        IOneStepProofEntry osp_\n    ) external override onlyDelegated {\n        require(address(resultReceiver) == address(0), \"ALREADY_INIT\");\n        require(address(resultReceiver_) != address(0), \"NO_RESULT_RECEIVER\");\n        resultReceiver = resultReceiver_;\n        sequencerInbox = sequencerInbox_;\n        bridge = bridge_;\n        osp = osp_;\n    }\n\n    /// @dev A osp breaking change is introduced as part of Stylus upgrade, where the new osp would not support\n    ///      pre-Stylus legacy wasmModuleRoot. To ensure that the new osp is not used for legacy wasmModuleRoot,\n    ///      we introduce a conditional OSP where condRoot should be set to the pre-Stylus root and condOsp should\n    ///      be set to the pre-Stylus osp. The correct value should be handled by the upgrade action contract.\n    function postUpgradeInit(\n        IOneStepProofEntry osp_,\n        bytes32 condRoot,\n        IOneStepProofEntry condOsp\n    ) external onlyDelegated onlyProxyOwner {\n        ospCond[condRoot] = condOsp;\n        osp = osp_;\n    }\n\n    function getOsp(bytes32 wasmModuleRoot) public view returns (IOneStepProofEntry) {\n        IOneStepProofEntry t = ospCond[wasmModuleRoot];\n        if (address(t) == address(0)) {\n            return osp;\n        } else {\n            return t;\n        }\n    }\n\n    function createChallenge(\n        bytes32 wasmModuleRoot_,\n        MachineStatus[2] calldata startAndEndMachineStatuses_,\n        GlobalState[2] calldata startAndEndGlobalStates_,\n        uint64 numBlocks,\n        address asserter_,\n        address challenger_,\n        uint256 asserterTimeLeft_,\n        uint256 challengerTimeLeft_\n    ) external override returns (uint64) {\n        require(msg.sender == address(resultReceiver), \"ONLY_ROLLUP_CHAL\");\n        bytes32[] memory segments = new bytes32[](2);\n        segments[0] = ChallengeLib.blockStateHash(\n            startAndEndMachineStatuses_[0],\n            startAndEndGlobalStates_[0].hash()\n        );\n        segments[1] = ChallengeLib.blockStateHash(\n            startAndEndMachineStatuses_[1],\n            startAndEndGlobalStates_[1].hash()\n        );\n\n        uint64 challengeIndex = ++totalChallengesCreated;\n        // The following is an assertion since it should never be possible, but it's an important invariant\n        assert(challengeIndex != NO_CHAL_INDEX);\n        ChallengeLib.Challenge storage challenge = challenges[challengeIndex];\n        challenge.wasmModuleRoot = wasmModuleRoot_;\n\n        // See validator/assertion.go ExecutionState RequiredBatches() for reasoning\n        uint64 maxInboxMessagesRead = startAndEndGlobalStates_[1].getInboxPosition();\n        if (\n            startAndEndMachineStatuses_[1] == MachineStatus.ERRORED ||\n            startAndEndGlobalStates_[1].getPositionInMessage() > 0\n        ) {\n            maxInboxMessagesRead++;\n        }\n        challenge.maxInboxMessages = maxInboxMessagesRead;\n        challenge.next = ChallengeLib.Participant({addr: asserter_, timeLeft: asserterTimeLeft_});\n        challenge.current = ChallengeLib.Participant({\n            addr: challenger_,\n            timeLeft: challengerTimeLeft_\n        });\n        challenge.lastMoveTimestamp = block.timestamp;\n        challenge.mode = ChallengeLib.ChallengeMode.BLOCK;\n\n        emit InitiatedChallenge(\n            challengeIndex,\n            startAndEndGlobalStates_[0],\n            startAndEndGlobalStates_[1]\n        );\n        completeBisection(challengeIndex, 0, numBlocks, segments);\n        return challengeIndex;\n    }\n\n    /**\n     * @notice Initiate the next round in the bisection by objecting to execution correctness with a bisection\n     * of an execution segment with the same length but a different endpoint. This is either the initial move\n     * or follows another execution objection\n     */\n    function bisectExecution(\n        uint64 challengeIndex,\n        ChallengeLib.SegmentSelection calldata selection,\n        bytes32[] calldata newSegments\n    ) external takeTurn(challengeIndex, selection, ChallengeModeRequirement.ANY) {\n        (uint256 challengeStart, uint256 challengeLength) = ChallengeLib.extractChallengeSegment(\n            selection\n        );\n        require(challengeLength > 1, \"TOO_SHORT\");\n        {\n            uint256 expectedDegree = challengeLength;\n            if (expectedDegree > MAX_CHALLENGE_DEGREE) {\n                expectedDegree = MAX_CHALLENGE_DEGREE;\n            }\n            require(newSegments.length == expectedDegree + 1, \"WRONG_DEGREE\");\n        }\n\n        requireValidBisection(selection, newSegments[0], newSegments[newSegments.length - 1]);\n\n        completeBisection(challengeIndex, challengeStart, challengeLength, newSegments);\n    }\n\n    function challengeExecution(\n        uint64 challengeIndex,\n        ChallengeLib.SegmentSelection calldata selection,\n        MachineStatus[2] calldata machineStatuses,\n        bytes32[2] calldata globalStateHashes,\n        uint256 numSteps\n    ) external takeTurn(challengeIndex, selection, ChallengeModeRequirement.BLOCK) {\n        require(numSteps >= 1, \"CHALLENGE_TOO_SHORT\");\n        require(numSteps <= OneStepProofEntryLib.MAX_STEPS, \"CHALLENGE_TOO_LONG\");\n        requireValidBisection(\n            selection,\n            ChallengeLib.blockStateHash(machineStatuses[0], globalStateHashes[0]),\n            ChallengeLib.blockStateHash(machineStatuses[1], globalStateHashes[1])\n        );\n\n        ChallengeLib.Challenge storage challenge = challenges[challengeIndex];\n        (uint256 executionChallengeAtSteps, uint256 challengeLength) = ChallengeLib\n            .extractChallengeSegment(selection);\n        require(challengeLength == 1, \"TOO_LONG\");\n\n        if (machineStatuses[0] != MachineStatus.FINISHED) {\n            // If the machine is in a halted state, it can't change\n            require(\n                machineStatuses[0] == machineStatuses[1] &&\n                    globalStateHashes[0] == globalStateHashes[1],\n                \"HALTED_CHANGE\"\n            );\n            _currentWin(challengeIndex, ChallengeTerminationType.BLOCK_PROOF);\n            return;\n        }\n\n        if (machineStatuses[1] == MachineStatus.ERRORED) {\n            // If the machine errors, it must return to the previous global state\n            require(globalStateHashes[0] == globalStateHashes[1], \"ERROR_CHANGE\");\n        }\n\n        bytes32[] memory segments = new bytes32[](2);\n        IOneStepProofEntry _osp = getOsp(challenge.wasmModuleRoot);\n        segments[0] = _osp.getStartMachineHash(globalStateHashes[0], challenge.wasmModuleRoot);\n        segments[1] = _osp.getEndMachineHash(machineStatuses[1], globalStateHashes[1]);\n\n        challenge.mode = ChallengeLib.ChallengeMode.EXECUTION;\n\n        completeBisection(challengeIndex, 0, numSteps, segments);\n\n        emit ExecutionChallengeBegun(challengeIndex, executionChallengeAtSteps);\n    }\n\n    function oneStepProveExecution(\n        uint64 challengeIndex,\n        ChallengeLib.SegmentSelection calldata selection,\n        bytes calldata proof\n    ) external takeTurn(challengeIndex, selection, ChallengeModeRequirement.EXECUTION) {\n        ChallengeLib.Challenge storage challenge = challenges[challengeIndex];\n        uint256 challengeStart;\n        {\n            uint256 challengeLength;\n            (challengeStart, challengeLength) = ChallengeLib.extractChallengeSegment(selection);\n            require(challengeLength == 1, \"TOO_LONG\");\n        }\n\n        bytes32 afterHash = getOsp(challenge.wasmModuleRoot).proveOneStep(\n            ExecutionContext({maxInboxMessagesRead: challenge.maxInboxMessages, bridge: bridge}),\n            challengeStart,\n            selection.oldSegments[selection.challengePosition],\n            proof\n        );\n        require(\n            afterHash != selection.oldSegments[selection.challengePosition + 1],\n            \"SAME_OSP_END\"\n        );\n\n        emit OneStepProofCompleted(challengeIndex);\n        _currentWin(challengeIndex, ChallengeTerminationType.EXECUTION_PROOF);\n    }\n\n    function timeout(uint64 challengeIndex) external override {\n        require(challenges[challengeIndex].mode != ChallengeLib.ChallengeMode.NONE, NO_CHAL);\n        require(isTimedOut(challengeIndex), \"TIMEOUT_DEADLINE\");\n        _nextWin(challengeIndex, ChallengeTerminationType.TIMEOUT);\n    }\n\n    function clearChallenge(uint64 challengeIndex) external override {\n        require(msg.sender == address(resultReceiver), \"NOT_RES_RECEIVER\");\n        require(challenges[challengeIndex].mode != ChallengeLib.ChallengeMode.NONE, NO_CHAL);\n        delete challenges[challengeIndex];\n        emit ChallengeEnded(challengeIndex, ChallengeTerminationType.CLEARED);\n    }\n\n    function currentResponder(uint64 challengeIndex) public view override returns (address) {\n        return challenges[challengeIndex].current.addr;\n    }\n\n    function isTimedOut(uint64 challengeIndex) public view virtual override returns (bool) {\n        return challenges[challengeIndex].isTimedOut();\n    }\n\n    function requireValidBisection(\n        ChallengeLib.SegmentSelection calldata selection,\n        bytes32 startHash,\n        bytes32 endHash\n    ) private pure {\n        require(selection.oldSegments[selection.challengePosition] == startHash, \"WRONG_START\");\n        require(selection.oldSegments[selection.challengePosition + 1] != endHash, \"SAME_END\");\n    }\n\n    function completeBisection(\n        uint64 challengeIndex,\n        uint256 challengeStart,\n        uint256 challengeLength,\n        bytes32[] memory newSegments\n    ) private {\n        assert(challengeLength >= 1);\n        assert(newSegments.length >= 2);\n\n        bytes32 challengeStateHash = ChallengeLib.hashChallengeState(\n            challengeStart,\n            challengeLength,\n            newSegments\n        );\n        challenges[challengeIndex].challengeStateHash = challengeStateHash;\n\n        emit Bisected(\n            challengeIndex,\n            challengeStateHash,\n            challengeStart,\n            challengeLength,\n            newSegments\n        );\n    }\n\n    /// @dev This function causes the mode of the challenge to be set to NONE by deleting the challenge\n    function _nextWin(uint64 challengeIndex, ChallengeTerminationType reason) private {\n        ChallengeLib.Challenge storage challenge = challenges[challengeIndex];\n        address next = challenge.next.addr;\n        address current = challenge.current.addr;\n        delete challenges[challengeIndex];\n        resultReceiver.completeChallenge(challengeIndex, next, current);\n        emit ChallengeEnded(challengeIndex, reason);\n    }\n\n    /**\n     * @dev this currently sets a challenge hash of 0 - no move is possible for the next participant to progress the\n     * state. It is assumed that wherever this function is consumed, the turn is then adjusted for the opposite party\n     * to timeout. This is done as a safety measure so challenges can only be resolved by timeouts during mainnet beta.\n     */\n    function _currentWin(\n        uint64 challengeIndex,\n        ChallengeTerminationType /* reason */\n    ) private {\n        ChallengeLib.Challenge storage challenge = challenges[challengeIndex];\n        challenge.challengeStateHash = bytes32(0);\n\n        //        address next = challenge.next.addr;\n        //        address current = challenge.current.addr;\n        //        delete challenges[challengeIndex];\n        //        resultReceiver.completeChallenge(challengeIndex, current, next);\n        //        emit ChallengeEnded(challengeIndex, reason);\n    }\n}\n"}, "src/challenge/IChallengeManager.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../state/Machine.sol\";\nimport \"../bridge/IBridge.sol\";\nimport \"../bridge/ISequencerInbox.sol\";\nimport \"../osp/IOneStepProofEntry.sol\";\n\nimport \"./IChallengeResultReceiver.sol\";\n\nimport \"./ChallengeLib.sol\";\n\ninterface IChallengeManager {\n    enum ChallengeTerminationType {\n        TIMEOUT,\n        BLOCK_PROOF,\n        EXECUTION_PROOF,\n        CLEARED\n    }\n\n    event InitiatedChallenge(\n        uint64 indexed challengeIndex,\n        GlobalState startState,\n        GlobalState endState\n    );\n\n    event Bisected(\n        uint64 indexed challengeIndex,\n        bytes32 indexed challengeRoot,\n        uint256 challengedSegmentStart,\n        uint256 challengedSegmentLength,\n        bytes32[] chainHashes\n    );\n\n    event ExecutionChallengeBegun(uint64 indexed challengeIndex, uint256 blockSteps);\n    event OneStepProofCompleted(uint64 indexed challengeIndex);\n\n    event ChallengeEnded(uint64 indexed challengeIndex, ChallengeTerminationType kind);\n\n    function initialize(\n        IChallengeResultReceiver resultReceiver_,\n        ISequencerInbox sequencerInbox_,\n        IBridge bridge_,\n        IOneStepProofEntry osp_\n    ) external;\n\n    function postUpgradeInit(\n        IOneStepProofEntry osp_,\n        bytes32 condRoot,\n        IOneStepProofEntry condOsp\n    ) external;\n\n    /// @notice Get the default osp, which is used for all wasm module roots that don't have a conditional OSP set\n    ///         Use getOsp(wasmModuleRoot) to get the OSP for a specific wasm module root\n    function osp() external view returns (IOneStepProofEntry);\n\n    /// @notice Get the OSP for a given wasm module root\n    function getOsp(bytes32 wasmModuleRoot) external view returns (IOneStepProofEntry);\n\n    function createChallenge(\n        bytes32 wasmModuleRoot_,\n        MachineStatus[2] calldata startAndEndMachineStatuses_,\n        GlobalState[2] calldata startAndEndGlobalStates_,\n        uint64 numBlocks,\n        address asserter_,\n        address challenger_,\n        uint256 asserterTimeLeft_,\n        uint256 challengerTimeLeft_\n    ) external returns (uint64);\n\n    function challengeInfo(uint64 challengeIndex_)\n        external\n        view\n        returns (ChallengeLib.Challenge memory);\n\n    function currentResponder(uint64 challengeIndex) external view returns (address);\n\n    function isTimedOut(uint64 challengeIndex) external view returns (bool);\n\n    function clearChallenge(uint64 challengeIndex_) external;\n\n    function timeout(uint64 challengeIndex_) external;\n}\n"}, "src/challenge/IChallengeResultReceiver.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\ninterface IChallengeResultReceiver {\n    function completeChallenge(\n        uint256 challengeIndex,\n        address winner,\n        address loser\n    ) external;\n}\n"}, "src/libraries/AddressAliasHelper.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nlibrary AddressAliasHelper {\n    uint160 internal constant OFFSET = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\n    /// the inbox to the msg.sender viewed in the L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        unchecked {\n            l2Address = address(uint160(l1Address) + OFFSET);\n        }\n    }\n\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\n    /// address in the L1 that submitted a tx to the inbox\n    /// @param l2Address L2 address as viewed in msg.sender\n    /// @return l1Address the address in the L1 that triggered the tx to L2\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        unchecked {\n            l1Address = address(uint160(l2Address) - OFFSET);\n        }\n    }\n}\n"}, "src/libraries/AdminFallbackProxy.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/proxy/Proxy.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\n\n/// @notice An extension to OZ's ERC1967Upgrade implementation to support two logic contracts\nabstract contract DoubleLogicERC1967Upgrade is ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.implementation.secondary\" subtracted by 1\n    bytes32 internal constant _IMPLEMENTATION_SECONDARY_SLOT =\n        0x2b1dbce74324248c222f0ec2d5ed7bd323cfc425b336f0253c5ccfda7265546d;\n\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback.secondary\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SECONDARY_SLOT =\n        0x49bd798cd84788856140a4cd5030756b4d08a9e4d55db725ec195f232d262a89;\n\n    /**\n     * @dev Emitted when the secondary implementation is upgraded.\n     */\n    event UpgradedSecondary(address indexed implementation);\n\n    /**\n     * @dev Returns the current secondary implementation address.\n     */\n    function _getSecondaryImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SECONDARY_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setSecondaryImplementation(address newImplementation) private {\n        require(\n            Address.isContract(newImplementation),\n            \"ERC1967: new secondary implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SECONDARY_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform secondary implementation upgrade\n     *\n     * Emits an {UpgradedSecondary} event.\n     */\n    function _upgradeSecondaryTo(address newImplementation) internal {\n        _setSecondaryImplementation(newImplementation);\n        emit UpgradedSecondary(newImplementation);\n    }\n\n    /**\n     * @dev Perform secondary implementation upgrade with additional setup call.\n     *\n     * Emits an {UpgradedSecondary} event.\n     */\n    function _upgradeSecondaryToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeSecondaryTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform secondary implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {UpgradedSecondary} event.\n     */\n    function _upgradeSecondaryToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SECONDARY_SLOT).value) {\n            _setSecondaryImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(\n                    slot == _IMPLEMENTATION_SECONDARY_SLOT,\n                    \"ERC1967Upgrade: unsupported secondary proxiableUUID\"\n                );\n            } catch {\n                revert(\"ERC1967Upgrade: new secondary implementation is not UUPS\");\n            }\n            _upgradeSecondaryToAndCall(newImplementation, data, forceCall);\n        }\n    }\n}\n\n/// @notice similar to TransparentUpgradeableProxy but allows the admin to fallback to a separate logic contract using DoubleLogicERC1967Upgrade\n/// @dev this follows the UUPS pattern for upgradeability - read more at https://github.com/OpenZeppelin/openzeppelin-contracts/tree/v4.5.0/contracts/proxy#transparent-vs-uups-proxies\ncontract AdminFallbackProxy is Proxy, DoubleLogicERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `adminLogic` and a secondary\n     * logic implementation specified by `userLogic`\n     *\n     * Only the `adminAddr` is able to use the `adminLogic` functions\n     * All other addresses can interact with the `userLogic` functions\n     */\n    function _initialize(\n        address adminLogic,\n        bytes memory adminData,\n        address userLogic,\n        bytes memory userData,\n        address adminAddr\n    ) internal {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        assert(\n            _IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1)\n        );\n        assert(\n            _IMPLEMENTATION_SECONDARY_SLOT ==\n                bytes32(uint256(keccak256(\"eip1967.proxy.implementation.secondary\")) - 1)\n        );\n        _changeAdmin(adminAddr);\n        _upgradeToAndCall(adminLogic, adminData, false);\n        _upgradeSecondaryToAndCall(userLogic, userData, false);\n    }\n\n    /// @inheritdoc Proxy\n    function _implementation() internal view override returns (address) {\n        require(msg.data.length >= 4, \"NO_FUNC_SIG\");\n        // if the sender is the proxy's admin, delegate to admin logic\n        // if the admin is disabled, all calls will be forwarded to user logic\n        // admin affordances can be disabled by setting to a no-op smart contract\n        // since there is a check for contract code before updating the value\n        address target = _getAdmin() != msg.sender\n            ? DoubleLogicERC1967Upgrade._getSecondaryImplementation()\n            : ERC1967Upgrade._getImplementation();\n        // implementation setters do an existence check, but we protect against selfdestructs this way\n        require(Address.isContract(target), \"TARGET_NOT_CONTRACT\");\n        return target;\n    }\n\n    /**\n     * @dev unlike transparent upgradeable proxies, this does allow the admin to fallback to a logic contract\n     * the admin is expected to interact only with the primary logic contract, which handles contract\n     * upgrades using the UUPS approach\n     */\n    function _beforeFallback() internal override {\n        super._beforeFallback();\n    }\n}\n"}, "src/libraries/ArbitrumChecker.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../precompiles/ArbSys.sol\";\n\nlibrary ArbitrumChecker {\n    function runningOnArbitrum() internal view returns (bool) {\n        (bool ok, bytes memory data) = address(100).staticcall(\n            abi.encodeWithSelector(ArbSys.arbOSVersion.selector)\n        );\n        return ok && data.length == 32;\n    }\n}\n"}, "src/libraries/Constants.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nuint64 constant NO_CHAL_INDEX = 0;\n\n// Expected seconds per block in Ethereum PoS\nuint256 constant ETH_POS_BLOCK_TIME = 12;\n\n/// @dev If nativeTokenDecimals is different than 18 decimals, bridge will inflate or deflate token amounts\n///      when depositing to child chain to match 18 decimal denomination. Opposite process happens when\n///      amount is withdrawn back to parent chain. In order to avoid uint256 overflows we restrict max number\n///      of decimals to 36 which should be enough for most practical use-cases.\nuint8 constant MAX_ALLOWED_NATIVE_TOKEN_DECIMALS = uint8(36);\n\n/// @dev Max amount of erc20 native token that can deposit when upscaling is required (i.e. < 18 decimals)\n///      Amounts higher than this would risk uint256 overflows when adjusting decimals. Considering\n///      18 decimals are 60 bits, we choose 2^192 as the limit which equals to ~6.3*10^57 weis of token\nuint256 constant MAX_UPSCALE_AMOUNT = type(uint192).max;\n"}, "src/libraries/CryptographyPrimitives.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\n///      This algorithm has been extracted from the implementation of smart pool (https://github.com/smartpool)\nlibrary CryptographyPrimitives {\n    // WARNING: This function has the keccak state in a weird order.\n    // If the normal Keccak state is [0, 1, 2, 3, 4, 5, 6, ..., 24]\n    // this function has its state as [0, 5, 10, 15, 20, 1, 6, 11, ..., 24]\n    function keccakF(uint256[25] memory a) internal pure returns (uint256[25] memory) {\n        uint256[5] memory c;\n        uint256[5] memory d;\n        //uint D_0; uint D_1; uint D_2; uint D_3; uint D_4;\n        uint256[25] memory b;\n\n        uint256[24] memory rc = [\n            uint256(0x0000000000000001),\n            0x0000000000008082,\n            0x800000000000808A,\n            0x8000000080008000,\n            0x000000000000808B,\n            0x0000000080000001,\n            0x8000000080008081,\n            0x8000000000008009,\n            0x000000000000008A,\n            0x0000000000000088,\n            0x0000000080008009,\n            0x000000008000000A,\n            0x000000008000808B,\n            0x800000000000008B,\n            0x8000000000008089,\n            0x8000000000008003,\n            0x8000000000008002,\n            0x8000000000000080,\n            0x000000000000800A,\n            0x800000008000000A,\n            0x8000000080008081,\n            0x8000000000008080,\n            0x0000000080000001,\n            0x8000000080008008\n        ];\n\n        unchecked {\n            for (uint256 i = 0; i < 24; i++) {\n                /*\n                for( x = 0 ; x < 5 ; x++ ) {\n                    C[x] = A[5*x]^A[5*x+1]^A[5*x+2]^A[5*x+3]^A[5*x+4];\n                }*/\n\n                c[0] = a[0] ^ a[1] ^ a[2] ^ a[3] ^ a[4];\n                c[1] = a[5] ^ a[6] ^ a[7] ^ a[8] ^ a[9];\n                c[2] = a[10] ^ a[11] ^ a[12] ^ a[13] ^ a[14];\n                c[3] = a[15] ^ a[16] ^ a[17] ^ a[18] ^ a[19];\n                c[4] = a[20] ^ a[21] ^ a[22] ^ a[23] ^ a[24];\n\n                /*\n                for( x = 0 ; x < 5 ; x++ ) {\n                    D[x] = C[(x+4)%5]^((C[(x+1)%5] * 2)&0xffffffffffffffff | (C[(x+1)%5]/(2**63)));\n                }*/\n\n                d[0] = c[4] ^ (((c[1] * 2) & 0xffffffffffffffff) | (c[1] / (2**63)));\n                d[1] = c[0] ^ (((c[2] * 2) & 0xffffffffffffffff) | (c[2] / (2**63)));\n                d[2] = c[1] ^ (((c[3] * 2) & 0xffffffffffffffff) | (c[3] / (2**63)));\n                d[3] = c[2] ^ (((c[4] * 2) & 0xffffffffffffffff) | (c[4] / (2**63)));\n                d[4] = c[3] ^ (((c[0] * 2) & 0xffffffffffffffff) | (c[0] / (2**63)));\n\n                /*\n                for( x = 0 ; x < 5 ; x++ ) {\n                    for( y = 0 ; y < 5 ; y++ ) {\n                        A[5*x+y] = A[5*x+y] ^ D[x];\n                    }\n                }*/\n\n                a[0] = a[0] ^ d[0];\n                a[1] = a[1] ^ d[0];\n                a[2] = a[2] ^ d[0];\n                a[3] = a[3] ^ d[0];\n                a[4] = a[4] ^ d[0];\n                a[5] = a[5] ^ d[1];\n                a[6] = a[6] ^ d[1];\n                a[7] = a[7] ^ d[1];\n                a[8] = a[8] ^ d[1];\n                a[9] = a[9] ^ d[1];\n                a[10] = a[10] ^ d[2];\n                a[11] = a[11] ^ d[2];\n                a[12] = a[12] ^ d[2];\n                a[13] = a[13] ^ d[2];\n                a[14] = a[14] ^ d[2];\n                a[15] = a[15] ^ d[3];\n                a[16] = a[16] ^ d[3];\n                a[17] = a[17] ^ d[3];\n                a[18] = a[18] ^ d[3];\n                a[19] = a[19] ^ d[3];\n                a[20] = a[20] ^ d[4];\n                a[21] = a[21] ^ d[4];\n                a[22] = a[22] ^ d[4];\n                a[23] = a[23] ^ d[4];\n                a[24] = a[24] ^ d[4];\n\n                /*Rho and pi steps*/\n                b[0] = a[0];\n                b[8] = (((a[1] * (2**36)) & 0xffffffffffffffff) | (a[1] / (2**28)));\n                b[11] = (((a[2] * (2**3)) & 0xffffffffffffffff) | (a[2] / (2**61)));\n                b[19] = (((a[3] * (2**41)) & 0xffffffffffffffff) | (a[3] / (2**23)));\n                b[22] = (((a[4] * (2**18)) & 0xffffffffffffffff) | (a[4] / (2**46)));\n                b[2] = (((a[5] * (2**1)) & 0xffffffffffffffff) | (a[5] / (2**63)));\n                b[5] = (((a[6] * (2**44)) & 0xffffffffffffffff) | (a[6] / (2**20)));\n                b[13] = (((a[7] * (2**10)) & 0xffffffffffffffff) | (a[7] / (2**54)));\n                b[16] = (((a[8] * (2**45)) & 0xffffffffffffffff) | (a[8] / (2**19)));\n                b[24] = (((a[9] * (2**2)) & 0xffffffffffffffff) | (a[9] / (2**62)));\n                b[4] = (((a[10] * (2**62)) & 0xffffffffffffffff) | (a[10] / (2**2)));\n                b[7] = (((a[11] * (2**6)) & 0xffffffffffffffff) | (a[11] / (2**58)));\n                b[10] = (((a[12] * (2**43)) & 0xffffffffffffffff) | (a[12] / (2**21)));\n                b[18] = (((a[13] * (2**15)) & 0xffffffffffffffff) | (a[13] / (2**49)));\n                b[21] = (((a[14] * (2**61)) & 0xffffffffffffffff) | (a[14] / (2**3)));\n                b[1] = (((a[15] * (2**28)) & 0xffffffffffffffff) | (a[15] / (2**36)));\n                b[9] = (((a[16] * (2**55)) & 0xffffffffffffffff) | (a[16] / (2**9)));\n                b[12] = (((a[17] * (2**25)) & 0xffffffffffffffff) | (a[17] / (2**39)));\n                b[15] = (((a[18] * (2**21)) & 0xffffffffffffffff) | (a[18] / (2**43)));\n                b[23] = (((a[19] * (2**56)) & 0xffffffffffffffff) | (a[19] / (2**8)));\n                b[3] = (((a[20] * (2**27)) & 0xffffffffffffffff) | (a[20] / (2**37)));\n                b[6] = (((a[21] * (2**20)) & 0xffffffffffffffff) | (a[21] / (2**44)));\n                b[14] = (((a[22] * (2**39)) & 0xffffffffffffffff) | (a[22] / (2**25)));\n                b[17] = (((a[23] * (2**8)) & 0xffffffffffffffff) | (a[23] / (2**56)));\n                b[20] = (((a[24] * (2**14)) & 0xffffffffffffffff) | (a[24] / (2**50)));\n\n                /*Xi state*/\n                /*\n                for( x = 0 ; x < 5 ; x++ ) {\n                    for( y = 0 ; y < 5 ; y++ ) {\n                        A[5*x+y] = B[5*x+y]^((~B[5*((x+1)%5)+y]) & B[5*((x+2)%5)+y]);\n                    }\n                }*/\n\n                a[0] = b[0] ^ ((~b[5]) & b[10]);\n                a[1] = b[1] ^ ((~b[6]) & b[11]);\n                a[2] = b[2] ^ ((~b[7]) & b[12]);\n                a[3] = b[3] ^ ((~b[8]) & b[13]);\n                a[4] = b[4] ^ ((~b[9]) & b[14]);\n                a[5] = b[5] ^ ((~b[10]) & b[15]);\n                a[6] = b[6] ^ ((~b[11]) & b[16]);\n                a[7] = b[7] ^ ((~b[12]) & b[17]);\n                a[8] = b[8] ^ ((~b[13]) & b[18]);\n                a[9] = b[9] ^ ((~b[14]) & b[19]);\n                a[10] = b[10] ^ ((~b[15]) & b[20]);\n                a[11] = b[11] ^ ((~b[16]) & b[21]);\n                a[12] = b[12] ^ ((~b[17]) & b[22]);\n                a[13] = b[13] ^ ((~b[18]) & b[23]);\n                a[14] = b[14] ^ ((~b[19]) & b[24]);\n                a[15] = b[15] ^ ((~b[20]) & b[0]);\n                a[16] = b[16] ^ ((~b[21]) & b[1]);\n                a[17] = b[17] ^ ((~b[22]) & b[2]);\n                a[18] = b[18] ^ ((~b[23]) & b[3]);\n                a[19] = b[19] ^ ((~b[24]) & b[4]);\n                a[20] = b[20] ^ ((~b[0]) & b[5]);\n                a[21] = b[21] ^ ((~b[1]) & b[6]);\n                a[22] = b[22] ^ ((~b[2]) & b[7]);\n                a[23] = b[23] ^ ((~b[3]) & b[8]);\n                a[24] = b[24] ^ ((~b[4]) & b[9]);\n\n                /*Last step*/\n                a[0] = a[0] ^ rc[i];\n            }\n        }\n\n        return a;\n    }\n\n    function rightRotate(uint32 x, uint32 n) internal pure returns (uint32) {\n        return ((x) >> (n)) | ((x) << (32 - (n)));\n    }\n\n    function ch(\n        uint32 e,\n        uint32 f,\n        uint32 g\n    ) internal pure returns (uint32) {\n        return ((e & f) ^ ((~e) & g));\n    }\n\n    // SHA256 compression function that operates on a 512 bit chunk\n    // Note that the input must be padded by the caller\n    // For the initial chunk, the initial values from the SHA256 spec should be passed in as hashState\n    // For subsequent rounds, hashState is the output from the previous round\n    function sha256Block(uint256[2] memory inputChunk, uint256 hashState)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            uint32[64] memory k = [\n                0x428a2f98,\n                0x71374491,\n                0xb5c0fbcf,\n                0xe9b5dba5,\n                0x3956c25b,\n                0x59f111f1,\n                0x923f82a4,\n                0xab1c5ed5,\n                0xd807aa98,\n                0x12835b01,\n                0x243185be,\n                0x550c7dc3,\n                0x72be5d74,\n                0x80deb1fe,\n                0x9bdc06a7,\n                0xc19bf174,\n                0xe49b69c1,\n                0xefbe4786,\n                0x0fc19dc6,\n                0x240ca1cc,\n                0x2de92c6f,\n                0x4a7484aa,\n                0x5cb0a9dc,\n                0x76f988da,\n                0x983e5152,\n                0xa831c66d,\n                0xb00327c8,\n                0xbf597fc7,\n                0xc6e00bf3,\n                0xd5a79147,\n                0x06ca6351,\n                0x14292967,\n                0x27b70a85,\n                0x2e1b2138,\n                0x4d2c6dfc,\n                0x53380d13,\n                0x650a7354,\n                0x766a0abb,\n                0x81c2c92e,\n                0x92722c85,\n                0xa2bfe8a1,\n                0xa81a664b,\n                0xc24b8b70,\n                0xc76c51a3,\n                0xd192e819,\n                0xd6990624,\n                0xf40e3585,\n                0x106aa070,\n                0x19a4c116,\n                0x1e376c08,\n                0x2748774c,\n                0x34b0bcb5,\n                0x391c0cb3,\n                0x4ed8aa4a,\n                0x5b9cca4f,\n                0x682e6ff3,\n                0x748f82ee,\n                0x78a5636f,\n                0x84c87814,\n                0x8cc70208,\n                0x90befffa,\n                0xa4506ceb,\n                0xbef9a3f7,\n                0xc67178f2\n            ];\n\n            uint32[64] memory w;\n            uint32 i;\n            for (i = 0; i < 8; i++) {\n                w[i] = uint32(inputChunk[0] >> (224 - (32 * i)));\n                w[i + 8] = uint32(inputChunk[1] >> (224 - (32 * i)));\n            }\n\n            uint32 s0;\n            uint32 s1;\n            for (i = 16; i < 64; i++) {\n                s0 = rightRotate(w[i - 15], 7) ^ rightRotate(w[i - 15], 18) ^ (w[i - 15] >> 3);\n\n                s1 = rightRotate(w[i - 2], 17) ^ rightRotate(w[i - 2], 19) ^ (w[i - 2] >> 10);\n                w[i] = w[i - 16] + s0 + w[i - 7] + s1;\n            }\n\n            uint32[8] memory state;\n\n            for (i = 0; i < 8; i++) {\n                state[i] = uint32(hashState >> (224 - (32 * i)));\n            }\n\n            uint32 temp1;\n            uint32 temp2;\n            uint32 maj;\n\n            for (i = 0; i < 64; i++) {\n                s1 =\n                    rightRotate(state[4], 6) ^\n                    rightRotate(state[4], 11) ^\n                    rightRotate(state[4], 25);\n                temp1 = state[7] + s1 + ch(state[4], state[5], state[6]) + k[i] + w[i];\n                s0 =\n                    rightRotate(state[0], 2) ^\n                    rightRotate(state[0], 13) ^\n                    rightRotate(state[0], 22);\n\n                maj = (state[0] & (state[1] ^ state[2])) ^ (state[1] & state[2]);\n                temp2 = s0 + maj;\n\n                state[7] = state[6];\n                state[6] = state[5];\n                state[5] = state[4];\n                state[4] = state[3] + temp1;\n                state[3] = state[2];\n                state[2] = state[1];\n                state[1] = state[0];\n                state[0] = temp1 + temp2;\n            }\n\n            for (i = 0; i < 8; i++) {\n                state[i] += uint32(hashState >> (224 - (32 * i)));\n            }\n\n            uint256 result;\n\n            for (i = 0; i < 8; i++) {\n                result |= (uint256(state[i]) << (224 - (32 * i)));\n            }\n\n            return result;\n        }\n    }\n}\n"}, "src/libraries/DecimalsConverterHelper.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nlibrary DecimalsConverterHelper {\n    /// @notice generic function for mapping amount from one decimal denomination to another\n    /// @dev Ie. let's say amount is 752. If token has 16 decimals and is being adjusted to\n    ///      18 decimals then amount will be 75200. If token has 20 decimals adjusted amount\n    ///      is 7. If token uses no decimals converted amount is 752*10^18.\n    ///      When amount is adjusted from 18 decimals back to native token decimals, opposite\n    ///      process is performed.\n    /// @param amount amount to convert\n    /// @param decimalsIn current decimals\n    /// @param decimalsOut target decimals\n    /// @return amount converted to 'decimalsOut' decimals\n    function adjustDecimals(\n        uint256 amount,\n        uint8 decimalsIn,\n        uint8 decimalsOut\n    ) internal pure returns (uint256) {\n        if (decimalsIn == decimalsOut) {\n            return amount;\n        } else if (decimalsIn < decimalsOut) {\n            return amount * 10**(decimalsOut - decimalsIn);\n        } else {\n            return amount / 10**(decimalsIn - decimalsOut);\n        }\n    }\n}\n"}, "src/libraries/DelegateCallAware.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport {NotOwner} from \"./Error.sol\";\n\n/// @dev A stateless contract that allows you to infer if the current call has been delegated or not\n/// Pattern used here is from UUPS implementation by the OpenZeppelin team\nabstract contract DelegateCallAware {\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegate call. This allows a function to be\n     * callable on the proxy contract but not on the logic contract.\n     */\n    modifier onlyDelegated() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"Function must not be called through delegatecall\");\n        _;\n    }\n\n    /// @dev Check that msg.sender is the current EIP 1967 proxy admin\n    modifier onlyProxyOwner() {\n        // Storage slot with the admin of the proxy contract\n        // This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1\n        bytes32 slot = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n        address admin;\n        assembly {\n            admin := sload(slot)\n        }\n        if (msg.sender != admin) revert NotOwner(msg.sender, admin);\n        _;\n    }\n}\n"}, "src/libraries/DoubleLogicUUPSUpgradeable.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport {DoubleLogicERC1967Upgrade} from \"./AdminFallbackProxy.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\n\n/// @notice An extension to OZ's UUPSUpgradeable contract to be used for handling UUPS upgrades with a DoubleLogicERC1967Upgrade proxy\n///         The should be used in the primary implementation slot of the DoubleLogicUUPS proxy\n/// @dev upgrades should be handles by the primary logic contract in order to pass the `onlyProxy` check\nabstract contract DoubleLogicUUPSUpgradeable is UUPSUpgradeable, DoubleLogicERC1967Upgrade {\n    /// @inheritdoc UUPSUpgradeable\n    function proxiableUUID() external view override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the secondary contract. Called by\n     * {upgradeSecondaryTo} and {upgradeSecondaryToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeSecondaryUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeSecondaryUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Upgrade the secondary implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeSecondaryUpgrade}.\n     *\n     * Emits an {UpgradedSecondary} event.\n     */\n    function upgradeSecondaryTo(address newImplementation) external onlyProxy {\n        _authorizeSecondaryUpgrade(newImplementation);\n        _upgradeSecondaryToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the secondary implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeSecondaryUpgrade}.\n     *\n     * Emits an {UpgradedSecondary} event.\n     */\n    function upgradeSecondaryToAndCall(address newImplementation, bytes memory data)\n        external\n        payable\n        onlyProxy\n    {\n        _authorizeSecondaryUpgrade(newImplementation);\n        _upgradeSecondaryToAndCallUUPS(newImplementation, data, true);\n    }\n}\n"}, "src/libraries/Error.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\n/// @dev Init was already called\nerror AlreadyInit();\n\n/// @dev Init was called with param set to zero that must be nonzero\nerror HadZeroInit();\n\n/// @dev Thrown when post upgrade init validation fails\nerror BadPostUpgradeInit();\n\n/// @dev Thrown when non owner tries to access an only-owner function\n/// @param sender The msg.sender who is not the owner\n/// @param owner The owner address\nerror NotOwner(address sender, address owner);\n\n/// @dev Thrown when an address that is not the rollup tries to call an only-rollup function\n/// @param sender The sender who is not the rollup\n/// @param rollup The rollup address authorized to call this function\nerror NotRollup(address sender, address rollup);\n\n/// @dev Thrown when the contract was not called directly from the origin ie msg.sender != tx.origin\nerror NotOrigin();\n\n/// @dev Provided data was too large\n/// @param dataLength The length of the data that is too large\n/// @param maxDataLength The max length the data can be\nerror DataTooLarge(uint256 dataLength, uint256 maxDataLength);\n\n/// @dev The provided is not a contract and was expected to be\n/// @param addr The adddress in question\nerror NotContract(address addr);\n\n/// @dev The merkle proof provided was too long\n/// @param actualLength The length of the merkle proof provided\n/// @param maxProofLength The max length a merkle proof can have\nerror MerkleProofTooLong(uint256 actualLength, uint256 maxProofLength);\n\n/// @dev Thrown when an un-authorized address tries to access an admin function\n/// @param sender The un-authorized sender\n/// @param rollup The rollup, which would be authorized\n/// @param owner The rollup's owner, which would be authorized\nerror NotRollupOrOwner(address sender, address rollup, address owner);\n\n// Bridge Errors\n\n/// @dev Thrown when an un-authorized address tries to access an only-inbox function\n/// @param sender The un-authorized sender\nerror NotDelayedInbox(address sender);\n\n/// @dev Thrown when an un-authorized address tries to access an only-sequencer-inbox function\n/// @param sender The un-authorized sender\nerror NotSequencerInbox(address sender);\n\n/// @dev Thrown when an un-authorized address tries to access an only-outbox function\n/// @param sender The un-authorized sender\nerror NotOutbox(address sender);\n\n/// @dev the provided outbox address isn't valid\n/// @param outbox address of outbox being set\nerror InvalidOutboxSet(address outbox);\n\n/// @dev The provided token address isn't valid\n/// @param token address of token being set\nerror InvalidTokenSet(address token);\n\n/// @dev Call to this specific address is not allowed\n/// @param target address of the call receiver\nerror CallTargetNotAllowed(address target);\n\n/// @dev Call that changes the balance of ERC20Bridge is not allowed\nerror CallNotAllowed();\n\n// Inbox Errors\n\n/// @dev msg.value sent to the inbox isn't high enough\nerror InsufficientValue(uint256 expected, uint256 actual);\n\n/// @dev submission cost provided isn't enough to create retryable ticket\nerror InsufficientSubmissionCost(uint256 expected, uint256 actual);\n\n/// @dev address not allowed to interact with the given contract\nerror NotAllowedOrigin(address origin);\n\n/// @dev used to convey retryable tx data in eth calls without requiring a tx trace\n/// this follows a pattern similar to EIP-3668 where reverts surface call information\nerror RetryableData(\n    address from,\n    address to,\n    uint256 l2CallValue,\n    uint256 deposit,\n    uint256 maxSubmissionCost,\n    address excessFeeRefundAddress,\n    address callValueRefundAddress,\n    uint256 gasLimit,\n    uint256 maxFeePerGas,\n    bytes data\n);\n\n/// @dev Thrown when a L1 chainId fork is detected\nerror L1Forked();\n\n/// @dev Thrown when a L1 chainId fork is not detected\nerror NotForked();\n\n/// @dev The provided gasLimit is larger than uint64\nerror GasLimitTooLarge();\n\n/// @dev The provided amount cannot be adjusted to 18 decimals due to overflow\nerror AmountTooLarge(uint256 amount);\n\n/// @dev Number of native token's decimals is restricted to enable conversions to 18 decimals\nerror NativeTokenDecimalsTooLarge(uint256 decimals);\n\n// Outbox Errors\n\n/// @dev The provided proof was too long\n/// @param proofLength The length of the too-long proof\nerror ProofTooLong(uint256 proofLength);\n\n/// @dev The output index was greater than the maximum\n/// @param index The output index\n/// @param maxIndex The max the index could be\nerror PathNotMinimal(uint256 index, uint256 maxIndex);\n\n/// @dev The calculated root does not exist\n/// @param root The calculated root\nerror UnknownRoot(bytes32 root);\n\n/// @dev The record has already been spent\n/// @param index The index of the spent record\nerror AlreadySpent(uint256 index);\n\n/// @dev A call to the bridge failed with no return data\nerror BridgeCallFailed();\n\n// Sequencer Inbox Errors\n\n/// @dev Thrown when someone attempts to read fewer messages than have already been read\nerror DelayedBackwards();\n\n/// @dev Thrown when someone attempts to read more messages than exist\nerror DelayedTooFar();\n\n/// @dev Force include can only read messages more blocks old than the delay period\nerror ForceIncludeBlockTooSoon();\n\n/// @dev Force include can only read messages more seconds old than the delay period\nerror ForceIncludeTimeTooSoon();\n\n/// @dev The message provided did not match the hash in the delayed inbox\nerror IncorrectMessagePreimage();\n\n/// @dev This can only be called by the batch poster\nerror NotBatchPoster();\n\n/// @dev The sequence number provided to this message was inconsistent with the number of batches already included\nerror BadSequencerNumber(uint256 stored, uint256 received);\n\n/// @dev The sequence message number provided to this message was inconsistent with the previous one\nerror BadSequencerMessageNumber(uint256 stored, uint256 received);\n\n/// @dev Tried to create an already valid Data Availability Service keyset\nerror AlreadyValidDASKeyset(bytes32);\n\n/// @dev Tried to use or invalidate an already invalid Data Availability Service keyset\nerror NoSuchKeyset(bytes32);\n\n/// @dev Thrown when the provided address is not the designated batch poster manager\nerror NotBatchPosterManager(address);\n\n/// @dev Thrown when a data blob feature is attempted to be used on a chain that doesnt support it\nerror DataBlobsNotSupported();\n\n/// @dev Thrown when an init param was supplied as empty\nerror InitParamZero(string name);\n\n/// @dev Thrown when data hashes where expected but not where present on the tx\nerror MissingDataHashes();\n\n/// @dev Thrown when rollup is not updated with updateRollupAddress\nerror RollupNotChanged();\n\n/// @dev Unsupported header flag was provided\nerror InvalidHeaderFlag(bytes1);\n\n/// @dev SequencerInbox and Bridge are not in the same feeToken/ETH mode\nerror NativeTokenMismatch();\n\n/// @dev Thrown when a deprecated function is called\nerror Deprecated();\n\n/// @dev Thrown when any component of maxTimeVariation is over uint64\nerror BadMaxTimeVariation();\n\n/// @dev Thrown when Blobstream verification fails for a Celestia Data Root\nerror InvalidCelestiaBatch();\n"}, "src/libraries/GasRefundEnabled.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.30;\n\nimport \"./IReader4844.sol\";\nimport \"./IGasRefunder.sol\";\n\nabstract contract GasRefundEnabled {\n    uint256 internal immutable gasPerBlob = 2**17;\n\n    /// @dev this refunds the sender for execution costs of the tx\n    /// calldata costs are only refunded if `msg.sender == tx.origin` to guarantee the value refunded relates to charging\n    /// for the `tx.input`. this avoids a possible attack where you generate large calldata from a contract and get over-refunded\n    modifier refundsGas(IGasRefunder gasRefunder, IReader4844 reader4844) {\n        uint256 startGasLeft = gasleft();\n        _;\n        if (address(gasRefunder) != address(0)) {\n            uint256 calldataSize = msg.data.length;\n            uint256 calldataWords = (calldataSize + 31) / 32;\n            // account for the CALLDATACOPY cost of the proxy contract, including the memory expansion cost\n            startGasLeft += calldataWords * 6 + (calldataWords**2) / 512;\n            // if triggered in a contract call, the spender may be overrefunded by appending dummy data to the call\n            // so we check if it is a top level call, which would mean the sender paid calldata as part of tx.input\n            // solhint-disable-next-line avoid-tx-origin\n            if (msg.sender != tx.origin) {\n                // We can't be sure if this calldata came from the top level tx,\n                // so to be safe we tell the gas refunder there was no calldata.\n                calldataSize = 0;\n            } else {\n                // for similar reasons to above we only refund blob gas when the tx.origin is the msg.sender\n                // this avoids the caller being able to send blobs to other contracts and still get refunded here\n                if (address(reader4844) != address(0)) {\n                    // add any cost for 4844 data, the data hash reader throws an error prior to 4844 being activated\n                    // we do this addition here rather in the GasRefunder so that we can check the msg.sender is the tx.origin\n                    try reader4844.getDataHashes() returns (bytes32[] memory dataHashes) {\n                        if (dataHashes.length != 0) {\n                            uint256 blobBasefee = reader4844.getBlobBaseFee();\n                            startGasLeft +=\n                                (dataHashes.length * gasPerBlob * blobBasefee) /\n                                block.basefee;\n                        }\n                    } catch {}\n                }\n            }\n\n            gasRefunder.onGasSpent(payable(msg.sender), startGasLeft - gasleft(), calldataSize);\n        }\n    }\n}\n"}, "src/libraries/IGasRefunder.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.30;\n\ninterface IGasRefunder {\n    function onGasSpent(\n        address payable spender,\n        uint256 gasUsed,\n        uint256 calldataSize\n    ) external returns (bool success);\n}\n"}, "src/libraries/IReader4844.sol": {"content": "// Copyright 2023-2024, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\ninterface IReader4844 {\n    /// @notice Returns the current BLOBBASEFEE\n    function getBlobBaseFee() external view returns (uint256);\n\n    /// @notice Returns all the data hashes of all the blobs on the current transaction\n    function getDataHashes() external view returns (bytes32[] memory);\n}\n"}, "src/libraries/MerkleLib.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport {MerkleProofTooLong} from \"./Error.sol\";\n\nlibrary MerkleLib {\n    function generateRoot(bytes32[] memory _hashes) internal pure returns (bytes32) {\n        bytes32[] memory prevLayer = _hashes;\n        while (prevLayer.length > 1) {\n            bytes32[] memory nextLayer = new bytes32[]((prevLayer.length + 1) / 2);\n            for (uint256 i = 0; i < nextLayer.length; i++) {\n                if (2 * i + 1 < prevLayer.length) {\n                    nextLayer[i] = keccak256(\n                        abi.encodePacked(prevLayer[2 * i], prevLayer[2 * i + 1])\n                    );\n                } else {\n                    nextLayer[i] = prevLayer[2 * i];\n                }\n            }\n            prevLayer = nextLayer;\n        }\n        return prevLayer[0];\n    }\n\n    function calculateRoot(\n        bytes32[] memory nodes,\n        uint256 route,\n        bytes32 item\n    ) internal pure returns (bytes32) {\n        uint256 proofItems = nodes.length;\n        if (proofItems > 256) revert MerkleProofTooLong(proofItems, 256);\n        bytes32 h = item;\n        for (uint256 i = 0; i < proofItems; ) {\n            bytes32 node = nodes[i];\n            if ((route & (1 << i)) == 0) {\n                assembly {\n                    mstore(0x00, h)\n                    mstore(0x20, node)\n                    h := keccak256(0x00, 0x40)\n                }\n            } else {\n                assembly {\n                    mstore(0x00, node)\n                    mstore(0x20, h)\n                    h := keccak256(0x00, 0x40)\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return h;\n    }\n}\n"}, "src/libraries/MessageTypes.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nuint8 constant L2_MSG = 3;\nuint8 constant L1MessageType_L2FundedByL1 = 7;\nuint8 constant L1MessageType_submitRetryableTx = 9;\nuint8 constant L1MessageType_ethDeposit = 12;\nuint8 constant L1MessageType_batchPostingReport = 13;\nuint8 constant L2MessageType_unsignedEOATx = 0;\nuint8 constant L2MessageType_unsignedContractTx = 1;\n\nuint8 constant ROLLUP_PROTOCOL_EVENT_TYPE = 8;\nuint8 constant INITIALIZATION_MSG_TYPE = 11;\n"}, "src/libraries/UUPSNotUpgradeable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\";\nimport {DoubleLogicERC1967Upgrade} from \"./AdminFallbackProxy.sol\";\n\n/**\n * @dev UUPSUpgradeable by OpenZeppelin but not upgradeable. This is expected to be used on the secondary\n * logic slot behind a DoubleLogicERC1967Upgrade proxy\n */\nabstract contract UUPSNotUpgradeable is IERC1822Proxiable, DoubleLogicERC1967Upgrade {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(\n            _getSecondaryImplementation() == __self,\n            \"Function must be called through active proxy\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(\n            address(this) == __self,\n            \"UUPSNotUpgradeable: must not be called through delegatecall\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate that the this implementation remains valid after an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SECONDARY_SLOT;\n    }\n}\n"}, "src/mocks/Benchmarks.sol": {"content": "// Copyright 2022-2023, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\ncontract Benchmarks {\n    function fillBlockRecover() external payable {\n        bytes32 bridgeToNova = 0xeddecf107b5740cef7f5a01e3ea7e287665c4e75a8eb6afae2fda2e3d4367786;\n        address cryptoIsCute = 0x361594F5429D23ECE0A88E4fBE529E1c49D524d8;\n        uint8 v = 27;\n        bytes32 r = 0xc6178c2de1078cd36c3bd302cde755340d7f17fcb3fcc0b9c333ba03b217029f;\n        bytes32 s = 0x5fdbcefe2675e96219cdae57a7894280bf80fd40d44ce146a35e169ea6a78fd3;\n        while (true) {\n            require(ecrecover(bridgeToNova, v, r, s) == cryptoIsCute, \"WRONG_ARBINAUT\");\n        }\n    }\n\n    function fillBlockMulMod() external payable {\n        uint256 value = 0xeddecf107b5740cef7f5a01e3ea7e287665c4e75a8eb6afae2fda2e3d4367786;\n        while (true) {\n            value = mulmod(\n                value,\n                0xc6178c2de1078cd36c3bd302cde755340d7f17fcb3fcc0b9c333ba03b217029f,\n                0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\n            );\n        }\n    }\n\n    function fillBlockHash() external payable {\n        bytes32 hash = 0xeddecf107b5740cef7f5a01e3ea7e287665c4e75a8eb6afae2fda2e3d4367786;\n        while (true) {\n            hash = keccak256(abi.encodePacked(hash));\n        }\n    }\n\n    function fillBlockAdd() external payable {\n        uint256 value = 0;\n        while (true) {\n            unchecked {\n                value += 0xeddecf107b5740cef7f5a01e3ea7e287665c4e75a8eb6afae2fda2e3d4367786;\n            }\n        }\n    }\n\n    function fillBlockQuickStep() external payable {\n        uint256 value = 0;\n        while (true) {\n            value = msg.value;\n        }\n    }\n}\n"}, "src/mocks/BridgeStub.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./InboxStub.sol\";\nimport {BadSequencerMessageNumber} from \"../libraries/Error.sol\";\n\nimport \"../bridge/IBridge.sol\";\nimport \"../bridge/IEthBridge.sol\";\n\ncontract BridgeStub is IBridge, IEthBridge {\n    struct InOutInfo {\n        uint256 index;\n        bool allowed;\n    }\n\n    mapping(address => InOutInfo) private allowedDelayedInboxesMap;\n    //mapping(address => InOutInfo) private allowedOutboxesMap;\n\n    address[] public allowedDelayedInboxList;\n    address[] public allowedOutboxList;\n\n    address public override activeOutbox;\n\n    // Accumulator for delayed inbox; tail represents hash of the current state; each element represents the inclusion of a new message.\n    bytes32[] public override delayedInboxAccs;\n\n    bytes32[] public override sequencerInboxAccs;\n\n    address public sequencerInbox;\n    uint256 public override sequencerReportedSubMessageCount;\n\n    address public nativeToken;\n    uint8 public nativeTokenDecimals;\n\n    function setSequencerInbox(address _sequencerInbox) external override {\n        sequencerInbox = _sequencerInbox;\n        emit SequencerInboxUpdated(_sequencerInbox);\n    }\n\n    function allowedDelayedInboxes(address inbox) external view override returns (bool) {\n        return allowedDelayedInboxesMap[inbox].allowed;\n    }\n\n    function allowedOutboxes(address) external pure override returns (bool) {\n        revert(\"NOT_IMPLEMENTED\");\n    }\n\n    function updateRollupAddress(IOwnable) external pure {\n        revert(\"NOT_IMPLEMENTED\");\n    }\n\n    function enqueueDelayedMessage(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    ) external payable override returns (uint256) {\n        require(allowedDelayedInboxesMap[msg.sender].allowed, \"NOT_FROM_INBOX\");\n        return\n            addMessageToDelayedAccumulator(\n                kind,\n                sender,\n                block.number,\n                block.timestamp, // solhint-disable-line not-rely-on-time\n                block.basefee,\n                messageDataHash\n            );\n    }\n\n    function enqueueSequencerMessage(\n        bytes32 dataHash,\n        uint256 afterDelayedMessagesRead,\n        uint256 prevMessageCount,\n        uint256 newMessageCount\n    )\n        external\n        returns (\n            uint256 seqMessageIndex,\n            bytes32 beforeAcc,\n            bytes32 delayedAcc,\n            bytes32 acc\n        )\n    {\n        if (\n            sequencerReportedSubMessageCount != prevMessageCount &&\n            prevMessageCount != 0 &&\n            sequencerReportedSubMessageCount != 0\n        ) {\n            revert BadSequencerMessageNumber(sequencerReportedSubMessageCount, prevMessageCount);\n        }\n        sequencerReportedSubMessageCount = newMessageCount;\n        seqMessageIndex = sequencerInboxAccs.length;\n        if (sequencerInboxAccs.length > 0) {\n            beforeAcc = sequencerInboxAccs[sequencerInboxAccs.length - 1];\n        }\n        if (afterDelayedMessagesRead > 0) {\n            delayedAcc = delayedInboxAccs[afterDelayedMessagesRead - 1];\n        }\n        acc = keccak256(abi.encodePacked(beforeAcc, dataHash, delayedAcc));\n        sequencerInboxAccs.push(acc);\n    }\n\n    function submitBatchSpendingReport(address batchPoster, bytes32 dataHash)\n        external\n        returns (uint256)\n    {\n        // TODO: implement stub\n    }\n\n    function addMessageToDelayedAccumulator(\n        uint8,\n        address,\n        uint256,\n        uint256,\n        uint256,\n        bytes32 messageDataHash\n    ) internal returns (uint256) {\n        uint256 count = delayedInboxAccs.length;\n        bytes32 messageHash = Messages.messageHash(\n            0,\n            address(uint160(0)),\n            0,\n            0,\n            0,\n            0,\n            messageDataHash\n        );\n        bytes32 prevAcc = 0;\n        if (count > 0) {\n            prevAcc = delayedInboxAccs[count - 1];\n        }\n        delayedInboxAccs.push(Messages.accumulateInboxMessage(prevAcc, messageHash));\n        return count;\n    }\n\n    function executeCall(\n        address,\n        uint256,\n        bytes calldata\n    ) external pure override returns (bool, bytes memory) {\n        revert(\"NOT_IMPLEMENTED\");\n    }\n\n    function setDelayedInbox(address inbox, bool enabled) external override {\n        InOutInfo storage info = allowedDelayedInboxesMap[inbox];\n        bool alreadyEnabled = info.allowed;\n        emit InboxToggle(inbox, enabled);\n        if (alreadyEnabled == enabled) {\n            return;\n        }\n        if (enabled) {\n            allowedDelayedInboxesMap[inbox] = InOutInfo(allowedDelayedInboxList.length, true);\n            allowedDelayedInboxList.push(inbox);\n        } else {\n            allowedDelayedInboxList[info.index] = allowedDelayedInboxList[\n                allowedDelayedInboxList.length - 1\n            ];\n            allowedDelayedInboxesMap[allowedDelayedInboxList[info.index]].index = info.index;\n            allowedDelayedInboxList.pop();\n            delete allowedDelayedInboxesMap[inbox];\n        }\n    }\n\n    function setOutbox(\n        address, /* outbox */\n        bool /* enabled*/\n    ) external pure override {\n        revert(\"NOT_IMPLEMENTED\");\n    }\n\n    function delayedMessageCount() external view override returns (uint256) {\n        return delayedInboxAccs.length;\n    }\n\n    function sequencerMessageCount() external view override returns (uint256) {\n        return sequencerInboxAccs.length;\n    }\n\n    function rollup() external pure override returns (IOwnable) {\n        revert(\"NOT_IMPLEMENTED\");\n    }\n\n    function acceptFundsFromOldBridge() external payable {}\n\n    function initialize(IOwnable) external pure {\n        revert(\"NOT_IMPLEMENTED\");\n    }\n}\n"}, "src/mocks/BridgeUnproxied.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./InboxStub.sol\";\nimport {BadSequencerMessageNumber} from \"../libraries/Error.sol\";\n\nimport \"../bridge/Bridge.sol\";\n\ncontract BridgeUnproxied is Bridge {\n    constructor() {\n        _activeOutbox = EMPTY_ACTIVEOUTBOX;\n        rollup = IOwnable(msg.sender);\n    }\n}\n"}, "src/mocks/InboxStub.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../bridge/IInboxBase.sol\";\nimport \"../bridge/IInbox.sol\";\nimport \"../bridge/IBridge.sol\";\nimport \"../bridge/IEthBridge.sol\";\n\nimport \"../bridge/Messages.sol\";\nimport \"./BridgeStub.sol\";\nimport {\n    L2_MSG,\n    L1MessageType_L2FundedByL1,\n    L1MessageType_submitRetryableTx,\n    L2MessageType_unsignedEOATx,\n    L2MessageType_unsignedContractTx\n} from \"../libraries/MessageTypes.sol\";\n\ncontract InboxStub is IInboxBase, IInbox {\n    IBridge public override bridge;\n    ISequencerInbox public override sequencerInbox;\n\n    bool public paused;\n    uint256 public immutable maxDataSize;\n\n    constructor() {\n        maxDataSize = 117964;\n    }\n\n    function pause() external pure {\n        revert(\"NOT IMPLEMENTED\");\n    }\n\n    function unpause() external pure {\n        revert(\"NOT IMPLEMENTED\");\n    }\n\n    function initialize(IBridge _bridge, ISequencerInbox) external {\n        require(address(bridge) == address(0), \"ALREADY_INIT\");\n        bridge = _bridge;\n    }\n\n    /**\n     * @notice Send a generic L2 message to the chain\n     * @dev This method is an optimization to avoid having to emit the entirety of the messageData in a log. Instead validators are expected to be able to parse the data from the transaction's input\n     * @param messageData Data of the message being sent\n     */\n    function sendL2MessageFromOrigin(bytes calldata messageData) external returns (uint256) {\n        // solhint-disable-next-line avoid-tx-origin\n        require(msg.sender == tx.origin, \"origin only\");\n        uint256 msgNum = deliverToBridge(L2_MSG, msg.sender, keccak256(messageData));\n        emit InboxMessageDeliveredFromOrigin(msgNum);\n        return msgNum;\n    }\n\n    /**\n     * @notice Send a generic L2 message to the chain\n     * @dev This method can be used to send any type of message that doesn't require L1 validation\n     * @param messageData Data of the message being sent\n     */\n    function sendL2Message(bytes calldata messageData) external override returns (uint256) {\n        uint256 msgNum = deliverToBridge(L2_MSG, msg.sender, keccak256(messageData));\n        emit InboxMessageDelivered(msgNum, messageData);\n        return msgNum;\n    }\n\n    function deliverToBridge(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    ) internal returns (uint256) {\n        return\n            IEthBridge(address(bridge)).enqueueDelayedMessage{value: msg.value}(\n                kind,\n                sender,\n                messageDataHash\n            );\n    }\n\n    function sendUnsignedTransaction(\n        uint256,\n        uint256,\n        uint256,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure override returns (uint256) {\n        revert(\"NOT_IMPLEMENTED\");\n    }\n\n    function sendContractTransaction(\n        uint256,\n        uint256,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure override returns (uint256) {\n        revert(\"NOT_IMPLEMENTED\");\n    }\n\n    function sendL1FundedUnsignedTransaction(\n        uint256,\n        uint256,\n        uint256,\n        address,\n        bytes calldata\n    ) external payable override returns (uint256) {\n        revert(\"NOT_IMPLEMENTED\");\n    }\n\n    function sendL1FundedContractTransaction(\n        uint256,\n        uint256,\n        address,\n        bytes calldata\n    ) external payable override returns (uint256) {\n        revert(\"NOT_IMPLEMENTED\");\n    }\n\n    function createRetryableTicket(\n        address,\n        uint256,\n        uint256,\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external payable override returns (uint256) {\n        revert(\"NOT_IMPLEMENTED\");\n    }\n\n    function unsafeCreateRetryableTicket(\n        address,\n        uint256,\n        uint256,\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external payable override returns (uint256) {\n        revert(\"NOT_IMPLEMENTED\");\n    }\n\n    function sendL1FundedUnsignedTransactionToFork(\n        uint256,\n        uint256,\n        uint256,\n        address,\n        bytes calldata\n    ) external payable returns (uint256) {\n        revert(\"NOT_IMPLEMENTED\");\n    }\n\n    function sendUnsignedTransactionToFork(\n        uint256,\n        uint256,\n        uint256,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure returns (uint256) {\n        revert(\"NOT_IMPLEMENTED\");\n    }\n\n    function sendWithdrawEthToFork(\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        address\n    ) external pure returns (uint256) {\n        revert(\"NOT_IMPLEMENTED\");\n    }\n\n    function depositEth() external payable override returns (uint256) {\n        revert(\"NOT_IMPLEMENTED\");\n    }\n\n    function postUpgradeInit(IBridge _bridge) external {}\n\n    function calculateRetryableSubmissionFee(uint256, uint256)\n        external\n        pure\n        override\n        returns (uint256)\n    {\n        revert(\"NOT_IMPLEMENTED\");\n    }\n\n    function setAllowList(address[] memory, bool[] memory) external pure {\n        revert(\"NOT_IMPLEMENTED\");\n    }\n\n    function setAllowListEnabled(bool) external pure {\n        revert(\"NOT_IMPLEMENTED\");\n    }\n\n    function isAllowed(address) external pure returns (bool) {\n        revert(\"NOT_IMPLEMENTED\");\n    }\n\n    function allowListEnabled() external pure returns (bool) {\n        revert(\"NOT_IMPLEMENTED\");\n    }\n\n    function getProxyAdmin() external pure returns (address) {\n        revert(\"NOT_IMPLEMENTED\");\n    }\n}\n"}, "src/mocks/MockBlobstream.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"../celestia/lib/DataRootTuple.sol\";\nimport \"../celestia/lib/tree/binary/BinaryMerkleTree.sol\";\n\nimport {IBlobstreamX} from \"../celestia/IBlobstreamX.sol\";\n\n// make a \"MockOSP\" that uses the address generated by the Mockstream deployment\n\ncontract Mockstream is IBlobstreamX {\n    /// @notice The block is the first one in the next data commitment.\n    uint64 public latestBlock;\n\n    /// @notice Nonce for proof events. Must be incremented sequentially.\n    uint256 public state_proofNonce;\n\n    /// @notice Mapping of data commitment nonces to data commitments.\n    mapping(uint256 => bytes32) public state_dataCommitments;\n\n    /// @notice Indicator of if the contract is frozen.\n    bool public frozen;\n\n    /// @dev Initializes the contract.\n    function initialize(uint64 _latestBlock) external {\n        frozen = false;\n        latestBlock = _latestBlock;\n        state_proofNonce = 1;\n    }\n\n    /// @notice Only the guardian can set the contract to a frozen state.\n    function updateFreeze(bool _freeze) external {\n        frozen = _freeze;\n    }\n\n    /// @notice Only the guardian can update the genesis state of the light client.\n    function updateGenesisState(uint64 _height) external {\n        latestBlock = _height;\n    }\n\n    function submitDataCommitment(\n        bytes32 _dataCommitment,\n        uint64 _beginBlock,\n        uint64 _endBlock\n    ) external {\n        if (latestBlock > _beginBlock || _beginBlock > _endBlock) {\n            revert(\"INVALID RANGE\");\n        }\n        state_dataCommitments[state_proofNonce] = _dataCommitment;\n\n        emit DataCommitmentStored(state_proofNonce, _beginBlock, _endBlock, _dataCommitment);\n\n        state_proofNonce++;\n        latestBlock = _endBlock;\n    }\n\n    /// @dev Verify the attestation for the given proof nonce, tuple, and proof. This is taken from\n    /// the existing Blobstream contract and is used to verify the data hash for a specific block\n    /// against a posted data commitment.\n    function verifyAttestation(\n        uint256 _proofNonce,\n        DataRootTuple memory _tuple,\n        BinaryMerkleProof memory _proof\n    ) external view returns (bool) {\n        if (frozen) {\n            revert ContractFrozen();\n        }\n\n        // Note: state_proofNonce slightly differs from Blobstream.sol because it is incremented\n        //   after each commit.\n        if (_proofNonce == 0 || _proofNonce >= state_proofNonce) {\n            return false;\n        }\n\n        // Load the tuple root at the given index from storage.\n        bytes32 root = state_dataCommitments[_proofNonce];\n\n        // Verify the proof.\n        (bool isProofValid, ) = BinaryMerkleTree.verify(root, _proof, abi.encode(_tuple));\n\n        return isProofValid;\n    }\n}\n"}, "src/mocks/MockResultReceiver.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../challenge/IChallengeResultReceiver.sol\";\nimport \"../challenge/IChallengeManager.sol\";\n\ncontract MockResultReceiver is IChallengeResultReceiver {\n    IChallengeManager public manager;\n    address public winner;\n    address public loser;\n    uint256 public challengeIndex;\n\n    event ChallengeCompleted(\n        uint256 indexed challengeIndex,\n        address indexed winner,\n        address indexed loser\n    );\n\n    constructor(IChallengeManager manager_) {\n        manager = manager_;\n    }\n\n    function createChallenge(\n        bytes32 wasmModuleRoot_,\n        MachineStatus[2] calldata startAndEndMachineStatuses_,\n        GlobalState[2] calldata startAndEndGlobalStates_,\n        uint64 numBlocks,\n        address asserter_,\n        address challenger_,\n        uint256 asserterTimeLeft_,\n        uint256 challengerTimeLeft_\n    ) external returns (uint64) {\n        return\n            manager.createChallenge(\n                wasmModuleRoot_,\n                startAndEndMachineStatuses_,\n                startAndEndGlobalStates_,\n                numBlocks,\n                asserter_,\n                challenger_,\n                asserterTimeLeft_,\n                challengerTimeLeft_\n            );\n    }\n\n    function completeChallenge(\n        uint256 challengeIndex_,\n        address winner_,\n        address loser_\n    ) external override {\n        winner = winner_;\n        loser = loser_;\n        challengeIndex = challengeIndex_;\n        emit ChallengeCompleted(challengeIndex, winner_, loser_);\n    }\n}\n"}, "src/mocks/MultiCallTest.sol": {"content": "// Copyright 2024, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\n/*\n * this contract is the solidity equivalent of stylus multicall test contract\n * it should only be used for stylus tests, and it ignores good solidity good practices\n */\n\ncontract MultiCallTest {\n    event Called(address addr, uint8 count, bool success, bytes returnData);\n    event Storage(bytes32 slot, bytes32 data, bool write);\n\n    function getBE(bytes calldata data, uint8 numBytes) internal pure returns (uint256) {\n        uint256 res = 0;\n        for (uint8 i = 0; i < numBytes; i++) {\n            res = res << 8;\n            res = res | uint8(data[i]);\n        }\n        return res;\n    }\n\n    // solhint-disable no-complex-fallback\n    // solhint-disable reason-string\n    // solhint-disable avoid-low-level-calls\n    // solhint-disable-next-line prettier/prettier\n    fallback(bytes calldata input) external payable returns (bytes memory) {\n        require(input.length > 0);\n        uint8 count = uint8(input[0]);\n        input = input[1:];\n\n        // combined output of all calls\n        bytes memory output;\n\n        for (uint8 i = 0; i < count; i++) {\n            uint32 length = uint32(getBE(input, 4));\n            input = input[4:];\n\n            bytes calldata curr = input[:length];\n            input = input[length:];\n\n            uint8 kind = uint8(curr[0]);\n            curr = curr[1:];\n\n            if (kind & 0xf0 == 0x0) {\n                // call\n                uint256 value;\n                if (kind & 0x3 == 0) {\n                    value = getBE(curr, 32);\n                    curr = curr[32:];\n                }\n\n                address addr = address(bytes20(curr[:20]));\n                bytes calldata data = curr[20:];\n                bytes memory out;\n                bool success;\n\n                if (kind & 0x3 == 0) {\n                    (success, out) = addr.call{value: value}(data);\n                } else if (kind & 0x3 == 1) {\n                    (success, out) = addr.delegatecall(data);\n                } else if (kind & 0x3 == 2) {\n                    (success, out) = addr.staticcall(data);\n                } else {\n                    revert(\"unknown call kind\");\n                }\n                if (!success) {\n                    if (kind & 0x4 == 0) {\n                        uint256 len = out.length;\n                        if (len > 0) {\n                            assembly {\n                                revert(add(out, 32), len)\n                            }\n                        } else {\n                            revert();\n                        }\n                    }\n                    out = \"\";\n                }\n                if (kind & 0x8 != 0) {\n                    emit Called(addr, count, success, out);\n                }\n                output = bytes.concat(output, out);\n            } else if (kind & 0xf0 == 0x10) {\n                // storage\n                bytes32 slot = bytes32(curr[:32]);\n                curr = curr[32:];\n                bytes32 data;\n                bool write;\n                if (kind & 0x3 == 0) {\n                    data = bytes32(curr[:32]);\n                    write = true;\n                    assembly {\n                        sstore(slot, data)\n                    }\n                } else if (kind & 0x3 == 1) {\n                    write = false;\n                    assembly {\n                        data := sload(slot)\n                    }\n                    output = bytes.concat(output, data);\n                } else {\n                    revert(\"unknown storage kind\");\n                }\n                if (kind & 0x8 != 0) {\n                    emit Storage(slot, data, write);\n                }\n            } else {\n                revert(\"unknown command\");\n            }\n        }\n\n        return output;\n    }\n}\n"}, "src/mocks/OneStepProverHostIoCelestiaMock.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../state/Value.sol\";\nimport \"../state/Machine.sol\";\nimport \"../state/Deserialize.sol\";\nimport \"../state/ModuleMemory.sol\";\nimport \"../osp/IOneStepProver.sol\";\nimport \"../bridge/Messages.sol\";\nimport \"../bridge/IBridge.sol\";\nimport {IBlobstreamX} from \"../celestia/IBlobstreamX.sol\";\n\nimport \"../celestia/BlobstreamVerifier.sol\";\n\ncontract OneStepProverHostIoCelestiaMock is IOneStepProver {\n    using GlobalStateLib for GlobalState;\n    using MerkleProofLib for MerkleProof;\n    using ModuleMemoryLib for ModuleMemory;\n    using ValueLib for Value;\n    using ValueStackLib for ValueStack;\n    using CelestiaBatchVerifier for address;\n\n    uint256 private constant LEAF_SIZE = 32;\n    uint256 private constant INBOX_NUM = 2;\n    uint64 private constant INBOX_HEADER_LEN = 40;\n    uint64 private constant DELAYED_HEADER_LEN = 112 + 1;\n\n    // Header Bytes\n    bytes1 public constant CELESTIA_MESSAGE_HEADER_FLAG = 0x63;\n\n    // Blobstream contract\n    address public constant BLOBSTREAM = 0x8F0FEbB820C4858e3C815f87391bdE38E62b4A8a;\n\n    function setLeafByte(bytes32 oldLeaf, uint256 idx, uint8 val) internal pure returns (bytes32) {\n        require(idx < LEAF_SIZE, \"BAD_SET_LEAF_BYTE_IDX\");\n        // Take into account that we are casting the leaf to a big-endian integer\n        uint256 leafShift = (LEAF_SIZE - 1 - idx) * 8;\n        uint256 newLeaf = uint256(oldLeaf);\n        newLeaf &= ~(0xFF << leafShift);\n        newLeaf |= uint256(val) << leafShift;\n        return bytes32(newLeaf);\n    }\n\n    function executeGetOrSetBytes32(\n        Machine memory mach,\n        Module memory mod,\n        GlobalState memory state,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) internal pure {\n        uint256 ptr = mach.valueStack.pop().assumeI32();\n        uint32 idx = mach.valueStack.pop().assumeI32();\n\n        if (idx >= GlobalStateLib.BYTES32_VALS_NUM) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        if (ptr + 32 > mod.moduleMemory.size || ptr % LEAF_SIZE != 0) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n\n        uint256 leafIdx = ptr / LEAF_SIZE;\n        uint256 proofOffset = 0;\n        bytes32 startLeafContents;\n        MerkleProof memory merkleProof;\n        (startLeafContents, proofOffset, merkleProof) = mod.moduleMemory.proveLeaf(\n            leafIdx,\n            proof,\n            proofOffset\n        );\n\n        if (inst.opcode == Instructions.GET_GLOBAL_STATE_BYTES32) {\n            mod.moduleMemory.merkleRoot = merkleProof.computeRootFromMemory(\n                leafIdx,\n                state.bytes32Vals[idx]\n            );\n        } else if (inst.opcode == Instructions.SET_GLOBAL_STATE_BYTES32) {\n            state.bytes32Vals[idx] = startLeafContents;\n        } else {\n            revert(\"BAD_GLOBAL_STATE_OPCODE\");\n        }\n    }\n\n    function executeGetU64(Machine memory mach, GlobalState memory state) internal pure {\n        uint32 idx = mach.valueStack.pop().assumeI32();\n\n        if (idx >= GlobalStateLib.U64_VALS_NUM) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n\n        mach.valueStack.push(ValueLib.newI64(state.u64Vals[idx]));\n    }\n\n    function executeSetU64(Machine memory mach, GlobalState memory state) internal pure {\n        uint64 val = mach.valueStack.pop().assumeI64();\n        uint32 idx = mach.valueStack.pop().assumeI32();\n\n        if (idx >= GlobalStateLib.U64_VALS_NUM) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        state.u64Vals[idx] = val;\n    }\n\n    uint256 internal constant BLS_MODULUS =\n        52435875175126190479447740508185965837690552500527637822603658699938581184513;\n    uint256 internal constant PRIMITIVE_ROOT_OF_UNITY =\n        10238227357739495823651030575849232062558860180284477541189508159991286009131;\n\n    // Computes b**e % m\n    // Really pure but the Solidity compiler sees the staticcall and requires view\n    function modExp256(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        bytes memory modExpInput = abi.encode(32, 32, 32, b, e, m);\n        (bool modexpSuccess, bytes memory modExpOutput) = address(0x05).staticcall(modExpInput);\n        require(modexpSuccess, \"MODEXP_FAILED\");\n        require(modExpOutput.length == 32, \"MODEXP_WRONG_LENGTH\");\n        return uint256(bytes32(modExpOutput));\n    }\n\n    function executeReadPreImage(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) internal view {\n        uint256 preimageOffset = mach.valueStack.pop().assumeI32();\n        uint256 ptr = mach.valueStack.pop().assumeI32();\n        if (preimageOffset % 32 != 0 || ptr + 32 > mod.moduleMemory.size || ptr % LEAF_SIZE != 0) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n\n        uint256 leafIdx = ptr / LEAF_SIZE;\n        uint256 proofOffset = 0;\n        bytes32 leafContents;\n        MerkleProof memory merkleProof;\n        (leafContents, proofOffset, merkleProof) = mod.moduleMemory.proveLeaf(\n            leafIdx,\n            proof,\n            proofOffset\n        );\n\n        bytes memory extracted;\n        uint8 proofType = uint8(proof[proofOffset]);\n        proofOffset++;\n        // These values must be kept in sync with `arbitrator/arbutil/src/types.rs`\n        // and `arbutil/preimage_type.go` (both in the nitro repo).\n        if (inst.argumentData == 0) {\n            // The machine is asking for a keccak256 preimage\n\n            if (proofType == 0) {\n                bytes calldata preimage = proof[proofOffset:];\n                require(keccak256(preimage) == leafContents, \"BAD_PREIMAGE\");\n\n                uint256 preimageEnd = preimageOffset + 32;\n                if (preimageEnd > preimage.length) {\n                    preimageEnd = preimage.length;\n                }\n                extracted = preimage[preimageOffset:preimageEnd];\n            } else {\n                // TODO: support proving via an authenticated contract\n                revert(\"UNKNOWN_PREIMAGE_PROOF\");\n            }\n        } else if (inst.argumentData == 1) {\n            // The machine is asking for a sha2-256 preimage\n\n            require(proofType == 0, \"UNKNOWN_PREIMAGE_PROOF\");\n            bytes calldata preimage = proof[proofOffset:];\n            require(sha256(preimage) == leafContents, \"BAD_PREIMAGE\");\n\n            uint256 preimageEnd = preimageOffset + 32;\n            if (preimageEnd > preimage.length) {\n                preimageEnd = preimage.length;\n            }\n            extracted = preimage[preimageOffset:preimageEnd];\n        } else if (inst.argumentData == 2) {\n            // The machine is asking for an Ethereum versioned hash preimage\n\n            require(proofType == 0, \"UNKNOWN_PREIMAGE_PROOF\");\n\n            // kzgProof should be a valid input to the EIP-4844 point evaluation precompile at address 0x0A.\n            // It should prove the preimageOffset/32'th word of the machine's requested KZG commitment.\n            bytes calldata kzgProof = proof[proofOffset:];\n\n            require(bytes32(kzgProof[:32]) == leafContents, \"KZG_PROOF_WRONG_HASH\");\n\n            uint256 fieldElementsPerBlob;\n            uint256 blsModulus;\n            {\n                (bool success, bytes memory kzgParams) = address(0x0A).staticcall(kzgProof);\n                require(success, \"INVALID_KZG_PROOF\");\n                require(kzgParams.length > 0, \"KZG_PRECOMPILE_MISSING\");\n                (fieldElementsPerBlob, blsModulus) = abi.decode(kzgParams, (uint256, uint256));\n            }\n\n            // With a hardcoded PRIMITIVE_ROOT_OF_UNITY, we can only support this BLS modulus.\n            // It may be worth in the future supporting arbitrary BLS moduli, but we would likely need to\n            // validate a user-supplied root of unity.\n            require(blsModulus == BLS_MODULUS, \"UNKNOWN_BLS_MODULUS\");\n\n            // If preimageOffset is greater than or equal to the blob size, leave extracted empty and call it here.\n            if (preimageOffset < fieldElementsPerBlob * 32) {\n                // We need to compute what point the polynomial should be evaluated at to get the right part of the preimage.\n                // KZG commitments use a bit reversal permutation to order the roots of unity.\n                // To account for that, we reverse the bit order of the index.\n                uint256 bitReversedIndex = 0;\n                // preimageOffset was required to be 32 byte aligned above\n                uint256 tmp = preimageOffset / 32;\n                for (uint256 i = 1; i < fieldElementsPerBlob; i <<= 1) {\n                    bitReversedIndex <<= 1;\n                    if (tmp & 1 == 1) {\n                        bitReversedIndex |= 1;\n                    }\n                    tmp >>= 1;\n                }\n\n                // First, we get the root of unity of order 2**fieldElementsPerBlob.\n                // We start with a root of unity of order 2**32 and then raise it to\n                // the power of (2**32)/fieldElementsPerBlob to get root of unity we need.\n                uint256 rootOfUnityPower = (1 << 32) / fieldElementsPerBlob;\n                // Then, we raise the root of unity to the power of bitReversedIndex,\n                // to retrieve this word of the KZG commitment.\n                rootOfUnityPower *= bitReversedIndex;\n                // z is the point the polynomial is evaluated at to retrieve this word of data\n                uint256 z = modExp256(PRIMITIVE_ROOT_OF_UNITY, rootOfUnityPower, blsModulus);\n                require(bytes32(kzgProof[32:64]) == bytes32(z), \"KZG_PROOF_WRONG_Z\");\n\n                extracted = kzgProof[64:96];\n            }\n        } else {\n            revert(\"UNKNOWN_PREIMAGE_TYPE\");\n        }\n\n        for (uint256 i = 0; i < extracted.length; i++) {\n            leafContents = setLeafByte(leafContents, i, uint8(extracted[i]));\n        }\n\n        mod.moduleMemory.merkleRoot = merkleProof.computeRootFromMemory(leafIdx, leafContents);\n\n        mach.valueStack.push(ValueLib.newI32(uint32(extracted.length)));\n    }\n\n    function validateSequencerInbox(\n        ExecutionContext calldata execCtx,\n        uint64 msgIndex,\n        bytes calldata message\n    ) internal view returns (bool) {\n        // need to check where exactly does proof offset usually land, see how we can get get rid of the length delimiter\n        // also review delayed message inbox issue Ottersect reported.\n        require(message.length >= INBOX_HEADER_LEN, \"BAD_SEQINBOX_PROOF\");\n\n        uint64 afterDelayedMsg;\n        (afterDelayedMsg, ) = Deserialize.u64(message, 32);\n        bytes32 messageHash = keccak256(message);\n        bytes32 beforeAcc;\n        bytes32 delayedAcc;\n\n        if (msgIndex > 0) {\n            beforeAcc = execCtx.bridge.sequencerInboxAccs(msgIndex - 1);\n        }\n        if (afterDelayedMsg > 0) {\n            delayedAcc = execCtx.bridge.delayedInboxAccs(afterDelayedMsg - 1);\n        }\n        bytes32 acc = keccak256(abi.encodePacked(beforeAcc, messageHash, delayedAcc));\n        require(acc == execCtx.bridge.sequencerInboxAccs(msgIndex), \"BAD_SEQINBOX_MESSAGE\");\n        return true;\n    }\n\n    function validateDelayedInbox(\n        ExecutionContext calldata execCtx,\n        uint64 msgIndex,\n        bytes calldata message\n    ) internal view returns (bool) {\n        require(message.length >= DELAYED_HEADER_LEN, \"BAD_DELAYED_PROOF\");\n\n        bytes32 beforeAcc;\n\n        if (msgIndex > 0) {\n            beforeAcc = execCtx.bridge.delayedInboxAccs(msgIndex - 1);\n        }\n\n        bytes32 messageDataHash = keccak256(message[DELAYED_HEADER_LEN:]);\n        bytes1 kind = message[0];\n        uint256 sender;\n        (sender, ) = Deserialize.u256(message, 1);\n\n        bytes32 messageHash = keccak256(\n            abi.encodePacked(kind, uint160(sender), message[33:DELAYED_HEADER_LEN], messageDataHash)\n        );\n        bytes32 acc = Messages.accumulateInboxMessage(beforeAcc, messageHash);\n\n        require(acc == execCtx.bridge.delayedInboxAccs(msgIndex), \"BAD_DELAYED_MESSAGE\");\n        return true;\n    }\n\n    function validateDaProof(bytes calldata proof, uint256 offset) internal view returns (uint256) {\n        // NOTE: the offset points to 40 bytes after the proof offset, which should point to a\n        // batch header flag for a sequencer inbox message\n        uint256 proofEnd;\n\n        if (proof[0] & CELESTIA_MESSAGE_HEADER_FLAG != 0) {\n            CelestiaBatchVerifier.Result result = CelestiaBatchVerifier.verifyBatch(\n                BLOBSTREAM,\n                proof[1:]\n            );\n\n            if (result == CelestiaBatchVerifier.Result.UNDECIDED) revert(\"BLOBSTREAM_UNDECIDED\");\n\n            // if its a counterfactual commitment, we replace the batch data with an empty batch\n            if (result == CelestiaBatchVerifier.Result.COUNTERFACTUAL_COMMITMENT) {\n                // this would slice the array into an empty batch\n                proofEnd = offset;\n            }\n\n            if (result == CelestiaBatchVerifier.Result.IN_BLOBSTREAM) {\n                // remove Celestia DA proof from proof\n                // add 88 for the 88 bytes in a celestia batch\n                // (the offset at this point already includes the batch header)\n                proofEnd = offset + 89;\n            }\n        }\n\n        return proofEnd;\n    }\n\n    function executeReadInboxMessage(\n        ExecutionContext calldata execCtx,\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) internal view {\n        uint256 messageOffset = mach.valueStack.pop().assumeI32();\n        uint256 ptr = mach.valueStack.pop().assumeI32();\n        uint256 msgIndex = mach.valueStack.pop().assumeI64();\n        if (\n            inst.argumentData == Instructions.INBOX_INDEX_SEQUENCER &&\n            msgIndex >= execCtx.maxInboxMessagesRead\n        ) {\n            mach.status = MachineStatus.TOO_FAR;\n            return;\n        }\n\n        if (ptr + 32 > mod.moduleMemory.size || ptr % LEAF_SIZE != 0) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n\n        uint256 leafIdx = ptr / LEAF_SIZE;\n        uint256 proofOffset = 0;\n        bytes32 leafContents;\n        MerkleProof memory merkleProof;\n        (leafContents, proofOffset, merkleProof) = mod.moduleMemory.proveLeaf(\n            leafIdx,\n            proof,\n            proofOffset\n        );\n        {\n            // TODO: support proving via an authenticated contract\n            require(proof[proofOffset] == 0, \"UNKNOWN_INBOX_PROOF\");\n            proofOffset++;\n\n            uint256 proofEnd = proof.length;\n\n            function(ExecutionContext calldata, uint64, bytes calldata)\n                internal\n                view\n                returns (bool) inboxValidate;\n\n            bool success;\n            if (inst.argumentData == Instructions.INBOX_INDEX_SEQUENCER) {\n                inboxValidate = validateSequencerInbox;\n                if (proof[proofOffset + 40] & CELESTIA_MESSAGE_HEADER_FLAG != 0) {\n                    proofEnd = validateDaProof(proof[proofOffset + 40:], proofOffset + 40);\n                }\n            } else if (inst.argumentData == Instructions.INBOX_INDEX_DELAYED) {\n                inboxValidate = validateDelayedInbox;\n            } else {\n                mach.status = MachineStatus.ERRORED;\n                return;\n            }\n            success = inboxValidate(execCtx, uint64(msgIndex), proof[proofOffset:proofEnd]);\n            if (!success) {\n                mach.status = MachineStatus.ERRORED;\n                return;\n            }\n        }\n\n        require(proof.length >= proofOffset, \"BAD_MESSAGE_PROOF\");\n        uint256 messageLength = proof.length - proofOffset;\n\n        uint32 i = 0;\n        for (; i < 32 && messageOffset + i < messageLength; i++) {\n            leafContents = setLeafByte(\n                leafContents,\n                i,\n                uint8(proof[proofOffset + messageOffset + i])\n            );\n        }\n\n        mod.moduleMemory.merkleRoot = merkleProof.computeRootFromMemory(leafIdx, leafContents);\n        mach.valueStack.push(ValueLib.newI32(i));\n    }\n\n    function executeHaltAndSetFinished(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory,\n        Instruction calldata,\n        bytes calldata\n    ) internal pure {\n        mach.status = MachineStatus.FINISHED;\n    }\n\n    function executeGlobalStateAccess(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) internal pure {\n        uint16 opcode = inst.opcode;\n\n        GlobalState memory state;\n        uint256 proofOffset = 0;\n        (state, proofOffset) = Deserialize.globalState(proof, proofOffset);\n        require(state.hash() == mach.globalStateHash, \"BAD_GLOBAL_STATE\");\n\n        if (\n            opcode == Instructions.GET_GLOBAL_STATE_BYTES32 ||\n            opcode == Instructions.SET_GLOBAL_STATE_BYTES32\n        ) {\n            executeGetOrSetBytes32(mach, mod, state, inst, proof[proofOffset:]);\n        } else if (opcode == Instructions.GET_GLOBAL_STATE_U64) {\n            executeGetU64(mach, state);\n        } else if (opcode == Instructions.SET_GLOBAL_STATE_U64) {\n            executeSetU64(mach, state);\n        } else {\n            revert(\"INVALID_GLOBALSTATE_OPCODE\");\n        }\n\n        mach.globalStateHash = state.hash();\n    }\n\n    function executeOneStep(\n        ExecutionContext calldata execCtx,\n        Machine calldata startMach,\n        Module calldata startMod,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) external view override returns (Machine memory mach, Module memory mod) {\n        mach = startMach;\n        mod = startMod;\n\n        uint16 opcode = inst.opcode;\n\n        function(\n            ExecutionContext calldata,\n            Machine memory,\n            Module memory,\n            Instruction calldata,\n            bytes calldata\n        ) internal view impl;\n\n        if (\n            opcode >= Instructions.GET_GLOBAL_STATE_BYTES32 &&\n            opcode <= Instructions.SET_GLOBAL_STATE_U64\n        ) {\n            impl = executeGlobalStateAccess;\n        } else if (opcode == Instructions.READ_PRE_IMAGE) {\n            impl = executeReadPreImage;\n        } else if (opcode == Instructions.READ_INBOX_MESSAGE) {\n            impl = executeReadInboxMessage;\n        } else if (opcode == Instructions.HALT_AND_SET_FINISHED) {\n            impl = executeHaltAndSetFinished;\n        } else {\n            revert(\"INVALID_MEMORY_OPCODE\");\n        }\n\n        impl(execCtx, mach, mod, inst, proof);\n    }\n}\n"}, "src/mocks/PendingBlkTimeAndNrAdvanceCheck.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../precompiles/ArbSys.sol\";\n\ncontract PendingBlkTimeAndNrAdvanceCheck {\n    uint256 immutable deployedAt;\n    uint256 immutable deployedAtBlock;\n    ArbSys constant ARB_SYS = ArbSys(address(100));\n\n    constructor() {\n        deployedAt = block.timestamp;\n        deployedAtBlock = ARB_SYS.arbBlockNumber();\n    }\n\n    function isAdvancing() external {\n        require(block.timestamp > deployedAt, \"Time didn't advance\");\n        require(ARB_SYS.arbBlockNumber() > deployedAtBlock, \"Block didn't advance\");\n    }\n\n    function checkArbBlockHashReturnsLatest(bytes32 expected) external {\n        bytes32 gotBlockHash = ARB_SYS.arbBlockHash(ARB_SYS.arbBlockNumber() - 1);\n        require(gotBlockHash != bytes32(0), \"ZERO_BLOCK_HASH\");\n        require(gotBlockHash == expected, \"WRONG_BLOCK_HASH\");\n    }\n}\n"}, "src/mocks/Program.sol": {"content": "// Copyright 2022-2023, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\nimport \"../precompiles/ArbSys.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\ncontract ProgramTest {\n    event Hash(bytes32 result);\n\n    function callKeccak(address program, bytes calldata data) external {\n        // in keccak.rs\n        //     the input is the # of hashings followed by a preimage\n        //     the output is the iterated hash of the preimage\n        (bool success, bytes memory result) = address(program).call(data);\n        require(success, \"call failed\");\n        bytes32 hash = bytes32(result);\n        emit Hash(hash);\n        require(hash == keccak256(data[1:]));\n    }\n\n    function staticcallProgram(address program, bytes calldata data)\n        external\n        view\n        returns (bytes memory)\n    {\n        (bool success, bytes memory result) = address(program).staticcall(data);\n        require(success, \"call failed\");\n        return result;\n    }\n\n    function assert256(\n        bytes memory data,\n        string memory text,\n        uint256 expected\n    ) internal pure returns (bytes memory) {\n        uint256 value = abi.decode(data, (uint256));\n        require(value == expected, text);\n\n        bytes memory rest = new bytes(data.length - 32);\n        for (uint256 i = 32; i < data.length; i++) {\n            rest[i - 32] = data[i];\n        }\n        return rest;\n    }\n\n    function staticcallEvmData(\n        address program,\n        address fundedAccount,\n        uint64 gas,\n        bytes calldata data\n    ) external view returns (bytes memory) {\n        (bool success, bytes memory result) = address(program).staticcall{gas: gas}(data);\n        require(success, \"call failed\");\n\n        address arbPrecompile = address(0x69);\n        address ethPrecompile = address(0x01);\n\n        result = assert256(result, \"block number \", block.number - 1);\n        result = assert256(result, \"chain id     \", block.chainid);\n        result = assert256(result, \"base fee     \", block.basefee);\n        result = assert256(result, \"gas price    \", tx.gasprice);\n        result = assert256(result, \"gas limit    \", block.gaslimit);\n        result = assert256(result, \"value        \", 0);\n        result = assert256(result, \"timestamp    \", block.timestamp);\n        result = assert256(result, \"balance      \", fundedAccount.balance);\n        result = assert256(result, \"rust address \", uint256(uint160(program)));\n        result = assert256(result, \"sender       \", uint256(uint160(address(this))));\n        result = assert256(result, \"origin       \", uint256(uint160(tx.origin)));\n        result = assert256(result, \"coinbase     \", uint256(uint160(address(block.coinbase))));\n        result = assert256(result, \"rust codehash\", uint256(program.codehash));\n        result = assert256(result, \"arb codehash \", uint256(arbPrecompile.codehash));\n        result = assert256(result, \"eth codehash \", uint256(ethPrecompile.codehash));\n\n        bytes memory code = new bytes(program.code.length);\n        for (uint256 i = 0; i < program.code.length; i++) {\n            code[i] = result[i];\n        }\n        require(keccak256(code) == keccak256(program.code), \"code\");\n        bytes memory rest = new bytes(result.length - program.code.length);\n        for (uint256 i = program.code.length; i < result.length; i++) {\n            rest[i - program.code.length] = result[i];\n        }\n\n        result = rest;\n        return result;\n    }\n\n    function checkRevertData(\n        address program,\n        bytes calldata data,\n        bytes calldata expected\n    ) external payable returns (bytes memory) {\n        (bool success, bytes memory result) = address(program).call{value: msg.value}(data);\n        require(!success, \"unexpected success\");\n        require(result.length == expected.length, \"wrong revert data length\");\n        for (uint256 i = 0; i < result.length; i++) {\n            require(result[i] == expected[i], \"revert data mismatch\");\n        }\n        return result;\n    }\n\n    function mathTest(address program) external {\n        uint256 value = 0xeddecf107b5740cef7f5a01e3ea7e287665c4e75a8eb6afae2fda2e3d4367786;\n        value = mulmod(\n            value,\n            0xc6178c2de1078cd36c3bd302cde755340d7f17fcb3fcc0b9c333ba03b217029f,\n            0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\n        );\n        value = addmod(\n            value,\n            0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f,\n            0xc6178c2de1078cd36c3bd302cde755340d7f17fcb3fcc0b9c333ba03b217029f\n        );\n        unchecked {\n            value /= 0xeddecf107b5740ce;\n            value = value**0xfffffffefffffc2f;\n            value = value % 0xc6178c2de1078cd3;\n        }\n\n        (bool success, bytes memory result) = address(program).call(\"\");\n        require(success, \"call failed\");\n        require(keccak256(result) == keccak256(abi.encodePacked(value)));\n    }\n}\n"}, "src/mocks/ProxyAdminForBinding.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\n\ncontract ProxyAdminForBinding is ProxyAdmin {}\n"}, "src/mocks/SdkStorage.sol": {"content": "// Copyright 2022-2023, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\ncontract SdkStorage {\n    bool flag;\n    address owner;\n    address other;\n    Struct sub;\n    Struct[] structs;\n    uint64[] vector;\n    uint40[][] nested;\n    bytes bytesFull;\n    bytes bytesLong;\n    string chars;\n    Maps maps;\n    Arrays arrays;\n\n    struct Struct {\n        uint16 num;\n        int32 other;\n        bytes32 word;\n    }\n\n    struct Maps {\n        mapping(uint256 => address) basic;\n        mapping(address => bool[]) vects;\n        mapping(int32 => address)[] array;\n        mapping(bytes1 => mapping(bool => uint256)) nested;\n        mapping(string => Struct) structs;\n    }\n\n    struct Arrays {\n        string[4] strings;\n        uint8 spacer;\n        uint24[5] packed;\n        uint8 trail;\n        address[2] spill;\n        uint8[2][4] matrix;\n        int96[4][] vector;\n        int96[][4] vectors;\n        Struct[3] structs;\n    }\n\n    function populate() external {\n        flag = true;\n        owner = address(0x70);\n        other = address(0x30);\n\n        sub.num = 32;\n        sub.other = type(int32).max;\n        sub.word = bytes32(uint256(64));\n\n        for (uint64 i = 0; i < 32; i++) {\n            vector.push(i);\n        }\n        vector[7] = 77;\n\n        for (uint256 w = 0; w < 10; w++) {\n            nested.push(new uint40[](w));\n            for (uint256 i = 0; i < w; i++) {\n                nested[w][i] = uint40(i);\n            }\n        }\n        for (uint256 w = 0; w < 10; w++) {\n            for (uint256 i = 0; i < w; i++) {\n                nested[w][i] *= 2;\n            }\n        }\n\n        for (uint8 i = 0; i < 31; i++) {\n            bytesFull = abi.encodePacked(bytesFull, i);\n        }\n        for (uint8 i = 0; i < 80; i++) {\n            bytesLong = abi.encodePacked(bytesLong, i);\n        }\n        chars = \"arbitrum stylus\";\n\n        for (uint256 i = 0; i < 16; i++) {\n            maps.basic[i] = address(uint160(i));\n        }\n\n        for (uint160 a = 0; a < 4; a++) {\n            maps.vects[address(a)] = new bool[](0);\n            for (uint256 i = 0; i <= a; i++) {\n                maps.vects[address(a)].push(true);\n            }\n        }\n\n        for (int32 i = 0; i < 4; i++) {\n            maps.array.push();\n            maps.array[uint256(uint32(i))][i] = address(uint160(uint32(i)));\n        }\n\n        for (uint8 i = 0; i < 4; i++) {\n            maps.nested[bytes1(i)][i % 2 == 0] = i + 1;\n        }\n\n        maps.structs[\"stylus\"] = sub;\n\n        for (uint256 i = 0; i < 4; i++) {\n            structs.push(sub);\n        }\n\n        arrays.strings[2] = \"L2 is for you!\";\n\n        for (uint256 i = 0; i < 5; i++) {\n            arrays.packed[i] = uint24(i);\n        }\n\n        for (uint256 i = 0; i < 2; i++) {\n            arrays.spill[i] = address(uint160(i));\n        }\n\n        for (uint256 i = 0; i < 4; i++) {\n            arrays.matrix[i][0] = uint8(i);\n            arrays.matrix[i][1] = arrays.matrix[i][0] + 1;\n        }\n\n        for (uint256 w = 0; w < 3; w++) {\n            int96[4] memory array;\n            for (int256 i = 0; i < 4; i++) {\n                array[uint256(i)] = int96(i);\n            }\n            arrays.vector.push(array);\n        }\n\n        for (uint256 w = 0; w < 4; w++) {\n            for (int96 i = 0; i < 4; i++) {\n                arrays.vectors[w].push(i);\n            }\n        }\n\n        for (uint256 i = 0; i < 3; i++) {\n            arrays.structs[i] = sub;\n        }\n    }\n\n    function remove() external {\n        while (bytesFull.length != 0) {\n            bytesFull.pop();\n        }\n\n        while (bytesLong.length > 16) {\n            bytesLong.pop();\n        }\n\n        chars = \"wasm is cute <3\";\n\n        while (vector.length != 0) {\n            vector.pop();\n        }\n\n        while (nested.length > 1) {\n            nested.pop();\n        }\n\n        for (uint256 i = 0; i < 8; i++) {\n            delete maps.basic[i];\n        }\n        maps.basic[8] = address(32);\n\n        for (uint160 i = 0; i < 4; i++) {\n            delete maps.vects[address(i)];\n        }\n\n        structs.pop();\n\n        delete arrays.matrix;\n        delete arrays.vector;\n        delete arrays.vectors;\n        delete arrays.structs;\n    }\n}\n"}, "src/mocks/SequencerInboxStub.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../bridge/SequencerInbox.sol\";\nimport \"../bridge/IEthBridge.sol\";\nimport {INITIALIZATION_MSG_TYPE} from \"../libraries/MessageTypes.sol\";\n\ncontract SequencerInboxStub is SequencerInbox {\n    constructor(\n        IBridge bridge_,\n        address sequencer_,\n        ISequencerInbox.MaxTimeVariation memory maxTimeVariation_,\n        uint256 maxDataSize_,\n        IReader4844 reader4844_,\n        bool isUsingFeeToken_\n    ) SequencerInbox(maxDataSize_, reader4844_, isUsingFeeToken_) {\n        bridge = bridge_;\n        rollup = IOwnable(msg.sender);\n        delayBlocks = uint64(maxTimeVariation_.delayBlocks);\n        futureBlocks = uint64(maxTimeVariation_.futureBlocks);\n        delaySeconds = uint64(maxTimeVariation_.delaySeconds);\n        futureSeconds = uint64(maxTimeVariation_.futureSeconds);\n        isBatchPoster[sequencer_] = true;\n    }\n\n    function addInitMessage(uint256 chainId) external {\n        bytes memory initMsg = abi.encodePacked(chainId);\n        uint256 num = IEthBridge(address(bridge)).enqueueDelayedMessage(\n            INITIALIZATION_MSG_TYPE,\n            address(0),\n            keccak256(initMsg)\n        );\n        require(num == 0, \"ALREADY_DELAYED_INIT\");\n        emit InboxMessageDelivered(num, initMsg);\n        (bytes32 dataHash, IBridge.TimeBounds memory timeBounds) = formEmptyDataHash(1);\n        (\n            uint256 sequencerMessageCount,\n            bytes32 beforeAcc,\n            bytes32 delayedAcc,\n            bytes32 afterAcc\n        ) = addSequencerL2BatchImpl(dataHash, 1, 0, 0, 1);\n        require(sequencerMessageCount == 0, \"ALREADY_SEQ_INIT\");\n        emit SequencerBatchDelivered(\n            sequencerMessageCount,\n            beforeAcc,\n            afterAcc,\n            delayedAcc,\n            totalDelayedMessagesRead,\n            timeBounds,\n            IBridge.BatchDataLocation.NoData\n        );\n    }\n\n    function getTimeBounds() internal view override returns (IBridge.TimeBounds memory bounds) {\n        this; // silence warning about function not being view\n        return bounds;\n    }\n}\n"}, "src/mocks/Simple.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../bridge/ISequencerInbox.sol\";\nimport \"../precompiles/ArbRetryableTx.sol\";\nimport \"../precompiles/ArbSys.sol\";\n\ncontract Simple {\n    uint64 public counter;\n    uint256 public difficulty;\n\n    event CounterEvent(uint64 count);\n    event RedeemedEvent(address caller, address redeemer);\n    event NullEvent();\n    event LogAndIncrementCalled(uint256 expected, uint256 have);\n\n    function increment() external {\n        counter++;\n    }\n\n    function logAndIncrement(uint256 expected) external {\n        emit LogAndIncrementCalled(expected, counter);\n        counter++;\n    }\n\n    function incrementEmit() external {\n        counter++;\n        emit CounterEvent(counter);\n    }\n\n    function incrementRedeem() external {\n        // solhint-disable-next-line avoid-tx-origin\n        require(msg.sender == tx.origin, \"SENDER_NOT_ORIGIN\");\n        require(ArbSys(address(0x64)).wasMyCallersAddressAliased(), \"NOT_ALIASED\");\n        counter++;\n        emit RedeemedEvent(msg.sender, ArbRetryableTx(address(110)).getCurrentRedeemer());\n    }\n\n    function emitNullEvent() external {\n        emit NullEvent();\n    }\n\n    function checkBlockHashes() external view returns (uint256) {\n        require(blockhash(block.number - 1) != blockhash(block.number - 2), \"SAME_BLOCK_HASH\");\n        return block.number;\n    }\n\n    function storeDifficulty() external {\n        difficulty = block.difficulty;\n    }\n\n    function getBlockDifficulty() external view returns (uint256) {\n        return difficulty;\n    }\n\n    function noop() external pure {}\n\n    function pleaseRevert() external pure {\n        revert(\"SOLIDITY_REVERTING\");\n    }\n\n    function checkIsTopLevelOrWasAliased(bool useTopLevel, bool expected) public view {\n        if (useTopLevel) {\n            require(ArbSys(address(100)).isTopLevelCall() == expected, \"UNEXPECTED_RESULT\");\n        } else {\n            require(\n                ArbSys(address(100)).wasMyCallersAddressAliased() == expected,\n                \"UNEXPECTED_RESULT\"\n            );\n        }\n    }\n\n    function checkCalls(\n        bool useTopLevel,\n        bool directCase,\n        bool staticCase,\n        bool delegateCase,\n        bool callcodeCase,\n        bool callCase\n    ) public {\n        // DIRECT CALL\n        if (useTopLevel) {\n            require(ArbSys(address(100)).isTopLevelCall() == directCase, \"UNEXPECTED_RESULT\");\n        } else {\n            require(\n                ArbSys(address(100)).wasMyCallersAddressAliased() == directCase,\n                \"UNEXPECTED_RESULT\"\n            );\n        }\n\n        // STATIC CALL\n        this.checkIsTopLevelOrWasAliased(useTopLevel, staticCase);\n\n        // DELEGATE CALL\n        bytes memory data = abi.encodeWithSelector(\n            this.checkIsTopLevelOrWasAliased.selector,\n            useTopLevel,\n            delegateCase\n        );\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = address(this).delegatecall(data);\n        require(success, \"DELEGATE_CALL_FAILED\");\n\n        // CALLCODE\n        data = abi.encodeWithSelector(\n            this.checkIsTopLevelOrWasAliased.selector,\n            useTopLevel,\n            callcodeCase\n        );\n        assembly {\n            success := callcode(gas(), address(), 0, add(data, 32), mload(data), 0, 0)\n        }\n        require(success, \"CALLCODE_FAILED\");\n\n        // CALL\n        data = abi.encodeWithSelector(\n            this.checkIsTopLevelOrWasAliased.selector,\n            useTopLevel,\n            callCase\n        );\n        // solhint-disable-next-line avoid-low-level-calls\n        (success, ) = address(this).call(data);\n        require(success, \"CALL_FAILED\");\n    }\n\n    function checkGasUsed(address to, bytes calldata input) external view returns (uint256) {\n        uint256 before = gasleft();\n        // The inner call may revert, but we still want to return the amount of gas used,\n        // so we ignore the result of this call.\n        // solhint-disable-next-line avoid-low-level-calls\n        // solc-ignore-next-line unused-call-retval\n        to.staticcall{gas: before - 10000}(input);\n        return before - gasleft();\n    }\n\n    function postManyBatches(\n        ISequencerInbox sequencerInbox,\n        bytes memory batchData,\n        uint256 numberToPost\n    ) external {\n        uint256 sequenceNumber = sequencerInbox.batchCount();\n        uint256 delayedMessagesRead = sequencerInbox.totalDelayedMessagesRead();\n        for (uint256 i = 0; i < numberToPost; i++) {\n            sequencerInbox.addSequencerL2Batch(\n                sequenceNumber,\n                batchData,\n                delayedMessagesRead,\n                IGasRefunder(address(0)),\n                0,\n                0\n            );\n            sequenceNumber++;\n        }\n    }\n}\n"}, "src/mocks/SimpleCacheManager.sol": {"content": "// Copyright 2022-2024, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\nimport \"../precompiles/ArbWasmCache.sol\";\n\ncontract SimpleCacheManager {\n    function cacheProgram(address program) external {\n        ArbWasmCache(address(0x72)).cacheProgram(program);\n    }\n\n    function evictProgram(address program) external {\n        ArbWasmCache(address(0x72)).evictCodehash(codehash(program));\n    }\n\n    function codehash(address program) internal view returns (bytes32 hash) {\n        assembly {\n            hash := extcodehash(program)\n        }\n    }\n}\n"}, "src/mocks/SimpleProxy.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/proxy/Proxy.sol\";\n\ncontract SimpleProxy is Proxy {\n    address private immutable impl;\n\n    constructor(address impl_) {\n        impl = impl_;\n    }\n\n    function _implementation() internal view override returns (address) {\n        return impl;\n    }\n}\n"}, "src/mocks/SingleExecutionChallenge.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../challenge/ChallengeManager.sol\";\n\ncontract SingleExecutionChallenge is ChallengeManager {\n    constructor(\n        IOneStepProofEntry osp_,\n        IChallengeResultReceiver resultReceiver_,\n        uint64 maxInboxMessagesRead_,\n        bytes32[2] memory startAndEndHashes,\n        uint256 numSteps_,\n        address asserter_,\n        address challenger_,\n        uint256 asserterTimeLeft_,\n        uint256 challengerTimeLeft_\n    ) {\n        osp = osp_;\n        resultReceiver = resultReceiver_;\n        uint64 challengeIndex = ++totalChallengesCreated;\n        ChallengeLib.Challenge storage challenge = challenges[challengeIndex];\n        challenge.maxInboxMessages = maxInboxMessagesRead_;\n        bytes32[] memory segments = new bytes32[](2);\n        segments[0] = startAndEndHashes[0];\n        segments[1] = startAndEndHashes[1];\n        bytes32 challengeStateHash = ChallengeLib.hashChallengeState(0, numSteps_, segments);\n        challenge.challengeStateHash = challengeStateHash;\n        challenge.next = ChallengeLib.Participant({addr: asserter_, timeLeft: asserterTimeLeft_});\n        challenge.current = ChallengeLib.Participant({\n            addr: challenger_,\n            timeLeft: challengerTimeLeft_\n        });\n        challenge.lastMoveTimestamp = block.timestamp;\n        challenge.mode = ChallengeLib.ChallengeMode.EXECUTION;\n\n        emit Bisected(challengeIndex, challengeStateHash, 0, numSteps_, segments);\n    }\n}\n"}, "src/mocks/TimedOutChallengeManager.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../challenge/ChallengeManager.sol\";\n\ncontract TimedOutChallengeManager is ChallengeManager {\n    function isTimedOut(uint64) public pure override returns (bool) {\n        return true;\n    }\n}\n"}, "src/mocks/UpgradeExecutorMock.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"@offchainlabs/upgrade-executor/src/IUpgradeExecutor.sol\";\n\ncontract UpgradeExecutorMock is\n    Initializable,\n    AccessControlUpgradeable,\n    ReentrancyGuard,\n    IUpgradeExecutor\n{\n    using Address for address;\n\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n\n    /// @notice Emitted when an upgrade execution occurs\n    event UpgradeExecuted(address indexed upgrade, uint256 value, bytes data);\n\n    /// @notice Emitted when target call occurs\n    event TargetCallExecuted(address indexed target, uint256 value, bytes data);\n\n    constructor() initializer {}\n\n    /// @notice Initialise the upgrade executor\n    /// @param admin The admin who can update other roles, and itself - ADMIN_ROLE\n    /// @param executors Can call the execute function - EXECUTOR_ROLE\n    function initialize(address admin, address[] memory executors) public initializer {\n        require(admin != address(0), \"UpgradeExecutor: zero admin\");\n\n        __AccessControl_init();\n\n        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, ADMIN_ROLE);\n\n        _setupRole(ADMIN_ROLE, admin);\n        for (uint256 i = 0; i < executors.length; ++i) {\n            _setupRole(EXECUTOR_ROLE, executors[i]);\n        }\n    }\n\n    /// @notice Execute an upgrade by delegate calling an upgrade contract\n    /// @dev    Only executor can call this. Since we're using a delegatecall here the Upgrade contract\n    ///         will have access to the state of this contract - including the roles. Only upgrade contracts\n    ///         that do not touch local state should be used.\n    function execute(address upgrade, bytes memory upgradeCallData)\n        public\n        payable\n        onlyRole(EXECUTOR_ROLE)\n        nonReentrant\n    {\n        // OZ Address library check if the address is a contract and bubble up inner revert reason\n        address(upgrade).functionDelegateCall(\n            upgradeCallData,\n            \"UpgradeExecutor: inner delegate call failed without reason\"\n        );\n\n        emit UpgradeExecuted(upgrade, msg.value, upgradeCallData);\n    }\n\n    /// @notice Execute an upgrade by directly calling target contract\n    /// @dev    Only executor can call this.\n    function executeCall(address target, bytes memory targetCallData)\n        public\n        payable\n        onlyRole(EXECUTOR_ROLE)\n        nonReentrant\n    {\n        // OZ Address library check if the address is a contract and bubble up inner revert reason\n        address(target).functionCallWithValue(\n            targetCallData,\n            msg.value,\n            \"UpgradeExecutor: inner call failed without reason\"\n        );\n\n        emit TargetCallExecuted(target, msg.value, targetCallData);\n    }\n}\n"}, "src/node-interface/NodeInterface.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\n/** @title Interface for providing gas estimation for retryable auto-redeems and constructing outbox proofs\n *  @notice This contract doesn't exist on-chain. Instead it is a virtual interface accessible at\n *  0x00000000000000000000000000000000000000C8\n *  This is a cute trick to allow an Arbitrum node to provide data without us having to implement additional RPCs\n */\ninterface NodeInterface {\n    /**\n     * @notice Simulate the execution of a retryable ticket\n     * @dev Use eth_estimateGas on this call to estimate gas usage of retryable ticket\n     *      Since gas usage is not yet known, you may need to add extra deposit (e.g. 1e18 wei) during estimation\n     * @param sender unaliased sender of the L1 and L2 transaction\n     * @param deposit amount to deposit to sender in L2\n     * @param to destination L2 contract address\n     * @param l2CallValue call value for retryable L2 message\n     * @param excessFeeRefundAddress the address which receives the difference between execution fee paid and the actual execution cost\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n     * @param data ABI encoded data of L2 message\n     */\n    function estimateRetryableTicket(\n        address sender,\n        uint256 deposit,\n        address to,\n        uint256 l2CallValue,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @notice Constructs an outbox proof of an l2->l1 send's existence in the outbox accumulator.\n     * @dev Use eth_call to call.\n     * @param size the number of elements in the accumulator\n     * @param leaf the position of the send in the accumulator\n     * @return send the l2->l1 send's hash\n     * @return root the root of the outbox accumulator\n     * @return proof level-by-level branch hashes constituting a proof of the send's membership at the given size\n     */\n    function constructOutboxProof(uint64 size, uint64 leaf)\n        external\n        view\n        returns (\n            bytes32 send,\n            bytes32 root,\n            bytes32[] memory proof\n        );\n\n    /**\n     * @notice Finds the L1 batch containing a requested L2 block, reverting if none does.\n     * Use eth_call to call.\n     * Throws if block doesn't exist, or if block number is 0. Use eth_call\n     * @param blockNum The L2 block being queried\n     * @return batch The sequencer batch number containing the requested L2 block\n     */\n    function findBatchContainingBlock(uint64 blockNum) external view returns (uint64 batch);\n\n    /**\n     * @notice Gets the number of L1 confirmations of the sequencer batch producing the requested L2 block\n     * This gets the number of L1 confirmations for the input message producing the L2 block,\n     * which happens well before the L1 rollup contract confirms the L2 block.\n     * Throws if block doesnt exist in the L2 chain.\n     * @dev Use eth_call to call.\n     * @param blockHash The hash of the L2 block being queried\n     * @return confirmations The number of L1 confirmations the sequencer batch has. Returns 0 if block not yet included in an L1 batch.\n     */\n    function getL1Confirmations(bytes32 blockHash) external view returns (uint64 confirmations);\n\n    /**\n     * @notice Same as native gas estimation, but with additional info on the l1 costs.\n     * @dev Use eth_call to call.\n     * @param data the tx's calldata. Everything else like \"From\" and \"Gas\" are copied over\n     * @param to the tx's \"To\" (ignored when contractCreation is true)\n     * @param contractCreation whether \"To\" is omitted\n     * @return gasEstimate an estimate of the total amount of gas needed for this tx\n     * @return gasEstimateForL1 an estimate of the amount of gas needed for the l1 component of this tx\n     * @return baseFee the l2 base fee\n     * @return l1BaseFeeEstimate ArbOS's l1 estimate of the l1 base fee\n     */\n    function gasEstimateComponents(\n        address to,\n        bool contractCreation,\n        bytes calldata data\n    )\n        external\n        payable\n        returns (\n            uint64 gasEstimate,\n            uint64 gasEstimateForL1,\n            uint256 baseFee,\n            uint256 l1BaseFeeEstimate\n        );\n\n    /**\n     * @notice Estimates a transaction's l1 costs.\n     * @dev Use eth_call to call.\n     *      This method is similar to gasEstimateComponents, but doesn't include the l2 component\n     *      so that the l1 component can be known even when the tx may fail.\n     *      This method also doesn't pad the estimate as gas estimation normally does.\n     *      If using this value to submit a transaction, we'd recommend first padding it by 10%.\n     * @param data the tx's calldata. Everything else like \"From\" and \"Gas\" are copied over\n     * @param to the tx's \"To\" (ignored when contractCreation is true)\n     * @param contractCreation whether \"To\" is omitted\n     * @return gasEstimateForL1 an estimate of the amount of gas needed for the l1 component of this tx\n     * @return baseFee the l2 base fee\n     * @return l1BaseFeeEstimate ArbOS's l1 estimate of the l1 base fee\n     */\n    function gasEstimateL1Component(\n        address to,\n        bool contractCreation,\n        bytes calldata data\n    )\n        external\n        payable\n        returns (\n            uint64 gasEstimateForL1,\n            uint256 baseFee,\n            uint256 l1BaseFeeEstimate\n        );\n\n    /**\n     * @notice Returns the proof necessary to redeem a message\n     * @param batchNum index of outbox entry (i.e., outgoing messages Merkle root) in array of outbox entries\n     * @param index index of outgoing message in outbox entry\n     * @return proof Merkle proof of message inclusion in outbox entry\n     * @return path Merkle path to message\n     * @return l2Sender sender if original message (i.e., caller of ArbSys.sendTxToL1)\n     * @return l1Dest destination address for L1 contract call\n     * @return l2Block l2 block number at which sendTxToL1 call was made\n     * @return l1Block l1 block number at which sendTxToL1 call was made\n     * @return timestamp l2 Timestamp at which sendTxToL1 call was made\n     * @return amount value in L1 message in wei\n     * @return calldataForL1 abi-encoded L1 message data\n     */\n    function legacyLookupMessageBatchProof(uint256 batchNum, uint64 index)\n        external\n        view\n        returns (\n            bytes32[] memory proof,\n            uint256 path,\n            address l2Sender,\n            address l1Dest,\n            uint256 l2Block,\n            uint256 l1Block,\n            uint256 timestamp,\n            uint256 amount,\n            bytes memory calldataForL1\n        );\n\n    // @notice Returns the first block produced using the Nitro codebase\n    // @dev returns 0 for chains like Nova that don't contain classic blocks\n    // @return number the block number\n    function nitroGenesisBlock() external pure returns (uint256 number);\n\n    // @notice Returns the L1 block number of the L2 block\n    // @return l1BlockNum The L1 block number\n    function blockL1Num(uint64 l2BlockNum) external view returns (uint64 l1BlockNum);\n\n    /**\n     * @notice Finds the L2 block number range that has the given L1 block number\n     * @param blockNum The L1 block number to search for the range\n     * Throws if no L2 block exist with the given L1 block number\n     * @return firstBlock The first L2 block number with the given L1 block number\n     * @return lastBlock The last L2 block number with the given L1 block number\n     */\n    function l2BlockRangeForL1(uint64 blockNum)\n        external\n        view\n        returns (uint64 firstBlock, uint64 lastBlock);\n}\n"}, "src/node-interface/NodeInterfaceDebug.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\n/** @title An extension to NodeInterface not meant for public consumption. Do not call.\n *  @notice This contract doesn't exist on-chain. Instead it is a virtual interface accessible at 0xc9.\n *  These methods add additional debugging and network monitoring instruments not intended for end users and\n *  as such may change without notice.\n */\n\ninterface NodeInterfaceDebug {\n    struct RetryableInfo {\n        uint64 timeout;\n        address from;\n        address to;\n        uint256 value;\n        address beneficiary;\n        uint64 tries;\n        bytes data;\n    }\n\n    /**\n     * @notice gets a retryable\n     * @param ticket the retryable's id\n     * @return retryable the serialized retryable\n     */\n    function getRetryable(bytes32 ticket) external view returns (RetryableInfo memory retryable);\n}\n"}, "src/osp/HashProofHelper.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../libraries/CryptographyPrimitives.sol\";\n\n/// @dev The requested hash preimage at the given offset has not been proven yet\nerror NotProven(bytes32 fullHash, uint64 offset);\n\ncontract HashProofHelper {\n    struct KeccakState {\n        uint64 offset;\n        bytes part;\n        uint64[25] state;\n        uint256 length;\n    }\n\n    struct PreimagePart {\n        bool proven;\n        bytes part;\n    }\n\n    mapping(bytes32 => mapping(uint64 => PreimagePart)) private preimageParts;\n    mapping(address => KeccakState) public keccakStates;\n\n    event PreimagePartProven(bytes32 indexed fullHash, uint64 indexed offset, bytes part);\n\n    uint256 private constant MAX_PART_LENGTH = 32;\n    uint256 private constant KECCAK_ROUND_INPUT = 136;\n\n    function proveWithFullPreimage(bytes calldata data, uint64 offset)\n        external\n        returns (bytes32 fullHash)\n    {\n        fullHash = keccak256(data);\n        bytes memory part;\n        if (data.length > offset) {\n            uint256 partLength = data.length - offset;\n            if (partLength > 32) {\n                partLength = 32;\n            }\n            part = data[offset:(offset + partLength)];\n        }\n        preimageParts[fullHash][offset] = PreimagePart({proven: true, part: part});\n        emit PreimagePartProven(fullHash, offset, part);\n    }\n\n    // Flags: a bitset signaling various things about the proof, ordered from least to most significant bits.\n    //   0th bit: indicates that this data is the final chunk of preimage data.\n    //   1st bit: indicates that the preimage part currently being built should be cleared before this.\n    function proveWithSplitPreimage(\n        bytes calldata data,\n        uint64 offset,\n        uint256 flags\n    ) external returns (bytes32 fullHash) {\n        bool isFinal = (flags & (1 << 0)) != 0;\n        if ((flags & (1 << 1)) != 0) {\n            delete keccakStates[msg.sender];\n        }\n        require(isFinal || data.length % KECCAK_ROUND_INPUT == 0, \"NOT_BLOCK_ALIGNED\");\n        KeccakState storage state = keccakStates[msg.sender];\n        uint256 startLength = state.length;\n        if (startLength == 0) {\n            state.offset = offset;\n        } else {\n            require(state.offset == offset, \"DIFF_OFFSET\");\n        }\n        keccakUpdate(state, data, isFinal);\n        if (uint256(offset) + MAX_PART_LENGTH > startLength && offset < state.length) {\n            uint256 startIdx = 0;\n            if (offset > startLength) {\n                startIdx = offset - startLength;\n            }\n            uint256 endIdx = uint256(offset) + MAX_PART_LENGTH - startLength;\n            if (endIdx > data.length) {\n                endIdx = data.length;\n            }\n            for (uint256 i = startIdx; i < endIdx; i++) {\n                state.part.push(data[i]);\n            }\n        }\n        if (!isFinal) {\n            return bytes32(0);\n        }\n        for (uint256 i = 0; i < 32; i++) {\n            uint256 stateIdx = i / 8;\n            // work around our weird keccakF function state ordering\n            stateIdx = 5 * (stateIdx % 5) + stateIdx / 5;\n            uint8 b = uint8(state.state[stateIdx] >> ((i % 8) * 8));\n            fullHash |= bytes32(uint256(b) << (248 - (i * 8)));\n        }\n        preimageParts[fullHash][state.offset] = PreimagePart({proven: true, part: state.part});\n        emit PreimagePartProven(fullHash, state.offset, state.part);\n        delete keccakStates[msg.sender];\n    }\n\n    function keccakUpdate(\n        KeccakState storage state,\n        bytes calldata data,\n        bool isFinal\n    ) internal {\n        state.length += data.length;\n        while (true) {\n            if (data.length == 0 && !isFinal) {\n                break;\n            }\n            for (uint256 i = 0; i < KECCAK_ROUND_INPUT; i++) {\n                uint8 b = 0;\n                if (i < data.length) {\n                    b = uint8(data[i]);\n                } else {\n                    // Padding\n                    if (i == data.length) {\n                        b |= uint8(0x01);\n                    }\n                    if (i == KECCAK_ROUND_INPUT - 1) {\n                        b |= uint8(0x80);\n                    }\n                }\n                uint256 stateIdx = i / 8;\n                // work around our weird keccakF function state ordering\n                stateIdx = 5 * (stateIdx % 5) + stateIdx / 5;\n                state.state[stateIdx] ^= uint64(b) << uint64((i % 8) * 8);\n            }\n            uint256[25] memory state256;\n            for (uint256 i = 0; i < 25; i++) {\n                state256[i] = state.state[i];\n            }\n            state256 = CryptographyPrimitives.keccakF(state256);\n            for (uint256 i = 0; i < 25; i++) {\n                state.state[i] = uint64(state256[i]);\n            }\n            if (data.length < KECCAK_ROUND_INPUT) {\n                break;\n            }\n            data = data[KECCAK_ROUND_INPUT:];\n        }\n    }\n\n    function clearSplitProof() external {\n        delete keccakStates[msg.sender];\n    }\n\n    /// Retrieves up to 32 bytes of the preimage of fullHash at the given offset, reverting if it hasn't been proven yet.\n    function getPreimagePart(bytes32 fullHash, uint64 offset) external view returns (bytes memory) {\n        PreimagePart storage part = preimageParts[fullHash][offset];\n        if (!part.proven) {\n            revert NotProven(fullHash, offset);\n        }\n        return part.part;\n    }\n}\n"}, "src/osp/IOneStepProofEntry.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./IOneStepProver.sol\";\n\nlibrary OneStepProofEntryLib {\n    uint256 internal constant MAX_STEPS = 1 << 43;\n}\n\ninterface IOneStepProofEntry {\n    function getStartMachineHash(bytes32 globalStateHash, bytes32 wasmModuleRoot)\n        external\n        pure\n        returns (bytes32);\n\n    function getEndMachineHash(MachineStatus status, bytes32 globalStateHash)\n        external\n        pure\n        returns (bytes32);\n\n    function proveOneStep(\n        ExecutionContext calldata execCtx,\n        uint256 machineStep,\n        bytes32 beforeHash,\n        bytes calldata proof\n    ) external view returns (bytes32 afterHash);\n}\n"}, "src/osp/IOneStepProver.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../state/Machine.sol\";\nimport \"../state/Module.sol\";\nimport \"../state/Instructions.sol\";\nimport \"../state/GlobalState.sol\";\nimport \"../bridge/ISequencerInbox.sol\";\nimport \"../bridge/IBridge.sol\";\n\nstruct ExecutionContext {\n    uint256 maxInboxMessagesRead;\n    IBridge bridge;\n}\n\nabstract contract IOneStepProver {\n    function executeOneStep(\n        ExecutionContext memory execCtx,\n        Machine calldata mach,\n        Module calldata mod,\n        Instruction calldata instruction,\n        bytes calldata proof\n    ) external view virtual returns (Machine memory result, Module memory resultMod);\n}\n"}, "src/osp/OneStepProofEntry.sol": {"content": "// Copyright 2021-2023, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../state/Deserialize.sol\";\nimport \"../state/Machine.sol\";\nimport \"../state/MerkleProof.sol\";\nimport \"../state/MultiStack.sol\";\nimport \"./IOneStepProver.sol\";\nimport \"./IOneStepProofEntry.sol\";\n\ncontract OneStepProofEntry is IOneStepProofEntry {\n    using MerkleProofLib for MerkleProof;\n    using MachineLib for Machine;\n    using MultiStackLib for MultiStack;\n\n    using ValueStackLib for ValueStack;\n    using StackFrameLib for StackFrameWindow;\n\n    IOneStepProver public prover0;\n    IOneStepProver public proverMem;\n    IOneStepProver public proverMath;\n    IOneStepProver public proverHostIo;\n\n    constructor(\n        IOneStepProver prover0_,\n        IOneStepProver proverMem_,\n        IOneStepProver proverMath_,\n        IOneStepProver proverHostIo_\n    ) {\n        prover0 = prover0_;\n        proverMem = proverMem_;\n        proverMath = proverMath_;\n        proverHostIo = proverHostIo_;\n    }\n\n    // Copied from ChallengeLib.sol\n    function getStartMachineHash(bytes32 globalStateHash, bytes32 wasmModuleRoot)\n        external\n        pure\n        returns (bytes32)\n    {\n        // Start the value stack with the function call ABI for the entrypoint\n        Value[] memory startingValues = new Value[](3);\n        startingValues[0] = ValueLib.newRefNull();\n        startingValues[1] = ValueLib.newI32(0);\n        startingValues[2] = ValueLib.newI32(0);\n        ValueArray memory valuesArray = ValueArray({inner: startingValues});\n        ValueStack memory values = ValueStack({proved: valuesArray, remainingHash: 0});\n        ValueStack memory internalStack;\n        StackFrameWindow memory frameStack;\n        MultiStack memory emptyMultiStack;\n        emptyMultiStack.setEmpty();\n\n        Machine memory mach = Machine({\n            status: MachineStatus.RUNNING,\n            valueStack: values,\n            valueMultiStack: emptyMultiStack,\n            internalStack: internalStack,\n            frameStack: frameStack,\n            frameMultiStack: emptyMultiStack,\n            globalStateHash: globalStateHash,\n            moduleIdx: 0,\n            functionIdx: 0,\n            functionPc: 0,\n            recoveryPc: MachineLib.NO_RECOVERY_PC,\n            modulesRoot: wasmModuleRoot\n        });\n        return mach.hash();\n    }\n\n    // Copied from ChallengeLib.sol\n    function getEndMachineHash(MachineStatus status, bytes32 globalStateHash)\n        external\n        pure\n        returns (bytes32)\n    {\n        if (status == MachineStatus.FINISHED) {\n            return keccak256(abi.encodePacked(\"Machine finished:\", globalStateHash));\n        } else if (status == MachineStatus.ERRORED) {\n            return keccak256(abi.encodePacked(\"Machine errored:\"));\n        } else if (status == MachineStatus.TOO_FAR) {\n            return keccak256(abi.encodePacked(\"Machine too far:\"));\n        } else {\n            revert(\"BAD_BLOCK_STATUS\");\n        }\n    }\n\n    function proveOneStep(\n        ExecutionContext calldata execCtx,\n        uint256 machineStep,\n        bytes32 beforeHash,\n        bytes calldata proof\n    ) external view override returns (bytes32 afterHash) {\n        Machine memory mach;\n        Module memory mod;\n        MerkleProof memory modProof;\n        Instruction memory inst;\n\n        {\n            uint256 offset = 0;\n            (mach, offset) = Deserialize.machine(proof, offset);\n            require(mach.hash() == beforeHash, \"MACHINE_BEFORE_HASH\");\n            if (mach.status != MachineStatus.RUNNING) {\n                // Machine is halted.\n                // WARNING: at this point, most machine fields are unconstrained.\n                return mach.hash();\n            }\n\n            if (machineStep + 1 == OneStepProofEntryLib.MAX_STEPS) {\n                mach.status = MachineStatus.ERRORED;\n                return mach.hash();\n            }\n\n            (mod, offset) = Deserialize.module(proof, offset);\n            (modProof, offset) = Deserialize.merkleProof(proof, offset);\n            require(\n                modProof.computeRootFromModule(mach.moduleIdx, mod) == mach.modulesRoot,\n                \"MODULES_ROOT\"\n            );\n\n            {\n                Instruction[] memory codeChunk;\n                MerkleProof memory codeProof;\n                MerkleProof memory funcProof;\n                (codeChunk, offset) = Deserialize.instructions(proof, offset);\n                (codeProof, offset) = Deserialize.merkleProof(proof, offset);\n                (funcProof, offset) = Deserialize.merkleProof(proof, offset);\n                bytes32 codeHash = codeProof.computeRootFromInstructions(\n                    mach.functionPc / 64,\n                    codeChunk\n                );\n                bytes32 recomputedRoot = funcProof.computeRootFromFunction(\n                    mach.functionIdx,\n                    codeHash\n                );\n                require(recomputedRoot == mod.functionsMerkleRoot, \"BAD_FUNCTIONS_ROOT\");\n                inst = codeChunk[mach.functionPc % 64];\n            }\n            proof = proof[offset:];\n        }\n\n        uint256 oldModIdx = mach.moduleIdx;\n        mach.functionPc += 1;\n        uint16 opcode = inst.opcode;\n        IOneStepProver prover;\n        if (\n            (opcode >= Instructions.I32_LOAD && opcode <= Instructions.I64_LOAD32_U) ||\n            (opcode >= Instructions.I32_STORE && opcode <= Instructions.I64_STORE32) ||\n            opcode == Instructions.MEMORY_SIZE ||\n            opcode == Instructions.MEMORY_GROW\n        ) {\n            prover = proverMem;\n        } else if (\n            (opcode == Instructions.I32_EQZ || opcode == Instructions.I64_EQZ) ||\n            (opcode >= Instructions.I32_RELOP_BASE &&\n                opcode <= Instructions.I32_RELOP_BASE + Instructions.IRELOP_LAST) ||\n            (opcode >= Instructions.I32_UNOP_BASE &&\n                opcode <= Instructions.I32_UNOP_BASE + Instructions.IUNOP_LAST) ||\n            (opcode >= Instructions.I32_ADD && opcode <= Instructions.I32_ROTR) ||\n            (opcode >= Instructions.I64_RELOP_BASE &&\n                opcode <= Instructions.I64_RELOP_BASE + Instructions.IRELOP_LAST) ||\n            (opcode >= Instructions.I64_UNOP_BASE &&\n                opcode <= Instructions.I64_UNOP_BASE + Instructions.IUNOP_LAST) ||\n            (opcode >= Instructions.I64_ADD && opcode <= Instructions.I64_ROTR) ||\n            (opcode == Instructions.I32_WRAP_I64) ||\n            (opcode == Instructions.I64_EXTEND_I32_S || opcode == Instructions.I64_EXTEND_I32_U) ||\n            (opcode >= Instructions.I32_EXTEND_8S && opcode <= Instructions.I64_EXTEND_32S) ||\n            (opcode >= Instructions.I32_REINTERPRET_F32 &&\n                opcode <= Instructions.F64_REINTERPRET_I64)\n        ) {\n            prover = proverMath;\n        } else if (\n            (opcode >= Instructions.GET_GLOBAL_STATE_BYTES32 &&\n                opcode <= Instructions.SET_GLOBAL_STATE_U64) ||\n            (opcode >= Instructions.READ_PRE_IMAGE && opcode <= Instructions.UNLINK_MODULE) ||\n            (opcode >= Instructions.NEW_COTHREAD && opcode <= Instructions.SWITCH_COTHREAD)\n        ) {\n            prover = proverHostIo;\n        } else {\n            prover = prover0;\n        }\n\n        (mach, mod) = prover.executeOneStep(execCtx, mach, mod, inst, proof);\n\n        bool updateRoot = !(opcode == Instructions.LINK_MODULE ||\n            opcode == Instructions.UNLINK_MODULE);\n        if (updateRoot) {\n            mach.modulesRoot = modProof.computeRootFromModule(oldModIdx, mod);\n        }\n\n        if (mach.status == MachineStatus.ERRORED && mach.recoveryPc != MachineLib.NO_RECOVERY_PC) {\n            // capture error, recover into main thread.\n            mach.switchCoThreadStacks();\n            mach.setPcFromRecovery();\n            mach.status = MachineStatus.RUNNING;\n        }\n\n        return mach.hash();\n    }\n}\n"}, "src/osp/OneStepProver0.sol": {"content": "// Copyright 2021-2023, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../state/Value.sol\";\nimport \"../state/Machine.sol\";\nimport \"../state/Module.sol\";\nimport \"../state/Deserialize.sol\";\nimport \"./IOneStepProver.sol\";\n\ncontract OneStepProver0 is IOneStepProver {\n    using MachineLib for Machine;\n    using MerkleProofLib for MerkleProof;\n    using StackFrameLib for StackFrameWindow;\n    using ValueLib for Value;\n    using ValueStackLib for ValueStack;\n\n    function executeUnreachable(\n        Machine memory mach,\n        Module memory,\n        Instruction calldata,\n        bytes calldata\n    ) internal pure {\n        mach.status = MachineStatus.ERRORED;\n    }\n\n    function executeNop(\n        Machine memory mach,\n        Module memory,\n        Instruction calldata,\n        bytes calldata\n    ) internal pure {\n        // :)\n    }\n\n    function executeConstPush(\n        Machine memory mach,\n        Module memory,\n        Instruction calldata inst,\n        bytes calldata\n    ) internal pure {\n        uint16 opcode = inst.opcode;\n        ValueType ty;\n        if (opcode == Instructions.I32_CONST) {\n            ty = ValueType.I32;\n        } else if (opcode == Instructions.I64_CONST) {\n            ty = ValueType.I64;\n        } else if (opcode == Instructions.F32_CONST) {\n            ty = ValueType.F32;\n        } else if (opcode == Instructions.F64_CONST) {\n            ty = ValueType.F64;\n        } else {\n            revert(\"CONST_PUSH_INVALID_OPCODE\");\n        }\n\n        mach.valueStack.push(Value({valueType: ty, contents: uint64(inst.argumentData)}));\n    }\n\n    function executeDrop(\n        Machine memory mach,\n        Module memory,\n        Instruction calldata,\n        bytes calldata\n    ) internal pure {\n        mach.valueStack.pop();\n    }\n\n    function executeSelect(\n        Machine memory mach,\n        Module memory,\n        Instruction calldata,\n        bytes calldata\n    ) internal pure {\n        uint32 selector = mach.valueStack.pop().assumeI32();\n        Value memory b = mach.valueStack.pop();\n        Value memory a = mach.valueStack.pop();\n\n        if (selector != 0) {\n            mach.valueStack.push(a);\n        } else {\n            mach.valueStack.push(b);\n        }\n    }\n\n    function executeReturn(\n        Machine memory mach,\n        Module memory,\n        Instruction calldata,\n        bytes calldata\n    ) internal pure {\n        StackFrame memory frame = mach.frameStack.pop();\n        mach.setPc(frame.returnPc);\n    }\n\n    function createReturnValue(Machine memory mach) internal pure returns (Value memory) {\n        return ValueLib.newPc(mach.functionPc, mach.functionIdx, mach.moduleIdx);\n    }\n\n    function executeCall(\n        Machine memory mach,\n        Module memory,\n        Instruction calldata inst,\n        bytes calldata\n    ) internal pure {\n        // Push the return pc to the stack\n        mach.valueStack.push(createReturnValue(mach));\n\n        // Push caller module info to the stack\n        StackFrame memory frame = mach.frameStack.peek();\n        mach.valueStack.push(ValueLib.newI32(frame.callerModule));\n        mach.valueStack.push(ValueLib.newI32(frame.callerModuleInternals));\n\n        // Jump to the target\n        uint32 idx = uint32(inst.argumentData);\n        require(idx == inst.argumentData, \"BAD_CALL_DATA\");\n        mach.functionIdx = idx;\n        mach.functionPc = 0;\n    }\n\n    function executeCrossModuleCall(\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata inst,\n        bytes calldata\n    ) internal pure {\n        // Push the return pc to the stack\n        mach.valueStack.push(createReturnValue(mach));\n\n        // Push caller module info to the stack\n        mach.valueStack.push(ValueLib.newI32(mach.moduleIdx));\n        mach.valueStack.push(ValueLib.newI32(mod.internalsOffset));\n\n        // Jump to the target\n        uint32 func = uint32(inst.argumentData);\n        uint32 module = uint32(inst.argumentData >> 32);\n        require(inst.argumentData >> 64 == 0, \"BAD_CROSS_MODULE_CALL_DATA\");\n        mach.moduleIdx = module;\n        mach.functionIdx = func;\n        mach.functionPc = 0;\n    }\n\n    function executeCrossModuleForward(\n        Machine memory mach,\n        Module memory,\n        Instruction calldata inst,\n        bytes calldata\n    ) internal pure {\n        // Push the return pc to the stack\n        mach.valueStack.push(createReturnValue(mach));\n\n        // Push caller's caller module info to the stack\n        StackFrame memory frame = mach.frameStack.peek();\n        mach.valueStack.push(ValueLib.newI32(frame.callerModule));\n        mach.valueStack.push(ValueLib.newI32(frame.callerModuleInternals));\n\n        // Jump to the target\n        uint32 func = uint32(inst.argumentData);\n        uint32 module = uint32(inst.argumentData >> 32);\n        require(inst.argumentData >> 64 == 0, \"BAD_CROSS_MODULE_CALL_DATA\");\n        mach.moduleIdx = module;\n        mach.functionIdx = func;\n        mach.functionPc = 0;\n    }\n\n    function executeCrossModuleInternalCall(\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) internal pure {\n        // Get the target from the stack\n        uint32 internalIndex = uint32(inst.argumentData);\n        uint32 moduleIndex = mach.valueStack.pop().assumeI32();\n        Module memory calledMod;\n\n        MerkleProof memory modProof;\n        uint256 offset = 0;\n        (calledMod, offset) = Deserialize.module(proof, offset);\n        (modProof, offset) = Deserialize.merkleProof(proof, offset);\n        require(\n            modProof.computeRootFromModule(moduleIndex, calledMod) == mach.modulesRoot,\n            \"CROSS_MODULE_INTERNAL_MODULES_ROOT\"\n        );\n\n        // Push the return pc to the stack\n        mach.valueStack.push(createReturnValue(mach));\n\n        // Push caller module info to the stack\n        mach.valueStack.push(ValueLib.newI32(mach.moduleIdx));\n        mach.valueStack.push(ValueLib.newI32(mod.internalsOffset));\n\n        // Jump to the target\n        mach.moduleIdx = moduleIndex;\n        mach.functionIdx = internalIndex + calledMod.internalsOffset;\n        mach.functionPc = 0;\n    }\n\n    function executeCallerModuleInternalCall(\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata inst,\n        bytes calldata\n    ) internal pure {\n        // Push the return pc to the stack\n        mach.valueStack.push(createReturnValue(mach));\n\n        // Push caller module info to the stack\n        mach.valueStack.push(ValueLib.newI32(mach.moduleIdx));\n        mach.valueStack.push(ValueLib.newI32(mod.internalsOffset));\n\n        StackFrame memory frame = mach.frameStack.peek();\n        if (frame.callerModuleInternals == 0) {\n            // The caller module has no internals\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n\n        // Jump to the target\n        uint32 offset = uint32(inst.argumentData);\n        require(offset == inst.argumentData, \"BAD_CALLER_INTERNAL_CALL_DATA\");\n        mach.moduleIdx = frame.callerModule;\n        mach.functionIdx = frame.callerModuleInternals + offset;\n        mach.functionPc = 0;\n    }\n\n    function executeCallIndirect(\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) internal pure {\n        uint32 funcIdx;\n        {\n            uint32 elementIdx = mach.valueStack.pop().assumeI32();\n\n            // Prove metadata about the instruction and tables\n            bytes32 elemsRoot;\n            bytes32 wantedFuncTypeHash;\n            uint256 offset = 0;\n            {\n                uint64 tableIdx;\n                uint8 tableType;\n                uint64 tableSize;\n                MerkleProof memory tableMerkleProof;\n                (tableIdx, offset) = Deserialize.u64(proof, offset);\n                (wantedFuncTypeHash, offset) = Deserialize.b32(proof, offset);\n                (tableType, offset) = Deserialize.u8(proof, offset);\n                (tableSize, offset) = Deserialize.u64(proof, offset);\n                (elemsRoot, offset) = Deserialize.b32(proof, offset);\n                (tableMerkleProof, offset) = Deserialize.merkleProof(proof, offset);\n\n                // Validate the information by recomputing known hashes\n                bytes32 recomputed = keccak256(\n                    abi.encodePacked(\"Call indirect:\", tableIdx, wantedFuncTypeHash)\n                );\n                require(recomputed == bytes32(inst.argumentData), \"BAD_CALL_INDIRECT_DATA\");\n                recomputed = tableMerkleProof.computeRootFromTable(\n                    tableIdx,\n                    tableType,\n                    tableSize,\n                    elemsRoot\n                );\n                require(recomputed == mod.tablesMerkleRoot, \"BAD_TABLES_ROOT\");\n\n                // Check if the table access is out of bounds\n                if (elementIdx >= tableSize) {\n                    mach.status = MachineStatus.ERRORED;\n                    return;\n                }\n            }\n\n            bytes32 elemFuncTypeHash;\n            Value memory functionPointer;\n            MerkleProof memory elementMerkleProof;\n            (elemFuncTypeHash, offset) = Deserialize.b32(proof, offset);\n            (functionPointer, offset) = Deserialize.value(proof, offset);\n            (elementMerkleProof, offset) = Deserialize.merkleProof(proof, offset);\n            bytes32 recomputedElemRoot = elementMerkleProof.computeRootFromElement(\n                elementIdx,\n                elemFuncTypeHash,\n                functionPointer\n            );\n            require(recomputedElemRoot == elemsRoot, \"BAD_ELEMENTS_ROOT\");\n\n            if (elemFuncTypeHash != wantedFuncTypeHash) {\n                mach.status = MachineStatus.ERRORED;\n                return;\n            }\n\n            if (functionPointer.valueType == ValueType.REF_NULL) {\n                mach.status = MachineStatus.ERRORED;\n                return;\n            } else if (functionPointer.valueType == ValueType.FUNC_REF) {\n                funcIdx = uint32(functionPointer.contents);\n                require(funcIdx == functionPointer.contents, \"BAD_FUNC_REF_CONTENTS\");\n            } else {\n                revert(\"BAD_ELEM_TYPE\");\n            }\n        }\n\n        // Push the return pc to the stack\n        mach.valueStack.push(createReturnValue(mach));\n\n        // Push caller module info to the stack\n        StackFrame memory frame = mach.frameStack.peek();\n        mach.valueStack.push(ValueLib.newI32(frame.callerModule));\n        mach.valueStack.push(ValueLib.newI32(frame.callerModuleInternals));\n\n        // Jump to the target\n        mach.functionIdx = funcIdx;\n        mach.functionPc = 0;\n    }\n\n    function executeArbitraryJump(\n        Machine memory mach,\n        Module memory,\n        Instruction calldata inst,\n        bytes calldata\n    ) internal pure {\n        // Jump to target\n        uint32 pc = uint32(inst.argumentData);\n        require(pc == inst.argumentData, \"BAD_CALL_DATA\");\n        mach.functionPc = pc;\n    }\n\n    function executeArbitraryJumpIf(\n        Machine memory mach,\n        Module memory,\n        Instruction calldata inst,\n        bytes calldata\n    ) internal pure {\n        uint32 cond = mach.valueStack.pop().assumeI32();\n        if (cond != 0) {\n            // Jump to target\n            uint32 pc = uint32(inst.argumentData);\n            require(pc == inst.argumentData, \"BAD_CALL_DATA\");\n            mach.functionPc = pc;\n        }\n    }\n\n    function merkleProveGetValue(\n        bytes32 merkleRoot,\n        uint256 index,\n        bytes calldata proof\n    ) internal pure returns (Value memory) {\n        uint256 offset = 0;\n        Value memory proposedVal;\n        MerkleProof memory merkle;\n        (proposedVal, offset) = Deserialize.value(proof, offset);\n        (merkle, offset) = Deserialize.merkleProof(proof, offset);\n        bytes32 recomputedRoot = merkle.computeRootFromValue(index, proposedVal);\n        require(recomputedRoot == merkleRoot, \"WRONG_MERKLE_ROOT\");\n        return proposedVal;\n    }\n\n    function merkleProveSetValue(\n        bytes32 merkleRoot,\n        uint256 index,\n        Value memory newVal,\n        bytes calldata proof\n    ) internal pure returns (bytes32) {\n        Value memory oldVal;\n        uint256 offset = 0;\n        MerkleProof memory merkle;\n        (oldVal, offset) = Deserialize.value(proof, offset);\n        (merkle, offset) = Deserialize.merkleProof(proof, offset);\n        bytes32 recomputedRoot = merkle.computeRootFromValue(index, oldVal);\n        require(recomputedRoot == merkleRoot, \"WRONG_MERKLE_ROOT\");\n        return merkle.computeRootFromValue(index, newVal);\n    }\n\n    function executeLocalGet(\n        Machine memory mach,\n        Module memory,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) internal pure {\n        StackFrame memory frame = mach.frameStack.peek();\n        Value memory val = merkleProveGetValue(frame.localsMerkleRoot, inst.argumentData, proof);\n        mach.valueStack.push(val);\n    }\n\n    function executeLocalSet(\n        Machine memory mach,\n        Module memory,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) internal pure {\n        Value memory newVal = mach.valueStack.pop();\n        StackFrame memory frame = mach.frameStack.peek();\n        frame.localsMerkleRoot = merkleProveSetValue(\n            frame.localsMerkleRoot,\n            inst.argumentData,\n            newVal,\n            proof\n        );\n    }\n\n    function executeGlobalGet(\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) internal pure {\n        Value memory val = merkleProveGetValue(mod.globalsMerkleRoot, inst.argumentData, proof);\n        mach.valueStack.push(val);\n    }\n\n    function executeGlobalSet(\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) internal pure {\n        Value memory newVal = mach.valueStack.pop();\n        mod.globalsMerkleRoot = merkleProveSetValue(\n            mod.globalsMerkleRoot,\n            inst.argumentData,\n            newVal,\n            proof\n        );\n    }\n\n    function executeInitFrame(\n        Machine memory mach,\n        Module memory,\n        Instruction calldata inst,\n        bytes calldata\n    ) internal pure {\n        Value memory callerModuleInternals = mach.valueStack.pop();\n        Value memory callerModule = mach.valueStack.pop();\n        Value memory returnPc = mach.valueStack.pop();\n        StackFrame memory newFrame = StackFrame({\n            returnPc: returnPc,\n            localsMerkleRoot: bytes32(inst.argumentData),\n            callerModule: callerModule.assumeI32(),\n            callerModuleInternals: callerModuleInternals.assumeI32()\n        });\n        mach.frameStack.push(newFrame);\n    }\n\n    function executeMoveInternal(\n        Machine memory mach,\n        Module memory,\n        Instruction calldata inst,\n        bytes calldata\n    ) internal pure {\n        Value memory val;\n        if (inst.opcode == Instructions.MOVE_FROM_STACK_TO_INTERNAL) {\n            val = mach.valueStack.pop();\n            mach.internalStack.push(val);\n        } else if (inst.opcode == Instructions.MOVE_FROM_INTERNAL_TO_STACK) {\n            val = mach.internalStack.pop();\n            mach.valueStack.push(val);\n        } else {\n            revert(\"MOVE_INTERNAL_INVALID_OPCODE\");\n        }\n    }\n\n    function executeDup(\n        Machine memory mach,\n        Module memory,\n        Instruction calldata,\n        bytes calldata\n    ) internal pure {\n        Value memory val = mach.valueStack.peek();\n        mach.valueStack.push(val);\n    }\n\n    function executeOneStep(\n        ExecutionContext calldata,\n        Machine calldata startMach,\n        Module calldata startMod,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) external pure override returns (Machine memory mach, Module memory mod) {\n        mach = startMach;\n        mod = startMod;\n\n        uint16 opcode = inst.opcode;\n\n        function(Machine memory, Module memory, Instruction calldata, bytes calldata)\n            internal\n            pure impl;\n        if (opcode == Instructions.UNREACHABLE) {\n            impl = executeUnreachable;\n        } else if (opcode == Instructions.NOP) {\n            impl = executeNop;\n        } else if (opcode == Instructions.RETURN) {\n            impl = executeReturn;\n        } else if (opcode == Instructions.CALL) {\n            impl = executeCall;\n        } else if (opcode == Instructions.CROSS_MODULE_CALL) {\n            impl = executeCrossModuleCall;\n        } else if (opcode == Instructions.CROSS_MODULE_FORWARD) {\n            impl = executeCrossModuleForward;\n        } else if (opcode == Instructions.CROSS_MODULE_INTERNAL_CALL) {\n            impl = executeCrossModuleInternalCall;\n        } else if (opcode == Instructions.CALLER_MODULE_INTERNAL_CALL) {\n            impl = executeCallerModuleInternalCall;\n        } else if (opcode == Instructions.CALL_INDIRECT) {\n            impl = executeCallIndirect;\n        } else if (opcode == Instructions.ARBITRARY_JUMP) {\n            impl = executeArbitraryJump;\n        } else if (opcode == Instructions.ARBITRARY_JUMP_IF) {\n            impl = executeArbitraryJumpIf;\n        } else if (opcode == Instructions.LOCAL_GET) {\n            impl = executeLocalGet;\n        } else if (opcode == Instructions.LOCAL_SET) {\n            impl = executeLocalSet;\n        } else if (opcode == Instructions.GLOBAL_GET) {\n            impl = executeGlobalGet;\n        } else if (opcode == Instructions.GLOBAL_SET) {\n            impl = executeGlobalSet;\n        } else if (opcode == Instructions.INIT_FRAME) {\n            impl = executeInitFrame;\n        } else if (opcode == Instructions.DROP) {\n            impl = executeDrop;\n        } else if (opcode == Instructions.SELECT) {\n            impl = executeSelect;\n        } else if (opcode >= Instructions.I32_CONST && opcode <= Instructions.F64_CONST) {\n            impl = executeConstPush;\n        } else if (\n            opcode == Instructions.MOVE_FROM_STACK_TO_INTERNAL ||\n            opcode == Instructions.MOVE_FROM_INTERNAL_TO_STACK\n        ) {\n            impl = executeMoveInternal;\n        } else if (opcode == Instructions.DUP) {\n            impl = executeDup;\n        } else {\n            revert(\"INVALID_OPCODE\");\n        }\n\n        impl(mach, mod, inst, proof);\n    }\n}\n"}, "src/osp/OneStepProverHostIo.sol": {"content": "// Copyright 2021-2024, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../state/Value.sol\";\nimport \"../state/Machine.sol\";\nimport \"../state/MerkleProof.sol\";\nimport \"../state/MultiStack.sol\";\nimport \"../state/Deserialize.sol\";\nimport \"../state/ModuleMemory.sol\";\nimport \"../osp/IOneStepProver.sol\";\nimport \"../bridge/Messages.sol\";\nimport \"../bridge/IBridge.sol\";\nimport {IBlobstreamX} from \"../celestia/IBlobstreamX.sol\";\n\nimport \"../celestia/BlobstreamVerifier.sol\";\n\ncontract OneStepProverHostIo is IOneStepProver {\n    using GlobalStateLib for GlobalState;\n    using MachineLib for Machine;\n    using MerkleProofLib for MerkleProof;\n    using ModuleMemoryLib for ModuleMemory;\n    using MultiStackLib for MultiStack;\n    using ValueLib for Value;\n    using ValueStackLib for ValueStack;\n    using StackFrameLib for StackFrameWindow;\n    using CelestiaBatchVerifier for address;\n\n    uint256 private constant LEAF_SIZE = 32;\n    uint256 private constant INBOX_NUM = 2;\n    uint64 private constant INBOX_HEADER_LEN = 40;\n    uint64 private constant DELAYED_HEADER_LEN = 112 + 1;\n\n    // Header Bytes\n    bytes1 public constant CELESTIA_MESSAGE_HEADER_FLAG = 0x63;\n\n    // Blobstream contract (address on Arbitrum One Sepolia, MAKE SURE TO CHANGE FOR CORRESPONDING SETTLEMENT LAYER PRIOR TO DEPLOYMENT)\n    // https://docs.celestia.org/how-to-guides/blobstream\n    //Arb sepolia\n    //Base sepolia\n    //address public constant BLOBSTREAM = 0xc3e209eb245Fd59c8586777b499d6A665DF3ABD2;\n\n    //Base\n    //Arb\n    //address public constant BLOBSTREAM = 0xA83ca7775Bc2889825BcDeDfFa5b758cf69e8794;\n    \n    //Sepolia \n    //address public constant BLOBSTREAM = 0xF0c6429ebAB2e7DC6e05DaFB61128bE21f13cb1e;\n\n\n    //Mainnet\n    address public constant BLOBSTREAM = 0x7Cf3876F681Dbb6EdA8f6FfC45D66B996Df08fAe;\n    \n    function setLeafByte(bytes32 oldLeaf, uint256 idx, uint8 val) internal pure returns (bytes32) {\n        require(idx < LEAF_SIZE, \"BAD_SET_LEAF_BYTE_IDX\");\n        // Take into account that we are casting the leaf to a big-endian integer\n        uint256 leafShift = (LEAF_SIZE - 1 - idx) * 8;\n        uint256 newLeaf = uint256(oldLeaf);\n        newLeaf &= ~(0xFF << leafShift);\n        newLeaf |= uint256(val) << leafShift;\n        return bytes32(newLeaf);\n    }\n\n    function executeGetOrSetBytes32(\n        Machine memory mach,\n        Module memory mod,\n        GlobalState memory state,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) internal pure {\n        uint256 ptr = mach.valueStack.pop().assumeI32();\n        uint32 idx = mach.valueStack.pop().assumeI32();\n\n        if (idx >= GlobalStateLib.BYTES32_VALS_NUM) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        if (!mod.moduleMemory.isValidLeaf(ptr)) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n\n        uint256 leafIdx = ptr / LEAF_SIZE;\n        uint256 proofOffset = 0;\n        bytes32 startLeafContents;\n        MerkleProof memory merkleProof;\n        (startLeafContents, proofOffset, merkleProof) = mod.moduleMemory.proveLeaf(\n            leafIdx,\n            proof,\n            proofOffset\n        );\n\n        if (inst.opcode == Instructions.GET_GLOBAL_STATE_BYTES32) {\n            mod.moduleMemory.merkleRoot = merkleProof.computeRootFromMemory(\n                leafIdx,\n                state.bytes32Vals[idx]\n            );\n        } else if (inst.opcode == Instructions.SET_GLOBAL_STATE_BYTES32) {\n            state.bytes32Vals[idx] = startLeafContents;\n        } else {\n            revert(\"BAD_GLOBAL_STATE_OPCODE\");\n        }\n    }\n\n    function executeGetU64(Machine memory mach, GlobalState memory state) internal pure {\n        uint32 idx = mach.valueStack.pop().assumeI32();\n\n        if (idx >= GlobalStateLib.U64_VALS_NUM) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n\n        mach.valueStack.push(ValueLib.newI64(state.u64Vals[idx]));\n    }\n\n    function executeSetU64(Machine memory mach, GlobalState memory state) internal pure {\n        uint64 val = mach.valueStack.pop().assumeI64();\n        uint32 idx = mach.valueStack.pop().assumeI32();\n\n        if (idx >= GlobalStateLib.U64_VALS_NUM) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        state.u64Vals[idx] = val;\n    }\n\n    uint256 internal constant BLS_MODULUS =\n        52435875175126190479447740508185965837690552500527637822603658699938581184513;\n    uint256 internal constant PRIMITIVE_ROOT_OF_UNITY =\n        10238227357739495823651030575849232062558860180284477541189508159991286009131;\n\n    // Computes b**e % m\n    // Really pure but the Solidity compiler sees the staticcall and requires view\n    function modExp256(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        bytes memory modExpInput = abi.encode(32, 32, 32, b, e, m);\n        (bool modexpSuccess, bytes memory modExpOutput) = address(0x05).staticcall(modExpInput);\n        require(modexpSuccess, \"MODEXP_FAILED\");\n        require(modExpOutput.length == 32, \"MODEXP_WRONG_LENGTH\");\n        return uint256(bytes32(modExpOutput));\n    }\n\n    function executeReadPreImage(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) internal view {\n        uint256 preimageOffset = mach.valueStack.pop().assumeI32();\n        uint256 ptr = mach.valueStack.pop().assumeI32();\n        if (preimageOffset % 32 != 0 || ptr + 32 > mod.moduleMemory.size || ptr % LEAF_SIZE != 0) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n\n        uint256 leafIdx = ptr / LEAF_SIZE;\n        uint256 proofOffset = 0;\n        bytes32 leafContents;\n        MerkleProof memory merkleProof;\n        (leafContents, proofOffset, merkleProof) = mod.moduleMemory.proveLeaf(\n            leafIdx,\n            proof,\n            proofOffset\n        );\n\n        bytes memory extracted;\n        uint8 proofType = uint8(proof[proofOffset]);\n        proofOffset++;\n        // These values must be kept in sync with `arbitrator/arbutil/src/types.rs`\n        // and `arbutil/preimage_type.go` (both in the nitro repo).\n        if (inst.argumentData == 0) {\n            // The machine is asking for a keccak256 preimage\n\n            if (proofType == 0) {\n                bytes calldata preimage = proof[proofOffset:];\n                require(keccak256(preimage) == leafContents, \"BAD_PREIMAGE\");\n\n                uint256 preimageEnd = preimageOffset + 32;\n                if (preimageEnd > preimage.length) {\n                    preimageEnd = preimage.length;\n                }\n                extracted = preimage[preimageOffset:preimageEnd];\n            } else {\n                // TODO: support proving via an authenticated contract\n                revert(\"UNKNOWN_PREIMAGE_PROOF\");\n            }\n        } else if (inst.argumentData == 1) {\n            // The machine is asking for a sha2-256 preimage\n\n            require(proofType == 0, \"UNKNOWN_PREIMAGE_PROOF\");\n            bytes calldata preimage = proof[proofOffset:];\n            require(sha256(preimage) == leafContents, \"BAD_PREIMAGE\");\n\n            uint256 preimageEnd = preimageOffset + 32;\n            if (preimageEnd > preimage.length) {\n                preimageEnd = preimage.length;\n            }\n            extracted = preimage[preimageOffset:preimageEnd];\n        } else if (inst.argumentData == 2) {\n            // The machine is asking for an Ethereum versioned hash preimage\n\n            require(proofType == 0, \"UNKNOWN_PREIMAGE_PROOF\");\n\n            // kzgProof should be a valid input to the EIP-4844 point evaluation precompile at address 0x0A.\n            // It should prove the preimageOffset/32'th word of the machine's requested KZG commitment.\n            bytes calldata kzgProof = proof[proofOffset:];\n\n            require(bytes32(kzgProof[:32]) == leafContents, \"KZG_PROOF_WRONG_HASH\");\n\n            uint256 fieldElementsPerBlob;\n            uint256 blsModulus;\n            {\n                (bool success, bytes memory kzgParams) = address(0x0A).staticcall(kzgProof);\n                require(success, \"INVALID_KZG_PROOF\");\n                require(kzgParams.length > 0, \"KZG_PRECOMPILE_MISSING\");\n                (fieldElementsPerBlob, blsModulus) = abi.decode(kzgParams, (uint256, uint256));\n            }\n\n            // With a hardcoded PRIMITIVE_ROOT_OF_UNITY, we can only support this BLS modulus.\n            // It may be worth in the future supporting arbitrary BLS moduli, but we would likely need to\n            // validate a user-supplied root of unity.\n            require(blsModulus == BLS_MODULUS, \"UNKNOWN_BLS_MODULUS\");\n\n            // If preimageOffset is greater than or equal to the blob size, leave extracted empty and call it here.\n            if (preimageOffset < fieldElementsPerBlob * 32) {\n                // We need to compute what point the polynomial should be evaluated at to get the right part of the preimage.\n                // KZG commitments use a bit reversal permutation to order the roots of unity.\n                // To account for that, we reverse the bit order of the index.\n                uint256 bitReversedIndex = 0;\n                // preimageOffset was required to be 32 byte aligned above\n                uint256 tmp = preimageOffset / 32;\n                for (uint256 i = 1; i < fieldElementsPerBlob; i <<= 1) {\n                    bitReversedIndex <<= 1;\n                    if (tmp & 1 == 1) {\n                        bitReversedIndex |= 1;\n                    }\n                    tmp >>= 1;\n                }\n\n                // First, we get the root of unity of order 2**fieldElementsPerBlob.\n                // We start with a root of unity of order 2**32 and then raise it to\n                // the power of (2**32)/fieldElementsPerBlob to get root of unity we need.\n                uint256 rootOfUnityPower = (1 << 32) / fieldElementsPerBlob;\n                // Then, we raise the root of unity to the power of bitReversedIndex,\n                // to retrieve this word of the KZG commitment.\n                rootOfUnityPower *= bitReversedIndex;\n                // z is the point the polynomial is evaluated at to retrieve this word of data\n                uint256 z = modExp256(PRIMITIVE_ROOT_OF_UNITY, rootOfUnityPower, blsModulus);\n                require(bytes32(kzgProof[32:64]) == bytes32(z), \"KZG_PROOF_WRONG_Z\");\n\n                extracted = kzgProof[64:96];\n            }\n        } else {\n            revert(\"UNKNOWN_PREIMAGE_TYPE\");\n        }\n\n        for (uint256 i = 0; i < extracted.length; i++) {\n            leafContents = setLeafByte(leafContents, i, uint8(extracted[i]));\n        }\n\n        mod.moduleMemory.merkleRoot = merkleProof.computeRootFromMemory(leafIdx, leafContents);\n\n        mach.valueStack.push(ValueLib.newI32(uint32(extracted.length)));\n    }\n\n    function validateSequencerInbox(\n        ExecutionContext calldata execCtx,\n        uint64 msgIndex,\n        bytes calldata message\n    ) internal view returns (bool) {\n        // need to check where exactly does proof offset usually land, see how we can get get rid of the length delimiter\n        // also review delayed message inbox issue Ottersect reported.\n        require(message.length >= INBOX_HEADER_LEN, \"BAD_SEQINBOX_PROOF\");\n\n        uint64 afterDelayedMsg;\n        (afterDelayedMsg, ) = Deserialize.u64(message, 32);\n        bytes32 messageHash = keccak256(message);\n        bytes32 beforeAcc;\n        bytes32 delayedAcc;\n\n        if (msgIndex > 0) {\n            beforeAcc = execCtx.bridge.sequencerInboxAccs(msgIndex - 1);\n        }\n        if (afterDelayedMsg > 0) {\n            delayedAcc = execCtx.bridge.delayedInboxAccs(afterDelayedMsg - 1);\n        }\n        bytes32 acc = keccak256(abi.encodePacked(beforeAcc, messageHash, delayedAcc));\n        require(acc == execCtx.bridge.sequencerInboxAccs(msgIndex), \"BAD_SEQINBOX_MESSAGE\");\n        return true;\n    }\n\n    function validateDelayedInbox(\n        ExecutionContext calldata execCtx,\n        uint64 msgIndex,\n        bytes calldata message\n    ) internal view returns (bool) {\n        require(message.length >= DELAYED_HEADER_LEN, \"BAD_DELAYED_PROOF\");\n\n        bytes32 beforeAcc;\n\n        if (msgIndex > 0) {\n            beforeAcc = execCtx.bridge.delayedInboxAccs(msgIndex - 1);\n        }\n\n        bytes32 messageDataHash = keccak256(message[DELAYED_HEADER_LEN:]);\n        bytes1 kind = message[0];\n        uint256 sender;\n        (sender, ) = Deserialize.u256(message, 1);\n\n        bytes32 messageHash = keccak256(\n            abi.encodePacked(kind, uint160(sender), message[33:DELAYED_HEADER_LEN], messageDataHash)\n        );\n        bytes32 acc = Messages.accumulateInboxMessage(beforeAcc, messageHash);\n\n        require(acc == execCtx.bridge.delayedInboxAccs(msgIndex), \"BAD_DELAYED_MESSAGE\");\n        return true;\n    }\n\n    function validateDaProof(bytes calldata proof, uint256 offset) internal view returns (uint256) {\n        // NOTE: the offset points to 40 bytes after the proof offset, which should point to a\n        // batch header flag for a sequencer inbox message\n        uint256 proofEnd;\n\n        if (proof[0] & CELESTIA_MESSAGE_HEADER_FLAG != 0) {\n            CelestiaBatchVerifier.Result result = CelestiaBatchVerifier.verifyBatch(\n                BLOBSTREAM,\n                proof[1:]\n            );\n\n            if (result == CelestiaBatchVerifier.Result.UNDECIDED) revert(\"BLOBSTREAM_UNDECIDED\");\n\n            // if its a counterfactual commitment, we replace the batch data with an empty batch\n            if (result == CelestiaBatchVerifier.Result.COUNTERFACTUAL_COMMITMENT) {\n                // this would slice the array into an empty batch\n                proofEnd = offset;\n            }\n\n            if (result == CelestiaBatchVerifier.Result.IN_BLOBSTREAM) {\n                // remove Celestia DA proof from proof\n                // add 88 for the 88 bytes in a celestia batch\n                // (the offset at this point already includes the batch header)\n                proofEnd = offset + 89;\n            }\n        }\n\n        return proofEnd;\n    }\n\n    function executeReadInboxMessage(\n        ExecutionContext calldata execCtx,\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) internal view {\n        uint256 messageOffset = mach.valueStack.pop().assumeI32();\n        uint256 ptr = mach.valueStack.pop().assumeI32();\n        uint256 msgIndex = mach.valueStack.pop().assumeI64();\n        if (\n            inst.argumentData == Instructions.INBOX_INDEX_SEQUENCER &&\n            msgIndex >= execCtx.maxInboxMessagesRead\n        ) {\n            mach.status = MachineStatus.TOO_FAR;\n            return;\n        }\n\n        if (ptr + 32 > mod.moduleMemory.size || ptr % LEAF_SIZE != 0) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n\n        uint256 leafIdx = ptr / LEAF_SIZE;\n        uint256 proofOffset = 0;\n        bytes32 leafContents;\n        MerkleProof memory merkleProof;\n        (leafContents, proofOffset, merkleProof) = mod.moduleMemory.proveLeaf(\n            leafIdx,\n            proof,\n            proofOffset\n        );\n        {\n            // TODO: support proving via an authenticated contract\n            require(proof[proofOffset] == 0, \"UNKNOWN_INBOX_PROOF\");\n            proofOffset++;\n\n            uint256 proofEnd = proof.length;\n\n            function(ExecutionContext calldata, uint64, bytes calldata)\n                internal\n                view\n                returns (bool) inboxValidate;\n\n            bool success;\n            if (inst.argumentData == Instructions.INBOX_INDEX_SEQUENCER) {\n                inboxValidate = validateSequencerInbox;\n                if (proof[proofOffset + 40] & CELESTIA_MESSAGE_HEADER_FLAG != 0) {\n                    proofEnd = validateDaProof(proof[proofOffset + 40:], proofOffset + 40);\n                }\n            } else if (inst.argumentData == Instructions.INBOX_INDEX_DELAYED) {\n                inboxValidate = validateDelayedInbox;\n            } else {\n                mach.status = MachineStatus.ERRORED;\n                return;\n            }\n            success = inboxValidate(execCtx, uint64(msgIndex), proof[proofOffset:proofEnd]);\n            if (!success) {\n                mach.status = MachineStatus.ERRORED;\n                return;\n            }\n        }\n\n        require(proof.length >= proofOffset, \"BAD_MESSAGE_PROOF\");\n        uint256 messageLength = proof.length - proofOffset;\n\n        uint32 i = 0;\n        for (; i < 32 && messageOffset + i < messageLength; i++) {\n            leafContents = setLeafByte(\n                leafContents,\n                i,\n                uint8(proof[proofOffset + messageOffset + i])\n            );\n        }\n\n        mod.moduleMemory.merkleRoot = merkleProof.computeRootFromMemory(leafIdx, leafContents);\n        mach.valueStack.push(ValueLib.newI32(i));\n    }\n\n    function executeHaltAndSetFinished(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory,\n        Instruction calldata,\n        bytes calldata\n    ) internal pure {\n        mach.status = MachineStatus.FINISHED;\n    }\n\n    function isPowerOfTwo(uint256 value) internal pure returns (bool) {\n        return value != 0 && (value & (value - 1) == 0);\n    }\n\n    function proveLastLeaf(\n        Machine memory mach,\n        uint256 offset,\n        bytes calldata proof\n    )\n        internal\n        pure\n        returns (uint256 leaf, MerkleProof memory leafProof, MerkleProof memory zeroProof)\n    {\n        string memory prefix = \"Module merkle tree:\";\n        bytes32 root = mach.modulesRoot;\n\n        {\n            Module memory leafModule;\n            uint32 leaf32;\n            (leafModule, offset) = Deserialize.module(proof, offset);\n            (leaf32, offset) = Deserialize.u32(proof, offset);\n            (leafProof, offset) = Deserialize.merkleProof(proof, offset);\n            leaf = uint256(leaf32);\n\n            bytes32 compRoot = leafProof.computeRootFromModule(leaf, leafModule);\n            require(compRoot == root, \"WRONG_ROOT_FOR_LEAF\");\n        }\n\n        // if tree is unbalanced, check that the next leaf is 0\n        bool balanced = isPowerOfTwo(leaf + 1);\n        if (balanced) {\n            require(1 << leafProof.counterparts.length == leaf + 1, \"WRONG_LEAF\");\n        } else {\n            (zeroProof, offset) = Deserialize.merkleProof(proof, offset);\n            bytes32 compRoot = zeroProof.computeRootUnsafe(leaf + 1, 0, prefix);\n            require(compRoot == root, \"WRONG_ROOT_FOR_ZERO\");\n        }\n\n        return (leaf, leafProof, zeroProof);\n    }\n\n    function executeLinkModule(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata,\n        bytes calldata proof\n    ) internal pure {\n        string memory prefix = \"Module merkle tree:\";\n        bytes32 root = mach.modulesRoot;\n\n        uint256 pointer = mach.valueStack.pop().assumeI32();\n        if (!mod.moduleMemory.isValidLeaf(pointer)) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        (bytes32 userMod, uint256 offset, ) = mod.moduleMemory.proveLeaf(\n            pointer / LEAF_SIZE,\n            proof,\n            0\n        );\n\n        (uint256 leaf, , MerkleProof memory zeroProof) = proveLastLeaf(mach, offset, proof);\n\n        bool balanced = isPowerOfTwo(leaf + 1);\n        if (balanced) {\n            mach.modulesRoot = MerkleProofLib.growToNewRoot(root, leaf + 1, userMod, 0, prefix);\n        } else {\n            mach.modulesRoot = zeroProof.computeRootUnsafe(leaf + 1, userMod, prefix);\n        }\n\n        mach.valueStack.push(ValueLib.newI32(uint32(leaf + 1)));\n    }\n\n    function executeUnlinkModule(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory,\n        Instruction calldata,\n        bytes calldata proof\n    ) internal pure {\n        string memory prefix = \"Module merkle tree:\";\n\n        (uint256 leaf, MerkleProof memory leafProof, ) = proveLastLeaf(mach, 0, proof);\n\n        bool shrink = isPowerOfTwo(leaf);\n        if (shrink) {\n            mach.modulesRoot = leafProof.counterparts[leafProof.counterparts.length - 1];\n        } else {\n            mach.modulesRoot = leafProof.computeRootUnsafe(leaf, 0, prefix);\n        }\n    }\n\n    function executeGlobalStateAccess(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) internal pure {\n        uint16 opcode = inst.opcode;\n\n        GlobalState memory state;\n        uint256 proofOffset = 0;\n        (state, proofOffset) = Deserialize.globalState(proof, proofOffset);\n        require(state.hash() == mach.globalStateHash, \"BAD_GLOBAL_STATE\");\n\n        if (\n            opcode == Instructions.GET_GLOBAL_STATE_BYTES32 ||\n            opcode == Instructions.SET_GLOBAL_STATE_BYTES32\n        ) {\n            executeGetOrSetBytes32(mach, mod, state, inst, proof[proofOffset:]);\n        } else if (opcode == Instructions.GET_GLOBAL_STATE_U64) {\n            executeGetU64(mach, state);\n        } else if (opcode == Instructions.SET_GLOBAL_STATE_U64) {\n            executeSetU64(mach, state);\n        } else {\n            revert(\"INVALID_GLOBALSTATE_OPCODE\");\n        }\n\n        mach.globalStateHash = state.hash();\n    }\n\n    function executeNewCoThread(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory,\n        Instruction calldata,\n        bytes calldata\n    ) internal pure {\n        if (mach.recoveryPc != MachineLib.NO_RECOVERY_PC) {\n            // cannot create new cothread from inside cothread\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        mach.frameMultiStack.pushNew();\n        mach.valueMultiStack.pushNew();\n    }\n\n    function provePopCothread(MultiStack memory multi, bytes calldata proof) internal pure {\n        uint256 proofOffset = 0;\n        bytes32 newInactiveCoThread;\n        bytes32 newRemaining;\n        (newInactiveCoThread, proofOffset) = Deserialize.b32(proof, proofOffset);\n        (newRemaining, proofOffset) = Deserialize.b32(proof, proofOffset);\n        if (newInactiveCoThread == MultiStackLib.NO_STACK_HASH) {\n            require(newRemaining == bytes32(0), \"WRONG_COTHREAD_EMPTY\");\n            require(multi.remainingHash == bytes32(0), \"WRONG_COTHREAD_EMPTY\");\n        } else {\n            require(\n                keccak256(abi.encodePacked(\"cothread:\", newInactiveCoThread, newRemaining)) ==\n                    multi.remainingHash,\n                \"WRONG_COTHREAD_POP\"\n            );\n        }\n        multi.remainingHash = newRemaining;\n        multi.inactiveStackHash = newInactiveCoThread;\n    }\n\n    function executePopCoThread(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory,\n        Instruction calldata,\n        bytes calldata proof\n    ) internal pure {\n        if (mach.recoveryPc != MachineLib.NO_RECOVERY_PC) {\n            // cannot pop cothread from inside cothread\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        if (mach.frameMultiStack.inactiveStackHash == MultiStackLib.NO_STACK_HASH) {\n            // cannot pop cothread if there isn't one\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        provePopCothread(mach.valueMultiStack, proof);\n        provePopCothread(mach.frameMultiStack, proof[64:]);\n    }\n\n    function executeSwitchCoThread(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory,\n        Instruction calldata inst,\n        bytes calldata\n    ) internal pure {\n        if (mach.frameMultiStack.inactiveStackHash == MultiStackLib.NO_STACK_HASH) {\n            // cannot switch cothread if there isn't one\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        if (inst.argumentData == 0) {\n            if (mach.recoveryPc == MachineLib.NO_RECOVERY_PC) {\n                // switching to main thread, from main thread\n                mach.status = MachineStatus.ERRORED;\n                return;\n            }\n            mach.recoveryPc = MachineLib.NO_RECOVERY_PC;\n        } else {\n            if (mach.recoveryPc != MachineLib.NO_RECOVERY_PC) {\n                // switching from cothread to cothread\n                mach.status = MachineStatus.ERRORED;\n                return;\n            }\n            mach.setRecoveryFromPc(uint32(inst.argumentData));\n        }\n        mach.switchCoThreadStacks();\n    }\n\n    function executeOneStep(\n        ExecutionContext calldata execCtx,\n        Machine calldata startMach,\n        Module calldata startMod,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) external view override returns (Machine memory mach, Module memory mod) {\n        mach = startMach;\n        mod = startMod;\n\n        uint16 opcode = inst.opcode;\n\n        function(\n            ExecutionContext calldata,\n            Machine memory,\n            Module memory,\n            Instruction calldata,\n            bytes calldata\n        ) internal view impl;\n\n        if (\n            opcode >= Instructions.GET_GLOBAL_STATE_BYTES32 &&\n            opcode <= Instructions.SET_GLOBAL_STATE_U64\n        ) {\n            impl = executeGlobalStateAccess;\n        } else if (opcode == Instructions.READ_PRE_IMAGE) {\n            impl = executeReadPreImage;\n        } else if (opcode == Instructions.READ_INBOX_MESSAGE) {\n            impl = executeReadInboxMessage;\n        } else if (opcode == Instructions.HALT_AND_SET_FINISHED) {\n            impl = executeHaltAndSetFinished;\n        } else if (opcode == Instructions.LINK_MODULE) {\n            impl = executeLinkModule;\n        } else if (opcode == Instructions.UNLINK_MODULE) {\n            impl = executeUnlinkModule;\n        } else if (opcode == Instructions.NEW_COTHREAD) {\n            impl = executeNewCoThread;\n        } else if (opcode == Instructions.POP_COTHREAD) {\n            impl = executePopCoThread;\n        } else if (opcode == Instructions.SWITCH_COTHREAD) {\n            impl = executeSwitchCoThread;\n        } else {\n            revert(\"INVALID_MEMORY_OPCODE\");\n        }\n\n        impl(execCtx, mach, mod, inst, proof);\n    }\n}\n"}, "src/osp/OneStepProverMath.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../state/Value.sol\";\nimport \"../state/Machine.sol\";\nimport \"../state/Module.sol\";\nimport \"../state/Deserialize.sol\";\nimport \"./IOneStepProver.sol\";\n\ncontract OneStepProverMath is IOneStepProver {\n    using ValueLib for Value;\n    using ValueStackLib for ValueStack;\n\n    function executeEqz(\n        Machine memory mach,\n        Module memory,\n        Instruction calldata inst,\n        bytes calldata\n    ) internal pure {\n        Value memory v = mach.valueStack.pop();\n        if (inst.opcode == Instructions.I32_EQZ) {\n            require(v.valueType == ValueType.I32, \"NOT_I32\");\n        } else if (inst.opcode == Instructions.I64_EQZ) {\n            require(v.valueType == ValueType.I64, \"NOT_I64\");\n        } else {\n            revert(\"BAD_EQZ\");\n        }\n\n        uint32 output;\n        if (v.contents == 0) {\n            output = 1;\n        } else {\n            output = 0;\n        }\n\n        mach.valueStack.push(ValueLib.newI32(output));\n    }\n\n    function signExtend(uint32 a) internal pure returns (uint64) {\n        if (a & (1 << 31) != 0) {\n            return uint64(a) | uint64(0xffffffff00000000);\n        }\n        return uint64(a);\n    }\n\n    function i64RelOp(\n        uint64 a,\n        uint64 b,\n        uint16 relop\n    ) internal pure returns (bool) {\n        if (relop == Instructions.IRELOP_EQ) {\n            return (a == b);\n        } else if (relop == Instructions.IRELOP_NE) {\n            return (a != b);\n        } else if (relop == Instructions.IRELOP_LT_S) {\n            return (int64(a) < int64(b));\n        } else if (relop == Instructions.IRELOP_LT_U) {\n            return (a < b);\n        } else if (relop == Instructions.IRELOP_GT_S) {\n            return (int64(a) > int64(b));\n        } else if (relop == Instructions.IRELOP_GT_U) {\n            return (a > b);\n        } else if (relop == Instructions.IRELOP_LE_S) {\n            return (int64(a) <= int64(b));\n        } else if (relop == Instructions.IRELOP_LE_U) {\n            return (a <= b);\n        } else if (relop == Instructions.IRELOP_GE_S) {\n            return (int64(a) >= int64(b));\n        } else if (relop == Instructions.IRELOP_GE_U) {\n            return (a >= b);\n        } else {\n            revert(\"BAD IRELOP\");\n        }\n    }\n\n    function executeI32RelOp(\n        Machine memory mach,\n        Module memory,\n        Instruction calldata inst,\n        bytes calldata\n    ) internal pure {\n        uint32 b = mach.valueStack.pop().assumeI32();\n        uint32 a = mach.valueStack.pop().assumeI32();\n\n        uint16 relop = inst.opcode - Instructions.I32_RELOP_BASE;\n        uint64 a64;\n        uint64 b64;\n\n        if (\n            relop == Instructions.IRELOP_LT_S ||\n            relop == Instructions.IRELOP_GT_S ||\n            relop == Instructions.IRELOP_LE_S ||\n            relop == Instructions.IRELOP_GE_S\n        ) {\n            a64 = signExtend(a);\n            b64 = signExtend(b);\n        } else {\n            a64 = uint64(a);\n            b64 = uint64(b);\n        }\n\n        bool res = i64RelOp(a64, b64, relop);\n\n        mach.valueStack.push(ValueLib.newBoolean(res));\n    }\n\n    function executeI64RelOp(\n        Machine memory mach,\n        Module memory,\n        Instruction calldata inst,\n        bytes calldata\n    ) internal pure {\n        uint64 b = mach.valueStack.pop().assumeI64();\n        uint64 a = mach.valueStack.pop().assumeI64();\n\n        uint16 relop = inst.opcode - Instructions.I64_RELOP_BASE;\n\n        bool res = i64RelOp(a, b, relop);\n\n        mach.valueStack.push(ValueLib.newBoolean(res));\n    }\n\n    function genericIUnOp(\n        uint64 a,\n        uint16 unop,\n        uint16 bits\n    ) internal pure returns (uint32) {\n        require(bits == 32 || bits == 64, \"WRONG USE OF genericUnOp\");\n        if (unop == Instructions.IUNOP_CLZ) {\n            /* curbits is one-based to keep with unsigned mathematics */\n            uint32 curbit = bits;\n            while (curbit > 0 && (a & (1 << (curbit - 1)) == 0)) {\n                curbit -= 1;\n            }\n            return (bits - curbit);\n        } else if (unop == Instructions.IUNOP_CTZ) {\n            uint32 curbit = 0;\n            while (curbit < bits && ((a & (1 << curbit)) == 0)) {\n                curbit += 1;\n            }\n            return curbit;\n        } else if (unop == Instructions.IUNOP_POPCNT) {\n            uint32 curbit = 0;\n            uint32 res = 0;\n            while (curbit < bits) {\n                if ((a & (1 << curbit)) != 0) {\n                    res += 1;\n                }\n                curbit++;\n            }\n            return res;\n        }\n        revert(\"BAD IUnOp\");\n    }\n\n    function executeI32UnOp(\n        Machine memory mach,\n        Module memory,\n        Instruction calldata inst,\n        bytes calldata\n    ) internal pure {\n        uint32 a = mach.valueStack.pop().assumeI32();\n\n        uint16 unop = inst.opcode - Instructions.I32_UNOP_BASE;\n\n        uint32 res = genericIUnOp(a, unop, 32);\n\n        mach.valueStack.push(ValueLib.newI32(res));\n    }\n\n    function executeI64UnOp(\n        Machine memory mach,\n        Module memory,\n        Instruction calldata inst,\n        bytes calldata\n    ) internal pure {\n        uint64 a = mach.valueStack.pop().assumeI64();\n\n        uint16 unop = inst.opcode - Instructions.I64_UNOP_BASE;\n\n        uint64 res = uint64(genericIUnOp(a, unop, 64));\n\n        mach.valueStack.push(ValueLib.newI64(res));\n    }\n\n    function rotl32(uint32 a, uint32 b) internal pure returns (uint32) {\n        b %= 32;\n        return (a << b) | (a >> (32 - b));\n    }\n\n    function rotl64(uint64 a, uint64 b) internal pure returns (uint64) {\n        b %= 64;\n        return (a << b) | (a >> (64 - b));\n    }\n\n    function rotr32(uint32 a, uint32 b) internal pure returns (uint32) {\n        b %= 32;\n        return (a >> b) | (a << (32 - b));\n    }\n\n    function rotr64(uint64 a, uint64 b) internal pure returns (uint64) {\n        b %= 64;\n        return (a >> b) | (a << (64 - b));\n    }\n\n    function genericBinOp(\n        uint64 a,\n        uint64 b,\n        uint16 opcodeOffset\n    ) internal pure returns (uint64, bool) {\n        unchecked {\n            if (opcodeOffset == 0) {\n                // add\n                return (a + b, false);\n            } else if (opcodeOffset == 1) {\n                // sub\n                return (a - b, false);\n            } else if (opcodeOffset == 2) {\n                // mul\n                return (a * b, false);\n            } else if (opcodeOffset == 4) {\n                // div_u\n                if (b == 0) {\n                    return (0, true);\n                }\n                return (a / b, false);\n            } else if (opcodeOffset == 6) {\n                // rem_u\n                if (b == 0) {\n                    return (0, true);\n                }\n                return (a % b, false);\n            } else if (opcodeOffset == 7) {\n                // and\n                return (a & b, false);\n            } else if (opcodeOffset == 8) {\n                // or\n                return (a | b, false);\n            } else if (opcodeOffset == 9) {\n                // xor\n                return (a ^ b, false);\n            } else {\n                revert(\"INVALID_GENERIC_BIN_OP\");\n            }\n        }\n    }\n\n    function executeI32BinOp(\n        Machine memory mach,\n        Module memory,\n        Instruction calldata inst,\n        bytes calldata\n    ) internal pure {\n        uint32 b = mach.valueStack.pop().assumeI32();\n        uint32 a = mach.valueStack.pop().assumeI32();\n        uint32 res;\n\n        uint16 opcodeOffset = inst.opcode - Instructions.I32_ADD;\n\n        unchecked {\n            if (opcodeOffset == 3) {\n                // div_s\n                if (b == 0 || (int32(a) == -2147483648 && int32(b) == -1)) {\n                    mach.status = MachineStatus.ERRORED;\n                    return;\n                }\n                res = uint32(int32(a) / int32(b));\n            } else if (opcodeOffset == 5) {\n                // rem_s\n                if (b == 0) {\n                    mach.status = MachineStatus.ERRORED;\n                    return;\n                }\n                res = uint32(int32(a) % int32(b));\n            } else if (opcodeOffset == 10) {\n                // shl\n                res = a << (b % 32);\n            } else if (opcodeOffset == 12) {\n                // shr_u\n                res = a >> (b % 32);\n            } else if (opcodeOffset == 11) {\n                // shr_s\n                res = uint32(int32(a) >> (b % 32));\n            } else if (opcodeOffset == 13) {\n                // rotl\n                res = rotl32(a, b);\n            } else if (opcodeOffset == 14) {\n                // rotr\n                res = rotr32(a, b);\n            } else {\n                (uint64 computed, bool err) = genericBinOp(a, b, opcodeOffset);\n                if (err) {\n                    mach.status = MachineStatus.ERRORED;\n                    return;\n                }\n                res = uint32(computed);\n            }\n        }\n\n        mach.valueStack.push(ValueLib.newI32(res));\n    }\n\n    function executeI64BinOp(\n        Machine memory mach,\n        Module memory,\n        Instruction calldata inst,\n        bytes calldata\n    ) internal pure {\n        uint64 b = mach.valueStack.pop().assumeI64();\n        uint64 a = mach.valueStack.pop().assumeI64();\n        uint64 res;\n\n        uint16 opcodeOffset = inst.opcode - Instructions.I64_ADD;\n\n        unchecked {\n            if (opcodeOffset == 3) {\n                // div_s\n                if (b == 0 || (int64(a) == -9223372036854775808 && int64(b) == -1)) {\n                    mach.status = MachineStatus.ERRORED;\n                    return;\n                }\n                res = uint64(int64(a) / int64(b));\n            } else if (opcodeOffset == 5) {\n                // rem_s\n                if (b == 0) {\n                    mach.status = MachineStatus.ERRORED;\n                    return;\n                }\n                res = uint64(int64(a) % int64(b));\n            } else if (opcodeOffset == 10) {\n                // shl\n                res = a << (b % 64);\n            } else if (opcodeOffset == 12) {\n                // shr_u\n                res = a >> (b % 64);\n            } else if (opcodeOffset == 11) {\n                // shr_s\n                res = uint64(int64(a) >> (b % 64));\n            } else if (opcodeOffset == 13) {\n                // rotl\n                res = rotl64(a, b);\n            } else if (opcodeOffset == 14) {\n                // rotr\n                res = rotr64(a, b);\n            } else {\n                bool err;\n                (res, err) = genericBinOp(a, b, opcodeOffset);\n                if (err) {\n                    mach.status = MachineStatus.ERRORED;\n                    return;\n                }\n            }\n        }\n\n        mach.valueStack.push(ValueLib.newI64(res));\n    }\n\n    function executeI32WrapI64(\n        Machine memory mach,\n        Module memory,\n        Instruction calldata,\n        bytes calldata\n    ) internal pure {\n        uint64 a = mach.valueStack.pop().assumeI64();\n\n        uint32 a32 = uint32(a);\n\n        mach.valueStack.push(ValueLib.newI32(a32));\n    }\n\n    function executeI64ExtendI32(\n        Machine memory mach,\n        Module memory,\n        Instruction calldata inst,\n        bytes calldata\n    ) internal pure {\n        uint32 a = mach.valueStack.pop().assumeI32();\n\n        uint64 a64;\n\n        if (inst.opcode == Instructions.I64_EXTEND_I32_S) {\n            a64 = signExtend(a);\n        } else {\n            a64 = uint64(a);\n        }\n\n        mach.valueStack.push(ValueLib.newI64(a64));\n    }\n\n    function executeExtendSameType(\n        Machine memory mach,\n        Module memory,\n        Instruction calldata inst,\n        bytes calldata\n    ) internal pure {\n        ValueType ty;\n        uint8 sourceBits;\n        if (inst.opcode == Instructions.I32_EXTEND_8S) {\n            ty = ValueType.I32;\n            sourceBits = 8;\n        } else if (inst.opcode == Instructions.I32_EXTEND_16S) {\n            ty = ValueType.I32;\n            sourceBits = 16;\n        } else if (inst.opcode == Instructions.I64_EXTEND_8S) {\n            ty = ValueType.I64;\n            sourceBits = 8;\n        } else if (inst.opcode == Instructions.I64_EXTEND_16S) {\n            ty = ValueType.I64;\n            sourceBits = 16;\n        } else if (inst.opcode == Instructions.I64_EXTEND_32S) {\n            ty = ValueType.I64;\n            sourceBits = 32;\n        } else {\n            revert(\"INVALID_EXTEND_SAME_TYPE\");\n        }\n        uint256 resultMask;\n        if (ty == ValueType.I32) {\n            resultMask = (1 << 32) - 1;\n        } else {\n            resultMask = (1 << 64) - 1;\n        }\n        Value memory val = mach.valueStack.pop();\n        require(val.valueType == ty, \"BAD_EXTEND_SAME_TYPE_TYPE\");\n        uint256 sourceMask = (1 << sourceBits) - 1;\n        val.contents &= sourceMask;\n        if (val.contents & (1 << (sourceBits - 1)) != 0) {\n            // Extend sign flag\n            val.contents |= resultMask & ~sourceMask;\n        }\n        mach.valueStack.push(val);\n    }\n\n    function executeReinterpret(\n        Machine memory mach,\n        Module memory,\n        Instruction calldata inst,\n        bytes calldata\n    ) internal pure {\n        ValueType destTy;\n        ValueType sourceTy;\n        if (inst.opcode == Instructions.I32_REINTERPRET_F32) {\n            destTy = ValueType.I32;\n            sourceTy = ValueType.F32;\n        } else if (inst.opcode == Instructions.I64_REINTERPRET_F64) {\n            destTy = ValueType.I64;\n            sourceTy = ValueType.F64;\n        } else if (inst.opcode == Instructions.F32_REINTERPRET_I32) {\n            destTy = ValueType.F32;\n            sourceTy = ValueType.I32;\n        } else if (inst.opcode == Instructions.F64_REINTERPRET_I64) {\n            destTy = ValueType.F64;\n            sourceTy = ValueType.I64;\n        } else {\n            revert(\"INVALID_REINTERPRET\");\n        }\n        Value memory val = mach.valueStack.pop();\n        require(val.valueType == sourceTy, \"INVALID_REINTERPRET_TYPE\");\n        val.valueType = destTy;\n        mach.valueStack.push(val);\n    }\n\n    function executeOneStep(\n        ExecutionContext calldata,\n        Machine calldata startMach,\n        Module calldata startMod,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) external pure override returns (Machine memory mach, Module memory mod) {\n        mach = startMach;\n        mod = startMod;\n\n        uint16 opcode = inst.opcode;\n\n        function(Machine memory, Module memory, Instruction calldata, bytes calldata)\n            internal\n            pure impl;\n        if (opcode == Instructions.I32_EQZ || opcode == Instructions.I64_EQZ) {\n            impl = executeEqz;\n        } else if (\n            opcode >= Instructions.I32_RELOP_BASE &&\n            opcode <= Instructions.I32_RELOP_BASE + Instructions.IRELOP_LAST\n        ) {\n            impl = executeI32RelOp;\n        } else if (\n            opcode >= Instructions.I32_UNOP_BASE &&\n            opcode <= Instructions.I32_UNOP_BASE + Instructions.IUNOP_LAST\n        ) {\n            impl = executeI32UnOp;\n        } else if (opcode >= Instructions.I32_ADD && opcode <= Instructions.I32_ROTR) {\n            impl = executeI32BinOp;\n        } else if (\n            opcode >= Instructions.I64_RELOP_BASE &&\n            opcode <= Instructions.I64_RELOP_BASE + Instructions.IRELOP_LAST\n        ) {\n            impl = executeI64RelOp;\n        } else if (\n            opcode >= Instructions.I64_UNOP_BASE &&\n            opcode <= Instructions.I64_UNOP_BASE + Instructions.IUNOP_LAST\n        ) {\n            impl = executeI64UnOp;\n        } else if (opcode >= Instructions.I64_ADD && opcode <= Instructions.I64_ROTR) {\n            impl = executeI64BinOp;\n        } else if (opcode == Instructions.I32_WRAP_I64) {\n            impl = executeI32WrapI64;\n        } else if (\n            opcode == Instructions.I64_EXTEND_I32_S || opcode == Instructions.I64_EXTEND_I32_U\n        ) {\n            impl = executeI64ExtendI32;\n        } else if (opcode >= Instructions.I32_EXTEND_8S && opcode <= Instructions.I64_EXTEND_32S) {\n            impl = executeExtendSameType;\n        } else if (\n            opcode >= Instructions.I32_REINTERPRET_F32 && opcode <= Instructions.F64_REINTERPRET_I64\n        ) {\n            impl = executeReinterpret;\n        } else {\n            revert(\"INVALID_OPCODE\");\n        }\n\n        impl(mach, mod, inst, proof);\n    }\n}\n"}, "src/osp/OneStepProverMemory.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../state/Value.sol\";\nimport \"../state/Machine.sol\";\nimport \"../state/Deserialize.sol\";\nimport \"../state/ModuleMemory.sol\";\nimport \"./IOneStepProver.sol\";\n\ncontract OneStepProverMemory is IOneStepProver {\n    using MerkleProofLib for MerkleProof;\n    using ModuleMemoryLib for ModuleMemory;\n    using ValueLib for Value;\n    using ValueStackLib for ValueStack;\n\n    uint256 private constant LEAF_SIZE = 32;\n    uint64 private constant PAGE_SIZE = 65536;\n\n    function setLeafByte(\n        bytes32 oldLeaf,\n        uint256 idx,\n        uint8 val\n    ) internal pure returns (bytes32) {\n        require(idx < LEAF_SIZE, \"BAD_SET_LEAF_BYTE_IDX\");\n        // Take into account that we are casting the leaf to a big-endian integer\n        uint256 leafShift = (LEAF_SIZE - 1 - idx) * 8;\n        uint256 newLeaf = uint256(oldLeaf);\n        newLeaf &= ~(0xFF << leafShift);\n        newLeaf |= uint256(val) << leafShift;\n        return bytes32(newLeaf);\n    }\n\n    function executeMemoryLoad(\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) internal pure {\n        ValueType ty;\n        uint256 readBytes;\n        bool signed;\n        if (inst.opcode == Instructions.I32_LOAD) {\n            ty = ValueType.I32;\n            readBytes = 4;\n            signed = false;\n        } else if (inst.opcode == Instructions.I64_LOAD) {\n            ty = ValueType.I64;\n            readBytes = 8;\n            signed = false;\n        } else if (inst.opcode == Instructions.F32_LOAD) {\n            ty = ValueType.F32;\n            readBytes = 4;\n            signed = false;\n        } else if (inst.opcode == Instructions.F64_LOAD) {\n            ty = ValueType.F64;\n            readBytes = 8;\n            signed = false;\n        } else if (inst.opcode == Instructions.I32_LOAD8_S) {\n            ty = ValueType.I32;\n            readBytes = 1;\n            signed = true;\n        } else if (inst.opcode == Instructions.I32_LOAD8_U) {\n            ty = ValueType.I32;\n            readBytes = 1;\n            signed = false;\n        } else if (inst.opcode == Instructions.I32_LOAD16_S) {\n            ty = ValueType.I32;\n            readBytes = 2;\n            signed = true;\n        } else if (inst.opcode == Instructions.I32_LOAD16_U) {\n            ty = ValueType.I32;\n            readBytes = 2;\n            signed = false;\n        } else if (inst.opcode == Instructions.I64_LOAD8_S) {\n            ty = ValueType.I64;\n            readBytes = 1;\n            signed = true;\n        } else if (inst.opcode == Instructions.I64_LOAD8_U) {\n            ty = ValueType.I64;\n            readBytes = 1;\n            signed = false;\n        } else if (inst.opcode == Instructions.I64_LOAD16_S) {\n            ty = ValueType.I64;\n            readBytes = 2;\n            signed = true;\n        } else if (inst.opcode == Instructions.I64_LOAD16_U) {\n            ty = ValueType.I64;\n            readBytes = 2;\n            signed = false;\n        } else if (inst.opcode == Instructions.I64_LOAD32_S) {\n            ty = ValueType.I64;\n            readBytes = 4;\n            signed = true;\n        } else if (inst.opcode == Instructions.I64_LOAD32_U) {\n            ty = ValueType.I64;\n            readBytes = 4;\n            signed = false;\n        } else {\n            revert(\"INVALID_MEMORY_LOAD_OPCODE\");\n        }\n\n        uint256 index = inst.argumentData + mach.valueStack.pop().assumeI32();\n        (bool err, uint256 value, ) = mod.moduleMemory.load(index, readBytes, proof, 0);\n        if (err) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        uint64 readValue = uint64(value);\n\n        if (signed) {\n            // Go down to the original uint size, change to signed, go up to correct size, convert back to unsigned\n            if (readBytes == 1 && ty == ValueType.I32) {\n                readValue = uint32(int32(int8(uint8(readValue))));\n            } else if (readBytes == 1 && ty == ValueType.I64) {\n                readValue = uint64(int64(int8(uint8(readValue))));\n            } else if (readBytes == 2 && ty == ValueType.I32) {\n                readValue = uint32(int32(int16(uint16(readValue))));\n            } else if (readBytes == 2 && ty == ValueType.I64) {\n                readValue = uint64(int64(int16(uint16(readValue))));\n            } else if (readBytes == 4 && ty == ValueType.I64) {\n                readValue = uint64(int64(int32(uint32(readValue))));\n            } else {\n                revert(\"BAD_READ_BYTES_SIGNED\");\n            }\n        }\n\n        mach.valueStack.push(Value({valueType: ty, contents: readValue}));\n    }\n\n    function executeMemoryStore(\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) internal pure {\n        uint64 writeBytes;\n        uint64 toWrite;\n        {\n            ValueType ty;\n            if (inst.opcode == Instructions.I32_STORE) {\n                ty = ValueType.I32;\n                writeBytes = 4;\n            } else if (inst.opcode == Instructions.I64_STORE) {\n                ty = ValueType.I64;\n                writeBytes = 8;\n            } else if (inst.opcode == Instructions.F32_STORE) {\n                ty = ValueType.F32;\n                writeBytes = 4;\n            } else if (inst.opcode == Instructions.F64_STORE) {\n                ty = ValueType.F64;\n                writeBytes = 8;\n            } else if (inst.opcode == Instructions.I32_STORE8) {\n                ty = ValueType.I32;\n                writeBytes = 1;\n            } else if (inst.opcode == Instructions.I32_STORE16) {\n                ty = ValueType.I32;\n                writeBytes = 2;\n            } else if (inst.opcode == Instructions.I64_STORE8) {\n                ty = ValueType.I64;\n                writeBytes = 1;\n            } else if (inst.opcode == Instructions.I64_STORE16) {\n                ty = ValueType.I64;\n                writeBytes = 2;\n            } else if (inst.opcode == Instructions.I64_STORE32) {\n                ty = ValueType.I64;\n                writeBytes = 4;\n            } else {\n                revert(\"INVALID_MEMORY_STORE_OPCODE\");\n            }\n\n            Value memory writingVal = mach.valueStack.pop();\n            require(writingVal.valueType == ty, \"BAD_STORE_TYPE\");\n            toWrite = uint64(writingVal.contents);\n            if (writeBytes < 8) {\n                toWrite &= (uint64(1) << (writeBytes * 8)) - 1;\n            }\n        }\n\n        // Neither of these can overflow as they're computed with much less than 256 bit integers.\n        uint256 startIdx = inst.argumentData + mach.valueStack.pop().assumeI32();\n        if (startIdx + writeBytes > mod.moduleMemory.size) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n\n        uint256 proofOffset = 0;\n        uint256 lastProvedLeafIdx = ~uint256(0);\n        MerkleProof memory lastProvedMerkle;\n        bytes32 lastProvedLeafContents;\n        for (uint256 i = 0; i < writeBytes; i++) {\n            uint256 idx = startIdx + i;\n            uint256 leafIdx = idx / LEAF_SIZE;\n            if (leafIdx != lastProvedLeafIdx) {\n                if (lastProvedLeafIdx != ~uint256(0)) {\n                    // Apply the last leaf update\n                    mod.moduleMemory.merkleRoot = lastProvedMerkle.computeRootFromMemory(\n                        lastProvedLeafIdx,\n                        lastProvedLeafContents\n                    );\n                }\n                // This hits the stack size if we phrase it as mod.moduleMemory.proveLeaf(...)\n                (lastProvedLeafContents, proofOffset, lastProvedMerkle) = ModuleMemoryLib.proveLeaf(\n                    mod.moduleMemory,\n                    leafIdx,\n                    proof,\n                    proofOffset\n                );\n                lastProvedLeafIdx = leafIdx;\n            }\n            uint256 indexWithinLeaf = idx % LEAF_SIZE;\n            lastProvedLeafContents = setLeafByte(\n                lastProvedLeafContents,\n                indexWithinLeaf,\n                uint8(toWrite)\n            );\n            toWrite >>= 8;\n        }\n        mod.moduleMemory.merkleRoot = lastProvedMerkle.computeRootFromMemory(\n            lastProvedLeafIdx,\n            lastProvedLeafContents\n        );\n    }\n\n    function executeMemorySize(\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata,\n        bytes calldata\n    ) internal pure {\n        uint32 pages = uint32(mod.moduleMemory.size / PAGE_SIZE);\n        mach.valueStack.push(ValueLib.newI32(pages));\n    }\n\n    function executeMemoryGrow(\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata,\n        bytes calldata\n    ) internal pure {\n        uint32 oldPages = uint32(mod.moduleMemory.size / PAGE_SIZE);\n        uint32 growingPages = mach.valueStack.pop().assumeI32();\n        // Safe as the input integers are too small to overflow a uint256\n        uint256 newSize = uint256(oldPages) + uint256(growingPages);\n        if (newSize <= mod.moduleMemory.maxSize) {\n            mod.moduleMemory.size = uint64(newSize * PAGE_SIZE);\n            mach.valueStack.push(ValueLib.newI32(oldPages));\n        } else {\n            mach.valueStack.push(ValueLib.newI32(~uint32(0)));\n        }\n    }\n\n    function executeOneStep(\n        ExecutionContext calldata,\n        Machine calldata startMach,\n        Module calldata startMod,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) external pure override returns (Machine memory mach, Module memory mod) {\n        mach = startMach;\n        mod = startMod;\n\n        uint16 opcode = inst.opcode;\n\n        function(Machine memory, Module memory, Instruction calldata, bytes calldata)\n            internal\n            pure impl;\n        if (opcode >= Instructions.I32_LOAD && opcode <= Instructions.I64_LOAD32_U) {\n            impl = executeMemoryLoad;\n        } else if (opcode >= Instructions.I32_STORE && opcode <= Instructions.I64_STORE32) {\n            impl = executeMemoryStore;\n        } else if (opcode == Instructions.MEMORY_SIZE) {\n            impl = executeMemorySize;\n        } else if (opcode == Instructions.MEMORY_GROW) {\n            impl = executeMemoryGrow;\n        } else {\n            revert(\"INVALID_MEMORY_OPCODE\");\n        }\n\n        impl(mach, mod, inst, proof);\n    }\n}\n"}, "src/precompiles/ArbAddressTable.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\n/**\n * @title Allows registering / retrieving addresses at uint indices, saving calldata.\n * @notice Precompiled contract that exists in every Arbitrum chain at 0x0000000000000000000000000000000000000066.\n */\ninterface ArbAddressTable {\n    /**\n     * @notice Check whether an address exists in the address table\n     * @param addr address to check for presence in table\n     * @return true if address is in table\n     */\n    function addressExists(address addr) external view returns (bool);\n\n    /**\n     * @notice compress an address and return the result\n     * @param addr address to compress\n     * @return compressed address bytes\n     */\n    function compress(address addr) external returns (bytes memory);\n\n    /**\n     * @notice read a compressed address from a bytes buffer\n     * @param buf bytes buffer containing an address\n     * @param offset offset of target address\n     * @return resulting address and updated offset into the buffer (revert if buffer is too short)\n     */\n    function decompress(bytes calldata buf, uint256 offset)\n        external\n        view\n        returns (address, uint256);\n\n    /**\n     * @param addr address to lookup\n     * @return index of an address in the address table (revert if address isn't in the table)\n     */\n    function lookup(address addr) external view returns (uint256);\n\n    /**\n     * @param index index to lookup address\n     * @return address at a given index in address table (revert if index is beyond end of table)\n     */\n    function lookupIndex(uint256 index) external view returns (address);\n\n    /**\n     * @notice Register an address in the address table\n     * @param addr address to register\n     * @return index of the address (existing index, or newly created index if not already registered)\n     */\n    function register(address addr) external returns (uint256);\n\n    /**\n     * @return size of address table (= first unused index)\n     */\n    function size() external view returns (uint256);\n}\n"}, "src/precompiles/ArbAggregator.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\n/// @title Provides aggregators and their users methods for configuring how they participate in L1 aggregation.\n/// @notice Precompiled contract that exists in every Arbitrum chain at 0x000000000000000000000000000000000000006d\ninterface ArbAggregator {\n    /// @notice Deprecated, customization of preferred aggregator is no longer supported\n    /// @notice Get the address of an arbitrarily chosen batch poster.\n    /// @param addr ignored\n    /// @return (batchPosterAddress, true)\n    function getPreferredAggregator(address addr) external view returns (address, bool);\n\n    /// @notice Deprecated, there is no longer a single preferred aggregator, use getBatchPosters instead\n    /// @notice Get default aggregator.\n    function getDefaultAggregator() external view returns (address);\n\n    /// @notice Get a list of all current batch posters\n    /// @return Batch poster addresses\n    function getBatchPosters() external view returns (address[] memory);\n\n    /// @notice Adds newBatchPoster as a batch poster\n    /// This reverts unless called by a chain owner\n    /// @param newBatchPoster New batch poster\n    function addBatchPoster(address newBatchPoster) external;\n\n    /// @notice Get the address where fees to batchPoster are sent.\n    /// @param batchPoster The batch poster to get the fee collector for\n    /// @return The fee collectors address. This will sometimes but not always be the same as the batch poster's address.\n    function getFeeCollector(address batchPoster) external view returns (address);\n\n    /// @notice Set the address where fees to batchPoster are sent.\n    /// This reverts unless called by the batch poster, its fee collector, or a chain owner\n    /// @param batchPoster The batch poster to set the fee collector for\n    /// @param newFeeCollector The new fee collector to set\n    function setFeeCollector(address batchPoster, address newFeeCollector) external;\n\n    /// @notice Deprecated, always returns zero\n    /// @notice Get the tx base fee (in approximate L1 gas) for aggregator\n    /// @param aggregator The aggregator to get the base fee for\n    function getTxBaseFee(address aggregator) external view returns (uint256);\n\n    /// @notice Deprecated, is now a no-op\n    /// @notice Set the tx base fee (in approximate L1 gas) for aggregator\n    /// Revert unless called by aggregator or the chain owner\n    /// Revert if feeInL1Gas is outside the chain's allowed bounds\n    /// @param aggregator The aggregator to set the fee for\n    /// @param feeInL1Gas The base fee in L1 gas\n    function setTxBaseFee(address aggregator, uint256 feeInL1Gas) external;\n}\n"}, "src/precompiles/ArbBLS.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\n/// @title Disabled precompile, formerly used to register BLS public keys.\n/// @notice Precompiled contract that exists in every Arbitrum chain at 0x0000000000000000000000000000000000000067.\ninterface ArbBLS {\n\n}\n"}, "src/precompiles/ArbDebug.sol": {"content": "// Copyright 2021-2023, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\n/**\n * @title A test contract whose methods are only accessible in debug mode\n * @notice Precompiled contract that exists in every Arbitrum chain at 0x00000000000000000000000000000000000000ff.\n */\ninterface ArbDebug {\n    /// @notice Caller becomes a chain owner\n    function becomeChainOwner() external;\n\n    /// @notice Emit events with values based on the args provided\n    function events(bool flag, bytes32 value) external payable returns (address, uint256);\n\n    /// @notice Tries (and fails) to emit logs in a view context\n    function eventsView() external view;\n\n    // Events that exist for testing log creation and pricing\n    event Basic(bool flag, bytes32 indexed value);\n    event Mixed(\n        bool indexed flag,\n        bool not,\n        bytes32 indexed value,\n        address conn,\n        address indexed caller\n    );\n    event Store(\n        bool indexed flag,\n        address indexed field,\n        uint24 number,\n        bytes32 value,\n        bytes store\n    );\n\n    function customRevert(uint64 number) external pure;\n\n    function panic() external;\n\n    function legacyError() external pure;\n\n    error Custom(uint64, string, bool);\n    error Unused();\n}\n"}, "src/precompiles/ArbFunctionTable.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\n/// @title Deprecated - Provided aggregator's the ability to manage function tables,\n//  this enables one form of transaction compression.\n/// @notice The Nitro aggregator implementation does not use these,\n//  so these methods have been stubbed and their effects disabled.\n/// They are kept for backwards compatibility.\n/// Precompiled contract that exists in every Arbitrum chain at 0x0000000000000000000000000000000000000068.\ninterface ArbFunctionTable {\n    /// @notice Reverts since the table is empty\n    function upload(bytes calldata buf) external;\n\n    /// @notice Returns the empty table's size, which is 0\n    function size(address addr) external view returns (uint256);\n\n    /// @notice No-op\n    function get(address addr, uint256 index)\n        external\n        view\n        returns (\n            uint256,\n            bool,\n            uint256\n        );\n}\n"}, "src/precompiles/ArbGasInfo.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\n/// @title Provides insight into the cost of using the chain.\n/// @notice These methods have been adjusted to account for Nitro's heavy use of calldata compression.\n/// Of note to end-users, we no longer make a distinction between non-zero and zero-valued calldata bytes.\n/// Precompiled contract that exists in every Arbitrum chain at 0x000000000000000000000000000000000000006c.\ninterface ArbGasInfo {\n    /// @notice Get gas prices for a provided aggregator\n    /// @return return gas prices in wei\n    ///        (\n    ///            per L2 tx,\n    ///            per L1 calldata byte\n    ///            per storage allocation,\n    ///            per ArbGas base,\n    ///            per ArbGas congestion,\n    ///            per ArbGas total\n    ///        )\n    function getPricesInWeiWithAggregator(address aggregator)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    /// @notice Get gas prices. Uses the caller's preferred aggregator, or the default if the caller doesn't have a preferred one.\n    /// @return return gas prices in wei\n    ///        (\n    ///            per L2 tx,\n    ///            per L1 calldata byte\n    ///            per storage allocation,\n    ///            per ArbGas base,\n    ///            per ArbGas congestion,\n    ///            per ArbGas total\n    ///        )\n    function getPricesInWei()\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    /// @notice Get prices in ArbGas for the supplied aggregator\n    /// @return (per L2 tx, per L1 calldata byte, per storage allocation)\n    function getPricesInArbGasWithAggregator(address aggregator)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    /// @notice Get prices in ArbGas. Assumes the callers preferred validator, or the default if caller doesn't have a preferred one.\n    /// @return (per L2 tx, per L1 calldata byte, per storage allocation)\n    function getPricesInArbGas()\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    /// @notice Get the gas accounting parameters. `gasPoolMax` is always zero, as the exponential pricing model has no such notion.\n    /// @return (speedLimitPerSecond, gasPoolMax, maxTxGasLimit)\n    function getGasAccountingParams()\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    /// @notice Get the minimum gas price needed for a tx to succeed\n    function getMinimumGasPrice() external view returns (uint256);\n\n    /// @notice Get ArbOS's estimate of the L1 basefee in wei\n    function getL1BaseFeeEstimate() external view returns (uint256);\n\n    /// @notice Get how slowly ArbOS updates its estimate of the L1 basefee\n    function getL1BaseFeeEstimateInertia() external view returns (uint64);\n\n    /// @notice Get the L1 pricer reward rate, in wei per unit\n    /// Available in ArbOS version 11\n    function getL1RewardRate() external view returns (uint64);\n\n    /// @notice Get the L1 pricer reward recipient\n    /// Available in ArbOS version 11\n    function getL1RewardRecipient() external view returns (address);\n\n    /// @notice Deprecated -- Same as getL1BaseFeeEstimate()\n    function getL1GasPriceEstimate() external view returns (uint256);\n\n    /// @notice Get L1 gas fees paid by the current transaction\n    function getCurrentTxL1GasFees() external view returns (uint256);\n\n    /// @notice Get the backlogged amount of gas burnt in excess of the speed limit\n    function getGasBacklog() external view returns (uint64);\n\n    /// @notice Get how slowly ArbOS updates the L2 basefee in response to backlogged gas\n    function getPricingInertia() external view returns (uint64);\n\n    /// @notice Get the forgivable amount of backlogged gas ArbOS will ignore when raising the basefee\n    function getGasBacklogTolerance() external view returns (uint64);\n\n    /// @notice Returns the surplus of funds for L1 batch posting payments (may be negative).\n    function getL1PricingSurplus() external view returns (int256);\n\n    /// @notice Returns the base charge (in L1 gas) attributed to each data batch in the calldata pricer\n    function getPerBatchGasCharge() external view returns (int64);\n\n    /// @notice Returns the cost amortization cap in basis points\n    function getAmortizedCostCapBips() external view returns (uint64);\n\n    /// @notice Returns the available funds from L1 fees\n    function getL1FeesAvailable() external view returns (uint256);\n\n    /// @notice Returns the equilibration units parameter for L1 price adjustment algorithm\n    /// Available in ArbOS version 20\n    function getL1PricingEquilibrationUnits() external view returns (uint256);\n\n    /// @notice Returns the last time the L1 calldata pricer was updated.\n    /// Available in ArbOS version 20\n    function getLastL1PricingUpdateTime() external view returns (uint64);\n\n    /// @notice Returns the amount of L1 calldata payments due for rewards (per the L1 reward rate)\n    /// Available in ArbOS version 20\n    function getL1PricingFundsDueForRewards() external view returns (uint256);\n\n    /// @notice Returns the amount of L1 calldata posted since the last update.\n    /// Available in ArbOS version 20\n    function getL1PricingUnitsSinceUpdate() external view returns (uint64);\n\n    /// @notice Returns the L1 pricing surplus as of the last update (may be negative).\n    /// Available in ArbOS version 20\n    function getLastL1PricingSurplus() external view returns (int256);\n}\n"}, "src/precompiles/ArbInfo.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\n/// @title Lookup for basic info about accounts and contracts.\n/// @notice Precompiled contract that exists in every Arbitrum chain at 0x0000000000000000000000000000000000000065.\ninterface ArbInfo {\n    /// @notice Retrieves an account's balance\n    function getBalance(address account) external view returns (uint256);\n\n    /// @notice Retrieves a contract's deployed code\n    function getCode(address account) external view returns (bytes memory);\n}\n"}, "src/precompiles/ArbosActs.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.30;\n\n/**\n * @title This precompile represents ArbOS's internal actions as calls it makes to itself\n * @notice Calling this precompile will always revert and should not be done.\n */\ninterface ArbosActs {\n    /**\n     * @notice ArbOS \"calls\" this when starting a block\n     * @param l1BaseFee the L1 BaseFee\n     * @param l1BlockNumber the L1 block number\n     * @param timePassed number of seconds since the last block\n     */\n    function startBlock(\n        uint256 l1BaseFee,\n        uint64 l1BlockNumber,\n        uint64 l2BlockNumber,\n        uint64 timePassed\n    ) external;\n\n    function batchPostingReport(\n        uint256 batchTimestamp,\n        address batchPosterAddress,\n        uint64 batchNumber,\n        uint64 batchDataGas,\n        uint256 l1BaseFeeWei\n    ) external;\n\n    error CallerNotArbOS();\n}\n"}, "src/precompiles/ArbosTest.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\n/// @title Deprecated - Provides a method of burning arbitrary amounts of gas,\n/// @notice This exists for historical reasons. Pre-Nitro, `ArbosTest` had additional methods only the zero address could call.\n/// These have been removed since users don't use them and calls to missing methods revert.\n/// Precompiled contract that exists in every Arbitrum chain at 0x0000000000000000000000000000000000000069.\ninterface ArbosTest {\n    /// @notice Unproductively burns the amount of L2 ArbGas\n    function burnArbGas(uint256 gasAmount) external pure;\n}\n"}, "src/precompiles/ArbOwner.sol": {"content": "// Copyright 2021-2024, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\n/**\n * @title Provides owners with tools for managing the rollup.\n * @notice Calls by non-owners will always revert.\n * Most of Arbitrum Classic's owner methods have been removed since they no longer make sense in Nitro:\n * - What were once chain parameters are now parts of ArbOS's state, and those that remain are set at genesis.\n * - ArbOS upgrades happen with the rest of the system rather than being independent\n * - Exemptions to address aliasing are no longer offered. Exemptions were intended to support backward compatibility for contracts deployed before aliasing was introduced, but no exemptions were ever requested.\n * Precompiled contract that exists in every Arbitrum chain at 0x0000000000000000000000000000000000000070.\n **/\ninterface ArbOwner {\n    /// @notice Add account as a chain owner\n    function addChainOwner(address newOwner) external;\n\n    /// @notice Remove account from the list of chain owners\n    function removeChainOwner(address ownerToRemove) external;\n\n    /// @notice See if the user is a chain owner\n    function isChainOwner(address addr) external view returns (bool);\n\n    /// @notice Retrieves the list of chain owners\n    function getAllChainOwners() external view returns (address[] memory);\n\n    /// @notice Set how slowly ArbOS updates its estimate of the L1 basefee\n    function setL1BaseFeeEstimateInertia(uint64 inertia) external;\n\n    /// @notice Set the L2 basefee directly, bypassing the pool calculus\n    function setL2BaseFee(uint256 priceInWei) external;\n\n    /// @notice Set the minimum basefee needed for a transaction to succeed\n    function setMinimumL2BaseFee(uint256 priceInWei) external;\n\n    /// @notice Set the computational speed limit for the chain\n    function setSpeedLimit(uint64 limit) external;\n\n    /// @notice Set the maximum size a tx (and block) can be\n    function setMaxTxGasLimit(uint64 limit) external;\n\n    /// @notice Set the L2 gas pricing inertia\n    function setL2GasPricingInertia(uint64 sec) external;\n\n    /// @notice Set the L2 gas backlog tolerance\n    function setL2GasBacklogTolerance(uint64 sec) external;\n\n    /// @notice Get the network fee collector\n    function getNetworkFeeAccount() external view returns (address);\n\n    /// @notice Get the infrastructure fee collector\n    function getInfraFeeAccount() external view returns (address);\n\n    /// @notice Set the network fee collector\n    function setNetworkFeeAccount(address newNetworkFeeAccount) external;\n\n    /// @notice Set the infrastructure fee collector\n    function setInfraFeeAccount(address newInfraFeeAccount) external;\n\n    /// @notice Upgrades ArbOS to the requested version at the requested timestamp\n    function scheduleArbOSUpgrade(uint64 newVersion, uint64 timestamp) external;\n\n    /// @notice Sets equilibration units parameter for L1 price adjustment algorithm\n    function setL1PricingEquilibrationUnits(uint256 equilibrationUnits) external;\n\n    /// @notice Sets inertia parameter for L1 price adjustment algorithm\n    function setL1PricingInertia(uint64 inertia) external;\n\n    /// @notice Sets reward recipient address for L1 price adjustment algorithm\n    function setL1PricingRewardRecipient(address recipient) external;\n\n    /// @notice Sets reward amount for L1 price adjustment algorithm, in wei per unit\n    function setL1PricingRewardRate(uint64 weiPerUnit) external;\n\n    /// @notice Set how much ArbOS charges per L1 gas spent on transaction data.\n    function setL1PricePerUnit(uint256 pricePerUnit) external;\n\n    /// @notice Sets the base charge (in L1 gas) attributed to each data batch in the calldata pricer\n    function setPerBatchGasCharge(int64 cost) external;\n\n    /**\n     * @notice Sets the Brotli compression level used for fast compression\n     * Available in ArbOS version 12 with default level as 1\n     */\n    function setBrotliCompressionLevel(uint64 level) external;\n\n    /// @notice Sets the cost amortization cap in basis points\n    function setAmortizedCostCapBips(uint64 cap) external;\n\n    /// @notice Releases surplus funds from L1PricerFundsPoolAddress for use\n    function releaseL1PricerSurplusFunds(uint256 maxWeiToRelease) external returns (uint256);\n\n    /// @notice Sets the amount of ink 1 gas buys\n    /// @param price the conversion rate (must fit in a uint24)\n    function setInkPrice(uint32 price) external;\n\n    /// @notice Sets the maximum depth (in wasm words) a wasm stack may grow\n    function setWasmMaxStackDepth(uint32 depth) external;\n\n    /// @notice Sets the number of free wasm pages a tx gets\n    function setWasmFreePages(uint16 pages) external;\n\n    /// @notice Sets the base cost of each additional wasm page\n    function setWasmPageGas(uint16 gas) external;\n\n    /// @notice Sets the maximum number of pages a wasm may allocate\n    function setWasmPageLimit(uint16 limit) external;\n\n    /// @notice Sets the minimum costs to invoke a program\n    /// @param gas amount of gas paid in increments of 256 when not the program is not cached\n    /// @param cached amount of gas paid in increments of 64 when the program is cached\n    function setWasmMinInitGas(uint8 gas, uint16 cached) external;\n\n    /// @notice Sets the linear adjustment made to program init costs.\n    /// @param percent the adjustment (100% = no adjustment).\n    function setWasmInitCostScalar(uint64 percent) external;\n\n    /// @notice Sets the number of days after which programs deactivate\n    function setWasmExpiryDays(uint16 _days) external;\n\n    /// @notice Sets the age a program must be to perform a keepalive\n    function setWasmKeepaliveDays(uint16 _days) external;\n\n    /// @notice Sets the number of extra programs ArbOS caches during a given block\n    function setWasmBlockCacheSize(uint16 count) external;\n\n    /// @notice Adds account as a wasm cache manager\n    function addWasmCacheManager(address manager) external;\n\n    /// @notice Removes account from the list of wasm cache managers\n    function removeWasmCacheManager(address manager) external;\n\n    /// @notice Sets serialized chain config in ArbOS state\n    function setChainConfig(string calldata chainConfig) external;\n\n    /// Emitted when a successful call is made to this precompile\n    event OwnerActs(bytes4 indexed method, address indexed owner, bytes data);\n}\n"}, "src/precompiles/ArbOwnerPublic.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\n/// @title Provides non-owners with info about the current chain owners.\n/// @notice Precompiled contract that exists in every Arbitrum chain at 0x000000000000000000000000000000000000006b.\ninterface ArbOwnerPublic {\n    /// @notice See if the user is a chain owner\n    function isChainOwner(address addr) external view returns (bool);\n\n    /**\n     * @notice Rectify the list of chain owners\n     * If successful, emits ChainOwnerRectified event\n     * Available in ArbOS version 11\n     */\n    function rectifyChainOwner(address ownerToRectify) external;\n\n    /// @notice Retrieves the list of chain owners\n    function getAllChainOwners() external view returns (address[] memory);\n\n    /// @notice Gets the network fee collector\n    function getNetworkFeeAccount() external view returns (address);\n\n    /// @notice Get the infrastructure fee collector\n    function getInfraFeeAccount() external view returns (address);\n\n    /// @notice Get the Brotli compression level used for fast compression\n    function getBrotliCompressionLevel() external view returns (uint64);\n\n    /// @notice Get the next scheduled ArbOS version upgrade and its activation timestamp.\n    /// Returns (0, 0) if no ArbOS upgrade is scheduled.\n    /// Available in ArbOS version 20.\n    function getScheduledUpgrade()\n        external\n        view\n        returns (uint64 arbosVersion, uint64 scheduledForTimestamp);\n\n    event ChainOwnerRectified(address rectifiedOwner);\n}\n"}, "src/precompiles/ArbRetryableTx.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\n/**\n * @title Methods for managing retryables.\n * @notice Precompiled contract in every Arbitrum chain for retryable transaction related data retrieval and interactions. Exists at 0x000000000000000000000000000000000000006e\n */\ninterface ArbRetryableTx {\n    /**\n     * @notice Schedule an attempt to redeem a redeemable tx, donating all of the call's gas to the redeem.\n     * Revert if ticketId does not exist.\n     * @param ticketId unique identifier of retryable message: keccak256(keccak256(ArbchainId, inbox-sequence-number), uint(0) )\n     * @return txId that the redeem attempt will have\n     */\n    function redeem(bytes32 ticketId) external returns (bytes32);\n\n    /**\n     * @notice Return the minimum lifetime of redeemable txn.\n     * @return lifetime in seconds\n     */\n    function getLifetime() external view returns (uint256);\n\n    /**\n     * @notice Return the timestamp when ticketId will age out, reverting if it does not exist\n     * @param ticketId unique ticket identifier\n     * @return timestamp for ticket's deadline\n     */\n    function getTimeout(bytes32 ticketId) external view returns (uint256);\n\n    /**\n     * @notice Adds one lifetime period to the life of ticketId.\n     * Donate gas to pay for the lifetime extension.\n     * If successful, emits LifetimeExtended event.\n     * Revert if ticketId does not exist, or if the timeout of ticketId is already at least one lifetime period in the future.\n     * @param ticketId unique ticket identifier\n     * @return new timeout of ticketId\n     */\n    function keepalive(bytes32 ticketId) external returns (uint256);\n\n    /**\n     * @notice Return the beneficiary of ticketId.\n     * Revert if ticketId doesn't exist.\n     * @param ticketId unique ticket identifier\n     * @return address of beneficiary for ticket\n     */\n    function getBeneficiary(bytes32 ticketId) external view returns (address);\n\n    /**\n     * @notice Cancel ticketId and refund its callvalue to its beneficiary.\n     * Revert if ticketId doesn't exist, or if called by anyone other than ticketId's beneficiary.\n     * @param ticketId unique ticket identifier\n     */\n    function cancel(bytes32 ticketId) external;\n\n    /**\n     * @notice Gets the redeemer of the current retryable redeem attempt.\n     * Returns the zero address if the current transaction is not a retryable redeem attempt.\n     * If this is an auto-redeem, returns the fee refund address of the retryable.\n     */\n    function getCurrentRedeemer() external view returns (address);\n\n    /**\n     * @notice Do not call. This method represents a retryable submission to aid explorers.\n     * Calling it will always revert.\n     */\n    function submitRetryable(\n        bytes32 requestId,\n        uint256 l1BaseFee,\n        uint256 deposit,\n        uint256 callvalue,\n        uint256 gasFeeCap,\n        uint64 gasLimit,\n        uint256 maxSubmissionFee,\n        address feeRefundAddress,\n        address beneficiary,\n        address retryTo,\n        bytes calldata retryData\n    ) external;\n\n    event TicketCreated(bytes32 indexed ticketId);\n    event LifetimeExtended(bytes32 indexed ticketId, uint256 newTimeout);\n    event RedeemScheduled(\n        bytes32 indexed ticketId,\n        bytes32 indexed retryTxHash,\n        uint64 indexed sequenceNum,\n        uint64 donatedGas,\n        address gasDonor,\n        uint256 maxRefund,\n        uint256 submissionFeeRefund\n    );\n    event Canceled(bytes32 indexed ticketId);\n\n    /// @dev DEPRECATED in favour of new RedeemScheduled event after the nitro upgrade\n    event Redeemed(bytes32 indexed userTxHash);\n\n    error NoTicketWithID();\n    error NotCallable();\n}\n"}, "src/precompiles/ArbStatistics.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\n/// @title Deprecated - Info about the rollup just prior to the Nitro upgrade\n/// @notice Precompiled contract in every Arbitrum chain for retryable transaction related data retrieval and interactions. Exists at 0x000000000000000000000000000000000000006f\ninterface ArbStatistics {\n    /// @notice Get Arbitrum block number and other statistics as they were right before the Nitro upgrade.\n    /// @return (\n    ///      Number of accounts,\n    ///      Total storage allocated (includes storage that was later deallocated),\n    ///      Total ArbGas used,\n    ///      Number of transaction receipt issued,\n    ///      Number of contracts created,\n    ///    )\n    function getStats()\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n}\n"}, "src/precompiles/ArbSys.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\n/**\n * @title System level functionality\n * @notice For use by contracts to interact with core L2-specific functionality.\n * Precompiled contract that exists in every Arbitrum chain at address(100), 0x0000000000000000000000000000000000000064.\n */\ninterface ArbSys {\n    /**\n     * @notice Get Arbitrum block number (distinct from L1 block number; Arbitrum genesis block has block number 0)\n     * @return block number as int\n     */\n    function arbBlockNumber() external view returns (uint256);\n\n    /**\n     * @notice Get Arbitrum block hash (reverts unless currentBlockNum-256 <= arbBlockNum < currentBlockNum)\n     * @return block hash\n     */\n    function arbBlockHash(uint256 arbBlockNum) external view returns (bytes32);\n\n    /**\n     * @notice Gets the rollup's unique chain identifier\n     * @return Chain identifier as int\n     */\n    function arbChainID() external view returns (uint256);\n\n    /**\n     * @notice Get internal version number identifying an ArbOS build\n     * @return version number as int\n     */\n    function arbOSVersion() external view returns (uint256);\n\n    /**\n     * @notice Returns 0 since Nitro has no concept of storage gas\n     * @return uint 0\n     */\n    function getStorageGasAvailable() external view returns (uint256);\n\n    /**\n     * @notice (deprecated) check if current call is top level (meaning it was triggered by an EoA or a L1 contract)\n     * @dev this call has been deprecated and may be removed in a future release\n     * @return true if current execution frame is not a call by another L2 contract\n     */\n    function isTopLevelCall() external view returns (bool);\n\n    /**\n     * @notice map L1 sender contract address to its L2 alias\n     * @param sender sender address\n     * @param unused argument no longer used\n     * @return aliased sender address\n     */\n    function mapL1SenderContractAddressToL2Alias(address sender, address unused)\n        external\n        pure\n        returns (address);\n\n    /**\n     * @notice check if the caller (of this caller of this) is an aliased L1 contract address\n     * @return true iff the caller's address is an alias for an L1 contract address\n     */\n    function wasMyCallersAddressAliased() external view returns (bool);\n\n    /**\n     * @notice return the address of the caller (of this caller of this), without applying L1 contract address aliasing\n     * @return address of the caller's caller, without applying L1 contract address aliasing\n     */\n    function myCallersAddressWithoutAliasing() external view returns (address);\n\n    /**\n     * @notice Send given amount of Eth to dest from sender.\n     * This is a convenience function, which is equivalent to calling sendTxToL1 with empty data.\n     * @param destination recipient address on L1\n     * @return unique identifier for this L2-to-L1 transaction.\n     */\n    function withdrawEth(address destination) external payable returns (uint256);\n\n    /**\n     * @notice Send a transaction to L1\n     * @dev it is not possible to execute on the L1 any L2-to-L1 transaction which contains data\n     * to a contract address without any code (as enforced by the Bridge contract).\n     * @param destination recipient address on L1\n     * @param data (optional) calldata for L1 contract call\n     * @return a unique identifier for this L2-to-L1 transaction.\n     */\n    function sendTxToL1(address destination, bytes calldata data)\n        external\n        payable\n        returns (uint256);\n\n    /**\n     * @notice Get send Merkle tree state\n     * @return size number of sends in the history\n     * @return root root hash of the send history\n     * @return partials hashes of partial subtrees in the send history tree\n     */\n    function sendMerkleTreeState()\n        external\n        view\n        returns (\n            uint256 size,\n            bytes32 root,\n            bytes32[] memory partials\n        );\n\n    /**\n     * @notice creates a send txn from L2 to L1\n     * @param position = (level << 192) + leaf = (0 << 192) + leaf = leaf\n     */\n    event L2ToL1Tx(\n        address caller,\n        address indexed destination,\n        uint256 indexed hash,\n        uint256 indexed position,\n        uint256 arbBlockNum,\n        uint256 ethBlockNum,\n        uint256 timestamp,\n        uint256 callvalue,\n        bytes data\n    );\n\n    /// @dev DEPRECATED in favour of the new L2ToL1Tx event above after the nitro upgrade\n    event L2ToL1Transaction(\n        address caller,\n        address indexed destination,\n        uint256 indexed uniqueId,\n        uint256 indexed batchNumber,\n        uint256 indexInBatch,\n        uint256 arbBlockNum,\n        uint256 ethBlockNum,\n        uint256 timestamp,\n        uint256 callvalue,\n        bytes data\n    );\n\n    /**\n     * @notice logs a merkle branch for proof synthesis\n     * @param reserved an index meant only to align the 4th index with L2ToL1Transaction's 4th event\n     * @param hash the merkle hash\n     * @param position = (level << 192) + leaf\n     */\n    event SendMerkleUpdate(\n        uint256 indexed reserved,\n        bytes32 indexed hash,\n        uint256 indexed position\n    );\n\n    error InvalidBlockNumber(uint256 requested, uint256 current);\n}\n"}, "src/precompiles/ArbWasm.sol": {"content": "// Copyright 2022-2024, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\n/**\n * @title Methods for managing user programs\n * @notice Precompiled contract that exists in every Arbitrum chain at 0x0000000000000000000000000000000000000071.\n */\ninterface ArbWasm {\n    /// @notice Activate a wasm program\n    /// @param program the program to activate\n    /// @return version the stylus version the program was activated against\n    /// @return dataFee the data fee paid to store the activated program\n    function activateProgram(address program)\n        external\n        payable\n        returns (uint16 version, uint256 dataFee);\n\n    /// @notice Gets the latest stylus version\n    /// @return version the stylus version\n    function stylusVersion() external view returns (uint16 version);\n\n    /// @notice Gets the stylus version the program with codehash was most recently activated against\n    /// @return version the program version (reverts for EVM contracts)\n    function codehashVersion(bytes32 codehash) external view returns (uint16 version);\n\n    /// @notice Extends a program's expiration date.\n    /// Reverts if too soon or if the program is not up to date.\n    function codehashKeepalive(bytes32 codehash) external payable;\n\n    /// @notice Gets a program's asm size.\n    /// Reverts if program is not active.\n    /// @return size the size in bytes\n    function codehashAsmSize(bytes32 codehash) external view returns (uint32 size);\n\n    /// @notice Gets the stylus version the program was most recently activated against\n    /// @return version the program version (reverts for EVM contracts)\n    function programVersion(address program) external view returns (uint16 version);\n\n    /// @notice Gets the cost to invoke the program\n    /// @return gas the amount of gas\n    /// @return gasWhenCached the amount of gas if the program was recently used\n    function programInitGas(address program)\n        external\n        view\n        returns (uint64 gas, uint64 gasWhenCached);\n\n    /// @notice Gets the memory footprint of the program at the given address in pages\n    /// @return footprint the memory footprint of program in pages (reverts for EVM contracts)\n    function programMemoryFootprint(address program) external view returns (uint16 footprint);\n\n    /// @notice Gets the amount of time remaining until the program expires\n    /// @return _secs the time left in seconds (reverts for EVM contracts)\n    function programTimeLeft(address program) external view returns (uint64 _secs);\n\n    /// @notice Gets the conversion rate between gas and ink\n    /// @return price the amount of ink 1 gas buys\n    function inkPrice() external view returns (uint32 price);\n\n    /// @notice Gets the wasm stack size limit\n    /// @return depth the maximum depth (in wasm words) a wasm stack may grow\n    function maxStackDepth() external view returns (uint32 depth);\n\n    /// @notice Gets the number of free wasm pages a program gets\n    /// @return pages the number of wasm pages (2^16 bytes)\n    function freePages() external view returns (uint16 pages);\n\n    /// @notice Gets the base cost of each additional wasm page (2^16 bytes)\n    /// @return gas base amount of gas needed to grow another wasm page\n    function pageGas() external view returns (uint16 gas);\n\n    /// @notice Gets the ramp that drives exponential memory costs\n    /// @return ramp bits representing the floating point value\n    function pageRamp() external view returns (uint64 ramp);\n\n    /// @notice Gets the maximum number of pages a wasm may allocate\n    /// @return limit the number of pages\n    function pageLimit() external view returns (uint16 limit);\n\n    /// @notice Gets the minimum costs to invoke a program\n    /// @return gas amount of gas in increments of 256 when not cached\n    /// @return cached amount of gas in increments of 64 when cached\n    function minInitGas() external view returns (uint8 gas, uint8 cached);\n\n    /// @notice Gets the linear adjustment made to program init costs.\n    /// @return percent the adjustment (100% = no adjustment).\n    function initCostScalar() external view returns (uint64 percent);\n\n    /// @notice Gets the number of days after which programs deactivate\n    /// @return _days the number of days\n    function expiryDays() external view returns (uint16 _days);\n\n    /// @notice Gets the age a program must be to perform a keepalive\n    /// @return _days the number of days\n    function keepaliveDays() external view returns (uint16 _days);\n\n    /// @notice Gets the number of extra programs ArbOS caches during a given block.\n    /// @return count the number of same-block programs.\n    function blockCacheSize() external view returns (uint16 count);\n\n    event ProgramActivated(\n        bytes32 indexed codehash,\n        bytes32 moduleHash,\n        address program,\n        uint256 dataFee,\n        uint16 version\n    );\n    event ProgramLifetimeExtended(bytes32 indexed codehash, uint256 dataFee);\n\n    error ProgramNotWasm();\n    error ProgramNotActivated();\n    error ProgramNeedsUpgrade(uint16 version, uint16 stylusVersion);\n    error ProgramExpired(uint64 ageInSeconds);\n    error ProgramUpToDate();\n    error ProgramKeepaliveTooSoon(uint64 ageInSeconds);\n    error ProgramInsufficientValue(uint256 have, uint256 want);\n}\n"}, "src/precompiles/ArbWasmCache.sol": {"content": "// Copyright 2022-2024, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\n/**\n * @title Methods for managing Stylus caches\n * @notice Precompiled contract that exists in every Arbitrum chain at 0x0000000000000000000000000000000000000072.\n */\ninterface ArbWasmCache {\n    /// @notice See if the user is a cache manager.\n    function isCacheManager(address manager) external view returns (bool);\n\n    /// @notice Retrieve all address managers.\n    /// @return managers the list of managers.\n    function allCacheManagers() external view returns (address[] memory managers);\n\n    /// @dev Deprecated, replaced with cacheProgram\n    function cacheCodehash(bytes32 codehash) external;\n\n    /// @notice Caches all programs with a codehash equal to the given address.\n    /// @notice Reverts if the programs have expired.\n    /// @notice Caller must be a cache manager or chain owner.\n    /// @notice If you're looking for how to bid for position, interact with the chain's cache manager contract.\n    function cacheProgram(address addr) external;\n\n    /// @notice Evicts all programs with the given codehash.\n    /// @notice Caller must be a cache manager or chain owner.\n    function evictCodehash(bytes32 codehash) external;\n\n    /// @notice Gets whether a program is cached. Note that the program may be expired.\n    function codehashIsCached(bytes32 codehash) external view returns (bool);\n\n    event UpdateProgramCache(address indexed manager, bytes32 indexed codehash, bool cached);\n}\n"}, "src/rollup/AbsRollupEventInbox.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./IRollupEventInbox.sol\";\nimport \"../bridge/IBridge.sol\";\nimport \"../bridge/IEthBridge.sol\";\nimport \"../precompiles/ArbGasInfo.sol\";\nimport \"../libraries/ArbitrumChecker.sol\";\nimport \"../bridge/IDelayedMessageProvider.sol\";\nimport \"../libraries/DelegateCallAware.sol\";\nimport {INITIALIZATION_MSG_TYPE} from \"../libraries/MessageTypes.sol\";\nimport {AlreadyInit, HadZeroInit, RollupNotChanged} from \"../libraries/Error.sol\";\n\n/**\n * @title The inbox for rollup protocol events\n */\nabstract contract AbsRollupEventInbox is\n    IRollupEventInbox,\n    IDelayedMessageProvider,\n    DelegateCallAware\n{\n    IBridge public override bridge;\n    address public override rollup;\n\n    modifier onlyRollup() {\n        require(msg.sender == rollup, \"ONLY_ROLLUP\");\n        _;\n    }\n\n    function initialize(IBridge _bridge) external override onlyDelegated {\n        if (address(bridge) != address(0)) revert AlreadyInit();\n        if (address(_bridge) == address(0)) revert HadZeroInit();\n        bridge = _bridge;\n        rollup = address(_bridge.rollup());\n    }\n\n    /// @notice Allows the rollup owner to sync the rollup address\n    function updateRollupAddress() external {\n        if (msg.sender != IOwnable(rollup).owner())\n            revert NotOwner(msg.sender, IOwnable(rollup).owner());\n        address newRollup = address(bridge.rollup());\n        if (rollup == newRollup) revert RollupNotChanged();\n        rollup = newRollup;\n    }\n\n    function rollupInitialized(uint256 chainId, string calldata chainConfig)\n        external\n        override\n        onlyRollup\n    {\n        require(bytes(chainConfig).length > 0, \"EMPTY_CHAIN_CONFIG\");\n        uint8 initMsgVersion = 1;\n        uint256 currentDataCost = _currentDataCostToReport();\n        bytes memory initMsg = abi.encodePacked(\n            chainId,\n            initMsgVersion,\n            currentDataCost,\n            chainConfig\n        );\n        uint256 num = _enqueueInitializationMsg(initMsg);\n        emit InboxMessageDelivered(num, initMsg);\n    }\n\n    function _enqueueInitializationMsg(bytes memory initMsg) internal virtual returns (uint256);\n\n    function _currentDataCostToReport() internal virtual returns (uint256);\n}\n"}, "src/rollup/BridgeCreator.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../bridge/Bridge.sol\";\nimport \"../bridge/SequencerInbox.sol\";\nimport \"../bridge/Inbox.sol\";\nimport \"../bridge/Outbox.sol\";\nimport \"./RollupEventInbox.sol\";\nimport \"../bridge/ERC20Bridge.sol\";\nimport \"../bridge/ERC20Inbox.sol\";\nimport \"../rollup/ERC20RollupEventInbox.sol\";\nimport \"../bridge/ERC20Outbox.sol\";\n\nimport \"../bridge/IBridge.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\n\ncontract BridgeCreator is Ownable {\n    BridgeContracts public ethBasedTemplates;\n    BridgeContracts public erc20BasedTemplates;\n\n    event TemplatesUpdated();\n    event ERC20TemplatesUpdated();\n\n    struct BridgeContracts {\n        IBridge bridge;\n        ISequencerInbox sequencerInbox;\n        IInboxBase inbox;\n        IRollupEventInbox rollupEventInbox;\n        IOutbox outbox;\n    }\n\n    constructor(\n        BridgeContracts memory _ethBasedTemplates,\n        BridgeContracts memory _erc20BasedTemplates\n    ) Ownable() {\n        ethBasedTemplates = _ethBasedTemplates;\n        erc20BasedTemplates = _erc20BasedTemplates;\n    }\n\n    function updateTemplates(BridgeContracts calldata _newTemplates) external onlyOwner {\n        ethBasedTemplates = _newTemplates;\n        emit TemplatesUpdated();\n    }\n\n    function updateERC20Templates(BridgeContracts calldata _newTemplates) external onlyOwner {\n        erc20BasedTemplates = _newTemplates;\n        emit ERC20TemplatesUpdated();\n    }\n\n    function _createBridge(address adminProxy, BridgeContracts storage templates)\n        internal\n        returns (BridgeContracts memory)\n    {\n        BridgeContracts memory frame;\n        frame.bridge = IBridge(\n            address(new TransparentUpgradeableProxy(address(templates.bridge), adminProxy, \"\"))\n        );\n        frame.sequencerInbox = ISequencerInbox(\n            address(\n                new TransparentUpgradeableProxy(address(templates.sequencerInbox), adminProxy, \"\")\n            )\n        );\n        frame.inbox = IInboxBase(\n            address(new TransparentUpgradeableProxy(address(templates.inbox), adminProxy, \"\"))\n        );\n        frame.rollupEventInbox = IRollupEventInbox(\n            address(\n                new TransparentUpgradeableProxy(address(templates.rollupEventInbox), adminProxy, \"\")\n            )\n        );\n        frame.outbox = IOutbox(\n            address(new TransparentUpgradeableProxy(address(templates.outbox), adminProxy, \"\"))\n        );\n        return frame;\n    }\n\n    function createBridge(\n        address adminProxy,\n        address rollup,\n        address nativeToken,\n        ISequencerInbox.MaxTimeVariation calldata maxTimeVariation\n    ) external returns (BridgeContracts memory) {\n        // create ETH-based bridge if address zero is provided for native token, otherwise create ERC20-based bridge\n        BridgeContracts memory frame = _createBridge(\n            adminProxy,\n            nativeToken == address(0) ? ethBasedTemplates : erc20BasedTemplates\n        );\n\n        // init contracts\n        if (nativeToken == address(0)) {\n            IEthBridge(address(frame.bridge)).initialize(IOwnable(rollup));\n        } else {\n            IERC20Bridge(address(frame.bridge)).initialize(IOwnable(rollup), nativeToken);\n        }\n        frame.sequencerInbox.initialize(IBridge(frame.bridge), maxTimeVariation);\n        frame.inbox.initialize(frame.bridge, frame.sequencerInbox);\n        frame.rollupEventInbox.initialize(frame.bridge);\n        frame.outbox.initialize(frame.bridge);\n\n        return frame;\n    }\n}\n"}, "src/rollup/Config.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../state/GlobalState.sol\";\nimport \"../state/Machine.sol\";\nimport \"../bridge/ISequencerInbox.sol\";\nimport \"../bridge/IBridge.sol\";\nimport \"../bridge/IOutbox.sol\";\nimport \"../bridge/IInboxBase.sol\";\nimport \"./IRollupEventInbox.sol\";\nimport \"./IRollupLogic.sol\";\nimport \"../challenge/IChallengeManager.sol\";\n\nstruct Config {\n    uint64 confirmPeriodBlocks;\n    uint64 extraChallengeTimeBlocks;\n    address stakeToken;\n    uint256 baseStake;\n    bytes32 wasmModuleRoot;\n    address owner;\n    address loserStakeEscrow;\n    uint256 chainId;\n    string chainConfig;\n    uint64 genesisBlockNum;\n    ISequencerInbox.MaxTimeVariation sequencerInboxMaxTimeVariation;\n}\n\nstruct ContractDependencies {\n    IBridge bridge;\n    ISequencerInbox sequencerInbox;\n    IInboxBase inbox;\n    IOutbox outbox;\n    IRollupEventInbox rollupEventInbox;\n    IChallengeManager challengeManager;\n    address rollupAdminLogic;\n    IRollupUser rollupUserLogic;\n    // misc contracts that are useful when interacting with the rollup\n    address validatorUtils;\n    address validatorWalletCreator;\n}\n"}, "src/rollup/DeployHelper.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport {IInbox} from \"../bridge/IInbox.sol\";\nimport {IInboxBase} from \"../bridge/IInboxBase.sol\";\nimport {IERC20Inbox} from \"../bridge/ERC20Inbox.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/// @notice Helper contract for deploying some keyless deployment to Arbitrum using delayed inbox\ncontract DeployHelper {\n    // All payload are padded with 0x04 (ArbOS L2MessageKind_SignedTx Type)\n\n    // Nick's CREATE2 Deterministic Deployment Proxy\n    // https://github.com/Arachnid/deterministic-deployment-proxy\n    address public constant NICK_CREATE2_DEPLOYER = 0x3fAB184622Dc19b6109349B94811493BF2a45362;\n    uint256 public constant NICK_CREATE2_VALUE = 0.01 ether;\n    bytes public constant NICK_CREATE2_PAYLOAD =\n        hex\"04f8a58085174876e800830186a08080b853604580600e600039806000f350fe7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf31ba02222222222222222222222222222222222222222222222222222222222222222a02222222222222222222222222222222222222222222222222222222222222222\";\n\n    // ERC-2470 Singleton Factory\n    // https://eips.ethereum.org/EIPS/eip-2470\n    address public constant ERC2470_DEPLOYER = 0xBb6e024b9cFFACB947A71991E386681B1Cd1477D;\n    uint256 public constant ERC2470_VALUE = 0.0247 ether;\n    bytes public constant ERC2470_PAYLOAD =\n        hex\"04f9016c8085174876e8008303c4d88080b90154608060405234801561001057600080fd5b50610134806100206000396000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c80634af63f0214602d575b600080fd5b60cf60048036036040811015604157600080fd5b810190602081018135640100000000811115605b57600080fd5b820183602082011115606c57600080fd5b80359060200191846001830284011164010000000083111715608d57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550509135925060eb915050565b604080516001600160a01b039092168252519081900360200190f35b6000818351602085016000f5939250505056fea26469706673582212206b44f8a82cb6b156bfcc3dc6aadd6df4eefd204bc928a4397fd15dacf6d5320564736f6c634300060200331b83247000822470\";\n\n    // Zoltu's CREATE2 Deterministic Deployment Proxy\n    // https://github.com/Zoltu/deterministic-deployment-proxy\n    address public constant ZOLTU_CREATE2_DEPLOYER = 0x4c8D290a1B368ac4728d83a9e8321fC3af2b39b1;\n    uint256 public constant ZOLTU_VALUE = 0.01 ether;\n    bytes public constant ZOLTU_CREATE2_PAYLOAD =\n        hex\"04f87e8085174876e800830186a08080ad601f80600e600039806000f350fe60003681823780368234f58015156014578182fd5b80825250506014600cf31ba02222222222222222222222222222222222222222222222222222222222222222a02222222222222222222222222222222222222222222222222222222222222222\";\n\n    // ERC-1820: Pseudo-introspection Registry Contract\n    // https://eips.ethereum.org/EIPS/eip-1820\n    address public constant ERC1820_DEPLOYER = 0xa990077c3205cbDf861e17Fa532eeB069cE9fF96;\n    uint256 public constant ERC1820_VALUE = 0.08 ether;\n    bytes public constant ERC1820_PAYLOAD =\n        hex\"04f90a388085174876e800830c35008080b909e5608060405234801561001057600080fd5b506109c5806100206000396000f3fe608060405234801561001057600080fd5b50600436106100a5576000357c010000000000000000000000000000000000000000000000000000000090048063a41e7d5111610078578063a41e7d51146101d4578063aabbb8ca1461020a578063b705676514610236578063f712f3e814610280576100a5565b806329965a1d146100aa5780633d584063146100e25780635df8122f1461012457806365ba36c114610152575b600080fd5b6100e0600480360360608110156100c057600080fd5b50600160a060020a038135811691602081013591604090910135166102b6565b005b610108600480360360208110156100f857600080fd5b5035600160a060020a0316610570565b60408051600160a060020a039092168252519081900360200190f35b6100e06004803603604081101561013a57600080fd5b50600160a060020a03813581169160200135166105bc565b6101c26004803603602081101561016857600080fd5b81019060208101813564010000000081111561018357600080fd5b82018360208201111561019557600080fd5b803590602001918460018302840111640100000000831117156101b757600080fd5b5090925090506106b3565b60408051918252519081900360200190f35b6100e0600480360360408110156101ea57600080fd5b508035600160a060020a03169060200135600160e060020a0319166106ee565b6101086004803603604081101561022057600080fd5b50600160a060020a038135169060200135610778565b61026c6004803603604081101561024c57600080fd5b508035600160a060020a03169060200135600160e060020a0319166107ef565b604080519115158252519081900360200190f35b61026c6004803603604081101561029657600080fd5b508035600160a060020a03169060200135600160e060020a0319166108aa565b6000600160a060020a038416156102cd57836102cf565b335b9050336102db82610570565b600160a060020a031614610339576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b6103428361092a565b15610397576040805160e560020a62461bcd02815260206004820152601a60248201527f4d757374206e6f7420626520616e204552433136352068617368000000000000604482015290519081900360640190fd5b600160a060020a038216158015906103b85750600160a060020a0382163314155b156104ff5760405160200180807f455243313832305f4143434550545f4d4147494300000000000000000000000081525060140190506040516020818303038152906040528051906020012082600160a060020a031663249cb3fa85846040518363ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018083815260200182600160a060020a0316600160a060020a031681526020019250505060206040518083038186803b15801561047e57600080fd5b505afa158015610492573d6000803e3d6000fd5b505050506040513d60208110156104a857600080fd5b5051146104ff576040805160e560020a62461bcd02815260206004820181905260248201527f446f6573206e6f7420696d706c656d656e742074686520696e74657266616365604482015290519081900360640190fd5b600160a060020a03818116600081815260208181526040808320888452909152808220805473ffffffffffffffffffffffffffffffffffffffff19169487169485179055518692917f93baa6efbd2244243bfee6ce4cfdd1d04fc4c0e9a786abd3a41313bd352db15391a450505050565b600160a060020a03818116600090815260016020526040812054909116151561059a5750806105b7565b50600160a060020a03808216600090815260016020526040902054165b919050565b336105c683610570565b600160a060020a031614610624576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b81600160a060020a031681600160a060020a0316146106435780610646565b60005b600160a060020a03838116600081815260016020526040808220805473ffffffffffffffffffffffffffffffffffffffff19169585169590951790945592519184169290917f605c2dbf762e5f7d60a546d42e7205dcb1b011ebc62a61736a57c9089d3a43509190a35050565b600082826040516020018083838082843780830192505050925050506040516020818303038152906040528051906020012090505b92915050565b6106f882826107ef565b610703576000610705565b815b600160a060020a03928316600081815260208181526040808320600160e060020a031996909616808452958252808320805473ffffffffffffffffffffffffffffffffffffffff19169590971694909417909555908152600284528181209281529190925220805460ff19166001179055565b600080600160a060020a038416156107905783610792565b335b905061079d8361092a565b156107c357826107ad82826108aa565b6107b85760006107ba565b815b925050506106e8565b600160a060020a0390811660009081526020818152604080832086845290915290205416905092915050565b6000808061081d857f01ffc9a70000000000000000000000000000000000000000000000000000000061094c565b909250905081158061082d575080155b1561083d576000925050506106e8565b61084f85600160e060020a031961094c565b909250905081158061086057508015155b15610870576000925050506106e8565b61087a858561094c565b909250905060018214801561088f5750806001145b1561089f576001925050506106e8565b506000949350505050565b600160a060020a0382166000908152600260209081526040808320600160e060020a03198516845290915281205460ff1615156108f2576108eb83836107ef565b90506106e8565b50600160a060020a03808316600081815260208181526040808320600160e060020a0319871684529091529020549091161492915050565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff161590565b6040517f01ffc9a7000000000000000000000000000000000000000000000000000000008082526004820183905260009182919060208160248189617530fa90519096909550935050505056fea165627a7a72305820377f4a2d4301ede9949f163f319021a6e9c687c292a5e2b2c4734c126b524e6c00291ba01820182018201820182018201820182018201820182018201820182018201820a01820182018201820182018201820182018201820182018201820182018201820\";\n\n    uint256 internal constant GASLIMIT = 21_000;\n\n    function _fundAndDeploy(\n        address inbox,\n        uint256 _value,\n        address _l2Address,\n        bytes memory payload,\n        address _nativeToken,\n        uint256 maxFeePerGas\n    ) internal {\n        uint256 submissionCost = IInboxBase(inbox).calculateRetryableSubmissionFee(\n            0,\n            block.basefee\n        );\n        uint256 feeAmount = _value + submissionCost + GASLIMIT * maxFeePerGas;\n\n        // fund the target L2 address\n        if (_nativeToken != address(0)) {\n            // calculate the fee amount in the native token's decimals\n            uint256 feeAmountNativeDenominated = feeAmount;\n            uint8 decimals = ERC20(_nativeToken).decimals();\n            if (decimals < 18) {\n                feeAmountNativeDenominated = feeAmount / (10**(18 - decimals));\n                // round up if necessary\n                if (feeAmountNativeDenominated * (10**(18 - decimals)) < feeAmount) {\n                    feeAmountNativeDenominated++;\n                }\n            } else if (decimals > 18) {\n                feeAmountNativeDenominated = feeAmount * (10**(decimals - 18));\n            }\n\n            IERC20Inbox(inbox).createRetryableTicket({\n                to: _l2Address,\n                l2CallValue: _value,\n                maxSubmissionCost: submissionCost,\n                excessFeeRefundAddress: msg.sender,\n                callValueRefundAddress: msg.sender,\n                gasLimit: GASLIMIT,\n                maxFeePerGas: maxFeePerGas,\n                tokenTotalFeeAmount: feeAmountNativeDenominated,\n                data: \"\"\n            });\n        } else {\n            IInbox(inbox).createRetryableTicket{value: feeAmount}({\n                to: _l2Address,\n                l2CallValue: _value,\n                maxSubmissionCost: submissionCost,\n                excessFeeRefundAddress: msg.sender,\n                callValueRefundAddress: msg.sender,\n                gasLimit: GASLIMIT,\n                maxFeePerGas: maxFeePerGas,\n                data: \"\"\n            });\n        }\n        // send L2 msg to execute deployment transaction\n        IInboxBase(inbox).sendL2Message(payload);\n    }\n\n    function perform(\n        address _inbox,\n        address _nativeToken,\n        uint256 _maxFeePerGas\n    ) external payable {\n        _fundAndDeploy(\n            _inbox,\n            NICK_CREATE2_VALUE,\n            NICK_CREATE2_DEPLOYER,\n            NICK_CREATE2_PAYLOAD,\n            _nativeToken,\n            _maxFeePerGas\n        );\n        _fundAndDeploy(\n            _inbox,\n            ERC2470_VALUE,\n            ERC2470_DEPLOYER,\n            ERC2470_PAYLOAD,\n            _nativeToken,\n            _maxFeePerGas\n        );\n        _fundAndDeploy(\n            _inbox,\n            ZOLTU_VALUE,\n            ZOLTU_CREATE2_DEPLOYER,\n            ZOLTU_CREATE2_PAYLOAD,\n            _nativeToken,\n            _maxFeePerGas\n        );\n        _fundAndDeploy(\n            _inbox,\n            ERC1820_VALUE,\n            ERC1820_DEPLOYER,\n            ERC1820_PAYLOAD,\n            _nativeToken,\n            _maxFeePerGas\n        );\n\n        // if paying with ETH refund the caller\n        if (_nativeToken == address(0)) {\n            payable(msg.sender).transfer(address(this).balance);\n        }\n    }\n\n    function getDeploymentTotalCost(IInboxBase inbox, uint256 maxFeePerGas)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 submissionCost = inbox.calculateRetryableSubmissionFee(0, block.basefee);\n        return\n            NICK_CREATE2_VALUE +\n            ERC2470_VALUE +\n            ZOLTU_VALUE +\n            ERC1820_VALUE +\n            4 *\n            (submissionCost + GASLIMIT * maxFeePerGas);\n    }\n}\n"}, "src/rollup/ERC20RollupEventInbox.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./AbsRollupEventInbox.sol\";\nimport \"../bridge/IERC20Bridge.sol\";\n\n/**\n * @title The inbox for rollup protocol events\n */\ncontract ERC20RollupEventInbox is AbsRollupEventInbox {\n    constructor() AbsRollupEventInbox() {}\n\n    function _enqueueInitializationMsg(bytes memory initMsg) internal override returns (uint256) {\n        uint256 tokenAmount = 0;\n        return\n            IERC20Bridge(address(bridge)).enqueueDelayedMessage(\n                INITIALIZATION_MSG_TYPE,\n                address(0),\n                keccak256(initMsg),\n                tokenAmount\n            );\n    }\n\n    function _currentDataCostToReport() internal pure override returns (uint256) {\n        // at the moment chains using fee token in Anytrust mode do not charge for the data posting fees\n        return 0;\n    }\n}\n"}, "src/rollup/FactoryDeployerHelper.sol": {"content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.30;\n\n/**\n * @title Helper contract for cross-chain deployment of deterministic factories when rollup uses custom fee token\n * @notice It bundles sending the fee token to inbox and invoking the factory deployment function.\n *         Prerequisite: fee token must be approved for this contract to send it to inbox.\n */\ncontract FactoryDeployerHelper {\n    address public constant DEPLOY_HELPER = address(0x90D68B056c411015eaE3EC0b98AD94E2C91419F1);\n    uint256 public constant MAX_FEE_PER_GAS = 100_000_000;\n\n    function deploy(address inbox) external {\n        deploy(inbox, MAX_FEE_PER_GAS);\n    }\n\n    function deploy(address inbox, uint256 maxFeePerGas) public {\n        address bridge = address(IInboxBase(inbox).bridge());\n        address feeToken = IERC20Bridge(bridge).nativeToken();\n\n        uint256 amount = IDeployHelper(DEPLOY_HELPER).getDeploymentTotalCost(inbox, maxFeePerGas);\n        IERC20(feeToken).transferFrom(msg.sender, inbox, amount);\n        IDeployHelper(DEPLOY_HELPER).perform(inbox, feeToken, maxFeePerGas);\n    }\n}\n\ninterface IERC20 {\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n}\n\ninterface IDeployHelper {\n    function getDeploymentTotalCost(address inbox, uint256 maxFeePerGas)\n        external\n        view\n        returns (uint256);\n\n    function perform(\n        address _inbox,\n        address _nativeToken,\n        uint256 _maxFeePerGas\n    ) external payable;\n}\n\ninterface IInboxBase {\n    function bridge() external view returns (address);\n}\n\ninterface IERC20Bridge {\n    function nativeToken() external view returns (address);\n}\n"}, "src/rollup/IRollupAdmin.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./IRollupCore.sol\";\nimport \"../bridge/ISequencerInbox.sol\";\nimport \"../bridge/IOutbox.sol\";\nimport \"../bridge/IOwnable.sol\";\nimport \"./Config.sol\";\n\ninterface IRollupAdmin {\n    event OwnerFunctionCalled(uint256 indexed id);\n\n    function initialize(Config calldata config, ContractDependencies calldata connectedContracts)\n        external;\n\n    /**\n     * @notice Add a contract authorized to put messages into this rollup's inbox\n     * @param _outbox Outbox contract to add\n     */\n    function setOutbox(IOutbox _outbox) external;\n\n    /**\n     * @notice Disable an old outbox from interacting with the bridge\n     * @param _outbox Outbox contract to remove\n     */\n    function removeOldOutbox(address _outbox) external;\n\n    /**\n     * @notice Enable or disable an inbox contract\n     * @param _inbox Inbox contract to add or remove\n     * @param _enabled New status of inbox\n     */\n    function setDelayedInbox(address _inbox, bool _enabled) external;\n\n    /**\n     * @notice Pause interaction with the rollup contract\n     */\n    function pause() external;\n\n    /**\n     * @notice Resume interaction with the rollup contract\n     */\n    function resume() external;\n\n    /**\n     * @notice Set the addresses of the validator whitelist\n     * @dev It is expected that both arrays are same length, and validator at\n     * position i corresponds to the value at position i\n     * @param _validator addresses to set in the whitelist\n     * @param _val value to set in the whitelist for corresponding address\n     */\n    function setValidator(address[] memory _validator, bool[] memory _val) external;\n\n    /**\n     * @notice Set a new owner address for the rollup proxy\n     * @param newOwner address of new rollup owner\n     */\n    function setOwner(address newOwner) external;\n\n    /**\n     * @notice Set minimum assertion period for the rollup\n     * @param newPeriod new minimum period for assertions\n     */\n    function setMinimumAssertionPeriod(uint256 newPeriod) external;\n\n    /**\n     * @notice Set number of blocks until a node is considered confirmed\n     * @param newConfirmPeriod new number of blocks until a node is confirmed\n     */\n    function setConfirmPeriodBlocks(uint64 newConfirmPeriod) external;\n\n    /**\n     * @notice Set number of extra blocks after a challenge\n     * @param newExtraTimeBlocks new number of blocks\n     */\n    function setExtraChallengeTimeBlocks(uint64 newExtraTimeBlocks) external;\n\n    /**\n     * @notice Set base stake required for an assertion\n     * @param newBaseStake maximum avmgas to be used per block\n     */\n    function setBaseStake(uint256 newBaseStake) external;\n\n    /**\n     * @notice Set the token used for stake, where address(0) == eth\n     * @dev Before changing the base stake token, you might need to change the\n     * implementation of the Rollup User logic!\n     * @param newStakeToken address of token used for staking\n     */\n    function setStakeToken(address newStakeToken) external;\n\n    /**\n     * @notice Upgrades the implementation of a beacon controlled by the rollup\n     * @param beacon address of beacon to be upgraded\n     * @param newImplementation new address of implementation\n     */\n    function upgradeBeacon(address beacon, address newImplementation) external;\n\n    function forceResolveChallenge(address[] memory stackerA, address[] memory stackerB) external;\n\n    function forceRefundStaker(address[] memory stacker) external;\n\n    function forceCreateNode(\n        uint64 prevNode,\n        uint256 prevNodeInboxMaxCount,\n        Assertion memory assertion,\n        bytes32 expectedNodeHash\n    ) external;\n\n    function forceConfirmNode(\n        uint64 nodeNum,\n        bytes32 blockHash,\n        bytes32 sendRoot\n    ) external;\n\n    function setLoserStakeEscrow(address newLoserStakerEscrow) external;\n\n    /**\n     * @notice Set the proving WASM module root\n     * @param newWasmModuleRoot new module root\n     */\n    function setWasmModuleRoot(bytes32 newWasmModuleRoot) external;\n\n    /**\n     * @notice set a new sequencer inbox contract\n     * @param _sequencerInbox new address of sequencer inbox\n     */\n    function setSequencerInbox(address _sequencerInbox) external;\n\n    /**\n     * @notice set the validatorWhitelistDisabled flag\n     * @param _validatorWhitelistDisabled new value of validatorWhitelistDisabled, i.e. true = disabled\n     */\n    function setValidatorWhitelistDisabled(bool _validatorWhitelistDisabled) external;\n}\n"}, "src/rollup/IRollupCore.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./Node.sol\";\nimport \"../bridge/IBridge.sol\";\nimport \"../bridge/IOutbox.sol\";\nimport \"../bridge/IInboxBase.sol\";\nimport \"./IRollupEventInbox.sol\";\nimport \"../challenge/IChallengeManager.sol\";\n\ninterface IRollupCore {\n    struct Staker {\n        uint256 amountStaked;\n        uint64 index;\n        uint64 latestStakedNode;\n        // currentChallenge is 0 if staker is not in a challenge\n        uint64 currentChallenge;\n        bool isStaked;\n    }\n\n    event RollupInitialized(bytes32 machineHash, uint256 chainId);\n\n    event NodeCreated(\n        uint64 indexed nodeNum,\n        bytes32 indexed parentNodeHash,\n        bytes32 indexed nodeHash,\n        bytes32 executionHash,\n        Assertion assertion,\n        bytes32 afterInboxBatchAcc,\n        bytes32 wasmModuleRoot,\n        uint256 inboxMaxCount\n    );\n\n    event NodeConfirmed(uint64 indexed nodeNum, bytes32 blockHash, bytes32 sendRoot);\n\n    event NodeRejected(uint64 indexed nodeNum);\n\n    event RollupChallengeStarted(\n        uint64 indexed challengeIndex,\n        address asserter,\n        address challenger,\n        uint64 challengedNode\n    );\n\n    event UserStakeUpdated(address indexed user, uint256 initialBalance, uint256 finalBalance);\n\n    event UserWithdrawableFundsUpdated(\n        address indexed user,\n        uint256 initialBalance,\n        uint256 finalBalance\n    );\n\n    function confirmPeriodBlocks() external view returns (uint64);\n\n    function extraChallengeTimeBlocks() external view returns (uint64);\n\n    function chainId() external view returns (uint256);\n\n    function baseStake() external view returns (uint256);\n\n    function wasmModuleRoot() external view returns (bytes32);\n\n    function bridge() external view returns (IBridge);\n\n    function sequencerInbox() external view returns (ISequencerInbox);\n\n    function outbox() external view returns (IOutbox);\n\n    function rollupEventInbox() external view returns (IRollupEventInbox);\n\n    function challengeManager() external view returns (IChallengeManager);\n\n    function loserStakeEscrow() external view returns (address);\n\n    function stakeToken() external view returns (address);\n\n    function minimumAssertionPeriod() external view returns (uint256);\n\n    function isValidator(address) external view returns (bool);\n\n    function validatorWhitelistDisabled() external view returns (bool);\n\n    /**\n     * @notice Get the Node for the given index.\n     */\n    function getNode(uint64 nodeNum) external view returns (Node memory);\n\n    /**\n     * @notice Returns the block in which the given node was created for looking up its creation event.\n     * Unlike the Node's createdAtBlock field, this will be the ArbSys blockNumber if the host chain is an Arbitrum chain.\n     * That means that the block number returned for this is usable for event queries.\n     * This function will revert if the given node number does not exist.\n     * @dev This function is meant for internal use only and has no stability guarantees.\n     */\n    function getNodeCreationBlockForLogLookup(uint64 nodeNum) external view returns (uint256);\n\n    /**\n     * @notice Check if the specified node has been staked on by the provided staker.\n     * Only accurate at the latest confirmed node and afterwards.\n     */\n    function nodeHasStaker(uint64 nodeNum, address staker) external view returns (bool);\n\n    /**\n     * @notice Get the address of the staker at the given index\n     * @param stakerNum Index of the staker\n     * @return Address of the staker\n     */\n    function getStakerAddress(uint64 stakerNum) external view returns (address);\n\n    /**\n     * @notice Check whether the given staker is staked\n     * @param staker Staker address to check\n     * @return True or False for whether the staker was staked\n     */\n    function isStaked(address staker) external view returns (bool);\n\n    /**\n     * @notice Get the latest staked node of the given staker\n     * @param staker Staker address to lookup\n     * @return Latest node staked of the staker\n     */\n    function latestStakedNode(address staker) external view returns (uint64);\n\n    /**\n     * @notice Get the current challenge of the given staker\n     * @param staker Staker address to lookup\n     * @return Current challenge of the staker\n     */\n    function currentChallenge(address staker) external view returns (uint64);\n\n    /**\n     * @notice Get the amount staked of the given staker\n     * @param staker Staker address to lookup\n     * @return Amount staked of the staker\n     */\n    function amountStaked(address staker) external view returns (uint256);\n\n    /**\n     * @notice Retrieves stored information about a requested staker\n     * @param staker Staker address to retrieve\n     * @return A structure with information about the requested staker\n     */\n    function getStaker(address staker) external view returns (Staker memory);\n\n    /**\n     * @notice Get the original staker address of the zombie at the given index\n     * @param zombieNum Index of the zombie to lookup\n     * @return Original staker address of the zombie\n     */\n    function zombieAddress(uint256 zombieNum) external view returns (address);\n\n    /**\n     * @notice Get Latest node that the given zombie at the given index is staked on\n     * @param zombieNum Index of the zombie to lookup\n     * @return Latest node that the given zombie is staked on\n     */\n    function zombieLatestStakedNode(uint256 zombieNum) external view returns (uint64);\n\n    /// @return Current number of un-removed zombies\n    function zombieCount() external view returns (uint256);\n\n    function isZombie(address staker) external view returns (bool);\n\n    /**\n     * @notice Get the amount of funds withdrawable by the given address\n     * @param owner Address to check the funds of\n     * @return Amount of funds withdrawable by owner\n     */\n    function withdrawableFunds(address owner) external view returns (uint256);\n\n    /**\n     * @return Index of the first unresolved node\n     * @dev If all nodes have been resolved, this will be latestNodeCreated + 1\n     */\n    function firstUnresolvedNode() external view returns (uint64);\n\n    /// @return Index of the latest confirmed node\n    function latestConfirmed() external view returns (uint64);\n\n    /// @return Index of the latest rollup node created\n    function latestNodeCreated() external view returns (uint64);\n\n    /// @return Ethereum block that the most recent stake was created\n    function lastStakeBlock() external view returns (uint64);\n\n    /// @return Number of active stakers currently staked\n    function stakerCount() external view returns (uint64);\n}\n"}, "src/rollup/IRollupEventInbox.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../bridge/IBridge.sol\";\n\ninterface IRollupEventInbox {\n    function bridge() external view returns (IBridge);\n\n    function initialize(IBridge _bridge) external;\n\n    function rollup() external view returns (address);\n\n    function updateRollupAddress() external;\n\n    function rollupInitialized(uint256 chainId, string calldata chainConfig) external;\n}\n"}, "src/rollup/IRollupLogic.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./IRollupCore.sol\";\nimport \"../bridge/ISequencerInbox.sol\";\nimport \"../bridge/IOutbox.sol\";\nimport \"../bridge/IOwnable.sol\";\n\ninterface IRollupUserAbs is IRollupCore, IOwnable {\n    /// @dev the user logic just validated configuration and shouldn't write to state during init\n    /// this allows the admin logic to ensure consistency on parameters.\n    function initialize(address stakeToken) external view;\n\n    function removeWhitelistAfterFork() external;\n\n    function removeWhitelistAfterValidatorAfk() external;\n\n    function isERC20Enabled() external view returns (bool);\n\n    function rejectNextNode(address stakerAddress) external;\n\n    function confirmNextNode(bytes32 blockHash, bytes32 sendRoot) external;\n\n    function fastConfirmNextNode(\n        bytes32 blockHash,\n        bytes32 sendRoot,\n        bytes32 nodeHash\n    ) external;\n\n    function stakeOnExistingNode(uint64 nodeNum, bytes32 nodeHash) external;\n\n    function stakeOnNewNode(\n        Assertion memory assertion,\n        bytes32 expectedNodeHash,\n        uint256 prevNodeInboxMaxCount\n    ) external;\n\n    function returnOldDeposit(address stakerAddress) external;\n\n    function reduceDeposit(uint256 target) external;\n\n    function removeZombie(uint256 zombieNum, uint256 maxNodes) external;\n\n    function removeOldZombies(uint256 startIndex) external;\n\n    function requiredStake(\n        uint256 blockNumber,\n        uint64 firstUnresolvedNodeNum,\n        uint64 latestCreatedNode\n    ) external view returns (uint256);\n\n    function currentRequiredStake() external view returns (uint256);\n\n    function countStakedZombies(uint64 nodeNum) external view returns (uint256);\n\n    function countZombiesStakedOnChildren(uint64 nodeNum) external view returns (uint256);\n\n    function requireUnresolvedExists() external view;\n\n    function requireUnresolved(uint256 nodeNum) external view;\n\n    function withdrawStakerFunds() external returns (uint256);\n\n    function createChallenge(\n        address[2] calldata stakers,\n        uint64[2] calldata nodeNums,\n        MachineStatus[2] calldata machineStatuses,\n        GlobalState[2] calldata globalStates,\n        uint64 numBlocks,\n        bytes32 secondExecutionHash,\n        uint256[2] calldata proposedTimes,\n        bytes32[2] calldata wasmModuleRoots\n    ) external;\n}\n\ninterface IRollupUser is IRollupUserAbs {\n    function newStakeOnExistingNode(uint64 nodeNum, bytes32 nodeHash) external payable;\n\n    function newStakeOnNewNode(\n        Assertion calldata assertion,\n        bytes32 expectedNodeHash,\n        uint256 prevNodeInboxMaxCount\n    ) external payable;\n\n    function addToDeposit(address stakerAddress) external payable;\n}\n\ninterface IRollupUserERC20 is IRollupUserAbs {\n    function newStakeOnExistingNode(\n        uint256 tokenAmount,\n        uint64 nodeNum,\n        bytes32 nodeHash\n    ) external;\n\n    function newStakeOnNewNode(\n        uint256 tokenAmount,\n        Assertion calldata assertion,\n        bytes32 expectedNodeHash,\n        uint256 prevNodeInboxMaxCount\n    ) external;\n\n    function addToDeposit(address stakerAddress, uint256 tokenAmount) external;\n}\n"}, "src/rollup/Node.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../state/GlobalState.sol\";\nimport \"../state/Machine.sol\";\n\nstruct ExecutionState {\n    GlobalState globalState;\n    MachineStatus machineStatus;\n}\n\nstruct Assertion {\n    ExecutionState beforeState;\n    ExecutionState afterState;\n    uint64 numBlocks;\n}\n\nstruct Node {\n    // Hash of the state of the chain as of this node\n    bytes32 stateHash;\n    // Hash of the data that can be challenged\n    bytes32 challengeHash;\n    // Hash of the data that will be committed if this node is confirmed\n    bytes32 confirmData;\n    // Index of the node previous to this one\n    uint64 prevNum;\n    // Deadline at which this node can be confirmed\n    uint64 deadlineBlock;\n    // Deadline at which a child of this node can be confirmed\n    uint64 noChildConfirmedBeforeBlock;\n    // Number of stakers staked on this node. This includes real stakers and zombies\n    uint64 stakerCount;\n    // Number of stakers staked on a child node. This includes real stakers and zombies\n    uint64 childStakerCount;\n    // This value starts at zero and is set to a value when the first child is created. After that it is constant until the node is destroyed or the owner destroys pending nodes\n    uint64 firstChildBlock;\n    // The number of the latest child of this node to be created\n    uint64 latestChildNumber;\n    // The block number when this node was created\n    uint64 createdAtBlock;\n    // A hash of all the data needed to determine this node's validity, to protect against reorgs\n    bytes32 nodeHash;\n}\n\n/**\n * @notice Utility functions for Node\n */\nlibrary NodeLib {\n    /**\n     * @notice Initialize a Node\n     * @param _stateHash Initial value of stateHash\n     * @param _challengeHash Initial value of challengeHash\n     * @param _confirmData Initial value of confirmData\n     * @param _prevNum Initial value of prevNum\n     * @param _deadlineBlock Initial value of deadlineBlock\n     * @param _nodeHash Initial value of nodeHash\n     */\n    function createNode(\n        bytes32 _stateHash,\n        bytes32 _challengeHash,\n        bytes32 _confirmData,\n        uint64 _prevNum,\n        uint64 _deadlineBlock,\n        bytes32 _nodeHash\n    ) internal view returns (Node memory) {\n        Node memory node;\n        node.stateHash = _stateHash;\n        node.challengeHash = _challengeHash;\n        node.confirmData = _confirmData;\n        node.prevNum = _prevNum;\n        node.deadlineBlock = _deadlineBlock;\n        node.noChildConfirmedBeforeBlock = _deadlineBlock;\n        node.createdAtBlock = uint64(block.number);\n        node.nodeHash = _nodeHash;\n        return node;\n    }\n\n    /**\n     * @notice Update child properties\n     * @param number The child number to set\n     */\n    function childCreated(Node storage self, uint64 number) internal {\n        if (self.firstChildBlock == 0) {\n            self.firstChildBlock = uint64(block.number);\n        }\n        self.latestChildNumber = number;\n    }\n\n    /**\n     * @notice Update the child confirmed deadline\n     * @param deadline The new deadline to set\n     */\n    function newChildConfirmDeadline(Node storage self, uint64 deadline) internal {\n        self.noChildConfirmedBeforeBlock = deadline;\n    }\n\n    /**\n     * @notice Check whether the current block number has met or passed the node's deadline\n     */\n    function requirePastDeadline(Node memory self) internal view {\n        require(block.number >= self.deadlineBlock, \"BEFORE_DEADLINE\");\n    }\n\n    /**\n     * @notice Check whether the current block number has met or passed deadline for children of this node to be confirmed\n     */\n    function requirePastChildConfirmDeadline(Node memory self) internal view {\n        require(block.number >= self.noChildConfirmedBeforeBlock, \"CHILD_TOO_RECENT\");\n    }\n}\n"}, "src/rollup/RollupAdminLogic.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./IRollupAdmin.sol\";\nimport \"./IRollupLogic.sol\";\nimport \"./RollupCore.sol\";\nimport \"../bridge/IOutbox.sol\";\nimport \"../bridge/ISequencerInbox.sol\";\nimport \"../challenge/IChallengeManager.sol\";\nimport \"../libraries/DoubleLogicUUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\n\nimport {NO_CHAL_INDEX} from \"../libraries/Constants.sol\";\n\ncontract RollupAdminLogic is RollupCore, IRollupAdmin, DoubleLogicUUPSUpgradeable {\n    function initialize(Config calldata config, ContractDependencies calldata connectedContracts)\n        external\n        override\n        onlyProxy\n        initializer\n    {\n        rollupDeploymentBlock = block.number;\n        bridge = connectedContracts.bridge;\n        sequencerInbox = connectedContracts.sequencerInbox;\n        connectedContracts.bridge.setDelayedInbox(address(connectedContracts.inbox), true);\n        connectedContracts.bridge.setSequencerInbox(address(connectedContracts.sequencerInbox));\n\n        inbox = connectedContracts.inbox;\n        outbox = connectedContracts.outbox;\n        connectedContracts.bridge.setOutbox(address(connectedContracts.outbox), true);\n        rollupEventInbox = connectedContracts.rollupEventInbox;\n        connectedContracts.bridge.setDelayedInbox(\n            address(connectedContracts.rollupEventInbox),\n            true\n        );\n\n        connectedContracts.rollupEventInbox.rollupInitialized(config.chainId, config.chainConfig);\n        connectedContracts.sequencerInbox.addSequencerL2Batch(\n            0,\n            \"\",\n            1,\n            IGasRefunder(address(0)),\n            0,\n            1\n        );\n\n        validatorUtils = connectedContracts.validatorUtils;\n        validatorWalletCreator = connectedContracts.validatorWalletCreator;\n        challengeManager = connectedContracts.challengeManager;\n\n        Node memory node = createInitialNode();\n        initializeCore(node);\n\n        confirmPeriodBlocks = config.confirmPeriodBlocks;\n        extraChallengeTimeBlocks = config.extraChallengeTimeBlocks;\n        chainId = config.chainId;\n        baseStake = config.baseStake;\n        wasmModuleRoot = config.wasmModuleRoot;\n        // A little over 15 minutes\n        minimumAssertionPeriod = 75;\n\n        // the owner can't access the rollup user facet where escrow is redeemable\n        require(config.loserStakeEscrow != _getAdmin(), \"INVALID_ESCROW_ADMIN\");\n        // this next check shouldn't be an issue if the owner controls an AdminProxy\n        // that accesses the admin facet, but still seems like a good extra precaution\n        require(config.loserStakeEscrow != config.owner, \"INVALID_ESCROW_OWNER\");\n        loserStakeEscrow = config.loserStakeEscrow;\n\n        stakeToken = config.stakeToken;\n\n        emit RollupInitialized(config.wasmModuleRoot, config.chainId);\n    }\n\n    function createInitialNode() private view returns (Node memory) {\n        GlobalState memory emptyGlobalState;\n        bytes32 state = RollupLib.stateHashMem(\n            ExecutionState(emptyGlobalState, MachineStatus.FINISHED),\n            1 // inboxMaxCount - force the first assertion to read a message\n        );\n        return\n            NodeLib.createNode(\n                state,\n                0, // challenge hash (not challengeable)\n                0, // confirm data\n                0, // prev node\n                uint64(block.number), // deadline block (not challengeable)\n                0 // initial node has a node hash of 0\n            );\n    }\n\n    /**\n     * Functions are only to reach this logic contract if the caller is the owner\n     * so there is no need for a redundant onlyOwner check\n     */\n\n    /**\n     * @notice Add a contract authorized to put messages into this rollup's inbox\n     * @param _outbox Outbox contract to add\n     */\n    function setOutbox(IOutbox _outbox) external override {\n        outbox = _outbox;\n        bridge.setOutbox(address(_outbox), true);\n        emit OwnerFunctionCalled(0);\n    }\n\n    /**\n     * @notice Disable an old outbox from interacting with the bridge\n     * @param _outbox Outbox contract to remove\n     */\n    function removeOldOutbox(address _outbox) external override {\n        require(_outbox != address(outbox), \"CUR_OUTBOX\");\n        bridge.setOutbox(_outbox, false);\n        emit OwnerFunctionCalled(1);\n    }\n\n    /**\n     * @notice Enable or disable an inbox contract\n     * @param _inbox Inbox contract to add or remove\n     * @param _enabled New status of inbox\n     */\n    function setDelayedInbox(address _inbox, bool _enabled) external override {\n        bridge.setDelayedInbox(address(_inbox), _enabled);\n        emit OwnerFunctionCalled(2);\n    }\n\n    /**\n     * @notice Pause interaction with the rollup contract.\n     * The time spent paused is not incremented in the rollup's timing for node validation.\n     * @dev this function may be frontrun by a validator (ie to create a node before the system is paused).\n     * The pause should be called atomically with required checks to be sure the system is paused in a consistent state.\n     * The RollupAdmin may execute a check against the Rollup's latest node num or the ChallengeManager, then execute this function atomically with it.\n     */\n    function pause() external override {\n        _pause();\n        emit OwnerFunctionCalled(3);\n    }\n\n    /**\n     * @notice Resume interaction with the rollup contract\n     */\n    function resume() external override {\n        _unpause();\n        emit OwnerFunctionCalled(4);\n    }\n\n    /// @notice allows the admin to upgrade the primary logic contract (ie rollup admin logic, aka this)\n    /// @dev this function doesn't revert as this primary logic contract is only\n    /// reachable by the proxy's admin\n    function _authorizeUpgrade(address newImplementation) internal override {}\n\n    /// @notice allows the admin to upgrade the secondary logic contract (ie rollup user logic)\n    /// @dev this function doesn't revert as this primary logic contract is only\n    /// reachable by the proxy's admin\n    function _authorizeSecondaryUpgrade(address newImplementation) internal override {}\n\n    /**\n     * @notice Set the addresses of the validator whitelist\n     * @dev It is expected that both arrays are same length, and validator at\n     * position i corresponds to the value at position i\n     * @param _validator addresses to set in the whitelist\n     * @param _val value to set in the whitelist for corresponding address\n     */\n    function setValidator(address[] calldata _validator, bool[] calldata _val) external override {\n        require(_validator.length > 0, \"EMPTY_ARRAY\");\n        require(_validator.length == _val.length, \"WRONG_LENGTH\");\n\n        for (uint256 i = 0; i < _validator.length; i++) {\n            isValidator[_validator[i]] = _val[i];\n        }\n        emit OwnerFunctionCalled(6);\n    }\n\n    /**\n     * @notice Set a new owner address for the rollup\n     * @dev it is expected that only the rollup admin can use this facet to set a new owner\n     * @param newOwner address of new rollup owner\n     */\n    function setOwner(address newOwner) external override {\n        _changeAdmin(newOwner);\n        emit OwnerFunctionCalled(7);\n    }\n\n    /**\n     * @notice Set minimum assertion period for the rollup\n     * @param newPeriod new minimum period for assertions\n     */\n    function setMinimumAssertionPeriod(uint256 newPeriod) external override {\n        minimumAssertionPeriod = newPeriod;\n        emit OwnerFunctionCalled(8);\n    }\n\n    /**\n     * @notice Set number of blocks until a node is considered confirmed\n     * @param newConfirmPeriod new number of blocks\n     */\n    function setConfirmPeriodBlocks(uint64 newConfirmPeriod) external override {\n        require(newConfirmPeriod > 0, \"INVALID_CONFIRM_PERIOD\");\n        confirmPeriodBlocks = newConfirmPeriod;\n        emit OwnerFunctionCalled(9);\n    }\n\n    /**\n     * @notice Set number of extra blocks after a challenge\n     * @param newExtraTimeBlocks new number of blocks\n     */\n    function setExtraChallengeTimeBlocks(uint64 newExtraTimeBlocks) external override {\n        extraChallengeTimeBlocks = newExtraTimeBlocks;\n        emit OwnerFunctionCalled(10);\n    }\n\n    /**\n     * @notice Set base stake required for an assertion\n     * @param newBaseStake minimum amount of stake required\n     */\n    function setBaseStake(uint256 newBaseStake) external override {\n        baseStake = newBaseStake;\n        emit OwnerFunctionCalled(12);\n    }\n\n    /**\n     * @notice Set the token used for stake, where address(0) == eth\n     * @dev Before changing the base stake token, you might need to change the\n     * implementation of the Rollup User facet!\n     * @param newStakeToken address of token used for staking\n     */\n    function setStakeToken(address newStakeToken) external override whenPaused {\n        /*\n         * To change the stake token without breaking consistency one would need to:\n         * Pause the system, have all stakers remove their funds,\n         * update the user logic to handle ERC20s, change the stake token, then resume.\n         *\n         * Note: To avoid loss of funds stakers must remove their funds and claim all the\n         * available withdrawable funds before the system is paused.\n         */\n        bool expectERC20Support = newStakeToken != address(0);\n        // this assumes the rollup isn't its own admin. if needed, instead use a ProxyAdmin by OZ!\n        bool actualERC20Support = IRollupUser(address(this)).isERC20Enabled();\n        require(actualERC20Support == expectERC20Support, \"NO_USER_LOGIC_SUPPORT\");\n        require(stakerCount() == 0, \"NO_ACTIVE_STAKERS\");\n        require(totalWithdrawableFunds == 0, \"NO_PENDING_WITHDRAW\");\n        stakeToken = newStakeToken;\n        emit OwnerFunctionCalled(13);\n    }\n\n    /**\n     * @notice Upgrades the implementation of a beacon controlled by the rollup\n     * @param beacon address of beacon to be upgraded\n     * @param newImplementation new address of implementation\n     */\n    function upgradeBeacon(address beacon, address newImplementation) external override {\n        UpgradeableBeacon(beacon).upgradeTo(newImplementation);\n        emit OwnerFunctionCalled(20);\n    }\n\n    function forceResolveChallenge(address[] calldata stakerA, address[] calldata stakerB)\n        external\n        override\n        whenPaused\n    {\n        require(stakerA.length > 0, \"EMPTY_ARRAY\");\n        require(stakerA.length == stakerB.length, \"WRONG_LENGTH\");\n        for (uint256 i = 0; i < stakerA.length; i++) {\n            uint64 chall = inChallenge(stakerA[i], stakerB[i]);\n\n            require(chall != NO_CHAL_INDEX, \"NOT_IN_CHALL\");\n            clearChallenge(stakerA[i]);\n            clearChallenge(stakerB[i]);\n            challengeManager.clearChallenge(chall);\n        }\n        emit OwnerFunctionCalled(21);\n    }\n\n    function forceRefundStaker(address[] calldata staker) external override whenPaused {\n        require(staker.length > 0, \"EMPTY_ARRAY\");\n        for (uint256 i = 0; i < staker.length; i++) {\n            require(_stakerMap[staker[i]].currentChallenge == NO_CHAL_INDEX, \"STAKER_IN_CHALL\");\n            reduceStakeTo(staker[i], 0);\n            turnIntoZombie(staker[i]);\n        }\n        emit OwnerFunctionCalled(22);\n    }\n\n    function forceCreateNode(\n        uint64 prevNode,\n        uint256 prevNodeInboxMaxCount,\n        Assertion calldata assertion,\n        bytes32 expectedNodeHash\n    ) external override whenPaused {\n        require(prevNode == latestConfirmed(), \"ONLY_LATEST_CONFIRMED\");\n\n        createNewNode(assertion, prevNode, prevNodeInboxMaxCount, expectedNodeHash);\n\n        emit OwnerFunctionCalled(23);\n    }\n\n    function forceConfirmNode(\n        uint64 nodeNum,\n        bytes32 blockHash,\n        bytes32 sendRoot\n    ) external override whenPaused {\n        // this skips deadline, staker and zombie validation\n        confirmNode(nodeNum, blockHash, sendRoot);\n        emit OwnerFunctionCalled(24);\n    }\n\n    function setLoserStakeEscrow(address newLoserStakerEscrow) external override {\n        // escrow holder can't be proxy admin, since escrow is only redeemable through\n        // the primary user logic contract\n        require(newLoserStakerEscrow != _getAdmin(), \"INVALID_ESCROW\");\n        loserStakeEscrow = newLoserStakerEscrow;\n        emit OwnerFunctionCalled(25);\n    }\n\n    /**\n     * @notice Set the proving WASM module root\n     * @param newWasmModuleRoot new module root\n     */\n    function setWasmModuleRoot(bytes32 newWasmModuleRoot) external override {\n        wasmModuleRoot = newWasmModuleRoot;\n        emit OwnerFunctionCalled(26);\n    }\n\n    /**\n     * @notice set a new sequencer inbox contract\n     * @param _sequencerInbox new address of sequencer inbox\n     */\n    function setSequencerInbox(address _sequencerInbox) external override {\n        bridge.setSequencerInbox(_sequencerInbox);\n        emit OwnerFunctionCalled(27);\n    }\n\n    /**\n     * @notice sets the rollup's inbox reference. Does not update the bridge's view.\n     * @param newInbox new address of inbox\n     */\n    function setInbox(IInboxBase newInbox) external {\n        inbox = newInbox;\n        emit OwnerFunctionCalled(28);\n    }\n\n    function createNitroMigrationGenesis(Assertion calldata assertion) external whenPaused {\n        bytes32 expectedSendRoot = bytes32(0);\n        uint64 expectedInboxCount = 1;\n\n        require(latestNodeCreated() == 0, \"NON_GENESIS_NODES_EXIST\");\n        require(GlobalStateLib.isEmpty(assertion.beforeState.globalState), \"NOT_EMPTY_BEFORE\");\n        require(\n            assertion.beforeState.machineStatus == MachineStatus.FINISHED,\n            \"BEFORE_MACHINE_NOT_FINISHED\"\n        );\n        // accessors such as state.getSendRoot not available for calldata structs, only memory\n        require(\n            assertion.afterState.globalState.bytes32Vals[1] == expectedSendRoot,\n            \"NOT_ZERO_SENDROOT\"\n        );\n        require(\n            assertion.afterState.globalState.u64Vals[0] == expectedInboxCount,\n            \"INBOX_NOT_AT_ONE\"\n        );\n        require(assertion.afterState.globalState.u64Vals[1] == 0, \"POSITION_IN_MESSAGE_NOT_ZERO\");\n        require(\n            assertion.afterState.machineStatus == MachineStatus.FINISHED,\n            \"AFTER_MACHINE_NOT_FINISHED\"\n        );\n        bytes32 genesisBlockHash = assertion.afterState.globalState.bytes32Vals[0];\n        createNewNode(assertion, 0, expectedInboxCount, bytes32(0));\n        confirmNode(1, genesisBlockHash, expectedSendRoot);\n        emit OwnerFunctionCalled(29);\n    }\n\n    /**\n     * @notice set the validatorWhitelistDisabled flag\n     * @param _validatorWhitelistDisabled new value of validatorWhitelistDisabled, i.e. true = disabled\n     */\n    function setValidatorWhitelistDisabled(bool _validatorWhitelistDisabled) external {\n        validatorWhitelistDisabled = _validatorWhitelistDisabled;\n        emit OwnerFunctionCalled(30);\n    }\n\n    /**\n     * @notice set the anyTrustFastConfirmer address\n     *         must also call `setValidator` to set the same address as a validator to work\n     *         old fast confirmer need to be removed from the validator list manually\n     * @param _anyTrustFastConfirmer new value of anyTrustFastConfirmer\n     */\n    function setAnyTrustFastConfirmer(address _anyTrustFastConfirmer) external {\n        anyTrustFastConfirmer = _anyTrustFastConfirmer;\n        emit OwnerFunctionCalled(31);\n    }\n}\n"}, "src/rollup/RollupCore.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport \"./Node.sol\";\nimport \"./RollupLib.sol\";\nimport \"./IRollupEventInbox.sol\";\nimport \"./IRollupCore.sol\";\n\nimport \"../challenge/IChallengeManager.sol\";\n\nimport \"../bridge/ISequencerInbox.sol\";\nimport \"../bridge/IBridge.sol\";\nimport \"../bridge/IOutbox.sol\";\n\nimport \"../precompiles/ArbSys.sol\";\n\nimport \"../libraries/ArbitrumChecker.sol\";\nimport {NO_CHAL_INDEX} from \"../libraries/Constants.sol\";\n\nabstract contract RollupCore is IRollupCore, PausableUpgradeable {\n    using NodeLib for Node;\n    using GlobalStateLib for GlobalState;\n\n    // Rollup Config\n    uint64 public confirmPeriodBlocks;\n    uint64 public extraChallengeTimeBlocks;\n    uint256 public chainId;\n    uint256 public baseStake;\n    bytes32 public wasmModuleRoot;\n\n    IInboxBase public inbox;\n    IBridge public bridge;\n    IOutbox public outbox;\n    ISequencerInbox public sequencerInbox;\n    IRollupEventInbox public rollupEventInbox;\n    IChallengeManager public override challengeManager;\n\n    // misc useful contracts when interacting with the rollup\n    address public validatorUtils;\n    address public validatorWalletCreator;\n\n    // when a staker loses a challenge, half of their funds get escrowed in this address\n    address public loserStakeEscrow;\n    address public stakeToken;\n    uint256 public minimumAssertionPeriod;\n\n    mapping(address => bool) public isValidator;\n\n    // Stakers become Zombies after losing a challenge\n    struct Zombie {\n        address stakerAddress;\n        uint64 latestStakedNode;\n    }\n\n    uint64 private _latestConfirmed;\n    uint64 private _firstUnresolvedNode;\n    uint64 private _latestNodeCreated;\n    uint64 private _lastStakeBlock;\n    mapping(uint64 => Node) private _nodes;\n    mapping(uint64 => mapping(address => bool)) private _nodeStakers;\n\n    address[] private _stakerList;\n    mapping(address => Staker) public _stakerMap;\n\n    Zombie[] private _zombies;\n\n    mapping(address => uint256) private _withdrawableFunds;\n    uint256 public totalWithdrawableFunds;\n    uint256 public rollupDeploymentBlock;\n\n    // The node number of the initial node\n    uint64 internal constant GENESIS_NODE = 0;\n\n    bool public validatorWhitelistDisabled;\n    address public anyTrustFastConfirmer;\n\n    // If the chain this RollupCore is deployed on is an Arbitrum chain.\n    bool internal immutable _hostChainIsArbitrum = ArbitrumChecker.runningOnArbitrum();\n    // If the chain RollupCore is deployed on, this will contain the ArbSys.blockNumber() at each node's creation.\n    mapping(uint64 => uint256) internal _nodeCreatedAtArbSysBlock;\n\n    /**\n     * @notice Get a storage reference to the Node for the given node index\n     * @param nodeNum Index of the node\n     * @return Node struct\n     */\n    function getNodeStorage(uint64 nodeNum) internal view returns (Node storage) {\n        return _nodes[nodeNum];\n    }\n\n    /**\n     * @notice Get the Node for the given index.\n     */\n    function getNode(uint64 nodeNum) public view override returns (Node memory) {\n        return getNodeStorage(nodeNum);\n    }\n\n    /**\n     * @notice Returns the block in which the given node was created for looking up its creation event.\n     * Unlike the Node's createdAtBlock field, this will be the ArbSys blockNumber if the host chain is an Arbitrum chain.\n     * That means that the block number returned for this is usable for event queries.\n     * This function will revert if the given node number does not exist.\n     * @dev This function is meant for internal use only and has no stability guarantees.\n     */\n    function getNodeCreationBlockForLogLookup(uint64 nodeNum)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (_hostChainIsArbitrum) {\n            uint256 blockNum = _nodeCreatedAtArbSysBlock[nodeNum];\n            require(blockNum > 0, \"NO_NODE\");\n            return blockNum;\n        } else {\n            Node storage node = getNodeStorage(nodeNum);\n            require(node.deadlineBlock != 0, \"NO_NODE\");\n            return node.createdAtBlock;\n        }\n    }\n\n    /**\n     * @notice Check if the specified node has been staked on by the provided staker.\n     * Only accurate at the latest confirmed node and afterwards.\n     */\n    function nodeHasStaker(uint64 nodeNum, address staker) public view override returns (bool) {\n        return _nodeStakers[nodeNum][staker];\n    }\n\n    /**\n     * @notice Get the address of the staker at the given index\n     * @param stakerNum Index of the staker\n     * @return Address of the staker\n     */\n    function getStakerAddress(uint64 stakerNum) external view override returns (address) {\n        return _stakerList[stakerNum];\n    }\n\n    /**\n     * @notice Check whether the given staker is staked\n     * @param staker Staker address to check\n     * @return True or False for whether the staker was staked\n     */\n    function isStaked(address staker) public view override returns (bool) {\n        return _stakerMap[staker].isStaked;\n    }\n\n    /**\n     * @notice Check whether the given staker is staked on the latest confirmed node,\n     * which includes if the staker is staked on a descendent of the latest confirmed node.\n     * @param staker Staker address to check\n     * @return True or False for whether the staker was staked\n     */\n    function isStakedOnLatestConfirmed(address staker) public view returns (bool) {\n        return _stakerMap[staker].isStaked && nodeHasStaker(_latestConfirmed, staker);\n    }\n\n    /**\n     * @notice Get the latest staked node of the given staker\n     * @param staker Staker address to lookup\n     * @return Latest node staked of the staker\n     */\n    function latestStakedNode(address staker) public view override returns (uint64) {\n        return _stakerMap[staker].latestStakedNode;\n    }\n\n    /**\n     * @notice Get the current challenge of the given staker\n     * @param staker Staker address to lookup\n     * @return Current challenge of the staker\n     */\n    function currentChallenge(address staker) public view override returns (uint64) {\n        return _stakerMap[staker].currentChallenge;\n    }\n\n    /**\n     * @notice Get the amount staked of the given staker\n     * @param staker Staker address to lookup\n     * @return Amount staked of the staker\n     */\n    function amountStaked(address staker) public view override returns (uint256) {\n        return _stakerMap[staker].amountStaked;\n    }\n\n    /**\n     * @notice Retrieves stored information about a requested staker\n     * @param staker Staker address to retrieve\n     * @return A structure with information about the requested staker\n     */\n    function getStaker(address staker) external view override returns (Staker memory) {\n        return _stakerMap[staker];\n    }\n\n    /**\n     * @notice Get the original staker address of the zombie at the given index\n     * @param zombieNum Index of the zombie to lookup\n     * @return Original staker address of the zombie\n     */\n    function zombieAddress(uint256 zombieNum) public view override returns (address) {\n        return _zombies[zombieNum].stakerAddress;\n    }\n\n    /**\n     * @notice Get Latest node that the given zombie at the given index is staked on\n     * @param zombieNum Index of the zombie to lookup\n     * @return Latest node that the given zombie is staked on\n     */\n    function zombieLatestStakedNode(uint256 zombieNum) public view override returns (uint64) {\n        return _zombies[zombieNum].latestStakedNode;\n    }\n\n    /**\n     * @notice Retrieves stored information about a requested zombie\n     * @param zombieNum Index of the zombie to lookup\n     * @return A structure with information about the requested staker\n     */\n    function getZombieStorage(uint256 zombieNum) internal view returns (Zombie storage) {\n        return _zombies[zombieNum];\n    }\n\n    /// @return Current number of un-removed zombies\n    function zombieCount() public view override returns (uint256) {\n        return _zombies.length;\n    }\n\n    function isZombie(address staker) public view override returns (bool) {\n        for (uint256 i = 0; i < _zombies.length; i++) {\n            if (staker == _zombies[i].stakerAddress) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @notice Get the amount of funds withdrawable by the given address\n     * @param user Address to check the funds of\n     * @return Amount of funds withdrawable by user\n     */\n    function withdrawableFunds(address user) external view override returns (uint256) {\n        return _withdrawableFunds[user];\n    }\n\n    /**\n     * @return Index of the first unresolved node\n     * @dev If all nodes have been resolved, this will be latestNodeCreated + 1\n     */\n    function firstUnresolvedNode() public view override returns (uint64) {\n        return _firstUnresolvedNode;\n    }\n\n    /// @return Index of the latest confirmed node\n    function latestConfirmed() public view override returns (uint64) {\n        return _latestConfirmed;\n    }\n\n    /// @return Index of the latest rollup node created\n    function latestNodeCreated() public view override returns (uint64) {\n        return _latestNodeCreated;\n    }\n\n    /// @return Ethereum block that the most recent stake was created\n    function lastStakeBlock() external view override returns (uint64) {\n        return _lastStakeBlock;\n    }\n\n    /// @return Number of active stakers currently staked\n    function stakerCount() public view override returns (uint64) {\n        return uint64(_stakerList.length);\n    }\n\n    /**\n     * @notice Initialize the core with an initial node\n     * @param initialNode Initial node to start the chain with\n     */\n    function initializeCore(Node memory initialNode) internal {\n        __Pausable_init();\n        _nodes[GENESIS_NODE] = initialNode;\n        _firstUnresolvedNode = GENESIS_NODE + 1;\n        if (_hostChainIsArbitrum) {\n            _nodeCreatedAtArbSysBlock[GENESIS_NODE] = ArbSys(address(100)).arbBlockNumber();\n        }\n    }\n\n    /**\n     * @notice React to a new node being created by storing it an incrementing the latest node counter\n     * @param node Node that was newly created\n     */\n    function nodeCreated(Node memory node) internal {\n        _latestNodeCreated++;\n        _nodes[_latestNodeCreated] = node;\n        if (_hostChainIsArbitrum) {\n            _nodeCreatedAtArbSysBlock[_latestNodeCreated] = ArbSys(address(100)).arbBlockNumber();\n        }\n    }\n\n    /// @notice Reject the next unresolved node\n    function _rejectNextNode() internal {\n        _firstUnresolvedNode++;\n    }\n\n    function confirmNode(\n        uint64 nodeNum,\n        bytes32 blockHash,\n        bytes32 sendRoot\n    ) internal {\n        Node storage node = getNodeStorage(nodeNum);\n        // Authenticate data against node's confirm data pre-image\n        require(node.confirmData == RollupLib.confirmHash(blockHash, sendRoot), \"CONFIRM_DATA\");\n\n        // trusted external call to outbox\n        outbox.updateSendRoot(sendRoot, blockHash);\n\n        _latestConfirmed = nodeNum;\n        _firstUnresolvedNode = nodeNum + 1;\n\n        emit NodeConfirmed(nodeNum, blockHash, sendRoot);\n    }\n\n    /**\n     * @notice Create a new stake at latest confirmed node\n     * @param stakerAddress Address of the new staker\n     * @param depositAmount Stake amount of the new staker\n     */\n    function createNewStake(address stakerAddress, uint256 depositAmount) internal {\n        uint64 stakerIndex = uint64(_stakerList.length);\n        _stakerList.push(stakerAddress);\n        _stakerMap[stakerAddress] = Staker(\n            depositAmount,\n            stakerIndex,\n            _latestConfirmed,\n            NO_CHAL_INDEX, // new staker is not in challenge\n            true\n        );\n        _nodeStakers[_latestConfirmed][stakerAddress] = true;\n        _lastStakeBlock = uint64(block.number);\n        emit UserStakeUpdated(stakerAddress, 0, depositAmount);\n    }\n\n    /**\n     * @notice Check to see whether the two stakers are in the same challenge\n     * @param stakerAddress1 Address of the first staker\n     * @param stakerAddress2 Address of the second staker\n     * @return Address of the challenge that the two stakers are in\n     */\n    function inChallenge(address stakerAddress1, address stakerAddress2)\n        internal\n        view\n        returns (uint64)\n    {\n        Staker storage staker1 = _stakerMap[stakerAddress1];\n        Staker storage staker2 = _stakerMap[stakerAddress2];\n        uint64 challenge = staker1.currentChallenge;\n        require(challenge != NO_CHAL_INDEX, \"NO_CHAL\");\n        require(challenge == staker2.currentChallenge, \"DIFF_IN_CHAL\");\n        return challenge;\n    }\n\n    /**\n     * @notice Make the given staker as not being in a challenge\n     * @param stakerAddress Address of the staker to remove from a challenge\n     */\n    function clearChallenge(address stakerAddress) internal {\n        Staker storage staker = _stakerMap[stakerAddress];\n        staker.currentChallenge = NO_CHAL_INDEX;\n    }\n\n    /**\n     * @notice Mark both the given stakers as engaged in the challenge\n     * @param staker1 Address of the first staker\n     * @param staker2 Address of the second staker\n     * @param challenge Address of the challenge both stakers are now in\n     */\n    function challengeStarted(\n        address staker1,\n        address staker2,\n        uint64 challenge\n    ) internal {\n        _stakerMap[staker1].currentChallenge = challenge;\n        _stakerMap[staker2].currentChallenge = challenge;\n    }\n\n    /**\n     * @notice Add to the stake of the given staker by the given amount\n     * @param stakerAddress Address of the staker to increase the stake of\n     * @param amountAdded Amount of stake to add to the staker\n     */\n    function increaseStakeBy(address stakerAddress, uint256 amountAdded) internal {\n        Staker storage staker = _stakerMap[stakerAddress];\n        uint256 initialStaked = staker.amountStaked;\n        uint256 finalStaked = initialStaked + amountAdded;\n        staker.amountStaked = finalStaked;\n        emit UserStakeUpdated(stakerAddress, initialStaked, finalStaked);\n    }\n\n    /**\n     * @notice Reduce the stake of the given staker to the given target\n     * @param stakerAddress Address of the staker to reduce the stake of\n     * @param target Amount of stake to leave with the staker\n     * @return Amount of value released from the stake\n     */\n    function reduceStakeTo(address stakerAddress, uint256 target) internal returns (uint256) {\n        Staker storage staker = _stakerMap[stakerAddress];\n        uint256 current = staker.amountStaked;\n        require(target <= current, \"TOO_LITTLE_STAKE\");\n        uint256 amountWithdrawn = current - target;\n        staker.amountStaked = target;\n        increaseWithdrawableFunds(stakerAddress, amountWithdrawn);\n        emit UserStakeUpdated(stakerAddress, current, target);\n        return amountWithdrawn;\n    }\n\n    /**\n     * @notice Remove the given staker and turn them into a zombie\n     * @param stakerAddress Address of the staker to remove\n     */\n    function turnIntoZombie(address stakerAddress) internal {\n        Staker storage staker = _stakerMap[stakerAddress];\n        _zombies.push(Zombie(stakerAddress, staker.latestStakedNode));\n        deleteStaker(stakerAddress);\n    }\n\n    /**\n     * @notice Update the latest staked node of the zombie at the given index\n     * @param zombieNum Index of the zombie to move\n     * @param latest New latest node the zombie is staked on\n     */\n    function zombieUpdateLatestStakedNode(uint256 zombieNum, uint64 latest) internal {\n        _zombies[zombieNum].latestStakedNode = latest;\n    }\n\n    /**\n     * @notice Remove the zombie at the given index\n     * @param zombieNum Index of the zombie to remove\n     */\n    function removeZombie(uint256 zombieNum) internal {\n        _zombies[zombieNum] = _zombies[_zombies.length - 1];\n        _zombies.pop();\n    }\n\n    /**\n     * @notice Mark the given staker as staked on this node\n     * @param staker Address of the staker to mark\n     */\n    function addStaker(uint64 nodeNum, address staker) internal {\n        require(!_nodeStakers[nodeNum][staker], \"ALREADY_STAKED\");\n        _nodeStakers[nodeNum][staker] = true;\n        Node storage node = getNodeStorage(nodeNum);\n        require(node.deadlineBlock != 0, \"NO_NODE\");\n\n        uint64 prevCount = node.stakerCount;\n        node.stakerCount = prevCount + 1;\n\n        if (nodeNum > GENESIS_NODE) {\n            Node storage parent = getNodeStorage(node.prevNum);\n            parent.childStakerCount++;\n            if (prevCount == 0) {\n                parent.newChildConfirmDeadline(uint64(block.number) + confirmPeriodBlocks);\n            }\n        }\n    }\n\n    /**\n     * @notice Remove the given staker from this node\n     * @param staker Address of the staker to remove\n     */\n    function removeStaker(uint64 nodeNum, address staker) internal {\n        require(_nodeStakers[nodeNum][staker], \"NOT_STAKED\");\n        _nodeStakers[nodeNum][staker] = false;\n\n        Node storage node = getNodeStorage(nodeNum);\n        node.stakerCount--;\n\n        if (nodeNum > GENESIS_NODE) {\n            getNodeStorage(node.prevNum).childStakerCount--;\n        }\n    }\n\n    /**\n     * @notice Remove the given staker and return their stake\n     * This should not be called if the staker is staked on a descendent of the latest confirmed node\n     * @param stakerAddress Address of the staker withdrawing their stake\n     */\n    function withdrawStaker(address stakerAddress) internal {\n        Staker storage staker = _stakerMap[stakerAddress];\n        uint64 latestConfirmedNum = latestConfirmed();\n        if (nodeHasStaker(latestConfirmedNum, stakerAddress)) {\n            // Withdrawing a staker whose latest staked node isn't resolved should be impossible\n            assert(staker.latestStakedNode == latestConfirmedNum);\n            removeStaker(latestConfirmedNum, stakerAddress);\n        }\n        uint256 initialStaked = staker.amountStaked;\n        increaseWithdrawableFunds(stakerAddress, initialStaked);\n        deleteStaker(stakerAddress);\n        emit UserStakeUpdated(stakerAddress, initialStaked, 0);\n    }\n\n    /**\n     * @notice Advance the given staker to the given node\n     * @param stakerAddress Address of the staker adding their stake\n     * @param nodeNum Index of the node to stake on\n     */\n    function stakeOnNode(address stakerAddress, uint64 nodeNum) internal {\n        Staker storage staker = _stakerMap[stakerAddress];\n        addStaker(nodeNum, stakerAddress);\n        staker.latestStakedNode = nodeNum;\n    }\n\n    /**\n     * @notice Clear the withdrawable funds for the given address\n     * @param account Address of the account to remove funds from\n     * @return Amount of funds removed from account\n     */\n    function withdrawFunds(address account) internal returns (uint256) {\n        uint256 amount = _withdrawableFunds[account];\n        _withdrawableFunds[account] = 0;\n        totalWithdrawableFunds -= amount;\n        emit UserWithdrawableFundsUpdated(account, amount, 0);\n        return amount;\n    }\n\n    /**\n     * @notice Increase the withdrawable funds for the given address\n     * @param account Address of the account to add withdrawable funds to\n     */\n    function increaseWithdrawableFunds(address account, uint256 amount) internal {\n        uint256 initialWithdrawable = _withdrawableFunds[account];\n        uint256 finalWithdrawable = initialWithdrawable + amount;\n        _withdrawableFunds[account] = finalWithdrawable;\n        totalWithdrawableFunds += amount;\n        emit UserWithdrawableFundsUpdated(account, initialWithdrawable, finalWithdrawable);\n    }\n\n    /**\n     * @notice Remove the given staker\n     * @param stakerAddress Address of the staker to remove\n     */\n    function deleteStaker(address stakerAddress) private {\n        Staker storage staker = _stakerMap[stakerAddress];\n        require(staker.isStaked, \"NOT_STAKED\");\n        uint64 stakerIndex = staker.index;\n        _stakerList[stakerIndex] = _stakerList[_stakerList.length - 1];\n        _stakerMap[_stakerList[stakerIndex]].index = stakerIndex;\n        _stakerList.pop();\n        delete _stakerMap[stakerAddress];\n    }\n\n    struct StakeOnNewNodeFrame {\n        uint256 currentInboxSize;\n        Node node;\n        bytes32 executionHash;\n        Node prevNode;\n        bytes32 lastHash;\n        bool hasSibling;\n        uint64 deadlineBlock;\n        bytes32 sequencerBatchAcc;\n    }\n\n    function createNewNode(\n        Assertion calldata assertion,\n        uint64 prevNodeNum,\n        uint256 prevNodeInboxMaxCount,\n        bytes32 expectedNodeHash\n    ) internal returns (bytes32 newNodeHash) {\n        require(\n            assertion.afterState.machineStatus == MachineStatus.FINISHED ||\n                assertion.afterState.machineStatus == MachineStatus.ERRORED,\n            \"BAD_AFTER_STATUS\"\n        );\n\n        StakeOnNewNodeFrame memory memoryFrame;\n        {\n            // validate data\n            memoryFrame.prevNode = getNode(prevNodeNum);\n            memoryFrame.currentInboxSize = bridge.sequencerMessageCount();\n\n            // Make sure the previous state is correct against the node being built on\n            require(\n                RollupLib.stateHash(assertion.beforeState, prevNodeInboxMaxCount) ==\n                    memoryFrame.prevNode.stateHash,\n                \"PREV_STATE_HASH\"\n            );\n\n            // Ensure that the assertion doesn't read past the end of the current inbox\n            uint64 afterInboxCount = assertion.afterState.globalState.getInboxPosition();\n            uint64 prevInboxPosition = assertion.beforeState.globalState.getInboxPosition();\n            require(afterInboxCount >= prevInboxPosition, \"INBOX_BACKWARDS\");\n            if (afterInboxCount == prevInboxPosition) {\n                require(\n                    assertion.afterState.globalState.getPositionInMessage() >=\n                        assertion.beforeState.globalState.getPositionInMessage(),\n                    \"INBOX_POS_IN_MSG_BACKWARDS\"\n                );\n            }\n            // See validator/assertion.go ExecutionState RequiredBatches() for reasoning\n            if (\n                assertion.afterState.machineStatus == MachineStatus.ERRORED ||\n                assertion.afterState.globalState.getPositionInMessage() > 0\n            ) {\n                // The current inbox message was read\n                afterInboxCount++;\n            }\n            require(afterInboxCount <= memoryFrame.currentInboxSize, \"INBOX_PAST_END\");\n            // This gives replay protection against the state of the inbox\n            if (afterInboxCount > 0) {\n                memoryFrame.sequencerBatchAcc = bridge.sequencerInboxAccs(afterInboxCount - 1);\n            }\n        }\n\n        {\n            memoryFrame.executionHash = RollupLib.executionHash(assertion);\n\n            memoryFrame.deadlineBlock = uint64(block.number) + confirmPeriodBlocks;\n\n            memoryFrame.hasSibling = memoryFrame.prevNode.latestChildNumber > 0;\n            // here we don't use ternacy operator to remain compatible with slither\n            if (memoryFrame.hasSibling) {\n                memoryFrame.lastHash = getNodeStorage(memoryFrame.prevNode.latestChildNumber)\n                    .nodeHash;\n            } else {\n                memoryFrame.lastHash = memoryFrame.prevNode.nodeHash;\n            }\n\n            newNodeHash = RollupLib.nodeHash(\n                memoryFrame.hasSibling,\n                memoryFrame.lastHash,\n                memoryFrame.executionHash,\n                memoryFrame.sequencerBatchAcc,\n                wasmModuleRoot\n            );\n            require(\n                newNodeHash == expectedNodeHash || expectedNodeHash == bytes32(0),\n                \"UNEXPECTED_NODE_HASH\"\n            );\n\n            memoryFrame.node = NodeLib.createNode(\n                RollupLib.stateHash(assertion.afterState, memoryFrame.currentInboxSize),\n                RollupLib.challengeRootHash(\n                    memoryFrame.executionHash,\n                    block.number,\n                    wasmModuleRoot\n                ),\n                RollupLib.confirmHash(assertion),\n                prevNodeNum,\n                memoryFrame.deadlineBlock,\n                newNodeHash\n            );\n        }\n\n        {\n            uint64 nodeNum = latestNodeCreated() + 1;\n\n            // Fetch a storage reference to prevNode since we copied our other one into memory\n            // and we don't have enough stack available to keep to keep the previous storage reference around\n            Node storage prevNode = getNodeStorage(prevNodeNum);\n            prevNode.childCreated(nodeNum);\n\n            nodeCreated(memoryFrame.node);\n        }\n\n        emit NodeCreated(\n            latestNodeCreated(),\n            memoryFrame.prevNode.nodeHash,\n            newNodeHash,\n            memoryFrame.executionHash,\n            assertion,\n            memoryFrame.sequencerBatchAcc,\n            wasmModuleRoot,\n            memoryFrame.currentInboxSize\n        );\n\n        return newNodeHash;\n    }\n}\n"}, "src/rollup/RollupCreator.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./RollupProxy.sol\";\nimport \"./IRollupAdmin.sol\";\nimport \"./BridgeCreator.sol\";\nimport \"@offchainlabs/upgrade-executor/src/IUpgradeExecutor.sol\";\nimport \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {DeployHelper} from \"./DeployHelper.sol\";\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract RollupCreator is Ownable {\n    using SafeERC20 for IERC20;\n\n    event RollupCreated(\n        address indexed rollupAddress,\n        address indexed nativeToken,\n        address inboxAddress,\n        address outbox,\n        address rollupEventInbox,\n        address challengeManager,\n        address adminProxy,\n        address sequencerInbox,\n        address bridge,\n        address upgradeExecutor,\n        address validatorUtils,\n        address validatorWalletCreator\n    );\n    event TemplatesUpdated();\n\n    struct RollupDeploymentParams {\n        Config config;\n        address[] validators;\n        uint256 maxDataSize;\n        address nativeToken;\n        bool deployFactoriesToL2;\n        uint256 maxFeePerGasForRetryables;\n        //// @dev The address of the batch poster, not used when set to zero address\n        address[] batchPosters;\n        address batchPosterManager;\n    }\n\n    BridgeCreator public bridgeCreator;\n    IOneStepProofEntry public osp;\n    IChallengeManager public challengeManagerTemplate;\n    IRollupAdmin public rollupAdminLogic;\n    IRollupUser public rollupUserLogic;\n    IUpgradeExecutor public upgradeExecutorLogic;\n\n    address public validatorUtils;\n    address public validatorWalletCreator;\n\n    DeployHelper public l2FactoriesDeployer;\n\n    constructor() Ownable() {}\n\n    // creator receives back excess fees (for deploying L2 factories) so it can refund the caller\n    receive() external payable {}\n\n    function setTemplates(\n        BridgeCreator _bridgeCreator,\n        IOneStepProofEntry _osp,\n        IChallengeManager _challengeManagerLogic,\n        IRollupAdmin _rollupAdminLogic,\n        IRollupUser _rollupUserLogic,\n        IUpgradeExecutor _upgradeExecutorLogic,\n        address _validatorUtils,\n        address _validatorWalletCreator,\n        DeployHelper _l2FactoriesDeployer\n    ) external onlyOwner {\n        bridgeCreator = _bridgeCreator;\n        osp = _osp;\n        challengeManagerTemplate = _challengeManagerLogic;\n        rollupAdminLogic = _rollupAdminLogic;\n        rollupUserLogic = _rollupUserLogic;\n        upgradeExecutorLogic = _upgradeExecutorLogic;\n        validatorUtils = _validatorUtils;\n        validatorWalletCreator = _validatorWalletCreator;\n        l2FactoriesDeployer = _l2FactoriesDeployer;\n        emit TemplatesUpdated();\n    }\n\n    /**\n     * @notice Create a new rollup\n     * @dev After this setup:\n     * @dev - UpgradeExecutor should be the owner of rollup\n     * @dev - UpgradeExecutor should be the owner of proxyAdmin which manages bridge contracts\n     * @dev - config.rollupOwner should have executor role on upgradeExecutor\n     * @dev - Bridge should have a single inbox and outbox\n     * @dev - Validators and batch poster should be set if provided\n     * @param deployParams The parameters for the rollup deployment. It consists of:\n     *          - config        The configuration for the rollup\n     *          - batchPoster   The address of the batch poster, not used when set to zero address\n     *          - validators    The list of validator addresses, not used when set to empty list\n     *          - nativeToken   Address of the custom fee token used by rollup. If rollup is ETH-based address(0) should be provided\n     *          - deployFactoriesToL2 Whether to deploy L2 factories using retryable tickets. If true, retryables need to be paid for in native currency.\n     *                          Deploying factories via retryable tickets at rollup creation time is the most reliable method to do it since it\n     *                          doesn't require paying the L1 gas. If deployment is not done as part of rollup creation TX, there is a risk that\n     *                          anyone can try to deploy factories and potentially burn the nonce 0 (ie. due to gas price spike when doing direct\n     *                          L2 TX). That would mean we permanently lost capability to deploy deterministic factory at expected address.\n     *          - maxFeePerGasForRetryables price bid for L2 execution.\n     *          - dataHashReader The address of the data hash reader used to read blob hashes\n     * @return The address of the newly created rollup\n     */\n    function createRollup(RollupDeploymentParams memory deployParams)\n        public\n        payable\n        returns (address)\n    {\n        {\n            // Make sure the immutable maxDataSize is as expected\n            (, ISequencerInbox ethSequencerInbox, IInboxBase ethInbox, , ) = bridgeCreator\n                .ethBasedTemplates();\n            require(\n                deployParams.maxDataSize == ethSequencerInbox.maxDataSize(),\n                \"SI_MAX_DATA_SIZE_MISMATCH\"\n            );\n            require(deployParams.maxDataSize == ethInbox.maxDataSize(), \"I_MAX_DATA_SIZE_MISMATCH\");\n\n            (, ISequencerInbox erc20SequencerInbox, IInboxBase erc20Inbox, , ) = bridgeCreator\n                .erc20BasedTemplates();\n            require(\n                deployParams.maxDataSize == erc20SequencerInbox.maxDataSize(),\n                \"SI_MAX_DATA_SIZE_MISMATCH\"\n            );\n            require(\n                deployParams.maxDataSize == erc20Inbox.maxDataSize(),\n                \"I_MAX_DATA_SIZE_MISMATCH\"\n            );\n        }\n\n        // create proxy admin which will manage bridge contracts\n        ProxyAdmin proxyAdmin = new ProxyAdmin();\n\n        // Create the rollup proxy to figure out the address and initialize it later\n        RollupProxy rollup = new RollupProxy{salt: keccak256(abi.encode(deployParams))}();\n\n        BridgeCreator.BridgeContracts memory bridgeContracts = bridgeCreator.createBridge(\n            address(proxyAdmin),\n            address(rollup),\n            deployParams.nativeToken,\n            deployParams.config.sequencerInboxMaxTimeVariation\n        );\n\n        IChallengeManager challengeManager = IChallengeManager(\n            address(\n                new TransparentUpgradeableProxy(\n                    address(challengeManagerTemplate),\n                    address(proxyAdmin),\n                    \"\"\n                )\n            )\n        );\n        challengeManager.initialize(\n            IChallengeResultReceiver(address(rollup)),\n            bridgeContracts.sequencerInbox,\n            bridgeContracts.bridge,\n            osp\n        );\n\n        // deploy and init upgrade executor\n        address upgradeExecutor = _deployUpgradeExecutor(deployParams.config.owner, proxyAdmin);\n\n        // upgradeExecutor shall be proxyAdmin's owner\n        proxyAdmin.transferOwnership(address(upgradeExecutor));\n\n        // initialize the rollup with this contract as owner to set batch poster and validators\n        // it will transfer the ownership to the upgrade executor later\n        deployParams.config.owner = address(this);\n        rollup.initializeProxy(\n            deployParams.config,\n            ContractDependencies({\n                bridge: bridgeContracts.bridge,\n                sequencerInbox: bridgeContracts.sequencerInbox,\n                inbox: bridgeContracts.inbox,\n                outbox: bridgeContracts.outbox,\n                rollupEventInbox: bridgeContracts.rollupEventInbox,\n                challengeManager: challengeManager,\n                rollupAdminLogic: address(rollupAdminLogic),\n                rollupUserLogic: rollupUserLogic,\n                validatorUtils: validatorUtils,\n                validatorWalletCreator: validatorWalletCreator\n            })\n        );\n\n        // Setting batch posters and batch poster manager\n        for (uint256 i = 0; i < deployParams.batchPosters.length; i++) {\n            bridgeContracts.sequencerInbox.setIsBatchPoster(deployParams.batchPosters[i], true);\n        }\n        if (deployParams.batchPosterManager != address(0)) {\n            bridgeContracts.sequencerInbox.setBatchPosterManager(deployParams.batchPosterManager);\n        }\n\n        // Call setValidator on the newly created rollup contract just if validator set is not empty\n        if (deployParams.validators.length != 0) {\n            bool[] memory _vals = new bool[](deployParams.validators.length);\n            for (uint256 i = 0; i < deployParams.validators.length; i++) {\n                _vals[i] = true;\n            }\n            IRollupAdmin(address(rollup)).setValidator(deployParams.validators, _vals);\n        }\n\n        IRollupAdmin(address(rollup)).setOwner(address(upgradeExecutor));\n\n        if (deployParams.deployFactoriesToL2) {\n            _deployFactories(\n                address(bridgeContracts.inbox),\n                deployParams.nativeToken,\n                deployParams.maxFeePerGasForRetryables\n            );\n        }\n\n        emit RollupCreated(\n            address(rollup),\n            deployParams.nativeToken,\n            address(bridgeContracts.inbox),\n            address(bridgeContracts.outbox),\n            address(bridgeContracts.rollupEventInbox),\n            address(challengeManager),\n            address(proxyAdmin),\n            address(bridgeContracts.sequencerInbox),\n            address(bridgeContracts.bridge),\n            address(upgradeExecutor),\n            address(validatorUtils),\n            address(validatorWalletCreator)\n        );\n        return address(rollup);\n    }\n\n    function _deployUpgradeExecutor(address rollupOwner, ProxyAdmin proxyAdmin)\n        internal\n        returns (address)\n    {\n        IUpgradeExecutor upgradeExecutor = IUpgradeExecutor(\n            address(\n                new TransparentUpgradeableProxy(\n                    address(upgradeExecutorLogic),\n                    address(proxyAdmin),\n                    bytes(\"\")\n                )\n            )\n        );\n        address[] memory executors = new address[](1);\n        executors[0] = rollupOwner;\n        upgradeExecutor.initialize(address(upgradeExecutor), executors);\n\n        return address(upgradeExecutor);\n    }\n\n    function _deployFactories(\n        address _inbox,\n        address _nativeToken,\n        uint256 _maxFeePerGas\n    ) internal {\n        if (_nativeToken == address(0)) {\n            // we need to fund 4 retryable tickets\n            uint256 cost = l2FactoriesDeployer.getDeploymentTotalCost(\n                IInboxBase(_inbox),\n                _maxFeePerGas\n            );\n\n            // do it\n            l2FactoriesDeployer.perform{value: cost}(_inbox, _nativeToken, _maxFeePerGas);\n\n            // refund the caller\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool sent, ) = msg.sender.call{value: address(this).balance}(\"\");\n            require(sent, \"Refund failed\");\n        } else {\n            // Transfer fee token amount needed to pay for retryable fees to the inbox.\n            uint256 totalFee = l2FactoriesDeployer.getDeploymentTotalCost(\n                IInboxBase(_inbox),\n                _maxFeePerGas\n            );\n\n            // calculate the fee amount in the native token's decimals\n            uint8 decimals = ERC20(_nativeToken).decimals();\n\n            uint256 totalFeeNativeDenominated = totalFee;\n            if (decimals < 18) {\n                uint256 gasCost = _maxFeePerGas * 21_000;\n                uint256 nickCreate2Cost = _scaleDownToNativeDecimals(\n                    l2FactoriesDeployer.NICK_CREATE2_VALUE() + gasCost,\n                    decimals\n                );\n                uint256 erc2470Cost = _scaleDownToNativeDecimals(\n                    l2FactoriesDeployer.ERC2470_VALUE() + gasCost,\n                    decimals\n                );\n                uint256 zoltuCreate2Cost = _scaleDownToNativeDecimals(\n                    l2FactoriesDeployer.ZOLTU_VALUE() + gasCost,\n                    decimals\n                );\n                uint256 erc1820Cost = _scaleDownToNativeDecimals(\n                    l2FactoriesDeployer.ERC1820_VALUE() + gasCost,\n                    decimals\n                );\n                totalFeeNativeDenominated =\n                    nickCreate2Cost +\n                    erc2470Cost +\n                    zoltuCreate2Cost +\n                    erc1820Cost;\n            } else if (decimals > 18) {\n                totalFeeNativeDenominated = totalFee * (10**(decimals - 18));\n            }\n\n            IERC20(_nativeToken).safeTransferFrom(msg.sender, _inbox, totalFeeNativeDenominated);\n\n            // do it\n            l2FactoriesDeployer.perform(_inbox, _nativeToken, _maxFeePerGas);\n        }\n    }\n\n    function _scaleDownToNativeDecimals(uint256 amount, uint8 decimals)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 scaledAmount = amount;\n        if (decimals < 18) {\n            scaledAmount = amount / (10**(18 - decimals));\n            // round up if necessary\n            if (scaledAmount * (10**(18 - decimals)) < amount) {\n                scaledAmount++;\n            }\n        }\n        return scaledAmount;\n    }\n}\n"}, "src/rollup/RollupEventInbox.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./AbsRollupEventInbox.sol\";\nimport \"../bridge/IEthBridge.sol\";\n\n/**\n * @title The inbox for rollup protocol events\n */\ncontract RollupEventInbox is AbsRollupEventInbox {\n    constructor() AbsRollupEventInbox() {}\n\n    function _enqueueInitializationMsg(bytes memory initMsg) internal override returns (uint256) {\n        return\n            IEthBridge(address(bridge)).enqueueDelayedMessage(\n                INITIALIZATION_MSG_TYPE,\n                address(0),\n                keccak256(initMsg)\n            );\n    }\n\n    function _currentDataCostToReport() internal view override returns (uint256) {\n        uint256 currentDataCost = block.basefee;\n        if (ArbitrumChecker.runningOnArbitrum()) {\n            currentDataCost += ArbGasInfo(address(0x6c)).getL1BaseFeeEstimate();\n        }\n        return currentDataCost;\n    }\n}\n"}, "src/rollup/RollupLib.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../challenge/IChallengeManager.sol\";\nimport \"../challenge/ChallengeLib.sol\";\nimport \"../state/GlobalState.sol\";\nimport \"../bridge/ISequencerInbox.sol\";\n\nimport \"../bridge/IBridge.sol\";\nimport \"../bridge/IOutbox.sol\";\nimport \"../bridge/IInboxBase.sol\";\nimport \"./Node.sol\";\nimport \"./IRollupEventInbox.sol\";\n\nlibrary RollupLib {\n    using GlobalStateLib for GlobalState;\n\n    function stateHash(ExecutionState calldata execState, uint256 inboxMaxCount)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encodePacked(\n                    execState.globalState.hash(),\n                    inboxMaxCount,\n                    execState.machineStatus\n                )\n            );\n    }\n\n    /// @dev same as stateHash but expects execState in memory instead of calldata\n    function stateHashMem(ExecutionState memory execState, uint256 inboxMaxCount)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encodePacked(\n                    execState.globalState.hash(),\n                    inboxMaxCount,\n                    execState.machineStatus\n                )\n            );\n    }\n\n    function executionHash(Assertion memory assertion) internal pure returns (bytes32) {\n        MachineStatus[2] memory statuses;\n        statuses[0] = assertion.beforeState.machineStatus;\n        statuses[1] = assertion.afterState.machineStatus;\n        GlobalState[2] memory globalStates;\n        globalStates[0] = assertion.beforeState.globalState;\n        globalStates[1] = assertion.afterState.globalState;\n        // TODO: benchmark how much this abstraction adds of gas overhead\n        return executionHash(statuses, globalStates, assertion.numBlocks);\n    }\n\n    function executionHash(\n        MachineStatus[2] memory statuses,\n        GlobalState[2] memory globalStates,\n        uint64 numBlocks\n    ) internal pure returns (bytes32) {\n        bytes32[] memory segments = new bytes32[](2);\n        segments[0] = ChallengeLib.blockStateHash(statuses[0], globalStates[0].hash());\n        segments[1] = ChallengeLib.blockStateHash(statuses[1], globalStates[1].hash());\n        return ChallengeLib.hashChallengeState(0, numBlocks, segments);\n    }\n\n    function challengeRootHash(\n        bytes32 execution,\n        uint256 proposedTime,\n        bytes32 wasmModuleRoot\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(execution, proposedTime, wasmModuleRoot));\n    }\n\n    function confirmHash(Assertion memory assertion) internal pure returns (bytes32) {\n        return\n            confirmHash(\n                assertion.afterState.globalState.getBlockHash(),\n                assertion.afterState.globalState.getSendRoot()\n            );\n    }\n\n    function confirmHash(bytes32 blockHash, bytes32 sendRoot) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(blockHash, sendRoot));\n    }\n\n    function nodeHash(\n        bool hasSibling,\n        bytes32 lastHash,\n        bytes32 assertionExecHash,\n        bytes32 inboxAcc,\n        bytes32 wasmModuleRoot\n    ) internal pure returns (bytes32) {\n        uint8 hasSiblingInt = hasSibling ? 1 : 0;\n        return\n            keccak256(\n                abi.encodePacked(\n                    hasSiblingInt,\n                    lastHash,\n                    assertionExecHash,\n                    inboxAcc,\n                    wasmModuleRoot\n                )\n            );\n    }\n}\n"}, "src/rollup/RollupProxy.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../libraries/AdminFallbackProxy.sol\";\nimport \"./IRollupAdmin.sol\";\nimport \"./Config.sol\";\n\ncontract RollupProxy is AdminFallbackProxy {\n    function initializeProxy(Config memory config, ContractDependencies memory connectedContracts)\n        external\n    {\n        if (\n            _getAdmin() == address(0) &&\n            _getImplementation() == address(0) &&\n            _getSecondaryImplementation() == address(0)\n        ) {\n            _initialize(\n                address(connectedContracts.rollupAdminLogic),\n                abi.encodeWithSelector(\n                    IRollupAdmin.initialize.selector,\n                    config,\n                    connectedContracts\n                ),\n                address(connectedContracts.rollupUserLogic),\n                abi.encodeWithSelector(IRollupUserAbs.initialize.selector, config.stakeToken),\n                config.owner\n            );\n        } else {\n            _fallback();\n        }\n    }\n}\n"}, "src/rollup/ValidatorUtils.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\npragma experimental ABIEncoderV2;\n\nimport \"../rollup/IRollupCore.sol\";\nimport \"../challenge/IChallengeManager.sol\";\nimport \"./IRollupLogic.sol\";\n\nimport {NO_CHAL_INDEX} from \"../libraries/Constants.sol\";\n\ncontract ValidatorUtils {\n    using NodeLib for Node;\n\n    enum ConfirmType {\n        NONE,\n        VALID,\n        INVALID\n    }\n\n    enum NodeConflictType {\n        NONE,\n        FOUND,\n        INDETERMINATE,\n        INCOMPLETE\n    }\n\n    struct NodeConflict {\n        NodeConflictType ty;\n        uint64 node1;\n        uint64 node2;\n    }\n\n    function findStakerConflict(\n        IRollupCore rollup,\n        address staker1,\n        address staker2,\n        uint256 maxDepth\n    ) external view returns (NodeConflict memory) {\n        uint64 staker1NodeNum = rollup.latestStakedNode(staker1);\n        uint64 staker2NodeNum = rollup.latestStakedNode(staker2);\n        return findNodeConflict(rollup, staker1NodeNum, staker2NodeNum, maxDepth);\n    }\n\n    function checkDecidableNextNode(IRollupUserAbs rollup) external view returns (ConfirmType) {\n        try ValidatorUtils(address(this)).requireConfirmable(rollup) {\n            return ConfirmType.VALID;\n        } catch {}\n\n        try ValidatorUtils(address(this)).requireRejectable(rollup) {\n            return ConfirmType.INVALID;\n        } catch {\n            return ConfirmType.NONE;\n        }\n    }\n\n    function requireRejectable(IRollupCore rollup) external view {\n        IRollupUser(address(rollup)).requireUnresolvedExists();\n        uint64 firstUnresolvedNode = rollup.firstUnresolvedNode();\n        Node memory node = rollup.getNode(firstUnresolvedNode);\n        if (node.prevNum == rollup.latestConfirmed()) {\n            // Verify the block's deadline has passed\n            require(block.number >= node.deadlineBlock, \"BEFORE_DEADLINE\");\n            rollup.getNode(node.prevNum).requirePastChildConfirmDeadline();\n\n            // Verify that no staker is staked on this node\n            require(\n                node.stakerCount ==\n                    IRollupUser(address(rollup)).countStakedZombies(firstUnresolvedNode),\n                \"HAS_STAKERS\"\n            );\n        }\n    }\n\n    function requireConfirmable(IRollupUserAbs rollup) external view {\n        rollup.requireUnresolvedExists();\n\n        uint256 stakerCount = rollup.stakerCount();\n        // There is at least one non-zombie staker\n        require(stakerCount > 0, \"NO_STAKERS\");\n\n        uint64 firstUnresolved = rollup.firstUnresolvedNode();\n        Node memory node = rollup.getNode(firstUnresolved);\n\n        // Verify the block's deadline has passed\n        node.requirePastDeadline();\n\n        // Check that prev is latest confirmed\n        assert(node.prevNum == rollup.latestConfirmed());\n\n        Node memory prevNode = rollup.getNode(node.prevNum);\n        prevNode.requirePastChildConfirmDeadline();\n\n        uint256 zombiesStakedOnOtherChildren = rollup.countZombiesStakedOnChildren(node.prevNum) -\n            rollup.countStakedZombies(firstUnresolved);\n        require(\n            prevNode.childStakerCount == node.stakerCount + zombiesStakedOnOtherChildren,\n            \"NOT_ALL_STAKED\"\n        );\n    }\n\n    function refundableStakers(IRollupCore rollup) external view returns (address[] memory) {\n        uint256 stakerCount = rollup.stakerCount();\n        address[] memory stakers = new address[](stakerCount);\n        uint256 latestConfirmed = rollup.latestConfirmed();\n        uint256 index = 0;\n        for (uint64 i = 0; i < stakerCount; i++) {\n            address staker = rollup.getStakerAddress(i);\n            uint256 latestStakedNode = rollup.latestStakedNode(staker);\n            if (latestStakedNode <= latestConfirmed && rollup.currentChallenge(staker) == 0) {\n                stakers[index] = staker;\n                index++;\n            }\n        }\n        assembly {\n            mstore(stakers, index)\n        }\n        return stakers;\n    }\n\n    function latestStaked(IRollupCore rollup, address staker)\n        external\n        view\n        returns (uint64, Node memory)\n    {\n        uint64 num = rollup.latestStakedNode(staker);\n        if (num == 0) {\n            num = rollup.latestConfirmed();\n        }\n        Node memory node = rollup.getNode(num);\n        return (num, node);\n    }\n\n    function stakedNodes(IRollupCore rollup, address staker)\n        external\n        view\n        returns (uint64[] memory)\n    {\n        uint64[] memory nodes = new uint64[](100000);\n        uint256 index = 0;\n        for (uint64 i = rollup.latestConfirmed(); i <= rollup.latestNodeCreated(); i++) {\n            if (rollup.nodeHasStaker(i, staker)) {\n                nodes[index] = i;\n                index++;\n            }\n        }\n        // Shrink array down to real size\n        assembly {\n            mstore(nodes, index)\n        }\n        return nodes;\n    }\n\n    function findNodeConflict(\n        IRollupCore rollup,\n        uint64 node1,\n        uint64 node2,\n        uint256 maxDepth\n    ) public view returns (NodeConflict memory) {\n        uint64 firstUnresolvedNode = rollup.firstUnresolvedNode();\n        uint64 node1Prev = rollup.getNode(node1).prevNum;\n        uint64 node2Prev = rollup.getNode(node2).prevNum;\n\n        for (uint256 i = 0; i < maxDepth; i++) {\n            if (node1 == node2) {\n                return NodeConflict(NodeConflictType.NONE, node1, node2);\n            }\n            if (node1Prev == node2Prev) {\n                return NodeConflict(NodeConflictType.FOUND, node1, node2);\n            }\n            if (node1Prev < firstUnresolvedNode && node2Prev < firstUnresolvedNode) {\n                return NodeConflict(NodeConflictType.INDETERMINATE, 0, 0);\n            }\n            if (node1Prev < node2Prev) {\n                node2 = node2Prev;\n                node2Prev = rollup.getNode(node2).prevNum;\n            } else {\n                node1 = node1Prev;\n                node1Prev = rollup.getNode(node1).prevNum;\n            }\n        }\n        return NodeConflict(NodeConflictType.INCOMPLETE, 0, 0);\n    }\n\n    function getStakers(\n        IRollupCore rollup,\n        uint64 startIndex,\n        uint64 max\n    ) public view returns (address[] memory, bool hasMore) {\n        uint256 maxStakers = rollup.stakerCount();\n        if (startIndex + max <= maxStakers) {\n            maxStakers = startIndex + max;\n            hasMore = true;\n        }\n\n        address[] memory stakers = new address[](maxStakers);\n        for (uint64 i = 0; i < maxStakers; i++) {\n            stakers[i] = rollup.getStakerAddress(startIndex + i);\n        }\n        return (stakers, hasMore);\n    }\n\n    function timedOutChallenges(\n        IRollupCore rollup,\n        uint64 startIndex,\n        uint64 max\n    ) external view returns (uint64[] memory, bool hasMore) {\n        (address[] memory stakers, bool hasMoreStakers) = getStakers(rollup, startIndex, max);\n        uint64[] memory challenges = new uint64[](stakers.length);\n        uint256 index = 0;\n        IChallengeManager challengeManager = rollup.challengeManager();\n        for (uint256 i = 0; i < stakers.length; i++) {\n            address staker = stakers[i];\n            uint64 challengeIndex = rollup.currentChallenge(staker);\n            if (\n                challengeIndex != NO_CHAL_INDEX &&\n                challengeManager.isTimedOut(challengeIndex) &&\n                challengeManager.currentResponder(challengeIndex) == staker\n            ) {\n                challenges[index++] = challengeIndex;\n            }\n        }\n        // Shrink array down to real size\n        assembly {\n            mstore(challenges, index)\n        }\n        return (challenges, hasMoreStakers);\n    }\n\n    // Worst case runtime of O(depth), as it terminates if it switches paths.\n    function areUnresolvedNodesLinear(IRollupCore rollup) external view returns (bool) {\n        uint256 end = rollup.latestNodeCreated();\n        for (uint64 i = rollup.firstUnresolvedNode(); i <= end; i++) {\n            if (i > 0 && rollup.getNode(i).prevNum != i - 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}, "src/rollup/ValidatorWallet.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../challenge/IChallengeManager.sol\";\nimport \"../libraries/DelegateCallAware.sol\";\nimport \"../libraries/IGasRefunder.sol\";\nimport \"../libraries/GasRefundEnabled.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/// @dev thrown when arrays provided don't have the expected length\nerror BadArrayLength(uint256 expected, uint256 actual);\n\n/// @dev thrown when a function is called by an address that isn't the owner nor a executor\nerror NotExecutorOrOwner(address actual);\n\n/// @dev thrown when the particular address can't be called by an executor\nerror OnlyOwnerDestination(address expected, address actual, address destination);\n\n/// @dev thrown when eth withdrawal tx fails\nerror WithdrawEthFail(address destination);\n\ncontract ValidatorWallet is OwnableUpgradeable, DelegateCallAware, GasRefundEnabled {\n    using Address for address;\n\n    /// @dev a executor is allowed to call only certain contracts\n    mapping(address => bool) public executors;\n\n    /// @dev allowed addresses which can be called by an executor\n    mapping(address => bool) public allowedExecutorDestinations;\n\n    modifier onlyExecutorOrOwner() {\n        if (!executors[_msgSender()] && owner() != _msgSender())\n            revert NotExecutorOrOwner(_msgSender());\n        _;\n    }\n\n    event ExecutorUpdated(address indexed executor, bool isExecutor);\n\n    /// @dev updates the executor addresses\n    function setExecutor(address[] calldata newExecutors, bool[] calldata isExecutor)\n        external\n        onlyOwner\n    {\n        if (newExecutors.length != isExecutor.length)\n            revert BadArrayLength(newExecutors.length, isExecutor.length);\n        unchecked {\n            for (uint64 i = 0; i < newExecutors.length; ++i) {\n                executors[newExecutors[i]] = isExecutor[i];\n                emit ExecutorUpdated(newExecutors[i], isExecutor[i]);\n            }\n        }\n    }\n\n    function initialize(\n        address _executor,\n        address _owner,\n        address[] calldata initialExecutorAllowedDests\n    ) external initializer onlyDelegated {\n        __Ownable_init();\n        transferOwnership(_owner);\n\n        executors[_executor] = true;\n        emit ExecutorUpdated(_executor, true);\n\n        unchecked {\n            for (uint64 i = 0; i < initialExecutorAllowedDests.length; ++i) {\n                allowedExecutorDestinations[initialExecutorAllowedDests[i]] = true;\n                emit AllowedExecutorDestinationsUpdated(initialExecutorAllowedDests[i], true);\n            }\n        }\n    }\n\n    event AllowedExecutorDestinationsUpdated(address indexed destination, bool isSet);\n\n    /// @notice updates the destination addresses which executors are allowed to call\n    function setAllowedExecutorDestinations(address[] calldata destinations, bool[] calldata isSet)\n        external\n        onlyOwner\n    {\n        if (destinations.length != isSet.length)\n            revert BadArrayLength(destinations.length, isSet.length);\n        unchecked {\n            for (uint256 i = 0; i < destinations.length; ++i) {\n                allowedExecutorDestinations[destinations[i]] = isSet[i];\n                emit AllowedExecutorDestinationsUpdated(destinations[i], isSet[i]);\n            }\n        }\n    }\n\n    /// @dev reverts if the current function can't be called\n    function validateExecuteTransaction(address destination) public view {\n        if (!allowedExecutorDestinations[destination] && owner() != _msgSender())\n            revert OnlyOwnerDestination(owner(), _msgSender(), destination);\n    }\n\n    function executeTransactions(\n        bytes[] calldata data,\n        address[] calldata destination,\n        uint256[] calldata amount\n    ) external payable {\n        executeTransactionsWithGasRefunder(IGasRefunder(address(0)), data, destination, amount);\n    }\n\n    function executeTransactionsWithGasRefunder(\n        IGasRefunder gasRefunder,\n        bytes[] calldata data,\n        address[] calldata destination,\n        uint256[] calldata amount\n    ) public payable onlyExecutorOrOwner refundsGas(gasRefunder, IReader4844(address(0))) {\n        uint256 numTxes = data.length;\n        if (numTxes != destination.length) revert BadArrayLength(numTxes, destination.length);\n        if (numTxes != amount.length) revert BadArrayLength(numTxes, amount.length);\n\n        for (uint256 i = 0; i < numTxes; i++) {\n            if (data[i].length > 0) require(destination[i].isContract(), \"NO_CODE_AT_ADDR\");\n            validateExecuteTransaction(destination[i]);\n            // We use a low level call here to allow for contract and non-contract calls\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = address(destination[i]).call{value: amount[i]}(data[i]);\n            if (!success) {\n                assembly {\n                    let ptr := mload(0x40)\n                    let size := returndatasize()\n                    returndatacopy(ptr, 0, size)\n                    revert(ptr, size)\n                }\n            }\n        }\n    }\n\n    function executeTransaction(\n        bytes calldata data,\n        address destination,\n        uint256 amount\n    ) external payable {\n        executeTransactionWithGasRefunder(IGasRefunder(address(0)), data, destination, amount);\n    }\n\n    function executeTransactionWithGasRefunder(\n        IGasRefunder gasRefunder,\n        bytes calldata data,\n        address destination,\n        uint256 amount\n    ) public payable onlyExecutorOrOwner refundsGas(gasRefunder, IReader4844(address(0))) {\n        if (data.length > 0) require(destination.isContract(), \"NO_CODE_AT_ADDR\");\n        validateExecuteTransaction(destination);\n        // We use a low level call here to allow for contract and non-contract calls\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = destination.call{value: amount}(data);\n        if (!success) {\n            assembly {\n                let ptr := mload(0x40)\n                let size := returndatasize()\n                returndatacopy(ptr, 0, size)\n                revert(ptr, size)\n            }\n        }\n    }\n\n    function timeoutChallenges(IChallengeManager manager, uint64[] calldata challenges) external {\n        timeoutChallengesWithGasRefunder(IGasRefunder(address(0)), manager, challenges);\n    }\n\n    function timeoutChallengesWithGasRefunder(\n        IGasRefunder gasRefunder,\n        IChallengeManager manager,\n        uint64[] calldata challenges\n    ) public onlyExecutorOrOwner refundsGas(gasRefunder, IReader4844(address(0))) {\n        uint256 challengesCount = challenges.length;\n        for (uint256 i = 0; i < challengesCount; i++) {\n            try manager.timeout(challenges[i]) {} catch (bytes memory error) {\n                if (error.length == 0) {\n                    // Assume out of gas\n                    // We need to revert here so gas estimation works\n                    require(false, \"GAS\");\n                }\n            }\n        }\n    }\n\n    receive() external payable {}\n\n    /// @dev allows the owner to withdraw eth held by this contract\n    function withdrawEth(uint256 amount, address destination) external onlyOwner {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = destination.call{value: amount}(\"\");\n        if (!success) revert WithdrawEthFail(destination);\n    }\n}\n"}, "src/rollup/ValidatorWalletCreator.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./ValidatorWallet.sol\";\n\ncontract ValidatorWalletCreator is Ownable {\n    event WalletCreated(\n        address indexed walletAddress,\n        address indexed executorAddress,\n        address indexed ownerAddress,\n        address adminProxy\n    );\n    event TemplateUpdated();\n\n    address public template;\n\n    constructor() Ownable() {\n        template = address(new ValidatorWallet());\n    }\n\n    function setTemplate(address _template) external onlyOwner {\n        template = _template;\n        emit TemplateUpdated();\n    }\n\n    function createWallet(address[] calldata initialExecutorAllowedDests)\n        external\n        returns (address)\n    {\n        address _executor = msg.sender;\n        address _owner = msg.sender;\n        ProxyAdmin admin = new ProxyAdmin();\n        address proxy = address(\n            new TransparentUpgradeableProxy(address(template), address(admin), \"\")\n        );\n        admin.transferOwnership(_owner);\n        ValidatorWallet(payable(proxy)).initialize(_executor, _owner, initialExecutorAllowedDests);\n        emit WalletCreated(proxy, _executor, _owner, address(admin));\n        return proxy;\n    }\n}\n"}, "src/state/Deserialize.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./Value.sol\";\nimport \"./ValueStack.sol\";\nimport \"./Machine.sol\";\nimport \"./MultiStack.sol\";\nimport \"./Instructions.sol\";\nimport \"./StackFrame.sol\";\nimport \"./MerkleProof.sol\";\nimport \"./ModuleMemoryCompact.sol\";\nimport \"./Module.sol\";\nimport \"./GlobalState.sol\";\n\nlibrary Deserialize {\n    function u8(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (uint8 ret, uint256 offset)\n    {\n        offset = startOffset;\n        ret = uint8(proof[offset]);\n        offset++;\n    }\n\n    function u16(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (uint16 ret, uint256 offset)\n    {\n        offset = startOffset;\n        for (uint256 i = 0; i < 16 / 8; i++) {\n            ret <<= 8;\n            ret |= uint8(proof[offset]);\n            offset++;\n        }\n    }\n\n    function u32(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (uint32 ret, uint256 offset)\n    {\n        offset = startOffset;\n        for (uint256 i = 0; i < 32 / 8; i++) {\n            ret <<= 8;\n            ret |= uint8(proof[offset]);\n            offset++;\n        }\n    }\n\n    function u64(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (uint64 ret, uint256 offset)\n    {\n        offset = startOffset;\n        for (uint256 i = 0; i < 64 / 8; i++) {\n            ret <<= 8;\n            ret |= uint8(proof[offset]);\n            offset++;\n        }\n    }\n\n    function u256(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (uint256 ret, uint256 offset)\n    {\n        offset = startOffset;\n        for (uint256 i = 0; i < 256 / 8; i++) {\n            ret <<= 8;\n            ret |= uint8(proof[offset]);\n            offset++;\n        }\n    }\n\n    function b32(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (bytes32 ret, uint256 offset)\n    {\n        offset = startOffset;\n        uint256 retInt;\n        (retInt, offset) = u256(proof, offset);\n        ret = bytes32(retInt);\n    }\n\n    function boolean(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (bool ret, uint256 offset)\n    {\n        offset = startOffset;\n        ret = uint8(proof[offset]) != 0;\n        offset++;\n    }\n\n    function value(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (Value memory val, uint256 offset)\n    {\n        offset = startOffset;\n        uint8 typeInt = uint8(proof[offset]);\n        offset++;\n        require(typeInt <= uint8(ValueLib.maxValueType()), \"BAD_VALUE_TYPE\");\n        uint256 contents;\n        (contents, offset) = u256(proof, offset);\n        val = Value({valueType: ValueType(typeInt), contents: contents});\n    }\n\n    function valueStack(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (ValueStack memory stack, uint256 offset)\n    {\n        offset = startOffset;\n        bytes32 remainingHash;\n        (remainingHash, offset) = b32(proof, offset);\n        uint256 provedLength;\n        (provedLength, offset) = u256(proof, offset);\n        Value[] memory proved = new Value[](provedLength);\n        for (uint256 i = 0; i < proved.length; i++) {\n            (proved[i], offset) = value(proof, offset);\n        }\n        stack = ValueStack({proved: ValueArray(proved), remainingHash: remainingHash});\n    }\n\n    function multiStack(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (MultiStack memory multistack, uint256 offset)\n    {\n        offset = startOffset;\n        bytes32 inactiveStackHash;\n        (inactiveStackHash, offset) = b32(proof, offset);\n        bytes32 remainingHash;\n        (remainingHash, offset) = b32(proof, offset);\n        multistack = MultiStack({\n            inactiveStackHash: inactiveStackHash,\n            remainingHash: remainingHash\n        });\n    }\n\n    function instructions(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (Instruction[] memory code, uint256 offset)\n    {\n        offset = startOffset;\n        uint8 count;\n        (count, offset) = u8(proof, offset);\n        code = new Instruction[](count);\n\n        for (uint256 i = 0; i < uint256(count); i++) {\n            uint16 opcode;\n            uint256 data;\n            (opcode, offset) = u16(proof, offset);\n            (data, offset) = u256(proof, offset);\n            code[i] = Instruction({opcode: opcode, argumentData: data});\n        }\n    }\n\n    function stackFrame(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (StackFrame memory window, uint256 offset)\n    {\n        offset = startOffset;\n        Value memory returnPc;\n        bytes32 localsMerkleRoot;\n        uint32 callerModule;\n        uint32 callerModuleInternals;\n        (returnPc, offset) = value(proof, offset);\n        (localsMerkleRoot, offset) = b32(proof, offset);\n        (callerModule, offset) = u32(proof, offset);\n        (callerModuleInternals, offset) = u32(proof, offset);\n        window = StackFrame({\n            returnPc: returnPc,\n            localsMerkleRoot: localsMerkleRoot,\n            callerModule: callerModule,\n            callerModuleInternals: callerModuleInternals\n        });\n    }\n\n    function stackFrameWindow(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (StackFrameWindow memory window, uint256 offset)\n    {\n        offset = startOffset;\n        bytes32 remainingHash;\n        (remainingHash, offset) = b32(proof, offset);\n        StackFrame[] memory proved;\n        if (proof[offset] != 0) {\n            offset++;\n            proved = new StackFrame[](1);\n            (proved[0], offset) = stackFrame(proof, offset);\n        } else {\n            offset++;\n            proved = new StackFrame[](0);\n        }\n        window = StackFrameWindow({proved: proved, remainingHash: remainingHash});\n    }\n\n    function moduleMemory(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (ModuleMemory memory mem, uint256 offset)\n    {\n        offset = startOffset;\n        uint64 size;\n        uint64 maxSize;\n        bytes32 root;\n        (size, offset) = u64(proof, offset);\n        (maxSize, offset) = u64(proof, offset);\n        (root, offset) = b32(proof, offset);\n        mem = ModuleMemory({size: size, maxSize: maxSize, merkleRoot: root});\n    }\n\n    function module(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (Module memory mod, uint256 offset)\n    {\n        offset = startOffset;\n        bytes32 globalsMerkleRoot;\n        ModuleMemory memory mem;\n        bytes32 tablesMerkleRoot;\n        bytes32 functionsMerkleRoot;\n        bytes32 extraHash;\n        uint32 internalsOffset;\n        (globalsMerkleRoot, offset) = b32(proof, offset);\n        (mem, offset) = moduleMemory(proof, offset);\n        (tablesMerkleRoot, offset) = b32(proof, offset);\n        (functionsMerkleRoot, offset) = b32(proof, offset);\n        (extraHash, offset) = b32(proof, offset);\n        (internalsOffset, offset) = u32(proof, offset);\n        mod = Module({\n            globalsMerkleRoot: globalsMerkleRoot,\n            moduleMemory: mem,\n            tablesMerkleRoot: tablesMerkleRoot,\n            functionsMerkleRoot: functionsMerkleRoot,\n            extraHash: extraHash,\n            internalsOffset: internalsOffset\n        });\n    }\n\n    function globalState(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (GlobalState memory state, uint256 offset)\n    {\n        offset = startOffset;\n\n        // using constant ints for array size requires newer solidity\n        bytes32[2] memory bytes32Vals;\n        uint64[2] memory u64Vals;\n\n        for (uint8 i = 0; i < GlobalStateLib.BYTES32_VALS_NUM; i++) {\n            (bytes32Vals[i], offset) = b32(proof, offset);\n        }\n        for (uint8 i = 0; i < GlobalStateLib.U64_VALS_NUM; i++) {\n            (u64Vals[i], offset) = u64(proof, offset);\n        }\n        state = GlobalState({bytes32Vals: bytes32Vals, u64Vals: u64Vals});\n    }\n\n    function machine(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (Machine memory mach, uint256 offset)\n    {\n        offset = startOffset;\n        {\n            MachineStatus status;\n            {\n                uint8 statusU8;\n                (statusU8, offset) = u8(proof, offset);\n                if (statusU8 == 0) {\n                    status = MachineStatus.RUNNING;\n                } else if (statusU8 == 1) {\n                    status = MachineStatus.FINISHED;\n                } else if (statusU8 == 2) {\n                    status = MachineStatus.ERRORED;\n                } else if (statusU8 == 3) {\n                    status = MachineStatus.TOO_FAR;\n                } else {\n                    revert(\"UNKNOWN_MACH_STATUS\");\n                }\n            }\n            ValueStack memory values;\n            ValueStack memory internalStack;\n            MultiStack memory valuesMulti;\n            StackFrameWindow memory frameStack;\n            MultiStack memory framesMulti;\n            (values, offset) = valueStack(proof, offset);\n            (valuesMulti, offset) = multiStack(proof, offset);\n            (internalStack, offset) = valueStack(proof, offset);\n            (frameStack, offset) = stackFrameWindow(proof, offset);\n            (framesMulti, offset) = multiStack(proof, offset);\n            mach = Machine({\n                status: status,\n                valueStack: values,\n                valueMultiStack: valuesMulti,\n                internalStack: internalStack,\n                frameStack: frameStack,\n                frameMultiStack: framesMulti,\n                globalStateHash: bytes32(0), // filled later\n                moduleIdx: 0, // filled later\n                functionIdx: 0, // filled later\n                functionPc: 0, // filled later\n                recoveryPc: bytes32(0), // filled later\n                modulesRoot: bytes32(0) // filled later\n            });\n        }\n        (mach.globalStateHash, offset) = b32(proof, offset);\n        (mach.moduleIdx, offset) = u32(proof, offset);\n        (mach.functionIdx, offset) = u32(proof, offset);\n        (mach.functionPc, offset) = u32(proof, offset);\n        (mach.recoveryPc, offset) = b32(proof, offset);\n        (mach.modulesRoot, offset) = b32(proof, offset);\n    }\n\n    function merkleProof(bytes calldata proof, uint256 startOffset)\n        internal\n        pure\n        returns (MerkleProof memory merkle, uint256 offset)\n    {\n        offset = startOffset;\n        uint8 length;\n        (length, offset) = u8(proof, offset);\n        bytes32[] memory counterparts = new bytes32[](length);\n        for (uint8 i = 0; i < length; i++) {\n            (counterparts[i], offset) = b32(proof, offset);\n        }\n        merkle = MerkleProof(counterparts);\n    }\n}\n"}, "src/state/GlobalState.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nstruct GlobalState {\n    bytes32[2] bytes32Vals;\n    uint64[2] u64Vals;\n}\n\nlibrary GlobalStateLib {\n    uint16 internal constant BYTES32_VALS_NUM = 2;\n    uint16 internal constant U64_VALS_NUM = 2;\n\n    function hash(GlobalState memory state) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    \"Global state:\",\n                    state.bytes32Vals[0],\n                    state.bytes32Vals[1],\n                    state.u64Vals[0],\n                    state.u64Vals[1]\n                )\n            );\n    }\n\n    function getBlockHash(GlobalState memory state) internal pure returns (bytes32) {\n        return state.bytes32Vals[0];\n    }\n\n    function getSendRoot(GlobalState memory state) internal pure returns (bytes32) {\n        return state.bytes32Vals[1];\n    }\n\n    function getInboxPosition(GlobalState memory state) internal pure returns (uint64) {\n        return state.u64Vals[0];\n    }\n\n    function getPositionInMessage(GlobalState memory state) internal pure returns (uint64) {\n        return state.u64Vals[1];\n    }\n\n    function isEmpty(GlobalState calldata state) internal pure returns (bool) {\n        return (state.bytes32Vals[0] == bytes32(0) &&\n            state.bytes32Vals[1] == bytes32(0) &&\n            state.u64Vals[0] == 0 &&\n            state.u64Vals[1] == 0);\n    }\n}\n"}, "src/state/Instructions.sol": {"content": "// Copyright 2021-2023, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nstruct Instruction {\n    uint16 opcode;\n    uint256 argumentData;\n}\n\nlibrary Instructions {\n    uint16 internal constant UNREACHABLE = 0x00;\n    uint16 internal constant NOP = 0x01;\n    uint16 internal constant RETURN = 0x0F;\n    uint16 internal constant CALL = 0x10;\n    uint16 internal constant CALL_INDIRECT = 0x11;\n    uint16 internal constant LOCAL_GET = 0x20;\n    uint16 internal constant LOCAL_SET = 0x21;\n    uint16 internal constant GLOBAL_GET = 0x23;\n    uint16 internal constant GLOBAL_SET = 0x24;\n\n    uint16 internal constant I32_LOAD = 0x28;\n    uint16 internal constant I64_LOAD = 0x29;\n    uint16 internal constant F32_LOAD = 0x2A;\n    uint16 internal constant F64_LOAD = 0x2B;\n    uint16 internal constant I32_LOAD8_S = 0x2C;\n    uint16 internal constant I32_LOAD8_U = 0x2D;\n    uint16 internal constant I32_LOAD16_S = 0x2E;\n    uint16 internal constant I32_LOAD16_U = 0x2F;\n    uint16 internal constant I64_LOAD8_S = 0x30;\n    uint16 internal constant I64_LOAD8_U = 0x31;\n    uint16 internal constant I64_LOAD16_S = 0x32;\n    uint16 internal constant I64_LOAD16_U = 0x33;\n    uint16 internal constant I64_LOAD32_S = 0x34;\n    uint16 internal constant I64_LOAD32_U = 0x35;\n\n    uint16 internal constant I32_STORE = 0x36;\n    uint16 internal constant I64_STORE = 0x37;\n    uint16 internal constant F32_STORE = 0x38;\n    uint16 internal constant F64_STORE = 0x39;\n    uint16 internal constant I32_STORE8 = 0x3A;\n    uint16 internal constant I32_STORE16 = 0x3B;\n    uint16 internal constant I64_STORE8 = 0x3C;\n    uint16 internal constant I64_STORE16 = 0x3D;\n    uint16 internal constant I64_STORE32 = 0x3E;\n\n    uint16 internal constant MEMORY_SIZE = 0x3F;\n    uint16 internal constant MEMORY_GROW = 0x40;\n\n    uint16 internal constant DROP = 0x1A;\n    uint16 internal constant SELECT = 0x1B;\n    uint16 internal constant I32_CONST = 0x41;\n    uint16 internal constant I64_CONST = 0x42;\n    uint16 internal constant F32_CONST = 0x43;\n    uint16 internal constant F64_CONST = 0x44;\n    uint16 internal constant I32_EQZ = 0x45;\n    uint16 internal constant I32_RELOP_BASE = 0x46;\n    uint16 internal constant IRELOP_EQ = 0;\n    uint16 internal constant IRELOP_NE = 1;\n    uint16 internal constant IRELOP_LT_S = 2;\n    uint16 internal constant IRELOP_LT_U = 3;\n    uint16 internal constant IRELOP_GT_S = 4;\n    uint16 internal constant IRELOP_GT_U = 5;\n    uint16 internal constant IRELOP_LE_S = 6;\n    uint16 internal constant IRELOP_LE_U = 7;\n    uint16 internal constant IRELOP_GE_S = 8;\n    uint16 internal constant IRELOP_GE_U = 9;\n    uint16 internal constant IRELOP_LAST = IRELOP_GE_U;\n\n    uint16 internal constant I64_EQZ = 0x50;\n    uint16 internal constant I64_RELOP_BASE = 0x51;\n\n    uint16 internal constant I32_UNOP_BASE = 0x67;\n    uint16 internal constant IUNOP_CLZ = 0;\n    uint16 internal constant IUNOP_CTZ = 1;\n    uint16 internal constant IUNOP_POPCNT = 2;\n    uint16 internal constant IUNOP_LAST = IUNOP_POPCNT;\n\n    uint16 internal constant I32_ADD = 0x6A;\n    uint16 internal constant I32_SUB = 0x6B;\n    uint16 internal constant I32_MUL = 0x6C;\n    uint16 internal constant I32_DIV_S = 0x6D;\n    uint16 internal constant I32_DIV_U = 0x6E;\n    uint16 internal constant I32_REM_S = 0x6F;\n    uint16 internal constant I32_REM_U = 0x70;\n    uint16 internal constant I32_AND = 0x71;\n    uint16 internal constant I32_OR = 0x72;\n    uint16 internal constant I32_XOR = 0x73;\n    uint16 internal constant I32_SHL = 0x74;\n    uint16 internal constant I32_SHR_S = 0x75;\n    uint16 internal constant I32_SHR_U = 0x76;\n    uint16 internal constant I32_ROTL = 0x77;\n    uint16 internal constant I32_ROTR = 0x78;\n\n    uint16 internal constant I64_UNOP_BASE = 0x79;\n\n    uint16 internal constant I64_ADD = 0x7C;\n    uint16 internal constant I64_SUB = 0x7D;\n    uint16 internal constant I64_MUL = 0x7E;\n    uint16 internal constant I64_DIV_S = 0x7F;\n    uint16 internal constant I64_DIV_U = 0x80;\n    uint16 internal constant I64_REM_S = 0x81;\n    uint16 internal constant I64_REM_U = 0x82;\n    uint16 internal constant I64_AND = 0x83;\n    uint16 internal constant I64_OR = 0x84;\n    uint16 internal constant I64_XOR = 0x85;\n    uint16 internal constant I64_SHL = 0x86;\n    uint16 internal constant I64_SHR_S = 0x87;\n    uint16 internal constant I64_SHR_U = 0x88;\n    uint16 internal constant I64_ROTL = 0x89;\n    uint16 internal constant I64_ROTR = 0x8A;\n\n    uint16 internal constant I32_WRAP_I64 = 0xA7;\n    uint16 internal constant I64_EXTEND_I32_S = 0xAC;\n    uint16 internal constant I64_EXTEND_I32_U = 0xAD;\n\n    uint16 internal constant I32_REINTERPRET_F32 = 0xBC;\n    uint16 internal constant I64_REINTERPRET_F64 = 0xBD;\n    uint16 internal constant F32_REINTERPRET_I32 = 0xBE;\n    uint16 internal constant F64_REINTERPRET_I64 = 0xBF;\n\n    uint16 internal constant I32_EXTEND_8S = 0xC0;\n    uint16 internal constant I32_EXTEND_16S = 0xC1;\n    uint16 internal constant I64_EXTEND_8S = 0xC2;\n    uint16 internal constant I64_EXTEND_16S = 0xC3;\n    uint16 internal constant I64_EXTEND_32S = 0xC4;\n\n    uint16 internal constant INIT_FRAME = 0x8002;\n    uint16 internal constant ARBITRARY_JUMP = 0x8003;\n    uint16 internal constant ARBITRARY_JUMP_IF = 0x8004;\n    uint16 internal constant MOVE_FROM_STACK_TO_INTERNAL = 0x8005;\n    uint16 internal constant MOVE_FROM_INTERNAL_TO_STACK = 0x8006;\n    uint16 internal constant DUP = 0x8008;\n    uint16 internal constant CROSS_MODULE_CALL = 0x8009;\n    uint16 internal constant CALLER_MODULE_INTERNAL_CALL = 0x800A;\n    uint16 internal constant CROSS_MODULE_FORWARD = 0x800B;\n    uint16 internal constant CROSS_MODULE_INTERNAL_CALL = 0x800C;\n\n    uint16 internal constant GET_GLOBAL_STATE_BYTES32 = 0x8010;\n    uint16 internal constant SET_GLOBAL_STATE_BYTES32 = 0x8011;\n    uint16 internal constant GET_GLOBAL_STATE_U64 = 0x8012;\n    uint16 internal constant SET_GLOBAL_STATE_U64 = 0x8013;\n\n    uint16 internal constant READ_PRE_IMAGE = 0x8020;\n    uint16 internal constant READ_INBOX_MESSAGE = 0x8021;\n    uint16 internal constant HALT_AND_SET_FINISHED = 0x8022;\n    uint16 internal constant LINK_MODULE = 0x8023;\n    uint16 internal constant UNLINK_MODULE = 0x8024;\n\n    uint16 internal constant NEW_COTHREAD = 0x8030;\n    uint16 internal constant POP_COTHREAD = 0x8031;\n    uint16 internal constant SWITCH_COTHREAD = 0x8032;\n\n    uint256 internal constant INBOX_INDEX_SEQUENCER = 0;\n    uint256 internal constant INBOX_INDEX_DELAYED = 1;\n\n    function hash(Instruction[] memory code) internal pure returns (bytes32) {\n        // To avoid quadratic expense, we declare a `bytes` early and populate its contents.\n        bytes memory data = new bytes(13 + 1 + 34 * code.length);\n        assembly {\n            // Represents the string \"Instructions:\", which we place after the length word.\n            mstore(\n                add(data, 32),\n                0x496e737472756374696f6e733a00000000000000000000000000000000000000\n            )\n        }\n\n        // write the instruction count\n        uint256 offset = 13;\n        data[offset] = bytes1(uint8(code.length));\n        offset++;\n\n        // write each instruction\n        for (uint256 i = 0; i < code.length; i++) {\n            Instruction memory inst = code[i];\n            data[offset] = bytes1(uint8(inst.opcode >> 8));\n            data[offset + 1] = bytes1(uint8(inst.opcode));\n            offset += 2;\n            uint256 argumentData = inst.argumentData;\n            assembly {\n                mstore(add(add(data, 32), offset), argumentData)\n            }\n            offset += 32;\n        }\n        return keccak256(data);\n    }\n}\n"}, "src/state/Machine.sol": {"content": "// Copyright 2021-2023, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./ValueStack.sol\";\nimport \"./Instructions.sol\";\nimport \"./MultiStack.sol\";\nimport \"./StackFrame.sol\";\n\nenum MachineStatus {\n    RUNNING,\n    FINISHED,\n    ERRORED,\n    TOO_FAR\n}\n\nstruct Machine {\n    MachineStatus status;\n    ValueStack valueStack;\n    MultiStack valueMultiStack;\n    ValueStack internalStack;\n    StackFrameWindow frameStack;\n    MultiStack frameMultiStack;\n    bytes32 globalStateHash;\n    uint32 moduleIdx;\n    uint32 functionIdx;\n    uint32 functionPc;\n    bytes32 recoveryPc;\n    bytes32 modulesRoot;\n}\n\nlibrary MachineLib {\n    using StackFrameLib for StackFrameWindow;\n    using ValueStackLib for ValueStack;\n    using MultiStackLib for MultiStack;\n\n    bytes32 internal constant NO_RECOVERY_PC = ~bytes32(0);\n\n    function hash(Machine memory mach) internal pure returns (bytes32) {\n        // Warning: the non-running hashes are replicated in Challenge\n        if (mach.status == MachineStatus.RUNNING) {\n            bytes32 valueMultiHash = mach.valueMultiStack.hash(\n                mach.valueStack.hash(),\n                mach.recoveryPc != NO_RECOVERY_PC\n            );\n            bytes32 frameMultiHash = mach.frameMultiStack.hash(\n                mach.frameStack.hash(),\n                mach.recoveryPc != NO_RECOVERY_PC\n            );\n            bytes memory preimage = abi.encodePacked(\n                \"Machine running:\",\n                valueMultiHash,\n                mach.internalStack.hash(),\n                frameMultiHash,\n                mach.globalStateHash,\n                mach.moduleIdx,\n                mach.functionIdx,\n                mach.functionPc,\n                mach.recoveryPc,\n                mach.modulesRoot\n            );\n            return keccak256(preimage);\n        } else if (mach.status == MachineStatus.FINISHED) {\n            return keccak256(abi.encodePacked(\"Machine finished:\", mach.globalStateHash));\n        } else if (mach.status == MachineStatus.ERRORED) {\n            return keccak256(abi.encodePacked(\"Machine errored:\"));\n        } else if (mach.status == MachineStatus.TOO_FAR) {\n            return keccak256(abi.encodePacked(\"Machine too far:\"));\n        } else {\n            revert(\"BAD_MACH_STATUS\");\n        }\n    }\n\n    function switchCoThreadStacks(Machine memory mach) internal pure {\n        bytes32 newActiveValue = mach.valueMultiStack.inactiveStackHash;\n        bytes32 newActiveFrame = mach.frameMultiStack.inactiveStackHash;\n        if (\n            newActiveFrame == MultiStackLib.NO_STACK_HASH ||\n            newActiveValue == MultiStackLib.NO_STACK_HASH\n        ) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        mach.frameMultiStack.inactiveStackHash = mach.frameStack.hash();\n        mach.valueMultiStack.inactiveStackHash = mach.valueStack.hash();\n        mach.frameStack.overwrite(newActiveFrame);\n        mach.valueStack.overwrite(newActiveValue);\n    }\n\n    function setPcFromData(Machine memory mach, uint256 data) internal pure returns (bool) {\n        if (data >> 96 != 0) {\n            return false;\n        }\n\n        mach.functionPc = uint32(data);\n        mach.functionIdx = uint32(data >> 32);\n        mach.moduleIdx = uint32(data >> 64);\n        return true;\n    }\n\n    function setPcFromRecovery(Machine memory mach) internal pure returns (bool) {\n        if (!setPcFromData(mach, uint256(mach.recoveryPc))) {\n            return false;\n        }\n        mach.recoveryPc = NO_RECOVERY_PC;\n        return true;\n    }\n\n    function setRecoveryFromPc(Machine memory mach, uint32 offset) internal pure returns (bool) {\n        if (mach.recoveryPc != NO_RECOVERY_PC) {\n            return false;\n        }\n\n        uint256 result;\n        result = uint256(mach.moduleIdx) << 64;\n        result = result | (uint256(mach.functionIdx) << 32);\n        result = result | uint256(mach.functionPc + offset - 1);\n        mach.recoveryPc = bytes32(result);\n        return true;\n    }\n\n    function setPc(Machine memory mach, Value memory pc) internal pure {\n        if (pc.valueType == ValueType.REF_NULL) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        if (pc.valueType != ValueType.INTERNAL_REF) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        if (!setPcFromData(mach, pc.contents)) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n    }\n}\n"}, "src/state/MerkleProof.sol": {"content": "// Copyright 2021-2023, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./Value.sol\";\nimport \"./Instructions.sol\";\nimport \"./Module.sol\";\n\nstruct MerkleProof {\n    bytes32[] counterparts;\n}\n\nlibrary MerkleProofLib {\n    using ModuleLib for Module;\n    using ValueLib for Value;\n\n    function computeRootFromValue(\n        MerkleProof memory proof,\n        uint256 index,\n        Value memory leaf\n    ) internal pure returns (bytes32) {\n        return computeRootUnsafe(proof, index, leaf.hash(), \"Value merkle tree:\");\n    }\n\n    function computeRootFromInstructions(\n        MerkleProof memory proof,\n        uint256 index,\n        Instruction[] memory code\n    ) internal pure returns (bytes32) {\n        return computeRootUnsafe(proof, index, Instructions.hash(code), \"Instruction merkle tree:\");\n    }\n\n    function computeRootFromFunction(\n        MerkleProof memory proof,\n        uint256 index,\n        bytes32 codeRoot\n    ) internal pure returns (bytes32) {\n        bytes32 h = keccak256(abi.encodePacked(\"Function:\", codeRoot));\n        return computeRootUnsafe(proof, index, h, \"Function merkle tree:\");\n    }\n\n    function computeRootFromMemory(\n        MerkleProof memory proof,\n        uint256 index,\n        bytes32 contents\n    ) internal pure returns (bytes32) {\n        bytes32 h = keccak256(abi.encodePacked(\"Memory leaf:\", contents));\n        return computeRootUnsafe(proof, index, h, \"Memory merkle tree:\");\n    }\n\n    function computeRootFromElement(\n        MerkleProof memory proof,\n        uint256 index,\n        bytes32 funcTypeHash,\n        Value memory val\n    ) internal pure returns (bytes32) {\n        bytes32 h = keccak256(abi.encodePacked(\"Table element:\", funcTypeHash, val.hash()));\n        return computeRootUnsafe(proof, index, h, \"Table element merkle tree:\");\n    }\n\n    function computeRootFromTable(\n        MerkleProof memory proof,\n        uint256 index,\n        uint8 tableType,\n        uint64 tableSize,\n        bytes32 elementsRoot\n    ) internal pure returns (bytes32) {\n        bytes32 h = keccak256(abi.encodePacked(\"Table:\", tableType, tableSize, elementsRoot));\n        return computeRootUnsafe(proof, index, h, \"Table merkle tree:\");\n    }\n\n    function computeRootFromModule(\n        MerkleProof memory proof,\n        uint256 index,\n        Module memory mod\n    ) internal pure returns (bytes32) {\n        return computeRootUnsafe(proof, index, mod.hash(), \"Module merkle tree:\");\n    }\n\n    // WARNING: leafHash must be computed in such a way that it cannot be a non-leaf hash.\n    function computeRootUnsafe(\n        MerkleProof memory proof,\n        uint256 index,\n        bytes32 leafHash,\n        string memory prefix\n    ) internal pure returns (bytes32 h) {\n        h = leafHash;\n        for (uint256 layer = 0; layer < proof.counterparts.length; layer++) {\n            if (index & 1 == 0) {\n                h = keccak256(abi.encodePacked(prefix, h, proof.counterparts[layer]));\n            } else {\n                h = keccak256(abi.encodePacked(prefix, proof.counterparts[layer], h));\n            }\n            index >>= 1;\n        }\n        require(index == 0, \"PROOF_TOO_SHORT\");\n    }\n\n    function growToNewRoot(\n        bytes32 root,\n        uint256 leaf,\n        bytes32 hash,\n        bytes32 zero,\n        string memory prefix\n    ) internal pure returns (bytes32) {\n        bytes32 h = hash;\n        uint256 node = leaf;\n        while (node > 1) {\n            h = keccak256(abi.encodePacked(prefix, h, zero));\n            zero = keccak256(abi.encodePacked(prefix, zero, zero));\n            node >>= 1;\n        }\n        return keccak256(abi.encodePacked(prefix, root, h));\n    }\n}\n"}, "src/state/Module.sol": {"content": "// Copyright 2021-2023, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./ModuleMemoryCompact.sol\";\n\nstruct Module {\n    bytes32 globalsMerkleRoot;\n    ModuleMemory moduleMemory;\n    bytes32 tablesMerkleRoot;\n    bytes32 functionsMerkleRoot;\n    bytes32 extraHash;\n    uint32 internalsOffset;\n}\n\nlibrary ModuleLib {\n    using ModuleMemoryCompactLib for ModuleMemory;\n\n    function hash(Module memory mod) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    \"Module:\",\n                    mod.globalsMerkleRoot,\n                    mod.moduleMemory.hash(),\n                    mod.tablesMerkleRoot,\n                    mod.functionsMerkleRoot,\n                    mod.extraHash,\n                    mod.internalsOffset\n                )\n            );\n    }\n}\n"}, "src/state/ModuleMemory.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./MerkleProof.sol\";\nimport \"./Deserialize.sol\";\nimport \"./ModuleMemoryCompact.sol\";\n\nlibrary ModuleMemoryLib {\n    using MerkleProofLib for MerkleProof;\n\n    uint256 private constant LEAF_SIZE = 32;\n\n    function hash(ModuleMemory memory mem) internal pure returns (bytes32) {\n        return ModuleMemoryCompactLib.hash(mem);\n    }\n\n    function proveLeaf(\n        ModuleMemory memory mem,\n        uint256 leafIdx,\n        bytes calldata proof,\n        uint256 startOffset\n    )\n        internal\n        pure\n        returns (\n            bytes32 contents,\n            uint256 offset,\n            MerkleProof memory merkle\n        )\n    {\n        offset = startOffset;\n        (contents, offset) = Deserialize.b32(proof, offset);\n        (merkle, offset) = Deserialize.merkleProof(proof, offset);\n        bytes32 recomputedRoot = merkle.computeRootFromMemory(leafIdx, contents);\n        require(recomputedRoot == mem.merkleRoot, \"WRONG_MEM_ROOT\");\n    }\n\n    function isValidLeaf(ModuleMemory memory mem, uint256 pointer) internal pure returns (bool) {\n        return pointer + 32 <= mem.size && pointer % LEAF_SIZE == 0;\n    }\n\n    function pullLeafByte(bytes32 leaf, uint256 idx) internal pure returns (uint8) {\n        require(idx < LEAF_SIZE, \"BAD_PULL_LEAF_BYTE_IDX\");\n        // Take into account that we are casting the leaf to a big-endian integer\n        uint256 leafShift = (LEAF_SIZE - 1 - idx) * 8;\n        return uint8(uint256(leaf) >> leafShift);\n    }\n\n    // loads a big-endian value from memory\n    function load(\n        ModuleMemory memory mem,\n        uint256 start,\n        uint256 width,\n        bytes calldata proof,\n        uint256 proofOffset\n    )\n        internal\n        pure\n        returns (\n            bool err,\n            uint256 value,\n            uint256 offset\n        )\n    {\n        if (start + width > mem.size) {\n            return (true, 0, proofOffset);\n        }\n\n        uint256 lastProvedLeafIdx = ~uint256(0);\n        bytes32 lastProvedLeafContents;\n        uint256 readValue;\n        for (uint256 i = 0; i < width; i++) {\n            uint256 idx = start + i;\n            uint256 leafIdx = idx / LEAF_SIZE;\n            if (leafIdx != lastProvedLeafIdx) {\n                (lastProvedLeafContents, proofOffset, ) = proveLeaf(\n                    mem,\n                    leafIdx,\n                    proof,\n                    proofOffset\n                );\n                lastProvedLeafIdx = leafIdx;\n            }\n            uint256 indexWithinLeaf = idx % LEAF_SIZE;\n            readValue |= uint256(pullLeafByte(lastProvedLeafContents, indexWithinLeaf)) << (i * 8);\n        }\n        return (false, readValue, proofOffset);\n    }\n}\n"}, "src/state/ModuleMemoryCompact.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nstruct ModuleMemory {\n    uint64 size;\n    uint64 maxSize;\n    bytes32 merkleRoot;\n}\n\nlibrary ModuleMemoryCompactLib {\n    function hash(ModuleMemory memory mem) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"Memory:\", mem.size, mem.maxSize, mem.merkleRoot));\n    }\n}\n"}, "src/state/MultiStack.sol": {"content": "// Copyright 2021-2024, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nstruct MultiStack {\n    bytes32 inactiveStackHash; // NO_STACK_HASH if no stack, 0 if empty stack\n    bytes32 remainingHash; // 0 if less than 2 cothreads exist\n}\n\nlibrary MultiStackLib {\n    bytes32 internal constant NO_STACK_HASH = ~bytes32(0);\n\n    function hash(\n        MultiStack memory multi,\n        bytes32 activeStackHash,\n        bool cothread\n    ) internal pure returns (bytes32) {\n        require(activeStackHash != NO_STACK_HASH, \"MULTISTACK_NOSTACK_ACTIVE\");\n        if (cothread) {\n            require(multi.inactiveStackHash != NO_STACK_HASH, \"MULTISTACK_NOSTACK_MAIN\");\n            return\n                keccak256(\n                    abi.encodePacked(\n                        \"multistack:\",\n                        multi.inactiveStackHash,\n                        activeStackHash,\n                        multi.remainingHash\n                    )\n                );\n        } else {\n            return\n                keccak256(\n                    abi.encodePacked(\n                        \"multistack:\",\n                        activeStackHash,\n                        multi.inactiveStackHash,\n                        multi.remainingHash\n                    )\n                );\n        }\n    }\n\n    function setEmpty(MultiStack memory multi) internal pure {\n        multi.inactiveStackHash = NO_STACK_HASH;\n        multi.remainingHash = 0;\n    }\n\n    function pushNew(MultiStack memory multi) internal pure {\n        if (multi.inactiveStackHash != NO_STACK_HASH) {\n            multi.remainingHash = keccak256(\n                abi.encodePacked(\"cothread:\", multi.inactiveStackHash, multi.remainingHash)\n            );\n        }\n        multi.inactiveStackHash = 0;\n    }\n}\n"}, "src/state/PcArray.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nstruct PcArray {\n    uint32[] inner;\n}\n\nlibrary PcArrayLib {\n    function get(PcArray memory arr, uint256 index) internal pure returns (uint32) {\n        return arr.inner[index];\n    }\n\n    function set(\n        PcArray memory arr,\n        uint256 index,\n        uint32 val\n    ) internal pure {\n        arr.inner[index] = val;\n    }\n\n    function length(PcArray memory arr) internal pure returns (uint256) {\n        return arr.inner.length;\n    }\n\n    function push(PcArray memory arr, uint32 val) internal pure {\n        uint32[] memory newInner = new uint32[](arr.inner.length + 1);\n        for (uint256 i = 0; i < arr.inner.length; i++) {\n            newInner[i] = arr.inner[i];\n        }\n        newInner[arr.inner.length] = val;\n        arr.inner = newInner;\n    }\n\n    function pop(PcArray memory arr) internal pure returns (uint32 popped) {\n        popped = arr.inner[arr.inner.length - 1];\n        uint32[] memory newInner = new uint32[](arr.inner.length - 1);\n        for (uint256 i = 0; i < newInner.length; i++) {\n            newInner[i] = arr.inner[i];\n        }\n        arr.inner = newInner;\n    }\n}\n"}, "src/state/StackFrame.sol": {"content": "// Copyright 2021-2023, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./Value.sol\";\n\nstruct StackFrame {\n    Value returnPc;\n    bytes32 localsMerkleRoot;\n    uint32 callerModule;\n    uint32 callerModuleInternals;\n}\n\nstruct StackFrameWindow {\n    StackFrame[] proved;\n    bytes32 remainingHash;\n}\n\nlibrary StackFrameLib {\n    using ValueLib for Value;\n\n    function hash(StackFrame memory frame) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    \"Stack frame:\",\n                    frame.returnPc.hash(),\n                    frame.localsMerkleRoot,\n                    frame.callerModule,\n                    frame.callerModuleInternals\n                )\n            );\n    }\n\n    function hash(StackFrameWindow memory window) internal pure returns (bytes32 h) {\n        h = window.remainingHash;\n        for (uint256 i = 0; i < window.proved.length; i++) {\n            h = keccak256(abi.encodePacked(\"Stack frame stack:\", hash(window.proved[i]), h));\n        }\n    }\n\n    function peek(StackFrameWindow memory window) internal pure returns (StackFrame memory) {\n        require(window.proved.length == 1, \"BAD_WINDOW_LENGTH\");\n        return window.proved[0];\n    }\n\n    function pop(StackFrameWindow memory window) internal pure returns (StackFrame memory frame) {\n        require(window.proved.length == 1, \"BAD_WINDOW_LENGTH\");\n        frame = window.proved[0];\n        window.proved = new StackFrame[](0);\n    }\n\n    function push(StackFrameWindow memory window, StackFrame memory frame) internal pure {\n        StackFrame[] memory newProved = new StackFrame[](window.proved.length + 1);\n        for (uint256 i = 0; i < window.proved.length; i++) {\n            newProved[i] = window.proved[i];\n        }\n        newProved[window.proved.length] = frame;\n        window.proved = newProved;\n    }\n\n    function overwrite(StackFrameWindow memory window, bytes32 root) internal pure {\n        window.remainingHash = root;\n        delete window.proved;\n    }\n}\n"}, "src/state/Value.sol": {"content": "// Copyright 2021-2023, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nenum ValueType {\n    I32,\n    I64,\n    F32,\n    F64,\n    REF_NULL,\n    FUNC_REF,\n    INTERNAL_REF\n}\n\nstruct Value {\n    ValueType valueType;\n    uint256 contents;\n}\n\nlibrary ValueLib {\n    function hash(Value memory val) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"Value:\", val.valueType, val.contents));\n    }\n\n    function maxValueType() internal pure returns (ValueType) {\n        return ValueType.INTERNAL_REF;\n    }\n\n    function assumeI32(Value memory val) internal pure returns (uint32) {\n        uint256 uintval = uint256(val.contents);\n        require(val.valueType == ValueType.I32, \"NOT_I32\");\n        require(uintval < (1 << 32), \"BAD_I32\");\n        return uint32(uintval);\n    }\n\n    function assumeI64(Value memory val) internal pure returns (uint64) {\n        uint256 uintval = uint256(val.contents);\n        require(val.valueType == ValueType.I64, \"NOT_I64\");\n        require(uintval < (1 << 64), \"BAD_I64\");\n        return uint64(uintval);\n    }\n\n    function newRefNull() internal pure returns (Value memory) {\n        return Value({valueType: ValueType.REF_NULL, contents: 0});\n    }\n\n    function newI32(uint32 x) internal pure returns (Value memory) {\n        return Value({valueType: ValueType.I32, contents: uint256(x)});\n    }\n\n    function newI64(uint64 x) internal pure returns (Value memory) {\n        return Value({valueType: ValueType.I64, contents: uint256(x)});\n    }\n\n    function newBoolean(bool x) internal pure returns (Value memory) {\n        if (x) {\n            return newI32(uint32(1));\n        } else {\n            return newI32(uint32(0));\n        }\n    }\n\n    function newPc(\n        uint32 funcPc,\n        uint32 func,\n        uint32 module\n    ) internal pure returns (Value memory) {\n        uint256 data = 0;\n        data |= funcPc;\n        data |= uint256(func) << 32;\n        data |= uint256(module) << 64;\n        return Value({valueType: ValueType.INTERNAL_REF, contents: data});\n    }\n}\n"}, "src/state/ValueArray.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./Value.sol\";\n\nstruct ValueArray {\n    Value[] inner;\n}\n\nlibrary ValueArrayLib {\n    function get(ValueArray memory arr, uint256 index) internal pure returns (Value memory) {\n        return arr.inner[index];\n    }\n\n    function set(\n        ValueArray memory arr,\n        uint256 index,\n        Value memory val\n    ) internal pure {\n        arr.inner[index] = val;\n    }\n\n    function length(ValueArray memory arr) internal pure returns (uint256) {\n        return arr.inner.length;\n    }\n\n    function push(ValueArray memory arr, Value memory val) internal pure {\n        Value[] memory newInner = new Value[](arr.inner.length + 1);\n        for (uint256 i = 0; i < arr.inner.length; i++) {\n            newInner[i] = arr.inner[i];\n        }\n        newInner[arr.inner.length] = val;\n        arr.inner = newInner;\n    }\n\n    function pop(ValueArray memory arr) internal pure returns (Value memory popped) {\n        popped = arr.inner[arr.inner.length - 1];\n        Value[] memory newInner = new Value[](arr.inner.length - 1);\n        for (uint256 i = 0; i < newInner.length; i++) {\n            newInner[i] = arr.inner[i];\n        }\n        arr.inner = newInner;\n    }\n}\n"}, "src/state/ValueStack.sol": {"content": "// Copyright 2021-2023, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"./Value.sol\";\nimport \"./ValueArray.sol\";\n\nstruct ValueStack {\n    ValueArray proved;\n    bytes32 remainingHash;\n}\n\nlibrary ValueStackLib {\n    using ValueLib for Value;\n    using ValueArrayLib for ValueArray;\n\n    function hash(ValueStack memory stack) internal pure returns (bytes32 h) {\n        h = stack.remainingHash;\n        uint256 len = stack.proved.length();\n        for (uint256 i = 0; i < len; i++) {\n            h = keccak256(abi.encodePacked(\"Value stack:\", stack.proved.get(i).hash(), h));\n        }\n    }\n\n    function peek(ValueStack memory stack) internal pure returns (Value memory) {\n        uint256 len = stack.proved.length();\n        return stack.proved.get(len - 1);\n    }\n\n    function pop(ValueStack memory stack) internal pure returns (Value memory) {\n        return stack.proved.pop();\n    }\n\n    function push(ValueStack memory stack, Value memory val) internal pure {\n        return stack.proved.push(val);\n    }\n\n    function overwrite(ValueStack memory stack, bytes32 root) internal pure {\n        stack.remainingHash = root;\n        delete stack.proved;\n    }\n}\n"}, "src/test-helpers/BridgeTester.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport {\n    NotContract,\n    NotRollupOrOwner,\n    NotDelayedInbox,\n    NotSequencerInbox,\n    NotOutbox,\n    InvalidOutboxSet\n} from \"../libraries/Error.sol\";\nimport \"../bridge/IBridge.sol\";\nimport \"../bridge/IEthBridge.sol\";\nimport \"../bridge/Messages.sol\";\nimport \"../libraries/DelegateCallAware.sol\";\n\n/**\n * @title Staging ground for incoming and outgoing messages\n * @notice Holds the inbox accumulator for delayed messages, and is the ETH escrow\n * for value sent with these messages.\n * Since the escrow is held here, this contract also contains a list of allowed\n * outboxes that can make calls from here and withdraw this escrow.\n */\ncontract BridgeTester is Initializable, DelegateCallAware, IBridge, IEthBridge {\n    using AddressUpgradeable for address;\n\n    struct InOutInfo {\n        uint256 index;\n        bool allowed;\n    }\n\n    mapping(address => InOutInfo) private allowedInboxesMap;\n    mapping(address => InOutInfo) private allowedOutboxesMap;\n\n    address[] public allowedDelayedInboxList;\n    address[] public allowedOutboxList;\n\n    address private _activeOutbox;\n\n    IOwnable public rollup;\n    address public sequencerInbox;\n\n    address public nativeToken;\n    uint8 public nativeTokenDecimals;\n\n    modifier onlyRollupOrOwner() {\n        if (msg.sender != address(rollup)) {\n            address rollupOwner = rollup.owner();\n            if (msg.sender != rollupOwner) {\n                revert NotRollupOrOwner(msg.sender, address(rollup), rollupOwner);\n            }\n        }\n        _;\n    }\n\n    function setSequencerInbox(address _sequencerInbox) external override onlyRollupOrOwner {\n        sequencerInbox = _sequencerInbox;\n        emit SequencerInboxUpdated(_sequencerInbox);\n    }\n\n    /// @dev Accumulator for delayed inbox messages; tail represents hash of the current state; each element represents the inclusion of a new message.\n    bytes32[] public override delayedInboxAccs;\n\n    bytes32[] public override sequencerInboxAccs;\n    uint256 public override sequencerReportedSubMessageCount;\n\n    address private constant EMPTY_ACTIVEOUTBOX = address(type(uint160).max);\n\n    function initialize(IOwnable rollup_) external initializer {\n        _activeOutbox = EMPTY_ACTIVEOUTBOX;\n        rollup = rollup_;\n    }\n\n    function updateRollupAddress(IOwnable _rollup) external {\n        rollup = _rollup;\n    }\n\n    function activeOutbox() public view returns (address) {\n        if (_activeOutbox == EMPTY_ACTIVEOUTBOX) return address(uint160(0));\n        return _activeOutbox;\n    }\n\n    function allowedDelayedInboxes(address inbox) external view override returns (bool) {\n        return allowedInboxesMap[inbox].allowed;\n    }\n\n    function allowedOutboxes(address outbox) external view override returns (bool) {\n        return allowedOutboxesMap[outbox].allowed;\n    }\n\n    function enqueueSequencerMessage(\n        bytes32 dataHash,\n        uint256 afterDelayedMessagesRead,\n        uint256 prevMessageCount,\n        uint256 newMessageCount\n    )\n        external\n        returns (\n            uint256 seqMessageIndex,\n            bytes32 beforeAcc,\n            bytes32 delayedAcc,\n            bytes32 acc\n        )\n    {\n        // TODO: implement stub logic\n    }\n\n    function submitBatchSpendingReport(address batchPoster, bytes32 dataHash)\n        external\n        returns (uint256)\n    {\n        // TODO: implement stub\n    }\n\n    /**\n     * @dev Enqueue a message in the delayed inbox accumulator.\n     * These messages are later sequenced in the SequencerInbox, either by the sequencer as\n     * part of a normal batch, or by force inclusion.\n     */\n    function enqueueDelayedMessage(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    ) external payable override returns (uint256) {\n        if (!allowedInboxesMap[msg.sender].allowed) revert NotDelayedInbox(msg.sender);\n        return\n            addMessageToDelayedAccumulator(\n                kind,\n                sender,\n                uint64(block.number),\n                uint64(block.timestamp), // solhint-disable-line not-rely-on-time\n                block.basefee,\n                messageDataHash\n            );\n    }\n\n    function addMessageToDelayedAccumulator(\n        uint8 kind,\n        address sender,\n        uint64 blockNumber,\n        uint64 blockTimestamp,\n        uint256 baseFeeL1,\n        bytes32 messageDataHash\n    ) internal returns (uint256) {\n        uint256 count = delayedInboxAccs.length;\n        bytes32 messageHash = Messages.messageHash(\n            kind,\n            sender,\n            blockNumber,\n            blockTimestamp,\n            count,\n            baseFeeL1,\n            messageDataHash\n        );\n        bytes32 prevAcc = 0;\n        if (count > 0) {\n            prevAcc = delayedInboxAccs[count - 1];\n        }\n        delayedInboxAccs.push(Messages.accumulateInboxMessage(prevAcc, messageHash));\n        emit MessageDelivered(\n            count,\n            prevAcc,\n            msg.sender,\n            kind,\n            sender,\n            messageDataHash,\n            baseFeeL1,\n            blockTimestamp\n        );\n        return count;\n    }\n\n    function executeCall(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external override returns (bool success, bytes memory returnData) {\n        if (!allowedOutboxesMap[msg.sender].allowed) revert NotOutbox(msg.sender);\n        if (data.length > 0 && !to.isContract()) revert NotContract(to);\n        address prevOutbox = _activeOutbox;\n        _activeOutbox = msg.sender;\n        // We set and reset active outbox around external call so activeOutbox remains valid during call\n\n        // We use a low level call here since we want to bubble up whether it succeeded or failed to the caller\n        // rather than reverting on failure as well as allow contract and non-contract calls\n        // solhint-disable-next-line avoid-low-level-calls\n        (success, returnData) = to.call{value: value}(data);\n        _activeOutbox = prevOutbox;\n        emit BridgeCallTriggered(msg.sender, to, value, data);\n    }\n\n    function setDelayedInbox(address inbox, bool enabled) external override onlyRollupOrOwner {\n        InOutInfo storage info = allowedInboxesMap[inbox];\n        bool alreadyEnabled = info.allowed;\n        emit InboxToggle(inbox, enabled);\n        if ((alreadyEnabled && enabled) || (!alreadyEnabled && !enabled)) {\n            return;\n        }\n        if (enabled) {\n            allowedInboxesMap[inbox] = InOutInfo(allowedDelayedInboxList.length, true);\n            allowedDelayedInboxList.push(inbox);\n        } else {\n            allowedDelayedInboxList[info.index] = allowedDelayedInboxList[\n                allowedDelayedInboxList.length - 1\n            ];\n            allowedInboxesMap[allowedDelayedInboxList[info.index]].index = info.index;\n            allowedDelayedInboxList.pop();\n            delete allowedInboxesMap[inbox];\n        }\n    }\n\n    function setOutbox(address outbox, bool enabled) external override onlyRollupOrOwner {\n        InOutInfo storage info = allowedOutboxesMap[outbox];\n        bool alreadyEnabled = info.allowed;\n        emit OutboxToggle(outbox, enabled);\n        if ((alreadyEnabled && enabled) || (!alreadyEnabled && !enabled)) {\n            return;\n        }\n        if (enabled) {\n            allowedOutboxesMap[outbox] = InOutInfo(allowedOutboxList.length, true);\n            allowedOutboxList.push(outbox);\n        } else {\n            allowedOutboxList[info.index] = allowedOutboxList[allowedOutboxList.length - 1];\n            allowedOutboxesMap[allowedOutboxList[info.index]].index = info.index;\n            allowedOutboxList.pop();\n            delete allowedOutboxesMap[outbox];\n        }\n    }\n\n    function delayedMessageCount() external view override returns (uint256) {\n        return delayedInboxAccs.length;\n    }\n\n    function sequencerMessageCount() external view override returns (uint256) {\n        return sequencerInboxAccs.length;\n    }\n\n    receive() external payable {}\n\n    function acceptFundsFromOldBridge() external payable {}\n}\n"}, "src/test-helpers/CryptographyPrimitivesTester.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../libraries/CryptographyPrimitives.sol\";\n\nlibrary CryptographyPrimitivesTester {\n    function keccakF(uint256[25] memory input) public pure returns (uint256[25] memory) {\n        return CryptographyPrimitives.keccakF(input);\n    }\n\n    function sha256Block(bytes32[2] memory inputChunk, bytes32 hashState)\n        public\n        pure\n        returns (bytes32)\n    {\n        return\n            bytes32(\n                CryptographyPrimitives.sha256Block(\n                    [uint256(inputChunk[0]), uint256(inputChunk[1])],\n                    uint256(hashState)\n                )\n            );\n    }\n}\n"}, "src/test-helpers/EthVault.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\n/**\n * Simple contract for testing bridge calls which include calldata\n */\ncontract EthVault {\n    uint256 public version = 0;\n\n    function setVersion(uint256 _version) external payable {\n        version = _version;\n    }\n\n    function justRevert() external payable {\n        revert(\"bye\");\n    }\n}\n"}, "src/test-helpers/InterfaceCompatibilityTester.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.30;\n\nimport \"../bridge/IBridge.sol\";\nimport \"../bridge/IOutbox.sol\";\nimport \"../bridge/IInboxBase.sol\";\nimport \"../bridge/ISequencerInbox.sol\";\n"}, "src/test-helpers/MessageTester.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../bridge/Messages.sol\";\n\ncontract MessageTester {\n    function messageHash(\n        uint8 messageType,\n        address sender,\n        uint64 blockNumber,\n        uint64 timestamp,\n        uint256 inboxSeqNum,\n        uint256 gasPriceL1,\n        bytes32 messageDataHash\n    ) public pure returns (bytes32) {\n        return\n            Messages.messageHash(\n                messageType,\n                sender,\n                blockNumber,\n                timestamp,\n                inboxSeqNum,\n                gasPriceL1,\n                messageDataHash\n            );\n    }\n\n    function accumulateInboxMessage(bytes32 inbox, bytes32 message) public pure returns (bytes32) {\n        return Messages.accumulateInboxMessage(inbox, message);\n    }\n}\n"}, "src/test-helpers/OutboxWithoutOptTester.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport {\n    AlreadyInit,\n    NotRollup,\n    ProofTooLong,\n    PathNotMinimal,\n    UnknownRoot,\n    AlreadySpent,\n    BridgeCallFailed\n} from \"../libraries/Error.sol\";\nimport \"../bridge/IBridge.sol\";\nimport \"../bridge/IOutbox.sol\";\nimport \"../libraries/MerkleLib.sol\";\nimport \"../libraries/DelegateCallAware.sol\";\n\ncontract OutboxWithoutOptTester is DelegateCallAware, IOutbox {\n    address public rollup; // the rollup contract\n    IBridge public bridge; // the bridge contract\n\n    function spent(uint256) external pure override returns (bytes32) {\n        revert(\"NOT_IMPLEMETED\");\n    }\n\n    mapping(uint256 => bool) public isSpent; // maps leaf number => if spent\n    mapping(bytes32 => bytes32) public roots; // maps root hashes => L2 block hash\n\n    struct L2ToL1Context {\n        uint128 l2Block;\n        uint128 l1Block;\n        uint128 timestamp;\n        bytes32 outputId;\n        address sender;\n    }\n    // Note, these variables are set and then wiped during a single transaction.\n    // Therefore their values don't need to be maintained, and their slots will\n    // be empty outside of transactions\n    L2ToL1Context internal context;\n    uint128 public constant OUTBOX_VERSION = 2;\n\n    function initialize(IBridge _bridge) external {\n        if (address(bridge) != address(0)) revert AlreadyInit();\n        bridge = _bridge;\n        rollup = address(_bridge.rollup());\n    }\n\n    function postUpgradeInit() external {}\n\n    function updateSendRoot(bytes32 root, bytes32 l2BlockHash) external override {\n        //if (msg.sender != rollup) revert NotRollup(msg.sender, rollup);  //test only!!!\n        roots[root] = l2BlockHash;\n        emit SendRootUpdated(root, l2BlockHash);\n    }\n\n    function updateRollupAddress() external onlyDelegated onlyProxyOwner {\n        rollup = address(bridge.rollup());\n    }\n\n    /// @notice When l2ToL1Sender returns a nonzero address, the message was originated by an L2 account\n    /// When the return value is zero, that means this is a system message\n    /// @dev the l2ToL1Sender behaves as the tx.origin, the msg.sender should be validated to protect against reentrancies\n    function l2ToL1Sender() external view override returns (address) {\n        return context.sender;\n    }\n\n    function l2ToL1Block() external view override returns (uint256) {\n        return uint256(context.l2Block);\n    }\n\n    function l2ToL1EthBlock() external view override returns (uint256) {\n        return uint256(context.l1Block);\n    }\n\n    function l2ToL1Timestamp() external view override returns (uint256) {\n        return uint256(context.timestamp);\n    }\n\n    // @deprecated batch number is now always 0\n    function l2ToL1BatchNum() external pure returns (uint256) {\n        return 0;\n    }\n\n    function l2ToL1OutputId() external view override returns (bytes32) {\n        return context.outputId;\n    }\n\n    /**\n     * @notice Executes a messages in an Outbox entry.\n     * @dev Reverts if dispute period hasn't expired, since the outbox entry\n     * is only created once the rollup confirms the respective assertion.\n     * @param proof Merkle proof of message inclusion in send root\n     * @param index Merkle path to message\n     * @param l2Sender sender if original message (i.e., caller of ArbSys.sendTxToL1)\n     * @param to destination address for L1 contract call\n     * @param l2Block l2 block number at which sendTxToL1 call was made\n     * @param l1Block l1 block number at which sendTxToL1 call was made\n     * @param l2Timestamp l2 Timestamp at which sendTxToL1 call was made\n     * @param value wei in L1 message\n     * @param data abi-encoded L1 message data\n     */\n    function executeTransaction(\n        bytes32[] calldata proof,\n        uint256 index,\n        address l2Sender,\n        address to,\n        uint256 l2Block,\n        uint256 l1Block,\n        uint256 l2Timestamp,\n        uint256 value,\n        bytes calldata data\n    ) external virtual override {\n        bytes32 outputId;\n        {\n            bytes32 userTx = calculateItemHash(\n                l2Sender,\n                to,\n                l2Block,\n                l1Block,\n                l2Timestamp,\n                value,\n                data\n            );\n\n            outputId = recordOutputAsSpent(proof, index, userTx);\n            emit OutBoxTransactionExecuted(to, l2Sender, 0, index);\n        }\n\n        // we temporarily store the previous values so the outbox can naturally\n        // unwind itself when there are nested calls to `executeTransaction`\n        L2ToL1Context memory prevContext = context;\n\n        context = L2ToL1Context({\n            sender: l2Sender,\n            l2Block: uint128(l2Block),\n            l1Block: uint128(l1Block),\n            timestamp: uint128(l2Timestamp),\n            outputId: outputId\n        });\n\n        // set and reset vars around execution so they remain valid during call\n        executeBridgeCall(to, value, data);\n\n        context = prevContext;\n    }\n\n    function executeTransactionSimulation(\n        uint256,\n        address,\n        address,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external pure override {\n        revert(\"Not implemented\");\n    }\n\n    function recordOutputAsSpent(\n        bytes32[] memory proof,\n        uint256 index,\n        bytes32 item\n    ) internal returns (bytes32) {\n        if (proof.length >= 256) revert ProofTooLong(proof.length);\n        if (index >= 2**proof.length) revert PathNotMinimal(index, 2**proof.length);\n\n        // Hash the leaf an extra time to prove it's a leaf\n        bytes32 calcRoot = calculateMerkleRoot(proof, index, item);\n        if (roots[calcRoot] == bytes32(0)) revert UnknownRoot(calcRoot);\n\n        if (isSpent[index]) revert AlreadySpent(index);\n        isSpent[index] = true;\n\n        return bytes32(index);\n    }\n\n    function executeBridgeCall(\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        (bool success, bytes memory returndata) = bridge.executeCall(to, value, data);\n        if (!success) {\n            if (returndata.length > 0) {\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert BridgeCallFailed();\n            }\n        }\n    }\n\n    function calculateItemHash(\n        address l2Sender,\n        address to,\n        uint256 l2Block,\n        uint256 l1Block,\n        uint256 l2Timestamp,\n        uint256 value,\n        bytes calldata data\n    ) public pure override returns (bytes32) {\n        return\n            keccak256(abi.encodePacked(l2Sender, to, l2Block, l1Block, l2Timestamp, value, data));\n    }\n\n    function calculateMerkleRoot(\n        bytes32[] memory proof,\n        uint256 path,\n        bytes32 item\n    ) public pure override returns (bytes32) {\n        return MerkleLib.calculateRoot(proof, path, keccak256(abi.encodePacked(item)));\n    }\n}\n"}, "src/test-helpers/RollupMock.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\ncontract RollupMock {\n    event WithdrawTriggered();\n    event ZombieTriggered();\n\n    address public owner;\n\n    constructor(address _owner) {\n        owner = _owner;\n    }\n\n    function withdrawStakerFunds() external returns (uint256) {\n        emit WithdrawTriggered();\n        return 0;\n    }\n\n    function removeOldZombies(\n        uint256 /* startIndex */\n    ) external {\n        emit ZombieTriggered();\n    }\n}\n"}, "src/test-helpers/TestToken.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * Basic ERC20 token\n */\ncontract TestToken is ERC20 {\n    constructor(uint256 initialSupply) ERC20(\"TestToken\", \"TT\") {\n        _mint(msg.sender, initialSupply);\n    }\n}\n"}, "src/test-helpers/ValueArrayTester.sol": {"content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.30;\n\nimport \"../state/ValueArray.sol\";\n\ncontract ValueArrayTester {\n    using ValueArrayLib for ValueArray;\n\n    function test() external pure {\n        ValueArray memory arr = ValueArray(new Value[](2));\n        require(arr.length() == 2, \"START_LEN\");\n        arr.set(0, ValueLib.newI32(1));\n        arr.set(1, ValueLib.newI32(2));\n        arr.push(ValueLib.newI32(3));\n        require(arr.length() == 3, \"PUSH_LEN\");\n        for (uint256 i = 0; i < arr.length(); i++) {\n            Value memory val = arr.get(i);\n            require(val.valueType == ValueType.I32, \"PUSH_VAL_TYPE\");\n            require(val.contents == i + 1, \"PUSH_VAL_CONTENTS\");\n        }\n        Value memory popped = arr.pop();\n        require(popped.valueType == ValueType.I32, \"POP_RET_TYPE\");\n        require(popped.contents == 3, \"POP_RET_CONTENTS\");\n        require(arr.length() == 2, \"POP_LEN\");\n        for (uint256 i = 0; i < arr.length(); i++) {\n            Value memory val = arr.get(i);\n            require(val.valueType == ValueType.I32, \"POP_VAL_TYPE\");\n            require(val.contents == i + 1, \"POP_VAL_CONTENTS\");\n        }\n    }\n}\n"}}, "settings": {"optimizer": {"enabled": false, "runs": 200}, "viaIR": true, "outputSelection": {"*": {"*": ["abi", "metadata", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers", "evm.legacyAssembly", "evm.bytecode.opcodes"]}}, "metadata": {"appendCBOR": false}, "libraries": {}}}