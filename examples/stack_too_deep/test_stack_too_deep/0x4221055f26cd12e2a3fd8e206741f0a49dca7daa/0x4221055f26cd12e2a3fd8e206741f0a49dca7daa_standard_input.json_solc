{"language": "Solidity", "sources": {"@openzeppelin/contracts/access/Ownable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.30;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"}, "@openzeppelin/contracts/security/ReentrancyGuard.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"}, "@openzeppelin/contracts/utils/Context.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"}, "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.30;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"}, "contracts/IMP.sol": {"content": "// SPDX-License-Identifier: MIT\n/**\n * @dev @brougkr\n */\npragma solidity ^0.8.30;\ninterface IMP \n{ \n    /**\n     * @dev { For Instances Where Golden Token Or Artists Have A Bespoke Mint Pass Contract }\n     */\n    function _LiveMintBurn(uint TicketID) external returns (address Recipient, uint ArtistID); \n}"}, "contracts/LaunchpadEnabled.sol": {"content": "//SPDX-License-Identifier: MIT\n/**\n * @dev @brougkr\n */\npragma solidity ^0.8.30;\nabstract contract LaunchpadEnabled\n{\n    /**\n     * @dev The Launchpad Address\n     */\n    address public _LAUNCHPAD = 0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700;\n\n    /**\n     * @dev Overrides The Launchpad Address\n     */\n    function _____OverrideLaunchpadAddress(address NewAddress) internal { _LAUNCHPAD = NewAddress; }\n\n    /**\n     * @dev Updates The Launchpad Address From Launchpad (batch upgrade)\n     */ \n    function _____NewLaunchpadAddress(address NewAddress) external onlyLaunchpad { _LAUNCHPAD = NewAddress; }\n\n    /**\n     * @dev Access Control Needed For A Contract To Be Able To Use The Launchpad\n    */\n    modifier onlyLaunchpad()\n    {\n        require(_LAUNCHPAD == msg.sender, \"onlyLaunchpad: Caller Is Not Launchpad\");\n        _;\n    }\n}"}, "contracts/MarketplaceDutch.sol": {"content": "//SPDX-License-Identifier: MIT\n/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\n/**\n * @dev: @brougkr\n */\npragma solidity ^0.8.30;\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { MerkleProof } from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport { IMP } from \"./IMP.sol\";\nimport { LaunchpadEnabled } from \"./LaunchpadEnabled.sol\";\ncontract MarketplaceDutch is Ownable, ReentrancyGuard, LaunchpadEnabled\n{\n    struct Sale\n    {\n        string _Name;                     // [0] -> _Name\n        uint _ProjectIDMintPass;          // [1] -> _ProjectIDMintPass\n        uint _ProjectIDArtBlocks;         // [2] -> _ProjectIDArtBlocks\n        uint _PriceStart;                 // [3] -> _PriceStart\n        uint _PriceEnd;                   // [4] -> _PriceEnd\n        uint _WalletLimiter;              // [5] -> _WalletLimiter\n        uint _MaximumAvailableForSale;    // [6] -> _MaximumAvailableForSale\n        uint _StartingBlockUnixTimestamp; // [7] -> _StartingBlockUnixTimestamp\n        uint _SecondsBetweenPriceDecay;   // [8] -> _SecondsBetweenPriceDecay\n        uint _SaleStrip;                  // [9] -> _SaleStrip note: For MintPack Sales, This Is The Default Amount Of Tokens To Mint Per Purchase Per Amount\n    }\n\n    struct InternalSale\n    {\n        address _NFT;           // [0] -> _NFT\n        address _Operator;      // [1] _Operator (Wallet That NFT Is Pulling From)\n        uint _CurrentIndex;     // [2] _CurrentIndex (If Simple Sale Type, This Is The Next Token Index To Iterate Upon)\n        uint _Type;             // [3] _SaleType (0 = Factory MintPass, 1 = Bespoke MintPass, 2 = transferFrom(), 3 = purchaseTo(), 4 = MintPack transferFrom())\n        bool _ActivePublic;     // [4] -> _ActivePublic\n        bool _ActiveBrightList; // [5] -> _ActiveBrightList \n        bool _Discount;         // [6] -> _Discount\n        bool _ActiveRespend;    // [7] -> _ActiveRespend\n    }\n\n    struct SaleParam\n    {\n        bytes32[] _Roots;        // [0] -> _Roots (Merkle Roots For BrightList)\n        bytes32[] _RootsAmounts; // [1] -> _RootsAmounts (Merkle Roots For BrightList Amounts)\n        uint[] _DiscountAmounts; // [2] -> _DiscountAmounts (Discount Amounts For Each Discount Priority Tier)\n    }\n\n    struct MiscSale\n    {\n        uint _AmountSold;         // [0] -> _AmountSold\n        uint _UniqueSales;        // [1] -> _UniqueSales\n        uint _FinalClearingPrice; // [2] -> _FinalClearingPrice\n        uint _CurrentRefundIndex; // [3] -> _CurrentRefundIndex\n    }\n\n    struct Order\n    {\n        address _Purchaser;       // [0] _Purchaser\n        uint _PurchaseValue;      // [1] _PurchaseValue\n        uint _PurchaseAmount;     // [2] _PurchaseAmount\n        uint _Priority;           // [3] _BrightList Priority Status note: (0 Is Highest Priority)\n        bool _BrightListPurchase; // [4] _BrightListPurchase\n        bool _Claimed;            // [5] _Claimed\n    }\n\n    struct _UserSaleInformation\n    {\n        uint[] _UserOrderIndexes;      // [0] -> _UserOrderIndexes        | The Indexes Of The User's Orders\n        uint _PurchasedAmount;         // [1] -> _PurchaseAmount          | The Amount Of Tokens Purchased By The User\n        uint _RemainingPurchaseAmount; // [2] -> _RemainingPurchaseAmount | The Amount Of Tokens Remaining To Be Purchased Specifically For The User\n        uint _ClaimIndex;              // [3] -> _ClaimIndex              | If ETH-Claims Are Enabled, This Is The User's Current Claim Index\n        uint _AmountRemaining;         // [4] -> _AmountRemaining         | The Amount Of Tokens Remaining To Be Sold\n        uint _CurrentPrice;            // [5] -> _MintPassCurrentPrice    | The Current Price Of The Token To Be Sold\n        uint _Priority;                // [6] -> _Priority For BrightList | The User's Priority For The BrightList | note: (0 Is Highest Priority) \n        uint _AmountPurchasedPriority; // [7] -> _AmountPurchasedPriority | The Amount Of Tokens Purchased By The User For The Provided Priority\n        uint _Credit;                  // [8] -> _Credit                  | The Amount Of Credit / Rebate Owed To The User (Without Discount) \n        bool _BrightListEligible;      // [9] -> _BrightListEligible      | If The User Is Eligible For The BrightList\n        bool _MaxAmountVerified;       // [10] -> _MaxAmountVerified      | If The User Passed MaxAmount Correctly\n        bool _ActiveRespend;           // [11] -> _ActiveRespend          | If Purchase Credit Is Able To Be Used\n        bool _Active;                  // [12] -> _Active                 | If The Sale Is Active\n    }\n\n    struct Info\n    {\n        uint _CurrentPrice;            // [0] -> _CurrentPrice\n        uint _MaximumAvailableForSale; // [1] -> _MaximumAvailableForSale\n        uint _AmountRemaining;         // [2] -> _AmountRemaining\n        bool _Active;                  // [3] -> _Active\n    }\n\n    /*------------------\n     * STATE VARIABLES *\n    -------------------*/\n\n    uint public _TOTAL_UNIQUE_SALES_DUTCH;                                               // Total Unique Dutch Sales\n    uint private constant _DEFAULT_PRIORITY = 69420;                                     // Default Priority Value \ud83d\ude09              \n    address private constant _DR = 0x00000000000076A84feF008CDAbe6409d2FE638B;           // Delegation Registry \n    address private constant _BRT_MULTISIG = 0x0BC56e3c1397e4570069e89C07936A5c6020e3BE; // `sales.brightmoments.eth`\n    \n    /*-----------\n     * MAPPINGS *\n    ------------*/\n\n    mapping(uint=>Sale) public Sales;                                                   // [SaleIndex] => Sale\n    mapping(uint=>MiscSale) public SaleState;                                           // [SaleIndex] => MiscSale\n    mapping(uint=>InternalSale) public SalesInternal;                                   // [SaleIndex] => InternalSale\n    mapping(uint=>Order[]) public Orders;                                               // [SaleIndex][UniqueSaleIndex] => Order\n    mapping(uint=>mapping(address=>_UserSaleInformation)) public UserInfo;              // [SaleIndex][Wallet] => UserInfo\n    mapping(uint=>SaleParam) private SaleParams;                                        // [SaleIndex] => SaleParam\n    mapping(address=>bool) public Admin;                                                // [Wallet] => IsAdmin\n    mapping(address=>uint) public NFTAddressToSaleIndex;                                // [NFT Address] => SaleIndex\n    mapping(uint=>mapping(address=>mapping(uint=>uint))) public PriorityPurchaseAmount; // [SaleIndex][Wallet][Priority] => Purchased Amount For Priority Level\n\n    event Purchased(address Purchaser, uint Amount, uint PurchaseValue, uint NewAmountSold, bool BrightList, uint Priority, uint AppliedCredit);\n    event Refunded(uint Value);\n    event OrderRefundFailed(uint SaleIndex, uint OrderIndex);\n    event SaleStarted(uint SaleIndex);\n    event RefundClaimed(uint SaleIndex, uint OrderIndex);\n\n    constructor() \n    { \n        Admin[msg.sender] = true; // `deployer.brightmoments.eth`\n        Admin[0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700] = true; // `operator.brightmoments.eth`\n    }\n\n    /*---------------------\n     * EXTERNAL FUNCTIONS *\n    ----------------------*/\n\n    /**\n     * @dev Purchases NFTs\n     * note: IF YOU PURCHASE THROUGH THE CONTRACT WITHOUT THE FRONTEND YOU WILL NOT BE ELIGIBLE FOR A DISCOUNT REBATE, REQUIRES A MERKLE PROOF\n     * note: `msg.value` Must Be Sufficient To Purchase NFTs @ The Current Price Of The Dutch Auction\n     * @param SaleIndex        | The Sale Index\n     * @param Amount           | Amount The Amount Of NFTs To Purchase\n     * @param MaxAmount        | Optional Maximum Brightlist Purchase Per Wallet Limiter\n     * @param Vault            | Vault (optional delegate.cash) (if opt-out, use address(0) or `` for this value)\n     * @param ProofEligibility | Merkle Proof For Priority Discount Eligibility\n     * @param ProofAmount      | Merkle Proof For Maximum Purchase Amount\n     * note: @param ProofEligibility Input --> [0x0] <-- For Empty Proof\n     * note: @param ProofAmount - Input --> [0x0] <-- For Empty Proof\n     */\n    function Purchase (\n        uint SaleIndex, \n        uint Amount, \n        uint MaxAmount, \n        address Vault, \n        bytes32[] calldata ProofEligibility, \n        bytes32[] calldata ProofAmount\n    ) external payable nonReentrant { \n        InternalSale memory _IS = SalesInternal[SaleIndex];\n        require(block.timestamp >= Sales[SaleIndex]._StartingBlockUnixTimestamp, \"DutchMarketplace: Sale Not Started\");\n        require(_IS._ActivePublic || _IS._ActiveBrightList, \"DutchMarketplace: Sale Not Active\");\n        address Recipient = msg.sender;\n        uint OrderIndex = SaleState[SaleIndex]._UniqueSales;\n        if(Vault != address(0)) { if(IDelegationRegistry(_DR).checkDelegateForAll(msg.sender, Vault)) { Recipient = Vault; } } \n        require(Recipient != address(0), \"DutchMarketplace: Invalid Recipient\");\n        if(SaleState[SaleIndex]._AmountSold + Amount > Sales[SaleIndex]._MaximumAvailableForSale)\n        {\n            Amount = Sales[SaleIndex]._MaximumAvailableForSale - SaleState[SaleIndex]._AmountSold;\n        }\n        uint NewAmountSold = SaleState[SaleIndex]._AmountSold + Amount;\n        require(NewAmountSold <= Sales[SaleIndex]._MaximumAvailableForSale, \"DutchMarketplace: Sold Out\");\n        uint Priority = _DEFAULT_PRIORITY;\n        uint NewUserPurchasedAmount = UserInfo[SaleIndex][Recipient]._PurchasedAmount + Amount;\n        bool BrightListEligible;\n        if(_IS._ActiveBrightList)\n        {\n            (BrightListEligible, Priority) = ViewBrightListStatus(SaleIndex, Recipient, ProofEligibility);\n            if(BrightListEligible)\n            {\n                uint UserPriorityPurchasedAmount = PriorityPurchaseAmount[SaleIndex][Recipient][Priority];\n                bytes32 _RootHash = SaleParams[SaleIndex]._RootsAmounts[Priority];\n                require(VerifyAmount(Recipient, MaxAmount, _RootHash, ProofAmount), \"DutchMarketplace: Invalid Max Amount Merkle Proof For Provided Merkle Priority\");\n                require(UserPriorityPurchasedAmount + Amount <= MaxAmount, \"DutchMarketplace: User Has Purchased All Allocation For Provided Merkle Priority\");\n                PriorityPurchaseAmount[SaleIndex][Recipient][Priority] += Amount;\n            }\n        }\n        require(Amount > 0 && Amount <= Sales[SaleIndex]._WalletLimiter, \"DutchMarketplace: Incorrect Desired Purchase Amount\");\n        uint CurrentPrice = ViewCurrentPrice(SaleIndex);\n        uint PurchaseValue = CurrentPrice * Amount;\n        uint AppliedCredit;\n        if(_IS._ActiveRespend) { AppliedCredit = __ActiveRespend(SaleIndex, CurrentPrice, PurchaseValue, msg.sender); } // AppliedCredit Is Capped @ Purchase Value\n        uint TotalETHContributed = msg.value + AppliedCredit;\n        require(TotalETHContributed >= PurchaseValue, \"DutchMarketplace: Incorrect ETH Amount Sent\");\n        if(TotalETHContributed > PurchaseValue && msg.value > 0) { __Refund(Recipient, TotalETHContributed - PurchaseValue); }\n        Orders[SaleIndex].push(Order(msg.sender, PurchaseValue, Amount, Priority, BrightListEligible, false));\n        UserInfo[SaleIndex][Recipient]._UserOrderIndexes.push(OrderIndex);\n        UserInfo[SaleIndex][Recipient]._PurchasedAmount = NewUserPurchasedAmount;\n        SaleState[SaleIndex]._UniqueSales = OrderIndex + 1;\n        SaleState[SaleIndex]._AmountSold = NewAmountSold;\n        require(SaleState[SaleIndex]._AmountSold <= Sales[SaleIndex]._MaximumAvailableForSale, \"DutchMarketplace: Overflow\");\n        if(SaleState[SaleIndex]._AmountSold == Sales[SaleIndex]._MaximumAvailableForSale)\n        { \n            SaleState[SaleIndex]._FinalClearingPrice = CurrentPrice; \n            ___EndSale(SaleIndex);\n        }\n        if(_IS._Type == 0) { IERC721(_IS._NFT)._MintToFactory(Sales[SaleIndex]._ProjectIDMintPass, msg.sender, Amount); } // Factory MintPass Direct Mint\n        else if (_IS._Type == 1) { IERC721(_IS._NFT)._MintToBespoke(msg.sender, Amount); }\n        else if (_IS._Type == 2) { IERC721(_IS._NFT)._MintToFactoryPack(Sales[SaleIndex]._ProjectIDMintPass, msg.sender, Amount); } // Factory MintPack Direct Mint\n        else if (_IS._Type == 3) // transferFrom() Sale Implementation (NFTs Already Minted)\n        {\n            for(uint x; x < Amount; x++)\n            {\n                IERC721(_IS._NFT).transferFrom(\n                    _IS._Operator,        // `from`\n                    msg.sender,           // `to`\n                    _IS._CurrentIndex + x // `tokenID`\n                );\n            }\n            SalesInternal[SaleIndex]._CurrentIndex = _IS._CurrentIndex + Amount;\n        }\n        else if (_IS._Type == 4) // purchaseTo() Sale Implementation\n        {\n            uint ProjectID = Sales[SaleIndex]._ProjectIDArtBlocks;\n            for(uint x; x < Amount; x++)\n            {\n                IERC721(_IS._NFT).purchaseTo(\n                    msg.sender, // `to`\n                    ProjectID   // `projectID`\n                );\n            }\n        }\n        else if (_IS._Type == 5) \n        {\n            uint _SaleStrip = Sales[SaleIndex]._SaleStrip;\n            uint _Start = _IS._CurrentIndex;\n            for(uint x; x < Amount; x++)\n            {\n                for(uint y; y < _SaleStrip; y++)\n                {\n                    IERC721(_IS._NFT).transferFrom(\n                        _IS._Operator, // `from`\n                        msg.sender,    // `to`\n                        _Start + y     // `tokenID`\n                    );\n                }\n                _Start += _SaleStrip;\n            }\n            SalesInternal[SaleIndex]._CurrentIndex = _IS._CurrentIndex + (_SaleStrip * Amount);\n        }\n        else { revert(\"DutchMarketplace: Incorrect Sale Configuration\"); }\n        emit Purchased(Recipient, Amount, PurchaseValue, NewAmountSold, BrightListEligible, Priority, AppliedCredit);\n    }\n\n    /*------------------\n     * ADMIN FUNCTIONS *\n    -------------------*/\n\n    /**\n     * @dev Starts A Sale\n     * note: The True Discount Amount Is 100 - _Sale._DiscountAmount\n     * note: Ex. _DiscountAmount = 75 = 25% Discount\n     * note: Simple = True = IERC721(NFT).transferFrom() Sale\n     * note: Simple = False = Custom purchaseTo Logic (ArtBlocks Or Custom Mint Pass)\n     */\n    function __StartSale(\n        Sale memory _Sale,\n        InternalSale memory _InternalSale,\n        bytes32[] calldata RootsPriority,\n        bytes32[] calldata RootsAmounts,\n        uint[] calldata DiscountAmounts\n    ) external onlyAdmin {\n        NFTAddressToSaleIndex[_InternalSale._NFT] = _TOTAL_UNIQUE_SALES_DUTCH;\n        Sales[_TOTAL_UNIQUE_SALES_DUTCH] = _Sale;\n        SalesInternal[_TOTAL_UNIQUE_SALES_DUTCH] = _InternalSale;\n        SaleParams[_TOTAL_UNIQUE_SALES_DUTCH] = SaleParam(RootsPriority, RootsAmounts, DiscountAmounts);\n        require(\n            _InternalSale._Type == 0 // Factory MintPass Direct Mint\n            ||\n            _InternalSale._Type == 1 // Bespoke MintPass Direct Mint\n            ||\n            _InternalSale._Type == 2 // Factory MintPack Direct Mint\n            ||\n            _InternalSale._Type == 3 // transferFrom() Sale (NFTs Already Minted)\n            ||\n            _InternalSale._Type == 4 // purchaseTo() Sale (ArtBlocks Or Custom Mint Pass)\n            ||\n            _InternalSale._Type == 5 // transferFrom() MintPack Sale (NFTs Already Minted)\n            , \"DutchMarketplace: Invalid Sale Type\"\n        );\n        require(RootsPriority.length == DiscountAmounts.length, \"DutchMarketplace: Invalid Merkle Root Length\");\n        for(uint x; x < SaleParams[_TOTAL_UNIQUE_SALES_DUTCH]._DiscountAmounts.length; x++)\n        {\n            require(DiscountAmounts[x] <= 100, \"DutchMarketplace: Invalid Discount Amount\");\n        }\n        require(Sales[_TOTAL_UNIQUE_SALES_DUTCH]._PriceStart >= Sales[_TOTAL_UNIQUE_SALES_DUTCH]._PriceEnd, \"DutchMarketplace: Invalid Start And End Prices\");\n        emit SaleStarted(_TOTAL_UNIQUE_SALES_DUTCH);\n        _TOTAL_UNIQUE_SALES_DUTCH++;\n    }\n\n    /**\n     * @dev Initiates Withdraw Of Refunds & Sale Proceeds\n     * note: This Is Only After The Sale Has Completed\n     */\n    function __InitiateRefundsAndProceeds(uint SaleIndex) external nonReentrant onlyAdmin \n    {\n        bool _TxConfirmed;\n        uint _Proceeds;\n        uint _Refund;\n        require(SaleState[SaleIndex]._FinalClearingPrice > 0, \"DutchMarketplace: Final Clearing Price Not Seeded\");\n        uint[] memory DiscountAmounts = SaleParams[SaleIndex]._DiscountAmounts;\n        for(uint OrderIndex = SaleState[SaleIndex]._CurrentRefundIndex; OrderIndex < SaleState[SaleIndex]._UniqueSales; OrderIndex++)\n        {\n            Order memory _Order = Orders[SaleIndex][OrderIndex];\n            if(!_Order._Claimed)\n            {\n                if(!_Order._BrightListPurchase) // No BrightList\n                {\n                    _Refund = _Order._PurchaseValue - (SaleState[SaleIndex]._FinalClearingPrice * _Order._PurchaseAmount);\n                    _Proceeds += _Order._PurchaseValue - _Refund;\n                    if(_Refund > 0) { (_TxConfirmed,) = _Order._Purchaser.call{ value: _Refund }(\"\"); }\n                }\n                else // BrightList\n                {\n                    _Refund = _Order._PurchaseValue - \n                    (\n                        ((SaleState[SaleIndex]._FinalClearingPrice * DiscountAmounts[_Order._Priority]) / 100)\n                        * \n                        _Order._PurchaseAmount\n                    );\n                    _Proceeds += _Order._PurchaseValue - _Refund;\n                    if(_Refund > 0) { (_TxConfirmed,) = _Order._Purchaser.call{ value: _Refund }(\"\"); }\n                }\n                if(!_TxConfirmed) { emit OrderRefundFailed(SaleIndex, OrderIndex); }\n                Orders[SaleIndex][OrderIndex]._Claimed = true;\n            }\n        }\n        (_TxConfirmed,) = _BRT_MULTISIG.call{ value: _Proceeds }(\"\"); \n        require(_TxConfirmed, \"DutchMarketplace: Multisig Refund Failed, Use Failsafe Withdraw And Manually Process\");\n        SaleState[SaleIndex]._CurrentRefundIndex = SaleState[SaleIndex]._UniqueSales; // Resets Refund Index\n    }\n\n    /*--------------*/\n    /*  ONLY OWNER  */\n    /*--------------*/\n\n    /**\n     * @dev Modifies The Sale Starting Token Index\n     * note: If `Simple` Sale, Then This Is The Current TokenID Being Transferred In The Sale\n     */\n    function ___ModifySaleStartingTokenIndex(uint SaleIndex, uint StartingTokenID) external onlyOwner\n    {\n        SalesInternal[SaleIndex]._CurrentIndex = StartingTokenID;\n    }\n\n    /**\n     * @dev Modifies The Sale Name\n     */\n    function ___ModifySaleName(uint SaleIndex, string calldata Name) external onlyOwner\n    {\n        Sales[SaleIndex]._Name = Name;\n    }\n\n    /**\n     * @dev Modifies The ArtBlocks Sale ProjectID (if applicable)\n     */\n    function ___ModifySaleProjectID(uint SaleIndex, uint ProjectID) external onlyOwner\n    {\n        Sales[SaleIndex]._ProjectIDMintPass = ProjectID;\n    }\n\n    /**\n     * @dev Modifies The Starting Price\n     */\n    function ___ModifyPriceStart(uint SaleIndex, uint PriceStart) external onlyOwner\n    {\n        Sales[SaleIndex]._PriceStart = PriceStart;\n    }\n\n    /**\n     * @dev Modifies The Ending Price\n     */\n    function ___ModifyPriceEnd(uint SaleIndex, uint PriceEnd) external onlyOwner\n    {\n        Sales[SaleIndex]._PriceEnd = PriceEnd;\n    }\n\n    /**\n     * @dev Modifies The Per-Wallet-Limiter\n     */\n    function ___ModifyWalletLimiter(uint SaleIndex, uint WalletLimiter) external onlyOwner\n    {\n        Sales[SaleIndex]._WalletLimiter = WalletLimiter;\n    }\n\n    /**\n     * @dev Modifies The Maximum NFTs For Sale\n     */\n    function ___ModifyMaxForSale(uint SaleIndex, uint AmountForSale) external onlyOwner\n    {\n        Sales[SaleIndex]._MaximumAvailableForSale = AmountForSale;\n    }\n\n    /**\n     * @dev Modifies The Starting Unix Timestamp\n     */\n    function ___ModifyTimestampStart(uint SaleIndex, uint Timestamp) external onlyOwner\n    {\n        Sales[SaleIndex]._StartingBlockUnixTimestamp = Timestamp;\n    }\n\n    /**\n     * @dev Modifies The Price Decay (Input In Seconds)\n     */\n    function ___ModifyPriceDecay(uint SaleIndex, uint PriceDecayInSeconds) external onlyOwner\n    {\n        Sales[SaleIndex]._SecondsBetweenPriceDecay = PriceDecayInSeconds;\n    }\n\n    /**\n     * @dev Modifies The Sale Discount Amount\n     * note: Ex. The True Discount Amount = 100 - `DiscountAmount`\n     * note: Ex. `DiscountAmount` = 75 | 100 - `DiscountAmount` = 25% Discount\n     */\n    function ___ModifySaleDiscountAmount(uint SaleIndex, uint[] calldata DiscountAmounts) external onlyOwner\n    {\n        for(uint x; x < DiscountAmounts.length; x++)\n        {\n            require(DiscountAmounts[x] <= 100, \"DutchMarketplace: Invalid Discount Amount\");\n            SaleParams[SaleIndex]._DiscountAmounts[x] = DiscountAmounts[x];\n        }\n    }\n\n    /**\n     * @dev Modifies The NFT Address Of A Sale\n     */\n    function ___ModifySaleNFTAddress(uint SaleIndex, address NFT) external onlyOwner\n    {\n        SalesInternal[SaleIndex]._NFT = NFT;\n    }\n\n    /**\n     * @dev Modifies The Final Clearing Price Of A Sale\n     */\n    function ___ModifySaleClearingPrice(uint SaleIndex, uint ClearingPrice) external onlyOwner\n    {\n        SaleState[SaleIndex]._FinalClearingPrice = ClearingPrice;\n    }\n\n    /**\n     * @dev Modifies The Public Active Sale State\n     */\n    function ___ModifySaleStatePublic(uint SaleIndex, bool State) external onlyOwner\n    {\n        SalesInternal[SaleIndex]._ActivePublic = State;\n    }\n\n    /**\n     * @dev Modifies The BrightList Active Sale State\n     */\n    function ___ModifySaleStateBrightList(uint SaleIndex, bool State) external onlyOwner\n    {\n        SalesInternal[SaleIndex]._ActiveBrightList = State;\n    }\n\n    /**\n     * @dev Modifies The State Of ETH Claims\n     * note: onlyOwner: This Enables Users To Claim ETH Rebate Pending In The Contract Before The Sale Concludes\n     */\n    function ___ModifySaleETHClaimsEnabled(uint SaleIndex, bool State) external onlyOwner\n    {\n        SalesInternal[SaleIndex]._ActiveRespend = State;\n    }\n\n    /**\n     * @dev onlyOwner: Modifies The Merkle Root(s) For Amounts\n     */\n    function ___ModifySaleRootAmounts(uint SaleIndex, bytes32[] calldata RootsAmounts) external onlyOwner\n    {\n        SaleParams[SaleIndex]._RootsAmounts = RootsAmounts;\n    }\n\n    /**\n     * @dev onlyOwner: Modifies The Merkle Root(s) For Eligibility\n     */\n    function ___ModifySaleRootEligibility(uint SaleIndex, bytes32[] calldata Roots) external onlyOwner\n    {\n        SaleParams[SaleIndex]._Roots = Roots;\n    }\n\n    /**\n     * @dev Modifies The Sale Root(s) For Merkle Eligibility & Amounts\n     */\n    function ___ModifySaleRoots(uint SaleIndex, bytes32[] calldata RootsEligibility, bytes32[] calldata RootsAmounts) external onlyOwner\n    {\n        SaleParams[SaleIndex]._Roots = RootsEligibility;\n        SaleParams[SaleIndex]._RootsAmounts = RootsAmounts;\n    }\n\n    /**\n     * @dev onlyOwner: Modifies Sale\n     */\n    function ___ModifySale(uint SaleIndex, Sale memory _Sale) external onlyOwner { Sales[SaleIndex] = _Sale; }\n\n    /**\n     * @dev Modifies The Sale Operator\n     */\n    function ___ModifySaleOperator(uint SaleIndex, address Operator) external onlyOwner { SalesInternal[SaleIndex]._Operator = Operator; }\n\n    /**\n     * @dev onlyOwner: Grants Admin Role\n     */\n    function ___AdminGrant(address _Admin) external onlyOwner { Admin[_Admin] = true; }\n\n    /**\n     * @dev onlyOwner: Removes Admin Role\n     */\n    function ___AdminRemove(address _Admin) external onlyOwner { Admin[_Admin] = false; }\n\n    /**\n     * @dev onlyOwner: Withdraws All Ether From The Contract\n     */\n    function ___WithdrawEther() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }\n\n    /**\n     * @dev onlyOwner: Withdraws Ether From Contract To Address With An Amount\n     */\n    function ___WithdrawEtherToAddress(address payable Recipient, uint Amount) external onlyOwner\n    {\n        require(Amount > 0 && Amount <= address(this).balance, \"Invalid Amount\");\n        (bool Success, ) = Recipient.call{value: Amount}(\"\");\n        require(Success, \"Unable to Withdraw, Recipient May Have Reverted\");\n    }\n\n    /**\n     * @dev Withdraws ERC721s From Contract\n     */\n    function ___WithdrawERC721(address Contract, address Recipient, uint[] calldata TokenIDs) external onlyOwner \n    { \n        for(uint TokenID; TokenID < TokenIDs.length;)\n        {\n            IERC721(Contract).transferFrom(address(this), Recipient, TokenIDs[TokenID]);\n            unchecked { TokenID++; }\n        }\n    }\n\n    /**\n     * @dev Changes The Launchpad Address\n     */\n    function ___ModifyLaunchpadAddress(address Launchpad) external onlyOwner { _____OverrideLaunchpadAddress(Launchpad); }\n\n    /*-----------------\n     * VIEW FUNCTIONS *\n    ------------------*/\n\n    /**\n     * @dev Returns Sale Information For A Given Wallet At `SaleIndex`\n     * @param SaleIndex        | The Sale Index\n     * @param Wallet           | The Currently Connected Wallet\n     * @param MaxAmount         | The Max Amount Of Tokens The User Can Purchase\n     * @param Vault            | The Vault Address\n     * @param ProofEligibility | The Proof For The BrightList\n     * @param ProofAmount      | The Proof For The MaxAmount\n     */\n    function ViewWalletSaleInformation(\n        uint SaleIndex,\n        address Wallet,\n        uint MaxAmount,\n        address Vault,\n        bytes32[] calldata ProofEligibility,\n        bytes32[] calldata ProofAmount\n    ) public view returns (_UserSaleInformation memory) {\n        uint CurrentPrice = ViewCurrentPrice(SaleIndex);\n        uint PurchasableAmount;\n        uint Priority;\n        bool Verified;\n        bool VerifiedAmount;\n        bool Active = SalesInternal[SaleIndex]._ActiveBrightList || SalesInternal[SaleIndex]._ActivePublic;\n        bool ActiveRespend = SalesInternal[SaleIndex]._ActiveRespend;\n        uint Credit = ViewPendingCredit(SaleIndex, Wallet);\n        if(Vault != address(0)) { if(IDelegationRegistry(_DR).checkDelegateForAll(Wallet, Vault)) { Wallet = Vault; } }\n        uint UserPurchasedAmount = UserInfo[SaleIndex][Wallet]._PurchasedAmount;\n        if(MaxAmount < UserPurchasedAmount) { MaxAmount = UserPurchasedAmount; }\n        PurchasableAmount = MaxAmount - UserPurchasedAmount;\n        (Verified, Priority) = ViewBrightListStatus(SaleIndex, Wallet, ProofEligibility);\n        uint PriorityPurchasedAmount = PriorityPurchaseAmount[SaleIndex][Wallet][Priority];\n        if(Verified) { VerifiedAmount = VerifyAmount(Wallet, MaxAmount, SaleParams[SaleIndex]._RootsAmounts[Priority], ProofAmount); }\n        return(\n            _UserSaleInformation(\n                UserInfo[SaleIndex][Wallet]._UserOrderIndexes,                                // The User's Order Indexes\n                UserPurchasedAmount,                                                          // The User's Total Purchase Amount For `SaleIndex`\n                PurchasableAmount,                                                            // The User's Purchasable Amount                          \n                UserInfo[SaleIndex][Wallet]._ClaimIndex,                                      // The User's Claim Index\n                Sales[SaleIndex]._MaximumAvailableForSale - SaleState[SaleIndex]._AmountSold, // The Remaining Amount Available For Sale\n                CurrentPrice,                                                                 // The Current Price Of A Sale\n                Priority,                                                                     // The Priority The User Is Eligible For\n                PriorityPurchasedAmount,                                                      // The Amount The User Has Purchased At The Priority  \n                Credit,                                                                       // The User's Pending Credit Available To Use Towards Next Purchase\n                Verified,                                                                     // If The User Is Eligible For BrightList\n                VerifiedAmount,                                                               // If The User Is Eligible For The MaxAmount\n                ActiveRespend,\n                Active                                                                        // If The Sale Is Active\n            )\n        );\n    }\n    \n    /**\n     * @dev Batch Returns Multiple Sale Informations For A User\n     */\n    function ViewWalletSaleInformations(\n        uint[] calldata SaleIndexes, \n        address Wallet, \n        uint[] calldata MaxAmounts, \n        address Vault, \n        bytes32[][] calldata ProofEligibilities, \n        bytes32[][] calldata ProofAmounts\n    ) public view returns(_UserSaleInformation[] memory)\n    {\n        require(\n            SaleIndexes.length == MaxAmounts.length \n            && \n            MaxAmounts.length == ProofEligibilities.length \n            && \n            ProofEligibilities.length == ProofAmounts.length, \n            \"DutchMarketplace: Array Lengths Must Match\"\n        );\n        _UserSaleInformation[] memory _UserSaleInformations = new _UserSaleInformation[](SaleIndexes.length);\n        for(uint x; x < SaleIndexes.length; x++)\n        {\n            _UserSaleInformations[x] = ViewWalletSaleInformation(\n                SaleIndexes[x],\n                Wallet,\n                MaxAmounts[x],\n                Vault,\n                ProofEligibilities[x],\n                ProofAmounts[x]\n            );\n        }\n        return _UserSaleInformations;\n    }\n\n    /**\n     * @dev Returns All Orders Of `SaleIndex` Within A Range `StartingIndex` & `EndingIndex` Inclusive\n     */\n    function ViewOrders(uint SaleIndex) external view returns (Order[] memory) { return Orders[SaleIndex]; }\n\n    /**\n     * @dev Returns All Orders Of `SaleIndex` Within A Range `StartingIndex` & `EndingIndex` Inclusive\n     */\n    function ViewOrdersInRange(uint SaleIndex, uint StartingIndex, uint EndingIndex) external view returns (Order[] memory) \n    { \n        uint Range = EndingIndex - StartingIndex;\n        Order[] memory _Orders = new Order[](Range);\n        for(uint x; x < Range; x++) { _Orders[x] = Orders[SaleIndex][StartingIndex+x]; }\n        return _Orders; \n    }\n\n    /**\n     * @dev Returns A [][] Of All Orders On Multiple SaleIndexes Within A Range `StartingIndex` & `EndingIndex` Inclusive\n     */\n    function ViewAllOrders(uint[] calldata SaleIndexes, uint StartingIndex, uint EndingIndex) external view returns (Order[][] memory)\n    {\n        Order[][] memory __Orders = new Order[][](EndingIndex-StartingIndex);\n        for(uint SaleIndex; SaleIndex <= SaleIndexes.length; SaleIndex++) { __Orders[SaleIndex] = Orders[SaleIndex]; }\n        return __Orders;\n    }\n\n    /**\n     * @dev Returns Sale Index By NFT Contract Address\n     */\n    function ViewSaleIndexByNFTAddress(address NFT) public view returns (uint)\n    {\n        uint SaleIndex = NFTAddressToSaleIndex[NFT];\n        if(SaleIndex != 0) { return SaleIndex; }\n        return 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff; // type(uint).max\n    }\n\n    /**\n     * @dev Returns an [] Of Sale States\n     */\n    function ViewSaleStates(uint[] calldata SaleIndexes) public view returns (Sale[] memory, Info[] memory)\n    {\n        Sale[] memory _Sales = new Sale[](SaleIndexes.length);\n        Info[] memory _Infos = new Info[](SaleIndexes.length);\n        bool Active;\n        for(uint x; x < SaleIndexes.length; x++) \n        { \n            Active = SalesInternal[SaleIndexes[x]]._ActivePublic || SalesInternal[SaleIndexes[x]]._ActiveBrightList;\n            _Sales[x] = Sales[SaleIndexes[x]]; \n            _Infos[x] = Info(\n                ViewCurrentPrice(SaleIndexes[x]),\n                Sales[SaleIndexes[x]]._MaximumAvailableForSale,\n                Sales[SaleIndexes[x]]._MaximumAvailableForSale - SaleState[SaleIndexes[x]]._AmountSold,\n                Active\n            );\n        }\n        return (_Sales, _Infos);\n    }\n\n    /**\n     * @dev Returns The Current Pending Credit / Rebate Of A User (With No Discount) Until The Sale Has Concluded.\n     * note: When The Final Clearing Price Is Seeded, This Function Switches To Show The User's Final Rebate (With Discounts If Eligible)\n     */\n    function ViewPendingCredit(uint SaleIndex, address Wallet) public view returns (uint)\n    {\n        uint CurrentPrice = ViewCurrentPrice(SaleIndex);\n        uint TotalCredit;\n        uint FinalClearingPrice = SaleState[SaleIndex]._FinalClearingPrice;\n        uint[] memory _UserOrderIndexes = UserInfo[SaleIndex][Wallet]._UserOrderIndexes;\n        uint[] memory _DiscountAmounts = SaleParams[SaleIndex]._DiscountAmounts;\n        for(uint ClaimIndex; ClaimIndex < _UserOrderIndexes.length; ClaimIndex++)\n        {\n            Order memory _Order = Orders[SaleIndex][_UserOrderIndexes[ClaimIndex]];\n            if(FinalClearingPrice > 0 && _Order._BrightListPurchase) \n            {\n                TotalCredit += _Order._PurchaseValue - \n                (\n                    ((SaleState[SaleIndex]._FinalClearingPrice * _DiscountAmounts[_Order._Priority]) / 100)\n                    * \n                    _Order._PurchaseAmount\n                );\n            }\n            else { TotalCredit += (_Order._PurchaseValue - (_Order._PurchaseAmount * CurrentPrice)); }\n        }\n        return TotalCredit;\n    }\n\n    /**\n     * @dev Returns An [] Of Internal Sale States\n     */\n    function ViewInternalSaleStates(uint[] calldata SaleIndexes) public view returns (InternalSale[] memory)\n    {\n        InternalSale[] memory _InternalSales = new InternalSale[](SaleIndexes.length);\n        for(uint x; x < SaleIndexes.length; x++) { _InternalSales[x] = SalesInternal[SaleIndexes[x]]; }\n        return _InternalSales;\n    }\n\n    /**\n     * @dev Returns Current Dutch Price For Sale Index\n     */\n    function ViewCurrentPrice(uint SaleIndex) public view returns (uint Price)\n    {\n        if(block.timestamp <= Sales[SaleIndex]._StartingBlockUnixTimestamp) { return Sales[SaleIndex]._PriceStart; }  // Sale Not Started\n        if(SaleState[SaleIndex]._FinalClearingPrice > 0) { return SaleState[SaleIndex]._FinalClearingPrice; } // Sale Finished\n        uint CurrentPrice = Sales[SaleIndex]._PriceStart; // Initiates Current Price\n        uint SecondsElapsed = block.timestamp - Sales[SaleIndex]._StartingBlockUnixTimestamp; // Unix Seconds Elapsed At Current Query Timestamp\n        CurrentPrice >>= SecondsElapsed / Sales[SaleIndex]._SecondsBetweenPriceDecay; // Div/2 For Each Half Life Iterated Upon\n        CurrentPrice -= (CurrentPrice * (SecondsElapsed % Sales[SaleIndex]._SecondsBetweenPriceDecay)) / Sales[SaleIndex]._SecondsBetweenPriceDecay / 2;\n        if(CurrentPrice <= Sales[SaleIndex]._PriceEnd) { return Sales[SaleIndex]._PriceEnd; } // Sale Ended At Resting Band\n        return CurrentPrice; // Sale Currently Active\n    }\n\n    /**\n     * @dev Returns All Order Information Including Addresses And Corresponding Refund Amounts\n     */\n    function ViewAllOrderRefunds(uint SaleIndex) public view returns (address[] memory, uint[] memory)\n    {\n        address[] memory Addresses = new address[](SaleState[SaleIndex]._UniqueSales);\n        uint[] memory Refunds = new uint[](SaleState[SaleIndex]._UniqueSales);\n        uint[] memory DiscountAmounts = SaleParams[SaleIndex]._DiscountAmounts;\n        uint CurrentPrice = ViewCurrentPrice(SaleIndex);\n        Order memory _Order;\n        for(uint OrderIndex; OrderIndex < SaleState[SaleIndex]._UniqueSales; OrderIndex++)\n        {\n            _Order = Orders[SaleIndex][OrderIndex];\n            if(_Order._BrightListPurchase)\n            {\n                Refunds[OrderIndex] = _Order._PurchaseValue - (\n                    ((SaleState[SaleIndex]._FinalClearingPrice * DiscountAmounts[_Order._Priority]) / 100) * _Order._PurchaseAmount\n                );\n            }\n            else { Refunds[OrderIndex] = _Order._PurchaseValue - (CurrentPrice * _Order._PurchaseAmount); }\n            Addresses[OrderIndex] = _Order._Purchaser;\n        }\n        return(Addresses, Refunds);\n    }\n\n    /**\n     * @dev Returns A User's Sale Stats Including Total Amount Purchased, Total Amount Spent, And Total Amount Rebated\n     * note: This Function Will Only Return Wallet Stats For A Sale That Has Concluded\n     * note: `NUM_ORDERS` Is The Final Cumulative Order Count Of `Wallet`\n     * note: `NUM_PURCHASED` Is The Total Number Of NFTs Purchased At `SaleIndex` By `Wallet`\n     * note: `FINAL_ETH_SPENT` Is The Cumulative Expended ETH Value From `Wallet` At The Conclusion Of The Sale Based On The Final Clearing Price Of The Dutch Auction\n     * note: `FINAL_ETH_REBATE` Is The Cumulative Unspent ETH That Is Rebated To `Wallet` At The Conclusion Of The Sale Based On The Final Clearing Price Of The Dutch Auction\n     * note: ETH Values Are Returned In WEI\n     * note: This Function Was A Request From The Keith Who Loves Vapes\n     */\n    function ViewSaleStats(uint SaleIndex, address Wallet) public view returns (uint NUM_ORDERS, uint NUM_PURCHASED, uint FINAL_ETH_SPENT, uint FINAL_ETH_REBATE)\n    {\n        require(SaleState[SaleIndex]._FinalClearingPrice > 0, \"Sale Not Concluded\");\n        uint CurrentPrice = ViewCurrentPrice(SaleIndex);\n        uint FinalRebate;\n        uint Spent;\n        uint NumPurchased;\n        uint OrderRebate;\n        uint FinalClearingPrice = SaleState[SaleIndex]._FinalClearingPrice;\n        uint[] memory _UserOrderIndexes = UserInfo[SaleIndex][Wallet]._UserOrderIndexes;\n        uint NumOrders = _UserOrderIndexes.length;\n        uint[] memory _DiscountAmounts = SaleParams[SaleIndex]._DiscountAmounts;\n        for(uint ClaimIndex; ClaimIndex < _UserOrderIndexes.length; ClaimIndex++)\n        {\n            Order memory _Order = Orders[SaleIndex][_UserOrderIndexes[ClaimIndex]];\n            if(FinalClearingPrice > 0 && _Order._BrightListPurchase) // brightlist priority discount\n            {\n                OrderRebate = _Order._PurchaseValue - \n                (\n                    ((SaleState[SaleIndex]._FinalClearingPrice * _DiscountAmounts[_Order._Priority]) / 100)\n                    * \n                    _Order._PurchaseAmount\n                );\n            }\n            else { OrderRebate = (_Order._PurchaseValue - (_Order._PurchaseAmount * CurrentPrice));  } // no discount\n            FinalRebate += OrderRebate;\n            Spent += (_Order._PurchaseValue - OrderRebate);\n            NumPurchased += _Order._PurchaseAmount;\n        }\n        return (NumOrders, NumPurchased, Spent, FinalRebate);\n    }\n\n    /**\n     * @dev Returns All State Parameters Of A Sale\n     */\n    function ViewAllSaleInformation(uint SaleIndex) public view returns (Sale memory, InternalSale memory, MiscSale memory, SaleParam memory, uint Price) \n    {\n        return ( Sales[SaleIndex], SalesInternal[SaleIndex], SaleState[SaleIndex], SaleParams[SaleIndex], ViewCurrentPrice(SaleIndex) );\n    }\n\n    /**\n     * @dev Returns If User Is On BrightList\n     * note: Returns BrightList Status & Best Priority Index\n     */\n    function ViewBrightListStatus(uint SaleIndex, address Recipient, bytes32[] calldata Proof) public view returns (bool, uint)\n    {\n        bool Verified;\n        bytes32 Leaf = keccak256(abi.encodePacked(Recipient));\n        for(uint PriorityIndex; PriorityIndex < SaleParams[SaleIndex]._Roots.length; PriorityIndex++) \n        { \n            Verified = MerkleProof.verify(Proof, SaleParams[SaleIndex]._Roots[PriorityIndex], Leaf); \n            if(Verified) { return (true, PriorityIndex); }\n        }\n        return (false, _DEFAULT_PRIORITY);\n    }\n\n    /**\n     * @dev Verifies Brightlist\n     */\n    function VerifyBrightList(address _Wallet, bytes32 _Root, bytes32[] calldata _Proof) public pure returns (bool)\n    {\n        bytes32 _Leaf = keccak256(abi.encodePacked(_Wallet));\n        return MerkleProof.verify(_Proof, _Root, _Leaf);\n    }\n\n    /**\n     * @dev Verifies Maximum Purchase Amount Being Passed Is Valid\n     */\n    function VerifyAmount(address _Wallet, uint _Amount, bytes32 _Root, bytes32[] calldata _Proof) public pure returns (bool)\n    {\n        bytes32 _Leaf = (keccak256(abi.encodePacked(_Wallet, _Amount)));\n        return MerkleProof.verify(_Proof, _Root, _Leaf);\n    }\n\n    /*---------------------\n     * INTERNAL FUNCTIONS *\n    ----------------------*/\n\n    /**\n     * @dev Ends A Sale\n     */\n    function ___EndSale(uint SaleIndex) internal \n    { \n        SalesInternal[SaleIndex]._ActivePublic = false; \n        SalesInternal[SaleIndex]._ActiveBrightList = false;\n    }\n\n    /**\n     * @dev Refunds `Recipient` ETH Amount `Value`\n     */\n    function __Refund(address Recipient, uint Value) internal\n    {\n        (bool Confirmed,) = Recipient.call{value: Value}(\"\"); \n        require(Confirmed, \"DutchMarketplace: Refund failed\");\n        emit Refunded(Value);\n    }\n\n    /**\n     * @dev Uses ETH Unspent By A User's Previous Purchase Orders Towards A New Purchase Order\n     */\n    function __ActiveRespend(uint SaleIndex, uint CurrentPrice, uint PurchaseValue, address Recipient) internal returns (uint)\n    {\n        uint TotalCredit;\n        uint PotentialCredit;\n        uint[] memory _UserOrderIndexes = UserInfo[SaleIndex][Recipient]._UserOrderIndexes;\n        for(uint ClaimIndex; ClaimIndex < _UserOrderIndexes.length; ClaimIndex++)\n        {\n            Order memory _Order = Orders[SaleIndex][_UserOrderIndexes[ClaimIndex]];\n            require(Recipient == _Order._Purchaser, \"DutchMarketplace: Invalid State\");\n            if(TotalCredit == PurchaseValue) { return TotalCredit; } // Returns Sufficient Credit For Entire Purchase Order\n            else\n            {\n                PotentialCredit = _Order._PurchaseValue - (_Order._PurchaseAmount * CurrentPrice); \n                if(PotentialCredit + TotalCredit > PurchaseValue) { PotentialCredit = PurchaseValue - TotalCredit; } // Only Pull As Much Credit As Needed\n                Orders[SaleIndex][_UserOrderIndexes[ClaimIndex]]._PurchaseValue = _Order._PurchaseValue - PotentialCredit;\n                TotalCredit += PotentialCredit;\n            }\n        }\n        return TotalCredit; // Returns The Total Amount Of Credit Available\n    }\n\n    /*------------------\n     * ACCESS MODIFIER *\n    -------------------*/\n\n    modifier onlyAdmin\n    {\n        require(Admin[msg.sender] || msg.sender == _LAUNCHPAD || msg.sender == owner());\n        _;\n    }\n}\ninterface IERC20 { function approve(address From, address To, uint Amount) external; }\ninterface IERC721 \n{ \n    /**\n     * @dev MintPass Factory Direct Mint\n     */\n    function _MintToFactory(uint ProjectID, address To, uint Amount) external;\n\n    /**\n     * @dev MintPass Factory Mint Pack Direct Mint\n     */\n    function _MintToFactoryPack(uint ProjectID, address To, uint Amount) external;\n\n    /**\n     * @dev MintPass Factory Mint Pack Direct Mint For Bespoke Mint Passes\n     */\n    function _MintToBespoke(address To, uint Amount) external;\n\n    /**\n     * @dev Standard ERC721 Transfer\n     */\n    function transferFrom(address From, address To, uint TokenID) external; \n\n    /**\n     * @dev ArtBlocks purchaseTo() Function\n     */\n    function purchaseTo(address _to, uint256 _ProjectIDMintPass) external payable returns (uint256 _tokenId);\n}\ninterface IDelegationRegistry\n{\n    /**\n     * @dev Checks If A Vault Has Delegated To The Delegate\n     */\n    function checkDelegateForAll(address delegate, address delegator) external view returns (bool);\n}"}}, "settings": {"viaIR": true, "optimizer": {"enabled": true, "runs": 200}, "outputSelection": {"*": {"*": ["abi", "metadata", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers", "evm.legacyAssembly", "evm.bytecode.opcodes"]}}, "libraries": {}, "metadata": {"appendCBOR": false}}}