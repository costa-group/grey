{"language": "Solidity", "sources": {"@kleros/erc-792/contracts/erc-1497/IEvidence.sol": {"content": "/**\n * @authors: [@ferittuncer, @hbarcelos]\n * @reviewers: []\n * @auditors: []\n * @bounties: []\n * @deployments: []\n * SPDX-License-Identifier: MIT\n */\npragma solidity ^0.8.30;\n\nimport \"../IArbitrator.sol\";\n\n/** @title IEvidence\n *  ERC-1497: Evidence Standard\n */\ninterface IEvidence {\n    /**\n     * @dev To be emitted when meta-evidence is submitted.\n     * @param _metaEvidenceID Unique identifier of meta-evidence.\n     * @param _evidence IPFS path to metaevidence, example: '/ipfs/Qmarwkf7C9RuzDEJNnarT3WZ7kem5bk8DZAzx78acJjMFH/metaevidence.json'\n     */\n    event MetaEvidence(uint256 indexed _metaEvidenceID, string _evidence);\n\n    /**\n     * @dev To be raised when evidence is submitted. Should point to the resource (evidences are not to be stored on chain due to gas considerations).\n     * @param _arbitrator The arbitrator of the contract.\n     * @param _evidenceGroupID Unique identifier of the evidence group the evidence belongs to.\n     * @param _party The address of the party submiting the evidence. Note that 0x0 refers to evidence not submitted by any party.\n     * @param _evidence IPFS path to evidence, example: '/ipfs/Qmarwkf7C9RuzDEJNnarT3WZ7kem5bk8DZAzx78acJjMFH/evidence.json'\n     */\n    event Evidence(\n        IArbitrator indexed _arbitrator,\n        uint256 indexed _evidenceGroupID,\n        address indexed _party,\n        string _evidence\n    );\n\n    /**\n     * @dev To be emitted when a dispute is created to link the correct meta-evidence to the disputeID.\n     * @param _arbitrator The arbitrator of the contract.\n     * @param _disputeID ID of the dispute in the Arbitrator contract.\n     * @param _metaEvidenceID Unique identifier of meta-evidence.\n     * @param _evidenceGroupID Unique identifier of the evidence group that is linked to this dispute.\n     */\n    event Dispute(\n        IArbitrator indexed _arbitrator,\n        uint256 indexed _disputeID,\n        uint256 _metaEvidenceID,\n        uint256 _evidenceGroupID\n    );\n}\n"}, "@kleros/erc-792/contracts/IArbitrable.sol": {"content": "/**\n * @authors: [@ferittuncer, @hbarcelos]\n * @reviewers: [@remedcu]\n * @auditors: []\n * @bounties: []\n * @deployments: []\n * SPDX-License-Identifier: MIT\n */\npragma solidity ^0.8.30;\n\nimport \"./IArbitrator.sol\";\n\n/**\n * @title IArbitrable\n * Arbitrable interface.\n * When developing arbitrable contracts, we need to:\n * - Define the action taken when a ruling is received by the contract.\n * - Allow dispute creation. For this a function must call arbitrator.createDispute{value: _fee}(_choices,_extraData);\n */\ninterface IArbitrable {\n    /**\n     * @dev To be raised when a ruling is given.\n     * @param _arbitrator The arbitrator giving the ruling.\n     * @param _disputeID ID of the dispute in the Arbitrator contract.\n     * @param _ruling The ruling which was given.\n     */\n    event Ruling(IArbitrator indexed _arbitrator, uint256 indexed _disputeID, uint256 _ruling);\n\n    /**\n     * @dev Give a ruling for a dispute. Must be called by the arbitrator.\n     * The purpose of this function is to ensure that the address calling it has the right to rule on the contract.\n     * @param _disputeID ID of the dispute in the Arbitrator contract.\n     * @param _ruling Ruling given by the arbitrator. Note that 0 is reserved for \"Not able/wanting to make a decision\".\n     */\n    function rule(uint256 _disputeID, uint256 _ruling) external;\n}\n"}, "@kleros/erc-792/contracts/IArbitrator.sol": {"content": "/**\n * @authors: [@ferittuncer, @hbarcelos]\n * @reviewers: [@remedcu]\n * @auditors: []\n * @bounties: []\n * @deployments: []\n * SPDX-License-Identifier: MIT\n */\n\npragma solidity ^0.8.30;\n\nimport \"./IArbitrable.sol\";\n\n/**\n * @title Arbitrator\n * Arbitrator abstract contract.\n * When developing arbitrator contracts we need to:\n * - Define the functions for dispute creation (createDispute) and appeal (appeal). Don't forget to store the arbitrated contract and the disputeID (which should be unique, may nbDisputes).\n * - Define the functions for cost display (arbitrationCost and appealCost).\n * - Allow giving rulings. For this a function must call arbitrable.rule(disputeID, ruling).\n */\ninterface IArbitrator {\n    enum DisputeStatus {\n        Waiting,\n        Appealable,\n        Solved\n    }\n\n    /**\n     * @dev To be emitted when a dispute is created.\n     * @param _disputeID ID of the dispute.\n     * @param _arbitrable The contract which created the dispute.\n     */\n    event DisputeCreation(uint256 indexed _disputeID, IArbitrable indexed _arbitrable);\n\n    /**\n     * @dev To be emitted when a dispute can be appealed.\n     * @param _disputeID ID of the dispute.\n     * @param _arbitrable The contract which created the dispute.\n     */\n    event AppealPossible(uint256 indexed _disputeID, IArbitrable indexed _arbitrable);\n\n    /**\n     * @dev To be emitted when the current ruling is appealed.\n     * @param _disputeID ID of the dispute.\n     * @param _arbitrable The contract which created the dispute.\n     */\n    event AppealDecision(uint256 indexed _disputeID, IArbitrable indexed _arbitrable);\n\n    /**\n     * @dev Create a dispute. Must be called by the arbitrable contract.\n     * Must be paid at least arbitrationCost(_extraData).\n     * @param _choices Amount of choices the arbitrator can make in this dispute.\n     * @param _extraData Can be used to give additional info on the dispute to be created.\n     * @return disputeID ID of the dispute created.\n     */\n    function createDispute(uint256 _choices, bytes calldata _extraData) external payable returns (uint256 disputeID);\n\n    /**\n     * @dev Compute the cost of arbitration. It is recommended not to increase it often, as it can be highly time and gas consuming for the arbitrated contracts to cope with fee augmentation.\n     * @param _extraData Can be used to give additional info on the dispute to be created.\n     * @return cost Amount to be paid.\n     */\n    function arbitrationCost(bytes calldata _extraData) external view returns (uint256 cost);\n\n    /**\n     * @dev Appeal a ruling. Note that it has to be called before the arbitrator contract calls rule.\n     * @param _disputeID ID of the dispute to be appealed.\n     * @param _extraData Can be used to give extra info on the appeal.\n     */\n    function appeal(uint256 _disputeID, bytes calldata _extraData) external payable;\n\n    /**\n     * @dev Compute the cost of appeal. It is recommended not to increase it often, as it can be higly time and gas consuming for the arbitrated contracts to cope with fee augmentation.\n     * @param _disputeID ID of the dispute to be appealed.\n     * @param _extraData Can be used to give additional info on the dispute to be created.\n     * @return cost Amount to be paid.\n     */\n    function appealCost(uint256 _disputeID, bytes calldata _extraData) external view returns (uint256 cost);\n\n    /**\n     * @dev Compute the start and end of the dispute's current or next appeal period, if possible. If not known or appeal is impossible: should return (0, 0).\n     * @param _disputeID ID of the dispute.\n     * @return start The start of the period.\n     * @return end The end of the period.\n     */\n    function appealPeriod(uint256 _disputeID) external view returns (uint256 start, uint256 end);\n\n    /**\n     * @dev Return the status of a dispute.\n     * @param _disputeID ID of the dispute to rule.\n     * @return status The status of the dispute.\n     */\n    function disputeStatus(uint256 _disputeID) external view returns (DisputeStatus status);\n\n    /**\n     * @dev Return the current ruling of a dispute. This is useful for parties to know if they should appeal.\n     * @param _disputeID ID of the dispute.\n     * @return ruling The ruling which has been given or the one which will be given if there is no appeal.\n     */\n    function currentRuling(uint256 _disputeID) external view returns (uint256 ruling);\n}\n"}, "contracts/extending-old/ForkModule.sol": {"content": "/** @authors: []\n *  @reviewers: []\n *  @auditors: []\n *  @bounties: []\n *  @deployments: []\n *  SPDX-License-Identifier: MIT\n */\n\npragma solidity ^0.8.30;\n\nimport {CappedMath} from \"../libraries/CappedMath.sol\";\nimport {IForkModule} from \"../interfaces/IForkModule.sol\";\nimport {IProofOfHumanityOld} from \"../interfaces/IProofOfHumanityOld.sol\";\n\n/** @title ForkModule\n *\n *  PoHV2 functions which interact with the old PoH contract.\n *  * -> Part of process of potential removal   |   *** -> Includes removal\n *  ccGrantHumanity\n *  ccDischargeHumanity ***\n *  claimHumanity\n *  revokeHumanity *\n *  advanceState   *\n *  executeRequest ***\n *  processVouches ***\n *  rule           ***\n */\ncontract ForkModule is IForkModule {\n    using CappedMath for uint40;\n\n    /// ====== STORAGE ====== ///\n\n    /// @dev Indicates that the contract has been initialized.\n    bool public initialized;\n\n    /// @dev PoH v1 contract instance.\n    IProofOfHumanityOld public proofOfHumanityV1;\n\n    /// @dev Address of PoH v2 contract instance.\n    address public proofOfHumanityV2;\n\n    /// @dev The submissionDuration fetched from PoH v1 at the initialization of this contract.\n    uint40 public submissionDuration;\n\n    /// @dev The time when the fork is considered as started.\n    uint40 public forkTime;\n\n    /// @dev The removed flag used to overwrite the v1 submission status.\n    mapping(address => bool) public removed;\n\n\n    /* Modifiers */\n\n    modifier initializer() {\n        require(!initialized);\n        initialized = true;\n        _;\n    }\n\n    modifier onlyV2() {\n        require(msg.sender == address(proofOfHumanityV2), \"!poh\");\n        _;\n    }\n\n    /// ====== CONSTRUCTOR ====== ///\n\n    /** @notice Initializes the ForkModule contract.\n     *  @param _proofOfHumanityV1 The address of the PoH v1 contract.\n     *  @param _proofOfHumanityV2 The address of the PoH v2 contract.\n     */\n    function initialize(address _proofOfHumanityV1, address _proofOfHumanityV2) public payable initializer {\n        proofOfHumanityV1 = IProofOfHumanityOld(_proofOfHumanityV1);\n        proofOfHumanityV2 = _proofOfHumanityV2;\n\n        forkTime = uint40(block.timestamp);\n\n        submissionDuration = uint40(proofOfHumanityV1.submissionDuration());\n    }\n\n    /// ====== FUNCTIONS ====== ///\n\n    /** @dev Directly mark a submission as removed.\n     *  @dev Called when removing as result of finalized revocation request or bad vouching.\n     *\n     *  @param _submissionID The address of the submission to mark as removed.\n     */\n    function remove(address _submissionID) external override onlyV2 {\n        removed[_submissionID] = true;\n    }\n\n    /** @dev Remove a submission because of a transfer request. Should revert in case of not meeting conditions.\n     *  @dev Returns expirationTime for better interaction with PoHv2 instance.\n     *\n     *  @dev Requirements:\n     *  - Submission must be registered in v1.\n     *\n     *  @param _submissionID Address corresponding to the human.\n     *  @return expirationTime Expiration time of the revoked humanity. Used for.\n     */\n    function tryRemove(address _submissionID) external override onlyV2 returns (uint40 expirationTime) {\n        require(!removed[_submissionID], \"removed!\");\n\n        (, uint64 submissionTime, , bool registered, , ) = proofOfHumanityV1.getSubmissionInfo(_submissionID);\n\n        expirationTime = uint40(submissionTime).addCap40(submissionDuration);\n\n        require(registered && block.timestamp < expirationTime && submissionTime < forkTime, \"registered!\");\n\n        removed[_submissionID] = true;\n    }\n\n    /// ====== VIEWS ====== ///\n\n    /** @dev Return true if the submission is registered on v1 and not removed here and not expired.\n     *  @param _submissionID The address of the submission.\n     *  @return Whether the submission is registered or not.\n     */\n    function isRegistered(address _submissionID) external view override returns (bool) {\n        if (removed[_submissionID]) return false;\n\n        (, uint64 submissionTime, , bool registered, , ) = proofOfHumanityV1.getSubmissionInfo(_submissionID);\n\n        uint40 expirationTime = uint40(submissionTime).addCap40(submissionDuration);\n\n        return registered && block.timestamp < expirationTime && submissionTime < forkTime;\n    }\n\n    /** @dev Returns the registration status and the expiration time of the submission.\n     *  @param _submissionID The address of the queried submission.\n     */\n    function getSubmissionInfo(\n        address _submissionID\n    ) external view override returns (bool registered, uint40 expirationTime) {\n        (, uint64 submissionTime, , bool registeredOnV1, , ) = proofOfHumanityV1.getSubmissionInfo(_submissionID);\n\n        expirationTime = uint40(submissionTime).addCap40(submissionDuration);\n\n        if (registeredOnV1 && expirationTime > block.timestamp)\n            registered = !removed[_submissionID] && submissionTime < forkTime;\n    }\n}\n"}, "contracts/extending-old/ProofOfHumanityExtended.sol": {"content": "/** @authors: [@andreimvp]\n *  @reviewers: [@unknownunknown1, @shotaronowhere*, @gratestas, Param, @fnanni-0*]\n *  @auditors: []\n *  @bounties: []\n *  @deployments: []\n *  SPDX-License-Identifier: MIT\n */\n\npragma solidity ^0.8.30;\n\nimport {IArbitrable} from \"@kleros/erc-792/contracts/IArbitrable.sol\";\nimport {IEvidence} from \"@kleros/erc-792/contracts/erc-1497/IEvidence.sol\";\nimport {IArbitrator} from \"@kleros/erc-792/contracts/IArbitrator.sol\";\n\nimport {IProofOfHumanity} from \"../interfaces/IProofOfHumanity.sol\";\nimport {SafeSend} from \"../libraries/SafeSend.sol\";\nimport {CappedMath} from \"../libraries/CappedMath.sol\";\n\nimport {IForkModule} from \"./ForkModule.sol\";\n\n/** @title ProofOfHumanity\n *  This contract is a curated registry for people. The users are identified by their address and can be added or removed through the request-challenge protocol.\n *  In order to challenge a registration request the challenger must provide one of the four reasons.\n *  New registration requests firstly should gain sufficient amount of vouches from other registered users and only after that they can be accepted or challenged.\n *  The users who vouched for a human that lost the challenge with the reason Duplicate or DoesNotExist would be penalized with optional fine or ban period.\n *  @notice This contract trusts that the Arbitrator is honest and will not reenter or modify its costs during a call.\n *  The arbitrator must support appeal period.\n */\ncontract ProofOfHumanityExtended is IProofOfHumanity, IArbitrable, IEvidence {\n    using SafeSend for address payable;\n    using CappedMath for uint256;\n    using CappedMath for uint40;\n\n    /// ====== CONSTANTS ====== ///\n\n    /// @dev The amount of non-zero choices the arbitrator can give.\n    uint256 private constant RULING_OPTIONS = 2;\n\n    /// @dev The number of vouches that will be automatically processed when executing a request.\n    uint256 private constant VOUCHES_TO_AUTOPROCESS = 10;\n\n    /// @dev Indicates that reasons' bitmap is full. 0b1111.\n    uint256 private constant FULL_REASONS_SET = 15;\n\n    /// @dev Divisor parameter for multipliers.\n    uint256 private constant MULTIPLIER_DIVISOR = 10000;\n\n    /// @dev The EIP-712 domainSeparator specific to this deployed instance. It is used to verify the IsHumanVoucher's signature.\n    bytes32 private DOMAIN_SEPARATOR;\n\n    /// @dev The EIP-712 typeHash of IsHumanVoucher == keccak256(\"IsHumanVoucher(address vouched,bytes20 humanityId,uint256 expirationTimestamp)\").\n    bytes32 private constant IS_HUMAN_VOUCHER_TYPEHASH =\n        0x396b8143cb24d01c85cbad0682e0e83f2ea427a5b3cd56872e8e1b2a55d4c2ab;\n\n    /// ====== ENUMS ====== ///\n\n    enum Party {\n        None, // Party per default when there is no challenger or requester. Also used for unconclusive ruling.\n        Requester, // Party that made the request to change a status.\n        Challenger // Party that challenged the request to change a status.\n    }\n\n    enum Reason {\n        None, // No reason specified. This option should be used to challenge removal requests.\n        IncorrectSubmission, // Request does not comply with the rules.\n        IdentityTheft, // Attempt to claim the humanity ID of another human.\n        SybilAttack, // Duplicate or human does not exist.\n        Deceased // Human has existed but does not exist anymore.\n    }\n\n    enum Status {\n        Vouching, // Request requires vouches / funding to advance to the next state. Should not be in this state for revocation requests.\n        Resolving, // Request is resolving and can be challenged within the time limit.\n        Disputed, // Request has been challenged.\n        Resolved // Request has been resolved.\n    }\n\n    /// ====== STRUCTS ====== ///\n\n    /** @dev A human makes requests to become the owner of the humanity.\n     *  @dev Multiple claimers can be in the claiming process at the same time. Only one request can be pending at a time.\n     *  @dev Owner must be in this struct in order to know the real owner during renewal process.\n     */\n    struct Humanity {\n        address owner; // Address corresponding to the humanity.\n        uint40 expirationTime; // Time when the humanity expires.\n        uint40 lastFailedRevocationTime; // Resolution time for last failed revocation request.\n        uint16 nbPendingRequests; // Number of pending requests in challenging phase.\n        bool vouching; // True if the human used its vouch for another human. This is set back to false once the vouch is processed.\n        bool pendingRevocation; // True if the human is in the process of revocation.\n        mapping(address => uint256) requestCount; // Mapping of the claimer address to the total number of requests at the moment of the claim.\n        Request[] requests; // Array of the ids to corresponding requests.\n    }\n\n    struct Request {\n        bool revocation; // True if the request is a revocation request. False if it is a renewal request.\n        Status status; // Current status of the request.\n        Reason currentReason; // Current reason a claim request was challenged with. Is left empty for removal requests.\n        uint8 usedReasons; // Bitmap of the reasons used by challengers of this request.\n        uint16 arbitratorDataId; // Index of the relevant arbitratorData struct. All the arbitrator info is stored in a separate struct to reduce gas cost.\n        uint16 lastChallengeId; // Id of the last challenge, which is equal to the total number of challenges for the request.\n        uint32 lastProcessedVouch; // Stores the index of the last processed vouch in the array of vouches. It is used for partial processing of the vouches in resolved requests.\n        address payable requester; // Address that made the request.\n        address payable ultimateChallenger; // Address of the challenger who won a dispute. Users who vouched for the challenged human must pay the fines to this address.\n        uint40 challengePeriodStart; // Time when the request can be challenged.\n        bool punishedVouch; // True if the requester was punished for bad vouching during a claim request.\n        bytes20[] vouches; // Stores the unique Ids of humans that vouched for this request and whose vouches were used in this request.\n        mapping(uint256 => Challenge) challenges; // Stores all the challenges of this request. challengeId -> Challenge.\n    }\n\n    struct ContributionsSet {\n        uint256 forRequester; // Amount of contributions made for the requester.\n        uint256 forChallenger; // Amount of contributions made for the challenger.\n    }\n\n    struct Round {\n        Party sideFunded; // Stores the side that successfully paid the appeal fees in the latest round. Note that if both sides have paid a new round is created.\n        uint256 feeRewards; // Sum of reimbursable fees and stake rewards available to the parties that made contributions to the side that ultimately wins a dispute.\n        ContributionsSet paidFees; // Tracks the fees paid by each side in this round.\n        mapping(address => ContributionsSet) contributions; // Maps contributors to their contributions for each side.\n    }\n\n    struct Challenge {\n        uint16 lastRoundId; // Id of the last round.\n        Party ruling; // Ruling given by the arbitrator of the dispute.\n        address payable challenger; // Address that challenged the request.\n        uint256 disputeId; // Id of the dispute related to the challenge.\n        mapping(uint256 => Round) rounds; // Tracks the info of each funding round of the challenge.\n    }\n\n    // The data tied to the arbitrator that will be needed to recover the info for arbitrator's call.\n    struct DisputeData {\n        uint96 requestId; // The Id of the request.\n        uint96 challengeId; // The Id of the challenge of the request.\n        bytes20 humanityId; // The Id of the humanity involving the disputed request.\n    }\n\n    struct ArbitratorData {\n        uint96 metaEvidenceUpdates; // Reference to the meta evidence to be used in disputes.\n        IArbitrator arbitrator; // Address of the trusted arbitrator to solve disputes.\n        bytes arbitratorExtraData; // Extra data for the arbitrator.\n    }\n\n    struct SignatureVouch {\n        uint40 expirationTime; // Time when the signature expires.\n        uint8 v; // `v` value of the signature.\n        bytes32 r; // `r` value of the signature.\n        bytes32 s; // `s` value of the signature.\n    }\n\n    /// ====== STORAGE ====== ///\n\n    /// @dev Address of wrapped version of the chain's native currency. WETH-like.\n    address public wNative;\n\n    /// @dev Indicates that the contract has been initialized.\n    bool public initialized;\n\n    /// @dev The address that can make governance changes to the parameters of the contract.\n    address public governor;\n\n    /// @dev The address of the CrossChainProofOfHumanity instance.\n    address public crossChainProofOfHumanity;\n\n    /// @dev The base deposit to make a new request for a humanity.\n    uint256 public requestBaseDeposit;\n\n    /// @dev Time after which the humanity will no longer be considered claimed. The human has to renew the humanity to refresh it.\n    uint40 public humanityLifespan;\n    /// @dev  The duration of the period when the registered humanity can be renewed.\n    uint40 public renewalPeriodDuration;\n    /// @dev The time after which a request becomes executable if not challenged.\n    uint40 public challengePeriodDuration;\n\n    /// @dev Cooldown after which a revocation request can be made after a previously failed one.\n    /// @dev Used to avoid exploiting revocation functionality to evade transfer requests.\n    uint40 public failedRevocationCooldown;\n\n    /// @dev The number of registered users that have to vouch for a new claim request in order for it to advance beyond Vouching state.\n    uint32 public requiredNumberOfVouches;\n\n    /// @dev Multiplier for calculating the fee stake that must be paid in the case where arbitrator refused to arbitrate.\n    uint256 public sharedStakeMultiplier;\n    /// @dev Multiplier for calculating the fee stake paid by the party that won the previous round.\n    uint256 public winnerStakeMultiplier;\n    /// @dev Multiplier for calculating the fee stake paid by the party that lost the previous round.\n    uint256 public loserStakeMultiplier;\n\n    /// @dev Fork Module instance to be used for interacting with v1 state.\n    IForkModule private forkModule;\n\n    /// @dev Gap for possible future versions storage layout changes.\n    /// @notice Decremented gap one because of fork module variable above.\n    uint256[49] internal __gap;\n\n    /// @dev Stores the arbitrator data of the contract. Updated each time the data is changed.\n    ArbitratorData[] public arbitratorDataHistory;\n\n    /// @dev Maps the humanity id to the Humanity data. humanityData[humanityId].\n    mapping(bytes20 => Humanity) private humanityData;\n\n    /// @dev Maps the address to the humanityId. It includes mapping to the humanity the owner or the account is in process of claiming. accountHumanity[address].\n    mapping(address => bytes20) private accountHumanity;\n\n    /// @dev Indicates whether or not the voucher has vouched for a certain human. vouches[voucherAddress][claimerAddress][humanityId].\n    mapping(address => mapping(address => mapping(bytes20 => bool))) public vouches;\n    /// @dev Maps a dispute Id with its data. disputeIdToData[arbitrator][disputeId].\n    mapping(address => mapping(uint256 => DisputeData)) public disputeIdToData;\n\n    /* Modifiers */\n\n    modifier initializer() {\n        require(!initialized);\n        initialized = true;\n        _;\n    }\n\n    modifier onlyGovernor() {\n        require(msg.sender == governor);\n        _;\n    }\n\n    modifier onlyCrossChain() {\n        require(msg.sender == crossChainProofOfHumanity);\n        _;\n    }\n\n    /// ====== EVENTS ====== ///\n\n    /** @dev Emitted when contract is initialized.\n     */\n    event Initialized();\n\n    /** @dev Emitted when governor changed.\n     *  @param governor New governor address.\n     */\n    event GovernorChanged(address governor);\n\n    /** @dev Emitted when the request base deposit is changed.\n     *  @param requestBaseDeposit The new value of the request base deposit.\n     */\n    event RequestBaseDepositChanged(uint256 requestBaseDeposit);\n\n    /** @dev Emitted when duration related variables changed.\n     *  @param humanityLifespan The new humanity lifespan.\n     *  @param renewalPeriodDuration The new duration of renewal period.\n     *  @param challengePeriodDuration The new duration of challenge period.\n     *  @param failedRevocationCooldown The new failed revocation cooldown.\n     */\n    event DurationsChanged(\n        uint40 humanityLifespan,\n        uint40 renewalPeriodDuration,\n        uint40 challengePeriodDuration,\n        uint40 failedRevocationCooldown\n    );\n\n    /** @dev Emitted when the required number of vouches is changed.\n     *  @param requiredNumberOfVouches The new required number of vouches.\n     */\n    event RequiredNumberOfVouchesChanged(uint32 requiredNumberOfVouches);\n\n    /** @dev Emitted when the stake multipliers are changed.\n     *  @param sharedMultiplier The new shared multiplier.\n     *  @param winnerMultiplier The new winner multiplier.\n     *  @param loserMultiplier The new loser multiplier.\n     */\n    event StakeMultipliersChanged(uint256 sharedMultiplier, uint256 winnerMultiplier, uint256 loserMultiplier);\n\n    /** @dev Emitted when the cross-chain proxy is changed.\n     *  @param crossChainProofOfHumanity The new cross-chain proxy address.\n     */\n    event CrossChainProxyChanged(address crossChainProofOfHumanity);\n\n    /** @dev Emitted when the arbitrator is changed.\n     *  @param arbitrator The new arbitrator address.\n     *  @param arbitratorExtraData The new arbitrator extra data.\n     */\n    event ArbitratorChanged(IArbitrator arbitrator, bytes arbitratorExtraData);\n\n    /** @dev Emitted when humanity is granted directly via cross-chain operations.\n     *  @param humanityId The humanity ID.\n     *  @param owner The address of the owner.\n     *  @param expirationTime The expiration time of the humanity.\n     */\n    event HumanityGrantedDirectly(bytes20 indexed humanityId, address indexed owner, uint40 expirationTime);\n\n    /** @dev Emitted when humanity is revoked directly via cross-chain operations or because of bad vouching.\n     *  @param humanityId The humanity ID.\n     */\n    event HumanityDischargedDirectly(bytes20 indexed humanityId);\n\n    /** @dev Emitted when a claim request for a humanityId is made.\n     *  @param requester The address of the requester.\n     *  @param humanityId The humanity ID.\n     *  @param requestId The ID of the request.\n     *  @param name The name associated with the human.\n     */\n    event ClaimRequest(\n        address indexed requester,\n        bytes20 indexed humanityId,\n        uint256 requestId,\n        string name\n    );\n\n    /** @dev Emitted when a renewal request is made.\n     *  @param requester The address of the requester.\n     *  @param humanityId The humanity ID.\n     *  @param requestId The ID of the request.\n     */\n    event RenewalRequest(address indexed requester, bytes20 indexed humanityId, uint256 requestId);\n\n    /** @dev Emitted when a revocation request is made.\n     *  @param requester The address of the requester.\n     *  @param humanityId The humanity ID.\n     *  @param requestId The ID of the request.\n     */\n    event RevocationRequest(address indexed requester, bytes20 indexed humanityId, uint256 requestId);\n\n    /** @dev Emitted when an on-chain vouch is added.\n     *  @param voucherAccount The address of the voucher.\n     *  @param claimer The address of the claimer.\n     *  @param humanityId The humanity ID the vouch claims the claimer corresponds to.\n     */\n    event VouchAdded(address indexed voucherAccount, address indexed claimer, bytes20 humanityId);\n\n    /** @dev Emitted when an on-chain vouch is removed.\n     *  @param voucherAccount The address of the voucher.\n     *  @param claimer The address of the claimer.\n     *  @param humanityId The humanity ID.\n     */\n    event VouchRemoved(address indexed voucherAccount, address indexed claimer, bytes20 humanityId);\n\n    /** @dev Emitted when an on-chain or off-chain vouch is registered for a request.\n     *  @param voucherHumanityId The humanity ID of the voucher.\n     *  @param vouchedHumanityId The humanity ID of the vouched user.\n     *  @param requestId The ID of the request.\n     */\n    event VouchRegistered(bytes20 indexed voucherHumanityId, bytes20 indexed vouchedHumanityId, uint256 requestId);\n\n    /** @dev Emitted when a request is withdrawn.\n     *  @param humanityId The humanity ID for which the sender withdraws the request for.\n     *  @param requestId The ID of the request.\n     */\n    event RequestWithdrawn(bytes20 humanityId, uint256 requestId);\n\n    /** @dev Emitted when the state of the request is advanced from vouching to pending state for a claimer.\n     *  @param claimer The address of the claimer.\n     */\n    event StateAdvanced(address claimer);\n\n    /** @dev Emitted when a request is challenged.\n     *  @param humanityId The humanity ID.\n     *  @param requestId The ID of the request.\n     *  @param challengeId The ID of the challenge.\n     *  @param reason The reason for the challenge.\n     *  @param disputeId The created dispute ID.\n     */\n    event RequestChallenged(\n        bytes20 humanityId,\n        uint256 requestId,\n        uint256 challengeId,\n        Reason reason,\n        uint256 disputeId\n    );\n\n    /** @dev Emitted when humanity is succesfully claimed.\n     *  @param humanityId The humanity ID.\n     *  @param requestId The ID of the succesfull request.\n     */\n    event HumanityClaimed(bytes20 humanityId, uint256 requestId);\n\n    /** @dev Emitted when humanity is succesfully revoked.\n     *  @param humanityId The humanity ID.\n     *  @param requestId The ID of the succesfull request.\n     */\n    event HumanityRevoked(bytes20 humanityId, uint256 requestId);\n\n    /** @dev Emitted when vouches are processed for a request.\n     *  @param humanityId The humanity ID.\n     *  @param requestId The ID of the request.\n     *  @param endIndex The index of the last vouch processed.\n     */\n    event VouchesProcessed(bytes20 humanityId, uint256 requestId, uint256 endIndex);\n\n    /** @dev Emitted when the challenge period is restarted after an unsuccesful challenge.\n     *  @param humanityId The humanity ID.\n     *  @param requestId The ID of the request.\n     *  @param challengeId The ID of the challenge.\n     */\n    event ChallengePeriodRestart(bytes20 humanityId, uint256 requestId, uint256 challengeId);\n\n    /** @dev Emitted when an appeal is created.\n     *  @param arbitrator The arbitrator address.\n     *  @param disputeId The ID of the dispute.\n     */\n    event AppealCreated(IArbitrator arbitrator, uint256 disputeId);\n\n    /** @dev Emitted when a contribution is made to a challenge.\n     *  @param humanityId The humanity ID.\n     *  @param requestId The ID of the request.\n     *  @param challengeId The ID of the challenge.\n     *  @param round The round of the contribution.\n     *  @param contributor The address of the contributor.\n     *  @param contribution The contribution amount.\n     *  @param side The side of the contribution.\n     */\n    event Contribution(\n        bytes20 humanityId,\n        uint256 requestId,\n        uint256 challengeId,\n        uint256 round,\n        address contributor,\n        uint256 contribution,\n        Party side\n    );\n\n    /** @dev Emitted when fees and rewards are withdrawn for a challenge round. \n     *  @param humanityId The humanity ID. \n     *  @param requestId The ID of the request. \n     *  @param challengeId The ID of the challenge. \n     *  @param round The round of the challenge. \n     *  @param beneficiary The address of the beneficiary. \n     */\n    event FeesAndRewardsWithdrawn(\n        bytes20 humanityId,\n        uint256 requestId,\n        uint256 challengeId,\n        uint256 round,\n        address beneficiary\n    );\n\n    /// ====== INITIALIZATION ====== ///\n\n    /** @notice Initializes the ProofOfHumanity contract.\n     *\n     *  @dev Emits {MetaEvidence} event for the registration meta evidence.\n     *  @dev Emits {MetaEvidence} event for the clearing meta evidence.\n     *\n     *  @param _wNative The address of the wrapped version of the native currency.\n     *  @param _arbitrator The trusted arbitrator to resolve potential disputes.\n     *  @param _arbitratorExtraData Extra data for the trusted arbitrator contract.\n     *  @param _registrationMetaEvidence The URI of the meta evidence object for registration requests.\n     *  @param _clearingMetaEvidence The URI of the meta evidence object for clearing requests.\n     *  @param _requestBaseDeposit The base deposit to make a request for a humanity.\n     *  @param _humanityLifespan Time in seconds during which the claimed humanity won't automatically lose its status.\n     *  @param _renewalPeriodDuration Value that defines the duration of humanity's renewal period.\n     *  @param _challengePeriodDuration The time in seconds during which the request can be challenged.\n     *  @param _failedRevocationCooldown The time in seconds after which a revocation request can be made after a previously failed one.\n     *  @param _multipliers The array that contains fee stake multipliers to avoid 'stack too deep' error.\n     *  @param _requiredNumberOfVouches The number of vouches the human has to have to pass from Vouching to Resolving phase.\n     */\n    function initialize(\n        address _wNative,\n        IArbitrator _arbitrator,\n        bytes memory _arbitratorExtraData,\n        string memory _registrationMetaEvidence,\n        string memory _clearingMetaEvidence,\n        uint256 _requestBaseDeposit,\n        uint40 _humanityLifespan,\n        uint40 _renewalPeriodDuration,\n        uint40 _challengePeriodDuration,\n        uint40 _failedRevocationCooldown,\n        uint256[3] memory _multipliers,\n        uint32 _requiredNumberOfVouches\n    ) public payable initializer {\n        wNative = _wNative;\n        governor = msg.sender;\n        requestBaseDeposit = _requestBaseDeposit;\n        humanityLifespan = _humanityLifespan;\n        renewalPeriodDuration = _renewalPeriodDuration;\n        challengePeriodDuration = _challengePeriodDuration;\n        failedRevocationCooldown = _failedRevocationCooldown;\n        sharedStakeMultiplier = _multipliers[0];\n        winnerStakeMultiplier = _multipliers[1];\n        loserStakeMultiplier = _multipliers[2];\n        requiredNumberOfVouches = _requiredNumberOfVouches;\n\n        arbitratorDataHistory.push(\n            ArbitratorData({arbitrator: _arbitrator, arbitratorExtraData: _arbitratorExtraData, metaEvidenceUpdates: 0})\n        );\n\n        // EIP-712.\n        bytes32 DOMAIN_TYPEHASH = 0x8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866; // keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\").\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(DOMAIN_TYPEHASH, keccak256(\"Proof of Humanity\"), block.chainid, address(this))\n        );\n\n        emit Initialized();\n        emit MetaEvidence(0, _registrationMetaEvidence);\n        emit MetaEvidence(1, _clearingMetaEvidence);\n    }\n\n    /// ====== GOVERNANCE ====== ///\n\n    /** @dev Grant humanity via cross-chain instance.\n     *  @dev Returns whether humanity was not claimed (thus granted successfully) for better interaction with CrossChainPoH instance.\n     *\n     *  @dev Emits {HumanityGrantedDirectly} event.\n     *\n     *  @dev Requirements:\n     *  - Human must not be in the process of claiming a humanity.\n     *\n     *  @param _humanityId Unique id to be added.\n     *  @param _account Address of account corresponding to the humanity.\n     *  @param _expirationTime Expiration time of the newly added humanity.\n     *  @return success Whether the humanity was successfully granted.\n     */\n    function ccGrantHumanity(\n        bytes20 _humanityId,\n        address _account,\n        uint40 _expirationTime\n    ) external onlyCrossChain returns (bool success) {\n        Humanity storage humanity = humanityData[_humanityId];\n\n        // If humanity is claimed, don't overwrite.\n        if (\n            (humanity.owner != address(0x0) && block.timestamp < humanity.expirationTime) ||\n            // If not claimed in this contract, check in fork module too.\n            forkModule.isRegistered(_account)\n        ) return false;\n\n        // Must not be in the process of claiming a humanity.\n        require(humanityData[accountHumanity[_account]].requestCount[_account] == 0);\n\n        humanity.owner = _account;\n        humanity.expirationTime = _expirationTime;\n        accountHumanity[_account] = _humanityId;\n\n        emit HumanityGrantedDirectly(_humanityId, _account, _expirationTime);\n\n        return true;\n    }\n\n    /** @dev Directly remove a humanity via cross-chain instance when initiating a transfer.\n     *  @dev Returns humanityId and expirationTime for better interaction with CrossChainPoH instance.\n     *\n     *  @dev Emits {HumanityDischargedDirectly} event.\n     *\n     *  @dev Requirements:\n     *  - Owner of the humanity must be _account.\n     *  - HumanityId must not be expired.\n     *  - Humanity must have no pending requests.\n     *  - Humanity must not be vouching at the moment.\n     *\n     *  @param _account Wallet address corresponding to the humanity to be revoked.\n     *  @return humanityId Humanity ID to be revoked.\n     *  @return expirationTime Expiration time of the revoked humanity.\n     */\n    function ccDischargeHumanity(\n        address _account\n    ) external onlyCrossChain returns (bytes20 humanityId, uint40 expirationTime) {\n        humanityId = accountHumanity[_account];\n        Humanity storage humanity = humanityData[humanityId];\n        require(humanity.nbPendingRequests == 0);\n\n        if (humanity.owner == _account && block.timestamp < humanity.expirationTime) {\n            require(!humanity.vouching);\n\n            expirationTime = humanity.expirationTime;\n\n            delete humanity.owner;\n        } else {\n            // V1 profiles have default humanity.\n            humanityId = bytes20(_account);\n\n            // Should revert in case account is not registered.\n            expirationTime = forkModule.tryRemove(_account);\n        }\n\n        emit HumanityDischargedDirectly(humanityId);\n    }\n\n    /** @dev Change the governor of the contract.\n     *\n     *  @dev Emits {GovernorChanged} event.\n     *\n     *  @param _governor The address of the new governor.\n     */\n    function changeGovernor(address _governor) external payable onlyGovernor {\n        governor = _governor;\n        emit GovernorChanged(_governor);\n    }\n\n    /** @dev Change the base amount required as a deposit to make a request for a humanity.\n     *\n     *  @dev Emits {RequestBaseDepositChanged} event.\n     *\n     *  @param _requestBaseDeposit The new base amount of wei required to make a new request.\n     */\n    function changeRequestBaseDeposit(uint256 _requestBaseDeposit) external payable onlyGovernor {\n        requestBaseDeposit = _requestBaseDeposit;\n        emit RequestBaseDepositChanged(_requestBaseDeposit);\n    }\n\n    /** @dev Change the duration of the humanity lifespan, renewal and challenge periods.\n     *\n     *  @dev Emits {DurationsChanged} event.\n     *\n     *  @dev Requirements:\n     *  - To ensure correct contract behaviour, the sum of challengePeriodDuration and renewalPeriodDuration should be less than humanityLifespan.\n     *\n     *  @param _humanityLifespan The new lifespan of the time the humanity is considered registered.\n     *  @param _renewalPeriodDuration The new value that defines the duration of the humanity's renewal period.\n     *  @param _challengePeriodDuration The new duration of the challenge period. It should be lower than the time for a dispute.\n     *  @param _failedRevocationCooldown The new cooldown duration to be waited after failed transfer requests.\n     */\n    function changeDurations(\n        uint40 _humanityLifespan,\n        uint40 _renewalPeriodDuration,\n        uint40 _challengePeriodDuration,\n        uint40 _failedRevocationCooldown\n    ) external payable onlyGovernor {\n        humanityLifespan = _humanityLifespan;\n        renewalPeriodDuration = _renewalPeriodDuration;\n        challengePeriodDuration = _challengePeriodDuration;\n        failedRevocationCooldown = _failedRevocationCooldown;\n        emit DurationsChanged(\n            _humanityLifespan,\n            _renewalPeriodDuration,\n            _challengePeriodDuration,\n            _failedRevocationCooldown\n        );\n    }\n\n    /** @dev Change the number of vouches required for the request to pass beyond Vouching state.\n     *\n     *  @dev Emits {RequiredNumberOfVouchesChanged} event.\n     *\n     *  @param _requiredNumberOfVouches The new required number of vouches.\n     */\n    function changeRequiredNumberOfVouches(uint32 _requiredNumberOfVouches) external payable onlyGovernor {\n        requiredNumberOfVouches = _requiredNumberOfVouches;\n        emit RequiredNumberOfVouchesChanged(_requiredNumberOfVouches);\n    }\n\n    /** @dev Change the proportion of arbitration fees that must be paid as fee stake by parties depending on the result of the dispute (e.g. when the arbitrator refused to rule).\n     *\n     *  @dev Emits {StakeMultipliersChanged} event.\n     *\n     *  @param _sharedStakeMultiplier Multiplier of arbitration fees that must be paid as fee stake by parties when there is no winner or loser. In basis points.\n     *  @param _winnerStakeMultiplier Multiplier of arbitration fees that must be paid as fee stake by the winner of the previous round. In basis points.\n     *  @param _loserStakeMultiplier Multiplier of arbitration fees that must be paid as fee stake by the loser of the previous round. In basis points.\n     */\n    function changeStakeMultipliers(\n        uint256 _sharedStakeMultiplier,\n        uint256 _winnerStakeMultiplier,\n        uint256 _loserStakeMultiplier\n    ) external payable onlyGovernor {\n        sharedStakeMultiplier = _sharedStakeMultiplier;\n        winnerStakeMultiplier = _winnerStakeMultiplier;\n        loserStakeMultiplier = _loserStakeMultiplier;\n        emit StakeMultipliersChanged(_sharedStakeMultiplier, _winnerStakeMultiplier, _loserStakeMultiplier);\n    }\n\n    /** @dev Update the meta evidence used for disputes.\n     *\n     *  @dev Emits {MetaEvidence} event for the registration meta evidence.\n     *  @dev Emits {MetaEvidence} event for the clearing meta evidence.\n     *\n     *  @param _registrationMetaEvidence The meta evidence to be used for future registration request disputes.\n     *  @param _clearingMetaEvidence The meta evidence to be used for future clearing request disputes.\n     */\n    function changeMetaEvidence(\n        string calldata _registrationMetaEvidence,\n        string calldata _clearingMetaEvidence\n    ) external payable onlyGovernor {\n        ArbitratorData storage arbitratorData = arbitratorDataHistory[arbitratorDataHistory.length - 1];\n        uint96 newMetaEvidenceUpdates = arbitratorData.metaEvidenceUpdates + 1;\n        arbitratorDataHistory.push(\n            ArbitratorData({\n                arbitrator: arbitratorData.arbitrator,\n                metaEvidenceUpdates: newMetaEvidenceUpdates,\n                arbitratorExtraData: arbitratorData.arbitratorExtraData\n            })\n        );\n        emit MetaEvidence(2 * newMetaEvidenceUpdates, _registrationMetaEvidence);\n        emit MetaEvidence(2 * newMetaEvidenceUpdates + 1, _clearingMetaEvidence);\n    }\n\n    /** @dev Change the arbitrator to be used for disputes that may be raised in the next requests. The arbitrator is trusted to support appeal period and not reenter.\n     *\n     *  @dev Emits {ArbitratorChanged} event.\n     *\n     *  @param _arbitrator The new trusted arbitrator to be used in the next requests.\n     *  @param _arbitratorExtraData The extra data used by the new arbitrator.\n     */\n    function changeArbitrator(IArbitrator _arbitrator, bytes calldata _arbitratorExtraData) external payable onlyGovernor {\n        ArbitratorData storage arbitratorData = arbitratorDataHistory[arbitratorDataHistory.length - 1];\n        arbitratorDataHistory.push(\n            ArbitratorData({\n                arbitrator: _arbitrator,\n                metaEvidenceUpdates: arbitratorData.metaEvidenceUpdates,\n                arbitratorExtraData: _arbitratorExtraData\n            })\n        );\n        emit ArbitratorChanged(_arbitrator, _arbitratorExtraData);\n    }\n\n    /** @dev Change the cross-chain instance.\n     *\n     *  @dev Emits {CrossChainProxyChanged} event.\n     *\n     *  @param _crossChainProofOfHumanity The new cross-chain instance to be used.\n     */\n    function changeCrossChainProofOfHumanity(address _crossChainProofOfHumanity) external payable onlyGovernor {\n        crossChainProofOfHumanity = _crossChainProofOfHumanity;\n        emit CrossChainProxyChanged(_crossChainProofOfHumanity);\n    }\n\n    /** @dev Change fork module instance.\n     *  @param _forkModule Address of fork module contract.\n     */\n    function changeForkModule(address _forkModule) external payable onlyGovernor {\n        forkModule = IForkModule(_forkModule);\n    }\n\n    /// ====== REQUESTS ====== ///\n\n    /** @dev Make a request to enter the registry. Paying the full deposit right away is not required as it can be crowdfunded later.\n     *\n     *  @dev Emits {ClaimRequest} event.\n     *  @dev Emits {Evidence} event.\n     *\n     *  @dev Requirements:\n     *  - Humanity ID not null.\n     *  - Sender must not own a humanity.\n     *  - Humanity corresponding to _humanityId must not be claimed (either no owner or expired).\n     *  - Sender must not be in the process of claiming a humanity (covered by _requestHumanity).\n     *\n     *  @param _humanityId The humanity ID the human applies for.\n     *  @param _evidence Link to evidence using its URI.\n     *  @param _name Name of the human.\n     */\n    function claimHumanity(bytes20 _humanityId, string calldata _evidence, string calldata _name) external payable {\n        Humanity storage humanity = humanityData[_humanityId];\n\n        require(_humanityId != 0);\n        require(!isHuman(msg.sender));\n        require(humanity.owner == address(0x0) || humanity.expirationTime < block.timestamp);\n\n        uint256 requestId = _requestHumanity(_humanityId);\n\n        emit ClaimRequest(msg.sender, _humanityId, requestId, _name);\n        emit Evidence(\n            arbitratorDataHistory[arbitratorDataHistory.length - 1].arbitrator,\n            uint256(keccak256(abi.encodePacked(_humanityId, requestId))),\n            msg.sender,\n            _evidence\n        );\n    }\n\n    /** @dev Make a request to renew humanity's lifespan.\n     *  @dev The user can reapply even when current lifespan has not expired, but only after the start of renewal period.\n     *  @notice Paying the full deposit right away is not required as it can be crowdfunded later.\n     *\n     *  @dev Emits {RenewalRequest} event.\n     *  @dev Emits {Evidence} event.\n     *\n     *  @dev Requirements:\n     *  - Sender must be current owner of the humanity.\n     *  - Current time passed the start of the renewal period for humanity.\n     *  - Sender must not be in the process of claiming a humanity (covered by _requestHumanity).\n     *\n     *  @param _evidence Link to evidence using its URI.\n     */\n    function renewHumanity(string calldata _evidence) external payable {\n        bytes20 humanityId = accountHumanity[msg.sender];\n\n        Humanity storage humanity = humanityData[humanityId];\n\n        if (humanity.owner == msg.sender) \n            require(humanity.expirationTime.subCap40(renewalPeriodDuration) < block.timestamp);\n        else {\n            humanityId = bytes20(msg.sender);\n            (bool registered, uint40 expirationTime) = forkModule.getSubmissionInfo(msg.sender);\n            require(registered && expirationTime.subCap40(renewalPeriodDuration) < block.timestamp);\n        }\n\n        uint256 requestId = _requestHumanity(humanityId);\n\n        emit RenewalRequest(msg.sender, humanityId, requestId);\n        emit Evidence(\n            arbitratorDataHistory[arbitratorDataHistory.length - 1].arbitrator,\n            uint256(keccak256(abi.encodePacked(humanityId, requestId))),\n            msg.sender,\n            _evidence\n        );\n    }\n\n    /** @dev Make a request to revoke a humanity.\n     *  @dev Accepts enough ETH to cover the deposit, reimburses the rest.\n     *  @dev Only one revocation possible at a time.\n     *\n     *  @dev Emits {RevocationRequest} event.\n     *  @dev Emits {Evidence} event.\n     *\n     *  @dev Requirements:\n     *  - Humanity must be claimed by someone and not expired.\n     *  - Humanity must not be pending any revocation.\n     *  - The cooldown for failed revocation must have passed since last failed revocation.\n     *  - Deposit must be fully paid.\n     *\n     *  @param _humanityId The id of the humanity to revoke.\n     *  @param _evidence Link to evidence using its URI.\n     */\n    function revokeHumanity(bytes20 _humanityId, string calldata _evidence) external payable {\n        Humanity storage humanity = humanityData[_humanityId];\n\n        require(\n            (humanity.owner != address(0x0) && block.timestamp < humanity.expirationTime) ||\n                // If not claimed on this contract check on V1.\n                forkModule.isRegistered(address(_humanityId))\n        );\n        require(!humanity.pendingRevocation);\n        require(humanity.lastFailedRevocationTime.addCap40(failedRevocationCooldown) < block.timestamp);\n\n        uint256 requestId = humanity.requests.length;\n\n        Request storage request = humanity.requests.push();\n        request.status = Status.Resolving;\n        request.revocation = true;\n        request.requester = payable(msg.sender);\n        request.challengePeriodStart = uint40(block.timestamp);\n\n        uint256 arbitratorDataId = arbitratorDataHistory.length - 1;\n        request.arbitratorDataId = uint16(arbitratorDataId);\n\n        humanity.pendingRevocation = true;\n        humanity.nbPendingRequests++;\n\n        ArbitratorData memory arbitratorData = arbitratorDataHistory[arbitratorDataId];\n        uint256 totalCost = arbitratorData.arbitrator.arbitrationCost(arbitratorData.arbitratorExtraData).addCap(\n            requestBaseDeposit\n        );\n\n        require(_contribute(_humanityId, requestId, 0, 0, Party.Requester, totalCost));\n\n        emit RevocationRequest(msg.sender, _humanityId, requestId);\n        emit Evidence(\n            arbitratorData.arbitrator,\n            uint256(keccak256(abi.encodePacked(_humanityId, requestId))),\n            msg.sender,\n            _evidence\n        );\n    }\n\n    /** @notice Fund the requester's deposit. Accepts enough ETH to cover the deposit, reimburses the rest.\n     *\n     *  @dev Requirements:\n     *  - Corresponding request is in Vouching state.\n     *\n     *  @param _humanityId The humanity ID corresponding to the request to fund.\n     *  @param _requestId The request to fund.\n     */\n    function fundRequest(bytes20 _humanityId, uint256 _requestId) external payable {\n        Request storage request = humanityData[_humanityId].requests[_requestId];\n        require(request.status == Status.Vouching);\n\n        ArbitratorData memory arbitratorData = arbitratorDataHistory[request.arbitratorDataId];\n        uint256 totalCost = arbitratorData.arbitrator.arbitrationCost(arbitratorData.arbitratorExtraData).addCap(\n            requestBaseDeposit\n        );\n\n        _contribute(_humanityId, _requestId, 0, 0, Party.Requester, totalCost);\n    }\n\n    /** @notice Vouch that the human corresponds to the humanity id.\n     *\n     *  @dev Emits {VouchAdded} event.\n     *\n     *  @param _account The address of the human.\n     *  @param _humanityId The humanity id the vouch specifies human corresponds to.\n     */\n    function addVouch(address _account, bytes20 _humanityId) external {\n        vouches[msg.sender][_account][_humanityId] = true;\n        emit VouchAdded(msg.sender, _account, _humanityId);\n    }\n\n    /** @notice Remove a previously added vouch.\n     *\n     *  @dev Emits {VouchRemoved} event.\n     *\n     *  @param _account The address of the human.\n     *  @param _humanityId The humanity id the vouch specifies human corresponds to.\n     */\n    function removeVouch(address _account, bytes20 _humanityId) external {\n        vouches[msg.sender][_account][_humanityId] = false;\n        emit VouchRemoved(msg.sender, _account, _humanityId);\n    }\n\n    /** @notice Allow to withdraw a mistakenly added request while it's still in a vouching state.\n     *\n     *  @dev Emits {RequestWithdrawn} event.\n     *\n     *  @dev Requirements:\n     *  - Sender must be in the process of claiming a humanity and the request is in Vouching state.\n     */\n    function withdrawRequest() external {\n        bytes20 humanityId = accountHumanity[msg.sender];\n        Humanity storage humanity = humanityData[humanityId];\n        uint256 requestId = humanity.requestCount[msg.sender] - 1;\n        Request storage request = humanity.requests[requestId];\n        require(request.status == Status.Vouching);\n\n        delete humanity.requestCount[msg.sender];\n        request.status = Status.Resolved;\n\n        // Automatically withdraw for the requester.\n        withdrawFeesAndRewards(payable(msg.sender), humanityId, requestId, 0, 0);\n\n        emit RequestWithdrawn(humanityId, requestId);\n    }\n\n    /** @dev Advance the request from Vouching to Resolving state if all conditions are met.\n     *\n     *  @dev Emits {VouchRegistered} event.\n     *  @dev Emits {StateAdvanced} event.\n     *\n     *  @dev Requirements:\n     *  - Request must be in Vouching state.\n     *  - Humanity must not be claimed (or is in renewal period).\n     *  - Requester must have the deposit covered.\n     *  - Provided signatures must be valid.\n     *  - Number of aggregated vouches must be at least required number of vouches.\n     *\n     *  @dev EIP-712:\n     *  struct IsHumanVoucher {\n     *      address vouched;\n     *      bytes20 humanityId;\n     *      uint256 expirationTimestamp;\n     *  }\n     *\n     *  @param _claimer The address of the human whose request status to advance.\n     *  @param _vouches Array of users whose vouches to count (optional).\n     *  @param _signatureVouches Array of EIP-712 signatures of struct IsHumanVoucher (optional).\n     */\n    function advanceState(\n        address _claimer,\n        address[] calldata _vouches,\n        SignatureVouch[] calldata _signatureVouches\n    ) external {\n        bytes20 humanityId = accountHumanity[_claimer];\n        Humanity storage humanity = humanityData[humanityId];\n        uint256 requestId = humanity.requestCount[_claimer] - 1;\n        Request storage request = humanity.requests[requestId];\n        require(request.status == Status.Vouching);\n        require(\n            humanity.owner == address(0x0) || humanity.expirationTime.subCap40(renewalPeriodDuration) < block.timestamp\n        );\n        require(request.challenges[0].rounds[0].sideFunded == Party.Requester);\n\n        address voucherAccount;\n        Humanity storage voucherHumanity;\n        uint256 requiredVouches = requiredNumberOfVouches;\n        uint256 nbSignatureVouches = _signatureVouches.length;\n        uint256 i;\n        bool isValid;\n\n        // Iterate over both vouches arrays until accumulating the required number of valid vouches\n        // If both arrays ends' have been reached and not enough valid vouches have been given, it will revert on overflow\n        while (request.vouches.length < requiredVouches) {\n            if (i < nbSignatureVouches) {\n                SignatureVouch memory signature = _signatureVouches[i];\n\n                // Used OZ check https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol#L125-L136\n                require(signature.s <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0);\n\n                voucherAccount = ecrecover(\n                    keccak256(\n                        abi.encodePacked(\n                            \"\\x19\\x01\",\n                            DOMAIN_SEPARATOR,\n                            keccak256(\n                                abi.encode(IS_HUMAN_VOUCHER_TYPEHASH, _claimer, humanityId, signature.expirationTime)\n                            )\n                        )\n                    ),\n                    signature.v,\n                    signature.r,\n                    signature.s\n                );\n\n                isValid = block.timestamp < signature.expirationTime;\n            } else {\n                // Overflows if the end of _vouches has been reached and not enough valid vouches were gathered.\n                voucherAccount = _vouches[i - nbSignatureVouches];\n\n                isValid = vouches[voucherAccount][_claimer][humanityId];\n            }\n\n            if (isValid) {\n                // If voucherAccount is null, voucherHumanityId will be null too which cannot be claimed (so it will fail the conditions)\n                bytes20 voucherHumanityId = humanityOf(voucherAccount);\n                voucherHumanity = humanityData[voucherHumanityId];\n                if (\n                    ((voucherHumanity.owner == voucherAccount && block.timestamp < voucherHumanity.expirationTime) ||\n                        forkModule.isRegistered(voucherAccount)) &&\n                    !voucherHumanity.vouching &&\n                    voucherAccount != _claimer\n                ) {\n                    request.vouches.push(voucherHumanityId);\n                    voucherHumanity.vouching = true;\n\n                    // Emit event to signal the processing of the signature vouch (and the on-chain as well)\n                    emit VouchRegistered(voucherHumanityId, humanityId, requestId);\n                }\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n\n        humanity.nbPendingRequests++;\n        request.status = Status.Resolving;\n        request.challengePeriodStart = uint40(block.timestamp);\n\n        emit StateAdvanced(_claimer);\n    }\n\n    /** @dev Challenge the human's request. Accept enough ETH to cover the deposit, reimburse the rest.\n     *\n     *  @dev Emits {RequestChallenged} event.\n     *  @dev Emits {Dispute} event.\n     *  @dev Emits {Evidence} event.\n     *\n     *  @dev Requirements:\n     *  - If it's a revocation request, reason must be None. If it's a claim request, reason must not be None.\n     *  - Request must be in resolving state.\n     *  - Must be challenge period for the request.\n     *  - Reason must not have been used for this request.\n     *  - Challenger side must be fully paid.\n     *\n     *  @param _humanityId Id of the humanity the request to challenge corresponds to.\n     *  @param _requestId Id of the request to challenge.\n     *  @param _reason Reason to challenge the request.\n     *  @param _evidence Link to evidence using its URI. Ignored if not provided.\n     */\n    function challengeRequest(\n        bytes20 _humanityId,\n        uint256 _requestId,\n        Reason _reason,\n        string calldata _evidence\n    ) external payable {\n        Request storage request = humanityData[_humanityId].requests[_requestId];\n        // If request is for revocation request reason must be None, otherwise must be not None\n        require(request.revocation == (_reason == Reason.None));\n        require(request.status == Status.Resolving);\n        require(block.timestamp < request.challengePeriodStart + challengePeriodDuration);\n\n        // Only check used reasons on claim requests\n        if (!request.revocation) {\n            // Get the bit that corresponds with reason's index.\n            uint8 reasonBit;\n            unchecked {\n                reasonBit = uint8(1 << (uint256(_reason) - 1));\n            }\n\n            require((reasonBit & ~request.usedReasons) == reasonBit);\n\n            // Mark the bit corresponding with reason's index as 'true', to indicate that the reason was used.\n            request.usedReasons ^= reasonBit;\n\n            request.currentReason = _reason;\n        }\n\n        uint256 challengeId = request.lastChallengeId++;\n        Challenge storage challenge = request.challenges[challengeId];\n        Round storage round = challenge.rounds[0];\n\n        ArbitratorData memory arbitratorData = arbitratorDataHistory[request.arbitratorDataId];\n        uint256 arbitrationCost = arbitratorData.arbitrator.arbitrationCost(arbitratorData.arbitratorExtraData);\n\n        require(_contribute(_humanityId, _requestId, challengeId, 0, Party.Challenger, arbitrationCost));\n\n        // Subtract the costs from the total of staked contributions.\n        round.feeRewards = round.feeRewards.subCap(arbitrationCost);\n\n        uint256 disputeId = arbitratorData.arbitrator.createDispute{value: arbitrationCost}(\n            RULING_OPTIONS,\n            arbitratorData.arbitratorExtraData\n        );\n        challenge.disputeId = disputeId;\n        challenge.challenger = payable(msg.sender);\n        challenge.lastRoundId++;\n\n        DisputeData storage disputeData = disputeIdToData[address(arbitratorData.arbitrator)][disputeId];\n        disputeData.humanityId = _humanityId;\n        disputeData.requestId = uint96(_requestId);\n        disputeData.challengeId = uint96(challengeId);\n\n        request.status = Status.Disputed;\n\n        // Hash evidenceGroupId to make sure it's unique.\n        uint256 evidenceGroupId = uint256(keccak256(abi.encodePacked(_humanityId, _requestId)));\n\n        emit RequestChallenged(_humanityId, _requestId, challengeId, _reason, disputeId);\n        emit Dispute(\n            arbitratorData.arbitrator,\n            disputeId,\n            2 * arbitratorData.metaEvidenceUpdates + (request.revocation ? 1 : 0),\n            evidenceGroupId\n        );\n        emit Evidence(arbitratorData.arbitrator, evidenceGroupId, msg.sender, _evidence);\n    }\n\n    /** @dev Take up to the total amount required to fund a side of an appeal. Reimburse the rest. Create an appeal if both sides are fully funded.\n     *\n     *  @dev Emits {AppealCreated} event.\n     *\n     *  @dev Requirements:\n     *  - Side funded must be either requester or challenger.\n     *  - Dispute must be in appeal period.\n     *  - Appeal period must not be over for loser.\n     *  - Request must be disputed.\n     *  - Must fund a non-funded side.\n     *\n     *  @param _arbitrator Address of the arbitrator used for the challenge.\n     *  @param _disputeId ID of the corresponding dispute.\n     *  @param _side Recipient of the contribution.\n     */\n    function fundAppeal(address _arbitrator, uint256 _disputeId, Party _side) external payable {\n        // You can only fund either the requester or the challenger.\n        require(_side != Party.None);\n\n        (uint256 appealPeriodStart, uint256 appealPeriodEnd) = IArbitrator(_arbitrator).appealPeriod(_disputeId);\n        require(appealPeriodStart < block.timestamp && block.timestamp < appealPeriodEnd);\n\n        uint256 multiplier;\n        Party winner = Party(IArbitrator(_arbitrator).currentRuling(_disputeId));\n        if (winner == _side) multiplier = winnerStakeMultiplier;\n        else if (winner == Party.None) multiplier = sharedStakeMultiplier;\n        else if (block.timestamp - appealPeriodStart < (appealPeriodEnd - appealPeriodStart) / 2)\n            multiplier = loserStakeMultiplier;\n            // If half of appeal period passed and side funded is winner, it will revert\n        else revert();\n\n        DisputeData memory disputeData = disputeIdToData[_arbitrator][_disputeId];\n        Request storage request = humanityData[disputeData.humanityId].requests[disputeData.requestId];\n        require(request.status == Status.Disputed);\n\n        Challenge storage challenge = request.challenges[disputeData.challengeId];\n        Round storage round = challenge.rounds[challenge.lastRoundId];\n\n        Party firstFunded = round.sideFunded;\n        require(_side != firstFunded);\n\n        uint256 appealCost = IArbitrator(_arbitrator).appealCost(\n            _disputeId,\n            arbitratorDataHistory[request.arbitratorDataId].arbitratorExtraData\n        );\n        uint256 totalCost = appealCost.addCap(appealCost.mulCap(multiplier) / MULTIPLIER_DIVISOR);\n\n        if (\n            _contribute(\n                disputeData.humanityId,\n                disputeData.requestId,\n                disputeData.challengeId,\n                challenge.lastRoundId,\n                _side,\n                totalCost\n            ) &&\n            // If firstFunded was assigned, it means other side was funded and if this one gets fully funded as well appeal can be created.\n            firstFunded != Party.None\n        ) {\n            IArbitrator(_arbitrator).appeal{value: appealCost}(\n                _disputeId,\n                arbitratorDataHistory[request.arbitratorDataId].arbitratorExtraData\n            );\n            challenge.lastRoundId++;\n\n            // Subtract the costs from the total of staked contributions\n            round.feeRewards = round.feeRewards.subCap(appealCost);\n\n            emit AppealCreated(IArbitrator(_arbitrator), _disputeId);\n        }\n    }\n\n    /** @dev Execute a request if the challenge period passed and request has not been successfully challenged.\n     *\n     *  @dev Emits {HumanityClaimed} event.\n     *  @dev Emits {HumanityRevoked} event.\n     *\n     *  @dev Requirements:\n     *  - Request must be in resolving state.\n     *  - Challenge period must have ended.\n     *\n     *  @param _humanityId Id of the humanity the request to execute corresponds to.\n     *  @param _requestId Id of the request to execute.\n     */\n    function executeRequest(bytes20 _humanityId, uint256 _requestId) external {\n        Humanity storage humanity = humanityData[_humanityId];\n        Request storage request = humanity.requests[_requestId];\n        require(request.status == Status.Resolving);\n        require(request.challengePeriodStart + challengePeriodDuration < block.timestamp);\n\n        if (request.revocation) {\n            if (humanity.owner != address(0x0) && block.timestamp < humanity.expirationTime) {\n                delete humanity.owner;\n                humanity.pendingRevocation = false;\n\n                // If not claimed in this contract, directly remove in fork module.\n            } else forkModule.remove(address(_humanityId));\n\n            emit HumanityRevoked(_humanityId, _requestId);\n        } else if (!request.punishedVouch) {\n            humanity.owner = request.requester;\n            humanity.expirationTime = uint40(block.timestamp).addCap40(humanityLifespan);\n\n            emit HumanityClaimed(_humanityId, _requestId);\n        }\n\n        humanity.nbPendingRequests--;\n        request.status = Status.Resolved;\n        delete humanity.requestCount[request.requester];\n\n        if (request.vouches.length != 0) processVouches(_humanityId, _requestId, VOUCHES_TO_AUTOPROCESS);\n\n        withdrawFeesAndRewards(request.requester, _humanityId, _requestId, 0, 0); // Automatically withdraw for the requester.\n    }\n\n    /** @dev Process vouches of the resolved request, so vouchings of users who vouched for it can be used for other humans.\n     *  @dev Profiles who vouched for successfully challenged claim requests are penalized.\n     *\n     *  @dev Emits {VouchesProcessed} event.\n     *  @dev Emits {HumanityDischargedDirectly} event.\n     *\n     *  @dev Requirements:\n     *  - Request must be resolved.\n     *\n     *  @param _humanityId Id of the humanity for which the request was made.\n     *  @param _requestId Id of request for which vouches to iterate.\n     *  @param _iterations Number of iterations to go through.\n     */\n    function processVouches(bytes20 _humanityId, uint256 _requestId, uint256 _iterations) public {\n        Request storage request = humanityData[_humanityId].requests[_requestId];\n        require(request.status == Status.Resolved);\n\n        uint256 lastProcessed = request.lastProcessedVouch;\n        uint256 endIndex = _iterations.addCap(lastProcessed);\n        uint256 vouchCount = request.vouches.length;\n\n        if (endIndex > vouchCount) endIndex = vouchCount;\n\n        Reason currentReason = request.currentReason;\n        // Penalty is applied for sybil attacks.\n        bool applyPenalty = request.ultimateChallenger != address(0x0) &&\n            (currentReason == Reason.SybilAttack || currentReason == Reason.IdentityTheft);\n\n        while (lastProcessed < endIndex) {\n            bytes20 voucherHumanityId = request.vouches[lastProcessed];\n            Humanity storage voucherHumanity = humanityData[voucherHumanityId];\n            voucherHumanity.vouching = false;\n\n            if (applyPenalty) {\n                // Situation when vouching address is in the middle of renewal process.\n                if (voucherHumanity.owner != address(0x0) && block.timestamp < voucherHumanity.expirationTime) {\n                    uint256 voucherRequestId = voucherHumanity.requestCount[voucherHumanity.owner] - 1;\n                    if (voucherRequestId != 0) voucherHumanity.requests[voucherRequestId].punishedVouch = true;\n\n                    delete voucherHumanity.owner;\n\n                    // If not claimed in this contract, directly remove in fork module.\n                } else forkModule.remove(address(voucherHumanityId));\n\n                emit HumanityDischargedDirectly(voucherHumanityId);\n            }\n\n            unchecked {\n                lastProcessed++;\n            }\n        }\n\n        request.lastProcessedVouch = uint32(endIndex);\n\n        emit VouchesProcessed(_humanityId, _requestId, endIndex);\n    }\n\n    /** @dev Reimburse contributions if no disputes were raised.\n     *  @dev If a dispute was raised, send the fee stake rewards and reimbursements proportionally to the contributions made to the winner of a dispute.\n     *\n     *  @dev Emits {FeesAndRewardsWithdrawn} event.\n     *\n     *  @dev Requirements:\n     *  - Request must be resolved.\n     *  - Beneficiary must not be null address.\n     *\n     *  @param _beneficiary The address that made contributions to a request.\n     *  @param _humanityId Id of humanity the request was for.\n     *  @param _requestId The request from which to withdraw.\n     *  @param _challengeId The Id of the challenge from which to withdraw.\n     *  @param _round The round from which to withdraw.\n     */\n    function withdrawFeesAndRewards(\n        address payable _beneficiary,\n        bytes20 _humanityId,\n        uint256 _requestId,\n        uint256 _challengeId,\n        uint256 _round\n    ) public {\n        Request storage request = humanityData[_humanityId].requests[_requestId];\n        Challenge storage challenge = request.challenges[_challengeId];\n        Round storage round = challenge.rounds[_round];\n        require(request.status == Status.Resolved);\n        require(_beneficiary != address(0x0));\n\n        Party ruling = challenge.ruling;\n        uint256 reward;\n        ContributionsSet storage beneficiaryContributions = round.contributions[_beneficiary];\n        if (_round != 0 && _round == challenge.lastRoundId) {\n            // Reimburse the payment if the last round wasn't fully funded.\n            // Note that the 0 round is always considered funded if there is a challenge.\n            // If there was no challenge the requester will be reimbursed with the subsequent condition, since the ruling will be Party.None.\n            reward = beneficiaryContributions.forRequester + beneficiaryContributions.forChallenger;\n        } else if (ruling == Party.None) {\n            uint256 totalFeesInRound = round.paidFees.forChallenger + round.paidFees.forRequester;\n            uint256 claimableFees = beneficiaryContributions.forChallenger + beneficiaryContributions.forRequester;\n            if (totalFeesInRound > 0) reward = (claimableFees * round.feeRewards) / totalFeesInRound;\n        } else if (_beneficiary == request.ultimateChallenger && _challengeId == 0 && _round == 0) {\n            // Challenger, who ultimately wins, will be able to get the deposit of the requester, even if he didn't participate in the initial dispute.\n            reward = round.feeRewards;\n            round.feeRewards = 0;\n        } else if (request.ultimateChallenger == address(0x0) || _challengeId != 0 || _round != 0) {\n            // This condition will prevent claiming a reward, intended for the ultimate challenger.\n            uint256 paidFees = ruling == Party.Requester ? round.paidFees.forRequester : round.paidFees.forChallenger;\n            if (paidFees > 0)\n                reward =\n                    ((\n                        ruling == Party.Requester\n                            ? beneficiaryContributions.forRequester\n                            : beneficiaryContributions.forChallenger\n                    ) * round.feeRewards) /\n                    paidFees;\n        }\n\n        beneficiaryContributions.forRequester = 0;\n        beneficiaryContributions.forChallenger = 0;\n        _beneficiary.safeSend(reward, wNative);\n\n        emit FeesAndRewardsWithdrawn(_humanityId, _requestId, _challengeId, _round, _beneficiary);\n    }\n\n    /** @notice Give a ruling for a dispute. Can only be called by the arbitrator. TRUSTED.\n     *\n     *  @dev Account for the situation where the winner loses a case due to paying less appeal fees than expected.\n     *  @dev Ruling 0 is reserved for \"Refused to arbitrate\".\n     *\n     *  @dev Emits {ChallengePeriodRestart} event.\n     *  @dev Emits {Ruling} event.\n     *\n     *  @dev Requirements:\n     *  - Must be called by the arbitrator of the request.\n     *  - Request must be disputed.\n     *\n     *  @param _disputeId Id of the dispute in the arbitrator contract.\n     *  @param _ruling Ruling given by the arbitrator.\n     */\n    function rule(uint256 _disputeId, uint256 _ruling) external override {\n        DisputeData memory disputeData = disputeIdToData[msg.sender][_disputeId];\n        Humanity storage humanity = humanityData[disputeData.humanityId];\n        Request storage request = humanity.requests[disputeData.requestId];\n        Challenge storage challenge = request.challenges[disputeData.challengeId];\n        Round storage round = challenge.rounds[challenge.lastRoundId];\n\n        require(address(arbitratorDataHistory[request.arbitratorDataId].arbitrator) == msg.sender);\n        require(request.status == Status.Disputed);\n\n        Party resultRuling = Party(_ruling);\n        // The ruling is inverted if the loser paid its fees.\n        if (round.sideFunded == Party.Requester)\n            // If one side paid its fees, the ruling is in its favor. Note that if the other side had also paid, an appeal would have been created.\n            resultRuling = Party.Requester;\n        else if (round.sideFunded == Party.Challenger) resultRuling = Party.Challenger;\n\n        // Store the rulings of each dispute for correct distribution of rewards.\n        challenge.ruling = resultRuling;\n\n        emit Ruling(IArbitrator(msg.sender), _disputeId, uint256(resultRuling));\n\n        if (request.revocation) {\n            humanity.pendingRevocation = false;\n\n            if (resultRuling == Party.Requester) {\n                if (humanity.owner != address(0x0) && block.timestamp < humanity.expirationTime)\n                    delete humanity.owner;\n                    // If not claimed in this contract, remove in fork module.\n                else forkModule.remove(address(disputeData.humanityId));\n\n                emit HumanityRevoked(disputeData.humanityId, disputeData.requestId);\n            } else humanity.lastFailedRevocationTime = uint40(block.timestamp);\n        } else {\n            // For a claim request there can be more than one dispute.\n            if (resultRuling == Party.Requester) {\n                if (!request.punishedVouch) {\n                    // All reasons being used means the request can't be challenged again, so we can update its status.\n                    if (request.usedReasons == FULL_REASONS_SET) {\n                        humanity.owner = request.requester;\n                        humanity.expirationTime = uint40(block.timestamp).addCap40(humanityLifespan);\n\n                        emit HumanityClaimed(disputeData.humanityId, disputeData.requestId);\n                    } else {\n                        // Refresh the state of the request so it can be challenged again.\n                        request.status = Status.Resolving;\n                        request.challengePeriodStart = uint40(block.timestamp);\n                        request.currentReason = Reason.None;\n\n                        emit ChallengePeriodRestart(\n                            disputeData.humanityId,\n                            disputeData.requestId,\n                            disputeData.challengeId\n                        );\n\n                        return;\n                    }\n                }\n                // Challenger won or it\u2019s a tie.\n            } else if (resultRuling == Party.Challenger) request.ultimateChallenger = challenge.challenger;\n        }\n\n        humanity.nbPendingRequests--;\n        request.status = Status.Resolved;\n        delete humanity.requestCount[request.requester];\n    }\n\n    /** @notice Submit a reference to evidence.\n     *\n     *  @dev Emits {Evidence} event.\n     *\n     *  @param _humanityId Id of humanity the request is for.\n     *  @param _requestId Id of request the evidence is related to.\n     *  @param _evidence A link to an evidence using its URI.\n     */\n    function submitEvidence(bytes20 _humanityId, uint256 _requestId, string calldata _evidence) external {\n        emit Evidence(\n            arbitratorDataHistory[humanityData[_humanityId].requests[_requestId].arbitratorDataId].arbitrator,\n            uint256(keccak256(abi.encodePacked(_humanityId, _requestId))),\n            msg.sender,\n            _evidence\n        );\n    }\n\n    /// ====== INTERNAL ====== ///\n\n    /** @notice Make a request to claim/renew the humanity.\n     *\n     *  @dev Requirements:\n     *  - Sender has no ongoing claim.\n     *\n     *  @param _humanityId Id of the humanity the request is for.\n     *  @return requestId Id of the created request.\n     */\n    function _requestHumanity(bytes20 _humanityId) internal returns (uint256 requestId) {\n        // Human must not be in the process of claiming a humanity.\n        require(humanityData[accountHumanity[msg.sender]].requestCount[msg.sender] == 0);\n\n        Humanity storage humanity = humanityData[_humanityId];\n\n        requestId = humanity.requests.length;\n\n        Request storage request = humanity.requests.push();\n        request.requester = payable(msg.sender);\n\n        uint256 arbitratorDataId = arbitratorDataHistory.length - 1;\n        request.arbitratorDataId = uint16(arbitratorDataId);\n\n        // Use requestCount like this in order to avoid having referencing the claimer's pending request as 0 at any point.\n        humanity.requestCount[msg.sender] = requestId + 1;\n        accountHumanity[msg.sender] = _humanityId;\n\n        ArbitratorData memory arbitratorData = arbitratorDataHistory[arbitratorDataId];\n        uint256 totalCost = arbitratorData.arbitrator.arbitrationCost(arbitratorData.arbitratorExtraData).addCap(\n            requestBaseDeposit\n        );\n        _contribute(_humanityId, requestId, 0, 0, Party.Requester, totalCost);\n    }\n\n    /** @dev Make a fee contribution. Reimburse remaining ETH.\n     *  @param _humanityId Humanity ID corresponding to the request.\n     *  @param _requestId Request corresponding to the round.\n     *  @param _challengeId Challenge corresponding to the round.\n     *  @param _roundId Round to contribute to.\n     *  @param _side Side to contribute to.\n     *  @param _totalRequired Total amount required for this side.\n     *  @return paidInFull Whether the contribution was paid in full.\n     */\n    function _contribute(\n        bytes20 _humanityId,\n        uint256 _requestId,\n        uint256 _challengeId,\n        uint256 _roundId,\n        Party _side,\n        uint256 _totalRequired\n    ) internal returns (bool paidInFull) {\n        Round storage round = humanityData[_humanityId].requests[_requestId].challenges[_challengeId].rounds[_roundId];\n\n        uint256 remainingETH;\n        uint256 contribution = msg.value;\n        uint256 requiredAmount = _totalRequired.subCap(\n            _side == Party.Requester ? round.paidFees.forRequester : round.paidFees.forChallenger\n        );\n        if (requiredAmount <= msg.value) {\n            contribution = requiredAmount;\n            remainingETH = msg.value - requiredAmount;\n\n            paidInFull = true;\n            round.sideFunded = round.sideFunded == Party.None ? _side : Party.None;\n        }\n\n        if (_side == Party.Requester) {\n            round.contributions[msg.sender].forRequester += contribution;\n            round.paidFees.forRequester += contribution;\n        } else {\n            round.contributions[msg.sender].forChallenger += contribution;\n            round.paidFees.forChallenger += contribution;\n        }\n        round.feeRewards += contribution;\n\n        emit Contribution(_humanityId, _requestId, _challengeId, _roundId, msg.sender, contribution, _side);\n\n        if (remainingETH != 0) payable(msg.sender).safeSend(remainingETH, wNative);\n    }\n\n    /// ====== GETTERS ====== ///\n\n    /** @notice Check whether humanity is claimed or not.\n     *  @param _humanityId The id of the humanity to check.\n     *  @return Whether humanity is claimed.\n     */\n    function isClaimed(bytes20 _humanityId) external view override returns (bool) {\n        Humanity storage humanity = humanityData[_humanityId];\n        // Check this contract's state first and, if humanity not claimed here, check fork module.\n        return\n            (humanity.owner != address(0x0) && block.timestamp < humanity.expirationTime) ||\n            forkModule.isRegistered(address(_humanityId));\n    }\n\n    /** @notice Check whether the account corresponds to a claimed humanity.\n     *  @param _account The account address.\n     *  @return Whether the account has a valid humanity.\n     */\n    function isHuman(address _account) public view override returns (bool) {\n        Humanity storage humanity = humanityData[accountHumanity[_account]];\n        // Check this contract's state first and, if account not registered here, check fork module.\n        return\n            (humanity.owner == _account && block.timestamp < humanity.expirationTime) ||\n            forkModule.isRegistered(_account);\n    }\n\n    /** @notice Get the owner of a humanity.\n     *  @param _humanityId The id of the humanity.\n     *  @return account The owner of the humanity.\n     */\n    function boundTo(bytes20 _humanityId) external view override returns (address) {\n        Humanity storage humanity = humanityData[_humanityId];\n        if (block.timestamp < humanity.expirationTime) return humanity.owner;\n        return (forkModule.isRegistered(address(_humanityId))) ? address(_humanityId) : address(0x0);\n    }\n\n    /** @notice Get the humanity corresponding to an address. Returns zero if it corresponds to no humanity.\n     *  @param _account The address to get the correspding humanity of.\n     *  @return humanityId The humanity corresponding to the address.\n     */\n    function humanityOf(address _account) public view override returns (bytes20 humanityId) {\n        humanityId = accountHumanity[_account];\n        Humanity storage humanity = humanityData[humanityId];\n        if (humanity.owner != _account || humanity.expirationTime < block.timestamp) {\n            if (forkModule.isRegistered(_account)) humanityId = bytes20(_account);\n            else humanityId = bytes20(0x0);\n        }\n    }\n\n    /** @notice Get the number of times the arbitrator data was updated.\n     *  @return The number of arbitrator data updates.\n     */\n    function getArbitratorDataHistoryCount() external view returns (uint256) {\n        return arbitratorDataHistory.length;\n    }\n\n    /** @notice Get info about the humanity.\n     *  @param _humanityId The ID of the humanity to get info about.\n     */\n    function getHumanityInfo(\n        bytes20 _humanityId\n    )\n        external\n        view\n        override\n        returns (\n            bool vouching,\n            bool pendingRevocation,\n            uint48 nbPendingRequests,\n            uint40 expirationTime,\n            address owner,\n            uint256 nbRequests\n        )\n    {\n        Humanity storage humanity = humanityData[_humanityId];\n        bool registeredOnV1 = false;\n        owner = address(_humanityId);\n        (registeredOnV1, expirationTime) = forkModule.getSubmissionInfo(owner);\n        if (!registeredOnV1) {\n            owner = humanity.owner;\n            expirationTime = humanity.expirationTime;\n        }\n        vouching = humanity.vouching;\n        nbPendingRequests = humanity.nbPendingRequests;\n        nbRequests = humanity.requests.length;\n        pendingRevocation = humanity.pendingRevocation;\n    }\n\n    /** @notice Get request ID of a claimer.\n     *  @param _claimer Address of the claimer.\n     */\n    function getClaimerRequestId(address _claimer) external view returns (uint256) {\n        return humanityData[accountHumanity[_claimer]].requestCount[_claimer] - 1;\n    }\n\n    /** @notice Get information of a request of a humanity.\n     *  @param _humanityId The address of the humanity.\n     *  @param _requestId The request\n     */\n    function getRequestInfo(\n        bytes20 _humanityId,\n        uint256 _requestId\n    )\n        external\n        view\n        returns (\n            bool punishedVouch,\n            uint8 usedReasons,\n            uint16 arbitratorDataId,\n            uint16 lastChallengeId,\n            uint40 challengePeriodStart,\n            address payable requester,\n            address payable ultimateChallenger,\n            Status status,\n            Reason currentReason\n        )\n    {\n        Request storage request = humanityData[_humanityId].requests[_requestId];\n        return (\n            request.punishedVouch,\n            request.usedReasons,\n            request.arbitratorDataId,\n            request.lastChallengeId,\n            request.challengePeriodStart,\n            request.requester,\n            request.ultimateChallenger,\n            request.status,\n            request.currentReason\n        );\n    }\n\n    /** @notice Get the information of a particular challenge of the request.\n     *  @param _humanityId The queried humanity Id.\n     *  @param _requestId The request to query.\n     *  @param _challengeId The challenge to query.\n     *  @return lastRoundId Id of last round.\n     *  @return challenger Address that challenged the request.\n     *  @return disputeId Id of the dispute related to the challenge.\n     *  @return ruling Ruling given by the arbitrator of the dispute.\n     */\n    function getChallengeInfo(\n        bytes20 _humanityId,\n        uint256 _requestId,\n        uint256 _challengeId\n    ) external view returns (uint16 lastRoundId, address challenger, uint256 disputeId, Party ruling) {\n        Challenge storage challenge = humanityData[_humanityId].requests[_requestId].challenges[_challengeId];\n        return (challenge.lastRoundId, challenge.challenger, challenge.disputeId, challenge.ruling);\n    }\n\n    /** @notice Get the information of a round of a request.\n     *  @param _humanityId The queried humanity Id.\n     *  @param _requestId The request to query.\n     *  @param _challengeId The challenge to query.\n     *  @param _round The round to query.\n     */\n    function getRoundInfo(\n        bytes20 _humanityId,\n        uint256 _requestId,\n        uint256 _challengeId,\n        uint256 _round\n    )\n        external\n        view\n        returns (\n            bool appealed,\n            uint256 paidFeesRequester,\n            uint256 paidFeesChallenger,\n            Party sideFunded,\n            uint256 feeRewards\n        )\n    {\n        Challenge storage challenge = humanityData[_humanityId].requests[_requestId].challenges[_challengeId];\n        Round storage round = challenge.rounds[_round];\n        return (\n            _round < (challenge.lastRoundId),\n            round.paidFees.forRequester,\n            round.paidFees.forChallenger,\n            round.sideFunded,\n            round.feeRewards\n        );\n    }\n\n    /** @notice Get the contributions made by a party for a given round of a given challenge of a request.\n     *  @param _humanityId The humanity id.\n     *  @param _requestId The request to query.\n     *  @param _challengeId the challenge to query.\n     *  @param _round The round to query.\n     *  @param _contributor The address of the contributor.\n     */\n    function getContributions(\n        bytes20 _humanityId,\n        uint256 _requestId,\n        uint256 _challengeId,\n        uint256 _round,\n        address _contributor\n    ) external view returns (uint256 forRequester, uint256 forChallenger) {\n        ContributionsSet memory contributions = humanityData[_humanityId]\n            .requests[_requestId]\n            .challenges[_challengeId]\n            .rounds[_round]\n            .contributions[_contributor];\n        return (contributions.forRequester, contributions.forChallenger);\n    }\n\n    /** @notice Get the number of vouches of a particular request.\n     *  @param _humanityId The Id of the queried human.\n     *  @param _requestId The request to query.\n     */\n    function getNumberOfVouches(bytes20 _humanityId, uint256 _requestId) external view returns (uint256) {\n        return humanityData[_humanityId].requests[_requestId].vouches.length;\n    }\n}\n"}, "contracts/interfaces/IForkModule.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IForkModule {\n    function remove(address _submissionID) external;\n\n    function tryRemove(address _submissionID) external returns (uint40);\n\n    function isRegistered(address _submissionID) external view returns (bool);\n\n    function getSubmissionInfo(address _submissionID) external view returns (bool registered, uint40 expirationTime);\n}\n"}, "contracts/interfaces/IProofOfHumanity.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IProofOfHumanity {\n    /* Manual adding/removing */\n\n    function ccGrantHumanity(\n        bytes20 _humanityId,\n        address _owner,\n        uint40 _expirationTime\n    ) external returns (bool success);\n\n    function ccDischargeHumanity(address _owner) external returns (bytes20 humanityId, uint40 expirationTime);\n\n    /* Views */\n\n    function isClaimed(bytes20 _humanityId) external view returns (bool);\n\n    function isHuman(address _address) external view returns (bool);\n\n    function boundTo(bytes20 _humanityId) external view returns (address);\n\n    function humanityOf(address _account) external view returns (bytes20 humanityId);\n\n    function getHumanityInfo(\n        bytes20 _humanityId\n    )\n        external\n        view\n        returns (\n            bool vouching,\n            bool pendingRevokal,\n            uint48 nbPendingRequests,\n            uint40 expirationTime,\n            address owner,\n            uint256 nbRequests\n        );\n}\n"}, "contracts/interfaces/IProofOfHumanityOld.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IProofOfHumanityOld {\n    enum OldStatus {\n        None,\n        Vouching,\n        PendingRegistration,\n        PendingRemoval\n    }\n\n    /* Views */\n\n    function submissionDuration() external view returns (uint64);\n\n    function isRegistered(address _submissionID) external view returns (bool);\n\n    function getSubmissionInfo(\n        address _submissionID\n    ) external view returns (OldStatus, uint64 submissionTime, uint64, bool registered, bool, uint256);\n}\n"}, "contracts/libraries/CappedMath.sol": {"content": "/**\n * @authors: [@mtsalenc*, @hbarcelos*, @fnanni-0]\n * @reviewers: [@clesaege*, @ferittuncer*]\n * @auditors: []\n * @bounties: []\n * @deployments: []\n * SPDX-License-Identifier: MIT\n */\n\npragma solidity ^0.8.30;\n\n/**\n * @title CappedMath\n * @dev Math operations with caps for under and overflow.\n */\nlibrary CappedMath {\n    uint256 private constant UINT_MAX = type(uint256).max;\n    uint40 private constant UINT40_MAX = type(uint40).max;\n\n    /**\n     * @dev Adds two unsigned integers, returns 2^256 - 1 on overflow.\n     */\n    function addCap(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        unchecked {\n            uint256 c = _a + _b;\n            return c >= _a ? c : UINT_MAX;\n        }\n    }\n\n    /**\n     * @dev Subtracts two integers, returns 0 on underflow.\n     */\n    function subCap(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        if (_b > _a) return 0;\n        unchecked {\n            return _a - _b;\n        }\n    }\n\n    /**\n     * @dev Multiplies two unsigned integers, returns 2^256 - 1 on overflow.\n     */\n    function mulCap(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring '_a' not being zero, but the\n        // benefit is lost if '_b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) return 0;\n\n        unchecked {\n            uint256 c = _a * _b;\n            return c / _a == _b ? c : UINT_MAX;\n        }\n    }\n\n    function addCap40(uint40 _a, uint40 _b) internal pure returns (uint40) {\n        unchecked {\n            uint40 c = _a + _b;\n            return c >= _a ? c : UINT40_MAX;\n        }\n    }\n\n    function subCap40(uint40 _a, uint40 _b) internal pure returns (uint40) {\n        if (_b > _a) return 0;\n        unchecked {\n            return _a - _b;\n        }\n    }\n\n    function mulCap40(uint40 _a, uint40 _b) internal pure returns (uint40) {\n        // Gas optimization: this is cheaper than requiring '_a' not being zero, but the\n        // benefit is lost if '_b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) return 0;\n\n        unchecked {\n            uint40 c = _a * _b;\n            return c / _a == _b ? c : UINT40_MAX;\n        }\n    }\n}\n"}, "contracts/libraries/SafeSend.sol": {"content": "/**\n * @authors: [@andreimvp]\n * @reviewers: []\n * @auditors: []\n * @bounties: []\n * SPDX-License-Identifier: MIT\n */\n\npragma solidity ^0.8.30;\n\ninterface WethLike {\n    function deposit() external payable;\n\n    function transfer(address dst, uint256 wad) external;\n}\n\nlibrary SafeSend {\n    function safeSend(address payable _to, uint256 _value, address _wethLike) internal {\n        if (_to.send(_value)) return;\n\n        WethLike(_wethLike).deposit{value: _value}();\n        WethLike(_wethLike).transfer(_to, _value);\n    }\n}\n"}}, "settings": {"optimizer": {"enabled": false, "runs": 200}, "viaIR": true, "evmVersion": "paris", "outputSelection": {"*": {"*": ["abi", "metadata", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers", "evm.legacyAssembly", "evm.bytecode.opcodes"]}}, "metadata": {"appendCBOR": false}, "libraries": {}}}