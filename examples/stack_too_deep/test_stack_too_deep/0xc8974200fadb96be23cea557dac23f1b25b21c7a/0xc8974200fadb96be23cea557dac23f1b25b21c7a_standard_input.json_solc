{"language": "Solidity", "sources": {"src/CctpR.sol": {"content": "// Copyright (c) 2025 Stable Technologies Inc\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at https://mozilla.org/MPL/2.0/.\n\npragma solidity ^0.8.30;\n\nimport {BytesParsing}      from \"wormhole-sdk/libraries/BytesParsing.sol\";\nimport {PermitParsing}     from \"wormhole-sdk/libraries/PermitParsing.sol\";\nimport {RawDispatcher}     from \"wormhole-sdk/RawDispatcher.sol\";\nimport {eagerAnd, eagerOr} from \"wormhole-sdk/Utils.sol\";\n\nimport {CctpRBase, Route}       from \"cctpr/assets/CctpRBase.sol\";\nimport {CctpROwner}             from \"cctpr/assets/CctpROwner.sol\";\nimport {CctpRUser, Permit2Data} from \"cctpr/assets/CctpRUser.sol\";\nimport {CctpRQuote}             from \"cctpr/assets/CctpRQuote.sol\";\nimport {\n  TRANSFER_WITH_RELAY_WITH_PERMIT_ID,\n  TRANSFER_WITH_RELAY_ID,\n  TRANSFER_WITH_RELAY_GASLESS_ID,\n  UPDATE_FEE_ADJUSTMENTS_ID,\n  OWNER_SWEEP_TOKENS_ID,\n  OWNER_UPDATE_FEE_RECIPIENT_ID,\n  OWNER_UPDATE_FEE_ADJUSTER_ID,\n  OWNER_UPDATE_OFFCHAIN_QUOTER_ID,\n  OWNER_PROPOSE_OWNERSHIP_TRANSFER_ID,\n  OWNER_ACCEPT_OWNERSHIP_TRANSFER_ID,\n  OWNER_CANCEL_OWNERSHIP_TRANSFER_ID,\n  OWNER_SET_CHAIN_ID_FOR_DOMAIN_ID,\n  QUERY_RELAY_IN_USDC_ID,\n  QUERY_RELAY_IN_GAS_TOKEN_ID\n} from \"cctpr/assets/CctpRIds.sol\";\n\nuint constant PERMIT2_SPENDER_SIZE   = 20;\nuint constant PERMIT2_AMOUNT_SIZE    =  8;\nuint constant PERMIT2_NONCE_SIZE     = 32;\nuint constant PERMIT2_DEADLINE_SIZE  =  4;\nuint constant PERMIT2_SIGNATURE_SIZE = 65;\nuint constant GASLESS_AUTH_SIZE =\n  PERMIT2_SPENDER_SIZE +\n  PERMIT2_AMOUNT_SIZE +\n  PERMIT2_NONCE_SIZE +\n  PERMIT2_DEADLINE_SIZE +\n  PERMIT2_SIGNATURE_SIZE;\n\nuint8 constant QUOTE_OFF_CHAIN     = 0x00;\nuint8 constant QUOTE_ON_CHAIN_USDC = 0x01;\nuint8 constant QUOTE_ON_CHAIN_GAS  = 0x02;\n\n//the off chain gas token quote amount is encoded in nano (gwei)\n//  thus needs to be converted to ato (wei)\nuint constant NANO_TO_ATO = 1e9;\n\ncontract CctpR is CctpRBase, CctpROwner, CctpRQuote, CctpRUser, RawDispatcher {\n  using BytesParsing for bytes;\n  using {BytesParsing.checkBound, BytesParsing.checkLength} for uint;\n\n  constructor(\n    bool isMainnet,\n    address owner,\n    address feeAdjuster,\n    address feeRecipient,\n    address offChainQuoter,\n    address usdc,\n    address tokenMessengerV1,\n    address tokenMessengerV2,\n    address avaxRouter,\n    address priceOracle,\n    address permit2,\n    bytes memory chainData\n  )\n    CctpRBase(\n      isMainnet,\n      feeRecipient,\n      offChainQuoter,\n      chainData\n    )\n    CctpROwner(owner, feeAdjuster)\n    CctpRQuote(priceOracle)\n    CctpRUser(usdc, tokenMessengerV1, tokenMessengerV2, avaxRouter, permit2) {}\n\n  function _exec(bytes calldata data) internal override returns (bytes memory) { unchecked {\n    (uint8 id, uint offset) = data.asUint8CdUnchecked(0);\n    if (id < UPDATE_FEE_ADJUSTMENTS_ID) {\n      //some type of transfer with relay ID\n      uint transferUsdc;\n      uint8 destinationDomain;\n      bytes32 mintRecipient;\n      uint32 gasDropoffMicroGasToken;\n      Route route;\n      uint maxFastFeeUsdc;\n      if (id < TRANSFER_WITH_RELAY_GASLESS_ID) {\n        if (id == TRANSFER_WITH_RELAY_WITH_PERMIT_ID) {\n          bytes calldata permit;\n          (permit, offset) = data.sliceCdUnchecked(offset, PermitParsing.PERMIT_SIZE);\n          (uint256 value, uint256 deadline, bytes32 r, bytes32 s, uint8 v) =\n            PermitParsing.decodePermitCd(permit);\n          _redeemUserPermit(value, deadline, r, s, v);\n        }\n        else if (id != TRANSFER_WITH_RELAY_ID)\n          _invalidId();\n\n        ( transferUsdc,\n          destinationDomain,\n          mintRecipient,\n          gasDropoffMicroGasToken,\n          route,\n          maxFastFeeUsdc,\n          offset\n        ) = _userTransferWithRelay(data, offset);\n      }\n      else if (id == TRANSFER_WITH_RELAY_GASLESS_ID) {\n        _checkZeroMsgValue();\n\n        Permit2Data memory permit2Data; uint gaslessFeeUsdc;\n        (permit2Data.owner,     offset) = data.asAddressCdUnchecked(offset);\n        (permit2Data.amount,    offset) = data.asUint64CdUnchecked(offset);\n        (permit2Data.nonce,     offset) = data.asUint256CdUnchecked(offset);\n        (permit2Data.deadline,  offset) = data.asUint32CdUnchecked(offset);\n        (permit2Data.signature, offset) = data.sliceCdUnchecked(offset, PERMIT2_SIGNATURE_SIZE);\n        (gaslessFeeUsdc,        offset) = data.asUint64CdUnchecked(offset);\n        ( transferUsdc,\n          destinationDomain,\n          mintRecipient,\n          gasDropoffMicroGasToken,\n          route,\n          maxFastFeeUsdc,\n          offset\n        ) = _gaslessTransferWithRelay(permit2Data, gaslessFeeUsdc, data, offset);\n      }\n      else\n        _invalidId();\n\n      _requestRelay(\n        transferUsdc,\n        destinationDomain,\n        mintRecipient,\n        gasDropoffMicroGasToken,\n        route,\n        maxFastFeeUsdc //always taken from the transfer amount\n      );\n    }\n    else {\n      _checkZeroMsgValue();\n\n      while (true) {\n        if (id == UPDATE_FEE_ADJUSTMENTS_ID) {\n          uint8 feeType;\n          uint8 mappingIndex;\n          uint256 feeAdjustments;\n          (feeType,        offset) = data.asUint8CdUnchecked(offset);\n          (mappingIndex,   offset) = data.asUint8CdUnchecked(offset);\n          (feeAdjustments, offset) = data.asUint256CdUnchecked(offset);\n          _updateFeeAdjustments(feeType, mappingIndex, feeAdjustments);\n        }\n        else if (id == OWNER_SWEEP_TOKENS_ID) {\n          address token;\n          uint256 amount;\n          (token,  offset) = data.asAddressCdUnchecked(offset);\n          (amount, offset) = data.asUint256CdUnchecked(offset);\n          _sweepTokens(token, amount);\n        }\n        else if (\n          eagerOr(id == OWNER_UPDATE_FEE_RECIPIENT_ID,\n          eagerOr(id == OWNER_UPDATE_FEE_ADJUSTER_ID,\n          eagerOr(id == OWNER_UPDATE_OFFCHAIN_QUOTER_ID,\n                  id == OWNER_PROPOSE_OWNERSHIP_TRANSFER_ID)))\n        ) {\n          address addr;\n          (addr, offset) = data.asAddressCdUnchecked(offset);\n          if (id == OWNER_UPDATE_FEE_RECIPIENT_ID)\n            _updateFeeRecipient(addr);\n          else if (id == OWNER_UPDATE_FEE_ADJUSTER_ID)\n            _updateFeeAdjuster(addr);\n          else if (id == OWNER_UPDATE_OFFCHAIN_QUOTER_ID)\n            _updateOffchainQuoter(addr);\n          else\n            _proposeOwnershipTransfer(addr);\n        }\n        else if (id == OWNER_ACCEPT_OWNERSHIP_TRANSFER_ID)\n          _acceptOwnership();\n        else if (id == OWNER_CANCEL_OWNERSHIP_TRANSFER_ID)\n          _cancelOwnershipTransfer();\n        else if (id == OWNER_SET_CHAIN_ID_FOR_DOMAIN_ID) {\n          uint8 domain;\n          uint16 chainId;\n          (domain,  offset) = data.asUint8CdUnchecked(offset);\n          (chainId, offset) = data.asUint16CdUnchecked(offset);\n          _updateChainIdForDomain(domain, chainId);\n        }\n        else\n          _invalidId();\n\n        if (offset >= data.length)\n          break;\n\n        (id, offset) = data.asUint8CdUnchecked(offset);\n      }\n    }\n\n    data.length.checkLength(offset);\n\n    return new bytes(0);\n  }}\n\n  function _get(bytes calldata data) internal view override returns (bytes memory ret) { unchecked {\n    uint offset = 0;\n    while (offset < data.length) {\n      uint8 query;\n      (query, offset) = data.asUint8CdUnchecked(offset);\n      bool isUsdQuery = query == QUERY_RELAY_IN_USDC_ID;\n      require(eagerOr(isUsdQuery, query == QUERY_RELAY_IN_GAS_TOKEN_ID), \"Invalid query\");\n      uint8 destinationDomain; //deliberately read as uint8\n      uint8 routeRaw;\n      uint32 gasDropoffMicroGasToken;\n      (destinationDomain,       offset) = data.asUint8CdUnchecked(offset);\n      (routeRaw,                offset) = data.asUint8CdUnchecked(offset);\n      (gasDropoffMicroGasToken, offset) = data.asUint32CdUnchecked(offset);\n      Route route = Route(routeRaw);\n\n      function(uint8,Route,uint32) internal view returns (uint) quoteFunction = isUsdQuery\n        ? _quoteInUsdc\n        : _quoteInGasToken;\n\n      ret = abi.encodePacked(ret, quoteFunction(\n        destinationDomain,\n        route,\n        gasDropoffMicroGasToken\n      ));\n    }\n    data.length.checkLength(offset);\n    return ret;\n  }}\n\n  function _userTransferWithRelay(\n    bytes calldata data,\n    uint offset\n  ) private returns (\n    uint    transferUsdc,\n    uint8   destinationDomain,\n    bytes32 mintRecipient,\n    uint32  gasDropoffMicroGasToken,\n    Route   route,\n    uint    maxFastFeeUsdc,\n    uint    newOffset\n  ) { unchecked {\n    uint inputUsdc; uint quoteType;\n    ( inputUsdc,\n      destinationDomain,\n      mintRecipient,\n      gasDropoffMicroGasToken,\n      route,\n      maxFastFeeUsdc,\n      quoteType,\n      offset\n    ) = _parseTransferCommonFields(data, offset);\n\n    if (quoteType == QUOTE_OFF_CHAIN) {\n      ( uint32 expirationTime,\n        bool chargeInUsdc,\n        uint64 rawRelayFee,\n        bytes32 r,\n        bytes32 s,\n        uint8 v,\n        uint offset2\n      ) = _parseOffChainQuote(data, offset);\n      offset = offset2;\n\n      _verifyOffChainQuote(\n        destinationDomain,\n        route,\n        gasDropoffMicroGasToken,\n        expirationTime,\n        chargeInUsdc,\n        rawRelayFee,\n        r, s, v\n      );\n\n      if (chargeInUsdc) {\n        require(msg.value == 0, \"msg.value > 0 but charging relayFee in usdc\");\n        _transferSenderUsdcRelayFee(rawRelayFee); //already in usdc\n      }\n      else {\n        uint relayFee = uint(rawRelayFee) * NANO_TO_ATO;\n        require(msg.value == relayFee, \"msg.value != signed relayFee\");\n        _transferGasToken(_feeRecipient, relayFee);\n      }\n      transferUsdc = inputUsdc; //offChain quotes always take relay fees from the allowance\n    }\n    else if (quoteType == QUOTE_ON_CHAIN_USDC) {\n      uint maxRelayFeeUsdc; bool takeRelayFeeFromInput;\n      (maxRelayFeeUsdc, takeRelayFeeFromInput, offset) = _parseOnChainUsdcQuote(data, offset);\n\n      uint relayFeeUsdc = _quoteInUsdc(destinationDomain, route, gasDropoffMicroGasToken);\n      require(\n        eagerAnd(\n          relayFeeUsdc <= maxRelayFeeUsdc,\n          eagerOr(!takeRelayFeeFromInput, relayFeeUsdc < inputUsdc)\n        ),\n        \"usd relay fee exceeds input amount\"\n      );\n      _transferSenderUsdcRelayFee(relayFeeUsdc);\n      transferUsdc = takeRelayFeeFromInput ? inputUsdc - relayFeeUsdc : inputUsdc;\n    }\n    else if (quoteType == QUOTE_ON_CHAIN_GAS) {\n      uint relayFeeGasToken = _quoteInGasToken(destinationDomain, route, gasDropoffMicroGasToken);\n      require(relayFeeGasToken <= msg.value, \"Gas token relay fee exceeds msg.value\");\n      _transferGasToken(_feeRecipient, relayFeeGasToken);\n      emit RelayFeeGasTokenPayment(relayFeeGasToken);\n      _transferGasToken(msg.sender, msg.value - relayFeeGasToken);\n      transferUsdc = inputUsdc;\n    }\n    else\n      revert(\"Invalid quote type\");\n\n    _acquireUsdcFromSender(transferUsdc);\n\n    newOffset = offset;\n  }}\n\n  function _gaslessTransferWithRelay(\n    Permit2Data memory permit2Data,\n    uint gaslessFeeUsdc,\n    bytes calldata data,\n    uint offset\n  ) private returns (\n    uint    transferUsdc,\n    uint8   destinationDomain,\n    bytes32 mintRecipient,\n    uint32  gasDropoffMicroGasToken,\n    Route   route,\n    uint    maxFastFeeUsdc,\n    uint    newOffset\n) { unchecked {\n    uint inputUsdc; uint quoteType;\n    ( inputUsdc,\n      destinationDomain,\n      mintRecipient,\n      gasDropoffMicroGasToken,\n      route,\n      maxFastFeeUsdc,\n      quoteType,\n      offset\n    ) = _parseTransferCommonFields(data, offset);\n\n    transferUsdc = inputUsdc;\n    uint requiredAmount = inputUsdc + gaslessFeeUsdc;\n    uint relayFeeUsdc;\n    uint maxRelayFeeUsdc;\n    bool isOnChainQuote;\n    if (quoteType == QUOTE_OFF_CHAIN) {\n      uint32 expirationTime; bool chargeInUsdc; bytes32 r; bytes32 s; uint8 v;\n      (expirationTime, chargeInUsdc, relayFeeUsdc, r, s, v, offset) =\n        _parseOffChainQuote(data, offset);\n\n      require(chargeInUsdc, \"Gasless but !chargeInUsdc\");\n\n      _verifyOffChainQuote(\n        destinationDomain,\n        route,\n        gasDropoffMicroGasToken,\n        expirationTime,\n        chargeInUsdc,\n        uint64(relayFeeUsdc),\n        r, s, v\n      );\n\n      requiredAmount += relayFeeUsdc;\n      require(permit2Data.amount == requiredAmount, \"Invalid amount\");\n      maxRelayFeeUsdc = relayFeeUsdc;\n      isOnChainQuote = false;\n    }\n    else {\n      require(quoteType == QUOTE_ON_CHAIN_USDC, \"Invalid quote type\");\n      bool takeRelayFeeFromInput;\n      (maxRelayFeeUsdc, takeRelayFeeFromInput, offset) = _parseOnChainUsdcQuote(data, offset);\n\n      relayFeeUsdc = _quoteInUsdc(destinationDomain, route, gasDropoffMicroGasToken);\n      require(relayFeeUsdc <= maxRelayFeeUsdc, \"Relay fee > max\");\n      if (takeRelayFeeFromInput) {\n        require(relayFeeUsdc < inputUsdc, \"Insufficient input\");\n        transferUsdc -= relayFeeUsdc;\n      }\n      else\n        requiredAmount += relayFeeUsdc;\n\n      isOnChainQuote = true;\n    }\n\n    _redeemPermit2WithWitness(\n      requiredAmount,\n      permit2Data,\n      inputUsdc,\n      destinationDomain,\n      mintRecipient,\n      gasDropoffMicroGasToken,\n      route,\n      maxFastFeeUsdc,\n      gaslessFeeUsdc,\n      maxRelayFeeUsdc,\n      isOnChainQuote\n    );\n\n    _transferThisUsdcRelayFee(gaslessFeeUsdc + relayFeeUsdc);\n\n    newOffset = offset;\n  }}\n\n  function _checkZeroMsgValue() private view {\n    require(msg.value == 0, \"nonzero msg.value\");\n  }\n\n  function _invalidId() private pure {\n    revert(\"Invalid id\");\n  }\n\n  function _parseTransferCommonFields(bytes calldata data, uint offset) private pure returns (\n    uint    inputUsdc,\n    uint8   destinationDomain, //deliberately read as uint8\n    bytes32 mintRecipient,\n    uint32  gasDropoffMicroGasToken,\n    Route   route,\n    uint    maxFastFeeUsdc,\n    uint    quoteType,\n    uint    newOffset\n  ) {\n    (inputUsdc,               offset) = data.asUint64CdUnchecked(offset);\n    (destinationDomain,       offset) = data.asUint8CdUnchecked(offset);\n    (mintRecipient,           offset) = data.asBytes32CdUnchecked(offset);\n    (gasDropoffMicroGasToken, offset) = data.asUint32CdUnchecked(offset);\n    (route, maxFastFeeUsdc,   offset) = _parseRoute(data, offset);\n    (quoteType,               offset) = data.asUint8CdUnchecked(offset);\n    newOffset = offset;\n  }\n\n  function _parseRoute(bytes calldata data, uint offset) private pure returns (\n    Route route,\n    uint  maxFastFeeUsdc,\n    uint  newOffset\n  ) {\n    uint8 routeRaw;\n    (routeRaw, offset) = data.asUint8CdUnchecked(offset);\n    route = Route(routeRaw);\n    if (route != Route.V1)\n      (maxFastFeeUsdc, offset) = data.asUint64CdUnchecked(offset);\n    newOffset = offset;\n  }\n\n  function _parseOffChainQuote(bytes calldata data, uint offset) private pure returns (\n    uint32  expirationTime,\n    bool    chargeInUsdc,\n    uint64  rawRelayFee, //either in (micro/atomic)usdc or nano gas token\n    bytes32 r,\n    bytes32 s,\n    uint8   v,\n    uint    newOffset\n  ) { unchecked {\n    (expirationTime, offset) = data.asUint32CdUnchecked(offset);\n    (chargeInUsdc,   offset) = data.asBoolCdUnchecked(offset);\n    (rawRelayFee,    offset) = data.asUint64CdUnchecked(offset);\n    (r,              offset) = data.asBytes32CdUnchecked(offset);\n    (s,              offset) = data.asBytes32CdUnchecked(offset);\n    (v,              offset) = data.asUint8CdUnchecked(offset);\n    newOffset = offset;\n  }}\n\n  function _parseOnChainUsdcQuote(bytes calldata data, uint offset) private pure returns (\n    uint maxRelayFeeUsdc,\n    bool takeRelayFeeFromInput,\n    uint newOffset\n  ) {\n    (maxRelayFeeUsdc,       offset) = data.asUint64CdUnchecked(offset);\n    (takeRelayFeeFromInput, offset) = data.asBoolCdUnchecked(offset);\n    newOffset = offset;\n  }\n}\n"}, "lib/wormhole-solidity-sdk/src/libraries/BytesParsing.sol": {"content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.30;\n\nimport \"wormhole-sdk/constants/Common.sol\";\n\n//This file appears comically large, but all unused functions are removed by the compiler.\nlibrary BytesParsing {\n  error OutOfBounds(uint256 offset, uint256 length);\n  error LengthMismatch(uint256 encodedLength, uint256 expectedLength);\n  error InvalidBoolVal(uint8 val);\n\n  /**\n   * Implements runtime check of logic that accesses memory.\n   * @param pastTheEndOffset The offset past the end relative to the accessed memory fragment.\n   * @param length The length of the memory fragment accessed.\n   */\n  function checkBound(uint pastTheEndOffset, uint length) internal pure {\n    if (pastTheEndOffset > length)\n      revert OutOfBounds(pastTheEndOffset, length);\n  }\n\n  function checkLength(uint encodedLength, uint expectedLength) internal pure {\n    if (encodedLength != expectedLength)\n      revert LengthMismatch(encodedLength, expectedLength);\n  }\n\n  //Summary of all remaining functions:\n  //\n  //Each function has 2*2=4 versions:\n  //  1. unchecked - no bounds checking (uses suffix `Unchecked`)\n  //  2. checked (no suffix)\n  //and (since Solidity does not allow overloading based on data location)\n  //  1. calldata input (uses tag `Cd` )\n  //  2. memory input (uses tag `Mem`)\n  //\n  //The canoncial/recommended way of parsing data to be maximally gas efficient is to prefer the\n  //  calldata variants over the memory variants and to use the unchecked variants with a manual\n  //  length check at the end using `checkLength` to ensure that encoded data was consumed exactly.\n  //\n  //WARNING: Neither variant uses safe math! It is up to the dev to ensure that offset and length\n  //  values are sensible. In other words, verify user inputs before passing them on. Preferably,\n  //  the format that's being parsed does not allow for such overflows in the first place by e.g.\n  //  encoding lengths using at most 4 bytes, etc.\n  //\n  //Functions:\n  //  Unless stated otherwise, all functions take an `encoded` bytes calldata/memory and an `offset`\n  //    as input and return the parsed value and the next offset (i.e. the offset pointing to the\n  //    next, unparsed byte).\n  //\n  // * slice(encoded, offset, length)\n  // * sliceUint<n>Prefixed - n in {8, 16, 32} - parses n bytes of length prefix followed by data\n  // * asAddress\n  // * asBool\n  // * asUint<8*n> - n in {1, ..., 32}, i.e. asUint8, asUint16, ..., asUint256\n  // * asBytes<n>  - n in {1, ..., 32}, i.e. asBytes1, asBytes2, ..., asBytes32\n\n  function sliceCdUnchecked(\n    bytes calldata encoded,\n    uint offset,\n    uint length\n  ) internal pure returns (bytes calldata ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret.offset := add(encoded.offset, offset)\n      ret.length := length\n      nextOffset := add(offset, length)\n    }\n  }\n\n  function sliceMemUnchecked(\n    bytes memory encoded,\n    uint offset,\n    uint length\n  ) internal pure returns (bytes memory ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, length)\n      ret := mload(FREE_MEMORY_PTR)\n\n      //Explanation on how we copy data here:\n      //  The bytes type has the following layout in memory:\n      //    [length: 32 bytes, data: length bytes]\n      //  So if we allocate `bytes memory foo = new bytes(1);` then `foo` will be a pointer to 33\n      //    bytes where the first 32 bytes contain the length and the last byte is the actual data.\n      //  Since mload always loads 32 bytes of memory at once, we use our shift variable to align\n      //    our reads so that our last read lines up exactly with the last 32 bytes of `encoded`.\n      //  However this also means that if the length of `encoded` is not a multiple of 32 bytes, our\n      //    first read will necessarily partly contain bytes from `encoded`'s 32 length bytes that\n      //    will be written into the length part of our `ret` slice.\n      //  We remedy this issue by writing the length of our `ret` slice at the end, thus\n      //    overwritting those garbage bytes.\n\n      //and(length, 31) is equivalent to `mod(length, 32)`, but 2 gas cheaper\n      let shift := and(length, WORD_SIZE_MINUS_ONE)\n      if iszero(shift) {\n        shift := WORD_SIZE\n      }\n\n      let dest := add(ret, shift)\n      let end := add(dest, length)\n      for {\n        let src := add(add(encoded, shift), offset)\n      } lt(dest, end) {\n        src := add(src, WORD_SIZE)\n        dest := add(dest, WORD_SIZE)\n      } {\n        mstore(dest, mload(src))\n      }\n\n      mstore(ret, length)\n      //When compiling with --via-ir then normally allocated memory (i.e. via new) will have 32 byte\n      //  memory alignment and so we enforce the same memory alignment here.\n      mstore(\n        FREE_MEMORY_PTR,\n        and(add(dest, WORD_SIZE_MINUS_ONE), not(WORD_SIZE_MINUS_ONE))\n      )\n    }\n  }\n\n/* -------------------------------------------------------------------------------------------------\nRemaining library code below was auto-generated via the following js/node code:\n\nconst dlTag = dl => dl ? \"Cd\" : \"Mem\";\nconst dlType = dl =>dl ? \"calldata\" : \"memory\";\n\nconst funcs = [\n  ...[8,16,32].map(n => [\n    `sliceUint${n}Prefixed`,\n    dl => [\n      `uint${n} len;`,\n      `(len, nextOffset) = asUint${n}${dlTag(dl)}Unchecked(encoded, offset);`,\n      `(ret, nextOffset) = slice${dlTag(dl)}Unchecked(encoded, nextOffset, uint(len));`\n    ],\n    dl => `bytes ${dlType(dl)}`,\n  ]), [\n    `asAddress`,\n    dl => [\n      `uint160 tmp;`,\n      `(tmp, nextOffset) = asUint160${dlTag(dl)}Unchecked(encoded, offset);`,\n      `ret = address(tmp);`\n    ],\n    _ => `address`\n  ], [\n    `asBool`,\n    dl => [\n      `uint8 val;`,\n      `(val, nextOffset) = asUint8${dlTag(dl)}Unchecked(encoded, offset);`,\n      `if (val & 0xfe != 0)`,\n      `  revert InvalidBoolVal(val);`,\n      `uint cleanedVal = uint(val);`,\n      `//skip 2x iszero opcode`,\n      `/// @solidity memory-safe-assembly`,\n      `assembly { ret := cleanedVal }`\n    ],\n    _ => `bool`\n  ],\n  ...Array.from({length: 32}, (_, i) => [\n    `asUint${(i+1)*8}`,\n    dl => [\n      `/// @solidity memory-safe-assembly`,\n      `assembly {`,\n      `  nextOffset := add(offset, ${i+1})`,\n      dl ? `  ret := shr(${256-(i+1)*8}, calldataload(add(encoded.offset, offset)))`\n         : `  ret := mload(add(encoded, nextOffset))`,\n      `}`\n    ],\n    _ => `uint${(i+1)*8}`\n  ]),\n  ...Array.from({length: 32}, (_, i) => [\n    `asBytes${i+1}`,\n    dl => [\n      `/// @solidity memory-safe-assembly`,\n      `assembly {`,\n      `  ret := ${dl ? \"calldataload\" : \"mload\"}(add(encoded${dl ? \".offset\" :\"\"}, ${dl ? \"offset\" : \"add(offset, WORD_SIZE)\"}))`,\n      `  nextOffset := add(offset, ${i+1})`,\n      `}`\n    ],\n    _ => `bytes${i+1}`\n  ]),\n];\n\nfor (const dl of [true, false])\n  console.log(\n`function slice${dlTag(dl)}(\n  bytes ${dlType(dl)} encoded,\n  uint offset,\n  uint length\n) internal pure returns (bytes ${dlType(dl)} ret, uint nextOffset) {\n  (ret, nextOffset) = slice${dlTag(dl)}Unchecked(encoded, offset, length);\n  checkBound(nextOffset, encoded.length);\n}\n`);\n\nfor (const [name, code, ret] of funcs) {\n  for (const dl of [true, false])\n    console.log(\n`function ${name}${dlTag(dl)}Unchecked(\n  bytes ${dlType(dl)} encoded,\n  uint offset\n) internal pure returns (${ret(dl)} ret, uint nextOffset) {\n  ${code(dl).join(\"\\n  \")}\n}\n\nfunction ${name}${dlTag(dl)}(\n  bytes ${dlType(dl)} encoded,\n  uint offset\n) internal pure returns (${ret(dl)} ret, uint nextOffset) {\n  (ret, nextOffset) = ${name}${dlTag(dl)}Unchecked(encoded, offset);\n  checkBound(nextOffset, encoded.length);\n}\n`);\n}\n------------------------------------------------------------------------------------------------- */\n\n  function sliceCd(\n    bytes calldata encoded,\n    uint offset,\n    uint length\n  ) internal pure returns (bytes calldata ret, uint nextOffset) {\n    (ret, nextOffset) = sliceCdUnchecked(encoded, offset, length);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function sliceMem(\n    bytes memory encoded,\n    uint offset,\n    uint length\n  ) internal pure returns (bytes memory ret, uint nextOffset) {\n    (ret, nextOffset) = sliceMemUnchecked(encoded, offset, length);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function sliceUint8PrefixedCdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes calldata ret, uint nextOffset) {\n    uint8 len;\n    (len, nextOffset) = asUint8CdUnchecked(encoded, offset);\n    (ret, nextOffset) = sliceCdUnchecked(encoded, nextOffset, uint(len));\n  }\n\n  function sliceUint8PrefixedCd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes calldata ret, uint nextOffset) {\n    (ret, nextOffset) = sliceUint8PrefixedCdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function sliceUint8PrefixedMemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes memory ret, uint nextOffset) {\n    uint8 len;\n    (len, nextOffset) = asUint8MemUnchecked(encoded, offset);\n    (ret, nextOffset) = sliceMemUnchecked(encoded, nextOffset, uint(len));\n  }\n\n  function sliceUint8PrefixedMem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes memory ret, uint nextOffset) {\n    (ret, nextOffset) = sliceUint8PrefixedMemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function sliceUint16PrefixedCdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes calldata ret, uint nextOffset) {\n    uint16 len;\n    (len, nextOffset) = asUint16CdUnchecked(encoded, offset);\n    (ret, nextOffset) = sliceCdUnchecked(encoded, nextOffset, uint(len));\n  }\n\n  function sliceUint16PrefixedCd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes calldata ret, uint nextOffset) {\n    (ret, nextOffset) = sliceUint16PrefixedCdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function sliceUint16PrefixedMemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes memory ret, uint nextOffset) {\n    uint16 len;\n    (len, nextOffset) = asUint16MemUnchecked(encoded, offset);\n    (ret, nextOffset) = sliceMemUnchecked(encoded, nextOffset, uint(len));\n  }\n\n  function sliceUint16PrefixedMem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes memory ret, uint nextOffset) {\n    (ret, nextOffset) = sliceUint16PrefixedMemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function sliceUint32PrefixedCdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes calldata ret, uint nextOffset) {\n    uint32 len;\n    (len, nextOffset) = asUint32CdUnchecked(encoded, offset);\n    (ret, nextOffset) = sliceCdUnchecked(encoded, nextOffset, uint(len));\n  }\n\n  function sliceUint32PrefixedCd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes calldata ret, uint nextOffset) {\n    (ret, nextOffset) = sliceUint32PrefixedCdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function sliceUint32PrefixedMemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes memory ret, uint nextOffset) {\n    uint32 len;\n    (len, nextOffset) = asUint32MemUnchecked(encoded, offset);\n    (ret, nextOffset) = sliceMemUnchecked(encoded, nextOffset, uint(len));\n  }\n\n  function sliceUint32PrefixedMem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes memory ret, uint nextOffset) {\n    (ret, nextOffset) = sliceUint32PrefixedMemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asAddressCdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (address ret, uint nextOffset) {\n    uint160 tmp;\n    (tmp, nextOffset) = asUint160CdUnchecked(encoded, offset);\n    ret = address(tmp);\n  }\n\n  function asAddressCd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (address ret, uint nextOffset) {\n    (ret, nextOffset) = asAddressCdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asAddressMemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (address ret, uint nextOffset) {\n    uint160 tmp;\n    (tmp, nextOffset) = asUint160MemUnchecked(encoded, offset);\n    ret = address(tmp);\n  }\n\n  function asAddressMem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (address ret, uint nextOffset) {\n    (ret, nextOffset) = asAddressMemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBoolCdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bool ret, uint nextOffset) {\n    uint8 val;\n    (val, nextOffset) = asUint8CdUnchecked(encoded, offset);\n    if (val & 0xfe != 0)\n      revert InvalidBoolVal(val);\n    uint cleanedVal = uint(val);\n    //skip 2x iszero opcode\n    /// @solidity memory-safe-assembly\n    assembly { ret := cleanedVal }\n  }\n\n  function asBoolCd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bool ret, uint nextOffset) {\n    (ret, nextOffset) = asBoolCdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBoolMemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bool ret, uint nextOffset) {\n    uint8 val;\n    (val, nextOffset) = asUint8MemUnchecked(encoded, offset);\n    if (val & 0xfe != 0)\n      revert InvalidBoolVal(val);\n    uint cleanedVal = uint(val);\n    //skip 2x iszero opcode\n    /// @solidity memory-safe-assembly\n    assembly { ret := cleanedVal }\n  }\n\n  function asBoolMem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bool ret, uint nextOffset) {\n    (ret, nextOffset) = asBoolMemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint8CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint8 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 1)\n      ret := shr(248, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint8Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint8 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint8CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint8MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint8 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 1)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint8Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint8 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint8MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint16CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint16 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 2)\n      ret := shr(240, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint16Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint16 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint16CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint16MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint16 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 2)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint16Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint16 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint16MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint24CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint24 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 3)\n      ret := shr(232, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint24Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint24 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint24CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint24MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint24 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 3)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint24Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint24 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint24MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint32CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint32 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 4)\n      ret := shr(224, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint32Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint32 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint32CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint32MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint32 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 4)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint32Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint32 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint32MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint40CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint40 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 5)\n      ret := shr(216, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint40Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint40 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint40CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint40MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint40 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 5)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint40Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint40 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint40MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint48CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint48 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 6)\n      ret := shr(208, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint48Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint48 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint48CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint48MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint48 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 6)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint48Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint48 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint48MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint56CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint56 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 7)\n      ret := shr(200, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint56Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint56 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint56CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint56MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint56 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 7)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint56Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint56 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint56MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint64CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint64 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 8)\n      ret := shr(192, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint64Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint64 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint64CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint64MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint64 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 8)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint64Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint64 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint64MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint72CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint72 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 9)\n      ret := shr(184, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint72Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint72 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint72CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint72MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint72 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 9)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint72Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint72 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint72MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint80CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint80 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 10)\n      ret := shr(176, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint80Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint80 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint80CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint80MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint80 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 10)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint80Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint80 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint80MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint88CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint88 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 11)\n      ret := shr(168, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint88Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint88 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint88CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint88MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint88 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 11)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint88Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint88 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint88MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint96CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint96 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 12)\n      ret := shr(160, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint96Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint96 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint96CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint96MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint96 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 12)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint96Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint96 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint96MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint104CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint104 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 13)\n      ret := shr(152, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint104Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint104 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint104CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint104MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint104 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 13)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint104Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint104 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint104MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint112CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint112 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 14)\n      ret := shr(144, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint112Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint112 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint112CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint112MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint112 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 14)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint112Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint112 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint112MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint120CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint120 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 15)\n      ret := shr(136, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint120Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint120 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint120CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint120MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint120 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 15)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint120Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint120 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint120MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint128CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint128 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 16)\n      ret := shr(128, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint128Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint128 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint128CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint128MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint128 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 16)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint128Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint128 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint128MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint136CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint136 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 17)\n      ret := shr(120, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint136Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint136 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint136CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint136MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint136 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 17)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint136Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint136 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint136MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint144CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint144 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 18)\n      ret := shr(112, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint144Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint144 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint144CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint144MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint144 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 18)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint144Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint144 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint144MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint152CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint152 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 19)\n      ret := shr(104, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint152Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint152 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint152CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint152MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint152 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 19)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint152Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint152 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint152MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint160CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint160 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 20)\n      ret := shr(96, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint160Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint160 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint160CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint160MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint160 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 20)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint160Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint160 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint160MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint168CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint168 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 21)\n      ret := shr(88, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint168Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint168 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint168CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint168MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint168 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 21)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint168Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint168 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint168MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint176CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint176 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 22)\n      ret := shr(80, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint176Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint176 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint176CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint176MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint176 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 22)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint176Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint176 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint176MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint184CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint184 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 23)\n      ret := shr(72, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint184Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint184 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint184CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint184MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint184 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 23)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint184Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint184 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint184MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint192CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint192 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 24)\n      ret := shr(64, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint192Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint192 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint192CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint192MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint192 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 24)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint192Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint192 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint192MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint200CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint200 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 25)\n      ret := shr(56, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint200Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint200 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint200CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint200MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint200 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 25)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint200Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint200 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint200MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint208CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint208 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 26)\n      ret := shr(48, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint208Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint208 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint208CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint208MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint208 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 26)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint208Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint208 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint208MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint216CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint216 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 27)\n      ret := shr(40, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint216Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint216 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint216CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint216MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint216 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 27)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint216Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint216 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint216MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint224CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint224 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 28)\n      ret := shr(32, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint224Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint224 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint224CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint224MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint224 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 28)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint224Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint224 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint224MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint232CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint232 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 29)\n      ret := shr(24, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint232Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint232 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint232CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint232MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint232 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 29)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint232Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint232 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint232MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint240CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint240 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 30)\n      ret := shr(16, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint240Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint240 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint240CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint240MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint240 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 30)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint240Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint240 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint240MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint248CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint248 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 31)\n      ret := shr(8, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint248Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint248 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint248CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint248MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint248 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 31)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint248Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint248 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint248MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint256CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint256 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 32)\n      ret := shr(0, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint256Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint256 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint256CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint256MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint256 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 32)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint256Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint256 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint256MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes1CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes1 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 1)\n    }\n  }\n\n  function asBytes1Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes1 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes1CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes1MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes1 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 1)\n    }\n  }\n\n  function asBytes1Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes1 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes1MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes2CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes2 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 2)\n    }\n  }\n\n  function asBytes2Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes2 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes2CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes2MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes2 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 2)\n    }\n  }\n\n  function asBytes2Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes2 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes2MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes3CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes3 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 3)\n    }\n  }\n\n  function asBytes3Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes3 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes3CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes3MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes3 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 3)\n    }\n  }\n\n  function asBytes3Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes3 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes3MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes4CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes4 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 4)\n    }\n  }\n\n  function asBytes4Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes4 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes4CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes4MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes4 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 4)\n    }\n  }\n\n  function asBytes4Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes4 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes4MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes5CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes5 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 5)\n    }\n  }\n\n  function asBytes5Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes5 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes5CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes5MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes5 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 5)\n    }\n  }\n\n  function asBytes5Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes5 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes5MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes6CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes6 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 6)\n    }\n  }\n\n  function asBytes6Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes6 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes6CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes6MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes6 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 6)\n    }\n  }\n\n  function asBytes6Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes6 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes6MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes7CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes7 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 7)\n    }\n  }\n\n  function asBytes7Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes7 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes7CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes7MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes7 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 7)\n    }\n  }\n\n  function asBytes7Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes7 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes7MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes8CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes8 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 8)\n    }\n  }\n\n  function asBytes8Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes8 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes8CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes8MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes8 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 8)\n    }\n  }\n\n  function asBytes8Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes8 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes8MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes9CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes9 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 9)\n    }\n  }\n\n  function asBytes9Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes9 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes9CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes9MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes9 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 9)\n    }\n  }\n\n  function asBytes9Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes9 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes9MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes10CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes10 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 10)\n    }\n  }\n\n  function asBytes10Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes10 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes10CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes10MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes10 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 10)\n    }\n  }\n\n  function asBytes10Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes10 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes10MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes11CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes11 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 11)\n    }\n  }\n\n  function asBytes11Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes11 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes11CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes11MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes11 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 11)\n    }\n  }\n\n  function asBytes11Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes11 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes11MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes12CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes12 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 12)\n    }\n  }\n\n  function asBytes12Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes12 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes12CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes12MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes12 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 12)\n    }\n  }\n\n  function asBytes12Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes12 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes12MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes13CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes13 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 13)\n    }\n  }\n\n  function asBytes13Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes13 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes13CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes13MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes13 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 13)\n    }\n  }\n\n  function asBytes13Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes13 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes13MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes14CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes14 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 14)\n    }\n  }\n\n  function asBytes14Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes14 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes14CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes14MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes14 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 14)\n    }\n  }\n\n  function asBytes14Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes14 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes14MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes15CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes15 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 15)\n    }\n  }\n\n  function asBytes15Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes15 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes15CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes15MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes15 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 15)\n    }\n  }\n\n  function asBytes15Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes15 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes15MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes16CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes16 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 16)\n    }\n  }\n\n  function asBytes16Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes16 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes16CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes16MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes16 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 16)\n    }\n  }\n\n  function asBytes16Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes16 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes16MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes17CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes17 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 17)\n    }\n  }\n\n  function asBytes17Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes17 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes17CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes17MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes17 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 17)\n    }\n  }\n\n  function asBytes17Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes17 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes17MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes18CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes18 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 18)\n    }\n  }\n\n  function asBytes18Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes18 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes18CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes18MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes18 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 18)\n    }\n  }\n\n  function asBytes18Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes18 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes18MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes19CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes19 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 19)\n    }\n  }\n\n  function asBytes19Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes19 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes19CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes19MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes19 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 19)\n    }\n  }\n\n  function asBytes19Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes19 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes19MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes20CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes20 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 20)\n    }\n  }\n\n  function asBytes20Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes20 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes20CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes20MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes20 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 20)\n    }\n  }\n\n  function asBytes20Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes20 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes20MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes21CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes21 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 21)\n    }\n  }\n\n  function asBytes21Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes21 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes21CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes21MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes21 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 21)\n    }\n  }\n\n  function asBytes21Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes21 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes21MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes22CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes22 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 22)\n    }\n  }\n\n  function asBytes22Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes22 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes22CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes22MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes22 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 22)\n    }\n  }\n\n  function asBytes22Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes22 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes22MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes23CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes23 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 23)\n    }\n  }\n\n  function asBytes23Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes23 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes23CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes23MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes23 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 23)\n    }\n  }\n\n  function asBytes23Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes23 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes23MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes24CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes24 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 24)\n    }\n  }\n\n  function asBytes24Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes24 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes24CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes24MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes24 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 24)\n    }\n  }\n\n  function asBytes24Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes24 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes24MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes25CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes25 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 25)\n    }\n  }\n\n  function asBytes25Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes25 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes25CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes25MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes25 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 25)\n    }\n  }\n\n  function asBytes25Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes25 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes25MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes26CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes26 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 26)\n    }\n  }\n\n  function asBytes26Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes26 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes26CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes26MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes26 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 26)\n    }\n  }\n\n  function asBytes26Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes26 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes26MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes27CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes27 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 27)\n    }\n  }\n\n  function asBytes27Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes27 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes27CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes27MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes27 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 27)\n    }\n  }\n\n  function asBytes27Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes27 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes27MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes28CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes28 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 28)\n    }\n  }\n\n  function asBytes28Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes28 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes28CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes28MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes28 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 28)\n    }\n  }\n\n  function asBytes28Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes28 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes28MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes29CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes29 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 29)\n    }\n  }\n\n  function asBytes29Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes29 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes29CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes29MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes29 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 29)\n    }\n  }\n\n  function asBytes29Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes29 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes29MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes30CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes30 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 30)\n    }\n  }\n\n  function asBytes30Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes30 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes30CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes30MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes30 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 30)\n    }\n  }\n\n  function asBytes30Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes30 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes30MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes31CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes31 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 31)\n    }\n  }\n\n  function asBytes31Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes31 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes31CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes31MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes31 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 31)\n    }\n  }\n\n  function asBytes31Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes31 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes31MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes32CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes32 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 32)\n    }\n  }\n\n  function asBytes32Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes32 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes32CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes32MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes32 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 32)\n    }\n  }\n\n  function asBytes32Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes32 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes32MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n}\n"}, "lib/wormhole-solidity-sdk/src/libraries/PermitParsing.sol": {"content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.30; //for (bugfixed) support of `using ... global;` syntax for libraries\n\nimport {BytesParsing} from \"wormhole-sdk/libraries/BytesParsing.sol\";\n\n// \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n// \u2502 Library for decoding ERC2612 Permit and Permit2 signatures and metadata \u2502\n// \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\n// # Format\n//\n// \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n// \u2502  Type   \u2502     Name    \u2502     Description                                   \u2502\n// \u251d\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2537\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2537\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2525\n// \u2502       ERC2612 Permit                                                      \u2502\n// \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n// \u2502 uint256 \u2502 value       \u2502 amount of tokens to approve                       \u2502\n// \u2502 uint256 \u2502 deadline    \u2502 unix timestamp until which the signature is valid \u2502\n// \u2502 bytes32 \u2502 r           \u2502 ECDSA signature component                         \u2502\n// \u2502 bytes32 \u2502 s           \u2502 ECDSA signature component                         \u2502\n// \u2502 uint8   \u2502 v           \u2502 ECDSA signature component                         \u2502\n// \u251d\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2537\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2537\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2525\n// \u2502       Permit2 Permit                                                      \u2502\n// \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n// \u2502 uint160 \u2502 amount      \u2502 amount of tokens to approve                       \u2502\n// \u2502 uint48  \u2502 expiration  \u2502 unix timestamp until which the approval is valid  \u2502\n// \u2502 uint48  \u2502 nonce       \u2502 akin to EVM transaction nonce (must count up)     \u2502\n// \u2502 uint256 \u2502 sigDeadline \u2502 timestamp until which the signature is valid      \u2502\n// \u2502 bytes   \u2502 signature   \u2502 ECDSA signature (r,s,v packed into 65 bytes)      \u2502\n// \u251d\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2537\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2537\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2525\n// \u2502       Permit2 Transfer                                                    \u2502\n// \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n// \u2502 uint256 \u2502 amount      \u2502 amount of tokens to transfer                      \u2502\n// \u2502 uint256 \u2502 nonce       \u2502 akin to EVM transaction nonce (must count up)     \u2502\n// \u2502 uint256 \u2502 sigDeadline \u2502 unix timestamp until which the signature is valid \u2502\n// \u2502 bytes   \u2502 signature   \u2502 ECDSA signature (r,s,v packed into 65 bytes)      \u2502\n// \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n//\n// # Library Functions & Naming Conventions\n//\n// All decode library functions come in 2x2=4 flavors:\n//   1. Data-Location:\n//     1.1. Calldata (using the Cd tag)\n//     1.2. Memory (using the Mem tag)\n//   2. Return Value:\n//     2.1. individual, stack-based return values (no extra tag)\n//     2.2. the associated, memory-allocated Struct (using the Struct tag)\n//\n// Like in BytesParsing, the Unchecked function name suffix does not refer to\n//   Solidity's `unchecked` keyword, but rather to the fact that no bounds checking\n//   is performed.\n//\n// Decoding functions flavorless base names:\n//   * decodePermit\n//   * decodePermit2Permit\n//   * decodePermit2Transfer\n//\n// Encoding functions (should only be relevant for testing):\n//   * encode (overloaded for each struct)\n//   * encodePermit\n//   * encodePermit2Permit\n//   * encodePermit2Transfer\n\nstruct Permit {\n  uint256 value;\n  uint256 deadline;\n  bytes32 r;\n  bytes32 s;\n  uint8   v;\n}\n\nstruct Permit2Permit {\n  uint160 amount;\n  uint48  expiration;\n  uint48  nonce;\n  uint256 sigDeadline;\n  bytes   signature;\n}\n\nstruct Permit2Transfer {\n  uint256 amount;\n  uint256 nonce;\n  uint256 sigDeadline;\n  bytes   signature;\n}\n\nlibrary PermitParsing {\n  using BytesParsing for bytes;\n  using {BytesParsing.checkLength} for uint;\n\n  error InvalidSignatureLength(uint length);\n\n  uint internal constant SIGNATURE_SIZE = 65;\n  uint internal constant PERMIT_SIZE = 32 + 32 + SIGNATURE_SIZE;\n  uint internal constant PERMIT2_PERMIT_SIZE = 20 + 6 + 6 + 32 + SIGNATURE_SIZE;\n  uint internal constant PERMIT2_TRANSFER_SIZE = 32 + 32 + 32 + SIGNATURE_SIZE;\n\n  // ERC2612 Permit\n\n  function decodePermitCd(\n    bytes calldata params\n  ) internal pure returns (\n    uint256 value,\n    uint256 deadline,\n    bytes32 r,\n    bytes32 s,\n    uint8   v\n  ) {\n    uint offset = 0;\n    (value, deadline, r, s, v, offset) = decodePermitCdUnchecked(params, offset);\n    params.length.checkLength(offset);\n  }\n\n  function decodePermitStructCd(\n    bytes calldata params\n  ) internal pure returns (Permit memory permit) {\n    ( permit.value,\n      permit.deadline,\n      permit.r,\n      permit.s,\n      permit.v\n    ) = decodePermitCd(params);\n  }\n\n  function decodePermitCdUnchecked(\n    bytes calldata params,\n    uint offset\n  ) internal pure returns (\n    uint256 value,\n    uint256 deadline,\n    bytes32 r,\n    bytes32 s,\n    uint8 v,\n    uint newOffset\n  ) {\n    (value,    offset) = params.asUint256CdUnchecked(offset);\n    (deadline, offset) = params.asUint256CdUnchecked(offset);\n    (r,        offset) = params.asBytes32CdUnchecked(offset);\n    (s,        offset) = params.asBytes32CdUnchecked(offset);\n    (v,        offset) = params.asUint8CdUnchecked(offset);\n    newOffset = offset;\n  }\n\n  function decodePermitCdStructUnchecked(\n    bytes calldata params,\n    uint offset\n  ) internal pure returns (Permit memory permit, uint newOffset) {\n    ( permit.value,\n      permit.deadline,\n      permit.r,\n      permit.s,\n      permit.v,\n      newOffset\n    ) = decodePermitCdUnchecked(params, offset);\n  }\n\n  function decodePermitMem(\n    bytes memory params\n  ) internal pure returns (\n    uint256 value,\n    uint256 deadline,\n    bytes32 r,\n    bytes32 s,\n    uint8   v\n  ) {\n    uint offset = 0;\n    (value, deadline, r, s, v, offset) = decodePermitMemUnchecked(params, offset);\n    params.length.checkLength(offset);\n  }\n\n  function decodePermitStructMem(\n    bytes memory params\n  ) internal pure returns (Permit memory permit) {\n    ( permit.value,\n      permit.deadline,\n      permit.r,\n      permit.s,\n      permit.v\n    ) = decodePermitMem(params);\n  }\n\n  function decodePermitMemUnchecked(\n    bytes memory params,\n    uint offset\n  ) internal pure returns (\n    uint256 value,\n    uint256 deadline,\n    bytes32 r,\n    bytes32 s,\n    uint8   v,\n    uint newOffset\n  ) {\n    (value,    offset) = params.asUint256MemUnchecked(offset);\n    (deadline, offset) = params.asUint256MemUnchecked(offset);\n    (r,        offset) = params.asBytes32MemUnchecked(offset);\n    (s,        offset) = params.asBytes32MemUnchecked(offset);\n    (v,        offset) = params.asUint8MemUnchecked(offset);\n    newOffset = offset;\n  }\n\n  function decodePermitMemStructUnchecked(\n    bytes memory params,\n    uint offset\n  ) internal pure returns (Permit memory permit, uint newOffset) {\n    ( permit.value,\n      permit.deadline,\n      permit.r,\n      permit.s,\n      permit.v,\n      newOffset\n    ) = decodePermitMemUnchecked(params, offset);\n  }\n\n  // Permit2 Permit\n\n  function decodePermit2PermitCd(\n    bytes calldata params\n  ) internal pure returns (\n    uint160 amount,\n    uint48  expiration,\n    uint48  nonce,\n    uint256 sigDeadline,\n    bytes calldata signature\n  ) {\n    uint offset = 0;\n    (amount, expiration, nonce, sigDeadline, signature, offset) =\n      decodePermit2PermitCdUnchecked(params, offset);\n    params.length.checkLength(offset);\n  }\n\n  function decodePermit2PermitStructCd(\n    bytes calldata params\n  ) internal pure returns (Permit2Permit memory permit) {\n    ( permit.amount,\n      permit.expiration,\n      permit.nonce,\n      permit.sigDeadline,\n      permit.signature\n    ) = decodePermit2PermitCd(params);\n  }\n\n  function decodePermit2PermitCdUnchecked(\n    bytes calldata params,\n    uint offset\n  ) internal pure returns (\n    uint160 amount,\n    uint48  expiration,\n    uint48  nonce,\n    uint256 sigDeadline,\n    bytes calldata signature,\n    uint    newOffset\n  ) {\n    (amount,      offset) = params.asUint160CdUnchecked(offset);\n    (expiration,  offset) = params.asUint48CdUnchecked(offset);\n    (nonce,       offset) = params.asUint48CdUnchecked(offset);\n    (sigDeadline, offset) = params.asUint256CdUnchecked(offset);\n    (signature,   offset) = params.sliceCdUnchecked(offset, SIGNATURE_SIZE);\n    newOffset = offset;\n  }\n\n  function decodePermit2PermitCdStructUnchecked(\n    bytes calldata params,\n    uint offset\n  ) internal pure returns (Permit2Permit memory permit, uint newOffset) {\n    ( permit.amount,\n      permit.expiration,\n      permit.nonce,\n      permit.sigDeadline,\n      permit.signature,\n      newOffset\n    ) = decodePermit2PermitCdUnchecked(params, offset);\n  }\n\n  function decodePermit2PermitMem(\n    bytes memory params\n  ) internal pure returns (\n    uint160 amount,\n    uint48  expiration,\n    uint48  nonce,\n    uint256 sigDeadline,\n    bytes memory signature\n  ) {\n    uint offset = 0;\n    (amount, expiration, nonce, sigDeadline, signature, offset) =\n      decodePermit2PermitMemUnchecked(params, offset);\n    params.length.checkLength(offset);\n  }\n\n  function decodePermit2PermitStructMem(\n    bytes memory params\n  ) internal pure returns (Permit2Permit memory permit) {\n    ( permit.amount,\n      permit.expiration,\n      permit.nonce,\n      permit.sigDeadline,\n      permit.signature\n    ) = decodePermit2PermitMem(params);\n  }\n\n  function decodePermit2PermitMemUnchecked(\n    bytes memory params,\n    uint offset\n  ) internal pure returns (\n    uint160 amount,\n    uint48  expiration,\n    uint48  nonce,\n    uint256 sigDeadline,\n    bytes memory signature,\n    uint    newOffset\n  ) {\n    (amount,      offset) = params.asUint160MemUnchecked(offset);\n    (expiration,  offset) = params.asUint48MemUnchecked(offset);\n    (nonce,       offset) = params.asUint48MemUnchecked(offset);\n    (sigDeadline, offset) = params.asUint256MemUnchecked(offset);\n    (signature,   offset) = params.sliceMemUnchecked(offset, SIGNATURE_SIZE);\n    newOffset = offset;\n  }\n\n  function decodePermit2PermitMemStructUnchecked(\n    bytes memory params,\n    uint offset\n  ) internal pure returns (Permit2Permit memory permit, uint newOffset) {\n    ( permit.amount,\n      permit.expiration,\n      permit.nonce,\n      permit.sigDeadline,\n      permit.signature,\n      newOffset\n    ) = decodePermit2PermitMemUnchecked(params, offset);\n  }\n\n  // Permit2 Transfer\n\n  function decodePermit2TransferCd(\n    bytes calldata params\n  ) internal pure returns (\n    uint256 amount,\n    uint256 nonce,\n    uint256 sigDeadline,\n    bytes memory signature\n  ) {\n    uint offset = 0;\n    (amount, nonce, sigDeadline, signature, offset) =\n      decodePermit2TransferCdUnchecked(params, offset);\n    params.length.checkLength(offset);\n  }\n\n  function decodePermit2TransferStructCd(\n    bytes calldata params\n  ) internal pure returns (Permit2Transfer memory transfer) {\n    ( transfer.amount,\n      transfer.nonce,\n      transfer.sigDeadline,\n      transfer.signature\n    ) = decodePermit2TransferCd(params);\n  }\n\n  function decodePermit2TransferCdUnchecked(\n    bytes calldata params,\n    uint offset\n  ) internal pure returns (\n    uint256 amount,\n    uint256 nonce,\n    uint256 sigDeadline,\n    bytes memory signature,\n    uint    newOffset\n  ) {\n    (amount,      offset) = params.asUint256CdUnchecked(offset);\n    (nonce,       offset) = params.asUint256CdUnchecked(offset);\n    (sigDeadline, offset) = params.asUint256CdUnchecked(offset);\n    (signature,   offset) = params.sliceCdUnchecked(offset, SIGNATURE_SIZE);\n    newOffset = offset;\n  }\n\n  function decodePermit2TransferCdStructUnchecked(\n    bytes calldata params,\n    uint offset\n  ) internal pure returns (Permit2Transfer memory transfer, uint newOffset) {\n    ( transfer.amount,\n      transfer.nonce,\n      transfer.sigDeadline,\n      transfer.signature,\n      newOffset\n    ) = decodePermit2TransferCdUnchecked(params, offset);\n  }\n\n  function decodePermit2TransferMem(\n    bytes memory params\n  ) internal pure returns (\n    uint256 amount,\n    uint256 nonce,\n    uint256 sigDeadline,\n    bytes memory signature\n  ) {\n    (amount, nonce, sigDeadline, signature, ) =\n      decodePermit2TransferMemUnchecked(params, 0);\n  }\n\n  function decodePermit2TransferStructMem(\n    bytes memory params\n  ) internal pure returns (Permit2Transfer memory transfer) {\n    ( transfer.amount,\n      transfer.nonce,\n      transfer.sigDeadline,\n      transfer.signature\n    ) = decodePermit2TransferMem(params);\n  }\n\n  function decodePermit2TransferMemUnchecked(\n    bytes memory params,\n    uint offset\n  ) internal pure returns (\n    uint256 amount,\n    uint256 nonce,\n    uint256 sigDeadline,\n    bytes memory signature,\n    uint newOffset\n  ) {\n    (amount,      offset) = params.asUint256MemUnchecked(offset);\n    (nonce,       offset) = params.asUint256MemUnchecked(offset);\n    (sigDeadline, offset) = params.asUint256MemUnchecked(offset);\n    (signature,   offset) = params.sliceMemUnchecked(offset, SIGNATURE_SIZE);\n    newOffset = offset;\n  }\n\n  function decodePermit2TransferMemStructUnchecked(\n    bytes memory params,\n    uint offset\n  ) internal pure returns (Permit2Transfer memory transfer, uint newOffset) {\n    ( transfer.amount,\n      transfer.nonce,\n      transfer.sigDeadline,\n      transfer.signature,\n      newOffset\n    ) = decodePermit2TransferMemUnchecked(params, offset);\n  }\n\n  // ------------ Encoding ------------\n\n  function encodePermit(\n    uint256 value,\n    uint256 deadline,\n    bytes32 r,\n    bytes32 s,\n    uint8   v\n  ) internal pure returns (bytes memory) {\n    return abi.encodePacked(value, deadline, r, s, v);\n  }\n\n  function encode(Permit memory permit) internal pure returns (bytes memory) {\n    return encodePermit(permit.value, permit.deadline, permit.r, permit.s, permit.v);\n  }\n\n  function encodePermit2Permit(\n    uint160 amount,\n    uint48  expiration,\n    uint48  nonce,\n    uint256 sigDeadline,\n    bytes memory signature\n  ) internal pure returns (bytes memory) {\n    if (signature.length != SIGNATURE_SIZE)\n      revert InvalidSignatureLength(signature.length);\n\n    return abi.encodePacked(amount, expiration, nonce, sigDeadline, signature);\n  }\n\n  function encode(Permit2Permit memory permit) internal pure returns (bytes memory) {\n    return encodePermit2Permit(\n      permit.amount,\n      permit.expiration,\n      permit.nonce,\n      permit.sigDeadline,\n      permit.signature\n    );\n  }\n\n  function encodePermit2Transfer(\n    uint256 amount,\n    uint256 nonce,\n    uint256 sigDeadline,\n    bytes memory signature\n  ) internal pure returns (bytes memory) {\n    if (signature.length != SIGNATURE_SIZE)\n      revert InvalidSignatureLength(signature.length);\n\n    return abi.encodePacked(amount, nonce, sigDeadline, signature);\n  }\n\n  function encode(Permit2Transfer memory transfer) internal pure returns (bytes memory) {\n    return encodePermit2Transfer(\n      transfer.amount,\n      transfer.nonce,\n      transfer.sigDeadline,\n      transfer.signature\n    );\n  }\n}\n\nusing PermitParsing for Permit global;\nusing PermitParsing for Permit2Permit global;\nusing PermitParsing for Permit2Transfer global;\n"}, "lib/wormhole-solidity-sdk/src/RawDispatcher.sol": {"content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.30;\n\n//TL;DR:\n//  Allows implementing custom call dispatching logic that is more efficient both in terms\n//    of gas (only when using the via-IR pipeline!) and calldata size than Solidity's default\n//    encoding and dispatching.\n//\n//  The numbers in the function names of this contract are meaningless and only serve the\n//    purpose of yielding a low selector that will guarantee that these functions will come\n//    first in Solidity's default function sorting _when using the via-IR pipeline_.\n//\n//See docs/RawDispatcher.md for details.\nabstract contract RawDispatcher {\n\n  //selector: 00000eb6\n  function exec768() external payable returns (bytes memory) {\n    return _exec(msg.data[4:]);\n  }\n\n  //selector: 0008a112\n  function get1959() external view returns (bytes memory) {\n    return _get(msg.data[4:]);\n  }\n\n  function _exec(bytes calldata data) internal virtual returns (bytes memory);\n\n  function _get(bytes calldata data) internal view virtual returns (bytes memory);\n}\n"}, "lib/wormhole-solidity-sdk/src/Utils.sol": {"content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.30;\n\nimport {\n  tokenOrNativeTransfer\n} from \"wormhole-sdk/utils/Transfer.sol\";\nimport {\n  reRevert\n} from \"wormhole-sdk/utils/Revert.sol\";\nimport {\n  NotAnEvmAddress,\n  toUniversalAddress,\n  fromUniversalAddress\n} from \"wormhole-sdk/utils/UniversalAddress.sol\";\nimport {\n  keccak256Word,\n  keccak256SliceUnchecked,\n  keccak256Cd\n} from \"wormhole-sdk/utils/Keccak.sol\";\nimport {\n  eagerAnd,\n  eagerOr\n} from \"wormhole-sdk/utils/EagerOps.sol\";\nimport {\n  normalizeAmount,\n  deNormalizeAmount\n} from \"wormhole-sdk/utils/DecimalNormalization.sol\";\n"}, "src/assets/CctpRBase.sol": {"content": "// Copyright (c) 2025 Stable Technologies Inc\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at https://mozilla.org/MPL/2.0/.\n\npragma solidity ^0.8.30;\n\nimport {\n  CHAIN_ID_ETHEREUM,\n  CHAIN_ID_AVALANCHE,\n  CHAIN_ID_OPTIMISM,\n  CHAIN_ID_ARBITRUM,\n  CHAIN_ID_NOBLE,\n  CHAIN_ID_SOLANA,\n  CHAIN_ID_BASE,\n  CHAIN_ID_POLYGON,\n  CHAIN_ID_SUI,\n  CHAIN_ID_APTOS,\n  CHAIN_ID_UNICHAIN,\n  CHAIN_ID_LINEA,\n  CHAIN_ID_SEPOLIA,\n  CHAIN_ID_OPTIMISM_SEPOLIA,\n  CHAIN_ID_ARBITRUM_SEPOLIA,\n  CHAIN_ID_BASE_SEPOLIA,\n  CHAIN_ID_POLYGON_SEPOLIA\n} from \"wormhole-sdk/constants/Chains.sol\";\nimport {eagerOr} from \"wormhole-sdk/Utils.sol\";\nimport {BytesParsing}  from \"wormhole-sdk/libraries/BytesParsing.sol\";\n\nuint constant ADJUSTMENTS_PER_SLOT = 10;\nuint constant CHAIN_IDS_PER_SLOT = 12;\n\n//use uint256 as array of chain ids i.e. uint16s\n//naming is slightly inaccurate because NOBLE is skipped and Aptos is not supported\nuint256 constant MAINNET_CCTP_DOMAIN_TO_CHAIN_ID = ((((((((((((((((((((((\n  uint(CHAIN_ID_LINEA    )) << 16) +\n  uint(CHAIN_ID_UNICHAIN )) << 16) +\n  uint(CHAIN_ID_APTOS    )) << 16) +\n  uint(CHAIN_ID_SUI      )) << 16) +\n  uint(CHAIN_ID_POLYGON  )) << 16) +\n  uint(CHAIN_ID_BASE     )) << 16) +\n  uint(CHAIN_ID_SOLANA   )) << 16) +\n  uint(CHAIN_ID_NOBLE    )) << 16) +\n  uint(CHAIN_ID_ARBITRUM )) << 16) +\n  uint(CHAIN_ID_OPTIMISM )) << 16) +\n  uint(CHAIN_ID_AVALANCHE)) << 16) +\n  uint(CHAIN_ID_ETHEREUM );\n\nuint256 constant TESTNET_CCTP_DOMAIN_TO_CHAIN_ID = ((((((((((((((((((((((\n  uint(CHAIN_ID_LINEA            )) << 16) +\n  uint(CHAIN_ID_UNICHAIN         )) << 16) +\n  uint(CHAIN_ID_APTOS            )) << 16) +\n  uint(CHAIN_ID_SUI              )) << 16) +\n  uint(CHAIN_ID_POLYGON_SEPOLIA  )) << 16) +\n  uint(CHAIN_ID_BASE_SEPOLIA     )) << 16) +\n  uint(CHAIN_ID_SOLANA           )) << 16) +\n  uint(CHAIN_ID_NOBLE            )) << 16) +\n  uint(CHAIN_ID_ARBITRUM_SEPOLIA )) << 16) +\n  uint(CHAIN_ID_OPTIMISM_SEPOLIA )) << 16) +\n  uint(CHAIN_ID_AVALANCHE        )) << 16) +\n  uint(CHAIN_ID_SEPOLIA          );\n\nfunction domainToChainId(uint domain, uint cctpDomainToChainId) pure returns (uint16) { unchecked {\n  return uint16(cctpDomainToChainId >> (domain * 16));\n}}\n\nfunction getAdjustmentFromMapping(\n  mapping (uint => uint256) storage domainMap,\n  uint domain\n) view returns (uint256, uint) { unchecked {\n  uint mappingIndex = domain / ADJUSTMENTS_PER_SLOT;\n  return (domainMap[mappingIndex], domain % ADJUSTMENTS_PER_SLOT);\n}}\n\nenum Route {\n  V1,\n  V2Direct,\n  AvaxHop\n}\n\nabstract contract CctpRBase {\n  using BytesParsing for bytes;\n\n  int  private  constant FEE_ADJUSTMENT_TO_MICRO_USD = 1e4;\n  uint internal constant FEE_ADJUSTMENT_RELATIVE_DENOMINATOR = 1e2;\n\n  uint256 internal immutable _cctpDomainToChainId;\n\n  // struct FeeAdjustment {\n  //   int16 absoluteUsd; // 2 decimals - positive for base fee, negative for discount\n  //   uint8 relativePercent; // 100 = 100% = at cost (no risk adjustment, no discount)\n  // }\n  // absoluteUsd is applied _after_ relativePercent, this allows for charging a flat fee\n  // gas dropoff is always unaffacted by fee adjustments\n\n  // FeeAdjustment structs are packed in groups of 10 per slot\n  // Since we have 3 bytes per domain, only 10 of them fit in a 32 byte slot\n  // i.e. the discounts of Ethereum are stored in the 3 least significant bytes of the 0th slot\n\n  // Each slot is mapped by the domain id divided by 10\n  // We are using mappings since they are more gas efficient than arrays\n  mapping (uint => uint256) internal _extraCctpDomainToChainId;\n  mapping (uint => uint256) internal _v1Adjustments;\n  mapping (uint => uint256) internal _v2DirectAdjustments;\n  mapping (uint => uint256) internal _avaxHopAdjustments;\n  mapping (uint => uint256) internal _gasDropoffAdjustments;\n\n  address internal _feeRecipient;\n  address internal _offChainQuoter;\n\n  constructor(\n    bool isMainnet,\n    address feeRecipient,\n    address offChainQuoter,\n    bytes memory chainData\n  ) {\n    _cctpDomainToChainId = isMainnet\n      ? MAINNET_CCTP_DOMAIN_TO_CHAIN_ID\n      : TESTNET_CCTP_DOMAIN_TO_CHAIN_ID;\n    _setFeeRecipient(feeRecipient);\n    _offChainQuoter = offChainQuoter;\n    uint offset = 0;\n    uint8 chainSlots;\n    (chainSlots, offset) = chainData.asUint8MemUnchecked(offset);\n    for (uint i = 1; i <= chainSlots; i++) {\n      (_extraCctpDomainToChainId[i], offset) = chainData.asUint256MemUnchecked(offset);\n    }\n    uint8 adjustmentSlots;\n    (adjustmentSlots, offset) = chainData.asUint8MemUnchecked(offset);\n    for (uint i = 0; i < adjustmentSlots; i++) {\n      (        _v1Adjustments[i], offset) = chainData.asUint256MemUnchecked(offset);\n      (  _v2DirectAdjustments[i], offset) = chainData.asUint256MemUnchecked(offset);\n      (   _avaxHopAdjustments[i], offset) = chainData.asUint256MemUnchecked(offset);\n      (_gasDropoffAdjustments[i], offset) = chainData.asUint256MemUnchecked(offset);\n    }\n    require(offset == chainData.length, \"Invalid chain data length\");\n  }\n\n  function _setFeeRecipient(address newFeeRecipient) internal {\n    require(newFeeRecipient != address(0), \"Invalid fee recipient\");\n    _feeRecipient = newFeeRecipient;\n  }\n\n  function _setChainIdForDomain(\n    uint domain,\n    uint16 chainId\n  ) internal { unchecked {\n    if (domain < CHAIN_IDS_PER_SLOT)\n      revert(\"Chain ID was added at deployment\");\n    (uint mappingIndex, uint subIndex) = _getChainIndexesForDomain(domain);\n    uint chainIds = _extraCctpDomainToChainId[mappingIndex];\n    uint shift = subIndex * 16;\n    uint mask = uint(type(uint16).max) << shift;\n    uint newChainIds = (chainIds & ~mask) | (uint256(chainId) << shift);\n    _extraCctpDomainToChainId[mappingIndex] = newChainIds;\n  }}\n\n  function _getTargetChainIdAndExecutionAdjustment(\n    uint8 destDomain,\n    Route route\n  ) internal view returns (\n    uint16 targetChainId,\n    int    adjustmentAbsoluteUsdc,\n    uint   adjustmentRelativePercent\n  ) {\n    if (destDomain < CHAIN_IDS_PER_SLOT) {\n      targetChainId = domainToChainId(destDomain, _cctpDomainToChainId);\n    }\n    else {\n      (uint mappingIndex, uint subIndex) = _getChainIndexesForDomain(destDomain);\n      targetChainId = domainToChainId(subIndex, _extraCctpDomainToChainId[mappingIndex]);\n    }\n    (uint feeAdjustments, uint extractIndex) = getAdjustmentFromMapping(\n      route == Route.V1 ? _v1Adjustments :\n      route == Route.V2Direct ? _v2DirectAdjustments :\n      _avaxHopAdjustments,\n      destDomain\n    );\n    (adjustmentAbsoluteUsdc, adjustmentRelativePercent) =\n      _extractFeeAdjustment(feeAdjustments, extractIndex);\n  }\n\n  function _getGasDropoffAdjustment(uint8 destDomain) internal view returns (\n    int  gasDropoffAbsoluteUsdc,\n    uint gasDropoffRelativePercent\n  ) {\n    (uint adjustments, uint index) = getAdjustmentFromMapping(_gasDropoffAdjustments, destDomain);\n    return _extractFeeAdjustment(adjustments, index);\n  }\n\n  function _getChainIndexesForDomain(\n    uint domain\n  ) internal pure returns (uint mappingIndex, uint subIndex) { unchecked {\n    return (domain / CHAIN_IDS_PER_SLOT, domain % CHAIN_IDS_PER_SLOT);\n  }}\n\n  function _extractFeeAdjustment(uint256 feeAdjustments, uint indexDomain) internal pure returns (\n    int  adjustmentAbsoluteUsdc,\n    uint adjustmentRelativePercent\n  ) { unchecked {\n    uint adjustment = feeAdjustments >> (indexDomain * 24);\n    adjustmentAbsoluteUsdc = int(int16(uint16(adjustment >> 8))) * FEE_ADJUSTMENT_TO_MICRO_USD;\n    adjustmentRelativePercent = uint8(adjustment);\n  }}\n}\n"}, "src/assets/CctpROwner.sol": {"content": "// Copyright (c) 2025 Stable Technologies Inc\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at https://mozilla.org/MPL/2.0/.\n\npragma solidity ^0.8.30;\n\nimport {BytesParsing} from \"wormhole-sdk/libraries/BytesParsing.sol\";\n\nimport {CctpRBase, Route} from \"cctpr/assets/CctpRBase.sol\";\nimport {eagerOr, tokenOrNativeTransfer} from \"wormhole-sdk/Utils.sol\";\n\nuint8 constant MAX_ROUTE_VARIANT_PLUS_ONE = uint8(Route.AvaxHop) + 1;\n\nabstract contract CctpROwner is CctpRBase {\n  using BytesParsing for bytes;\n\n  address internal _owner;\n  address internal _pendingOwner;\n  address internal _feeAdjuster;\n\n  constructor(address owner, address feeAdjuster) {\n    _owner = owner;\n    _feeAdjuster = feeAdjuster;\n  }\n\n  function _proposeOwnershipTransfer(address newOwner) internal {\n    _checkOwner();\n    _pendingOwner = newOwner;\n  }\n\n  function _acceptOwnership() internal {\n    _owner = _pendingOwner;\n    _checkOwner();\n    _pendingOwner = address(0);\n  }\n\n  function _cancelOwnershipTransfer() internal {\n    _checkOwner();\n    _pendingOwner = address(0);\n  }\n\n  function _updateFeeRecipient(address newFeeRecipient) internal {\n    _checkOwner();\n    _setFeeRecipient(newFeeRecipient);\n  }\n\n  function _updateFeeAdjuster(address newFeeAdjuster) internal {\n    _checkOwner();\n    _feeAdjuster = newFeeAdjuster;\n  }\n\n  function _updateOffchainQuoter(address newOffchainQuoter) internal {\n    _checkOwner();\n    _offChainQuoter = newOffchainQuoter;\n  }\n\n  function _updateFeeAdjustments(uint feeType, uint mappingIndex, uint256 newFeeAdjustments) internal {\n    require(eagerOr(msg.sender == _feeAdjuster, msg.sender == _owner), \"Not authorized\");\n    if (feeType == uint8(Route.V1))\n      _v1Adjustments[mappingIndex] = newFeeAdjustments;\n    else if (feeType == uint8(Route.V2Direct))\n      _v2DirectAdjustments[mappingIndex] = newFeeAdjustments;\n    else if (feeType == uint8(Route.AvaxHop))\n      _avaxHopAdjustments[mappingIndex] = newFeeAdjustments;\n    else if (feeType == MAX_ROUTE_VARIANT_PLUS_ONE)\n      _gasDropoffAdjustments[mappingIndex] = newFeeAdjustments;\n    else\n      revert(\"Invalid fee type\");\n  }\n\n  function _updateChainIdForDomain(\n    uint domain,\n    uint16 chainId\n  ) internal {\n    _checkOwner();\n    _setChainIdForDomain(domain, chainId);\n  }\n\n  function _sweepTokens(\n    address token,\n    uint256 amount\n  ) internal {\n    _checkOwner();\n    tokenOrNativeTransfer(token, msg.sender, amount);\n  }\n\n  function _checkOwner() private view {\n    require(msg.sender == _owner, \"Not authorized\");\n  }\n}\n"}, "src/assets/CctpRUser.sol": {"content": "// Copyright (c) 2025 Stable Technologies Inc\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at https://mozilla.org/MPL/2.0/.\n\npragma solidity ^0.8.30;\n\nimport {IPermit2}           from \"permit2/interfaces/IPermit2.sol\";\nimport {ISignatureTransfer} from \"permit2/interfaces/ISignatureTransfer.sol\";\n\nimport {CCTP_DOMAIN_AVALANCHE} from \"wormhole-sdk/constants/CctpDomains.sol\";\nimport {ITokenMessenger}       from \"wormhole-sdk/interfaces/cctp/ITokenMessenger.sol\";\nimport {IERC20Permit}          from \"wormhole-sdk/interfaces/token/IERC20Permit.sol\";\nimport {SafeERC20}             from \"wormhole-sdk/libraries/SafeERC20.sol\";\nimport {toUniversalAddress}    from \"wormhole-sdk/Utils.sol\";\n\nimport {ITokenMessengerV2} from \"cctpr/interfaces/ITokenMessengerV2.sol\";\nimport {Route}             from \"cctpr/assets/CctpRBase.sol\";\nimport {CctpRQuote}        from \"cctpr/assets/CctpRQuote.sol\";\n\n//see https://github.com/circlefin/evm-cctp-contracts/blob/63ab1f0ac06ce0793c0bbfbb8d09816bc211386d/src/v2/FinalityThresholds.sol#L27\nuint32 constant TOKEN_MESSENGER_V2_MIN_FINALITY_THRESHOLD = 500;\n\nstring constant WITNESS_TYPE_STRING =\n  \"TransferWithRelayWitness parameters)\"\n  \"TokenPermissions(address token,uint256 amount)\"\n  \"TransferWithRelayWitness(\"\n    \"uint64 baseAmount,\"\n    \"uint8 destinationDomain,\"\n    \"bytes32 mintRecipient,\"\n    \"uint32 microGasDropoff,\"\n    \"string corridor,\" //\"CCTPv1\", \"CCTPv2\", or \"CCTPv2->Avalanche->CCTPv1\"\n    \"uint64 maxFastFee,\" //must be 0 for v1 corridor\n    \"uint64 gaslessFee,\"\n    \"uint64 maxRelayFee,\" //for off-chain quotes, this is the exact relay fee\n    \"string quoteSource\" //\"OffChain\" or \"OnChain\"\n  \")\";\n\n//keccak256(\"TransferWithRelayWitness(uint64 baseAmount, ..., string quoteSource)\")\nbytes32 constant TRANSFER_WITH_RELAY_WITNESS_TYPE_HASH =\n  0xd8d8f589690ec7b04cede9a901610a0b0ff2cfec22ba31db6b1dafafe14784b7;\n\n//keccak256(\"CCTPv1\")\nbytes32 constant CORRIDOR_CCTPV1_HASH =\n  0xf1533fb304796ed47c5a84ee7aa17d7d2758d8e35e01eca21b7bc862ed739c56;\n//keccak256(\"CCTPv2\")\nbytes32 constant CORRIDOR_CCTPV2_HASH =\n  0xc64e7cd858aaed1e95e01a9ce10518ae3bee81bb20fdb394c41cebb3b92b5c11;\n//keccak256(\"CCTPv2->Avalanche->CCTPv1\")\nbytes32 constant CORRIDOR_CCTPV2_TO_AVALANCHE_TO_CCTPV1_HASH =\n  0xa51cd44d941d29943efd82dc41f83b1e1ec039f17d9c38f6b34845338eb287ff;\n\n//keccak256(\"OnChain\")\nbytes32 constant QUOTE_SOURCE_ONCHAIN_HASH =\n  0x04efdc127211e85550104881d990ac0ad8cab62a718ef27996783a3eefba1984;\n//keccak256(\"OffChain\")\nbytes32 constant QUOTE_SOURCE_OFFCHAIN_HASH =\n  0x05d3f7a2772bed1f9df7112906d61ae47d491128761de849c14fcd68aa8eee30;\n\nstruct Permit2Data {\n  address owner;\n  uint256 amount;\n  uint256 nonce;\n  uint32  deadline;\n  bytes   signature;\n}\n\nabstract contract CctpRUser is CctpRQuote {\n  //for v2 transfers, the cctpNonce is always 0\n  //gasDropoffMicroGasToken always corresponds to the next leg of the trip, meaning that for\n  //  v1 and v2Dirct transfers, it will straight-forwardly contain the amount that the user\n  //  requested, but for the avax hop, it will be 0 (because the first leg of the trip does not\n  //  have a gas dropoff), while the true value is stored in the cctp v2 hookdata and is emitted\n  //  by the avax router contract in its event that triggers the second leg of the trip (which\n  //  actually has to deliver the gas dropoff)\n  event RelayRequest(uint64 cctpNonce, uint32 gasDropoffMicroGasToken);\n  //allows tracking of charged relay fees from events and calldata:\n  //when quoting off-chain, the relay fee can be deduced from the quote calldata\n  //when quoting on-chain in usdc, there's the associated ERC20 transfer event to the fee recipient\n  //when quoting on-chain in gas token, we use the RelayFeeGasTokenPayment event for tracking\n  event RelayFeeGasTokenPayment(uint256 amount);\n\n  IERC20Permit      private immutable _usdc;\n  ITokenMessenger   private immutable _tokenMessengerV1;\n  ITokenMessengerV2 private immutable _tokenMessengerV2;\n  bytes32           private immutable _avaxRouter;\n  IPermit2          private immutable _permit2;\n  uint8             private immutable _sourceDomain;\n\n  constructor(\n    address usdc,\n    address tokenMessengerV1,\n    address tokenMessengerV2,\n    address avaxRouter,\n    address permit2\n  ) {\n    _usdc             = IERC20Permit(usdc);\n    _tokenMessengerV1 = ITokenMessenger(tokenMessengerV1);\n    _tokenMessengerV2 = ITokenMessengerV2(tokenMessengerV2);\n    _avaxRouter       = toUniversalAddress(avaxRouter);\n    _permit2          = IPermit2(permit2);\n\n    if (tokenMessengerV1 != address(0)) {\n      _sourceDomain = uint8(_tokenMessengerV1.localMessageTransmitter().localDomain());\n      _usdc.approve(tokenMessengerV1, type(uint256).max);\n    }\n    if (tokenMessengerV2 != address(0)) {\n      if (tokenMessengerV1 == address(0))\n        _sourceDomain = uint8(_tokenMessengerV2.localMessageTransmitter().localDomain());\n      _usdc.approve(tokenMessengerV2, type(uint256).max);\n    }\n  }\n\n  function _redeemUserPermit(\n    uint256 value,\n    uint256 deadline,\n    bytes32 r,\n    bytes32 s,\n    uint8 v\n  ) internal {\n    //allow failure to prevent front-running griefing attacks\n    //  (i.e. getting permit from mempool and submitting it to the inputToken contract directly)\n    try\n      _usdc.permit(msg.sender, address(this), value, deadline, v, r, s) {}\n    catch {}\n  }\n\n  function _redeemPermit2WithWitness(\n    uint requiredAmount,\n    Permit2Data memory permit2Data,\n    uint baseAmount,\n    uint8 destinationDomain,\n    bytes32 mintRecipient,\n    uint32 microGasDropoff,\n    Route corridor,\n    uint maxFastFee,\n    uint gaslessFee,\n    uint maxRelayFee,\n    bool isOnChainQuote\n  ) internal { unchecked {\n    bytes32 witness = keccak256(abi.encode(\n      TRANSFER_WITH_RELAY_WITNESS_TYPE_HASH,\n      baseAmount,\n      destinationDomain,\n      mintRecipient,\n      microGasDropoff,\n      corridor == Route.V1\n        ? CORRIDOR_CCTPV1_HASH\n        : corridor == Route.V2Direct\n        ? CORRIDOR_CCTPV2_HASH\n        : CORRIDOR_CCTPV2_TO_AVALANCHE_TO_CCTPV1_HASH,\n      maxFastFee,\n      gaslessFee,\n      maxRelayFee,\n      isOnChainQuote ? QUOTE_SOURCE_ONCHAIN_HASH : QUOTE_SOURCE_OFFCHAIN_HASH\n    ));\n\n    _permit2.permitWitnessTransferFrom(\n      ISignatureTransfer.PermitTransferFrom(\n        ISignatureTransfer.TokenPermissions(address(_usdc), permit2Data.amount),\n        permit2Data.nonce,\n        permit2Data.deadline\n      ),\n      ISignatureTransfer.SignatureTransferDetails(address(this), requiredAmount),\n      permit2Data.owner,\n      witness,\n      WITNESS_TYPE_STRING,\n      permit2Data.signature\n    );\n  }}\n\n  function _verifyOffChainQuote(\n    uint8 destinationDomain,\n    Route route,\n    uint32 gasDropoffMicroGasToken,\n    uint32 expirationTime,\n    bool chargeInUsdc,\n    uint64 rawRelayFee,\n    bytes32 r,\n    bytes32 s,\n    uint8 v\n  ) internal view {\n    require(expirationTime > block.timestamp, \"quote expired\");\n    address offChainQuoter = _offChainQuoter;\n    require(offChainQuoter != address(0), \"offChain quoting disabled\");\n\n    bytes32 hash = keccak256(abi.encodePacked(\n      _sourceDomain,\n      destinationDomain,\n      route,\n      gasDropoffMicroGasToken,\n      expirationTime,\n      chargeInUsdc,\n      rawRelayFee\n    ));\n\n    require(ecrecover(hash, v, r, s) == offChainQuoter, \"invalid quote signature\");\n  }\n\n  function _requestRelay(\n    uint transferUsdc,\n    uint8 destinationDomain,\n    bytes32 mintRecipient,\n    uint32 gasDropoffMicroGasToken,\n    Route route,\n    uint maxFastFeeUsdc //only relevant for v2 transfers, 0 for v1\n  ) internal {\n    if (route == Route.V1) {\n      uint64 cctpNonce = _tokenMessengerV1.depositForBurn(\n        transferUsdc,\n        destinationDomain,\n        mintRecipient,\n        address(_usdc)\n      );\n\n      emit RelayRequest(cctpNonce, gasDropoffMicroGasToken);\n    }\n    else if (route == Route.V2Direct) {\n      _tokenMessengerV2.depositForBurn(\n        transferUsdc,\n        destinationDomain,\n        mintRecipient,\n        address(_usdc),\n        bytes32(0), //destinationCaller -> anyone can redeem\n        maxFastFeeUsdc,\n        TOKEN_MESSENGER_V2_MIN_FINALITY_THRESHOLD\n      );\n\n      emit RelayRequest(0, gasDropoffMicroGasToken);\n    }\n    else { //route must equal Route.AvaxHop\n      _tokenMessengerV2.depositForBurnWithHook(\n        transferUsdc,\n        CCTP_DOMAIN_AVALANCHE,\n        _avaxRouter, //mint recipient\n        address(_usdc),\n        _avaxRouter, //destinationCaller\n        maxFastFeeUsdc,\n        TOKEN_MESSENGER_V2_MIN_FINALITY_THRESHOLD,\n        abi.encodePacked(destinationDomain, mintRecipient, gasDropoffMicroGasToken)\n      );\n\n      emit RelayRequest(0, 0);\n    }\n  }\n\n  function _acquireUsdcFromSender(uint amount) internal {\n    SafeERC20.safeTransferFrom(_usdc, msg.sender, address(this), amount);\n  }\n\n  function _transferThisUsdcRelayFee(uint relayFeeUsdc) internal {\n    if (relayFeeUsdc > 0)\n      SafeERC20.safeTransfer(_usdc, _feeRecipient, relayFeeUsdc);\n  }\n\n  function _transferSenderUsdcRelayFee(uint relayFeeUsdc) internal {\n    if (relayFeeUsdc > 0)\n      SafeERC20.safeTransferFrom(_usdc, msg.sender, _feeRecipient, relayFeeUsdc);\n  }\n\n  function _transferGasToken(address to, uint value) internal {\n    if (value > 0) {\n      (bool success, ) = to.call{value: value}(new bytes(0));\n      require(success, \"gas token transfer failed\");\n    }\n  }\n}\n"}, "src/assets/CctpRQuote.sol": {"content": "// Copyright (c) 2025 Stable Technologies Inc\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at https://mozilla.org/MPL/2.0/.\n\npragma solidity ^0.8.30;\n\nimport {WORD_SIZE} from \"wormhole-sdk/constants/Common.sol\";\nimport {BytesParsing} from \"wormhole-sdk/libraries/BytesParsing.sol\";\nimport {\n  CHAIN_ID_SOLANA,\n  CHAIN_ID_SUI,\n  CHAIN_ID_APTOS,\n  CHAIN_ID_NOBLE,\n  CHAIN_ID_AVALANCHE\n} from \"wormhole-sdk/constants/Chains.sol\";\nimport {eagerAnd, eagerOr} from \"wormhole-sdk/Utils.sol\";\n\nimport {\n  DISPATCHER_PROTOCOL_VERSION0,\n  PRICES_QUERIES_ID,\n  QUERY_FEE_PARAMS_ID,\n  CHAIN_ID_ID\n} from \"price-oracle/assets/PriceOracleIds.sol\";\nimport \"price-oracle/assets/types/ParamLibs.sol\";\nimport \"price-oracle/assets/types/EvmFeeParams.sol\";\nimport \"price-oracle/assets/types/SolanaFeeParams.sol\";\nimport \"price-oracle/assets/types/SuiFeeParams.sol\";\nimport {CctpRBase, Route} from \"cctpr/assets/CctpRBase.sol\";\n\n//constants are declared outside so they can be used in tests\n\nuint constant EVM_GAS_DROPOFF_GAS_COST = 22_000; //estimated using avalanche testnet\n\n//see sample tx:\n//https://etherscan.io/tx/0x9020dd97e93263239d65357504fdc2813c126a755cd6304d197b70642d529e2c\n// Size of the whole serialized tx in bytes\nuint constant EVM_V1_BILLED_SIZE = 664;\nuint constant EVM_V1_GAS_COST    = 165_000; //sampled gas usage is mostly between 140k and 163k\n\n//see sample tx:\n//https://sepolia.etherscan.io/tx/0xee70b773052207050070e05b8fdf8d0687f5fa64f15153464b19daacf11153d4\n// Size of the whole serialized tx in bytes\nuint constant EVM_V2_BILLED_SIZE = 793;\nuint constant EVM_V2_GAS_COST    = 175_000; //sampled gas usage is between 150k and 171k\n\n//see representative transfer sample tx:\n//https://suiscan.xyz/mainnet/tx/13nTP2FKisQvGaZ4HFNLFsThgisaqmsSsPxuvUXGgQmz\n// computation fee:   750,000 MIST / 750 MIST/gas unit => 1000 gas units\n// storage fee:     1,976,000 MIST / 7600 MIST/byte => 260 bytes\n// storage rebate:  1,956,240 MIST / 0.99 = 1,976,000 MIST / 7600 MIST/byte => 260 bytes\n// storage diff:       19,760 MIST / 7600 MIST/byte => 2.6 bytes final billing\nuint constant SUI_GAS_DROPOFF_COMPUTE_BUDGET = 1000;\nuint constant SUI_GAS_DROPOFF_STORAGE_BYTES  = 260;\nuint constant SUI_GAS_DROPOFF_STORAGE_REBATE = 260;\n\n//see representative sample tx:\n//https://suiscan.xyz/mainnet/tx/8UWX76vcVPmcDrVsb2q62q9pNG5cGWF2heCe3XAEYCNw\n// computation fee:  1,500,000 MIST / 750 MIST/gas unit => 2000 gas units\n// storage fee:     17,958,800 MIST / 7600 MIST/byte => 2363 bytes\n// storage rebate:  14,889,996 MIST / 0.99 = 15,040,400 MIST / 7600 MIST/byte => 1979 bytes\n// storage diff:     3,068,804 MIST / 7600 MIST/byte => 403.79 bytes\n// so while only 384 bytes are ultimately stored, the final billing is closer to 404 bytes\nuint constant SUI_COMPUTE_BUDGET = 2000;\nuint constant SUI_STORAGE_BYTES  = 2363;\nuint constant SUI_STORAGE_REBATE = 1979;\n\n//Solana gas dropoff cost is entirely negligible (costs 300 CUs)\n//Solana v1 and v2 have essentially the same compute budget requirements\nuint constant SOLANA_COMPUTE_BUDGET    = 200_000; //sampled consumption is 180k+\nuint constant SOLANA_ATA_STORAGE_BYTES = 128 + 165; //size of an ATA (account overhead + data)\n//CCTP v1 uses a bitmap account for replay protection:\n//see here: https://github.com/circlefin/solana-cctp-contracts/blob/9f8cf26d059cf8927ae0a0b351f3a7a88c7bdade/programs/message-transmitter/src/state.rs#L51-L58\n//The account size in total is 128 + 4 + 8 + 8*100 = 940 bytes for 6400 nonces.\n//So the rent cost per nonce comes out or ~0.15 bytes (~= 1k lamports) per nonce i.e. negligible.\nuint constant SOLANA_V1_STORAGE_BYTES = SOLANA_ATA_STORAGE_BYTES;\n//CCTP v2 on the other hand uses individual nonce PDAs and for god knows what reason, they even\n//  pointlessly store a bool in it - see here:\n//    https://github.com/circlefin/solana-cctp-contracts/blob/9f8cf26d059cf8927ae0a0b351f3a7a88c7bdade/programs/v2/message-transmitter-v2/src/state.rs#L50-L52\n//  and here:\n//    https://github.com/circlefin/solana-cctp-contracts/blob/9f8cf26d059cf8927ae0a0b351f3a7a88c7bdade/programs/v2/message-transmitter-v2/src/instructions/receive_message.rs#L59-L70\nuint constant SOLANA_V2_STORAGE_BYTES = 128 + 8 + 1 + SOLANA_ATA_STORAGE_BYTES;\nuint constant SOLANA_SIGNATURE_COUNT = 1;\n\n//fork testing suggests gas costs of ~240k but Avalanche testnet gives 281k:\n//https://testnet.snowtrace.io/address/0xE3a43C797B4f43eb0015d182e072809fA3827BF1\n//not sure where this discrepancy is coming from\nuint constant AVAX_HOP_GAS_COST = 281_200;\n\nabstract contract CctpRQuote is CctpRBase {\n  using BytesParsing for bytes;\n\n  bytes4 private constant GET1959_SELECTOR = bytes4(keccak256(\"get1959()\"));\n  uint48 private constant PRICE_ORACLE_QUERY_PREFIX = uint48((\n    uint(uint32(GET1959_SELECTOR))     << 8) +\n    uint(DISPATCHER_PROTOCOL_VERSION0) << 8) +\n    PRICES_QUERIES_ID;\n\n  address private immutable _priceOracle;\n  uint16  private immutable _chainId;\n\n  constructor(address priceOracle) {\n    _priceOracle = priceOracle;\n    (_chainId, ) = _invokeOracle(\n      abi.encodePacked(PRICE_ORACLE_QUERY_PREFIX, uint8(1), CHAIN_ID_ID)\n    ).asUint16MemUnchecked(0);\n    require(_chainId != 0, \"PriceOracle misconfigured\");\n  }\n\n  function _quoteInUsdc(\n    uint8 destinationDomain,\n    Route route,\n    uint32 gasDropOffMicroGasToken\n  ) internal view returns (uint) { unchecked {\n    (uint16 targetChainId, int execAdjustmentAbsoluteUsdc, uint execAdjustmentRelativePercent) =\n      _getTargetChainIdAndExecutionAdjustment(destinationDomain, route);\n\n    //short-circuiting to avoid unnecessary oracle call\n    if (eagerAnd(execAdjustmentRelativePercent == 0, gasDropOffMicroGasToken == 0)) {\n      require(execAdjustmentAbsoluteUsdc >= 0, \"misconfigured feeAdjustment\");\n      return uint(execAdjustmentAbsoluteUsdc);\n    }\n\n    uint hopUsd18 = 0;\n    uint256 targetFeeParams;\n    if (route == Route.AvaxHop) {\n      bytes memory feeParams = _invokeOracle(\n        abi.encodePacked(\n          PRICE_ORACLE_QUERY_PREFIX,\n          uint8(2),\n          QUERY_FEE_PARAMS_ID,\n          targetChainId,\n          QUERY_FEE_PARAMS_ID,\n          CHAIN_ID_AVALANCHE\n        )\n      );\n\n      uint offset;\n      uint256 avalancheFeeParams;\n      (targetFeeParams, offset) = feeParams.asUint256MemUnchecked(0);\n      (avalancheFeeParams,    ) = feeParams.asUint256MemUnchecked(offset);\n\n      hopUsd18 = _calcHopUsd18(avalancheFeeParams);\n    }\n    else\n      (targetFeeParams, ) = _invokeOracle(\n        abi.encodePacked(PRICE_ORACLE_QUERY_PREFIX, uint8(1), QUERY_FEE_PARAMS_ID, targetChainId)\n      ).asUint256MemUnchecked(0);\n\n    uint usd18Quote = _quoteInUsd18(\n      route,\n      hopUsd18,\n      targetChainId,\n      targetFeeParams,\n      gasDropOffMicroGasToken,\n      execAdjustmentAbsoluteUsdc,\n      execAdjustmentRelativePercent,\n      destinationDomain\n    );\n\n    return usd18Quote / 1e12;\n  }}\n\n  function _quoteInGasToken(\n    uint8 destinationDomain,\n    Route route,\n    uint32 gasDropOffMicroGasToken\n  ) internal view returns (uint) { unchecked {\n    (uint16 targetChainId, int execAdjustmentAbsoluteUsdc, uint execAdjustmentRelativePercent) =\n      _getTargetChainIdAndExecutionAdjustment(destinationDomain, route);\n\n    uint256 localChainFeeParams;\n    uint usd18Quote;\n    if (eagerAnd(execAdjustmentRelativePercent == 0, gasDropOffMicroGasToken == 0)) {\n      require(execAdjustmentAbsoluteUsdc >= 0, \"misconfigured feeAdjustment\");\n      (localChainFeeParams, ) = _invokeOracle(\n        abi.encodePacked(\n          PRICE_ORACLE_QUERY_PREFIX,\n          uint8(1),\n          QUERY_FEE_PARAMS_ID,\n          _chainId\n        )\n      ).asUint256MemUnchecked(0);\n      usd18Quote = uint(execAdjustmentAbsoluteUsdc) * 1e12;\n    }\n    else {\n      uint hopUsd18 = 0;\n      uint256 targetFeeParams;\n      if (route == Route.AvaxHop) {\n        bytes memory feeParams = _invokeOracle(\n          abi.encodePacked(\n            PRICE_ORACLE_QUERY_PREFIX,\n            uint8(3),\n            QUERY_FEE_PARAMS_ID,\n            targetChainId,\n            QUERY_FEE_PARAMS_ID,\n            _chainId,\n            QUERY_FEE_PARAMS_ID,\n            CHAIN_ID_AVALANCHE\n          )\n        );\n\n        uint offset;\n        uint256 avalancheFeeParams;\n        (targetFeeParams,     offset) = feeParams.asUint256MemUnchecked(0);\n        (localChainFeeParams, offset) = feeParams.asUint256MemUnchecked(offset);\n        (avalancheFeeParams,        ) = feeParams.asUint256MemUnchecked(offset);\n\n        hopUsd18 = _calcHopUsd18(avalancheFeeParams);\n      }\n      else {\n        bytes memory feeParams = _invokeOracle(\n          abi.encodePacked(\n            PRICE_ORACLE_QUERY_PREFIX,\n            uint8(2),\n            QUERY_FEE_PARAMS_ID,\n            targetChainId,\n            QUERY_FEE_PARAMS_ID,\n            _chainId\n          )\n        );\n\n        uint offset;\n        (targetFeeParams, offset) = feeParams.asUint256MemUnchecked(0);\n        (localChainFeeParams,   ) = feeParams.asUint256MemUnchecked(offset);\n      }\n\n      usd18Quote = _quoteInUsd18(\n        route,\n        hopUsd18,\n        targetChainId,\n        targetFeeParams,\n        gasDropOffMicroGasToken,\n        execAdjustmentAbsoluteUsdc,\n        execAdjustmentRelativePercent,\n        destinationDomain\n      );\n    }\n\n    return usd18Quote * 1e18 / EvmFeeParams.wrap(localChainFeeParams).gasTokenPrice().from();\n  }}\n\n  // -- private --\n\n  function _invokeOracle(bytes memory encodedCall) private view returns (bytes memory response) {\n    (bool success, bytes memory result) = address(_priceOracle).staticcall(encodedCall);\n    require(success, \"PriceOracle call failed\");\n\n    //manual impl of abi.decode(result, (bytes))\n    (uint length, uint offset) = result.asUint256MemUnchecked(WORD_SIZE);\n    (response, ) = result.sliceMemUnchecked(offset, length);\n  }\n\n  function _quoteInUsd18(\n    Route route,\n    uint hopUsd18,\n    uint16 targetChainId,\n    uint256 targetFeeParams,\n    uint32 gasDropOffMicroGasToken,\n    int execAdjustmentAbsoluteUsdc,\n    uint execAdjustmentRelativePercent,\n    uint8 destinationDomain\n  ) private view returns (uint) { unchecked {\n    function(uint16,uint256,bool) internal pure returns (uint,uint) func =\n      route == Route.V2Direct\n      ? _v2ExecutionCostAndGasTokenPrice\n      : _v1ExecutionCostAndGasTokenPrice;\n\n    (uint targetExecutionCost, uint targetGasTokenPrice) =\n      func(targetChainId, targetFeeParams, gasDropOffMicroGasToken != 0);\n\n    //adjust execution cost\n    uint unadjustedExecutionCostUsd18 = hopUsd18 + targetExecutionCost * targetGasTokenPrice / 1e18;\n    uint finalExecutionCostUsd18 = _applyFeeAdjustment(\n      unadjustedExecutionCostUsd18,\n      execAdjustmentAbsoluteUsdc,\n      execAdjustmentRelativePercent\n    );\n\n    uint finalGasDropoffUsd18 = 0;\n    if (gasDropOffMicroGasToken != 0) {\n      //adjust gas dropoff\n      uint unadjustedGasDropoffUsd18 =\n        GasDropoff.wrap(gasDropOffMicroGasToken).from() * targetGasTokenPrice / 1e18;\n      (int gasDropoffAbsoluteUsdc, uint gasDropoffRelativePercent) =\n        _getGasDropoffAdjustment(destinationDomain);\n      finalGasDropoffUsd18 = _applyFeeAdjustment(\n        unadjustedGasDropoffUsd18,\n        gasDropoffAbsoluteUsdc,\n        gasDropoffRelativePercent\n      );\n    }\n\n    //total quote\n    return finalExecutionCostUsd18 + finalGasDropoffUsd18;\n  }}\n\n  function _v1ExecutionCostAndGasTokenPrice(\n    uint16 targetChainId,\n    uint256 targetFeeParams,\n    bool gasDropoffRequested\n  ) private pure returns (uint targetExecutionCost, uint targetGasTokenPrice) { unchecked {\n    if (targetChainId == CHAIN_ID_SOLANA) {\n      //gas dropoff costs are negligible and hence ignored on Solana\n      SolanaFeeParams solanaFeeParams = SolanaFeeParams.wrap(targetFeeParams);\n      targetExecutionCost =\n        SOLANA_COMPUTE_BUDGET     * solanaFeeParams.computationPrice().from()\n        + SOLANA_V1_STORAGE_BYTES * solanaFeeParams.pricePerAccountByte().from()\n        + SOLANA_SIGNATURE_COUNT  * solanaFeeParams.signaturePrice().from();\n      targetGasTokenPrice = solanaFeeParams.gasTokenPrice().from();\n    }\n    else if (targetChainId == CHAIN_ID_SUI) {\n      SuiFeeParams suiFeeParams = SuiFeeParams.wrap(targetFeeParams);\n      uint computeCost   = SUI_COMPUTE_BUDGET;\n      uint storageBytes  = SUI_STORAGE_BYTES;\n      uint storageRebate = SUI_STORAGE_REBATE;\n      if (gasDropoffRequested) {\n        computeCost   += SUI_GAS_DROPOFF_COMPUTE_BUDGET;\n        storageBytes  += SUI_GAS_DROPOFF_STORAGE_BYTES;\n        storageRebate += SUI_GAS_DROPOFF_STORAGE_REBATE;\n      }\n      uint storagePrice = suiFeeParams.storagePrice().from();\n      targetExecutionCost =\n        computeCost * suiFeeParams.computationPrice().from()\n        + storageBytes * storagePrice\n        - (storageRebate * storagePrice *\n           suiFeeParams.storageRebate().from() / StorageRebateLib.MAX\n          );\n      targetGasTokenPrice = suiFeeParams.gasTokenPrice().from();\n    }\n    else if (eagerOr(targetChainId == CHAIN_ID_APTOS, targetChainId == CHAIN_ID_NOBLE))\n      revert(\"Aptos/Noble only supports flat fee and no gas dropoff\");\n    else {\n      EvmFeeParams evmFeeParams = EvmFeeParams.wrap(targetFeeParams);\n      uint gasCost = EVM_V1_GAS_COST;\n      if (gasDropoffRequested)\n        gasCost += EVM_GAS_DROPOFF_GAS_COST;\n\n      targetExecutionCost =\n        gasCost * evmFeeParams.gasPrice().from()\n        + EVM_V1_BILLED_SIZE * evmFeeParams.pricePerTxByte().from();\n      targetGasTokenPrice = evmFeeParams.gasTokenPrice().from();\n    }\n  }}\n\n  function _v2ExecutionCostAndGasTokenPrice(\n    uint16 targetChainId,\n    uint256 targetFeeParams,\n    bool gasDropoffRequested\n  ) private pure returns (uint targetExecutionCost, uint targetGasTokenPrice) { unchecked {\n    bool isNoble = targetChainId == CHAIN_ID_NOBLE;\n    bool isSui   = targetChainId == CHAIN_ID_SUI;\n    bool isAptos = targetChainId == CHAIN_ID_APTOS;\n    require(!eagerOr(eagerOr(isNoble, isSui), isAptos), \"v2Direct supports EVM and Solana\");\n\n    if (targetChainId == CHAIN_ID_SOLANA) {\n      //gas dropoff costs are negligible and hence ignored on Solana\n      SolanaFeeParams solanaFeeParams = SolanaFeeParams.wrap(targetFeeParams);\n      targetExecutionCost =\n        SOLANA_COMPUTE_BUDGET     * solanaFeeParams.computationPrice().from()\n        + SOLANA_V2_STORAGE_BYTES * solanaFeeParams.pricePerAccountByte().from()\n        + SOLANA_SIGNATURE_COUNT  * solanaFeeParams.signaturePrice().from();\n      targetGasTokenPrice = solanaFeeParams.gasTokenPrice().from();\n    }\n    else {\n      EvmFeeParams evmFeeParams = EvmFeeParams.wrap(targetFeeParams);\n      uint gasCost = EVM_V2_GAS_COST;\n      if (gasDropoffRequested)\n        gasCost += EVM_GAS_DROPOFF_GAS_COST;\n\n      targetExecutionCost =\n        gasCost * evmFeeParams.gasPrice().from()\n        + EVM_V2_BILLED_SIZE * evmFeeParams.pricePerTxByte().from();\n      targetGasTokenPrice = evmFeeParams.gasTokenPrice().from();\n    }\n  }}\n\n  function _calcHopUsd18(uint256 avalancheFeeParams) private pure returns (uint) { unchecked {\n    EvmFeeParams feeParams = EvmFeeParams.wrap(avalancheFeeParams);\n    return AVAX_HOP_GAS_COST *\n      feeParams.gasPrice().from() * feeParams.gasTokenPrice().from() / 1e18;\n  }}\n\n  function _applyFeeAdjustment(\n    uint usd18,\n    int adjustmentAbsoluteUsdc,\n    uint adjustmentRelativePercent\n  ) private pure returns (uint) { unchecked {\n    uint scaledUsd18 = usd18 * adjustmentRelativePercent / FEE_ADJUSTMENT_RELATIVE_DENOMINATOR;\n    int signedUsd18 = int(scaledUsd18) + adjustmentAbsoluteUsdc * 1e12;\n    return signedUsd18 < 0 ? 0 : uint(signedUsd18);\n  }}\n}\n"}, "src/assets/CctpRIds.sol": {"content": "// Copyright (c) 2025 Stable Technologies Inc\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at https://mozilla.org/MPL/2.0/.\n\npragma solidity ^0.8.30;\n\nuint8 constant TRANSFER_WITH_RELAY_WITH_PERMIT_ID = 0x01;\nuint8 constant TRANSFER_WITH_RELAY_ID             = 0x02;\nuint8 constant TRANSFER_WITH_RELAY_GASLESS_ID     = 0x03;\n\nuint8 constant UPDATE_FEE_ADJUSTMENTS_ID = 0x11;\n\nuint8 constant OWNER_SWEEP_TOKENS_ID               = 0x12;\nuint8 constant OWNER_UPDATE_FEE_RECIPIENT_ID       = 0x13;\nuint8 constant OWNER_UPDATE_FEE_ADJUSTER_ID        = 0x14;\nuint8 constant OWNER_UPDATE_OFFCHAIN_QUOTER_ID     = 0x15;\nuint8 constant OWNER_PROPOSE_OWNERSHIP_TRANSFER_ID = 0x16;\nuint8 constant OWNER_ACCEPT_OWNERSHIP_TRANSFER_ID  = 0x17;\nuint8 constant OWNER_CANCEL_OWNERSHIP_TRANSFER_ID  = 0x18;\nuint8 constant OWNER_SET_CHAIN_ID_FOR_DOMAIN_ID    = 0x19;\n\nuint8 constant QUERY_RELAY_IN_USDC_ID      = 0x81;\nuint8 constant QUERY_RELAY_IN_GAS_TOKEN_ID = 0x82;\n"}, "lib/wormhole-solidity-sdk/src/constants/Common.sol": {"content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.30;\n\n// \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n// \u2502 NOTE: We can't define e.g. WORD_SIZE_MINUS_ONE via WORD_SIZE - 1 because     \u2502\n// \u2502       of solc restrictions on what constants can be used in inline assembly. \u2502\n// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nuint256 constant WORD_SIZE = 32;\nuint256 constant WORD_SIZE_MINUS_ONE = 31; //=0x1f=0b00011111\n//see section \"prefer `< MAX + 1` over `<= MAX` for const comparison\" in docs/Optimization.md\nuint256 constant WORD_SIZE_PLUS_ONE = 33;\n\nuint256 constant SCRATCH_SPACE_PTR = 0x00;\nuint256 constant SCRATCH_SPACE_SIZE = 64;\n\nuint256 constant FREE_MEMORY_PTR = 0x40;"}, "lib/wormhole-solidity-sdk/src/utils/Transfer.sol": {"content": "\n// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"IERC20/IERC20.sol\";\nimport {SafeERC20} from \"SafeERC20/SafeERC20.sol\";\n\nerror PaymentFailure(address target);\n\n//Note: Always forwards all gas, so consider gas griefing attack opportunities by the recipient.\n//Note: Don't use this method if you need events for 0 amount transfers.\nfunction tokenOrNativeTransfer(address tokenOrZeroForNative, address to, uint256 amount) {\n  if (amount == 0)\n    return;\n\n  if (tokenOrZeroForNative == address(0)) {\n    (bool success, ) = to.call{value: amount}(new bytes(0));\n    if (!success)\n      revert PaymentFailure(to);\n  }\n  else\n    SafeERC20.safeTransfer(IERC20(tokenOrZeroForNative), to, amount);\n}\n"}, "lib/wormhole-solidity-sdk/src/utils/Revert.sol": {"content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.30;\n\nimport {WORD_SIZE} from \"wormhole-sdk/constants/Common.sol\";\n\n//bubble up errors from low level calls\nfunction reRevert(bytes memory err) pure {\n  assembly (\"memory-safe\") {\n    revert(add(err, WORD_SIZE), mload(err))\n  }\n}\n"}, "lib/wormhole-solidity-sdk/src/utils/UniversalAddress.sol": {"content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.30;\n\nerror NotAnEvmAddress(bytes32);\n\nfunction toUniversalAddress(address addr) pure returns (bytes32 universalAddr) {\n  universalAddr = bytes32(uint256(uint160(addr)));\n}\n\nfunction fromUniversalAddress(bytes32 universalAddr) pure returns (address addr) {\n  if (bytes12(universalAddr) != 0)\n    revert NotAnEvmAddress(universalAddr);\n\n  assembly (\"memory-safe\") {\n    addr := universalAddr\n  }\n}\n"}, "lib/wormhole-solidity-sdk/src/utils/Keccak.sol": {"content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.30;\n\nimport {WORD_SIZE, SCRATCH_SPACE_PTR, FREE_MEMORY_PTR} from \"wormhole-sdk/constants/Common.sol\";\n\nfunction keccak256Word(bytes32 word) pure returns (bytes32 hash) {\n  /// @solidity memory-safe-assembly\n  assembly {\n    mstore(SCRATCH_SPACE_PTR, word)\n    hash := keccak256(SCRATCH_SPACE_PTR, WORD_SIZE)\n  }\n}\n\nfunction keccak256SliceUnchecked(\n  bytes memory encoded,\n  uint offset,\n  uint length\n) pure returns (bytes32 hash) {\n  /// @solidity memory-safe-assembly\n  assembly {\n    // The length of the bytes type `length` field is that of a word in memory\n    let ptr := add(add(encoded, offset), WORD_SIZE)\n    hash := keccak256(ptr, length)\n  }\n}\n\nfunction keccak256Cd(\n  bytes calldata encoded\n) pure returns (bytes32 hash) {\n  /// @solidity memory-safe-assembly\n  assembly {\n    let freeMemory := mload(FREE_MEMORY_PTR)\n    calldatacopy(freeMemory, encoded.offset, encoded.length)\n    hash := keccak256(freeMemory, encoded.length)\n  }\n}\n"}, "lib/wormhole-solidity-sdk/src/utils/EagerOps.sol": {"content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.30;\n\n//see Optimization.md for rationale on avoiding short-circuiting\nfunction eagerAnd(bool lhs, bool rhs) pure returns (bool ret) {\n  /// @solidity memory-safe-assembly\n  assembly {\n    ret := and(lhs, rhs)\n  }\n}\n\n//see Optimization.md for rationale on avoiding short-circuiting\nfunction eagerOr(bool lhs, bool rhs) pure returns (bool ret) {\n  /// @solidity memory-safe-assembly\n  assembly {\n    ret := or(lhs, rhs)\n  }\n}\n"}, "lib/wormhole-solidity-sdk/src/utils/DecimalNormalization.sol": {"content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.30;\n\nuint constant TOKEN_BRIDGE_NORMALIZED_DECIMALS = 8;\n\nfunction normalizeAmount(uint amount, uint decimals) pure returns (uint) { unchecked {\n  if (decimals > TOKEN_BRIDGE_NORMALIZED_DECIMALS)\n    amount /= 10 ** (decimals - TOKEN_BRIDGE_NORMALIZED_DECIMALS);\n\n  return amount;\n}}\n\nfunction deNormalizeAmount(uint amount, uint decimals) pure returns (uint) { unchecked {\n  if (decimals > TOKEN_BRIDGE_NORMALIZED_DECIMALS)\n    amount *= 10 ** (decimals - TOKEN_BRIDGE_NORMALIZED_DECIMALS);\n\n  return amount;\n}}\n"}, "lib/wormhole-solidity-sdk/src/constants/Chains.sol": {"content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.30;\n\n// This file is auto-generated by gen/chains.ts.\n\n// In the wormhole wire format, 0 indicates that a message is for any destination chain\nuint16 constant CHAIN_ID_UNSET = 0;\nuint16 constant CHAIN_ID_SOLANA = 1;\nuint16 constant CHAIN_ID_ETHEREUM = 2;\nuint16 constant CHAIN_ID_TERRA = 3;\nuint16 constant CHAIN_ID_BSC = 4;\nuint16 constant CHAIN_ID_POLYGON = 5;\nuint16 constant CHAIN_ID_AVALANCHE = 6;\nuint16 constant CHAIN_ID_OASIS = 7;\nuint16 constant CHAIN_ID_ALGORAND = 8;\nuint16 constant CHAIN_ID_AURORA = 9;\nuint16 constant CHAIN_ID_FANTOM = 10;\nuint16 constant CHAIN_ID_KARURA = 11;\nuint16 constant CHAIN_ID_ACALA = 12;\nuint16 constant CHAIN_ID_KLAYTN = 13;\nuint16 constant CHAIN_ID_CELO = 14;\nuint16 constant CHAIN_ID_NEAR = 15;\nuint16 constant CHAIN_ID_MOONBEAM = 16;\nuint16 constant CHAIN_ID_NEON = 17;\nuint16 constant CHAIN_ID_TERRA2 = 18;\nuint16 constant CHAIN_ID_INJECTIVE = 19;\nuint16 constant CHAIN_ID_OSMOSIS = 20;\nuint16 constant CHAIN_ID_SUI = 21;\nuint16 constant CHAIN_ID_APTOS = 22;\nuint16 constant CHAIN_ID_ARBITRUM = 23;\nuint16 constant CHAIN_ID_OPTIMISM = 24;\nuint16 constant CHAIN_ID_GNOSIS = 25;\nuint16 constant CHAIN_ID_PYTHNET = 26;\nuint16 constant CHAIN_ID_XPLA = 28;\nuint16 constant CHAIN_ID_BTC = 29;\nuint16 constant CHAIN_ID_BASE = 30;\nuint16 constant CHAIN_ID_SEI = 32;\nuint16 constant CHAIN_ID_SCROLL = 34;\nuint16 constant CHAIN_ID_MANTLE = 35;\nuint16 constant CHAIN_ID_BLAST = 36;\nuint16 constant CHAIN_ID_XLAYER = 37;\nuint16 constant CHAIN_ID_LINEA = 38;\nuint16 constant CHAIN_ID_BERACHAIN = 39;\nuint16 constant CHAIN_ID_SEIEVM = 40;\nuint16 constant CHAIN_ID_SNAXCHAIN = 43;\nuint16 constant CHAIN_ID_UNICHAIN = 44;\nuint16 constant CHAIN_ID_WORLDCHAIN = 45;\nuint16 constant CHAIN_ID_INK = 46;\nuint16 constant CHAIN_ID_HYPER_E_V_M = 47;\nuint16 constant CHAIN_ID_MONAD = 48;\nuint16 constant CHAIN_ID_MEZO = 50;\nuint16 constant CHAIN_ID_SONIC = 52;\nuint16 constant CHAIN_ID_WORMCHAIN = 3104;\nuint16 constant CHAIN_ID_COSMOSHUB = 4000;\nuint16 constant CHAIN_ID_EVMOS = 4001;\nuint16 constant CHAIN_ID_KUJIRA = 4002;\nuint16 constant CHAIN_ID_NEUTRON = 4003;\nuint16 constant CHAIN_ID_CELESTIA = 4004;\nuint16 constant CHAIN_ID_STARGAZE = 4005;\nuint16 constant CHAIN_ID_SEDA = 4006;\nuint16 constant CHAIN_ID_DYMENSION = 4007;\nuint16 constant CHAIN_ID_PROVENANCE = 4008;\nuint16 constant CHAIN_ID_NOBLE = 4009;\nuint16 constant CHAIN_ID_SEPOLIA = 10002;\nuint16 constant CHAIN_ID_ARBITRUM_SEPOLIA = 10003;\nuint16 constant CHAIN_ID_BASE_SEPOLIA = 10004;\nuint16 constant CHAIN_ID_OPTIMISM_SEPOLIA = 10005;\nuint16 constant CHAIN_ID_HOLESKY = 10006;\nuint16 constant CHAIN_ID_POLYGON_SEPOLIA = 10007;\n"}, "lib/permit2/src/interfaces/IPermit2.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {ISignatureTransfer} from \"./ISignatureTransfer.sol\";\nimport {IAllowanceTransfer} from \"./IAllowanceTransfer.sol\";\n\n/// @notice Permit2 handles signature-based transfers in SignatureTransfer and allowance-based transfers in AllowanceTransfer.\n/// @dev Users must approve Permit2 before calling any of the transfer functions.\ninterface IPermit2 is ISignatureTransfer, IAllowanceTransfer {\n// IPermit2 unifies the two interfaces so users have maximal flexibility with their approval.\n}\n"}, "lib/permit2/src/interfaces/ISignatureTransfer.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IEIP712} from \"./IEIP712.sol\";\n\n/// @title SignatureTransfer\n/// @notice Handles ERC20 token transfers through signature based actions\n/// @dev Requires user's token approval on the Permit2 contract\ninterface ISignatureTransfer is IEIP712 {\n    /// @notice Thrown when the requested amount for a transfer is larger than the permissioned amount\n    /// @param maxAmount The maximum amount a spender can request to transfer\n    error InvalidAmount(uint256 maxAmount);\n\n    /// @notice Thrown when the number of tokens permissioned to a spender does not match the number of tokens being transferred\n    /// @dev If the spender does not need to transfer the number of tokens permitted, the spender can request amount 0 to be transferred\n    error LengthMismatch();\n\n    /// @notice Emits an event when the owner successfully invalidates an unordered nonce.\n    event UnorderedNonceInvalidation(address indexed owner, uint256 word, uint256 mask);\n\n    /// @notice The token and amount details for a transfer signed in the permit transfer signature\n    struct TokenPermissions {\n        // ERC20 token address\n        address token;\n        // the maximum amount that can be spent\n        uint256 amount;\n    }\n\n    /// @notice The signed permit message for a single token transfer\n    struct PermitTransferFrom {\n        TokenPermissions permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice Specifies the recipient address and amount for batched transfers.\n    /// @dev Recipients and amounts correspond to the index of the signed token permissions array.\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount.\n    struct SignatureTransferDetails {\n        // recipient address\n        address to;\n        // spender requested amount\n        uint256 requestedAmount;\n    }\n\n    /// @notice Used to reconstruct the signed permit message for multiple token transfers\n    /// @dev Do not need to pass in spender address as it is required that it is msg.sender\n    /// @dev Note that a user still signs over a spender address\n    struct PermitBatchTransferFrom {\n        // the tokens and corresponding amounts permitted for a transfer\n        TokenPermissions[] permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice A map from token owner address and a caller specified word index to a bitmap. Used to set bits in the bitmap to prevent against signature replay protection\n    /// @dev Uses unordered nonces so that permit messages do not need to be spent in a certain order\n    /// @dev The mapping is indexed first by the token owner, then by an index specified in the nonce\n    /// @dev It returns a uint256 bitmap\n    /// @dev The index, or wordPosition is capped at type(uint248).max\n    function nonceBitmap(address, uint256) external view returns (uint256);\n\n    /// @notice Transfers a token using a signed permit message\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers a token using a signed permit message\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Invalidates the bits specified in mask for the bitmap at the word position\n    /// @dev The wordPos is maxed at type(uint248).max\n    /// @param wordPos A number to index the nonceBitmap at\n    /// @param mask A bitmap masked against msg.sender's current bitmap at the word position\n    function invalidateUnorderedNonces(uint256 wordPos, uint256 mask) external;\n}\n"}, "lib/wormhole-solidity-sdk/src/constants/CctpDomains.sol": {"content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.30;\n\n// This file is auto-generated by gen/cctpDomains.ts.\n\nuint32 constant CCTP_DOMAIN_ETHEREUM = 0;\nuint32 constant CCTP_DOMAIN_AVALANCHE = 1;\nuint32 constant CCTP_DOMAIN_OPTIMISM = 2;\nuint32 constant CCTP_DOMAIN_ARBITRUM = 3;\nuint32 constant CCTP_DOMAIN_SOLANA = 5;\nuint32 constant CCTP_DOMAIN_BASE = 6;\nuint32 constant CCTP_DOMAIN_POLYGON = 7;\nuint32 constant CCTP_DOMAIN_SUI = 8;\nuint32 constant CCTP_DOMAIN_APTOS = 9;\nuint32 constant CCTP_DOMAIN_UNICHAIN = 10;\n\n// Additional Testnet mappings:\nuint32 constant CCTP_DOMAIN_SEPOLIA = 0;\nuint32 constant CCTP_DOMAIN_OPTIMISM_SEPOLIA = 2;\nuint32 constant CCTP_DOMAIN_ARBITRUM_SEPOLIA = 3;\nuint32 constant CCTP_DOMAIN_BASE_SEPOLIA = 6;\n"}, "lib/wormhole-solidity-sdk/src/interfaces/cctp/ITokenMessenger.sol": {"content": "// SPDX-License-Identifier: Apache 2\n// Copyright (c) 2022, Circle Internet Financial Limited.\n//\n// stripped version of:\n//   https://github.com/circlefin/evm-cctp-contracts/blob/master/src/MessageTransmitter.sol\n\npragma solidity ^0.8.30;\n\nimport {IOwnable2Step} from \"./shared/IOwnable2Step.sol\";\n\nimport {IMessageTransmitter} from \"./IMessageTransmitter.sol\";\nimport {ITokenMinter} from \"./ITokenMinter.sol\";\n\ninterface ITokenMessenger is IOwnable2Step {\n  event DepositForBurn(\n    uint64 indexed nonce,\n    address indexed burnToken,\n    uint256 amount,\n    address indexed depositor,\n    bytes32 mintRecipient,\n    uint32 destinationDomain,\n    bytes32 destinationTokenMessenger,\n    bytes32 destinationCaller\n  );\n\n  event MintAndWithdraw(address indexed mintRecipient, uint256 amount, address indexed mintToken);\n\n  event RemoteTokenMessengerAdded(uint32 domain, bytes32 tokenMessenger);\n  event RemoteTokenMessengerRemoved(uint32 domain, bytes32 tokenMessenger);\n\n  event LocalMinterAdded(address localMinter);\n  event LocalMinterRemoved(address localMinter);\n\n  function messageBodyVersion() external view returns (uint32);\n  function localMessageTransmitter() external view returns (IMessageTransmitter);\n  function localMinter() external view returns (ITokenMinter);\n  function remoteTokenMessengers(uint32 domain) external view returns (bytes32);\n\n  function depositForBurn(\n    uint256 amount,\n    uint32 destinationDomain,\n    bytes32 mintRecipient,\n    address burnToken\n  ) external returns (uint64 nonce);\n\n  function depositForBurnWithCaller(\n    uint256 amount,\n    uint32 destinationDomain,\n    bytes32 mintRecipient,\n    address burnToken,\n    bytes32 destinationCaller\n  ) external returns (uint64 nonce);\n\n  function replaceDepositForBurn(\n    bytes calldata originalMessage,\n    bytes calldata originalAttestation,\n    bytes32 newDestinationCaller,\n    bytes32 newMintRecipient\n  ) external;\n\n  function handleReceiveMessage(\n    uint32 remoteDomain,\n    bytes32 sender,\n    bytes calldata messageBody\n  ) external returns (bool);\n\n  function addRemoteTokenMessenger(uint32 domain, bytes32 tokenMessenger) external;\n  function removeRemoteTokenMessenger(uint32 domain) external;\n\n  function addLocalMinter(address newLocalMinter) external;\n  function removeLocalMinter() external;\n}"}, "lib/wormhole-solidity-sdk/src/interfaces/token/IERC20Permit.sol": {"content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.30;\n\nimport \"IERC20/IERC20.sol\";\n\n//https://eips.ethereum.org/EIPS/eip-2612\ninterface IERC20Permit is IERC20 {\n  function permit(\n    address owner,\n    address spender,\n    uint value,\n    uint deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n  function nonces(address owner) external view returns (uint);\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"}, "lib/wormhole-solidity-sdk/src/libraries/SafeERC20.sol": {"content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"IERC20/IERC20.sol\";\nimport {WORD_SIZE, SCRATCH_SPACE_PTR} from \"wormhole-sdk/constants/Common.sol\";\n\n//Like OpenZeppelin's SafeERC20.sol, but slimmed down and more gas efficient.\n//\n//The main difference to OZ's implementation (besides the missing functions) is that we skip the\n//  EXTCODESIZE check that OZ does upon successful calls to ensure that an actual contract was\n//  called. The rationale for omitting this check is that ultimately the contract using the token\n//  has to verify that it \"makes sense\" for its use case regardless. Otherwise, a random token, or\n//  even just a contract that always returns true, could be passed, which makes this check\n//  superfluous in the final analysis.\n//\n//We also save on code size by not duplicating the assembly code in two separate functions.\n//  Otoh, we simply swallow revert reasons of failing token operations instead of bubbling them up.\n//  This is less clean and makes debugging harder, but is likely still a worthwhile trade-off\n//    given the cost in gas and code size.\nlibrary SafeERC20 {\n  error SafeERC20FailedOperation(address token);\n\n  function safeTransfer(IERC20 token, address to, uint256 value) internal {\n    _revertOnFailure(token, abi.encodeCall(token.transfer, (to, value)));\n  }\n\n  function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n    _revertOnFailure(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n  }\n\n  function forceApprove(IERC20 token, address spender, uint256 value) internal {\n    bytes memory approveCall = abi.encodeCall(token.approve, (spender, value));\n\n    if (!_callWithOptionalReturnCheck(token, approveCall)) {\n      _revertOnFailure(token, abi.encodeCall(token.approve, (spender, 0)));\n      _revertOnFailure(token, approveCall);\n    }\n  }\n\n  function _callWithOptionalReturnCheck(\n    IERC20 token,\n    bytes memory encodedCall\n  ) private returns (bool success) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      mstore(SCRATCH_SPACE_PTR, 0)\n      success := call( //see https://www.evm.codes/?fork=cancun#f1\n        gas(),                       //gas\n        token,                       //callee\n        0,                           //value\n        add(encodedCall, WORD_SIZE), //input ptr\n        mload(encodedCall),          //input size\n        SCRATCH_SPACE_PTR,           //output ptr\n        WORD_SIZE                    //output size\n      )\n      //calls to addresses without code are always successful\n      if success {\n        success := or(iszero(returndatasize()), mload(SCRATCH_SPACE_PTR))\n      }\n    }\n  }\n\n  function _revertOnFailure(IERC20 token, bytes memory encodedCall) private {\n    if (!_callWithOptionalReturnCheck(token, encodedCall))\n      revert SafeERC20FailedOperation(address(token));\n  }\n}\n"}, "src/interfaces/ITokenMessengerV2.sol": {"content": "// Copyright (c) 2025 Stable Technologies Inc\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at https://mozilla.org/MPL/2.0/.\n\npragma solidity ^0.8.30;\n\nimport {IMessageTransmitterV2} from \"./IMessageTransmitterV2.sol\";\n\ninterface ITokenMessengerV2 {\n  function depositForBurn(\n    uint256 amount,\n    uint32 destinationDomain,\n    bytes32 mintRecipient,\n    address burnToken,\n    bytes32 destinationCaller,\n    uint256 maxFee,\n    uint32 minFinalityThreshold\n  ) external;\n\n  function depositForBurnWithHook(\n    uint256 amount,\n    uint32 destinationDomain,\n    bytes32 mintRecipient,\n    address burnToken,\n    bytes32 destinationCaller,\n    uint256 maxFee,\n    uint32 minFinalityThreshold,\n    bytes calldata hookData\n  ) external;\n\n  function localMessageTransmitter() external view returns (IMessageTransmitterV2);\n}\n"}, "../../price-oracle/evm/src/assets/PriceOracleIds.sol": {"content": "// Copyright (c) 2025 Stable Technologies Inc\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at https://mozilla.org/MPL/2.0/.\n\n// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.30;\n\n// ----------- Dispatcher Ids -----------\n\nuint8 constant DISPATCHER_PROTOCOL_VERSION0 = 0;\n\n// Execute commands\n\nuint8 constant PRICES_ID = 0x00;\nuint8 constant UPDATE_ASSISTANT_ID = 0x01;\n\n// Query commands\n\nuint8 constant PRICES_QUERIES_ID = 0x80;\nuint8 constant ASSISTANT_ID = 0x81;\n\n// ----------- Prices Ids ---------------\n\n// Execute commands\n\nuint8 constant EVM_FEE_PARAMS_ID = 0x00;\nuint8 constant EVM_GAS_PRICE_ID = 0x01;\nuint8 constant EVM_PRICE_PER_TX_BYTE_ID = 0x02;\nuint8 constant GAS_TOKEN_PRICE_ID = 0x03;\nuint8 constant SOLANA_COMPUTATION_PRICE_ID = 0x04;\nuint8 constant SOLANA_PRICE_PER_ACCOUNT_BYTE_ID = 0x05;\nuint8 constant SOLANA_SIGNATURE_PRICE_ID = 0x06;\nuint8 constant SUI_COMPUTATION_PRICE_ID = 0x07;\nuint8 constant SUI_STORAGE_PRICE_ID = 0x08;\nuint8 constant SUI_STORAGE_REBATE_ID = 0x09;\n\n// Query commands\n\nuint8 constant EVM_TX_QUOTE_ID = 0x80;\nuint8 constant SOLANA_TX_QUOTE_ID = 0x81;\nuint8 constant SUI_TX_QUOTE_ID = 0x82;\n\nuint8 constant QUERY_FEE_PARAMS_ID = 0x90;\nuint8 constant CHAIN_ID_ID = 0x91;\n"}, "../../price-oracle/evm/src/assets/types/ParamLibs.sol": {"content": "// Copyright (c) 2025 Stable Technologies Inc\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at https://mozilla.org/MPL/2.0/.\n\n// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.30;\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// !!! All unit libs return prices via their `from` functions as fixed point uints !!!\n// !!!   with 18 decimals in \"human units\" (i.e. eth, not wei, sol, not lamports). !!!\n// !!! So if 1 eth = $1000, then GasTokenPrice.from() returns 1e21 [usd/gasToken]. !!!\n// !!! Likewise, `to` functions expect prices in the same format.                  !!!\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n// Summary (since most of this file is boilerplate):\n//\n//      Type               \u2502 External Repr \u2502 Internal Repr \u2502 Bytes\n//\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n//  GasTokenPrice          \u2502 usd/gasToken  \u2502 \u00b5usd/gasToken \u2502   6\n//     GasPrice            \u2502 gasToken/gas  \u2502   Mwei/gas    \u2502   4\n//  PricePerTxByte         \u2502 gasToken/byte \u2502   Mwei/byte   \u2502   4\n// SolanaComputationPrice  \u2502    sol/cu     \u2502 \u00b5lamports/cu  \u2502   4\n// PricePerAccountByte     \u2502   sol/byte    \u2502 lamports/byte \u2502   4\n//  SignaturePrice         \u2502    sol/sig    \u2502 lamports/sig  \u2502   4\n//    GasDropoff           \u2502   gasToken    \u2502   \u00b5gasToken   \u2502   4\n//     BaseFee             \u2502      usd      \u2502     \u00b5usd      \u2502   4\n// SuiComputationPrice     \u2502    sui/cu     \u2502    mist/cu    \u2502   4\n//   StoragePrice          \u2502    sui/byte   \u2502   mist/byte   \u2502   4\n//  StorageRebate          \u2502  percentage   \u2502    0 to 100   \u2502   1\n\nerror LosingAllPrecision(uint256 , uint256 divisor);\nerror ExceedsMax(uint256 stored, uint256 max);\n\nfunction checkedUnitDiv(uint val, uint divisor, uint max) pure returns (uint) { unchecked {\n  if (val == 0)\n    return 0;\n\n  uint ret = val / divisor;\n  if (ret == 0)\n    revert LosingAllPrecision(val, divisor);\n\n  if (ret > max)\n    revert ExceedsMax(ret, max);\n\n  return ret;\n}}\n\n//gasToken is a more general term for elements of the set {sol, eth, avax, ...}\ntype GasTokenPrice is uint48;\n//external repr: usd/gasToken with 18 decimals (1 usd/eth => 1e18, usd NOT \u00b5usd!)\nlibrary GasTokenPriceLib {\n  //WARNING: any changes must be reflected in the typescript SDK!\n  uint internal constant BYTE_SIZE = 6;\n  uint private constant UNIT = 1e12; //\u00b5usd/gasToken (1e6 * 1e12 = 1e18)\n\n  function to(uint val) internal pure returns (GasTokenPrice) {\n    uint tmp = checkedUnitDiv(val, UNIT, type(uint48).max);\n\n    //skip unneccessary cleanup\n    uint48 ret;\n    assembly (\"memory-safe\") { ret := tmp }\n\n    return GasTokenPrice.wrap(ret);\n  }\n\n  function from(GasTokenPrice val) internal pure returns (uint) { unchecked {\n    return uint(GasTokenPrice.unwrap(val)) * UNIT;\n  }\n}}\nusing GasTokenPriceLib for GasTokenPrice global;\n\n//cost of 1 consumed gas unit\ntype GasPrice is uint32;\n//external repr: gasToken/gas with 18 decimals (eth/gas NOT Gwei/gas!)\nlibrary GasPriceLib {\n  //WARNING: any changes must be reflected in the typescript SDK!\n  uint internal constant BYTE_SIZE = 4;\n  uint private constant UNIT = 1e6;\n\n  function to(uint val) internal pure returns (GasPrice) { unchecked {\n    uint tmp = checkedUnitDiv(val, UNIT, type(uint32).max);\n\n    //skip unneccessary cleanup\n    uint32 ret;\n    assembly (\"memory-safe\") { ret := tmp }\n\n    return GasPrice.wrap(ret);\n  }}\n\n  function from(GasPrice val) internal pure returns (uint) { unchecked {\n    return uint(GasPrice.unwrap(val)) * UNIT;\n  }\n}}\nusing GasPriceLib for GasPrice global;\n\n//per byte cost of calldata on L2s\ntype PricePerTxByte is uint32;\n//external repr: gasToken/byte (of calldata) with 18 decimals (eth/byte NOT Gwei/gas!)\nlibrary PricePerTxByteLib {\n  //WARNING: any changes must be reflected in the typescript SDK!\n  uint internal constant BYTE_SIZE = 4;\n  uint private constant UNIT = 1e6;\n\n  function to(uint val) internal pure returns (PricePerTxByte) { unchecked {\n    uint tmp = checkedUnitDiv(val, UNIT, type(uint32).max);\n\n    //skip unneccessary cleanup\n    uint32 ret;\n    assembly (\"memory-safe\") { ret := tmp }\n\n    return PricePerTxByte.wrap(ret);\n  }}\n\n  function from(PricePerTxByte val) internal pure returns (uint) { unchecked {\n    return uint(PricePerTxByte.unwrap(val)) * UNIT;\n  }\n}}\nusing PricePerTxByteLib for PricePerTxByte global;\n\n// The price of a computation unit on the Solana chain\ntype SolanaComputationPrice is uint32;\n// External repr: sol/CU with 18 decimals (NOT lamports/CU!)\nlibrary SolanaComputationPriceLib {\n  //WARNING: any changes must be reflected in the typescript SDK!\n  uint internal constant BYTE_SIZE = 4;\n  uint private constant UNIT = 1e3; // Stored in microlamports/CU (15 decimals per CU)\n\n  function to(uint256 val) internal pure returns (SolanaComputationPrice) { unchecked {\n    uint tmp = checkedUnitDiv(val, UNIT, type(uint32).max);\n\n    //skip unneccessary cleanup\n    uint32 ret;\n    assembly (\"memory-safe\") { ret := tmp }\n\n    return SolanaComputationPrice.wrap(ret);\n  }}\n\n  function from(SolanaComputationPrice val) internal pure returns (uint256) { unchecked {\n    return uint256(SolanaComputationPrice.unwrap(val)) * UNIT;\n  }\n}}\nusing SolanaComputationPriceLib for SolanaComputationPrice global;\n\n//per byte cost of solana account data\ntype PricePerAccountByte is uint32;\n//external repr: sol/byte (of account data) with 18 decimals (NOT lamports/byte!)\n//At time of writing: 6_960 lamports/byte (alson likely won't change).\n//So likely returned value: 6_960_000_000_000 = 0.00000696 sol/byte\nlibrary PricePerAccountByteLib {\n  //WARNING: any changes must be reflected in the typescript SDK!\n  uint internal constant BYTE_SIZE = 4;\n  uint private constant UNIT = 1e9; //stored in lamports/byte\n\n  function to(uint256 val) internal pure returns (PricePerAccountByte) { unchecked {\n    uint tmp = checkedUnitDiv(val, UNIT, type(uint32).max);\n\n    //skip unneccessary cleanup\n    uint32 ret;\n    assembly (\"memory-safe\") { ret := tmp }\n\n    return PricePerAccountByte.wrap(ret);\n  }}\n\n  function from(PricePerAccountByte val) internal pure returns (uint256) { unchecked {\n    return uint256(PricePerAccountByte.unwrap(val)) * UNIT;\n  }\n}}\nusing PricePerAccountByteLib for PricePerAccountByte global;\n\n// Cost per signature in Solana\ntype SignaturePrice is uint32;\n//external repr: sol/signature with 18 decimals (NOT lamports/byte!)\n//At time of writing: 10000 lamports per signature\nlibrary SignaturePriceLib {\n  //WARNING: any changes must be reflected in the typescript SDK!\n  uint internal constant BYTE_SIZE = 4;\n  uint private constant UNIT = 1e9; //stored in lamports/byte\n\n  function to(uint256 val) internal pure returns (SignaturePrice) { unchecked {\n    uint tmp = checkedUnitDiv(val, UNIT, type(uint32).max);\n\n    //skip unneccessary cleanup\n    uint32 ret;\n    assembly (\"memory-safe\") { ret := tmp }\n\n    return SignaturePrice.wrap(ret);\n  }}\n\n  function from(SignaturePrice val) internal pure returns (uint256) { unchecked {\n    return uint256(SignaturePrice.unwrap(val)) * UNIT;\n  }\n}}\nusing SignaturePriceLib for SignaturePrice global;\n\n//requested amount of additional gas dropoff for a delivery\ntype GasDropoff is uint32;\n//external repr: gasToken with 18 decimals\nlibrary GasDropoffLib {\n  //WARNING: any changes must be reflected in the typescript SDK!\n  uint internal constant BYTE_SIZE = 4;\n  uint private constant UNIT = 1e12; //specified in \u00b5gasToken\n\n  function to(uint256 val) internal pure returns (GasDropoff) { unchecked {\n    uint tmp = checkedUnitDiv(val, UNIT, type(uint32).max);\n\n    //skip unneccessary cleanup\n    uint32 ret;\n    assembly (\"memory-safe\") { ret := tmp }\n\n    return GasDropoff.wrap(ret);\n  }}\n\n  function from(GasDropoff val) internal pure returns (uint256) { unchecked {\n    return uint256(GasDropoff.unwrap(val)) * UNIT;\n  }\n}}\nusing GasDropoffLib for GasDropoff global;\n\ntype BaseFee is uint32;\n//external repr: usd with 18 decimals\nlibrary BaseFeeLib {\n  //WARNING: any changes must be reflected in the typescript SDK!\n  uint internal constant BYTE_SIZE = 4;\n  uint private constant UNIT = 1e12; //specified in \u00b5usd\n\n  function to(uint256 val) internal pure returns (BaseFee) { unchecked {\n    uint tmp = checkedUnitDiv(val, UNIT, type(uint32).max);\n\n    //skip unneccessary cleanup\n    uint32 ret;\n    assembly (\"memory-safe\") { ret := tmp }\n\n    return BaseFee.wrap(ret);\n  }}\n\n  function from(BaseFee val) internal pure returns (uint256) { unchecked {\n    return uint256(BaseFee.unwrap(val)) * UNIT;\n  }\n}}\nusing BaseFeeLib for BaseFee global;\n\n// The price of a computation unit on the SUI chain\n// Similarly to EVM, this is the price of a computation unit in MIST\n// It varies depending on the current state of the network\ntype SuiComputationPrice is uint32;\n// External repr: SUI with 18 decimals, not MIST/computationUnit\nlibrary SuiComputationPriceLib {\n  //WARNING: any changes must be reflected in the typescript SDK!\n  uint internal constant BYTE_SIZE = 4;\n  uint private constant UNIT = 1e9; // Stored in MIST\n\n  function to(uint256 val) internal pure returns (SuiComputationPrice) { unchecked {\n    uint tmp = checkedUnitDiv(val, UNIT, type(uint32).max);\n\n    //skip unneccessary cleanup\n    uint32 ret;\n    assembly (\"memory-safe\") { ret := tmp }\n\n    return SuiComputationPrice.wrap(ret);\n  }}\n\n  function from(SuiComputationPrice val) internal pure returns (uint256) { unchecked {\n    return uint256(SuiComputationPrice.unwrap(val)) * UNIT;\n  }\n}}\nusing SuiComputationPriceLib for SuiComputationPrice global;\n\n// The price of a storage byte on the SUI chain\n// This one is set by governance and thus is unlikely to change\ntype StoragePrice is uint32;\n// External repr: SUI with 18 decimals, not MIST/bytes\nlibrary StoragePriceLib {\n  //WARNING: any changes must be reflected in the typescript SDK!\n  uint internal constant BYTE_SIZE = 4;\n  uint private constant UNIT = 1e9; // Stored in MIST\n\n  function to(uint256 val) internal pure returns (StoragePrice) { unchecked {\n    uint tmp = checkedUnitDiv(val, UNIT, type(uint32).max);\n\n    //skip unneccessary cleanup\n    uint32 ret;\n    assembly (\"memory-safe\") { ret := tmp }\n\n    return StoragePrice.wrap(ret);\n  }}\n\n  function from(StoragePrice val) internal pure returns (uint256) { unchecked {\n    return uint256(StoragePrice.unwrap(val)) * UNIT;\n  }\n}}\nusing StoragePriceLib for StoragePrice global;\n\n// The percentage of storage rebate between 0 and 100\n// This one is set by governance and thus is unlikely to change\ntype StorageRebate is uint8;\n// External repr: A percentage, ideally an integer number between 0 and 100\nlibrary StorageRebateLib {\n  //WARNING: any changes must be reflected in the typescript SDK!\n  uint internal constant BYTE_SIZE = 1;\n  uint internal constant MAX = 100;\n\n  function to(uint256 val) internal pure returns (StorageRebate) { unchecked {\n    if (val > MAX)\n      revert ExceedsMax(val, MAX);\n\n    //skip unneccessary cleanup\n    uint8 ret;\n    assembly (\"memory-safe\") { ret := val }\n\n    return StorageRebate.wrap(ret);\n  }}\n\n  function from(StorageRebate val) internal pure returns (uint256) { unchecked {\n    return uint256(StorageRebate.unwrap(val));\n  }\n}}\nusing StorageRebateLib for StorageRebate global;"}, "../../price-oracle/evm/src/assets/types/EvmFeeParams.sol": {"content": "// Copyright (c) 2025 Stable Technologies Inc\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at https://mozilla.org/MPL/2.0/.\n\n// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.30;\n\nimport {\n  GasTokenPrice, GasTokenPriceLib,\n  GasPrice, GasPriceLib,\n  PricePerTxByte, PricePerTxByteLib\n} from \"./ParamLibs.sol\";\n\nerror InvalidEvmLayout(uint256 value);\n\n//store everything in one slot and make reads and writes cheap (no struct in memory nonsense)\ntype EvmFeeParams is uint256;\nlibrary EvmFeeParamsLib {\n  //layout (low to high bits - i.e. in packed struct order) with internal and external units:\n  //  6 bytes gasTokenPrice - \u03bcusd / eth (=> min: 1e-6 usd/eth, max: ~1e8 usd/eth)\n  //  4 bytes gasPrice - Mwei / gas\n  //  4 bytes pricePerTxByte - Mwei / byte\n  // 18 bytes currently unused\n\n  uint256 private constant GAS_TOKEN_PRICE_SIZE = GasTokenPriceLib.BYTE_SIZE * 8;\n  uint256 private constant GAS_TOKEN_PRICE_OFFSET = 0;\n  uint256 private constant GAS_TOKEN_PRICE_WRITE_MASK =\n    ~(((1 << GAS_TOKEN_PRICE_SIZE) - 1) << GAS_TOKEN_PRICE_OFFSET);\n\n  uint256 private constant GAS_PRICE_SIZE = GasPriceLib.BYTE_SIZE * 8;\n  uint256 private constant GAS_PRICE_OFFSET =\n    GAS_TOKEN_PRICE_OFFSET + GAS_TOKEN_PRICE_SIZE;\n  uint256 private constant GAS_PRICE_WRITE_MASK =\n    ~(((1 << GAS_PRICE_SIZE) - 1) << GAS_PRICE_OFFSET);\n\n  uint256 private constant PRICE_PER_BYTE_SIZE = PricePerTxByteLib.BYTE_SIZE * 8;\n  uint256 private constant PRICE_PER_BYTE_OFFSET =\n    GAS_PRICE_OFFSET + GAS_PRICE_SIZE;\n  uint256 private constant PRICE_PER_BYTE_WRITE_MASK =\n    ~(((1 << PRICE_PER_BYTE_SIZE) - 1) << PRICE_PER_BYTE_OFFSET);\n\n  uint256 private constant LAYOUT_WRITE_MASK = //all unused bits are 1\n    PRICE_PER_BYTE_WRITE_MASK & GAS_PRICE_WRITE_MASK & GAS_TOKEN_PRICE_WRITE_MASK;\n\n  function checkedWrap(uint256 value) internal pure returns (EvmFeeParams) { unchecked {\n    if ((value & LAYOUT_WRITE_MASK) != 0)\n      revert InvalidEvmLayout(value);\n\n    return EvmFeeParams.wrap(value);\n  }}\n\n  function gasTokenPrice(EvmFeeParams params) internal pure returns (GasTokenPrice) { unchecked {\n    return GasTokenPrice.wrap(\n      uint48(EvmFeeParams.unwrap(params) >> GAS_TOKEN_PRICE_OFFSET)\n    );\n  }}\n\n  function gasTokenPrice(\n    EvmFeeParams params,\n    GasTokenPrice gasTokenPrice_\n  ) internal pure returns (EvmFeeParams) { unchecked {\n    return EvmFeeParams.wrap(\n      (EvmFeeParams.unwrap(params) & GAS_TOKEN_PRICE_WRITE_MASK) |\n      (uint256(GasTokenPrice.unwrap(gasTokenPrice_)) << GAS_TOKEN_PRICE_OFFSET)\n    );\n  }}\n\n  function gasPrice(EvmFeeParams params) internal pure returns (GasPrice) { unchecked {\n    return GasPrice.wrap(\n      uint32(EvmFeeParams.unwrap(params) >> GAS_PRICE_OFFSET)\n    );\n  }}\n\n  function gasPrice(\n    EvmFeeParams params,\n    GasPrice gasPrice_\n  ) internal pure returns (EvmFeeParams) { unchecked {\n    return EvmFeeParams.wrap(\n      (EvmFeeParams.unwrap(params) & GAS_PRICE_WRITE_MASK) |\n      (uint256(GasPrice.unwrap(gasPrice_)) << GAS_PRICE_OFFSET)\n    );\n  }}\n\n  function pricePerTxByte(EvmFeeParams params) internal pure returns (PricePerTxByte) { unchecked {\n    return PricePerTxByte.wrap(\n      uint32(EvmFeeParams.unwrap(params) >> PRICE_PER_BYTE_OFFSET)\n    );\n  }}\n\n  function pricePerTxByte(\n    EvmFeeParams params,\n    PricePerTxByte pricePerTxByte_\n  ) internal pure returns (EvmFeeParams) { unchecked {\n    return EvmFeeParams.wrap(\n      (EvmFeeParams.unwrap(params) & PRICE_PER_BYTE_WRITE_MASK) |\n      (uint256(PricePerTxByte.unwrap(pricePerTxByte_)) << PRICE_PER_BYTE_OFFSET)\n    );\n  }}\n}\nusing EvmFeeParamsLib for EvmFeeParams global;\n"}, "../../price-oracle/evm/src/assets/types/SolanaFeeParams.sol": {"content": "// Copyright (c) 2025 Stable Technologies Inc\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at https://mozilla.org/MPL/2.0/.\n\n// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.30;\n\nimport {\n  GasTokenPrice, GasTokenPriceLib,\n  PricePerAccountByte, PricePerAccountByteLib,\n  SolanaComputationPrice, SolanaComputationPriceLib,\n  SignaturePrice, SignaturePriceLib\n} from \"./ParamLibs.sol\";\n\nerror InvalidSolanaLayout(uint256 value);\n\n//store everything in one slot and make reads and writes cheap (no struct in memory nonsense)\ntype SolanaFeeParams is uint256;\nlibrary SolanaFeeParamsLib {\n  // layout (low to high bits - i.e. in packed struct order) - unit:\n  //  6 bytes gasTokenPrice    - \u03bcusd/sol (=> min: 1e-6 usd/sol, max: ~1e8 usd/sol)\n  //  4 bytes computationPrice  - microlamports/CU\n  //  4 bytes pricePerAccountByte  - lamports/byte\n  //  4 bytes signaturePrice    - lamports/signature\n  // 14 bytes currently unused\n\n  uint256 private constant GAS_TOKEN_PRICE_SIZE = GasTokenPriceLib.BYTE_SIZE * 8;\n  uint256 private constant GAS_TOKEN_PRICE_OFFSET = 0;\n  uint256 private constant GAS_TOKEN_PRICE_WRITE_MASK =\n    ~(((1 << GAS_TOKEN_PRICE_SIZE) - 1) << GAS_TOKEN_PRICE_OFFSET);\n\n  uint256 private constant COMPUTATION_PRICE_SIZE = SolanaComputationPriceLib.BYTE_SIZE * 8;\n  uint256 private constant COMPUTATION_PRICE_OFFSET =\n    GAS_TOKEN_PRICE_OFFSET + GAS_TOKEN_PRICE_SIZE;\n  uint256 private constant COMPUTATION_PRICE_WRITE_MASK =\n    ~(((1 << COMPUTATION_PRICE_SIZE) - 1) << COMPUTATION_PRICE_OFFSET);\n\n  uint256 private constant PRICE_PER_ACCOUNT_BYTE_SIZE = PricePerAccountByteLib.BYTE_SIZE * 8;\n  uint256 private constant PRICE_PER_ACCOUNT_BYTE_OFFSET =\n    COMPUTATION_PRICE_OFFSET + COMPUTATION_PRICE_SIZE;\n  uint256 private constant PRICE_PER_ACCOUNT_BYTE_WRITE_MASK =\n    ~(((1 << PRICE_PER_ACCOUNT_BYTE_SIZE) - 1) << PRICE_PER_ACCOUNT_BYTE_OFFSET);\n\n  uint256 private constant SIGNATURE_PRICE_SIZE = SignaturePriceLib.BYTE_SIZE * 8;\n  uint256 private constant SIGNATURE_PRICE_OFFSET =\n    PRICE_PER_ACCOUNT_BYTE_OFFSET + PRICE_PER_ACCOUNT_BYTE_SIZE;\n  uint256 private constant SIGNATURE_PRICE_WRITE_MASK =\n    ~(((1 << SIGNATURE_PRICE_SIZE) - 1) << SIGNATURE_PRICE_OFFSET);\n\n  uint256 private constant LAYOUT_WRITE_MASK = //all unused bits are 1\n    GAS_TOKEN_PRICE_WRITE_MASK & COMPUTATION_PRICE_WRITE_MASK &\n    PRICE_PER_ACCOUNT_BYTE_WRITE_MASK & SIGNATURE_PRICE_WRITE_MASK;\n\n  function checkedWrap(uint256 value) internal pure returns (SolanaFeeParams) { unchecked {\n    if ((value & LAYOUT_WRITE_MASK) != 0)\n      revert InvalidSolanaLayout(value);\n\n    return SolanaFeeParams.wrap(value);\n  }}\n\n  function gasTokenPrice(\n    SolanaFeeParams params\n  ) internal pure returns (GasTokenPrice) { unchecked {\n    return GasTokenPrice.wrap(\n      uint48(SolanaFeeParams.unwrap(params) >> GAS_TOKEN_PRICE_OFFSET)\n    );\n  }}\n\n  function gasTokenPrice(\n    SolanaFeeParams params,\n    GasTokenPrice gasTokenPrice_\n  ) internal pure returns (SolanaFeeParams) { unchecked {\n    return SolanaFeeParams.wrap(\n      (SolanaFeeParams.unwrap(params) & GAS_TOKEN_PRICE_WRITE_MASK) |\n      (uint256(GasTokenPrice.unwrap(gasTokenPrice_)) << GAS_TOKEN_PRICE_OFFSET)\n    );\n  }}\n\n  function pricePerAccountByte(\n    SolanaFeeParams params\n  ) internal pure returns (PricePerAccountByte) { unchecked {\n    return PricePerAccountByte.wrap(\n      uint32(SolanaFeeParams.unwrap(params) >> PRICE_PER_ACCOUNT_BYTE_OFFSET)\n    );\n  }}\n\n  function pricePerAccountByte(\n    SolanaFeeParams params,\n    PricePerAccountByte pricePerAccountByte_\n  ) internal pure returns (SolanaFeeParams) { unchecked {\n    return SolanaFeeParams.wrap(\n      (SolanaFeeParams.unwrap(params) & PRICE_PER_ACCOUNT_BYTE_WRITE_MASK) |\n      (uint256(PricePerAccountByte.unwrap(pricePerAccountByte_)) << PRICE_PER_ACCOUNT_BYTE_OFFSET)\n    );\n  }}\n\n  function computationPrice(\n    SolanaFeeParams params\n  ) internal pure returns (SolanaComputationPrice) { unchecked {\n    return SolanaComputationPrice.wrap(\n      uint32(SolanaFeeParams.unwrap(params) >> COMPUTATION_PRICE_OFFSET)\n    );\n  }}\n\n  function computationPrice(\n    SolanaFeeParams params,\n    SolanaComputationPrice computationPrice_\n  ) internal pure returns (SolanaFeeParams) { unchecked {\n    return SolanaFeeParams.wrap(\n      (SolanaFeeParams.unwrap(params) & COMPUTATION_PRICE_WRITE_MASK) |\n      (uint256(SolanaComputationPrice.unwrap(computationPrice_)) << COMPUTATION_PRICE_OFFSET)\n    );\n  }}\n\n  function signaturePrice(\n    SolanaFeeParams params\n  ) internal pure returns (SignaturePrice) { unchecked {\n    return SignaturePrice.wrap(\n      uint32(SolanaFeeParams.unwrap(params) >> SIGNATURE_PRICE_OFFSET)\n    );\n  }}\n\n  function signaturePrice(\n    SolanaFeeParams params,\n    SignaturePrice signaturePrice_\n  ) internal pure returns (SolanaFeeParams) { unchecked {\n    return SolanaFeeParams.wrap(\n      (SolanaFeeParams.unwrap(params) & SIGNATURE_PRICE_WRITE_MASK) |\n      (uint256(SignaturePrice.unwrap(signaturePrice_)) << SIGNATURE_PRICE_OFFSET)\n    );\n  }}\n}\n\nusing SolanaFeeParamsLib for SolanaFeeParams global;"}, "../../price-oracle/evm/src/assets/types/SuiFeeParams.sol": {"content": "// Copyright (c) 2025 Stable Technologies Inc\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at https://mozilla.org/MPL/2.0/.\n\n// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.30;\n\nimport {\n  GasTokenPrice, GasTokenPriceLib,\n  SuiComputationPrice, SuiComputationPriceLib,\n  StoragePrice, StoragePriceLib,\n  StorageRebate, StorageRebateLib\n} from \"./ParamLibs.sol\";\n\nerror InvalidSuiLayout(uint256 value);\n\n//store everything in one slot and make reads and writes cheap (no struct in memory nonsense)\ntype SuiFeeParams is uint256;\nlibrary SuiFeeParamsLib {\n  // layout (low to high bits - i.e. in packed struct order) - unit:\n  //  6 bytes gasTokenPrice    - \u03bcusd/sui (=> min: 1e-6 usd/sui, max: ~1e8 usd/sui)\n  //  4 bytes computationPrice - mist/computationUnit\n  //  4 bytes storagePrice     - mist/byte\n  //  1 byte  storageRebate    - number between 0 and 100\n  // 17 bytes currently unused\n\n  uint256 private constant GAS_TOKEN_PRICE_SIZE = GasTokenPriceLib.BYTE_SIZE * 8;\n  uint256 private constant GAS_TOKEN_PRICE_OFFSET = 0;\n  uint256 private constant GAS_TOKEN_PRICE_WRITE_MASK =\n    ~(((1 << GAS_TOKEN_PRICE_SIZE) - 1) << GAS_TOKEN_PRICE_OFFSET);\n\n  uint256 private constant COMPUTATION_PRICE_SIZE = SuiComputationPriceLib.BYTE_SIZE * 8;\n  uint256 private constant COMPUTATION_PRICE_OFFSET =\n    GAS_TOKEN_PRICE_OFFSET + GAS_TOKEN_PRICE_SIZE;\n  uint256 private constant COMPUTATION_PRICE_WRITE_MASK =\n    ~(((1 << COMPUTATION_PRICE_SIZE) - 1) << COMPUTATION_PRICE_OFFSET);\n\n  uint256 private constant STORAGE_PRICE_SIZE = StoragePriceLib.BYTE_SIZE * 8;\n  uint256 private constant STORAGE_PRICE_OFFSET =\n    COMPUTATION_PRICE_OFFSET + COMPUTATION_PRICE_SIZE;\n  uint256 private constant STORAGE_PRICE_WRITE_MASK =\n    ~(((1 << STORAGE_PRICE_SIZE) - 1) << STORAGE_PRICE_OFFSET);\n\n  uint256 private constant STORAGE_REBATE_SIZE = StoragePriceLib.BYTE_SIZE * 8;\n  uint256 private constant STORAGE_REBATE_OFFSET =\n    STORAGE_PRICE_OFFSET + STORAGE_PRICE_SIZE;\n  uint256 private constant STORAGE_REBATE_WRITE_MASK =\n    ~(((1 << STORAGE_REBATE_SIZE) - 1) << STORAGE_REBATE_OFFSET);\n\n  uint256 private constant LAYOUT_WRITE_MASK = //all unused bits are 1\n    GAS_TOKEN_PRICE_WRITE_MASK & COMPUTATION_PRICE_WRITE_MASK & \n    STORAGE_PRICE_WRITE_MASK & STORAGE_REBATE_WRITE_MASK;\n\n  function checkedWrap(uint256 value) internal pure returns (SuiFeeParams) { unchecked {\n    if ((value & LAYOUT_WRITE_MASK) != 0)\n      revert InvalidSuiLayout(value);\n\n    return SuiFeeParams.wrap(value);\n  }}\n\n  function gasTokenPrice(\n    SuiFeeParams params\n  ) internal pure returns (GasTokenPrice) { unchecked {\n    return GasTokenPrice.wrap(\n      uint48(SuiFeeParams.unwrap(params) >> GAS_TOKEN_PRICE_OFFSET)\n    );\n  }}\n\n  function gasTokenPrice(\n    SuiFeeParams params,\n    GasTokenPrice gasTokenPrice_\n  ) internal pure returns (SuiFeeParams) { unchecked {\n    return SuiFeeParams.wrap(\n      (SuiFeeParams.unwrap(params) & GAS_TOKEN_PRICE_WRITE_MASK) |\n      (uint256(GasTokenPrice.unwrap(gasTokenPrice_)) << GAS_TOKEN_PRICE_OFFSET)\n    );\n  }}\n\n  function computationPrice(\n    SuiFeeParams params\n  ) internal pure returns (SuiComputationPrice) { unchecked {\n    return SuiComputationPrice.wrap(\n      uint32(SuiFeeParams.unwrap(params) >> COMPUTATION_PRICE_OFFSET)\n    );\n  }}\n\n  function computationPrice(\n    SuiFeeParams params,\n    SuiComputationPrice computationPrice_\n  ) internal pure returns (SuiFeeParams) { unchecked {\n    return SuiFeeParams.wrap(\n      (SuiFeeParams.unwrap(params) & COMPUTATION_PRICE_WRITE_MASK) |\n      (uint256(SuiComputationPrice.unwrap(computationPrice_)) << COMPUTATION_PRICE_OFFSET)\n    );\n  }}\n\n  function storagePrice(\n    SuiFeeParams params\n  ) internal pure returns (StoragePrice) { unchecked {\n    return StoragePrice.wrap(\n      uint32(SuiFeeParams.unwrap(params) >> STORAGE_PRICE_OFFSET)\n    );\n  }}\n\n  function storagePrice(\n    SuiFeeParams params,\n    StoragePrice storagePrice_\n  ) internal pure returns (SuiFeeParams) { unchecked {\n    return SuiFeeParams.wrap(\n      (SuiFeeParams.unwrap(params) & STORAGE_PRICE_WRITE_MASK) |\n      (uint256(StoragePrice.unwrap(storagePrice_)) << STORAGE_PRICE_OFFSET)\n    );\n  }}\n\n  function storageRebate(\n    SuiFeeParams params\n  ) internal pure returns (StorageRebate) { unchecked {\n    return StorageRebate.wrap(\n      uint8(SuiFeeParams.unwrap(params) >> STORAGE_REBATE_OFFSET)\n    );\n  }}\n\n  function storageRebate(\n    SuiFeeParams params,\n    StorageRebate storageRebate_\n  ) internal pure returns (SuiFeeParams) { unchecked {\n    return SuiFeeParams.wrap(\n      (SuiFeeParams.unwrap(params) & STORAGE_REBATE_WRITE_MASK) |\n      (uint256(StorageRebate.unwrap(storageRebate_)) << STORAGE_REBATE_OFFSET)\n    );\n  }}\n}\n\nusing SuiFeeParamsLib for SuiFeeParams global;"}, "lib/wormhole-solidity-sdk/src/interfaces/token/IERC20.sol": {"content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.30;\n\n//https://eips.ethereum.org/EIPS/eip-20\ninterface IERC20 {\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  function totalSupply() external view returns (uint256);\n  function balanceOf(address account) external view returns (uint256);\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function transfer(address to, uint256 amount) external returns (bool);\n  function approve(address spender, uint256 amount) external returns (bool);\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"}, "lib/permit2/src/interfaces/IAllowanceTransfer.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IEIP712} from \"./IEIP712.sol\";\n\n/// @title AllowanceTransfer\n/// @notice Handles ERC20 token permissions through signature based allowance setting and ERC20 token transfers by checking allowed amounts\n/// @dev Requires user's token approval on the Permit2 contract\ninterface IAllowanceTransfer is IEIP712 {\n    /// @notice Thrown when an allowance on a token has expired.\n    /// @param deadline The timestamp at which the allowed amount is no longer valid\n    error AllowanceExpired(uint256 deadline);\n\n    /// @notice Thrown when an allowance on a token has been depleted.\n    /// @param amount The maximum amount allowed\n    error InsufficientAllowance(uint256 amount);\n\n    /// @notice Thrown when too many nonces are invalidated.\n    error ExcessiveInvalidation();\n\n    /// @notice Emits an event when the owner successfully invalidates an ordered nonce.\n    event NonceInvalidation(\n        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce\n    );\n\n    /// @notice Emits an event when the owner successfully sets permissions on a token for the spender.\n    event Approval(\n        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration\n    );\n\n    /// @notice Emits an event when the owner successfully sets permissions using a permit signature on a token for the spender.\n    event Permit(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 nonce\n    );\n\n    /// @notice Emits an event when the owner sets the allowance back to 0 with the lockdown function.\n    event Lockdown(address indexed owner, address token, address spender);\n\n    /// @notice The permit data for a token\n    struct PermitDetails {\n        // ERC20 token address\n        address token;\n        // the maximum amount allowed to spend\n        uint160 amount;\n        // timestamp at which a spender's token allowances become invalid\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n\n    /// @notice The permit message signed for a single token allowance\n    struct PermitSingle {\n        // the permit data for a single token alownce\n        PermitDetails details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n\n    /// @notice The permit message signed for multiple token allowances\n    struct PermitBatch {\n        // the permit data for multiple token allowances\n        PermitDetails[] details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n\n    /// @notice The saved permissions\n    /// @dev This info is saved per owner, per token, per spender and all signed over in the permit message\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\n    struct PackedAllowance {\n        // amount allowed\n        uint160 amount;\n        // permission expiry\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n\n    /// @notice A token spender pair.\n    struct TokenSpenderPair {\n        // the token the spender is approved\n        address token;\n        // the spender address\n        address spender;\n    }\n\n    /// @notice Details for a token transfer.\n    struct AllowanceTransferDetails {\n        // the owner of the token\n        address from;\n        // the recipient of the token\n        address to;\n        // the amount of the token\n        uint160 amount;\n        // the token to be transferred\n        address token;\n    }\n\n    /// @notice A mapping from owner address to token address to spender address to PackedAllowance struct, which contains details and conditions of the approval.\n    /// @notice The mapping is indexed in the above order see: allowance[ownerAddress][tokenAddress][spenderAddress]\n    /// @dev The packed slot holds the allowed amount, expiration at which the allowed amount is no longer valid, and current nonce thats updated on any signature based approvals.\n    function allowance(address user, address token, address spender)\n        external\n        view\n        returns (uint160 amount, uint48 expiration, uint48 nonce);\n\n    /// @notice Approves the spender to use up to amount of the specified token up until the expiration\n    /// @param token The token to approve\n    /// @param spender The spender address to approve\n    /// @param amount The approved amount of the token\n    /// @param expiration The timestamp at which the approval is no longer valid\n    /// @dev The packed allowance also holds a nonce, which will stay unchanged in approve\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n\n    /// @notice Permit a spender to a given amount of the owners token via the owner's EIP-712 signature\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\n    /// @param owner The owner of the tokens being approved\n    /// @param permitSingle Data signed over by the owner specifying the terms of approval\n    /// @param signature The owner's signature over the permit data\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n\n    /// @notice Permit a spender to the signed amounts of the owners tokens via the owner's EIP-712 signature\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\n    /// @param owner The owner of the tokens being approved\n    /// @param permitBatch Data signed over by the owner specifying the terms of approval\n    /// @param signature The owner's signature over the permit data\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n\n    /// @notice Transfer approved tokens from one address to another\n    /// @param from The address to transfer from\n    /// @param to The address of the recipient\n    /// @param amount The amount of the token to transfer\n    /// @param token The token address to transfer\n    /// @dev Requires the from address to have approved at least the desired amount\n    /// of tokens to msg.sender.\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n\n    /// @notice Transfer approved tokens in a batch\n    /// @param transferDetails Array of owners, recipients, amounts, and tokens for the transfers\n    /// @dev Requires the from addresses to have approved at least the desired amount\n    /// of tokens to msg.sender.\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n\n    /// @notice Enables performing a \"lockdown\" of the sender's Permit2 identity\n    /// by batch revoking approvals\n    /// @param approvals Array of approvals to revoke.\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\n\n    /// @notice Invalidate nonces for a given (token, spender) pair\n    /// @param token The token to invalidate nonces for\n    /// @param spender The spender to invalidate nonces for\n    /// @param newNonce The new nonce to set. Invalidates all nonces less than it.\n    /// @dev Can't invalidate more than 2**16 nonces per transaction.\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\n}\n"}, "lib/permit2/src/interfaces/IEIP712.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IEIP712 {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"}, "lib/wormhole-solidity-sdk/src/interfaces/cctp/shared/IOwnable2Step.sol": {"content": "// SPDX-License-Identifier: Apache 2\n// Copyright (c) 2022, Circle Internet Financial Limited.\n//\n// stripped, flattened version of:\n//   https://github.com/circlefin/evm-cctp-contracts/blob/master/src/roles/Ownable2Step.sol\n\npragma solidity ^0.8.30;\n\ninterface IOwnable2Step {\n  event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  function transferOwnership(address newOwner) external;\n  function acceptOwnership() external;\n\n  function owner() external view returns (address);\n  function pendingOwner() external view returns (address);\n}\n"}, "lib/wormhole-solidity-sdk/src/interfaces/cctp/IMessageTransmitter.sol": {"content": "// SPDX-License-Identifier: Apache 2\n// Copyright (c) 2022, Circle Internet Financial Limited.\n//\n// stripped, flattened version of:\n//   https://github.com/circlefin/evm-cctp-contracts/blob/master/src/MessageTransmitter.sol\n\npragma solidity ^0.8.30;\n\nimport {IOwnable2Step} from \"./shared/IOwnable2Step.sol\";\nimport {IPausable} from \"./shared/IPausable.sol\";\n\ninterface IAttestable {\n  event AttesterEnabled(address indexed attester);\n  event AttesterDisabled(address indexed attester);\n\n  event SignatureThresholdUpdated(uint256 oldSignatureThreshold, uint256 newSignatureThreshold);\n  event AttesterManagerUpdated(\n    address indexed previousAttesterManager,\n    address indexed newAttesterManager\n  );\n\n  function attesterManager() external view returns (address);\n  function isEnabledAttester(address attester) external view returns (bool);\n  function getNumEnabledAttesters() external view returns (uint256);\n  function getEnabledAttester(uint256 index) external view returns (address);\n\n  function updateAttesterManager(address newAttesterManager) external;\n  function setSignatureThreshold(uint256 newSignatureThreshold) external;\n  function enableAttester(address attester) external;\n  function disableAttester(address attester) external;\n}\n\ninterface IMessageTransmitter is IAttestable, IPausable, IOwnable2Step {\n  event MessageSent(bytes message);\n\n  event MessageReceived(\n    address indexed caller,\n    uint32 sourceDomain,\n    uint64 indexed nonce,\n    bytes32 sender,\n    bytes messageBody\n  );\n\n  function localDomain() external view returns (uint32);\n  function version() external view returns (uint32);\n  function maxMessageBodySize() external view returns (uint256);\n  function nextAvailableNonce() external view returns (uint64);\n  function usedNonces(bytes32 nonce) external view returns (bool);\n\n  function sendMessage(\n    uint32 destinationDomain,\n    bytes32 recipient,\n    bytes calldata messageBody\n  ) external returns (uint64);\n\n  function sendMessageWithCaller(\n    uint32 destinationDomain,\n    bytes32 recipient,\n    bytes32 destinationCaller,\n    bytes calldata messageBody\n  ) external returns (uint64);\n\n  function replaceMessage(\n    bytes calldata originalMessage,\n    bytes calldata originalAttestation,\n    bytes calldata newMessageBody,\n    bytes32 newDestinationCaller\n  ) external;\n\n  function receiveMessage(\n    bytes calldata message,\n    bytes calldata attestation\n  ) external returns (bool success);\n\n  function setMaxMessageBodySize(uint256 newMaxMessageBodySize) external;\n}\n"}, "lib/wormhole-solidity-sdk/src/interfaces/cctp/ITokenMinter.sol": {"content": "// SPDX-License-Identifier: Apache 2\n// Copyright (c) 2022, Circle Internet Financial Limited.\n//stripped version of:\n//https://github.com/circlefin/evm-cctp-contracts/blob/master/src/interfaces/ITokenMinter.sol\n\npragma solidity ^0.8.30;\n\nimport {IOwnable2Step} from \"./shared/IOwnable2Step.sol\";\nimport {IPausable} from \"./shared/IPausable.sol\";\n\ninterface ITokenController {\n  event TokenPairLinked(address localToken, uint32 remoteDomain, bytes32 remoteToken);\n  event TokenPairUnlinked(address localToken, uint32 remoteDomain, bytes32 remoteToken);\n\n  event SetBurnLimitPerMessage(address indexed token, uint256 burnLimitPerMessage);\n  event SetTokenController(address tokenController);\n\n  function burnLimitsPerMessage(address token) external view returns (uint256);\n  function remoteTokensToLocalTokens(bytes32 sourceIdHash) external view returns (address);\n  function tokenController() external view returns (address);\n\n  function linkTokenPair(address localToken, uint32 remoteDomain, bytes32 remoteToken) external;\n  function unlinkTokenPair(address localToken, uint32 remoteDomain, bytes32 remoteToken) external;\n  function setMaxBurnAmountPerMessage(address localToken, uint256 burnLimitPerMessage) external;\n}\n\ninterface ITokenMinter is ITokenController, IPausable, IOwnable2Step {\n  event LocalTokenMessengerAdded(address localTokenMessenger);\n  event LocalTokenMessengerRemoved(address localTokenMessenger);\n\n  function localTokenMessenger() external view returns (address);\n  function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n\n  function mint(uint32 sourceDomain, bytes32 burnToken, address to, uint256 amount) external;\n  function burn(address burnToken, uint256 burnAmount) external;\n\n  function addLocalTokenMessenger(address newLocalTokenMessenger) external;\n  function removeLocalTokenMessenger() external;\n  function setTokenController(address newTokenController) external;\n}\n"}, "src/interfaces/IMessageTransmitterV2.sol": {"content": "// Copyright (c) 2025 Stable Technologies Inc\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at https://mozilla.org/MPL/2.0/.\n\npragma solidity ^0.8.30;\n\ninterface IMessageTransmitterV2 {\n  function localDomain() external view returns (uint32);\n}\n"}, "lib/wormhole-solidity-sdk/src/interfaces/cctp/shared/IPausable.sol": {"content": "// SPDX-License-Identifier: Apache 2\n// Copyright (c) 2022, Circle Internet Financial Limited.\n//\n// stripped version of:\n//   https://github.com/circlefin/evm-cctp-contracts/blob/master/src/roles/Pausable.sol\n\npragma solidity ^0.8.30;\n\ninterface IPausable {\n  event Pause();\n  event Unpause();\n  event PauserChanged(address indexed newAddress);\n\n  function paused() external view returns (bool);\n  function pauser() external view returns (address);\n\n  function pause() external;\n  function unpause() external;\n  function updatePauser(address newPauser) external;\n}\n"}}, "settings": {"remappings": ["forge-std/=lib/forge-std/src/", "permit2/=lib/permit2/src/", "IERC20/=lib/wormhole-solidity-sdk/src/interfaces/token/", "wormhole-sdk/=lib/wormhole-solidity-sdk/src/", "price-oracle/=../../price-oracle/evm/src/", "cctpr/=src/", "SafeERC20/=lib/wormhole-solidity-sdk/src/libraries/", "ds-test/=lib/permit2/lib/forge-std/lib/ds-test/src/", "forge-gas-snapshot/=lib/permit2/lib/forge-gas-snapshot/src/", "openzeppelin-contracts/=lib/permit2/lib/openzeppelin-contracts/", "solmate/=lib/permit2/lib/solmate/", "wormhole-solidity-sdk/=lib/wormhole-solidity-sdk/src/"], "optimizer": {"enabled": false, "runs": 200}, "metadata": {"appendCBOR": false}, "outputSelection": {"*": {"*": ["abi", "metadata", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers", "evm.legacyAssembly", "evm.bytecode.opcodes"]}}, "evmVersion": "paris", "viaIR": true, "libraries": {}}}