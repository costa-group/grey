{"language": "Solidity", "sources": {"src/ERC6909Launcher.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ncontract ERC6909Launcher {\n    // ERC6909 state variables\n    mapping(uint256 => string) public name;\n    mapping(uint256 => string) public symbol;\n    mapping(uint256 => string) public tokenURI;\n    mapping(uint256 => string) public description;\n    mapping(uint256 => string) public websiteUri;\n    mapping(uint256 => string) public telegramUri;\n    mapping(uint256 => string) public twitterUri;\n    mapping(uint256 => uint256) public totalSupply;\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    mapping(address => mapping(address => mapping(uint256 => uint256))) private _allowances;\n\n    // Launcher state variables\n    uint256 private _currentTokenId = 1; // Incremental ID counter\n\n    // Constants\n    uint256 public constant FIXED_SUPPLY = 210_000_000 * 10**18;\n    uint256 public constant BPS_DENOMINATOR = 10000;\n    uint256 public constant CURVE_PRECISION = 1e18;\n    uint256 public constant MAX_PROTOCOL_FEE_BPS = 100; // 1% cap\n\n    // Anti-sniper protection constants\n    uint256 public constant MAX_WALLET_PERCENTAGE = 200; // 2% in basis points\n    uint256 public constant MAX_WALLET_DURATION = 60; // 60 seconds\n    uint256 public constant CREATOR_MAX_PREBUY_PERCENTAGE = 500; // 5% in basis points\n\n    // Security bounds\n    uint256 public constant MIN_VIRTUAL_RESERVE = 1e15; // 0.001 ETH minimum\n    uint256 public constant MAX_VIRTUAL_RESERVE = 1e25; // Maximum reserve\n    uint256 public constant MAX_TRADE_AMOUNT = 1000 ether; // Maximum single trade\n    uint256 public constant MAX_CREATOR_TOKENS_GLOBAL = 1000; // Maximum 1000 tokens per creator\n\n    // Custom single-side bonding curve parameters\n    uint256 public constant INITIAL_VIRTUAL_ETH = 0; // Start with 0 ETH virtual reserve\n    uint256 public constant INITIAL_VIRTUAL_TOKENS = FIXED_SUPPLY; // All tokens in virtual pool initially\n\n    // Market cap parameters (ETH based)\n    uint256 public constant STARTING_MCAP_ETH = 2.6 ether; \n\n    // Protocol fee configuration\n    uint256 public protocolFeeBps = 30; // 0.3% initial fee\n    address public feeRecipient1;\n    address public feeRecipient2;\n    address public owner;\n\n    // Token configuration\n    struct TokenConfig {\n        uint256 virtualEthReserve;\n        uint256 virtualTokenReserve;\n        uint256 realEthReserve;\n        uint256 circulatingSupply;\n        uint256 createdAt;\n        address creator;\n        bool isActive;\n        uint256 accumulatedVolume;\n        // Anti-sniper protection\n        uint256 maxWalletUntil;\n        uint256 maxWalletAmount;\n    }\n\n    // Enhanced metadata structure\n    struct TokenMetadata {\n        uint256 tokenId;\n        string name;\n        string symbol;\n        string description;\n        string imageUri;\n        string websiteUri;\n        string telegramUri;\n        string twitterUri;\n        address creator;\n        uint256 createdAt;\n        uint256 marketCap;\n        uint256 volume24h;\n        uint256 holders;\n        uint256 circulatingSupply;\n        uint256 priceEth;\n        uint256 priceUsd;\n        bool maxWalletActive;\n        uint256 maxWalletAmount;\n        uint256 maxWalletEndsAt;\n    }\n\n    // State mappings\n    mapping(uint256 => TokenConfig) public tokenConfigs;\n    mapping(uint256 => bool) public tokenExists;\n    mapping(uint256 => mapping(address => bool)) public holders;\n    mapping(uint256 => uint256) public holderCounts;\n    mapping(uint256 => uint256) public volume24h;\n    mapping(uint256 => uint256) public lastVolumeUpdate;\n    mapping(address => uint256) public creatorTokenCount;\n    mapping(address => uint256) public creatorTotalPreBuy; // Track total pre-buy per creator\n\n    // Governance\n    uint256 public constant GOVERNANCE_DELAY = 2 days; // 2 day timelock for admin changes\n    mapping(bytes32 => uint256) public timelockProposals; // proposal hash => execution time\n\n    // Fee distribution with reentrancy protection\n    bool private _feeDistributionLocked;\n\n    // Accumulated fees for failed distributions\n    uint256 public pendingFees;\n\n    // Arrays for enumeration\n    uint256[] public allTokenIds;\n    mapping(address => uint256[]) public creatorTokens;\n\n    // Fee collection\n    uint256 public totalFeesCollected;\n\n    // Reentrancy protection\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n\n    // Accounting tolerance\n    uint256 public constant ACCOUNTING_TOLERANCE = 1e6; // Small fixed tolerance for rounding\n\n    // ERC6909 events\n    event Transfer(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 amount);\n    event OperatorSet(address indexed owner, address indexed operator, bool approved);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id, uint256 amount);\n\n    // Launcher events\n    event TokenCreated(\n        uint256 indexed tokenId,\n        address indexed creator,\n        string name,\n        string symbol,\n        string description,\n        string imageUri,\n        uint256 timestamp,\n        uint256 virtualEthReserve,\n        uint256 virtualTokenReserve,\n        bool creatorPreBuy,\n        uint256 creatorTokens\n    );\n\n    event TokenTrade(\n        uint256 indexed tokenId,\n        address indexed trader,\n        bool indexed isBuy,\n        uint256 ethAmount,\n        uint256 tokenAmount,\n        uint256 fee,\n        uint256 priceAfter,\n        uint256 marketCap,\n        uint256 timestamp\n    );\n\n    event MaxWalletUpdated(\n        uint256 indexed tokenId,\n        bool isActive,\n        uint256 maxWalletAmount,\n        uint256 endsAt\n    );\n\n    event AntiSniperTriggered(\n        uint256 indexed tokenId,\n        address indexed trader,\n        uint256 attemptedAmount,\n        uint256 maxAllowed\n    );\n\n    event CreatorPreBuy(\n        uint256 indexed tokenId,\n        address indexed creator,\n        uint256 ethAmount,\n        uint256 tokenAmount\n    );\n\n    event HolderUpdate(\n        uint256 indexed tokenId,\n        address indexed holder,\n        bool isNewHolder,\n        uint256 balance,\n        uint256 totalHolders\n    );\n\n    event VolumeUpdate(\n        uint256 indexed tokenId,\n        uint256 volume24h,\n        uint256 timestamp\n    );\n\n    event MetadataUpdate(\n        uint256 indexed tokenId,\n        string websiteUri,\n        string telegramUri,\n        string twitterUri\n    );\n\n    event FeeCollected(\n        uint256 indexed tokenId,\n        uint256 feeAmount,\n        uint256 totalFees\n    );\n\n    event ProtocolFeeUpdated(\n        uint256 oldFeeBps,\n        uint256 newFeeBps\n    );\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    event FeeRecipientUpdated(\n        address indexed oldRecipient,\n        address indexed newRecipient,\n        bool isFirstRecipient\n    );\n\n    event FeeDistributionFailed(\n        uint256 fee,\n        uint256 totalPendingFees\n    );\n\n    // Custom errors\n    error TokenNotFound();\n    error InsufficientETH();\n    error InsufficientTokens();\n    error InvalidParameters();\n    error Unauthorized();\n    error TransferFailed();\n    error ExcessiveSlippage();\n    error TradeAmountTooLarge();\n    error InvalidReserveRatio();\n    error AccountingError();\n    error ZeroAddress();\n    error MaxWalletExceeded();\n    error CreatorPreBuyTooLarge();\n    error CreatorPreBuyFailed();\n    error ExcessiveProtocolFee();\n    error PrecisionError();\n\n    modifier onlyOwner() {\n        if (msg.sender != owner) revert Unauthorized();\n        _;\n    }\n\n    modifier nonReentrant() {\n        if (_status == _ENTERED) revert();\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n\n    modifier accountingCheck(uint256 tokenId) {\n        _;\n        _verifyAccountingInvariant(tokenId);\n    }\n\n    constructor(address _feeRecipient1, address _feeRecipient2) {\n        if (_feeRecipient1 == address(0)) revert ZeroAddress();\n        if (_feeRecipient2 == address(0)) revert ZeroAddress();\n        owner = msg.sender;\n        feeRecipient1 = _feeRecipient1;\n        feeRecipient2 = _feeRecipient2;\n        _status = _NOT_ENTERED; // Initialize reentrancy protection\n    }\n\n    // ERC6909 functions\n    function balanceOf(address owner_, uint256 id) public view returns (uint256) {\n        return _balances[id][owner_];\n    }\n\n    function allowance(address owner_, address spender, uint256 id) public view returns (uint256) {\n        return _allowances[owner_][spender][id];\n    }\n\n    function isOperator(address owner_, address operator) public view returns (bool) {\n        if (operator == address(this)) return true;\n        return _operatorApprovals[owner_][operator];\n    }\n\n    function setOperator(address operator, bool approved) public returns (bool) {\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit OperatorSet(msg.sender, operator, approved);\n        return true;\n    }\n\n    function approve(address spender, uint256 id, uint256 amount) public returns (bool) {\n        _allowances[msg.sender][spender][id] = amount;\n        emit Approval(msg.sender, spender, id, amount);\n        return true;\n    }\n\n    function transfer(address to, uint256 id, uint256 amount) public returns (bool) {\n        return _transfer(msg.sender, to, id, amount);\n    }\n\n    function transferFrom(address from, address to, uint256 id, uint256 amount) public returns (bool) {\n        if (msg.sender != from && !_operatorApprovals[from][msg.sender]) {\n            uint256 allowed = _allowances[from][msg.sender][id];\n            if (allowed != type(uint256).max) {\n                if (allowed < amount) revert InsufficientTokens();\n                _allowances[from][msg.sender][id] = allowed - amount;\n            }\n        }\n        return _transfer(from, to, id, amount);\n    }\n\n    function _transfer(address from, address to, uint256 id, uint256 amount) internal returns (bool) {\n        if (from == address(0)) revert ZeroAddress();\n        if (to == address(0)) revert ZeroAddress();\n\n        uint256 fromBalance = _balances[id][from];\n        if (fromBalance < amount) revert InsufficientTokens();\n\n        // Use unchecked for gas optimization since we've already checked\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n\n        emit Transfer(msg.sender, from, to, id, amount);\n        return true;\n    }\n\n    function _mint(address to, uint256 id, uint256 amount) internal {\n        if (to == address(0)) revert ZeroAddress();\n\n        unchecked {\n            totalSupply[id] += amount;\n            _balances[id][to] += amount;\n        }\n\n        emit Transfer(msg.sender, address(0), to, id, amount);\n    }\n\n    /**\n     * @notice Create a new token with optimal bonding curve and anti-sniper protection\n     * @param name_ Token name\n     * @param symbol_ Token symbol\n     * @param description_ Token description\n     * @param imageUri Token image URI\n     * @param websiteUri_ Token website URL\n     * @param telegramUri_ Token telegram URL\n     * @param twitterUri_ Token twitter URL\n     * @param creatorPreBuy Whether creator wants to pre-buy tokens\n     * @return tokenId The created token ID\n     */\n    function createToken(\n        string calldata name_,\n        string calldata symbol_,\n        string calldata description_,\n        string calldata imageUri,\n        string calldata websiteUri_,\n        string calldata telegramUri_,\n        string calldata twitterUri_,\n        bool creatorPreBuy\n    ) external payable returns (uint256 tokenId) {\n        // Use incremental ID generation\n        tokenId = _currentTokenId++;\n\n        // Validate creator pre-buy if requested\n        uint256 creatorTokenAmount = 0;\n        if (creatorPreBuy) {\n            if (msg.value == 0) revert CreatorPreBuyFailed();\n\n            // Check global creator limits\n            if (creatorTokenCount[msg.sender] >= MAX_CREATOR_TOKENS_GLOBAL) {\n                revert CreatorPreBuyTooLarge();\n            }\n\n            // Calculate fee first, then tokens based on net ETH\n            uint256 fee = _calculateFee(msg.value);\n            uint256 ethAfterFee = msg.value - fee;\n\n            // Calculate maximum 5% of supply in tokens\n            uint256 maxPreBuyTokens = (FIXED_SUPPLY * CREATOR_MAX_PREBUY_PERCENTAGE) / BPS_DENOMINATOR;\n\n            // Calculate tokens out based on net ETH after fee\n            creatorTokenAmount = _calculateTokensOutForReserves(INITIAL_VIRTUAL_ETH, INITIAL_VIRTUAL_TOKENS, ethAfterFee);\n\n            if (creatorTokenAmount > maxPreBuyTokens) {\n                revert CreatorPreBuyTooLarge();\n            }\n\n            // Check global pre-buy limit per creator\n            if (creatorTotalPreBuy[msg.sender] + creatorTokenAmount > maxPreBuyTokens) {\n                revert CreatorPreBuyTooLarge();\n            }\n        }\n\n        // Initialize token metadata\n        name[tokenId] = name_;\n        symbol[tokenId] = symbol_;\n        tokenURI[tokenId] = imageUri;\n        description[tokenId] = description_;\n        websiteUri[tokenId] = websiteUri_;\n        telegramUri[tokenId] = telegramUri_;\n        twitterUri[tokenId] = twitterUri_;\n\n        // Mint total supply to this contract\n        _mint(address(this), tokenId, FIXED_SUPPLY);\n\n        // Calculate max wallet amount (2% of supply)\n        uint256 maxWalletAmount = (FIXED_SUPPLY * MAX_WALLET_PERCENTAGE) / BPS_DENOMINATOR;\n\n        // Initialize token configuration with custom single-side curve\n        tokenConfigs[tokenId] = TokenConfig({\n            virtualEthReserve: INITIAL_VIRTUAL_ETH, // Start with 0 ETH\n            virtualTokenReserve: INITIAL_VIRTUAL_TOKENS, // All tokens initially\n            realEthReserve: 0,\n            circulatingSupply: 0,\n            createdAt: block.timestamp,\n            creator: msg.sender,\n            isActive: true,\n            accumulatedVolume: 0,\n            maxWalletUntil: block.timestamp + MAX_WALLET_DURATION,\n            maxWalletAmount: maxWalletAmount\n        });\n\n        tokenExists[tokenId] = true;\n        allTokenIds.push(tokenId);\n        creatorTokens[msg.sender].push(tokenId);\n        creatorTokenCount[msg.sender]++;\n\n        // Emit max wallet event\n        emit MaxWalletUpdated(\n            tokenId,\n            true,\n            maxWalletAmount,\n            block.timestamp + MAX_WALLET_DURATION\n        );\n\n        // Handle creator pre-buy if requested\n        if (creatorPreBuy && creatorTokenAmount > 0) {\n            _executeCreatorPreBuy(tokenId, creatorTokenAmount);\n        }\n\n        emit TokenCreated(\n            tokenId,\n            msg.sender,\n            name_,\n            symbol_,\n            description_,\n            imageUri,\n            block.timestamp,\n            INITIAL_VIRTUAL_ETH, // 0 ETH initially\n            INITIAL_VIRTUAL_TOKENS, // All tokens initially\n            creatorPreBuy,\n            creatorTokenAmount\n        );\n    }\n\n    /**\n     * @notice Buy tokens with anti-sniper protection\n     */\n    function buyTokens(uint256 tokenId, uint256 minTokensOut) \n        external \n        payable \n        nonReentrant\n        accountingCheck(tokenId)\n        returns (uint256 tokensOut) \n    {\n        if (!tokenExists[tokenId]) revert TokenNotFound();\n        if (msg.value == 0) revert InsufficientETH();\n        if (msg.value > MAX_TRADE_AMOUNT) revert TradeAmountTooLarge();\n\n        TokenConfig storage config = tokenConfigs[tokenId];\n\n        // Calculate fee\n        uint256 fee = _calculateFee(msg.value);\n        uint256 ethIn = msg.value - fee;\n\n        // Calculate tokens out with precision handling\n        tokensOut = _calculateTokensOutSecure(tokenId, ethIn);\n\n        if (tokensOut < minTokensOut) revert ExcessiveSlippage();\n        if (tokensOut > (FIXED_SUPPLY - config.circulatingSupply)) {\n            revert InsufficientTokens();\n        }\n\n        // Check anti-sniper protection\n        _checkMaxWalletLimit(tokenId, msg.sender, tokensOut);\n\n        // Update state\n        _updateStateForBuy(tokenId, ethIn, tokensOut, fee);\n\n        // Transfer tokens to buyer\n        bool success = _transfer(address(this), msg.sender, tokenId, tokensOut);\n        if (!success) revert TransferFailed();\n\n        // Update tracking\n        _updateHolder(tokenId, msg.sender);\n        _updateVolume(tokenId, msg.value); // Use gross amount for consistency\n\n        // Update fee accounting (state changes before external calls)\n        if (fee > 0) {\n            pendingFees += fee;\n            totalFeesCollected += fee;\n        }\n\n        // Attempt to distribute fees\n        if (fee > 0) {\n            _distributeFees(fee);\n        }\n\n\n        // Calculate and emit trade event\n        uint256 priceAfter = getCurrentPrice(tokenId);\n        uint256 marketCap = (priceAfter * config.circulatingSupply) / CURVE_PRECISION;\n\n        emit TokenTrade(\n            tokenId,\n            msg.sender,\n            true,\n            ethIn,\n            tokensOut,\n            fee,\n            priceAfter,\n            marketCap,\n            block.timestamp\n        );\n\n        emit FeeCollected(tokenId, fee, totalFeesCollected);\n    }\n\n    /**\n     * @notice Sell tokens with enhanced precision handling\n     */\n    function sellTokens(uint256 tokenId, uint256 tokenAmount, uint256 minEthOut) \n        external \n        nonReentrant\n        accountingCheck(tokenId)\n        returns (uint256 ethOut) \n    {\n        if (!tokenExists[tokenId]) revert TokenNotFound();\n        if (tokenAmount == 0) revert InsufficientTokens();\n\n        TokenConfig storage config = tokenConfigs[tokenId];\n\n        // Enhanced balance check with precision handling\n        uint256 userBalance = _balances[tokenId][msg.sender];\n        if (userBalance < tokenAmount) revert InsufficientTokens();\n\n        // Enhanced full balance sale precision handling\n        if (tokenAmount == userBalance && userBalance > 0) {\n            uint256 testEthOut = _calculateEthOutSecure(tokenId, tokenAmount);\n            if (testEthOut > config.realEthReserve) {\n                // Calculate exact sellable amount based on available ETH\n                uint256 maxSellableTokens = _calculateMaxSellableTokens(tokenId, config.realEthReserve);\n                if (maxSellableTokens < tokenAmount) {\n                    tokenAmount = maxSellableTokens;\n                }\n            }\n        }\n\n        // Calculate ETH out\n        uint256 ethOutGross = _calculateEthOutSecure(tokenId, tokenAmount);\n        uint256 fee = _calculateFee(ethOutGross);\n        ethOut = ethOutGross - fee;\n\n        if (ethOut < minEthOut) revert ExcessiveSlippage();\n\n        // Strict accounting checks without tolerance\n        if (ethOut > config.realEthReserve) revert InsufficientETH();\n\n        // Balance check - only trade fees are deducted from available balance\n        uint256 availableBalance = address(this).balance - pendingFees;\n        if (ethOut > availableBalance) {\n            revert AccountingError();\n        }\n\n        // Transfer tokens first\n        bool success = _transfer(msg.sender, address(this), tokenId, tokenAmount);\n        if (!success) revert TransferFailed();\n\n        // Update state\n        _updateStateForSell(tokenId, ethOutGross, tokenAmount);\n\n        // Update tracking\n        _updateHolder(tokenId, msg.sender);\n        _updateVolume(tokenId, ethOutGross); // Use gross amount for consistency\n\n        // Update fee accounting first (state changes before external calls)\n        if (fee > 0) {\n            pendingFees += fee;\n            totalFeesCollected += fee;\n        }\n\n        // Send ETH to seller\n        (bool ethSuccess,) = msg.sender.call{value: ethOut}(\"\");\n        if (!ethSuccess) revert TransferFailed();\n\n        // Attempt to distribute fees AFTER main operation\n        if (fee > 0) {\n            _distributeFees(fee);\n        }\n\n\n        // Calculate and emit events\n        uint256 priceAfter = getCurrentPrice(tokenId);\n        uint256 marketCap = (priceAfter * config.circulatingSupply) / CURVE_PRECISION;\n\n        emit TokenTrade(\n            tokenId,\n            msg.sender,\n            false,\n            ethOutGross,\n            tokenAmount,\n            fee,\n            priceAfter,\n            marketCap,\n            block.timestamp\n        );\n\n        emit FeeCollected(tokenId, fee, totalFeesCollected);\n    }\n\n    /**\n     * @notice Check anti-sniper max wallet protection\n     */\n    function _checkMaxWalletLimit(uint256 tokenId, address buyer, uint256 tokenAmount) internal {\n        TokenConfig storage config = tokenConfigs[tokenId];\n\n        if (block.timestamp <= config.maxWalletUntil) {\n            uint256 currentBalance = _balances[tokenId][buyer];\n            uint256 newBalance = currentBalance + tokenAmount;\n\n            if (newBalance > config.maxWalletAmount) {\n                emit AntiSniperTriggered(tokenId, buyer, newBalance, config.maxWalletAmount);\n                revert MaxWalletExceeded();\n            }\n        } else {\n            // Disable max wallet protection\n            if (config.maxWalletUntil != 0) {\n                config.maxWalletUntil = 0;\n                emit MaxWalletUpdated(tokenId, false, 0, 0);\n            }\n        }\n    }\n\n    /**\n     * @notice Execute creator pre-buy during token creation\n     */\n    function _executeCreatorPreBuy(uint256 tokenId, uint256 creatorTokenAmount) internal {\n        TokenConfig storage config = tokenConfigs[tokenId];\n\n        // Calculate fee consistently with the token amount calculation\n        uint256 fee = _calculateFee(msg.value);\n        uint256 ethIn = msg.value - fee;\n\n        // Verify the token amount matches the ETH after fee\n        uint256 expectedTokenAmount = _calculateTokensOutForReserves(INITIAL_VIRTUAL_ETH, INITIAL_VIRTUAL_TOKENS, ethIn);\n        if (creatorTokenAmount != expectedTokenAmount) {\n            revert CreatorPreBuyFailed();\n        }\n\n        // Update state for creator pre-buy\n        config.virtualEthReserve += ethIn;\n        config.virtualTokenReserve -= creatorTokenAmount;\n        config.realEthReserve += ethIn;\n        config.circulatingSupply += creatorTokenAmount;\n        config.accumulatedVolume += msg.value;\n\n        // Transfer tokens to creator\n        bool success = _transfer(address(this), msg.sender, tokenId, creatorTokenAmount);\n        if (!success) revert CreatorPreBuyFailed();\n\n        // Update holder tracking\n        _updateHolder(tokenId, msg.sender);\n        _updateVolume(tokenId, msg.value);\n\n        // Update fee accounting (state changes before external calls)\n        if (fee > 0) {\n            pendingFees += fee;\n            totalFeesCollected += fee;\n        }\n\n        // Update global creator pre-buy tracking\n        creatorTotalPreBuy[msg.sender] += creatorTokenAmount;\n\n        // Attempt to distribute fees\n        if (fee > 0) {\n            _distributeFees(fee);\n        }\n\n        emit CreatorPreBuy(tokenId, msg.sender, ethIn, creatorTokenAmount);\n        emit FeeCollected(tokenId, fee, totalFeesCollected);\n    }\n\n    /**\n     * @notice Calculate tokens out using consistent constant product curve\n     * @dev Fixed curve that ensures proper initial market cap of 6-8k\n     */\n    function _calculateTokensOutForReserves(\n        uint256 virtualEthReserve,\n        uint256 virtualTokenReserve,\n        uint256 ethIn\n    ) internal pure returns (uint256 tokensOut) {\n        if (ethIn == 0) return 0;\n\n        // Use consistent constant product curve: x * y = k\n        // For initial market cap of 6-8k with 2.6 ETH starting mcap\n        uint256 baseVirtualEth = STARTING_MCAP_ETH; // 2.6 ETH virtual base\n        uint256 totalEthReserve = virtualEthReserve + baseVirtualEth;\n\n        // Overflow protection\n        if (totalEthReserve > type(uint256).max - ethIn) {\n            revert InvalidParameters();\n        }\n        if (ethIn > type(uint256).max / virtualTokenReserve) {\n            revert InvalidParameters();\n        }\n\n        // Division by zero protection\n        uint256 newEthReserve = totalEthReserve + ethIn;\n        if (newEthReserve == 0) {\n            revert InvalidParameters();\n        }\n\n        // Constant product formula: tokensOut = (virtualTokenReserve * ethIn) / (totalEthReserve + ethIn)\n        uint256 k = totalEthReserve * virtualTokenReserve;\n        uint256 newTokenReserve = k / newEthReserve;\n\n        // Protect against underflow\n        if (newTokenReserve > virtualTokenReserve) {\n            revert InvalidParameters();\n        }\n\n        tokensOut = virtualTokenReserve - newTokenReserve;\n\n        if (tokensOut > virtualTokenReserve) {\n            revert InvalidParameters();\n        }\n    }\n\n    /**\n     * @notice Enhanced bonding curve calculation with overflow protection\n     */\n    function _calculateTokensOutSecure(uint256 tokenId, uint256 ethIn) \n        internal \n        view \n        returns (uint256 tokensOut) \n    {\n        TokenConfig storage config = tokenConfigs[tokenId];\n        return _calculateTokensOutForReserves(config.virtualEthReserve, config.virtualTokenReserve, ethIn);\n    }\n\n    /**\n     * @notice Enhanced ETH out calculation with consistent constant product curve\n     */\n    function _calculateEthOutSecure(uint256 tokenId, uint256 tokenIn) \n        internal \n        view \n        returns (uint256 ethOut) \n    {\n        TokenConfig storage config = tokenConfigs[tokenId];\n\n        if (tokenIn == 0) return 0;\n\n        // Use consistent constant product curve for selling\n        uint256 baseVirtualEth = STARTING_MCAP_ETH; // 2.6 ETH virtual base\n        uint256 totalEthReserve = config.virtualEthReserve + baseVirtualEth;\n\n        // Overflow protection\n        if (config.virtualTokenReserve > type(uint256).max - tokenIn) {\n            revert InvalidParameters();\n        }\n        if (tokenIn > type(uint256).max / totalEthReserve) {\n            revert InvalidParameters();\n        }\n\n        // Division by zero protection\n        uint256 newTokenReserve = config.virtualTokenReserve + tokenIn;\n        if (newTokenReserve == 0) {\n            revert InvalidParameters();\n        }\n\n        // Constant product formula: ethOut = (totalEthReserve * tokenIn) / (virtualTokenReserve + tokenIn)\n        uint256 k = totalEthReserve * config.virtualTokenReserve;\n        uint256 newEthReserve = k / newTokenReserve;\n\n        // Protect against underflow\n        if (newEthReserve > totalEthReserve) {\n            revert InvalidParameters();\n        }\n\n        ethOut = totalEthReserve - newEthReserve;\n\n        // Ensure we don't return more ETH than available\n        if (ethOut > totalEthReserve) {\n            revert InvalidParameters();\n        }\n\n        // Most importantly: limit to real ETH reserve that was actually paid in\n        if (config.realEthReserve > 0 && ethOut > config.realEthReserve) {\n            ethOut = config.realEthReserve;\n        }\n    }\n\n    /**\n     * @notice Calculate fee with overflow protection\n     */\n    function _calculateFee(uint256 amount) internal view returns (uint256) {\n        if (amount == 0) return 0;\n        if (amount > type(uint256).max / protocolFeeBps) {\n            revert InvalidParameters();\n        }\n        if (BPS_DENOMINATOR == 0) {\n            revert InvalidParameters();\n        }\n        return (amount * protocolFeeBps) / BPS_DENOMINATOR;\n    }\n\n    /**\n     * @notice Calculate maximum sellable tokens for given ETH amount\n     */\n    function _calculateMaxSellableTokens(uint256 tokenId, uint256 maxEthOut) internal view returns (uint256) {\n        TokenConfig storage config = tokenConfigs[tokenId];\n        if (maxEthOut == 0 || config.virtualTokenReserve == 0) return 0;\n\n        uint256 baseVirtualEth = STARTING_MCAP_ETH;\n        uint256 totalEthReserve = config.virtualEthReserve + baseVirtualEth;\n\n        // Solve for tokenIn using constant product curve\n        // maxEthOut = (totalEthReserve * tokenIn) / (virtualTokenReserve + tokenIn)\n        // Rearranging: tokenIn = (maxEthOut * virtualTokenReserve) / (totalEthReserve - maxEthOut)\n        if (totalEthReserve <= maxEthOut) {\n            return config.circulatingSupply; // Can sell all circulating tokens\n        }\n\n        // Overflow protection\n        if (maxEthOut > type(uint256).max / config.virtualTokenReserve) {\n            return config.circulatingSupply;\n        }\n\n        // Division by zero protection\n        if (totalEthReserve <= maxEthOut) {\n            return config.circulatingSupply;\n        }\n\n        uint256 numerator = maxEthOut * config.virtualTokenReserve;\n        uint256 denominator = totalEthReserve - maxEthOut;\n\n        // Additional check to prevent division by zero\n        if (denominator == 0) {\n            return config.circulatingSupply;\n        }\n\n        return numerator / denominator;\n    }\n\n    /**\n     * @notice Distribute fees equally between two recipients with true atomic execution\n     */\n    function _distributeFees(uint256 fee) internal {\n        if (fee == 0) return;\n        if (_feeDistributionLocked) return;\n\n        _feeDistributionLocked = true;\n\n        // Split fee equally between two recipients\n        uint256 fee1 = fee / 2;\n        uint256 fee2 = fee - fee1; // Handles odd amounts by giving remainder to recipient2\n\n        // Note: Contract balance is checked for availability before transfers\n\n        // Attempt both transfers\n        (bool feeSuccess1,) = feeRecipient1.call{value: fee1}(\"\");\n        (bool feeSuccess2,) = feeRecipient2.call{value: fee2}(\"\");\n\n        // If both transfers succeeded, deduct from pending\n        if (feeSuccess1 && feeSuccess2) {\n            pendingFees -= fee;\n        } else {\n            // If either failed, emit event but do not revert\n            emit FeeDistributionFailed(fee, pendingFees);\n        }\n\n        _feeDistributionLocked = false;\n    }\n\n    /**\n     * @notice Update state for buy operations\n     */\n    function _updateStateForBuy(\n        uint256 tokenId, \n        uint256 ethIn, \n        uint256 tokensOut, \n        uint256 fee\n    ) internal {\n        TokenConfig storage config = tokenConfigs[tokenId];\n\n        // Check for overflow\n        if (config.virtualEthReserve > type(uint256).max - ethIn) {\n            revert InvalidParameters();\n        }\n        if (config.circulatingSupply > type(uint256).max - tokensOut) {\n            revert InvalidParameters();\n        }\n        if (config.realEthReserve > type(uint256).max - ethIn) {\n            revert InvalidParameters();\n        }\n\n        // Update reserves and supply\n        config.virtualEthReserve += ethIn;\n        config.virtualTokenReserve -= tokensOut;\n        config.realEthReserve += ethIn;\n        config.circulatingSupply += tokensOut;\n        config.accumulatedVolume += ethIn + fee;\n\n        // Accounting invariant verification is now handled at the end of trade functions\n    }\n\n    /**\n     * @notice Update state for sell operations\n     */\n    function _updateStateForSell(\n        uint256 tokenId, \n        uint256 ethOutGross, \n        uint256 tokenAmount\n    ) internal {\n        TokenConfig storage config = tokenConfigs[tokenId];\n\n        // Strict state checks without tolerance\n        if (config.virtualEthReserve < ethOutGross) {\n            revert InvalidParameters();\n        }\n        if (config.circulatingSupply < tokenAmount) {\n            revert InvalidParameters();\n        }\n        if (config.realEthReserve < ethOutGross) {\n            revert InsufficientETH();\n        }\n\n        // Update reserves and supply\n        config.virtualEthReserve -= ethOutGross;\n        config.virtualTokenReserve += tokenAmount;\n        config.realEthReserve -= ethOutGross;\n        config.circulatingSupply -= tokenAmount;\n        config.accumulatedVolume += ethOutGross;\n    }\n\n\n    /**\n     * @notice Verify accounting invariants with improved precision tolerance\n     */\n    function _verifyAccountingInvariant(uint256 tokenId) internal view {\n        TokenConfig storage config = tokenConfigs[tokenId];\n\n        // Calculate available balance for trading (contract balance minus pending fees)\n        uint256 availableBalance;\n\n        if (address(this).balance >= pendingFees) {\n            availableBalance = address(this).balance - pendingFees;\n        } else {\n            // If pendingFees > contract balance, available balance is 0\n            availableBalance = 0;\n        }\n\n        // Allow small fixed tolerance for rounding\n        if (config.realEthReserve > availableBalance + ACCOUNTING_TOLERANCE) {\n            revert AccountingError();\n        }\n\n        // Circulating supply should not exceed total supply\n        if (config.circulatingSupply > FIXED_SUPPLY) {\n            revert AccountingError();\n        }\n\n        // Virtual token reserve should not be zero (would break price calculations)\n        if (config.virtualTokenReserve == 0) {\n            revert AccountingError();\n        }\n    }\n\n    /**\n     * @notice Get current token price in ETH using consistent constant product curve\n     */\n    function getCurrentPrice(uint256 tokenId) public view returns (uint256 price) {\n        if (!tokenExists[tokenId]) revert TokenNotFound();\n        TokenConfig storage config = tokenConfigs[tokenId];\n\n        if (config.virtualTokenReserve == 0) return 0;\n\n        // Consistent price calculation using constant product curve\n        uint256 baseVirtualEth = STARTING_MCAP_ETH; // 2.6 ETH virtual base\n        uint256 totalEthReserve = config.virtualEthReserve + baseVirtualEth;\n\n        // Division by zero protection\n        if (config.virtualTokenReserve == 0) {\n            revert InvalidParameters();\n        }\n\n        // Overflow protection in price calculation\n        if (totalEthReserve > type(uint256).max / CURVE_PRECISION) {\n            // Use scaled calculation for very large reserves\n            uint256 scaledTokenReserve = config.virtualTokenReserve / 1e18;\n            if (scaledTokenReserve == 0) {\n                revert InvalidParameters();\n            }\n            price = (totalEthReserve / 1e9) * (CURVE_PRECISION / 1e9) / scaledTokenReserve;\n        } else {\n            price = (totalEthReserve * CURVE_PRECISION) / config.virtualTokenReserve;\n        }\n    }\n\n    /**\n     * @notice Get current market cap in ETH - consistent with pricing logic\n     * @dev Uses same pricing logic as getCurrentPrice for consistency\n     */\n    function getCurrentMarketCap(uint256 tokenId) public view returns (uint256 marketCap) {\n        if (!tokenExists[tokenId]) revert TokenNotFound();\n\n        // Use consistent pricing logic to calculate market cap\n        uint256 price = getCurrentPrice(tokenId);\n\n        // Market cap = price per token * total supply\n        // Use safe math to prevent overflow\n        if (price > type(uint256).max / FIXED_SUPPLY) {\n            // Use scaled calculation for very high prices\n            marketCap = (price / 1e9) * (FIXED_SUPPLY / 1e9);\n        } else {\n            marketCap = (price * FIXED_SUPPLY) / CURVE_PRECISION;\n        }\n    }\n\n    /**\n     * @notice Get starting price per token in ETH\n     */\n    function getStartingPrice() public pure returns (uint256) {\n        return STARTING_MCAP_ETH / FIXED_SUPPLY;\n    }\n\n    /**\n     * @notice Calculate tokens out (public interface)\n     */\n    function calculateTokensOut(uint256 tokenId, uint256 ethIn) \n        public \n        view \n        returns (uint256 tokensOut) \n    {\n        if (!tokenExists[tokenId]) revert TokenNotFound();\n        return _calculateTokensOutSecure(tokenId, ethIn);\n    }\n\n    /**\n     * @notice Calculate ETH out (public interface)\n     */\n    function calculateEthOut(uint256 tokenId, uint256 tokenIn) \n        public \n        view \n        returns (uint256 ethOut) \n    {\n        if (!tokenExists[tokenId]) revert TokenNotFound();\n        return _calculateEthOutSecure(tokenId, tokenIn);\n    }\n\n    /**\n     * @notice Check if max wallet protection is active\n     */\n    function isMaxWalletActive(uint256 tokenId) public view returns (bool active, uint256 maxAmount, uint256 endsAt) {\n        if (!tokenExists[tokenId]) revert TokenNotFound();\n        TokenConfig storage config = tokenConfigs[tokenId];\n\n        active = block.timestamp <= config.maxWalletUntil;\n        maxAmount = active ? config.maxWalletAmount : 0;\n        endsAt = config.maxWalletUntil;\n    }\n\n    /**\n     * @notice Get comprehensive token metadata\n     */\n    function getTokenMetadata(uint256 tokenId) \n        external \n        view \n        returns (TokenMetadata memory metadata) \n    {\n        if (!tokenExists[tokenId]) revert TokenNotFound();\n\n        TokenConfig storage config = tokenConfigs[tokenId];\n        uint256 currentPrice = getCurrentPrice(tokenId);\n        (bool maxWalletActive, uint256 maxWalletAmount, uint256 maxWalletEndsAt) = isMaxWalletActive(tokenId);\n\n        metadata = TokenMetadata({\n            tokenId: tokenId,\n            name: name[tokenId],\n            symbol: symbol[tokenId],\n            description: description[tokenId],\n            imageUri: tokenURI[tokenId],\n            websiteUri: websiteUri[tokenId],\n            telegramUri: telegramUri[tokenId],\n            twitterUri: twitterUri[tokenId],\n            creator: config.creator,\n            createdAt: config.createdAt,\n            marketCap: getCurrentMarketCap(tokenId),\n            volume24h: volume24h[tokenId],\n            holders: holderCounts[tokenId],\n            circulatingSupply: config.circulatingSupply,\n            priceEth: currentPrice,\n            priceUsd: 0,\n            maxWalletActive: maxWalletActive,\n            maxWalletAmount: maxWalletAmount,\n            maxWalletEndsAt: maxWalletEndsAt\n        });\n    }\n\n    /**\n     * @notice Propose protocol fee change (only owner)\n     */\n    function proposeProtocolFee(uint256 newFeeBps) external onlyOwner {\n        if (newFeeBps > MAX_PROTOCOL_FEE_BPS) revert ExcessiveProtocolFee();\n\n        bytes32 proposalHash = keccak256(abi.encode(\"setProtocolFee\", newFeeBps));\n        timelockProposals[proposalHash] = block.timestamp + GOVERNANCE_DELAY;\n    }\n\n    /**\n     * @notice Execute protocol fee change after timelock\n     */\n    function executeProtocolFeeChange(uint256 newFeeBps) external onlyOwner {\n        if (newFeeBps > MAX_PROTOCOL_FEE_BPS) revert ExcessiveProtocolFee();\n\n        bytes32 proposalHash = keccak256(abi.encode(\"setProtocolFee\", newFeeBps));\n        uint256 executeTime = timelockProposals[proposalHash];\n\n        if (executeTime == 0 || block.timestamp < executeTime) {\n            revert Unauthorized();\n        }\n\n        uint256 oldFeeBps = protocolFeeBps;\n        protocolFeeBps = newFeeBps;\n\n        delete timelockProposals[proposalHash];\n        emit ProtocolFeeUpdated(oldFeeBps, newFeeBps);\n    }\n\n    /**\n     * @notice Propose fee recipient change (only owner)\n     */\n    function proposeFeeRecipientChange(address newFeeRecipient1, address newFeeRecipient2) external onlyOwner {\n        if (newFeeRecipient1 == address(0)) revert ZeroAddress();\n        if (newFeeRecipient2 == address(0)) revert ZeroAddress();\n\n        bytes32 proposalHash = keccak256(abi.encode(\"setFeeRecipients\", newFeeRecipient1, newFeeRecipient2));\n        timelockProposals[proposalHash] = block.timestamp + GOVERNANCE_DELAY;\n    }\n\n    /**\n     * @notice Execute fee recipient change after timelock\n     */\n    function executeFeeRecipientChange(address newFeeRecipient1, address newFeeRecipient2) external onlyOwner {\n        if (newFeeRecipient1 == address(0)) revert ZeroAddress();\n        if (newFeeRecipient2 == address(0)) revert ZeroAddress();\n\n        bytes32 proposalHash = keccak256(abi.encode(\"setFeeRecipients\", newFeeRecipient1, newFeeRecipient2));\n        uint256 executeTime = timelockProposals[proposalHash];\n\n        if (executeTime == 0 || block.timestamp < executeTime) {\n            revert Unauthorized();\n        }\n\n        address oldRecipient1 = feeRecipient1;\n        address oldRecipient2 = feeRecipient2;\n\n        feeRecipient1 = newFeeRecipient1;\n        feeRecipient2 = newFeeRecipient2;\n\n        delete timelockProposals[proposalHash];\n        emit FeeRecipientUpdated(oldRecipient1, newFeeRecipient1, true);\n        emit FeeRecipientUpdated(oldRecipient2, newFeeRecipient2, false);\n    }\n\n    /**\n     * @notice Propose ownership transfer (only owner)\n     */\n    function proposeOwnershipTransfer(address newOwner) external onlyOwner {\n        if (newOwner == address(0)) revert ZeroAddress();\n\n        bytes32 proposalHash = keccak256(abi.encode(\"transferOwnership\", newOwner));\n        timelockProposals[proposalHash] = block.timestamp + GOVERNANCE_DELAY;\n    }\n\n    /**\n     * @notice Execute ownership transfer after timelock\n     */\n    function executeOwnershipTransfer(address newOwner) external onlyOwner {\n        if (newOwner == address(0)) revert ZeroAddress();\n\n        bytes32 proposalHash = keccak256(abi.encode(\"transferOwnership\", newOwner));\n        uint256 executeTime = timelockProposals[proposalHash];\n\n        if (executeTime == 0 || block.timestamp < executeTime) {\n            revert Unauthorized();\n        }\n\n        address previousOwner = owner;\n        owner = newOwner;\n\n        delete timelockProposals[proposalHash];\n        emit OwnershipTransferred(previousOwner, newOwner);\n    }\n\n    /**\n     * @notice Retry failed fee distributions (only owner)\n     */\n    function retryFeeDistribution() external onlyOwner {\n        uint256 feesToDistribute = pendingFees;\n        if (feesToDistribute == 0) return;\n\n        // Attempt to distribute pending fees\n        _distributeFees(feesToDistribute);\n    }\n\n    /**\n     * @notice Update metadata (only creator)\n     */\n    function updateMetadata(\n        uint256 tokenId,\n        string calldata websiteUri_,\n        string calldata telegramUri_,\n        string calldata twitterUri_\n    ) external {\n        if (!tokenExists[tokenId]) revert TokenNotFound();\n        if (tokenConfigs[tokenId].creator != msg.sender) revert Unauthorized();\n\n        // Actually store the metadata\n        websiteUri[tokenId] = websiteUri_;\n        telegramUri[tokenId] = telegramUri_;\n        twitterUri[tokenId] = twitterUri_;\n\n        emit MetadataUpdate(tokenId, websiteUri_, telegramUri_, twitterUri_);\n    }\n\n    // Helper functions for tracking\n    function _updateHolder(uint256 tokenId, address holder) internal {\n        uint256 balance = _balances[tokenId][holder];\n        bool wasHolder = holders[tokenId][holder];\n        bool isHolder = balance > 0;\n\n        if (!wasHolder && isHolder) {\n            holders[tokenId][holder] = true;\n            holderCounts[tokenId]++;\n            emit HolderUpdate(tokenId, holder, true, balance, holderCounts[tokenId]);\n        } else if (wasHolder && !isHolder) {\n            holders[tokenId][holder] = false;\n            if (holderCounts[tokenId] > 0) {\n                holderCounts[tokenId]--;\n            }\n            emit HolderUpdate(tokenId, holder, false, balance, holderCounts[tokenId]);\n        }\n    }\n\n    function _updateVolume(uint256 tokenId, uint256 ethAmount) internal {\n        uint256 currentTime = block.timestamp;\n        uint256 lastUpdate = lastVolumeUpdate[tokenId];\n\n        if (currentTime > lastUpdate + 24 hours) {\n            volume24h[tokenId] = ethAmount;\n        } else {\n            // Proper overflow protection\n            if (volume24h[tokenId] > type(uint256).max - ethAmount) {\n                volume24h[tokenId] = type(uint256).max; // Cap at maximum\n            } else {\n                volume24h[tokenId] += ethAmount;\n            }\n        }\n\n        lastVolumeUpdate[tokenId] = currentTime;\n        emit VolumeUpdate(tokenId, volume24h[tokenId], currentTime);\n    }\n\n    // View functions\n    function getTotalTokens() external view returns (uint256) {\n        return allTokenIds.length;\n    }\n\n    function getTokensByCreator(address creator) external view returns (uint256[] memory) {\n        return creatorTokens[creator];\n    }\n\n    function getTokens(uint256 offset, uint256 limit) \n        external \n        view \n        returns (uint256[] memory tokenIds) \n    {\n        uint256 totalTokens = allTokenIds.length;\n        if (offset >= totalTokens) {\n            return new uint256[](0);\n        }\n\n        uint256 end = offset + limit;\n        if (end > totalTokens) {\n            end = totalTokens;\n        }\n\n        tokenIds = new uint256[](end - offset);\n        for (uint256 i = offset; i < end; i++) {\n            tokenIds[i - offset] = allTokenIds[i];\n        }\n    }\n\n    function getTokenConfig(uint256 tokenId) \n        external \n        view \n        returns (TokenConfig memory) \n    {\n        if (!tokenExists[tokenId]) revert TokenNotFound();\n        return tokenConfigs[tokenId];\n    }\n\n    function getCurrentTokenId() external view returns (uint256) {\n        return _currentTokenId;\n    }\n\n    function getProtocolFee() external view returns (uint256) {\n        return protocolFeeBps;\n    }\n}\n"}}, "settings": {"remappings": ["forge-std/=lib/forge-std/src/"], "optimizer": {"enabled": true, "runs": 200}, "metadata": {"appendCBOR": false}, "outputSelection": {"*": {"*": ["abi", "metadata", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers", "evm.legacyAssembly", "evm.bytecode.opcodes"]}}, "evmVersion": "cancun", "viaIR": true}}