{"language": "Solidity", "sources": {"src/lib/MetadataRenderer.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\nimport { MetadataLib } from \"./MetadataLib.sol\";\nimport { ResetPeriod } from \"../types/ResetPeriod.sol\";\nimport { Scope } from \"../types/Scope.sol\";\n\n/**\n * @title MetadataRenderer\n * @notice Deployed contract implementing functionality for deriving and displaying\n * ERC6909 metadata as well as metadata specific to various underlying tokens.\n */\ncontract MetadataRenderer {\n    using EfficiencyLib for uint256;\n    using MetadataLib for address;\n    using MetadataLib for uint256;\n\n    address public immutable theCompact;\n\n    constructor() {\n        theCompact = msg.sender;\n    }\n\n    /**\n     * @notice External view function for generating the URI for a resource lock's ERC6909\n     * token. The URI is derived from the lock's details and token identifier.\n     * @param id          The ERC6909 token identifier.\n     * @return            The generated URI string.\n     */\n    function uri(uint256 id) external view returns (string memory) {\n        (address token, address allocator, ResetPeriod resetPeriod, Scope scope) = id.toLockDetails(theCompact);\n        return token.toURI(allocator, resetPeriod, scope, id);\n    }\n\n    /**\n     * @notice External view function for generating the name of an ERC6909 token. Combines\n     * \"Compact\" with the underlying token's name, falling back to a default if needed.\n     * @param id The ERC6909 token identifier.\n     * @return   The generated name string.\n     */\n    function name(uint256 id) external view returns (string memory) {\n        return string.concat(\"Compact \", id.asSanitizedAddress().readNameWithDefaultValue());\n    }\n\n    /**\n     * @notice External view function for generating the symbol of an ERC6909 token. Combines\n     * a handshake emoji with the underlying token's symbol, falling back to a default if\n     * needed.\n     * @param id The ERC6909 token identifier.\n     * @return   The generated symbol string.\n     */\n    function symbol(uint256 id) external view returns (string memory) {\n        return string.concat(unicode\"\ud83e\udd1d-\", id.asSanitizedAddress().readSymbolWithDefaultValue());\n    }\n\n    /**\n     * @notice External view function for retrieving the decimals of an ERC6909 token.\n     * Returns the decimals of the underlying token, falling back to a default if needed.\n     * @param id The ERC6909 token identifier.\n     * @return   The number of decimals for the token.\n     */\n    function decimals(uint256 id) external view returns (uint8) {\n        return id.asSanitizedAddress().readDecimalsAsUint8WithDefaultValue();\n    }\n}\n"}, "src/lib/EfficiencyLib.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { Scope } from \"../types/Scope.sol\";\nimport { ResetPeriod } from \"../types/ResetPeriod.sol\";\n\n/**\n * @title EfficiencyLib\n * @notice Library contract implementing logic for efficient value comparisons,\n * conversions, typecasting, and sanitization. Also provides functions to prevent\n * the function specializer from being triggered when using static arguments.\n */\nlibrary EfficiencyLib {\n    /**\n     * @notice Internal view function to convert the provided account address to the caller if that\n     *         address is the null address (0x0).\n     * @dev    Uses bitwise operations to avoid branching, making this function more gas efficient\n     *         than using a traditional if-else statement. The implementation follows the pattern\n     *         `result = xor(a, mul(xor(a, b), condition))` which resolves to either a or b based\n     *         on the condition; as the condition in this case is contingent on the first argument\n     *         having a value of zero, the nested xor can safely be omitted.\n     * @param  account               The address to check and potentially replace.\n     * @return accountOrCallerIfNull The original address if non-zero, otherwise msg.sender.\n     */\n    function usingCallerIfNull(address account) internal view returns (address accountOrCallerIfNull) {\n        assembly (\"memory-safe\") {\n            accountOrCallerIfNull := xor(account, mul(caller(), iszero(account)))\n        }\n    }\n\n    /**\n     * @notice Internal pure function that performs a bitwise AND on two booleans.\n     * Avoids Solidity's conditional evaluation of logical AND. Only safe when\n     * inputs are known to be exactly 0 or 1 with no dirty bits.\n     * @param a  The first boolean value.\n     * @param b  The second boolean value.\n     * @return c The result of the bitwise AND.\n     */\n    function and(bool a, bool b) internal pure returns (bool c) {\n        assembly (\"memory-safe\") {\n            c := and(a, b)\n        }\n    }\n\n    /**\n     * @notice Internal pure function that performs a bitwise OR on two booleans.\n     * Avoids Solidity's conditional evaluation of logical OR. Only safe when\n     * inputs are known to be exactly 0 or 1 with no dirty bits.\n     * @param a  The first boolean value.\n     * @param b  The second boolean value.\n     * @return c The result of the bitwise OR.\n     */\n    function or(bool a, bool b) internal pure returns (bool c) {\n        assembly (\"memory-safe\") {\n            c := or(a, b)\n        }\n    }\n\n    /**\n     * @notice Internal pure function that sanitizes an address by clearing the\n     * upper 96 bits. Used for ensuring consistent address handling.\n     * @param accountValue The value to sanitize.\n     * @return account     The sanitized address.\n     */\n    function asSanitizedAddress(uint256 accountValue) internal pure returns (address account) {\n        assembly (\"memory-safe\") {\n            account := shr(96, shl(96, accountValue))\n        }\n    }\n\n    /**\n     * @notice Internal pure function that checks if an address has its lower 160\n     * bits set to zero.\n     * @param account The address to check.\n     * @return isNull Whether the address is null.\n     */\n    function isNullAddress(address account) internal pure returns (bool isNull) {\n        assembly (\"memory-safe\") {\n            isNull := iszero(shl(96, account))\n        }\n    }\n\n    /**\n     * @notice Internal pure function that converts a boolean to a uint256.\n     * @param a  The boolean to convert.\n     * @return b The resulting uint256.\n     */\n    function asUint256(bool a) internal pure returns (uint256 b) {\n        assembly (\"memory-safe\") {\n            b := a\n        }\n    }\n\n    /**\n     * @notice Internal pure function that converts a uint96 to a uint256.\n     * @param a  The uint96 to convert.\n     * @return b The resulting uint256.\n     */\n    function asUint256(uint96 a) internal pure returns (uint256 b) {\n        assembly (\"memory-safe\") {\n            b := a\n        }\n    }\n\n    /**\n     * @notice Internal pure function that converts a bytes12 to a uint256.\n     * @param a  The bytes12 to convert.\n     * @return b The resulting uint256.\n     */\n    function asUint256(bytes12 a) internal pure returns (uint256 b) {\n        assembly (\"memory-safe\") {\n            b := a\n        }\n    }\n\n    /**\n     * @notice Internal pure function that converts a Scope enum to a uint256.\n     * @param a  The Scope enum to convert.\n     * @return b The resulting uint256.\n     */\n    function asUint256(Scope a) internal pure returns (uint256 b) {\n        assembly (\"memory-safe\") {\n            b := a\n        }\n    }\n\n    /**\n     * @notice Internal pure function that converts an address to a uint256.\n     * @param a  The address to convert.\n     * @return b The resulting uint256.\n     */\n    function asUint256(address a) internal pure returns (uint256 b) {\n        assembly (\"memory-safe\") {\n            b := a\n        }\n    }\n\n    /**\n     * @notice Internal pure function that converts a ResetPeriod enum to a uint256.\n     * @param a  The ResetPeriod enum to convert.\n     * @return b The resulting uint256.\n     */\n    function asUint256(ResetPeriod a) internal pure returns (uint256 b) {\n        assembly (\"memory-safe\") {\n            b := a\n        }\n    }\n\n    /**\n     * @notice Internal pure function that prevents the function specializer from\n     * optimizing uint256 arguments. XORs the value with calldatasize(), which\n     * will always be non-zero in a real call.\n     * @param a  The uint256 value to make stubborn.\n     * @return b The original value, preventing specialization.\n     */\n    function asStubborn(uint256 a) internal pure returns (uint256 b) {\n        assembly (\"memory-safe\") {\n            b := or(iszero(calldatasize()), a)\n        }\n    }\n\n    /**\n     * @notice Internal pure function that prevents the function specializer from\n     * inlining functions that take fixed boolean arguments. Since calldatasize()\n     * will always be non-zero when making a standard function call, an OR\n     * against iszero(calldatasize()) will always result in the original value.\n     * @param a  The boolean value to make stubborn.\n     * @return b The original value, preventing specialization.\n     */\n    function asStubborn(bool a) internal pure returns (bool b) {\n        assembly (\"memory-safe\") {\n            b := or(iszero(calldatasize()), a)\n        }\n    }\n}\n"}, "src/lib/MetadataLib.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { ITheCompact } from \"../interfaces/ITheCompact.sol\";\nimport { ResetPeriod } from \"../types/ResetPeriod.sol\";\nimport { Scope } from \"../types/Scope.sol\";\nimport { IdLib } from \"./IdLib.sol\";\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\nimport { LibString } from \"solady/utils/LibString.sol\";\nimport { MetadataReaderLib } from \"solady/utils/MetadataReaderLib.sol\";\nimport { Base64 } from \"solady/utils/Base64.sol\";\n\n/**\n * @title MetadataLib\n * @notice Library contract implementing logic for deriving and displaying\n * ERC6909 metadata as well as metadata specific to various underlying tokens.\n */\nlibrary MetadataLib {\n    using EfficiencyLib for Scope;\n    using EfficiencyLib for ResetPeriod;\n    using EfficiencyLib for address;\n    using EfficiencyLib for uint96;\n    using IdLib for address;\n    using IdLib for uint96;\n    using LibString for string;\n    using LibString for address;\n    using LibString for uint256;\n    using LibString for uint96;\n    using MetadataReaderLib for address;\n    using MetadataLib for address;\n    using MetadataLib for ResetPeriod;\n    using MetadataLib for Scope;\n    using MetadataLib for Lock;\n\n    struct Lock {\n        address token;\n        address allocator;\n        ResetPeriod resetPeriod;\n        Scope scope;\n    }\n\n    /**\n     * @notice Internal pure function for converting a ResetPeriod enum to a human-readable string.\n     * @param resetPeriod The ResetPeriod enum value to convert.\n     * @return resetPeriodString A string representation of the reset period.\n     */\n    function toString(ResetPeriod resetPeriod) internal pure returns (string memory resetPeriodString) {\n        // Equivalent to:\n        // if (resetPeriod == ResetPeriod.OneSecond) {\n        //     return \"1s\";\n        // } else if (resetPeriod == ResetPeriod.FifteenSeconds) {\n        //     return \"15s\";\n        // } else if (resetPeriod == ResetPeriod.OneMinute) {\n        //     return \"1m\";\n        // } else if (resetPeriod == ResetPeriod.TenMinutes) {\n        //     return \"10m\";\n        // } else if (resetPeriod == ResetPeriod.OneHourAndFiveMinutes) {\n        //     return \"1h 5m\";\n        // } else if (resetPeriod == ResetPeriod.OneDay) {\n        //     return \"24h\";\n        // } else if (resetPeriod == ResetPeriod.SevenDaysAndOneHour) {\n        //     return \"7d 1h\";\n        // } else {\n        //     return \"30d\";\n        // }\n\n        bytes4 chunk;\n        uint256 length;\n        assembly (\"memory-safe\") {\n            chunk :=\n                shl(0xe0, shr(shl(5, resetPeriod), 0x3330640037643168323468003168356d31306d00316d00003135730031730000))\n            let lastByteIsZero := iszero(shl(0x18, chunk))\n            length := sub(5, add(shl(1, lastByteIsZero), iszero(shl(0x10, chunk))))\n            if iszero(lastByteIsZero) {\n                chunk :=\n                    xor(shl(0xe8, xor(and(0xffff00, shr(0xe8, chunk)), 0x20)), shl(0xd8, and(0xffff, shr(0xe0, chunk))))\n            }\n        }\n\n        resetPeriodString = new string(length);\n\n        assembly (\"memory-safe\") {\n            mstore(add(resetPeriodString, 0x20), chunk)\n        }\n    }\n\n    /**\n     * @notice Internal pure function for converting a Scope enum to a human-readable string.\n     * @param scope The Scope enum value to convert.\n     * @return A string representation of the scope.\n     */\n    function toString(Scope scope) internal pure returns (string memory) {\n        // Equivalent to:\n        // if (scope == Scope.Multichain) {\n        //     return \"Multichain\";\n        // } else {\n        //     return \"Chain-specific\";\n        // }\n\n        string memory scopeString = new string(14);\n        assembly (\"memory-safe\") {\n            mstore(\n                add(scopeString, 0x1f),\n                shl(\n                    add(0x88, shl(5, iszero(scope))),\n                    shr(mul(0x78, iszero(scope)), 0x0a4d756c7469636861696e0e436861696e2d7370656369666963)\n                )\n            )\n        }\n        return scopeString;\n    }\n\n    function toLockDetails(uint256 id, address theCompact)\n        internal\n        view\n        returns (address token, address allocator, ResetPeriod resetPeriod, Scope scope)\n    {\n        (token, allocator, resetPeriod, scope,) = ITheCompact(theCompact).getLockDetails(id);\n    }\n\n    /**\n     * @notice Internal view function for generating a token URI for a given lock and ID.\n     * @param token       The address of the underlying token (or address(0) for native tokens).\n     * @param allocator   The address of the allocator mediating the resource lock.\n     * @param resetPeriod The duration after which the underlying tokens can be withdrawn once a forced withdrawal is initiated.\n     * @param scope       The scope of the resource lock (multichain or single chain).\n     * @param id          The ERC6909 token identifier.\n     * @return uri A JSON string containing token metadata.\n     */\n    function toURI(address token, address allocator, ResetPeriod resetPeriod, Scope scope, uint256 id)\n        internal\n        view\n        returns (string memory uri)\n    {\n        Lock memory lock = Lock({ token: token, allocator: allocator, resetPeriod: resetPeriod, scope: scope });\n        string memory name = string.concat('{\"name\": \"Compact ', lock.token.readSymbolWithDefaultValue(), '\",');\n        string memory image;\n        {\n            // Generate dynamic SVG and Base64 encode it\n            string memory svg = _generateSvgImage(lock);\n            string memory encodedSvg = Base64.encode(bytes(svg));\n            image = string.concat('\"image\": \"data:image/svg+xml;base64,', encodedSvg, '\",');\n        }\n\n        uri = string.concat(name, _getDescription(lock), image, _getAttributes(lock, id));\n    }\n\n    /**\n     * @notice Internal view function for generating the attributes section of the token metadata.\n     * @param lock The lock.\n     * @param id The ERC6909 token identifier.\n     * @return attributes The attributes section of the token metadata.\n     */\n    function _getAttributes(Lock memory lock, uint256 id) internal view returns (string memory attributes) {\n        // Initialize the attributes string and add Token details\n        {\n            (\n                string memory tokenAddress,\n                string memory tokenName,\n                string memory tokenSymbol,\n                string memory tokenDecimals\n            ) = _getTokenDetails(lock);\n\n            attributes = string.concat(\n                '\"attributes\": [',\n                _makeAttribute(\"ID\", id.toHexString(), false, true),\n                _makeAttribute(\"Token Address\", tokenAddress, false, true),\n                _makeAttribute(\"Token Name\", tokenName, false, true),\n                _makeAttribute(\"Token Symbol\", tokenSymbol, false, true),\n                _makeAttribute(\"Token Decimals\", tokenDecimals, false, false)\n            );\n        }\n\n        // Allocator & Lock details, then close the JSON array and object\n        {\n            attributes = string.concat(\n                attributes,\n                _makeAttribute(\"Allocator Address\", lock.allocator.toHexStringChecksummed(), false, true),\n                _makeAttribute(\"Allocator Name\", _tryReadAllocatorName(lock.allocator), false, true),\n                _makeAttribute(\"Scope\", lock.scope.toString(), false, true),\n                _makeAttribute(\"Reset Period\", lock.resetPeriod.toString(), false, true),\n                _makeAttribute(\"Lock Tag\", uint96(lock.toLockTag()).toHexString(), false, true),\n                _makeAttribute(\"Origin Chain\", block.chainid.toString(), true, true),\n                \"]}\"\n            );\n        }\n    }\n\n    /**\n     * @notice Internal view function for generating the description section of the token metadata.\n     * @param lock The lock containing token, allocator, reset period, and scope information.\n     * @return description The description section of the token metadata as a JSON string.\n     */\n    function _getDescription(Lock memory lock) internal view returns (string memory description) {\n        (string memory tokenAddress, string memory tokenName,,) = _getTokenDetails(lock);\n        string memory allocatorName = _tryReadAllocatorName(lock.allocator);\n        string memory resetPeriod = lock.resetPeriod.toString();\n        string memory scope = lock.scope.toString();\n        description = string.concat(\n            '\"description\": \"[The Compact v1] ',\n            tokenName,\n            \" (\",\n            tokenAddress,\n            \") resource lock using \",\n            allocatorName,\n            \" (\",\n            lock.allocator.toHexStringChecksummed(),\n            \"), \",\n            scope,\n            \" scope, and a \",\n            resetPeriod,\n            ' reset period\",'\n        );\n    }\n\n    /**\n     * @notice Internal view function for retrieving token details.\n     * @param lock The lock containing the token address.\n     * @return tokenAddress The token's address as a checksummed hex string.\n     * @return tokenName The token's name or a default value if not available.\n     * @return tokenSymbol The token's symbol or a default value if not available.\n     * @return tokenDecimals The token's decimals as a string or a default value if not available.\n     */\n    function _getTokenDetails(Lock memory lock)\n        internal\n        view\n        returns (\n            string memory tokenAddress,\n            string memory tokenName,\n            string memory tokenSymbol,\n            string memory tokenDecimals\n        )\n    {\n        tokenAddress = lock.token.toHexStringChecksummed();\n        tokenName = lock.token.readNameWithDefaultValue();\n        tokenSymbol = lock.token.readSymbolWithDefaultValue();\n        tokenDecimals = uint256(lock.token.readDecimalsAsUint8WithDefaultValue()).toString();\n    }\n\n    /**\n     * @notice Internal view function to generate a dynamic SVG image for the token.\n     * @param lock The lock containing token, allocator, reset period, and scope information.\n     * @return A string containing the complete SVG image markup.\n     */\n    function _generateSvgImage(Lock memory lock) internal view returns (string memory) {\n        return string.concat(\n            '<svg width=\"500\" height=\"290\" viewBox=\"0 0 500 290\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">',\n            _getSvgDefs(lock),\n            _getSvgBackground(),\n            _getSvgBorder(),\n            _getSvgAnimatedText(lock),\n            _getSvgTitleSection(lock),\n            _getSvgDetailsSection(lock),\n            \"</svg>\"\n        );\n    }\n\n    /**\n     * @notice Dynamically generate a color scheme based on a given token address.\n     * @param token The address of the token to generate colors for.\n     * @return bgColor1 The first background color.\n     * @return bgColor2 The second background color.\n     * @return bgColor3 The third background color.\n     */\n    function _generateColors(address token) internal pure returns (string memory, string memory, string memory) {\n        bytes32 tokenHash = keccak256(abi.encodePacked(token));\n\n        string memory bgColor1 = LibString.toHexStringNoPrefix(uint24(bytes3(tokenHash)));\n        string memory bgColor2 =\n            LibString.toHexStringNoPrefix(uint24(bytes3(bytes32(uint256(uint256(tokenHash) >> 96)))));\n        string memory bgColor3 =\n            LibString.toHexStringNoPrefix(uint24(bytes3(bytes32(uint256(uint256(tokenHash) >> 192)))));\n\n        return (bgColor1, bgColor2, bgColor3);\n    }\n\n    /**\n     * @notice Returns the SVG definitions section with filters, gradients, and paths.\n     * @param lock The lock containing the token address used for color generation.\n     * @return A string containing the SVG definitions markup.\n     */\n    function _getSvgDefs(Lock memory lock) internal pure returns (string memory) {\n        (string memory bgColor1, string memory bgColor2, string memory bgColor3) = _generateColors(lock.token);\n\n        // Filter definitions for background generation (used to create the gradient effect)\n        string memory filterDefs = string.concat(\n            // feImage 1 (main background)\n            '<defs><filter id=\"f1\"><feImage result=\"p0\" xlink:href=\"data:image/svg+xml;base64,',\n            Base64.encode(\n                bytes(\n                    string.concat(\n                        '<svg width=\"500\" height=\"290\" viewBox=\"0 0 500 290\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"500px\" height=\"290px\" fill=\"#',\n                        bgColor1,\n                        '\"/></svg>'\n                    )\n                )\n            ),\n            // feImage 2 (first circle overlay)\n            '\"/><feImage result=\"p1\" xlink:href=\"data:image/svg+xml;base64,',\n            Base64.encode(\n                bytes(\n                    string.concat(\n                        '<svg width=\"500\" height=\"290\" viewBox=\"0 0 500 290\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"400\" cy=\"100\" r=\"150px\" fill=\"#',\n                        bgColor2,\n                        '\"/></svg>'\n                    )\n                )\n            ),\n            // feImage 3 (second circle overlay)\n            '\"/><feImage result=\"p2\" xlink:href=\"data:image/svg+xml;base64,',\n            Base64.encode(\n                bytes(\n                    string.concat(\n                        '<svg width=\"500\" height=\"290\" viewBox=\"0 0 500 290\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"120\" cy=\"200\" r=\"120px\" fill=\"#',\n                        bgColor3,\n                        '\"/></svg>'\n                    )\n                )\n            ),\n            // Blending directives (enhances the gradient effect), Blur filter (makes the gradient smoother), Drop shadow filter (makes the text more readable)\n            '\"/><feBlend mode=\"overlay\" in=\"p0\" in2=\"p1\" /><feBlend mode=\"exclusion\" in2=\"p2\" /><feGaussianBlur stdDeviation=\"42\" /></filter><filter id=\"tb\"><feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"24\" /></filter><filter id=\"ts\" x=\"-20%\" y=\"-20%\" width=\"140%\" height=\"140%\"><feDropShadow dx=\"0\" dy=\"0\" stdDeviation=\"1\" flood-opacity=\"0.8\" flood-color=\"black\" /></filter>'\n        );\n\n        return filterDefs.concat(\n            // Outer clip path (clips the entire SVG), Path for the animated text (creates a looped animation), & Gradient mask for the title text (fades out towards the right edge of the canvas)\n            '<clipPath id=\"c\"><rect width=\"500\" height=\"290\" rx=\"42\" ry=\"42\" /></clipPath><path id=\"tp\" d=\"M40 12 H460 A28 28 0 0 1 488 40 V250 A28 28 0 0 1 460 278 H40 A28 28 0 0 1 12 250 V40 A28 28 0 0 1 40 12 z\" /><linearGradient id=\"gs\" x1=\"0\" y1=\"0\" x2=\"1\" y2=\"0\"><stop offset=\"0.7\" stop-color=\"white\" stop-opacity=\"1\" /><stop offset=\".95\" stop-color=\"white\" stop-opacity=\"0\" /></linearGradient><mask id=\"fs\" maskContentUnits=\"userSpaceOnUse\"><rect width=\"440px\" height=\"200px\" fill=\"url(#gs)\" /></mask></defs>'\n        );\n    }\n\n    /**\n     * @notice Returns the SVG background section with gradient and filter effects.\n     * @return A string containing the SVG background markup.\n     */\n    function _getSvgBackground() internal pure returns (string memory) {\n        return\n        '<g clip-path=\"url(#c)\"><rect fill=\"none\" x=\"0px\" y=\"0px\" width=\"500px\" height=\"290px\" /><rect style=\"filter: url(#f1)\" x=\"0px\" y=\"0px\" width=\"500px\" height=\"290px\" /><g style=\"filter:url(#tb); transform:scale(1.5); transform-origin:left top;\"><rect fill=\"none\" x=\"0px\" y=\"0px\" width=\"500px\" height=\"290px\" /><ellipse cx=\"25%\" cy=\"0px\" rx=\"180px\" ry=\"120px\" fill=\"#000\" opacity=\"0.85\" /></g></g>';\n    }\n\n    /**\n     * @notice Returns the SVG border elements that frame the token image.\n     * @return A string containing the SVG border markup.\n     */\n    function _getSvgBorder() internal pure returns (string memory) {\n        return\n        '<rect x=\"0\" y=\"0\" width=\"500\" height=\"290\" rx=\"42\" ry=\"42\" fill=\"rgba(0,0,0,0)\" stroke=\"rgba(255,255,255,0.2)\" /><rect x=\"16\" y=\"16\" width=\"468\" height=\"258\" rx=\"26\" ry=\"26\" fill=\"rgba(0,0,0,0)\" stroke=\"rgba(255,255,255,0.2)\" />';\n    }\n\n    /**\n     * @notice Returns the SVG animated text that moves along the border.\n     * @return The SVG animated text.\n     */\n    function _getSvgAnimatedText(Lock memory lock) internal view returns (string memory) {\n        (string memory tokenAddress, string memory tokenName, string memory tokenSymbol,) = _getTokenDetails(lock);\n        string memory middot = unicode\" \u2022 \";\n        string memory token = string.concat(\n            tokenName,\n            middot,\n            tokenSymbol,\n            middot,\n            tokenAddress,\n            middot,\n            \"Lock Tag \",\n            uint96(toLockTag(lock)).toHexString()\n        );\n        string memory allocator = string.concat(\n            \"The Compact v1\",\n            middot,\n            lock.scope.toString(),\n            \" Resource Lock\",\n            middot,\n            _tryReadAllocatorName(lock.allocator),\n            \" @ \",\n            lock.allocator.toHexStringChecksummed()\n        );\n\n        // Paths are duplicated to create a looped animation\n        return string.concat(\n            '<text text-rendering=\"optimizeSpeed\" filter=\"url(#ts)\">',\n            _getTextPath(token, \"-100%\"),\n            _getTextPath(token, \"0%\"),\n            _getTextPath(allocator, \"50%\"),\n            _getTextPath(allocator, \"-50%\"),\n            \"</text>\"\n        );\n    }\n\n    /**\n     * @notice Builds a textPath element that moves along the border.\n     * @param text The text to display.\n     * @param startOffset The starting offset of the text.\n     * @return The SVG animated text.\n     */\n    function _getTextPath(string memory text, string memory startOffset) internal pure returns (string memory) {\n        return string.concat(\n            '<textPath startOffset=\"',\n            startOffset,\n            '\" fill=\"white\" font-family=\"monospace\" font-size=\"10px\" xlink:href=\"#tp\">',\n            text,\n            '<animate additive=\"sum\" attributeName=\"startOffset\" from=\"0%\" to=\"100%\" begin=\"0s\" dur=\"30s\" repeatCount=\"indefinite\" /></textPath>'\n        );\n    }\n\n    /**\n     * @notice Returns the SVG title section.\n     * @param lock The lock.\n     * @return The SVG title section.\n     */\n    function _getSvgTitleSection(Lock memory lock) internal view returns (string memory) {\n        (,, string memory tokenSymbol,) = _getTokenDetails(lock);\n        string memory scope = lock.scope.toString();\n        string memory lockId = lock.toId().toHexString();\n        return string.concat(\n            '<g id=\"title\"><text y=\"60px\" x=\"32px\" fill=\"white\" font-family=\"monospace\" font-weight=\"100\" font-size=\"32px\" filter=\"url(#ts)\">Compact ',\n            tokenSymbol,\n            '</text><text y=\"90px\" x=\"32px\" fill=\"rgba(255,255,255,0.6)\" font-family=\"monospace\" font-weight=\"50\" font-size=\"22px\" filter=\"url(#ts)\">',\n            scope,\n            ' Resource Lock</text><text y=\"110px\" x=\"32px\" fill=\"rgba(255,255,255,0.6)\" font-family=\"monospace\" font-weight=\"100\" font-size=\"10px\" filter=\"url(#ts)\">ID: ',\n            lockId,\n            \"</text></g>\"\n        );\n    }\n\n    /**\n     * @notice Returns the SVG details section\n     * @dev This section contains the details of the lock, including the token, allocator, and reset period.\n     * @param lock The lock.\n     * @return The SVG details section.\n     */\n    function _getSvgDetailsSection(Lock memory lock) internal view returns (string memory) {\n        (, string memory tokenName, string memory tokenSymbol,) = _getTokenDetails(lock);\n        string memory allocatorName = _tryReadAllocatorName(lock.allocator);\n        string memory resetPeriod = lock.resetPeriod.toString();\n        string memory scope = lock.scope.toString();\n        // Handshake Icon\n        string memory iconSvg =\n            unicode'<g style=\"transform:translate(420px, 50px)\"><text x=\"20px\" y=\"28px\" text-anchor=\"middle\" font-size=\"64px\" opacity=\"0.4\">\ud83e\udd1d';\n\n        // Detail Boxes\n        string memory detailBoxesSvg = string.concat(\n            // Left column & Locked Token\n            '</text></g><g style=\"transform:translate(32px, 140px)\"><rect width=\"200px\" height=\"64px\" rx=\"8px\" ry=\"8px\" fill=\"rgba(0,0,0,0.6)\" /><text x=\"12px\" y=\"17px\" font-family=\"monospace\" font-size=\"12px\" fill=\"rgba(255,255,255,0.6)\">Locked Token: </text>',\n            _makeWrappable(string.concat(tokenName, \" (\", tokenSymbol, \")\"), \"190px\", \"40px\"),\n            // Reset Period\n            '</g><g style=\"transform:translate(32px, 212px)\"><rect width=\"200px\" height=\"26px\" rx=\"8px\" ry=\"8px\" fill=\"rgba(0,0,0,0.6)\" /><text x=\"12px\" y=\"17px\" font-family=\"monospace\" font-size=\"12px\" fill=\"white\"><tspan fill=\"rgba(255,255,255,0.6)\">Reset Period: </tspan>',\n            resetPeriod,\n            // Right column & Allocator\n            '</text></g><g style=\"transform:translate(260px, 140px)\"><rect width=\"210px\" height=\"64px\" rx=\"8px\" ry=\"8px\" fill=\"rgba(0,0,0,0.6)\" /><text x=\"12px\" y=\"17px\" font-family=\"monospace\" font-size=\"12px\" fill=\"rgba(255,255,255,0.6)\">Allocator: </text>',\n            _makeWrappable(allocatorName, \"190px\", \"40px\"),\n            // Resource lock tag\n            '</g><g style=\"transform:translate(260px, 212px)\"><rect width=\"210px\" height=\"26px\" rx=\"8px\" ry=\"8px\" fill=\"rgba(0,0,0,0.6)\" /><text x=\"12px\" y=\"17px\" font-family=\"monospace\" font-size=\"12px\" fill=\"white\"><tspan fill=\"rgba(255,255,255,0.6)\">Scope: </tspan>',\n            scope,\n            // Bottom row (Origin Chain)\n            '</text></g><g><text x=\"50%\" y=\"260px\" font-family=\"monospace\" font-size=\"12px\" fill=\"white\" text-anchor=\"middle\" filter=\"url(#ts)\"><tspan fill=\"rgba(255,255,255,0.6)\">Origin Chain: </tspan>',\n            LibString.toString(block.chainid),\n            \"</text></g>\"\n        );\n\n        return iconSvg.concat(detailBoxesSvg);\n    }\n\n    /**\n     * @notice Internal pure function for formatting a metadata attribute as a JSON string.\n     * @param trait      The trait name.\n     * @param value      The trait value.\n     * @param terminal   Whether this is the last attribute in the list.\n     * @param quoted     Whether the value should be quoted.\n     * @return attribute The formatted attribute string.\n     */\n    function _makeAttribute(string memory trait, string memory value, bool terminal, bool quoted)\n        internal\n        pure\n        returns (string memory attribute)\n    {\n        string memory maybeQuote = quoted ? '\"' : \"\";\n        string memory terminator = terminal ? \"}\" : \"},\";\n        attribute = string.concat('{\"trait_type\": \"', trait, '\", \"value\": ', maybeQuote, value, maybeQuote, terminator);\n    }\n\n    /**\n     * @notice Wraps text in a foreignObject element to allow for text wrapping.\n     * @param text The text to wrap.\n     * @param width The width of the foreignObject.\n     * @param height The height of the foreignObject.\n     * @return The wrapped text.\n     */\n    function _makeWrappable(string memory text, string memory width, string memory height)\n        internal\n        pure\n        returns (string memory)\n    {\n        return string.concat(\n            '<foreignObject x=\"12px\" y=\"22px\" width=\"',\n            width,\n            '\" height=\"',\n            height,\n            '\"><span xmlns=\"http://www.w3.org/1999/xhtml\" style=\"font-family: monospace;font-size: 14px;color: white;\">',\n            text,\n            \"</span></foreignObject>\"\n        );\n    }\n\n    /**\n     * @notice Try to read the name from the allocator contract.\n     * @param allocatorAddress The address of the allocator.\n     * @return The name of the allocator or \"Unnamed Allocator\" if not readable.\n     */\n    function _tryReadAllocatorName(address allocatorAddress) internal view returns (string memory) {\n        string memory name = allocatorAddress.readName();\n        if (bytes(name).length == 0) {\n            name = \"Unnamed Allocator\";\n        }\n        return name;\n    }\n\n    /**\n     * @notice Internal view function for retrieving a token's name with a fallback value.\n     * @param token The address of the token.\n     * @return name The token's name or a default value if not available.\n     */\n    function readNameWithDefaultValue(address token) internal view returns (string memory name) {\n        // Use \"Native Token\" as the default name for address(0). Note that this will not be the\n        // correct name on some chains.\n        if (token == address(0)) {\n            return \"Native Token\";\n        }\n\n        name = token.readName().escapeJSON();\n        if (bytes(name).length == 0) {\n            name = \"Unknown Token\";\n        }\n    }\n\n    /**\n     * @notice Internal view function for retrieving a token's symbol with a fallback value.\n     * @param token   The address of the token.\n     * @return symbol The token's symbol or a default value if not available.\n     */\n    function readSymbolWithDefaultValue(address token) internal view returns (string memory symbol) {\n        // Use \"ETH\" as the default symbol for address(0). Note that this will not be the\n        // correct symbol on some chains.\n        if (token.isNullAddress()) {\n            return \"ETH\";\n        }\n\n        symbol = token.readSymbol().escapeJSON();\n        if (bytes(symbol).length == 0) {\n            symbol = \"???\";\n        }\n    }\n\n    /**\n     * @notice Internal view function for retrieving a token's decimals as a uint8 with a fallback value.\n     * @param token     The address of the token.\n     * @return decimals The token's decimals as a uint8 or a default value if not available.\n     */\n    function readDecimalsAsUint8WithDefaultValue(address token) internal view returns (uint8 decimals) {\n        if (token.isNullAddress()) {\n            return 18;\n        }\n        decimals = token.readDecimals();\n    }\n\n    /**\n     * @notice Internal pure function for generating a lock tag from a lock.\n     * @param lock The lock.\n     * @return lockTag The lock tag.\n     */\n    function toLockTag(Lock memory lock) internal pure returns (bytes12) {\n        uint96 allocatorId = lock.allocator.toAllocatorId();\n        return allocatorId.toLockTag(lock.scope, lock.resetPeriod);\n    }\n\n    /**\n     * @notice Internal pure function for deriving a resource lock ID from lock details.\n     * @param lock The lock.\n     * @return id The ID.\n     */\n    function toId(Lock memory lock) internal pure returns (uint256 id) {\n        id = (\n            (lock.scope.asUint256() << 255) | (lock.resetPeriod.asUint256() << 252)\n                | (lock.allocator.toAllocatorId().asUint256() << 160) | lock.token.asUint256()\n        );\n    }\n}\n"}, "src/types/ResetPeriod.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nenum ResetPeriod {\n    OneSecond,\n    FifteenSeconds,\n    OneMinute,\n    TenMinutes,\n    OneHourAndFiveMinutes,\n    OneDay,\n    SevenDaysAndOneHour,\n    ThirtyDays\n}\n"}, "src/types/Scope.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nenum Scope {\n    Multichain,\n    ChainSpecific\n}\n"}, "src/interfaces/ITheCompact.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { ForcedWithdrawalStatus } from \"../types/ForcedWithdrawalStatus.sol\";\nimport { EmissaryStatus } from \"../types/EmissaryStatus.sol\";\nimport { ResetPeriod } from \"../types/ResetPeriod.sol\";\nimport { Scope } from \"../types/Scope.sol\";\nimport { CompactCategory } from \"../types/CompactCategory.sol\";\nimport { ISignatureTransfer } from \"permit2/src/interfaces/ISignatureTransfer.sol\";\nimport { AllocatedTransfer } from \"../types/Claims.sol\";\nimport { DepositDetails } from \"../types/DepositDetails.sol\";\nimport { AllocatedBatchTransfer } from \"../types/BatchClaims.sol\";\n\n/**\n * @title The Compact \u2014 Core Interface\n * @custom:version 1\n * @author 0age (0age.eth)\n * @custom:coauthor mgretzke (mgretzke.eth)\n * @custom:coauthor ccashwell (ccashwell.eth)\n * @custom:coauthor reednaa (reednaa.eth)\n * @custom:coauthor zeroknots (zeroknots.eth)\n * @custom:security-contact security@uniswap.org\n * @notice The Compact is an ownerless ERC6909 contract that facilitates the voluntary\n * formation and mediation of reusable \"resource locks.\" This interface contract specifies\n * external functions for making deposits, for performing allocated transfers and\n * withdrawals, for initiating and performing forced withdrawals, and for registering\n * compact claim hashes and typehashes directly. It also contains methods for registering\n * allocators and for enabling allocators to consume nonces directly. Finally, it specifies\n * a number of view functions, events and errors.\n */\ninterface ITheCompact {\n    /**\n     * @notice Event indicating that a claim has been processed for a given compact.\n     * @param sponsor   The account sponsoring the claimed compact.\n     * @param allocator The account mediating the resource locks utilized by the claim.\n     * @param arbiter   The account verifying and initiating the settlement of the claim.\n     * @param claimHash A bytes32 hash derived from the details of the claimed compact.\n     * @param nonce     The nonce (scoped to the allocator) on the claimed compact.\n     */\n    event Claim(\n        address indexed sponsor, address indexed allocator, address indexed arbiter, bytes32 claimHash, uint256 nonce\n    );\n\n    /**\n     * @notice Event indicating that a nonce has been consumed directly.\n     * @param allocator The account mediating the nonces.\n     * @param nonce     The nonce (scoped to the allocator) in question.\n     */\n    event NonceConsumedDirectly(address indexed allocator, uint256 nonce);\n\n    /**\n     * @notice Event indicating a change in forced withdrawal status.\n     * @param account        The account for which the withdrawal status has changed.\n     * @param id             The ERC6909 token identifier of the associated resource lock.\n     * @param activating     Whether the forced withdrawal is being activated or has been deactivated.\n     * @param withdrawableAt The timestamp when tokens become withdrawable if it is being activated.\n     */\n    event ForcedWithdrawalStatusUpdated(\n        address indexed account, uint256 indexed id, bool activating, uint256 withdrawableAt\n    );\n\n    /**\n     * @notice Event indicating that a compact has been registered directly.\n     * @param sponsor   The address registering the compact in question.\n     * @param claimHash A bytes32 hash derived from the details of the compact.\n     * @param typehash  The EIP-712 typehash associated with the registered compact.\n     */\n    event CompactRegistered(address indexed sponsor, bytes32 claimHash, bytes32 typehash);\n\n    /**\n     * @notice Event indicating that an emissary has been assigned for a given sponsor and lock tag.\n     * @param sponsor  The address for which the emissary has been assigned.\n     * @param lockTag  The lock tag for which the emissary has been assigned.\n     * @param emissary The account of the emissary that has been assigned.\n     */\n    event EmissaryAssigned(address indexed sponsor, bytes12 indexed lockTag, address indexed emissary);\n\n    /**\n     * @notice Event indicating that a new emissary assignment has been scheduled for a given sponsor\n     * and lock tag. Note that this is only required when a previous emissary has already been assigned\n     * for the given combination of sponsor and lock tag.\n     * @param sponsor      The address for which the emissary assignment has been scheduled.\n     * @param lockTag      The lock tag for which the emissary assignment has been scheduled.\n     * @param assignableAt The block timestamp at which a new emissary may be assigned.\n     */\n    event EmissaryAssignmentScheduled(address indexed sponsor, bytes12 indexed lockTag, uint256 assignableAt);\n\n    /**\n     * @notice Event indicating an allocator has been registered.\n     * @param allocatorId The unique identifier assigned to the allocator.\n     * @param allocator   The address of the registered allocator.\n     */\n    event AllocatorRegistered(uint96 allocatorId, address allocator);\n\n    /**\n     * @notice External payable function for depositing native tokens into a resource lock with\n     * custom reset period and scope parameters. The ERC6909 token amount received by the recipient\n     * will match the amount of native tokens sent with the transaction. Note that supplying the\n     * null address for the recipient will result in the caller being applied as the recipient.\n     * @param lockTag   The lock tag containing allocator ID, reset period, and scope.\n     * @param recipient The address that will receive the corresponding ERC6909 tokens.\n     * @return id       The ERC6909 token identifier of the associated resource lock.\n     */\n    function depositNative(bytes12 lockTag, address recipient) external payable returns (uint256 id);\n\n    /**\n     * @notice External function for depositing ERC20 tokens into a resource lock with custom reset\n     * period and scope parameters. The caller must directly approve The Compact to transfer a\n     * sufficient amount of the ERC20 token on its behalf. The ERC6909 token amount received by\n     * the recipient is derived from the difference between the starting and ending balance held\n     * in the resource lock, which may differ from the amount transferred depending on the\n     * implementation details of the respective token.  Note that supplying the null address for\n     * the recipient will result in the caller being applied as the recipient.\n     * @param token     The address of the ERC20 token to deposit.\n     * @param lockTag   The lock tag containing allocator ID, reset period, and scope.\n     * @param amount    The amount of tokens to deposit.\n     * @param recipient The address that will receive the corresponding ERC6909 tokens.\n     * @return id       The ERC6909 token identifier of the associated resource lock.\n     */\n    function depositERC20(address token, bytes12 lockTag, uint256 amount, address recipient)\n        external\n        returns (uint256 id);\n\n    /**\n     * @notice External payable function for depositing multiple tokens in a single transaction.\n     * The first entry in idsAndAmounts can optionally represent native tokens by providing the\n     * null address and an amount matching msg.value. For ERC20 tokens, the caller must directly\n     * approve The Compact to transfer sufficient amounts on its behalf. The ERC6909 token amounts\n     * received by the recipient are derived from the differences between starting and ending\n     * balances held in the resource locks, which may differ from the amounts transferred depending\n     * on the implementation details of the respective tokens.  Note that supplying the null\n     * address for the recipient will result in the caller being applied as the recipient.\n     * @param idsAndAmounts Array of [id, amount] pairs indicating resource locks & amounts to deposit.\n     * @param recipient     The address that will receive the corresponding ERC6909 tokens.\n     * @return              Whether the batch deposit was successfully completed.\n     */\n    function batchDeposit(uint256[2][] calldata idsAndAmounts, address recipient) external payable returns (bool);\n\n    /**\n     * @notice External function for depositing ERC20 tokens using Permit2 authorization. The\n     * depositor must approve Permit2 to transfer the tokens on its behalf unless the token in\n     * question automatically grants approval to Permit2. The ERC6909 token amount received by the\n     * recipient is derived from the difference between the starting and ending balance held\n     * in the resource lock, which may differ from the amount transferred depending on the\n     * implementation details of the respective token. The Permit2 authorization signed by the\n     * depositor must contain a CompactDeposit witness containing the allocator, the reset period,\n     * the scope, and the intended recipient of the deposit.\n     * @param permit    The permit data signed by the depositor.\n     * @param depositor The account signing the permit2 authorization and depositing the tokens.\n     * @param lockTag   The lock tag containing allocator ID, reset period, and scope.\n     * @param recipient The address that will receive the corresponding the ERC6909 tokens.\n     * @param signature The Permit2 signature from the depositor authorizing the deposit.\n     * @return id       The ERC6909 token identifier of the associated resource lock.\n     */\n    function depositERC20ViaPermit2(\n        ISignatureTransfer.PermitTransferFrom calldata permit,\n        address depositor,\n        bytes12 lockTag,\n        address recipient,\n        bytes calldata signature\n    ) external returns (uint256 id);\n\n    /**\n     * @notice External payable function for depositing multiple tokens using Permit2\n     * authorization in a single transaction. The first token id can optionally represent native\n     * tokens by providing the null address and an amount matching msg.value. The depositor must\n     * approve Permit2 to transfer the tokens on its behalf unless the tokens automatically\n     * grant approval to Permit2. The ERC6909 token amounts received by the recipient are derived\n     * from the differences between starting and ending balances held in the resource locks,\n     * which may differ from the amounts transferred depending on the implementation details of\n     * the respective tokens. The Permit2 authorization signed by the depositor must contain a\n     * CompactDeposit witness containing the allocator, the reset period, the scope, and the\n     * intended recipient of the deposits.\n     * @param depositor The account signing the permit2 authorization and depositing the tokens.\n     * @param permitted The permit data signed by the depositor.\n     * @param details   The details of the deposit.\n     * @param recipient The address that will receive the corresponding ERC6909 tokens.\n     * @param signature The Permit2 signature from the depositor authorizing the deposits.\n     * @return ids      Array of ERC6909 token identifiers for the associated resource locks.\n     */\n    function batchDepositViaPermit2(\n        address depositor,\n        ISignatureTransfer.TokenPermissions[] calldata permitted,\n        DepositDetails calldata details,\n        address recipient,\n        bytes calldata signature\n    ) external payable returns (uint256[] memory ids);\n\n    /**\n     * @notice Transfers or withdraws ERC6909 tokens to multiple recipients with allocator approval.\n     * @param transfer A Transfer struct containing the following:\n     *  -  allocatorData Authorization signature from the allocator.\n     *  -  nonce         Parameter enforcing replay protection, scoped to the allocator.\n     *  -  expires       Timestamp after which the transfer cannot be executed.\n     *  -  id            The ERC6909 token identifier of the resource lock.\n     *  -  recipients    A Component array, each containing:\n     *     -  claimant   The account that will receive tokens.\n     *     -  amount     The amount of tokens the claimant will receive.\n     * @return           Boolean indicating whether the transfer or withdrawal was successful.\n     */\n    function allocatedTransfer(AllocatedTransfer calldata transfer) external returns (bool);\n\n    /**\n     * @notice Transfers or withdraws ERC6909 tokens from multiple resource locks to multiple\n     *         recipients with allocator approval.\n     * @param transfer A BatchTransfer struct containing the following:\n     *  -  allocatorData  Authorization signature from the allocator.\n     *  -  nonce          Parameter enforcing replay protection, scoped to the allocator.\n     *  -  expires        Timestamp after which the transfer cannot be executed.\n     *  -  transfers      Array of ComponentsById, each containing:\n     *     -  id          The ERC6909 token identifier of the resource lock.\n     *     -  portions    A Component array, each containing:\n     *        -  claimant The account that will receive tokens.\n     *        -  amount   The amount of tokens the claimant will receive.\n     * @return            Boolean indicating whether the transfer was successful.\n     */\n    function allocatedBatchTransfer(AllocatedBatchTransfer calldata transfer) external returns (bool);\n\n    /**\n     * @notice External function to register a claim hash and its associated EIP-712 typehash.\n     * The registered claim hash will remain valid until the allocator consumes the nonce.\n     * @param claimHash A bytes32 hash derived from the details of the compact.\n     * @param typehash  The EIP-712 typehash associated with the registered claim hash.\n     * @return          Boolean indicating whether the claim hash was successfully registered.\n     */\n    function register(bytes32 claimHash, bytes32 typehash) external returns (bool);\n\n    /**\n     * @notice External function to register multiple claim hashes and their associated EIP-712\n     * typehashes in a single call. Each registered claim hash will remain valid until the allocator\n     * consumes the nonce.\n     * @param claimHashesAndTypehashes Array of [claimHash, typehash] pairs for registration.\n     * @return                         Boolean indicating whether all claim hashes were successfully registered.\n     */\n    function registerMultiple(bytes32[2][] calldata claimHashesAndTypehashes) external returns (bool);\n\n    /**\n     * @notice Register a claim on behalf of a sponsor with their signature.\n     * @param typehash         The EIP-712 typehash associated with the registered compact.\n     * @param arbiter          The account tasked with verifying and submitting the claim.\n     * @param sponsor          The address of the sponsor for whom the claim is being registered.\n     * @param nonce            A parameter to enforce replay protection, scoped to allocator.\n     * @param expires          The time at which the claim expires.\n     * @param lockTag          The lock tag containing allocator ID, reset period, and scope.\n     * @param token            The address of the token associated with the claim.\n     * @param amount           The amount of tokens associated with the claim.\n     * @param witness          Hash of the witness data.\n     * @param sponsorSignature The signature from the sponsor authorizing the registration.\n     * @return claimHash       Hash for verifying that the expected compact was registered.\n     */\n    function registerFor(\n        bytes32 typehash,\n        address arbiter,\n        address sponsor,\n        uint256 nonce,\n        uint256 expires,\n        bytes12 lockTag,\n        address token,\n        uint256 amount,\n        bytes32 witness,\n        bytes calldata sponsorSignature\n    ) external returns (bytes32 claimHash);\n\n    /**\n     * @notice Register a batch claim on behalf of a sponsor with their signature.\n     * @param typehash          The EIP-712 typehash associated with the registered compact.\n     * @param arbiter           The account tasked with verifying and submitting the claim.\n     * @param sponsor           The address of the sponsor for whom the claim is being registered.\n     * @param nonce             A parameter to enforce replay protection, scoped to allocator.\n     * @param expires           The time at which the claim expires.\n     * @param idsAndAmountsHash Hash of array of [id, amount] pairs per resource lock.\n     * @param witness           Hash of the witness data.\n     * @param sponsorSignature  The signature from the sponsor authorizing the registration.\n     * @return claimHash        Hash for verifying that the expected compact was registered.\n     */\n    function registerBatchFor(\n        bytes32 typehash,\n        address arbiter,\n        address sponsor,\n        uint256 nonce,\n        uint256 expires,\n        bytes32 idsAndAmountsHash,\n        bytes32 witness,\n        bytes calldata sponsorSignature\n    ) external returns (bytes32 claimHash);\n\n    /**\n     * @notice Register a multichain claim on behalf of a sponsor with their signature.\n     * @param typehash         The EIP-712 typehash associated with the registered compact.\n     * @param sponsor          The address of the sponsor for whom the claim is being registered.\n     * @param nonce            A parameter to enforce replay protection, scoped to allocator.\n     * @param expires          The time at which the claim expires.\n     * @param elementsHash     Hash of elements (arbiter, chainId, idsAndAmounts, & mandate) per chain.\n     * @param notarizedChainId Chain ID of the domain used to sign the multichain compact.\n     * @param sponsorSignature The signature from the sponsor authorizing the registration.\n     * @return claimHash       Hash for verifying that the expected compact was registered.\n     */\n    function registerMultichainFor(\n        bytes32 typehash,\n        address sponsor,\n        uint256 nonce,\n        uint256 expires,\n        bytes32 elementsHash,\n        uint256 notarizedChainId,\n        bytes calldata sponsorSignature\n    ) external returns (bytes32 claimHash);\n\n    /**\n     * @notice External payable function for depositing native tokens into a resource lock\n     * and simultaneously registering a compact. The allocator, the claim hash, and the typehash\n     * used for the claim hash are provided as additional arguments, and the default reset period\n     * (ten minutes) and scope (multichain) will be used for the resource lock. The ERC6909 token\n     * amount received by the caller will match the amount of native tokens sent with the transaction.\n     * @param lockTag   The lock tag containing allocator ID, reset period, and scope.\n     * @param claimHash A bytes32 hash derived from the details of the compact.\n     * @param typehash  The EIP-712 typehash associated with the registered compact.\n     * @return id       The ERC6909 token identifier of the associated resource lock.\n     */\n    function depositNativeAndRegister(bytes12 lockTag, bytes32 claimHash, bytes32 typehash)\n        external\n        payable\n        returns (uint256 id);\n\n    /**\n     * @notice External payable function for depositing native tokens and simultaneously registering a\n     * compact on behalf of someone else. The amount of the claim must be explicitly provided otherwise\n     * a wrong claim hash may be derived.\n     * @param recipient  The recipient of the ERC6909 token.\n     * @param lockTag    The lock tag containing allocator ID, reset period, and scope.\n     * @param arbiter    The account tasked with verifying and submitting the claim.\n     * @param nonce      A parameter to enforce replay protection, scoped to allocator.\n     * @param expires    The time at which the claim expires.\n     * @param typehash   The EIP-712 typehash associated with the registered compact.\n     * @param witness    Hash of the witness data.\n     * @return id        The ERC6909 token identifier of the associated resource lock.\n     * @return claimHash Hash for verifying that the expected compact was registered.\n     */\n    function depositNativeAndRegisterFor(\n        address recipient,\n        bytes12 lockTag,\n        address arbiter,\n        uint256 nonce,\n        uint256 expires,\n        bytes32 typehash,\n        bytes32 witness\n    ) external payable returns (uint256 id, bytes32 claimHash);\n\n    /**\n     * @notice External function for depositing ERC20 tokens and simultaneously registering a\n     * compact. The default reset period (ten minutes) and scope (multichain) will be used. The\n     * caller must directly approve The Compact to transfer a sufficient amount of the ERC20 token\n     * on its behalf. The ERC6909 token amount received back by the caller is derived from the\n     * difference between the starting and ending balance held in the resource lock, which may differ\n     * from the amount transferred depending on the implementation details of the respective token.\n     * @param token     The address of the ERC20 token to deposit.\n     * @param lockTag   The lock tag containing allocator ID, reset period, and scope.\n     * @param amount    The amount of tokens to deposit.\n     * @param claimHash A bytes32 hash derived from the details of the compact.\n     * @param typehash  The EIP-712 typehash associated with the registered compact.\n     * @return id       The ERC6909 token identifier of the associated resource lock.\n     */\n    function depositERC20AndRegister(\n        address token,\n        bytes12 lockTag,\n        uint256 amount,\n        bytes32 claimHash,\n        bytes32 typehash\n    ) external returns (uint256 id);\n\n    /**\n     * @notice External function for depositing ERC20 tokens and simultaneously registering a\n     * compact on behalf of someone else. The caller must directly approve The Compact to transfer\n     * a sufficient amount of the ERC20 token on its behalf. The ERC6909 token amount received by\n     * designated recipient the caller is derived from the difference between the starting and ending\n     * balance held in the resource lock, which may differ from the amount transferred depending on\n     * the implementation details of the respective token.\n     * @dev The final ERC6909 token amounts will be substituted into the compact which will be\n     * registered with the returned registeredAmount instead of the provided amount.\n     * Ensure the claim is processed using either the registeredAmount or the ERC6909 transfer event.\n     * This is especially important for fee-on-transfer tokens.\n     * @param recipient         The recipient of the ERC6909 token.\n     * @param token             The address of the ERC20 token to deposit.\n     * @param lockTag           Lock tag containing allocator ID, reset period, & scope.\n     * @param amount            The amount of tokens to deposit.\n     * @param arbiter           The account tasked with verifying and submitting the claim.\n     * @param nonce             A parameter to enforce replay protection, scoped to allocator.\n     * @param expires           The time at which the claim expires.\n     * @param typehash          The EIP-712 typehash associated with the registered compact.\n     * @param witness           Hash of the witness data.\n     * @return id               The ERC6909 token identifier of the associated resource lock.\n     * @return claimHash        Hash for verifying that the expected compact was registered.\n     * @return registeredAmount Final registered amount after potential transfer fees.\n     */\n    function depositERC20AndRegisterFor(\n        address recipient,\n        address token,\n        bytes12 lockTag,\n        uint256 amount,\n        address arbiter,\n        uint256 nonce,\n        uint256 expires,\n        bytes32 typehash,\n        bytes32 witness\n    ) external returns (uint256 id, bytes32 claimHash, uint256 registeredAmount);\n\n    /**\n     * @notice External payable function for depositing multiple tokens in a single transaction\n     * and registering a set of claim hashes. The first entry in idsAndAmounts can optionally\n     * represent native tokens by providing the null address and an amount matching msg.value. For\n     * ERC20 tokens, the caller must directly approve The Compact to transfer sufficient amounts\n     * on its behalf. The ERC6909 token amounts received by the recipient are derived from the\n     * differences between starting and ending balances held in the resource locks, which may\n     * differ from the amounts transferred depending on the implementation details of the\n     * respective tokens. Note that resource lock ids must be supplied in alphanumeric order.\n     * @param idsAndAmounts            Array of [id, amount] pairs indicating resource locks & amounts to deposit.\n     * @param claimHashesAndTypehashes Array of [claimHash, typehash] pairs for registration.\n     * @return                         Boolean indicating whether the batch deposit & claim hash registration was successful.\n     */\n    function batchDepositAndRegisterMultiple(\n        uint256[2][] calldata idsAndAmounts,\n        bytes32[2][] calldata claimHashesAndTypehashes\n    ) external payable returns (bool);\n\n    /**\n     * @notice External function for depositing ERC20 tokens and simultaneously registering a\n     * batch compact on behalf of someone else. The caller must directly approve The Compact\n     * to transfer a sufficient amount of the ERC20 token on its behalf. The ERC6909 token amount\n     * received by designated recipient the caller is derived from the difference between the\n     * starting and ending balance held in the resource lock, which may differ from the amount\n     * transferred depending on the implementation details of the respective token.\n     * @dev The final ERC6909 token amounts will be substituted into the compact which will be\n     * registered with the returned registeredAmounts instead of the provided idsAndAmounts.\n     * Ensure the claim is processed using either the registeredAmounts or the ERC6909 transfer events.\n     * This is especially important for fee-on-transfer tokens.\n     * @param recipient          The recipient of the ERC6909 token.\n     * @param idsAndAmounts      Array of [id, amount] pairs indicating resource locks & amounts to deposit.\n     * @param arbiter            The account tasked with verifying and submitting the claim.\n     * @param nonce              A parameter to enforce replay protection, scoped to allocator.\n     * @param expires            The time at which the claim expires.\n     * @param typehash           The EIP-712 typehash associated with the registered compact.\n     * @param witness            Hash of the witness data.\n     * @return claimHash         Hash for verifying that the expected compact was registered.\n     * @return registeredAmounts Array containing the final minted amount of each id.\n     */\n    function batchDepositAndRegisterFor(\n        address recipient,\n        uint256[2][] calldata idsAndAmounts,\n        address arbiter,\n        uint256 nonce,\n        uint256 expires,\n        bytes32 typehash,\n        bytes32 witness\n    ) external payable returns (bytes32 claimHash, uint256[] memory registeredAmounts);\n\n    /**\n     * @notice External function for depositing ERC20 tokens using Permit2 authorization and\n     * registering a compact. The depositor must approve Permit2 to transfer the tokens on its\n     * behalf unless the token in question automatically grants approval to Permit2. The ERC6909\n     * token amount received by the depositor is derived from the difference between the starting\n     * and ending balance held in the resource lock, which may differ from the amount transferred\n     * depending on the implementation details of the respective token. The Permit2 authorization\n     * signed by the depositor must contain an Activation witness containing the id of the resource\n     * lock and an associated Compact, BatchCompact, or MultichainCompact payload matching the\n     * specified compact category.\n     * @param permit          The permit data signed by the depositor.\n     * @param depositor       The account signing the permit2 authorization and depositing the tokens.\n     * @param lockTag         The lock tag containing allocator ID, reset period, and scope.\n     * @param claimHash       A bytes32 hash derived from the details of the compact.\n     * @param compactCategory The category of the compact being registered (Compact, BatchCompact, or MultichainCompact).\n     * @param witness         Additional data used in generating the claim hash.\n     * @param signature       The Permit2 signature from the depositor authorizing the deposit.\n     * @return id             The ERC6909 token identifier of the associated resource lock.\n     */\n    function depositERC20AndRegisterViaPermit2(\n        ISignatureTransfer.PermitTransferFrom calldata permit,\n        address depositor,\n        bytes12 lockTag,\n        bytes32 claimHash,\n        CompactCategory compactCategory,\n        string calldata witness,\n        bytes calldata signature\n    ) external returns (uint256 id);\n\n    /**\n     * @notice External payable function for depositing multiple tokens using Permit2\n     * authorization and registering a compact in a single transaction. The first token id can\n     * optionally represent native tokens by providing the null address and an amount matching\n     * msg.value. The depositor must approve Permit2 to transfer the tokens on its behalf unless\n     * the tokens automatically grant approval to Permit2. The ERC6909 token amounts received by\n     * the depositor are derived from the differences between starting and ending balances held\n     * in the resource locks, which may differ from the amounts transferred depending on the\n     * implementation details of the respective tokens. The Permit2 authorization signed by the\n     * depositor must contain a BatchActivation witness containing the ids of the resource locks\n     * and an associated Compact, BatchCompact, or MultichainCompact payload matching the\n     * specified compact category.\n     * @param depositor       The account signing the permit2 authorization and depositing the tokens.\n     * @param permitted       Array of token permissions specifying the deposited tokens and amounts.\n     * @param details         The details of the deposit.\n     * @param claimHash       A bytes32 hash derived from the details of the compact.\n     * @param compactCategory The category of the compact being registered (Compact, BatchCompact, or MultichainCompact).\n     * @param witness         Additional data used in generating the claim hash.\n     * @param signature       The Permit2 signature from the depositor authorizing the deposits.\n     * @return ids            Array of ERC6909 token identifiers for the associated resource locks.\n     */\n    function batchDepositAndRegisterViaPermit2(\n        address depositor,\n        ISignatureTransfer.TokenPermissions[] calldata permitted,\n        DepositDetails calldata details,\n        bytes32 claimHash,\n        CompactCategory compactCategory,\n        string calldata witness,\n        bytes calldata signature\n    ) external payable returns (uint256[] memory ids);\n\n    /**\n     * @notice External function to initiate a forced withdrawal for a resource lock. Once\n     * enabled, forced withdrawals can be executed after the reset period has elapsed. The\n     * withdrawableAt timestamp returned will be the current timestamp plus the reset period\n     * associated with the resource lock.\n     * @param id              The ERC6909 token identifier for the resource lock.\n     * @return withdrawableAt The timestamp at which tokens become withdrawable.\n     */\n    function enableForcedWithdrawal(uint256 id) external returns (uint256 withdrawableAt);\n\n    /**\n     * @notice External function to disable a previously enabled forced withdrawal for a\n     * resource lock.\n     * @param id The ERC6909 token identifier for the resource lock.\n     * @return   Boolean indicating whether the forced withdrawal was successfully disabled.\n     */\n    function disableForcedWithdrawal(uint256 id) external returns (bool);\n\n    /**\n     * @notice External function to execute a forced withdrawal from a resource lock after the\n     * reset period has elapsed. The tokens will be withdrawn to the specified recipient in the\n     * amount requested. The ERC6909 token balance of the caller will be reduced by the\n     * difference in the balance held by the resource lock before and after the withdrawal,\n     * which may differ from the provided amount depending on the underlying token in question.\n     * @param id        The ERC6909 token identifier for the resource lock.\n     * @param recipient The account that will receive the withdrawn tokens.\n     * @param amount    The amount of tokens to withdraw.\n     * @return          Boolean indicating whether the forced withdrawal was successfully executed.\n     */\n    function forcedWithdrawal(uint256 id, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @notice Assigns an emissary for the caller that has authority to authorize claims where that\n     * caller is the sponsor. The emissary will utilize a reset period dictated by the reset period\n     * on the provided lock tag that blocks reassignment of the emissary for the duration of that\n     * reset period. The reset period ensures that once an emissary is assigned, another assignment\n     * cannot be made until the reset period has elapsed.\n     * @param lockTag  The lockTag the emissary will be assigned for.\n     * @param emissary The emissary to assign for the given caller and lock tag.\n     * @return         Boolean indicating whether the assignment was successful.\n     */\n    function assignEmissary(bytes12 lockTag, address emissary) external returns (bool);\n\n    /**\n     * @notice Schedules a future emissary assignment for a specific lock tag. The reset period on\n     * the lock tag determines how long reassignment will be blocked after this assignment. This\n     * allows for a delay before the next assignment can be made. Note that the reset period of the\n     * current emissary (if set) will dictate when the next assignment will be allowed.\n     * @param lockTag                        The lockTag the emissary assignment is scheduled for.\n     * @return emissaryAssignmentAvailableAt The timestamp when the next assignment will be allowed.\n     */\n    function scheduleEmissaryAssignment(bytes12 lockTag) external returns (uint256 emissaryAssignmentAvailableAt);\n\n    /**\n     * @notice External function for consuming allocator nonces. Only callable by a registered\n     * allocator. Once consumed, any compact payloads that utilize those nonces cannot be claimed.\n     * @param nonces Array of nonces to be consumed.\n     * @return       Boolean indicating whether all nonces were successfully consumed.\n     */\n    function consume(uint256[] calldata nonces) external returns (bool);\n\n    /**\n     * @notice External function for registering an allocator. Can be called by anyone if one\n     * of three conditions is met: the caller is the allocator address being registered, the\n     * allocator address contains code, or a proof is supplied representing valid create2\n     * deployment parameters that resolve to the supplied allocator address.\n     * @param allocator    The address to register as an allocator.\n     * @param proof        An 85-byte value containing create2 address derivation parameters (0xff ++ factory ++ salt ++ initcode hash).\n     * @return allocatorId A unique identifier assigned to the registered allocator.\n     */\n    function __registerAllocator(address allocator, bytes calldata proof) external returns (uint96 allocatorId);\n\n    /**\n     * @notice External function to benchmark withdrawal costs to determine the required stipend\n     * on the fallback for failing withdrawals when processing claims. The salt is used to derive\n     * a cold account to benchmark the native token withdrawal. Note that exactly 2 wei must be\n     * provided when calling this function, and that the provided wei will be irrecoverable.\n     * @param salt A bytes32 value used to derive a cold account for benchmarking.\n     */\n    function __benchmark(bytes32 salt) external payable;\n\n    /**\n     * @notice External view function for retrieving the details of a resource lock. Returns the\n     * underlying token, the mediating allocator, the reset period, and the scope.\n     * @param id           The ERC6909 token identifier of the resource lock.\n     * @return token       The address of the underlying token (or address(0) for native tokens).\n     * @return allocator   The account of the allocator mediating the resource lock.\n     * @return resetPeriod The duration after which the resource lock can be reset once a forced withdrawal is initiated.\n     * @return scope       The scope of the resource lock (multichain or single chain).\n     * @return lockTag     The lock tag containing the allocator ID, the reset period, and the scope.\n     */\n    function getLockDetails(uint256 id)\n        external\n        view\n        returns (address token, address allocator, ResetPeriod resetPeriod, Scope scope, bytes12 lockTag);\n\n    /**\n     * @notice External view function for checking the registration status of a compact. Returns\n     * both whether the claim hash is currently active and when it was registered (if relevant).\n     * Note that an \"active\" compact may in fact not be claimable, (e.g. it has expired, the\n     * nonce has been consumed, etc).\n     * @param sponsor   The account that registered the compact.\n     * @param claimHash A bytes32 hash derived from the details of the compact.\n     * @param typehash  The EIP-712 typehash associated with the registered claim hash.\n     * @return isActive Boolean indicating whether the compact registration is currently active.\n     */\n    function isRegistered(address sponsor, bytes32 claimHash, bytes32 typehash) external view returns (bool isActive);\n\n    /**\n     * @notice External view function for checking the forced withdrawal status of a resource\n     * lock for a given account. Returns both the current status (disabled, pending, or enabled)\n     * and the timestamp at which forced withdrawals will be enabled (if status is pending) or\n     * became enabled (if status is enabled).\n     * @param account                      The account to get the forced withdrawal status for.\n     * @param id                           The ERC6909 token identifier of the resource lock.\n     * @return status                      The current ForcedWithdrawalStatus (disabled, pending, or enabled).\n     * @return forcedWithdrawalAvailableAt The timestamp at which tokens become withdrawable if status is pending.\n     */\n    function getForcedWithdrawalStatus(address account, uint256 id)\n        external\n        view\n        returns (ForcedWithdrawalStatus status, uint256 forcedWithdrawalAvailableAt);\n\n    /**\n     * @notice Gets the current emissary status for an allocator. Returns the current status,\n     * the timestamp when reassignment will be allowed again (based on reset period), and\n     * the currently assigned emissary (if any).\n     * @param sponsor                        The address of the sponsor to check.\n     * @param lockTag                        The lockTag to check.\n     * @return status                        The current emissary assignment status.\n     * @return emissaryAssignmentAvailableAt The timestamp when reassignment will be allowed.\n     * @return currentEmissary               The currently assigned emissary address (or zero address if none).\n     */\n    function getEmissaryStatus(address sponsor, bytes12 lockTag)\n        external\n        view\n        returns (EmissaryStatus status, uint256 emissaryAssignmentAvailableAt, address currentEmissary);\n\n    /**\n     * @notice External view function for checking whether a specific nonce has been consumed by\n     * an allocator. Once consumed, a nonce cannot be reused for claims mediated by that allocator.\n     * @param nonce     The nonce to check.\n     * @param allocator The account of the allocator.\n     * @return consumed Boolean indicating whether the nonce has been consumed.\n     */\n    function hasConsumedAllocatorNonce(uint256 nonce, address allocator) external view returns (bool consumed);\n\n    /**\n     * @notice External view function for getting required stipends for releasing tokens as a\n     * fallback on claims where withdrawals do not succeed. Any requested withdrawal is first\n     * attempted using half of available gas. If it fails, then a direct 6909 transfer will be\n     * performed as long as the remaining gas left exceeds the benchmarked stipend.\n     * @return nativeTokenStipend The gas stipend required for native token withdrawals.\n     * @return erc20TokenStipend  The gas stipend required for ERC20 token withdrawals.\n     */\n    function getRequiredWithdrawalFallbackStipends()\n        external\n        view\n        returns (uint256 nativeTokenStipend, uint256 erc20TokenStipend);\n\n    /**\n     * @notice External view function for returning the domain separator of the contract.\n     * @return domainSeparator A bytes32 representing the domain separator for the contract.\n     */\n    function DOMAIN_SEPARATOR() external view returns (bytes32 domainSeparator);\n\n    /**\n     * @notice External pure function for returning the name of the contract.\n     * @return A string representing the name of the contract.\n     */\n    function name() external pure returns (string memory);\n\n    error InvalidToken(address token);\n    error Expired(uint256 expiration);\n    error InvalidSignature();\n    error PrematureWithdrawal(uint256 id);\n    error ForcedWithdrawalFailed();\n    error ForcedWithdrawalAlreadyDisabled(address account, uint256 id);\n    error UnallocatedTransfer(address operator, address from, address to, uint256 id, uint256 amount);\n    error InvalidBatchAllocation();\n    error InvalidRegistrationProof(address allocator);\n    error InvalidBatchDepositStructure();\n    error AllocatedAmountExceeded(uint256 allocatedAmount, uint256 providedAmount);\n    error InvalidScope(uint256 id);\n    error InvalidDepositTokenOrdering();\n    error InvalidDepositBalanceChange();\n    error Permit2CallFailed();\n    error ReentrantCall(address existingCaller);\n    error InconsistentAllocators();\n    error InvalidAllocation(address allocator);\n    error ChainIndexOutOfRange();\n    error InvalidEmissaryAssignment();\n    error EmissaryAssignmentUnavailable(uint256 assignableAt);\n    error InvalidLockTag();\n}\n"}, "src/lib/IdLib.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { ResetPeriod } from \"../types/ResetPeriod.sol\";\nimport { Scope } from \"../types/Scope.sol\";\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\nimport { EfficientHashLib } from \"solady/utils/EfficientHashLib.sol\";\n\n/**\n * @title IdLib\n * @notice Library contract implementing logic for deriving IDs for allocators and\n * for resource locks, converting between various IDs, and for extracting details\n * related to those IDs. This includes logic for registering allocators and for\n * assigning them an allocator ID.\n */\nlibrary IdLib {\n    using IdLib for bytes12;\n    using IdLib for uint96;\n    using IdLib for uint256;\n    using IdLib for address;\n    using EfficiencyLib for bool;\n    using EfficiencyLib for uint96;\n    using EfficiencyLib for bytes12;\n    using EfficiencyLib for uint256;\n    using EfficiencyLib for address;\n    using EfficiencyLib for ResetPeriod;\n    using EfficiencyLib for Scope;\n    using EfficientHashLib for bytes;\n\n    error NoAllocatorRegistered(uint96 allocatorId);\n    error AllocatorAlreadyRegistered(uint96 allocatorId, address allocator);\n\n    // Storage slot seed for mapping allocator IDs to allocator addresses.\n    uint256 private constant _ALLOCATOR_BY_ALLOCATOR_ID_SLOT_SEED = 0x000044036fc77deaed2300000000000000000000000;\n\n    // keccak256(bytes(\"AllocatorRegistered(uint96,address)\")).\n    uint256 private constant _ALLOCATOR_REGISTERED_EVENT_SIGNATURE =\n        0xc54dcaa67a8fd7b4a9aa6fd57351934c792613d5ec1acbd65274270e6de8f7e4;\n\n    // Error selectors for NoAllocatorRegistered and AllocatorAlreadyRegistered.\n    uint256 private constant _NO_ALLOCATOR_REGISTERED_ERROR_SIGNATURE = 0xcf90c3a8;\n    uint256 private constant _ALLOCATOR_ALREADY_REGISTERED_ERROR_SIGNATURE = 0xc18b0e97;\n\n    /**\n     * @notice Internal function for registering an allocator. Derives an ID for the\n     * allocator and stores the allocator's address for that ID, reverting if an\n     * allocator has already been registered for the ID in question.\n     * @param allocator The address to register as an allocator.\n     * @return allocatorId The derived ID for the registered allocator.\n     */\n    function register(address allocator) internal returns (uint96 allocatorId) {\n        // Derive the allocator ID for the provided allocator address.\n        allocatorId = allocator.toAllocatorId();\n\n        assembly (\"memory-safe\") {\n            // Derive storage slot for allocator registration by ID.\n            let allocatorSlot := or(_ALLOCATOR_BY_ALLOCATOR_ID_SLOT_SEED, allocatorId)\n\n            // Retrieve the allocator value at the derived storage slot.\n            let registeredAllocator := sload(allocatorSlot)\n\n            // Revert if an allocator has already been registered for the ID.\n            if registeredAllocator {\n                mstore(0, _ALLOCATOR_ALREADY_REGISTERED_ERROR_SIGNATURE)\n                mstore(0x20, allocatorId)\n                mstore(0x40, registeredAllocator)\n                revert(0x1c, 0x44)\n            }\n\n            // Store allocator address (sanitize first as an added precaution).\n            allocator := shr(0x60, shl(0x60, allocator))\n            sstore(allocatorSlot, allocator)\n\n            // Emit AllocatorRegistered(allocatorId, allocator) event.\n            mstore(0x00, allocatorId)\n            mstore(0x20, allocator)\n            log1(0x00, 0x40, _ALLOCATOR_REGISTERED_EVENT_SIGNATURE)\n        }\n    }\n\n    /**\n     * @notice Internal view function for constructing a resource lock ID assuming that the\n     * provided allocator has been registered. Derives the allocator ID from the registered\n     * allocator, and combines it with the provided scope, reset period, and token address\n     * to form a single ID value. Reverts if the allocator is not registered.\n     * @param token   The address of the underlying token.\n     * @param lockTag The lock tag containing allocator ID, reset period, and scope.\n     * @return id     The derived resource lock ID.\n     */\n    function toIdIfRegistered(address token, bytes12 lockTag) internal view returns (uint256 id) {\n        // Derive the allocator ID for the provided allocator address.\n        lockTag.toAllocatorId().mustHaveARegisteredAllocator();\n\n        // Derive resource lock ID (pack scope, reset period, allocator ID, & token).\n        id = lockTag.asUint256() | token.asUint256();\n    }\n\n    /**\n     * @notice Internal view function for extracting and validating an allocator ID from\n     * a resource lock ID. Reverts if the allocator is not registered.\n     * @param id           The resource lock ID to extract from.\n     * @return allocatorId The validated allocator ID.\n     */\n    function toAllocatorIdIfRegistered(uint256 id) internal view returns (uint96 allocatorId) {\n        allocatorId = id.toAllocatorId();\n        allocatorId.mustHaveARegisteredAllocator();\n    }\n\n    /**\n     * @notice Internal view function for retrieving an allocator's address from their ID.\n     * Reverts if no allocator is registered with the provided ID.\n     * @param allocatorId The ID to look up.\n     * @return allocator  The registered allocator's address.\n     */\n    function toRegisteredAllocator(uint96 allocatorId) internal view returns (address allocator) {\n        assembly (\"memory-safe\") {\n            // Retrieve allocator from storage based on allocator ID.\n            allocator := sload(or(_ALLOCATOR_BY_ALLOCATOR_ID_SLOT_SEED, allocatorId))\n\n            // Revert if no registered allocator is located.\n            if iszero(allocator) {\n                mstore(0, _NO_ALLOCATOR_REGISTERED_ERROR_SIGNATURE)\n                mstore(0x20, allocatorId)\n                revert(0x1c, 0x24)\n            }\n        }\n    }\n\n    /**\n     * @notice Internal view function that checks if an allocator ID has a registered\n     * allocator. Reverts if no allocator is registered.\n     * @param allocatorId The allocator ID to check.\n     */\n    function mustHaveARegisteredAllocator(uint96 allocatorId) internal view {\n        assembly (\"memory-safe\") {\n            // Derive storage slot using scope + allocatorId & ensure allocator is set.\n            if iszero(sload(or(_ALLOCATOR_BY_ALLOCATOR_ID_SLOT_SEED, allocatorId))) {\n                mstore(0, _NO_ALLOCATOR_REGISTERED_ERROR_SIGNATURE)\n                mstore(0x20, allocatorId)\n                revert(0x1c, 0x24)\n            }\n        }\n    }\n\n    /**\n     * @notice Internal view function that checks if an allocator can be registered.\n     * Returns true if any of the following are true:\n     *  - The caller is the allocator\n     *  - The allocator address contains code\n     *  - The proof is a valid create2 deployment that derives the allocator address\n     *    (e.g. proof must take the form of 0xff ++ factory ++ salt ++ initcode hash)\n     * @param allocator The address to check.\n     * @param proof     An 85-byte value containing create2 address derivation parameters.\n     * @return          Whether the allocator can be registered.\n     */\n    function canBeRegistered(address allocator, bytes calldata proof) internal view returns (bool) {\n        return (msg.sender == allocator).or(allocator.code.length > 0).or(\n            proof.length == 85 && (proof[0] == 0xff).and(allocator == address(uint160(uint256(proof.hashCalldata()))))\n        );\n    }\n\n    /**\n     * @notice Internal pure function for building the \"lock tag\" from an\n     * allocatorId, scope, and reset period.\n     * @param allocatorId The allocator ID, must be at most 92 bits: 4 bits for the compact flag, 88 bits from the allocator address.\n     * @param scope       The scope of the resource lock (multichain or single chain).\n     * @param resetPeriod The duration after which the resource lock can be reset.\n     * @return lockTag    The lock tag.\n     */\n    function toLockTag(uint96 allocatorId, Scope scope, ResetPeriod resetPeriod)\n        internal\n        pure\n        returns (bytes12 lockTag)\n    {\n        // Derive lock tag (pack scope, reset period, & allocator ID).\n        assembly {\n            lockTag := or(or(shl(255, scope), shl(252, resetPeriod)), shl(160, allocatorId))\n        }\n    }\n\n    /**\n     * @notice Internal pure function for extracting the \"lock tag\" from an ID.\n     * @param id The resource lock ID.\n     * @return lockTag The lock tag.\n     */\n    function toLockTag(uint256 id) internal pure returns (bytes12 lockTag) {\n        // Extract the lock tag.\n        assembly (\"memory-safe\") {\n            lockTag := shl(160, shr(160, id))\n        }\n    }\n\n    /**\n     * @notice Internal pure function for extracting the last 20 bytes of an\n     * underlying uint256 as an address. This represents either the token\n     * address (for a resource lock ID) or the claimant address (for a claimant\n     * value).\n     * @param id The uint256 to extract from.\n     * @return   The address.\n     */\n    function toAddress(uint256 id) internal pure returns (address) {\n        return id.asSanitizedAddress();\n    }\n\n    /**\n     * @notice Internal pure function for creating a new resource lock ID with a\n     * different token address.\n     * @param id         The resource lock ID to modify.\n     * @param token      The new token address.\n     * @return updatedId The modified resource lock ID.\n     */\n    function withReplacedToken(uint256 id, address token) internal pure returns (uint256 updatedId) {\n        assembly (\"memory-safe\") {\n            updatedId := or(shl(160, shr(160, id)), shr(96, shl(96, token)))\n        }\n    }\n\n    /**\n     * @notice Internal pure function for creating a new resource lock ID from an\n     * existing id and a lock tag.\n     * @param id         The resource lock ID to modify.\n     * @param lockTag    The new lock tag.\n     * @return updatedId The modified resource lock ID.\n     */\n    function withReplacedLockTag(uint256 id, bytes12 lockTag) internal pure returns (uint256 updatedId) {\n        assembly (\"memory-safe\") {\n            updatedId := or(shl(160, shr(160, lockTag)), shr(96, shl(96, id)))\n        }\n    }\n\n    /**\n     * @notice Internal pure function for extracting the scope from a resource lock ID.\n     * @param id     The resource lock ID to extract from.\n     * @return scope The scope (uppermost bit).\n     */\n    function toScope(uint256 id) internal pure returns (Scope scope) {\n        assembly (\"memory-safe\") {\n            // extract uppermost bit\n            scope := shr(255, id)\n        }\n    }\n\n    /**\n     * @notice Internal pure function for extracting the reset period from a resource\n     * lock ID.\n     * @param id           The resource lock ID to extract from.\n     * @return resetPeriod The reset period (bits 252-254).\n     */\n    function toResetPeriod(uint256 id) internal pure returns (ResetPeriod resetPeriod) {\n        assembly (\"memory-safe\") {\n            // extract 2nd, 3rd & 4th uppermost bits\n            resetPeriod := and(shr(252, id), 7)\n        }\n    }\n\n    /**\n     * @notice Internal pure function for extracting the reset period from a resource\n     * lock tag.\n     * @param lockTag      The resource lock tag to extract from.\n     * @return resetPeriod The reset period (bits 252-254).\n     */\n    function toResetPeriod(bytes12 lockTag) internal pure returns (ResetPeriod resetPeriod) {\n        assembly (\"memory-safe\") {\n            // extract 2nd, 3rd & 4th uppermost bits\n            resetPeriod := and(shr(252, lockTag), 7)\n        }\n    }\n\n    /**\n     * @notice Internal pure function for converting a reset period to its duration in\n     * seconds. There are eight distinct reset periods ranging from one second to\n     * thirty days. Specific periods include some additional padding:\n     *  - One hour is padded by five minutes\n     *  - Seven days is padded by one hour\n     * @dev No bounds check performed; ensure that the enum value is in range.\n     * @param resetPeriod The reset period to convert.\n     * @return duration   The duration in seconds.\n     */\n    function toSeconds(ResetPeriod resetPeriod) internal pure returns (uint256 duration) {\n        assembly (\"memory-safe\") {\n            // Bitpacked durations in 24-bit segments:\n            // 278d00  094890  015180  000f3c  000258  00003c  00000f  000001\n            // 30 days 7 days  1 day   1 hour  10 min  1 min   15 sec  1 sec\n            let bitpacked := 0x278d00094890015180000f3c00025800003c00000f000001\n\n            // Shift right by period * 24 bits & mask the least significant 24 bits.\n            duration := and(shr(mul(resetPeriod, 24), bitpacked), 0xffffff)\n        }\n    }\n\n    /**\n     * @notice Internal pure function for computing an address's compact flag. The flag\n     * is a 4-bit value that represents how \"compact\" the address of an allocator is. A\n     * fully \"compact\" allocator address will have nine leading zero bytes, or eighteen\n     * leading zero nibbles. To be considered even partially compact, the account must\n     * have at least two leading zero bytes, or four leading zero nibbles. The full\n     * scoring formula is therefore:\n     *  - 0-3 leading zero nibbles: 0\n     *  - 4-17 leading zero nibbles: number of leading zeros minus 3\n     *  - 18+ leading zero nibbles: 15\n     * @param allocator    The address to compute the flag for.\n     * @return compactFlag The computed compact flag.\n     */\n    function toCompactFlag(address allocator) internal pure returns (uint8 compactFlag) {\n        assembly (\"memory-safe\") {\n            // Extract the uppermost 72 bits of the address.\n            let x := shr(184, shl(96, allocator))\n\n            // Propagate the highest set bit.\n            x := or(x, shr(1, x))\n            x := or(x, shr(2, x))\n            x := or(x, shr(4, x))\n            x := or(x, shr(8, x))\n            x := or(x, shr(16, x))\n            x := or(x, shr(32, x))\n            x := or(x, shr(64, x))\n\n            // Count set bits to derive most significant bit in the last byte.\n            let y := sub(x, and(shr(1, x), 0x5555555555555555))\n            y := add(and(y, 0x3333333333333333), and(shr(2, y), 0x3333333333333333))\n            y := and(add(y, shr(4, y)), 0x0f0f0f0f0f0f0f0f)\n            y := add(y, shr(8, y))\n            y := add(y, shr(16, y))\n            y := add(y, shr(32, y))\n\n            // Look up final value in the sequence.\n            compactFlag := and(shr(and(sub(72, and(y, 127)), not(3)), 0xfedcba9876543210000), 15)\n        }\n    }\n\n    /**\n     * @notice Internal pure function for extracting the allocator ID from a resource\n     * lock ID. The allocator ID is a 92-bit value, with the first 4 bits representing\n     * the compact flag and the last 88 bits matching the last 88 bits of the underlying\n     * allocator, but is represented by a uint96 as solidity only supports uint values\n     * for multiples of 8 bits.\n     * @param id           The resource lock ID to extract from.\n     * @return allocatorId The allocator ID (bits 160-251).\n     */\n    function toAllocatorId(uint256 id) internal pure returns (uint96 allocatorId) {\n        assembly (\"memory-safe\") {\n            // Extract bits 5-96.\n            allocatorId := shr(164, shl(4, id))\n        }\n    }\n\n    /**\n     * @notice Internal pure function for computing an allocator's ID from their address.\n     * Combines the compact flag (4 bits) with the last 88 bits of the address.\n     * @param allocator    The address to compute the ID for.\n     * @return allocatorId The computed allocator ID.\n     */\n    function toAllocatorId(address allocator) internal pure returns (uint96 allocatorId) {\n        uint8 compactFlag = allocator.toCompactFlag();\n\n        assembly (\"memory-safe\") {\n            allocatorId := or(shl(88, compactFlag), shr(168, shl(168, allocator)))\n        }\n    }\n\n    /**\n     * @notice Internal pure function for extracting the allocator ID from a resource\n     * lock tag. The allocator ID is a 92-bit value, with the first 4 bits representing\n     * the compact flag and the last 88 bits matching the last 88 bits of the underlying\n     * allocator, but is represented by a uint96 as solidity only supports uint values\n     * for multiples of 8 bits.\n     * @param lockTag      The resource lock tag to extract from.\n     * @return allocatorId The allocator ID (bits 160-251).\n     */\n    function toAllocatorId(bytes12 lockTag) internal pure returns (uint96 allocatorId) {\n        assembly (\"memory-safe\") {\n            // Extract bits 5-96.\n            allocatorId := shr(164, shl(4, lockTag))\n        }\n    }\n\n    /**\n     * @notice Internal view function for ensuring that the allocator ID from a resource\n     * lock tag is registered to an allocator.\n     * @param lockTag The resource lock tag to check allocator registration for.\n     */\n    function hasRegisteredAllocatorId(bytes12 lockTag) internal view {\n        lockTag.toAllocatorId().mustHaveARegisteredAllocator();\n    }\n}\n"}, "lib/solady/src/utils/LibString.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {LibBytes} from \"./LibBytes.sol\";\n\n/// @notice Library for converting numbers into strings and other string operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\n///\n/// @dev Note:\n/// For performance and bytecode compactness, most of the string operations are restricted to\n/// byte strings (7-bit ASCII), except where otherwise specified.\n/// Usage of byte string operations on charsets with runes spanning two or more bytes\n/// can lead to undefined behavior.\nlibrary LibString {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          STRUCTS                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Goated string storage struct that totally MOGs, no cap, fr.\n    /// Uses less gas and bytecode than Solidity's native string storage. It's meta af.\n    /// Packs length with the first 31 bytes if <255 bytes, so it\u2019s mad tight.\n    struct StringStorage {\n        bytes32 _spacer;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The length of the output is too small to contain all the hex digits.\n    error HexLengthInsufficient();\n\n    /// @dev The length of the string is more than 32 bytes.\n    error TooBigForSmallString();\n\n    /// @dev The input string must be a 7-bit ASCII.\n    error StringNot7BitASCII();\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         CONSTANTS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The constant returned when the `search` is not found in the string.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /// @dev Lookup for '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.\n    uint128 internal constant ALPHANUMERIC_7_BIT_ASCII = 0x7fffffe07fffffe03ff000000000000;\n\n    /// @dev Lookup for 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.\n    uint128 internal constant LETTERS_7_BIT_ASCII = 0x7fffffe07fffffe0000000000000000;\n\n    /// @dev Lookup for 'abcdefghijklmnopqrstuvwxyz'.\n    uint128 internal constant LOWERCASE_7_BIT_ASCII = 0x7fffffe000000000000000000000000;\n\n    /// @dev Lookup for 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.\n    uint128 internal constant UPPERCASE_7_BIT_ASCII = 0x7fffffe0000000000000000;\n\n    /// @dev Lookup for '0123456789'.\n    uint128 internal constant DIGITS_7_BIT_ASCII = 0x3ff000000000000;\n\n    /// @dev Lookup for '0123456789abcdefABCDEF'.\n    uint128 internal constant HEXDIGITS_7_BIT_ASCII = 0x7e0000007e03ff000000000000;\n\n    /// @dev Lookup for '01234567'.\n    uint128 internal constant OCTDIGITS_7_BIT_ASCII = 0xff000000000000;\n\n    /// @dev Lookup for '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~ \\t\\n\\r\\x0b\\x0c'.\n    uint128 internal constant PRINTABLE_7_BIT_ASCII = 0x7fffffffffffffffffffffff00003e00;\n\n    /// @dev Lookup for '!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~'.\n    uint128 internal constant PUNCTUATION_7_BIT_ASCII = 0x78000001f8000001fc00fffe00000000;\n\n    /// @dev Lookup for ' \\t\\n\\r\\x0b\\x0c'.\n    uint128 internal constant WHITESPACE_7_BIT_ASCII = 0x100003e00;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                 STRING STORAGE OPERATIONS                  */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Sets the value of the string storage `$` to `s`.\n    function set(StringStorage storage $, string memory s) internal {\n        LibBytes.set(bytesStorage($), bytes(s));\n    }\n\n    /// @dev Sets the value of the string storage `$` to `s`.\n    function setCalldata(StringStorage storage $, string calldata s) internal {\n        LibBytes.setCalldata(bytesStorage($), bytes(s));\n    }\n\n    /// @dev Sets the value of the string storage `$` to the empty string.\n    function clear(StringStorage storage $) internal {\n        delete $._spacer;\n    }\n\n    /// @dev Returns whether the value stored is `$` is the empty string \"\".\n    function isEmpty(StringStorage storage $) internal view returns (bool) {\n        return uint256($._spacer) & 0xff == uint256(0);\n    }\n\n    /// @dev Returns the length of the value stored in `$`.\n    function length(StringStorage storage $) internal view returns (uint256) {\n        return LibBytes.length(bytesStorage($));\n    }\n\n    /// @dev Returns the value stored in `$`.\n    function get(StringStorage storage $) internal view returns (string memory) {\n        return string(LibBytes.get(bytesStorage($)));\n    }\n\n    /// @dev Returns the uint8 at index `i`. If out-of-bounds, returns 0.\n    function uint8At(StringStorage storage $, uint256 i) internal view returns (uint8) {\n        return LibBytes.uint8At(bytesStorage($), i);\n    }\n\n    /// @dev Helper to cast `$` to a `BytesStorage`.\n    function bytesStorage(StringStorage storage $)\n        internal\n        pure\n        returns (LibBytes.BytesStorage storage casted)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted.slot := $.slot\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                     DECIMAL OPERATIONS                     */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(uint256 value) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits.\n            result := add(mload(0x40), 0x80)\n            mstore(0x40, add(result, 0x20)) // Allocate memory.\n            mstore(result, 0) // Zeroize the slot after the string.\n\n            let end := result // Cache the end of the memory to calculate the length later.\n            let w := not(0) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                result := add(result, w) // `sub(result, 1)`.\n                // Store the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(result, add(48, mod(temp, 10)))\n                temp := div(temp, 10) // Keep dividing `temp` until zero.\n                if iszero(temp) { break }\n            }\n            let n := sub(end, result)\n            result := sub(result, 0x20) // Move the pointer 32 bytes back to make room for the length.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(int256 value) internal pure returns (string memory result) {\n        if (value >= 0) return toString(uint256(value));\n        unchecked {\n            result = toString(~uint256(value) + 1);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We still have some spare memory space on the left,\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\n            let n := mload(result) // Load the string length.\n            mstore(result, 0x2d) // Store the '-' character.\n            result := sub(result, 1) // Move back the string pointer by a byte.\n            mstore(result, add(n, 1)) // Update the string length.\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                   HEXADECIMAL OPERATIONS                   */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `byteCount` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `byteCount * 2 + 2` bytes.\n    /// Reverts if `byteCount` is too small for the output to contain all the digits.\n    function toHexString(uint256 value, uint256 byteCount)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = toHexStringNoPrefix(value, byteCount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the \"0x\" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `byteCount` bytes.\n    /// The output is not prefixed with \"0x\" and is encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `byteCount * 2` bytes.\n    /// Reverts if `byteCount` is too small for the output to contain all the digits.\n    function toHexStringNoPrefix(uint256 value, uint256 byteCount)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, `byteCount * 2` bytes\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\n            // We add 0x20 to the total and round down to a multiple of 0x20.\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\n            result := add(mload(0x40), and(add(shl(1, byteCount), 0x42), not(0x1f)))\n            mstore(0x40, add(result, 0x20)) // Allocate memory.\n            mstore(result, 0) // Zeroize the slot after the string.\n\n            let end := result // Cache the end to calculate the length later.\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let start := sub(result, add(byteCount, byteCount))\n            let w := not(1) // Tsk.\n            let temp := value\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for {} 1 {} {\n                result := add(result, w) // `sub(result, 2)`.\n                mstore8(add(result, 1), mload(and(temp, 15)))\n                mstore8(result, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(xor(result, start)) { break }\n            }\n            if temp {\n                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\n                revert(0x1c, 0x04)\n            }\n            let n := sub(end, result)\n            result := sub(result, 0x20)\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2 + 2` bytes.\n    function toHexString(uint256 value) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the \"0x\" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\".\n    /// The output excludes leading \"0\" from the `toHexString` output.\n    /// `0x00: \"0x0\", 0x01: \"0x1\", 0x12: \"0x12\", 0x123: \"0x123\"`.\n    function toMinimalHexString(uint256 value) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(result, 0x20))), 0x30) // Whether leading zero is present.\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(add(result, o), 0x3078) // Store the \"0x\" prefix, accounting for leading zero.\n            result := sub(add(result, o), 2) // Move the pointer, accounting for leading zero.\n            mstore(result, sub(n, o)) // Store the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output excludes leading \"0\" from the `toHexStringNoPrefix` output.\n    /// `0x00: \"0\", 0x01: \"1\", 0x12: \"12\", 0x123: \"123\"`.\n    function toMinimalHexStringNoPrefix(uint256 value)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(result, 0x20))), 0x30) // Whether leading zero is present.\n            let n := mload(result) // Get the length.\n            result := add(result, o) // Move the pointer, accounting for leading zero.\n            mstore(result, sub(n, o)) // Store the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2` bytes.\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\n            result := add(mload(0x40), 0x80)\n            mstore(0x40, add(result, 0x20)) // Allocate memory.\n            mstore(result, 0) // Zeroize the slot after the string.\n\n            let end := result // Cache the end to calculate the length later.\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \"0123456789abcdef\" lookup.\n\n            let w := not(1) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                result := add(result, w) // `sub(result, 2)`.\n                mstore8(add(result, 1), mload(and(temp, 15)))\n                mstore8(result, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(temp) { break }\n            }\n            let n := sub(end, result)\n            result := sub(result, 0x20)\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\", encoded using 2 hexadecimal digits per byte,\n    /// and the alphabets are capitalized conditionally according to\n    /// https://eips.ethereum.org/EIPS/eip-55\n    function toHexStringChecksummed(address value) internal pure returns (string memory result) {\n        result = toHexString(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\n            let o := add(result, 0x22)\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\n            let t := shl(240, 136) // `0b10001000 << 240`\n            for { let i := 0 } 1 {} {\n                mstore(add(i, i), mul(t, byte(i, hashed)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\n            o := add(o, 0x20)\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    function toHexString(address value) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the \"0x\" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(address value) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            // Allocate memory.\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\n            mstore(0x40, add(result, 0x80))\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \"0123456789abcdef\" lookup.\n\n            result := add(result, 2)\n            mstore(result, 40) // Store the length.\n            let o := add(result, 0x20)\n            mstore(add(o, 40), 0) // Zeroize the slot after the string.\n            value := shl(96, value)\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let i := 0 } 1 {} {\n                let p := add(o, add(i, i))\n                let temp := byte(i, value)\n                mstore8(add(p, 1), mload(and(temp, 15)))\n                mstore8(p, mload(shr(4, temp)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexString(bytes memory raw) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(raw);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the \"0x\" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(raw)\n            result := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\n            mstore(result, add(n, n)) // Store the length of the output.\n\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \"0123456789abcdef\" lookup.\n            let o := add(result, 0x20)\n            let end := add(raw, n)\n            for {} iszero(eq(raw, end)) {} {\n                raw := add(raw, 1)\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\n                o := add(o, 2)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                   RUNE STRING OPERATIONS                   */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the number of UTF characters in the string.\n    function runeCount(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                mstore(0x00, div(not(0), 255))\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\n                let o := add(s, 0x20)\n                let end := add(o, mload(s))\n                for { result := 1 } 1 { result := add(result, 1) } {\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\n                    if iszero(lt(o, end)) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns if this string is a 7-bit ASCII string.\n    /// (i.e. all characters codes are in [0..127])\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            let mask := shl(7, div(not(0), 255))\n            let n := mload(s)\n            if n {\n                let o := add(s, 0x20)\n                let end := add(o, n)\n                let last := mload(end)\n                mstore(end, 0)\n                for {} 1 {} {\n                    if and(mask, mload(o)) {\n                        result := 0\n                        break\n                    }\n                    o := add(o, 0x20)\n                    if iszero(lt(o, end)) { break }\n                }\n                mstore(end, last)\n            }\n        }\n    }\n\n    /// @dev Returns if this string is a 7-bit ASCII string,\n    /// AND all characters are in the `allowed` lookup.\n    /// Note: If `s` is empty, returns true regardless of `allowed`.\n    function is7BitASCII(string memory s, uint128 allowed) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if mload(s) {\n                let allowed_ := shr(128, shl(128, allowed))\n                let o := add(s, 0x20)\n                for { let end := add(o, mload(s)) } 1 {} {\n                    result := and(result, shr(byte(0, mload(o)), allowed_))\n                    o := add(o, 1)\n                    if iszero(and(result, lt(o, end))) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Converts the bytes in the 7-bit ASCII string `s` to\n    /// an allowed lookup for use in `is7BitASCII(s, allowed)`.\n    /// To save runtime gas, you can cache the result in an immutable variable.\n    function to7BitASCIIAllowedLookup(string memory s) internal pure returns (uint128 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                let o := add(s, 0x20)\n                for { let end := add(o, mload(s)) } 1 {} {\n                    result := or(result, shl(byte(0, mload(o)), 1))\n                    o := add(o, 1)\n                    if iszero(lt(o, end)) { break }\n                }\n                if shr(128, result) {\n                    mstore(0x00, 0xc9807e0d) // `StringNot7BitASCII()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                   BYTE STRING OPERATIONS                   */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    // For performance and bytecode compactness, byte string operations are restricted\n    // to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.\n    // Usage of byte string operations on charsets with runes spanning two or more bytes\n    // can lead to undefined behavior.\n\n    /// @dev Returns `subject` all occurrences of `needle` replaced with `replacement`.\n    function replace(string memory subject, string memory needle, string memory replacement)\n        internal\n        pure\n        returns (string memory)\n    {\n        return string(LibBytes.replace(bytes(subject), bytes(needle), bytes(replacement)));\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function indexOf(string memory subject, string memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return LibBytes.indexOf(bytes(subject), bytes(needle), from);\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function indexOf(string memory subject, string memory needle) internal pure returns (uint256) {\n        return LibBytes.indexOf(bytes(subject), bytes(needle), 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function lastIndexOf(string memory subject, string memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return LibBytes.lastIndexOf(bytes(subject), bytes(needle), from);\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function lastIndexOf(string memory subject, string memory needle)\n        internal\n        pure\n        returns (uint256)\n    {\n        return LibBytes.lastIndexOf(bytes(subject), bytes(needle), type(uint256).max);\n    }\n\n    /// @dev Returns true if `needle` is found in `subject`, false otherwise.\n    function contains(string memory subject, string memory needle) internal pure returns (bool) {\n        return LibBytes.contains(bytes(subject), bytes(needle));\n    }\n\n    /// @dev Returns whether `subject` starts with `needle`.\n    function startsWith(string memory subject, string memory needle) internal pure returns (bool) {\n        return LibBytes.startsWith(bytes(subject), bytes(needle));\n    }\n\n    /// @dev Returns whether `subject` ends with `needle`.\n    function endsWith(string memory subject, string memory needle) internal pure returns (bool) {\n        return LibBytes.endsWith(bytes(subject), bytes(needle));\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(string memory subject, uint256 times) internal pure returns (string memory) {\n        return string(LibBytes.repeat(bytes(subject), times));\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(string memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (string memory)\n    {\n        return string(LibBytes.slice(bytes(subject), start, end));\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\n    /// `start` is a byte offset.\n    function slice(string memory subject, uint256 start) internal pure returns (string memory) {\n        return string(LibBytes.slice(bytes(subject), start, type(uint256).max));\n    }\n\n    /// @dev Returns all the indices of `needle` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(string memory subject, string memory needle)\n        internal\n        pure\n        returns (uint256[] memory)\n    {\n        return LibBytes.indicesOf(bytes(subject), bytes(needle));\n    }\n\n    /// @dev Returns an arrays of strings based on the `delimiter` inside of the `subject` string.\n    function split(string memory subject, string memory delimiter)\n        internal\n        pure\n        returns (string[] memory result)\n    {\n        bytes[] memory a = LibBytes.split(bytes(subject), bytes(delimiter));\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n        }\n    }\n\n    /// @dev Returns a concatenated string of `a` and `b`.\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\n    function concat(string memory a, string memory b) internal pure returns (string memory) {\n        return string(LibBytes.concat(bytes(a), bytes(b)));\n    }\n\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function toCase(string memory subject, bool toUpper)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(subject)\n            if n {\n                result := mload(0x40)\n                let o := add(result, 0x20)\n                let d := sub(subject, result)\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\n                for { let end := add(o, n) } 1 {} {\n                    let b := byte(0, mload(add(d, o)))\n                    mstore8(o, xor(and(shr(b, flags), 0x20), b))\n                    o := add(o, 1)\n                    if eq(o, end) { break }\n                }\n                mstore(result, n) // Store the length.\n                mstore(o, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\n            }\n        }\n    }\n\n    /// @dev Returns a string from a small bytes32 string.\n    /// `s` must be null-terminated, or behavior will be undefined.\n    function fromSmallString(bytes32 s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let n := 0\n            for {} byte(n, s) { n := add(n, 1) } {} // Scan for '\\0'.\n            mstore(result, n) // Store the length.\n            let o := add(result, 0x20)\n            mstore(o, s) // Store the bytes of the string.\n            mstore(add(o, n), 0) // Zeroize the slot after the string.\n            mstore(0x40, add(result, 0x40)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the small string, with all bytes after the first null byte zeroized.\n    function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} byte(result, s) { result := add(result, 1) } {} // Scan for '\\0'.\n            mstore(0x00, s)\n            mstore(result, 0x00)\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Returns the string as a normalized null-terminated small string.\n    function toSmallString(string memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(s)\n            if iszero(lt(result, 33)) {\n                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\n                revert(0x1c, 0x04)\n            }\n            result := shl(shl(3, sub(32, result)), mload(add(s, result)))\n        }\n    }\n\n    /// @dev Returns a lowercased copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function lower(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, false);\n    }\n\n    /// @dev Returns an UPPERCASED copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function upper(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, true);\n    }\n\n    /// @dev Escapes the string to be used within HTML tags.\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let end := add(s, mload(s))\n            let o := add(result, 0x20)\n            // Store the bytes of the packed offsets and strides into the scratch space.\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\n            mstore(0x1f, 0x900094)\n            mstore(0x08, 0xc0000000a6ab)\n            // Store \"&quot;&amp;&#39;&lt;&gt;\" into the scratch space.\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\n            for {} iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // Not in `[\"\\\"\",\"'\",\"&\",\"<\",\">\"]`.\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\n                    mstore8(o, c)\n                    o := add(o, 1)\n                    continue\n                }\n                let t := shr(248, mload(c))\n                mstore(o, mload(and(t, 0x1f)))\n                o := add(o, shr(5, t))\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\n    function escapeJSON(string memory s, bool addDoubleQuotes)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let o := add(result, 0x20)\n            if addDoubleQuotes {\n                mstore8(o, 34)\n                o := add(1, o)\n            }\n            // Store \"\\\\u0000\" in scratch space.\n            // Store \"0123456789abcdef\" in scratch space.\n            // Also, store `{0x08:\"b\", 0x09:\"t\", 0x0a:\"n\", 0x0c:\"f\", 0x0d:\"r\"}`.\n            // into the scratch space.\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\n            // Bitmask for detecting `[\"\\\"\",\"\\\\\"]`.\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\n            for { let end := add(s, mload(s)) } iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                if iszero(lt(c, 0x20)) {\n                    if iszero(and(shl(c, 1), e)) {\n                        // Not in `[\"\\\"\",\"\\\\\"]`.\n                        mstore8(o, c)\n                        o := add(o, 1)\n                        continue\n                    }\n                    mstore8(o, 0x5c) // \"\\\\\".\n                    mstore8(add(o, 1), c)\n                    o := add(o, 2)\n                    continue\n                }\n                if iszero(and(shl(c, 1), 0x3700)) {\n                    // Not in `[\"\\b\",\"\\t\",\"\\n\",\"\\f\",\"\\d\"]`.\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\n                    mstore(o, mload(0x19)) // \"\\\\u00XX\".\n                    o := add(o, 6)\n                    continue\n                }\n                mstore8(o, 0x5c) // \"\\\\\".\n                mstore8(add(o, 1), mload(add(c, 8)))\n                o := add(o, 2)\n            }\n            if addDoubleQuotes {\n                mstore8(o, 34)\n                o := add(1, o)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\n        result = escapeJSON(s, false);\n    }\n\n    /// @dev Encodes `s` so that it can be safely used in a URI,\n    /// just like `encodeURIComponent` in JavaScript.\n    /// See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\n    /// See: https://datatracker.ietf.org/doc/html/rfc2396\n    /// See: https://datatracker.ietf.org/doc/html/rfc3986\n    function encodeURIComponent(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            // Store \"0123456789ABCDEF\" in scratch space.\n            // Uppercased to be consistent with JavaScript's implementation.\n            mstore(0x0f, 0x30313233343536373839414243444546)\n            let o := add(result, 0x20)\n            for { let end := add(s, mload(s)) } iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // If not in `[0-9A-Z-a-z-_.!~*'()]`.\n                if iszero(and(1, shr(c, 0x47fffffe87fffffe03ff678200000000))) {\n                    mstore8(o, 0x25) // '%'.\n                    mstore8(add(o, 1), mload(and(shr(4, c), 15)))\n                    mstore8(add(o, 2), mload(and(c, 15)))\n                    o := add(o, 3)\n                    continue\n                }\n                mstore8(o, c)\n                o := add(o, 1)\n            }\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`.\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small string.\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // These should be evaluated on compile time, as far as possible.\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\n            let x := not(or(m, or(b, add(m, and(b, m)))))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\n        }\n    }\n\n    /// @dev Returns 0 if `a == b`, -1 if `a < b`, +1 if `a > b`.\n    /// If `a` == b[:a.length]`, and `a.length < b.length`, returns -1.\n    function cmp(string memory a, string memory b) internal pure returns (int256) {\n        return LibBytes.cmp(bytes(a), bytes(b));\n    }\n\n    /// @dev Packs a single string with its length into a single word.\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\n    function packOne(string memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We don't need to zero right pad the string,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes.\n                    mload(add(a, 0x1f)),\n                    // `length != 0 && length < 32`. Abuses underflow.\n                    // Assumes that the length is valid and within the block gas limit.\n                    lt(sub(mload(a), 1), 0x1f)\n                )\n        }\n    }\n\n    /// @dev Unpacks a string packed using {packOne}.\n    /// Returns the empty string if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40) // Grab the free memory pointer.\n            mstore(0x40, add(result, 0x40)) // Allocate 2 words (1 for the length, 1 for the bytes).\n            mstore(result, 0) // Zeroize the length slot.\n            mstore(add(result, 0x1f), packed) // Store the length and bytes.\n            mstore(add(add(result, 0x20), mload(result)), 0) // Right pad with zeroes.\n        }\n    }\n\n    /// @dev Packs two strings with their lengths into a single word.\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLen := mload(a)\n            // We don't need to zero right pad the strings,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    or( // Load the length and the bytes of `a` and `b`.\n                    shl(shl(3, sub(0x1f, aLen)), mload(add(a, aLen))), mload(sub(add(b, 0x1e), aLen))),\n                    // `totalLen != 0 && totalLen < 31`. Abuses underflow.\n                    // Assumes that the lengths are valid and within the block gas limit.\n                    lt(sub(add(aLen, mload(b)), 1), 0x1e)\n                )\n        }\n    }\n\n    /// @dev Unpacks strings packed using {packTwo}.\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\n    function unpackTwo(bytes32 packed)\n        internal\n        pure\n        returns (string memory resultA, string memory resultB)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            resultA := mload(0x40) // Grab the free memory pointer.\n            resultB := add(resultA, 0x40)\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\n            mstore(0x40, add(resultB, 0x40))\n            // Zeroize the length slots.\n            mstore(resultA, 0)\n            mstore(resultB, 0)\n            // Store the lengths and bytes.\n            mstore(add(resultA, 0x1f), packed)\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\n            // Right pad with zeroes.\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(string memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Assumes that the string does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retUnpaddedSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the string is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retUnpaddedSize), 0)\n            mstore(retStart, 0x20) // Store the return offset.\n            // End the transaction, returning the string.\n            return(retStart, and(not(0x1f), add(0x1f, retUnpaddedSize)))\n        }\n    }\n}\n"}, "lib/solady/src/utils/MetadataReaderLib.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Library for reading contract metadata robustly.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/MetadataReaderLib.sol)\nlibrary MetadataReaderLib {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         CONSTANTS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Default gas stipend for contract reads. High enough for most practical use cases\n    /// (able to SLOAD about 1000 bytes of data), but low enough to prevent griefing.\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\n\n    /// @dev Default string byte length limit.\n    uint256 internal constant STRING_LIMIT_DEFAULT = 1000;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                METADATA READING OPERATIONS                 */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    // Best-effort string reading operations.\n    // Should NOT revert as long as sufficient gas is provided.\n    //\n    // Performs the following in order:\n    // 1. Returns the empty string for the following cases:\n    //     - Reverts.\n    //     - No returndata (e.g. function returns nothing, EOA).\n    //     - Returns empty string.\n    // 2. Attempts to `abi.decode` the returndata into a string.\n    // 3. With any remaining gas, scans the returndata from start to end for the\n    //    null byte '\\0', to interpret the returndata as a null-terminated string.\n\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\"name()\"))`.\n    function readName(address target) internal view returns (string memory) {\n        return _string(target, _ptr(0x06fdde03), STRING_LIMIT_DEFAULT, GAS_STIPEND_NO_GRIEF);\n    }\n\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\"name()\"), limit)`.\n    function readName(address target, uint256 limit) internal view returns (string memory) {\n        return _string(target, _ptr(0x06fdde03), limit, GAS_STIPEND_NO_GRIEF);\n    }\n\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\"name()\"), limit, gasStipend)`.\n    function readName(address target, uint256 limit, uint256 gasStipend)\n        internal\n        view\n        returns (string memory)\n    {\n        return _string(target, _ptr(0x06fdde03), limit, gasStipend);\n    }\n\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\"symbol()\"))`.\n    function readSymbol(address target) internal view returns (string memory) {\n        return _string(target, _ptr(0x95d89b41), STRING_LIMIT_DEFAULT, GAS_STIPEND_NO_GRIEF);\n    }\n\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\"symbol()\"), limit)`.\n    function readSymbol(address target, uint256 limit) internal view returns (string memory) {\n        return _string(target, _ptr(0x95d89b41), limit, GAS_STIPEND_NO_GRIEF);\n    }\n\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\"symbol()\"), limit, gasStipend)`.\n    function readSymbol(address target, uint256 limit, uint256 gasStipend)\n        internal\n        view\n        returns (string memory)\n    {\n        return _string(target, _ptr(0x95d89b41), limit, gasStipend);\n    }\n\n    /// @dev Performs a best-effort string query on `target` with `data` as the calldata.\n    /// The string will be truncated to `STRING_LIMIT_DEFAULT` (1000) bytes.\n    function readString(address target, bytes memory data) internal view returns (string memory) {\n        return _string(target, _ptr(data), STRING_LIMIT_DEFAULT, GAS_STIPEND_NO_GRIEF);\n    }\n\n    /// @dev Performs a best-effort string query on `target` with `data` as the calldata.\n    /// The string will be truncated to `limit` bytes.\n    function readString(address target, bytes memory data, uint256 limit)\n        internal\n        view\n        returns (string memory)\n    {\n        return _string(target, _ptr(data), limit, GAS_STIPEND_NO_GRIEF);\n    }\n\n    /// @dev Performs a best-effort string query on `target` with `data` as the calldata.\n    /// The string will be truncated to `limit` bytes.\n    function readString(address target, bytes memory data, uint256 limit, uint256 gasStipend)\n        internal\n        view\n        returns (string memory)\n    {\n        return _string(target, _ptr(data), limit, gasStipend);\n    }\n\n    // Best-effort unsigned integer reading operations.\n    // Should NOT revert as long as sufficient gas is provided.\n    //\n    // Performs the following in order:\n    // 1. Attempts to `abi.decode` the result into a uint256\n    //    (equivalent across all Solidity uint types, downcast as needed).\n    // 2. Returns zero for the following cases:\n    //     - Reverts.\n    //     - No returndata (e.g. function returns nothing, EOA).\n    //     - Returns zero.\n    //     - `abi.decode` failure.\n\n    /// @dev Equivalent to `uint8(readUint(abi.encodeWithSignature(\"decimals()\")))`.\n    function readDecimals(address target) internal view returns (uint8) {\n        return uint8(_uint(target, _ptr(0x313ce567), GAS_STIPEND_NO_GRIEF));\n    }\n\n    /// @dev Equivalent to `uint8(readUint(abi.encodeWithSignature(\"decimals()\"), gasStipend))`.\n    function readDecimals(address target, uint256 gasStipend) internal view returns (uint8) {\n        return uint8(_uint(target, _ptr(0x313ce567), gasStipend));\n    }\n\n    /// @dev Performs a best-effort uint query on `target` with `data` as the calldata.\n    function readUint(address target, bytes memory data) internal view returns (uint256) {\n        return _uint(target, _ptr(data), GAS_STIPEND_NO_GRIEF);\n    }\n\n    /// @dev Performs a best-effort uint query on `target` with `data` as the calldata.\n    function readUint(address target, bytes memory data, uint256 gasStipend)\n        internal\n        view\n        returns (uint256)\n    {\n        return _uint(target, _ptr(data), gasStipend);\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Attempts to read and return a string at `target`.\n    function _string(address target, bytes32 ptr, uint256 limit, uint256 gasStipend)\n        private\n        view\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function min(x_, y_) -> _z {\n                _z := xor(x_, mul(xor(x_, y_), lt(y_, x_)))\n            }\n            for {} staticcall(gasStipend, target, add(ptr, 0x20), mload(ptr), 0x00, 0x20) {} {\n                let m := mload(0x40) // Grab the free memory pointer.\n                let s := add(0x20, m) // Start of the string's bytes in memory.\n                // Attempt to `abi.decode` if the returndatasize is greater or equal to 64.\n                if iszero(lt(returndatasize(), 0x40)) {\n                    let o := mload(0x00) // Load the string's offset in the returndata.\n                    // If the string's offset is within bounds.\n                    if iszero(gt(o, sub(returndatasize(), 0x20))) {\n                        returndatacopy(m, o, 0x20) // Copy the string's length.\n                        // If the full string's end is within bounds.\n                        // Note: If the full string doesn't fit, the `abi.decode` must be aborted\n                        // for compliance purposes, regardless if the truncated string can fit.\n                        if iszero(gt(mload(m), sub(returndatasize(), add(o, 0x20)))) {\n                            let n := min(mload(m), limit) // Truncate if needed.\n                            mstore(m, n) // Overwrite the length.\n                            returndatacopy(s, add(o, 0x20), n) // Copy the string's bytes.\n                            mstore(add(s, n), 0) // Zeroize the slot after the string.\n                            mstore(0x40, add(0x20, add(s, n))) // Allocate memory for the string.\n                            result := m\n                            break\n                        }\n                    }\n                }\n                // Try interpreting as a null-terminated string.\n                let n := min(returndatasize(), limit) // Truncate if needed.\n                returndatacopy(s, 0, n) // Copy the string's bytes.\n                mstore8(add(s, n), 0) // Place a '\\0' at the end.\n                let i := s // Pointer to the next byte to scan.\n                for {} byte(0, mload(i)) { i := add(i, 1) } {} // Scan for '\\0'.\n                mstore(m, sub(i, s)) // Store the string's length.\n                mstore(i, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(0x20, i)) // Allocate memory for the string.\n                result := m\n                break\n            }\n        }\n    }\n\n    /// @dev Attempts to read and return a uint at `target`.\n    function _uint(address target, bytes32 ptr, uint256 gasStipend)\n        private\n        view\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result :=\n                mul(\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gasStipend, target, add(ptr, 0x20), mload(ptr), 0x20, 0x20)\n                    )\n                )\n        }\n    }\n\n    /// @dev Casts the function selector `s` into a pointer.\n    function _ptr(uint256 s) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Layout the calldata in the scratch space for temporary usage.\n            mstore(0x04, s) // Store the function selector.\n            mstore(result, 4) // Store the length.\n        }\n    }\n\n    /// @dev Casts the `data` into a pointer.\n    function _ptr(bytes memory data) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := data\n        }\n    }\n}\n"}, "lib/solady/src/utils/Base64.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Library to encode strings in Base64.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\n/// @author Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos - <brecht@loopring.org>.\nlibrary Base64 {\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\n    /// @param noPadding Whether to strip away the padding.\n    function encode(bytes memory data, bool fileSafe, bool noPadding)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                // Multiply by 4/3 rounded up.\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\n\n                // Set `result` to point to the start of the free memory.\n                result := mload(0x40)\n\n                // Store the table into the scratch space.\n                // Offsetted by -1 byte so that the `mload` will load the character.\n                // We will rewrite the free memory pointer at `0x40` later with\n                // the allocated size.\n                // The magic constant 0x0670 will turn \"-_\" into \"+/\".\n                mstore(0x1f, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\")\n                mstore(0x3f, xor(\"ghijklmnopqrstuvwxyz0123456789-_\", mul(iszero(fileSafe), 0x0670)))\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, encodedLength)\n\n                let dataEnd := add(add(0x20, data), dataLength)\n                let dataEndValue := mload(dataEnd) // Cache the value at the `dataEnd` slot.\n                mstore(dataEnd, 0x00) // Zeroize the `dataEnd` slot to clear dirty bits.\n\n                // Run over the input, 3 bytes at a time.\n                for {} 1 {} {\n                    data := add(data, 3) // Advance 3 bytes.\n                    let input := mload(data)\n\n                    // Write 4 bytes. Optimized for fewer stack operations.\n                    mstore8(0, mload(and(shr(18, input), 0x3F)))\n                    mstore8(1, mload(and(shr(12, input), 0x3F)))\n                    mstore8(2, mload(and(shr(6, input), 0x3F)))\n                    mstore8(3, mload(and(input, 0x3F)))\n                    mstore(ptr, mload(0x00))\n\n                    ptr := add(ptr, 4) // Advance 4 bytes.\n                    if iszero(lt(ptr, end)) { break }\n                }\n                mstore(dataEnd, dataEndValue) // Restore the cached value at `dataEnd`.\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\n                // Equivalent to `o = [0, 2, 1][dataLength % 3]`.\n                let o := div(2, mod(dataLength, 3))\n                // Offset `ptr` and pad with '='. We can simply write over the end.\n                mstore(sub(ptr, o), shl(240, 0x3d3d))\n                // Set `o` to zero if there is padding.\n                o := mul(iszero(iszero(noPadding)), o)\n                mstore(sub(ptr, o), 0) // Zeroize the slot after the string.\n                mstore(result, sub(encodedLength, o)) // Store the length.\n            }\n        }\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, false, false)`.\n    function encode(bytes memory data) internal pure returns (string memory result) {\n        result = encode(data, false, false);\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, fileSafe, false)`.\n    function encode(bytes memory data, bool fileSafe)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = encode(data, fileSafe, false);\n    }\n\n    /// @dev Decodes base64 encoded `data`.\n    ///\n    /// Supports:\n    /// - RFC 4648 (both standard and file-safe mode).\n    /// - RFC 3501 (63: ',').\n    ///\n    /// Does not support:\n    /// - Line breaks.\n    ///\n    /// Note: For performance reasons,\n    /// this function will NOT revert on invalid `data` inputs.\n    /// Outputs for invalid inputs will simply be undefined behaviour.\n    /// It is the user's responsibility to ensure that the `data`\n    /// is a valid base64 encoded string.\n    function decode(string memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                let decodedLength := mul(shr(2, dataLength), 3)\n\n                for {} 1 {} {\n                    // If padded.\n                    if iszero(and(dataLength, 3)) {\n                        let t := xor(mload(add(data, dataLength)), 0x3d3d)\n                        // forgefmt: disable-next-item\n                        decodedLength := sub(\n                            decodedLength,\n                            add(iszero(byte(30, t)), iszero(byte(31, t)))\n                        )\n                        break\n                    }\n                    // If non-padded.\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\n                    break\n                }\n                result := mload(0x40)\n\n                // Write the length of the bytes.\n                mstore(result, decodedLength)\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, decodedLength)\n\n                // Load the table into the scratch space.\n                // Constants are optimized for smaller bytecode with zero gas overhead.\n                // `m` also doubles as the mask of the upper 6 bits.\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\n                mstore(0x5b, m)\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\n\n                for {} 1 {} {\n                    // Read 4 bytes.\n                    data := add(data, 4)\n                    let input := mload(data)\n\n                    // Write 3 bytes.\n                    // forgefmt: disable-next-item\n                    mstore(ptr, or(\n                        and(m, mload(byte(28, input))),\n                        shr(6, or(\n                            and(m, mload(byte(29, input))),\n                            shr(6, or(\n                                and(m, mload(byte(30, input))),\n                                shr(6, mload(byte(31, input)))\n                            ))\n                        ))\n                    ))\n                    ptr := add(ptr, 3)\n                    if iszero(lt(ptr, end)) { break }\n                }\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\n                mstore(end, 0) // Zeroize the slot after the bytes.\n                mstore(0x60, 0) // Restore the zero slot.\n            }\n        }\n    }\n}\n"}, "src/types/ForcedWithdrawalStatus.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nenum ForcedWithdrawalStatus {\n    Disabled, // Not pending or enabled for forced withdrawal\n    Pending, // Not yet available, but initiated\n    Enabled // Available for forced withdrawal on demand\n\n}\n"}, "src/types/EmissaryStatus.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nenum EmissaryStatus {\n    Disabled, // Not pending or enabled for forced withdrawal\n    Scheduled, // Available but scheduled\n    Enabled // Available for forced withdrawal on demand\n\n}\n\nstruct EmissaryConfig {\n    // 20 bytes\n    address emissary; // address of the sponsor's emissary\n    // 12 bytes\n    uint96 assignableAt; // timestamp after which an emissary can be re-assigned\n}\n"}, "src/types/CompactCategory.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nenum CompactCategory {\n    Compact,\n    BatchCompact,\n    MultichainCompact\n}\n"}, "lib/permit2/src/interfaces/ISignatureTransfer.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IEIP712} from \"./IEIP712.sol\";\n\n/// @title SignatureTransfer\n/// @notice Handles ERC20 token transfers through signature based actions\n/// @dev Requires user's token approval on the Permit2 contract\ninterface ISignatureTransfer is IEIP712 {\n    /// @notice Thrown when the requested amount for a transfer is larger than the permissioned amount\n    /// @param maxAmount The maximum amount a spender can request to transfer\n    error InvalidAmount(uint256 maxAmount);\n\n    /// @notice Thrown when the number of tokens permissioned to a spender does not match the number of tokens being transferred\n    /// @dev If the spender does not need to transfer the number of tokens permitted, the spender can request amount 0 to be transferred\n    error LengthMismatch();\n\n    /// @notice Emits an event when the owner successfully invalidates an unordered nonce.\n    event UnorderedNonceInvalidation(address indexed owner, uint256 word, uint256 mask);\n\n    /// @notice The token and amount details for a transfer signed in the permit transfer signature\n    struct TokenPermissions {\n        // ERC20 token address\n        address token;\n        // the maximum amount that can be spent\n        uint256 amount;\n    }\n\n    /// @notice The signed permit message for a single token transfer\n    struct PermitTransferFrom {\n        TokenPermissions permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice Specifies the recipient address and amount for batched transfers.\n    /// @dev Recipients and amounts correspond to the index of the signed token permissions array.\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount.\n    struct SignatureTransferDetails {\n        // recipient address\n        address to;\n        // spender requested amount\n        uint256 requestedAmount;\n    }\n\n    /// @notice Used to reconstruct the signed permit message for multiple token transfers\n    /// @dev Do not need to pass in spender address as it is required that it is msg.sender\n    /// @dev Note that a user still signs over a spender address\n    struct PermitBatchTransferFrom {\n        // the tokens and corresponding amounts permitted for a transfer\n        TokenPermissions[] permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice A map from token owner address and a caller specified word index to a bitmap. Used to set bits in the bitmap to prevent against signature replay protection\n    /// @dev Uses unordered nonces so that permit messages do not need to be spent in a certain order\n    /// @dev The mapping is indexed first by the token owner, then by an index specified in the nonce\n    /// @dev It returns a uint256 bitmap\n    /// @dev The index, or wordPosition is capped at type(uint248).max\n    function nonceBitmap(address, uint256) external view returns (uint256);\n\n    /// @notice Transfers a token using a signed permit message\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers a token using a signed permit message\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Invalidates the bits specified in mask for the bitmap at the word position\n    /// @dev The wordPos is maxed at type(uint248).max\n    /// @param wordPos A number to index the nonceBitmap at\n    /// @param mask A bitmap masked against msg.sender's current bitmap at the word position\n    function invalidateUnorderedNonces(uint256 wordPos, uint256 mask) external;\n}\n"}, "src/types/Claims.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { Component } from \"./Components.sol\";\n\nstruct AllocatedTransfer {\n    bytes allocatorData; // Authorization from the allocator.\n    uint256 nonce; // A parameter to enforce replay protection, scoped to allocator.\n    uint256 expires; // The time at which the transfer or withdrawal expires.\n    uint256 id; // The token ID of the ERC6909 token to transfer or withdraw.\n    Component[] recipients; // The recipients and amounts of each transfer.\n}\n\nstruct Claim {\n    bytes allocatorData; // Authorization from the allocator.\n    bytes sponsorSignature; // Authorization from the sponsor.\n    address sponsor; // The account to source the tokens from.\n    uint256 nonce; // A parameter to enforce replay protection, scoped to allocator.\n    uint256 expires; // The time at which the claim expires.\n    bytes32 witness; // Hash of the witness data.\n    string witnessTypestring; // Witness typestring appended to existing typestring.\n    uint256 id; // The token ID of the ERC6909 token to allocate.\n    uint256 allocatedAmount; // The original allocated amount of ERC6909 tokens.\n    Component[] claimants; // The claim recipients and amounts; specified by the arbiter.\n}\n\nlibrary ClaimsLib {\n    /**\n     * @notice Returns the raw calldata pointer to the claim.\n     * @param claim The claim to get the raw pointer of.\n     * @return rawClaimPtr The raw pointer to the claim.\n     */\n    function asRawPtr(Claim calldata claim) internal pure returns (uint256 rawClaimPtr) {\n        assembly {\n            rawClaimPtr := claim\n        }\n    }\n}\n"}, "src/types/DepositDetails.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nstruct DepositDetails {\n    uint256 nonce;\n    uint256 deadline;\n    bytes12 lockTag;\n}\n"}, "src/types/BatchClaims.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { ComponentsById, BatchClaimComponent } from \"./Components.sol\";\n\nstruct AllocatedBatchTransfer {\n    bytes allocatorData; // Authorization from the allocator.\n    uint256 nonce; // A parameter to enforce replay protection, scoped to allocator.\n    uint256 expires; // The time at which the transfer or withdrawal expires.\n    ComponentsById[] transfers; // The recipients and amounts of each transfer for each ID.\n}\n\nstruct BatchClaim {\n    bytes allocatorData; // Authorization from the allocator.\n    bytes sponsorSignature; // Authorization from the sponsor.\n    address sponsor; // The account to source the tokens from.\n    uint256 nonce; // A parameter to enforce replay protection, scoped to allocator.\n    uint256 expires; // The time at which the claim expires.\n    bytes32 witness; // Hash of the witness data.\n    string witnessTypestring; // Witness typestring appended to existing typestring.\n    BatchClaimComponent[] claims; // The claim token IDs, recipients and amounts.\n}\n\nlibrary BatchClaimsLib {\n    /**\n     * @notice Returns the raw calldata pointer to the batch claim.\n     * @param claim The batch claim to get the raw pointer of.\n     * @return rawClaimPtr The raw pointer to the batch claim.\n     */\n    function asRawPtr(BatchClaim calldata claim) internal pure returns (uint256 rawClaimPtr) {\n        assembly {\n            rawClaimPtr := claim\n        }\n    }\n}\n"}, "lib/solady/src/utils/EfficientHashLib.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Library for efficiently performing keccak256 hashes.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EfficientHashLib.sol)\n/// @dev To avoid stack-too-deep, you can use:\n/// ```\n/// bytes32[] memory buffer = EfficientHashLib.malloc(10);\n/// EfficientHashLib.set(buffer, 0, value0);\n/// ..\n/// EfficientHashLib.set(buffer, 9, value9);\n/// bytes32 finalHash = EfficientHashLib.hash(buffer);\n/// ```\nlibrary EfficientHashLib {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*               MALLOC-LESS HASHING OPERATIONS               */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns `keccak256(abi.encode(v0))`.\n    function hash(bytes32 v0) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            result := keccak256(0x00, 0x20)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0))`.\n    function hash(uint256 v0) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            result := keccak256(0x00, 0x20)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1))`.\n    function hash(bytes32 v0, bytes32 v1) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            mstore(0x20, v1)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1))`.\n    function hash(uint256 v0, uint256 v1) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            mstore(0x20, v1)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1, v2))`.\n    function hash(bytes32 v0, bytes32 v1, bytes32 v2) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            result := keccak256(m, 0x60)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1, v2))`.\n    function hash(uint256 v0, uint256 v1, uint256 v2) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            result := keccak256(m, 0x60)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1, v2, v3))`.\n    function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            result := keccak256(m, 0x80)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1, v2, v3))`.\n    function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            result := keccak256(m, 0x80)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v4))`.\n    function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            result := keccak256(m, 0xa0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v4))`.\n    function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            result := keccak256(m, 0xa0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v5))`.\n    function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            result := keccak256(m, 0xc0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v5))`.\n    function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            result := keccak256(m, 0xc0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v6))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            result := keccak256(m, 0xe0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v6))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            result := keccak256(m, 0xe0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v7))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            result := keccak256(m, 0x100)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v7))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            result := keccak256(m, 0x100)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v8))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            result := keccak256(m, 0x120)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v8))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            result := keccak256(m, 0x120)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v9))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            result := keccak256(m, 0x140)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v9))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            result := keccak256(m, 0x140)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v10))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            result := keccak256(m, 0x160)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v10))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            result := keccak256(m, 0x160)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v11))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10,\n        bytes32 v11\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            result := keccak256(m, 0x180)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v11))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10,\n        uint256 v11\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            result := keccak256(m, 0x180)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v12))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10,\n        bytes32 v11,\n        bytes32 v12\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            result := keccak256(m, 0x1a0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v12))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10,\n        uint256 v11,\n        uint256 v12\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            result := keccak256(m, 0x1a0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v13))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10,\n        bytes32 v11,\n        bytes32 v12,\n        bytes32 v13\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            mstore(add(m, 0x1a0), v13)\n            result := keccak256(m, 0x1c0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v13))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10,\n        uint256 v11,\n        uint256 v12,\n        uint256 v13\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            mstore(add(m, 0x1a0), v13)\n            result := keccak256(m, 0x1c0)\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*             BYTES32 BUFFER HASHING OPERATIONS              */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns `keccak256(abi.encode(buffer[0], .., buffer[buffer.length - 1]))`.\n    function hash(bytes32[] memory buffer) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(add(buffer, 0x20), shl(5, mload(buffer)))\n        }\n    }\n\n    /// @dev Sets `buffer[i]` to `value`, without a bounds check.\n    /// Returns the `buffer` for function chaining.\n    function set(bytes32[] memory buffer, uint256 i, bytes32 value)\n        internal\n        pure\n        returns (bytes32[] memory)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(buffer, shl(5, add(1, i))), value)\n        }\n        return buffer;\n    }\n\n    /// @dev Sets `buffer[i]` to `value`, without a bounds check.\n    /// Returns the `buffer` for function chaining.\n    function set(bytes32[] memory buffer, uint256 i, uint256 value)\n        internal\n        pure\n        returns (bytes32[] memory)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(buffer, shl(5, add(1, i))), value)\n        }\n        return buffer;\n    }\n\n    /// @dev Returns `new bytes32[](n)`, without zeroing out the memory.\n    function malloc(uint256 n) internal pure returns (bytes32[] memory buffer) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            buffer := mload(0x40)\n            mstore(buffer, n)\n            mstore(0x40, add(shl(5, add(1, n)), buffer))\n        }\n    }\n\n    /// @dev Frees memory that has been allocated for `buffer`.\n    /// No-op if `buffer.length` is zero, or if new memory has been allocated after `buffer`.\n    function free(bytes32[] memory buffer) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(buffer)\n            mstore(shl(6, lt(iszero(n), eq(add(shl(5, add(1, n)), buffer), mload(0x40)))), buffer)\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      EQUALITY CHECKS                       */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns `a == abi.decode(b, (bytes32))`.\n    function eq(bytes32 a, bytes memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(0x20, mload(b)), eq(a, mload(add(b, 0x20))))\n        }\n    }\n\n    /// @dev Returns `abi.decode(a, (bytes32)) == a`.\n    function eq(bytes memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(0x20, mload(a)), eq(b, mload(add(a, 0x20))))\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*               BYTE SLICE HASHING OPERATIONS                */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns the keccak256 of the slice from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function hash(bytes memory b, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            end := xor(end, mul(xor(end, n), lt(n, end)))\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            result := keccak256(add(add(b, 0x20), start), mul(gt(end, start), sub(end, start)))\n        }\n    }\n\n    /// @dev Returns the keccak256 of the slice from `start` to the end of the bytes.\n    function hash(bytes memory b, uint256 start) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            result := keccak256(add(add(b, 0x20), start), mul(gt(n, start), sub(n, start)))\n        }\n    }\n\n    /// @dev Returns the keccak256 of the bytes.\n    function hash(bytes memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(add(b, 0x20), mload(b))\n        }\n    }\n\n    /// @dev Returns the keccak256 of the slice from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function hashCalldata(bytes calldata b, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            end := xor(end, mul(xor(end, b.length), lt(b.length, end)))\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(end, start), sub(end, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := keccak256(mload(0x40), n)\n        }\n    }\n\n    /// @dev Returns the keccak256 of the slice from `start` to the end of the bytes.\n    function hashCalldata(bytes calldata b, uint256 start) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(b.length, start), sub(b.length, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := keccak256(mload(0x40), n)\n        }\n    }\n\n    /// @dev Returns the keccak256 of the bytes.\n    function hashCalldata(bytes calldata b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            calldatacopy(mload(0x40), b.offset, b.length)\n            result := keccak256(mload(0x40), b.length)\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      SHA2-256 HELPERS                      */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns `sha256(abi.encode(b))`. Yes, it's more efficient.\n    function sha2(bytes32 b) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, b)\n            result := mload(staticcall(gas(), 2, 0x00, 0x20, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the slice from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function sha2(bytes memory b, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            end := xor(end, mul(xor(end, n), lt(n, end)))\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            // forgefmt: disable-next-item\n            result := mload(staticcall(gas(), 2, add(add(b, 0x20), start),\n                mul(gt(end, start), sub(end, start)), 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the slice from `start` to the end of the bytes.\n    function sha2(bytes memory b, uint256 start) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            // forgefmt: disable-next-item\n            result := mload(staticcall(gas(), 2, add(add(b, 0x20), start),\n                mul(gt(n, start), sub(n, start)), 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the bytes.\n    function sha2(bytes memory b) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(staticcall(gas(), 2, add(b, 0x20), mload(b), 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the slice from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function sha2Calldata(bytes calldata b, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            end := xor(end, mul(xor(end, b.length), lt(b.length, end)))\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(end, start), sub(end, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := mload(staticcall(gas(), 2, mload(0x40), n, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the slice from `start` to the end of the bytes.\n    function sha2Calldata(bytes calldata b, uint256 start) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(b.length, start), sub(b.length, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := mload(staticcall(gas(), 2, mload(0x40), n, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the bytes.\n    function sha2Calldata(bytes calldata b) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            calldatacopy(mload(0x40), b.offset, b.length)\n            result := mload(staticcall(gas(), 2, mload(0x40), b.length, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n}\n"}, "lib/solady/src/utils/LibBytes.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @notice Library for byte related operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBytes.sol)\nlibrary LibBytes {\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                          STRUCTS                           */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Goated bytes storage struct that totally MOGs, no cap, fr.\n    /// Uses less gas and bytecode than Solidity's native bytes storage. It's meta af.\n    /// Packs length with the first 31 bytes if <255 bytes, so it\u2019s mad tight.\n    struct BytesStorage {\n        bytes32 _spacer;\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                         CONSTANTS                          */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev The constant returned when the `search` is not found in the bytes.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                  BYTE STORAGE OPERATIONS                   */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Sets the value of the bytes storage `$` to `s`.\n    function set(BytesStorage storage $, bytes memory s) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(s)\n            let packed := or(0xff, shl(8, n))\n            for { let i := 0 } 1 {} {\n                if iszero(gt(n, 0xfe)) {\n                    i := 0x1f\n                    packed := or(n, shl(8, mload(add(s, i))))\n                    if iszero(gt(n, i)) { break }\n                }\n                let o := add(s, 0x20)\n                mstore(0x00, $.slot)\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\n                    sstore(add(p, shr(5, i)), mload(add(o, i)))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, n)) { break }\n                }\n                break\n            }\n            sstore($.slot, packed)\n        }\n    }\n\n    /// @dev Sets the value of the bytes storage `$` to `s`.\n    function setCalldata(BytesStorage storage $, bytes calldata s) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let packed := or(0xff, shl(8, s.length))\n            for { let i := 0 } 1 {} {\n                if iszero(gt(s.length, 0xfe)) {\n                    i := 0x1f\n                    packed := or(s.length, shl(8, shr(8, calldataload(s.offset))))\n                    if iszero(gt(s.length, i)) { break }\n                }\n                mstore(0x00, $.slot)\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\n                    sstore(add(p, shr(5, i)), calldataload(add(s.offset, i)))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, s.length)) { break }\n                }\n                break\n            }\n            sstore($.slot, packed)\n        }\n    }\n\n    /// @dev Sets the value of the bytes storage `$` to the empty bytes.\n    function clear(BytesStorage storage $) internal {\n        delete $._spacer;\n    }\n\n    /// @dev Returns whether the value stored is `$` is the empty bytes \"\".\n    function isEmpty(BytesStorage storage $) internal view returns (bool) {\n        return uint256($._spacer) & 0xff == uint256(0);\n    }\n\n    /// @dev Returns the length of the value stored in `$`.\n    function length(BytesStorage storage $) internal view returns (uint256 result) {\n        result = uint256($._spacer);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := and(0xff, result)\n            result := or(mul(shr(8, result), eq(0xff, n)), mul(n, iszero(eq(0xff, n))))\n        }\n    }\n\n    /// @dev Returns the value stored in `$`.\n    function get(BytesStorage storage $) internal view returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let o := add(result, 0x20)\n            let packed := sload($.slot)\n            let n := shr(8, packed)\n            for { let i := 0 } 1 {} {\n                if iszero(eq(or(packed, 0xff), packed)) {\n                    mstore(o, packed)\n                    n := and(0xff, packed)\n                    i := 0x1f\n                    if iszero(gt(n, i)) { break }\n                }\n                mstore(0x00, $.slot)\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\n                    mstore(add(o, i), sload(add(p, shr(5, i))))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, n)) { break }\n                }\n                break\n            }\n            mstore(result, n) // Store the length of the memory.\n            mstore(add(o, n), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(o, n), 0x20)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the uint8 at index `i`. If out-of-bounds, returns 0.\n    function uint8At(BytesStorage storage $, uint256 i) internal view returns (uint8 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let packed := sload($.slot) } 1 {} {\n                if iszero(eq(or(packed, 0xff), packed)) {\n                    if iszero(gt(i, 0x1e)) {\n                        result := byte(i, packed)\n                        break\n                    }\n                    if iszero(gt(i, and(0xff, packed))) {\n                        mstore(0x00, $.slot)\n                        let j := sub(i, 0x1f)\n                        result := byte(and(j, 0x1f), sload(add(keccak256(0x00, 0x20), shr(5, j))))\n                    }\n                    break\n                }\n                if iszero(gt(i, shr(8, packed))) {\n                    mstore(0x00, $.slot)\n                    result := byte(and(i, 0x1f), sload(add(keccak256(0x00, 0x20), shr(5, i))))\n                }\n                break\n            }\n        }\n    }\n\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\n    /*                      BYTES OPERATIONS                      */\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\n\n    /// @dev Returns `subject` all occurrences of `needle` replaced with `replacement`.\n    function replace(bytes memory subject, bytes memory needle, bytes memory replacement)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let needleLen := mload(needle)\n            let replacementLen := mload(replacement)\n            let d := sub(result, subject) // Memory difference.\n            let i := add(subject, 0x20) // Subject bytes pointer.\n            mstore(0x00, add(i, mload(subject))) // End of subject.\n            if iszero(gt(needleLen, mload(subject))) {\n                let subjectSearchEnd := add(sub(mload(0x00), needleLen), 1)\n                let h := 0 // The hash of `needle`.\n                if iszero(lt(needleLen, 0x20)) { h := keccak256(add(needle, 0x20), needleLen) }\n                let s := mload(add(needle, 0x20))\n                for { let m := shl(3, sub(0x20, and(needleLen, 0x1f))) } 1 {} {\n                    let t := mload(i)\n                    // Whether the first `needleLen % 32` bytes of `subject` and `needle` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(i, needleLen), h)) {\n                                mstore(add(i, d), t)\n                                i := add(i, 1)\n                                if iszero(lt(i, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        for { let j := 0 } 1 {} {\n                            mstore(add(add(i, d), j), mload(add(add(replacement, 0x20), j)))\n                            j := add(j, 0x20)\n                            if iszero(lt(j, replacementLen)) { break }\n                        }\n                        d := sub(add(d, replacementLen), needleLen)\n                        if needleLen {\n                            i := add(i, needleLen)\n                            if iszero(lt(i, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(add(i, d), t)\n                    i := add(i, 1)\n                    if iszero(lt(i, subjectSearchEnd)) { break }\n                }\n            }\n            let end := mload(0x00)\n            let n := add(sub(d, add(result, 0x20)), end)\n            // Copy the rest of the bytes one word at a time.\n            for {} lt(i, end) { i := add(i, 0x20) } { mstore(add(i, d), mload(i)) }\n            let o := add(i, d)\n            mstore(o, 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function indexOf(bytes memory subject, bytes memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := not(0) // Initialize to `NOT_FOUND`.\n            for { let subjectLen := mload(subject) } 1 {} {\n                if iszero(mload(needle)) {\n                    result := from\n                    if iszero(gt(from, subjectLen)) { break }\n                    result := subjectLen\n                    break\n                }\n                let needleLen := mload(needle)\n                let subjectStart := add(subject, 0x20)\n\n                subject := add(subjectStart, from)\n                let end := add(sub(add(subjectStart, subjectLen), needleLen), 1)\n                let m := shl(3, sub(0x20, and(needleLen, 0x1f)))\n                let s := mload(add(needle, 0x20))\n\n                if iszero(and(lt(subject, end), lt(from, subjectLen))) { break }\n\n                if iszero(lt(needleLen, 0x20)) {\n                    for { let h := keccak256(add(needle, 0x20), needleLen) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, needleLen), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        if iszero(lt(subject, end)) { break }\n                    }\n                    break\n                }\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function indexOf(bytes memory subject, bytes memory needle) internal pure returns (uint256) {\n        return indexOf(subject, needle, 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function lastIndexOf(bytes memory subject, bytes memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := not(0) // Initialize to `NOT_FOUND`.\n                let needleLen := mload(needle)\n                if gt(needleLen, mload(subject)) { break }\n                let w := result\n\n                let fromMax := sub(mload(subject), needleLen)\n                if iszero(gt(fromMax, from)) { from := fromMax }\n\n                let end := add(add(subject, 0x20), w)\n                subject := add(add(subject, 0x20), from)\n                if iszero(gt(subject, end)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                for { let h := keccak256(add(needle, 0x20), needleLen) } 1 {} {\n                    if eq(keccak256(subject, needleLen), h) {\n                        result := sub(subject, add(end, 1))\n                        break\n                    }\n                    subject := add(subject, w) // `sub(subject, 1)`.\n                    if iszero(gt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function lastIndexOf(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (uint256)\n    {\n        return lastIndexOf(subject, needle, type(uint256).max);\n    }\n\n    /// @dev Returns true if `needle` is found in `subject`, false otherwise.\n    function contains(bytes memory subject, bytes memory needle) internal pure returns (bool) {\n        return indexOf(subject, needle) != NOT_FOUND;\n    }\n\n    /// @dev Returns whether `subject` starts with `needle`.\n    function startsWith(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(needle)\n            // Just using keccak256 directly is actually cheaper.\n            let t := eq(keccak256(add(subject, 0x20), n), keccak256(add(needle, 0x20), n))\n            result := lt(gt(n, mload(subject)), t)\n        }\n    }\n\n    /// @dev Returns whether `subject` ends with `needle`.\n    function endsWith(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(needle)\n            let notInRange := gt(n, mload(subject))\n            // `subject + 0x20 + max(subject.length - needle.length, 0)`.\n            let t := add(add(subject, 0x20), mul(iszero(notInRange), sub(mload(subject), n)))\n            // Just using keccak256 directly is actually cheaper.\n            result := gt(eq(keccak256(t, n), keccak256(add(needle, 0x20), n)), notInRange)\n        }\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(bytes memory subject, uint256 times)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := mload(subject) // Subject length.\n            if iszero(or(iszero(times), iszero(l))) {\n                result := mload(0x40)\n                subject := add(subject, 0x20)\n                let o := add(result, 0x20)\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    for { let j := 0 } 1 {} {\n                        mstore(add(o, j), mload(add(subject, j)))\n                        j := add(j, 0x20)\n                        if iszero(lt(j, l)) { break }\n                    }\n                    o := add(o, l)\n                    times := sub(times, 1)\n                    if iszero(times) { break }\n                }\n                mstore(o, 0) // Zeroize the slot after the bytes.\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\n                mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(bytes memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := mload(subject) // Subject length.\n            if iszero(gt(l, end)) { end := l }\n            if iszero(gt(l, start)) { start := l }\n            if lt(start, end) {\n                result := mload(0x40)\n                let n := sub(end, start)\n                let i := add(subject, start)\n                let w := not(0x1f)\n                // Copy the `subject` one word at a time, backwards.\n                for { let j := and(add(n, 0x1f), w) } 1 {} {\n                    mstore(add(result, j), mload(add(i, j)))\n                    j := add(j, w) // `sub(j, 0x20)`.\n                    if iszero(j) { break }\n                }\n                let o := add(add(result, 0x20), n)\n                mstore(o, 0) // Zeroize the slot after the bytes.\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\n                mstore(result, n) // Store the length.\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the bytes.\n    /// `start` is a byte offset.\n    function slice(bytes memory subject, uint256 start)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        result = slice(subject, start, type(uint256).max);\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets. Faster than Solidity's native slicing.\n    function sliceCalldata(bytes calldata subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            end := xor(end, mul(xor(end, subject.length), lt(subject.length, end)))\n            start := xor(start, mul(xor(start, subject.length), lt(subject.length, start)))\n            result.offset := add(subject.offset, start)\n            result.length := mul(lt(start, end), sub(end, start))\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the bytes.\n    /// `start` is a byte offset. Faster than Solidity's native slicing.\n    function sliceCalldata(bytes calldata subject, uint256 start)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            start := xor(start, mul(xor(start, subject.length), lt(subject.length, start)))\n            result.offset := add(subject.offset, start)\n            result.length := mul(lt(start, subject.length), sub(subject.length, start))\n        }\n    }\n\n    /// @dev Reduces the size of `subject` to `n`.\n    /// If `n` is greater than the size of `subject`, this will be a no-op.\n    function truncate(bytes memory subject, uint256 n)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := subject\n            mstore(mul(lt(n, mload(result)), result), n)\n        }\n    }\n\n    /// @dev Returns a copy of `subject`, with the length reduced to `n`.\n    /// If `n` is greater than the size of `subject`, this will be a no-op.\n    function truncatedCalldata(bytes calldata subject, uint256 n)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result.offset := subject.offset\n            result.length := xor(n, mul(xor(n, subject.length), lt(subject.length, n)))\n        }\n    }\n\n    /// @dev Returns all the indices of `needle` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLen := mload(needle)\n            if iszero(gt(searchLen, mload(subject))) {\n                result := mload(0x40)\n                let i := add(subject, 0x20)\n                let o := add(result, 0x20)\n                let subjectSearchEnd := add(sub(add(i, mload(subject)), searchLen), 1)\n                let h := 0 // The hash of `needle`.\n                if iszero(lt(searchLen, 0x20)) { h := keccak256(add(needle, 0x20), searchLen) }\n                let s := mload(add(needle, 0x20))\n                for { let m := shl(3, sub(0x20, and(searchLen, 0x1f))) } 1 {} {\n                    let t := mload(i)\n                    // Whether the first `searchLen % 32` bytes of `subject` and `needle` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(i, searchLen), h)) {\n                                i := add(i, 1)\n                                if iszero(lt(i, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        mstore(o, sub(i, add(subject, 0x20))) // Append to `result`.\n                        o := add(o, 0x20)\n                        i := add(i, searchLen) // Advance `i` by `searchLen`.\n                        if searchLen {\n                            if iszero(lt(i, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    i := add(i, 1)\n                    if iszero(lt(i, subjectSearchEnd)) { break }\n                }\n                mstore(result, shr(5, sub(o, add(result, 0x20)))) // Store the length of `result`.\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(o, 0x20))\n            }\n        }\n    }\n\n    /// @dev Returns an arrays of bytess based on the `delimiter` inside of the `subject` bytes.\n    function split(bytes memory subject, bytes memory delimiter)\n        internal\n        pure\n        returns (bytes[] memory result)\n    {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let indexPtr := add(indices, 0x20)\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n            mstore(add(indicesEnd, w), mload(subject))\n            mstore(indices, add(mload(indices), 1))\n            for { let prevIndex := 0 } 1 {} {\n                let index := mload(indexPtr)\n                mstore(indexPtr, 0x60)\n                if iszero(eq(index, prevIndex)) {\n                    let element := mload(0x40)\n                    let l := sub(index, prevIndex)\n                    mstore(element, l) // Store the length of the element.\n                    // Copy the `subject` one word at a time, backwards.\n                    for { let o := and(add(l, 0x1f), w) } 1 {} {\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                        o := add(o, w) // `sub(o, 0x20)`.\n                        if iszero(o) { break }\n                    }\n                    mstore(add(add(element, 0x20), l), 0) // Zeroize the slot after the bytes.\n                    // Allocate memory for the length and the bytes, rounded up to a multiple of 32.\n                    mstore(0x40, add(element, and(add(l, 0x3f), w)))\n                    mstore(indexPtr, element) // Store the `element` into the array.\n                }\n                prevIndex := add(index, mload(delimiter))\n                indexPtr := add(indexPtr, 0x20)\n                if iszero(lt(indexPtr, indicesEnd)) { break }\n            }\n            result := indices\n            if iszero(mload(delimiter)) {\n                result := add(indices, 0x20)\n                mstore(result, sub(mload(indices), 2))\n            }\n        }\n    }\n\n    /// @dev Returns a concatenated bytes of `a` and `b`.\n    /// Cheaper than `bytes.concat()` and does not de-align the free memory pointer.\n    function concat(bytes memory a, bytes memory b) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let w := not(0x1f)\n            let aLen := mload(a)\n            // Copy `a` one word at a time, backwards.\n            for { let o := and(add(aLen, 0x20), w) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let bLen := mload(b)\n            let output := add(result, aLen)\n            // Copy `b` one word at a time, backwards.\n            for { let o := and(add(bLen, 0x20), w) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let totalLen := add(aLen, bLen)\n            let last := add(add(result, 0x20), totalLen)\n            mstore(last, 0) // Zeroize the slot after the bytes.\n            mstore(result, totalLen) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`.\n    function eq(bytes memory a, bytes memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small bytes.\n    function eqs(bytes memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // These should be evaluated on compile time, as far as possible.\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\n            let x := not(or(m, or(b, add(m, and(b, m)))))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\n        }\n    }\n\n    /// @dev Returns 0 if `a == b`, -1 if `a < b`, +1 if `a > b`.\n    /// If `a` == b[:a.length]`, and `a.length < b.length`, returns -1.\n    function cmp(bytes memory a, bytes memory b) internal pure returns (int256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLen := mload(a)\n            let bLen := mload(b)\n            let n := and(xor(aLen, mul(xor(aLen, bLen), lt(bLen, aLen))), not(0x1f))\n            if n {\n                for { let i := 0x20 } 1 {} {\n                    let x := mload(add(a, i))\n                    let y := mload(add(b, i))\n                    if iszero(or(xor(x, y), eq(i, n))) {\n                        i := add(i, 0x20)\n                        continue\n                    }\n                    result := sub(gt(x, y), lt(x, y))\n                    break\n                }\n            }\n            // forgefmt: disable-next-item\n            if iszero(result) {\n                let l := 0x201f1e1d1c1b1a191817161514131211100f0e0d0c0b0a090807060504030201\n                let x := and(mload(add(add(a, 0x20), n)), shl(shl(3, byte(sub(aLen, n), l)), not(0)))\n                let y := and(mload(add(add(b, 0x20), n)), shl(shl(3, byte(sub(bLen, n), l)), not(0)))\n                result := sub(gt(x, y), lt(x, y))\n                if iszero(result) { result := sub(gt(aLen, bLen), lt(aLen, bLen)) }\n            }\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(bytes memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Assumes that the bytes does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retUnpaddedSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the bytes is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retUnpaddedSize), 0)\n            mstore(retStart, 0x20) // Store the return offset.\n            // End the transaction, returning the bytes.\n            return(retStart, and(not(0x1f), add(0x1f, retUnpaddedSize)))\n        }\n    }\n\n    /// @dev Directly returns `a` with minimal copying.\n    function directReturn(bytes[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a) // `a.length`.\n            let o := add(a, 0x20) // Start of elements in `a`.\n            let u := a // Highest memory slot.\n            let w := not(0x1f)\n            for { let i := 0 } iszero(eq(i, n)) { i := add(i, 1) } {\n                let c := add(o, shl(5, i)) // Location of pointer to `a[i]`.\n                let s := mload(c) // `a[i]`.\n                let l := mload(s) // `a[i].length`.\n                let r := and(l, 0x1f) // `a[i].length % 32`.\n                let z := add(0x20, and(l, w)) // Offset of last word in `a[i]` from `s`.\n                // If `s` comes before `o`, or `s` is not zero right padded.\n                if iszero(lt(lt(s, o), or(iszero(r), iszero(shl(shl(3, r), mload(add(s, z))))))) {\n                    let m := mload(0x40)\n                    mstore(m, l) // Copy `a[i].length`.\n                    for {} 1 {} {\n                        mstore(add(m, z), mload(add(s, z))) // Copy `a[i]`, backwards.\n                        z := add(z, w) // `sub(z, 0x20)`.\n                        if iszero(z) { break }\n                    }\n                    let e := add(add(m, 0x20), l)\n                    mstore(e, 0) // Zeroize the slot after the copied bytes.\n                    mstore(0x40, add(e, 0x20)) // Allocate memory.\n                    s := m\n                }\n                mstore(c, sub(s, o)) // Convert to calldata offset.\n                let t := add(l, add(s, 0x20))\n                if iszero(lt(t, u)) { u := t }\n            }\n            let retStart := add(a, w) // Assumes `a` doesn't start from scratch space.\n            mstore(retStart, 0x20) // Store the return offset.\n            return(retStart, add(0x40, sub(u, retStart))) // End the transaction.\n        }\n    }\n\n    /// @dev Returns the word at `offset`, without any bounds checks.\n    function load(bytes memory a, uint256 offset) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(a, 0x20), offset))\n        }\n    }\n\n    /// @dev Returns the word at `offset`, without any bounds checks.\n    function loadCalldata(bytes calldata a, uint256 offset)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := calldataload(add(a.offset, offset))\n        }\n    }\n\n    /// @dev Returns a slice representing a static struct in the calldata. Performs bounds checks.\n    function staticStructInCalldata(bytes calldata a, uint256 offset)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := sub(a.length, 0x20)\n            result.offset := add(a.offset, offset)\n            result.length := sub(a.length, offset)\n            if or(shr(64, or(l, a.offset)), gt(offset, l)) { revert(l, 0x00) }\n        }\n    }\n\n    /// @dev Returns a slice representing a dynamic struct in the calldata. Performs bounds checks.\n    function dynamicStructInCalldata(bytes calldata a, uint256 offset)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := sub(a.length, 0x20)\n            let s := calldataload(add(a.offset, offset)) // Relative offset of `result` from `a.offset`.\n            result.offset := add(a.offset, s)\n            result.length := sub(a.length, s)\n            if or(shr(64, or(s, or(l, a.offset))), gt(offset, l)) { revert(l, 0x00) }\n        }\n    }\n\n    /// @dev Returns bytes in calldata. Performs bounds checks.\n    function bytesInCalldata(bytes calldata a, uint256 offset)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := sub(a.length, 0x20)\n            let s := calldataload(add(a.offset, offset)) // Relative offset of `result` from `a.offset`.\n            result.offset := add(add(a.offset, s), 0x20)\n            result.length := calldataload(add(a.offset, s))\n            // forgefmt: disable-next-item\n            if or(shr(64, or(result.length, or(s, or(l, a.offset)))),\n                or(gt(add(s, result.length), l), gt(offset, l))) { revert(l, 0x00) }\n        }\n    }\n\n    /// @dev Returns empty calldata bytes. For silencing the compiler.\n    function emptyCalldata() internal pure returns (bytes calldata result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result.length := 0\n        }\n    }\n}\n"}, "lib/permit2/src/interfaces/IEIP712.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IEIP712 {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"}, "src/types/Components.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nstruct Component {\n    uint256 claimant; // The lockTag + recipient of the transfer or withdrawal.\n    uint256 amount; // The amount of tokens to transfer or withdraw.\n}\n\nstruct ComponentsById {\n    uint256 id; // The token ID of the ERC6909 token to transfer or withdraw.\n    Component[] portions; // claimants and amounts.\n}\n\nstruct TransferComponent {\n    uint256 id; // The token ID of the ERC6909 token to transfer or withdraw.\n    uint256 amount; // The token amount to transfer or withdraw.\n}\n\nstruct BatchClaimComponent {\n    uint256 id; // The token ID of the ERC6909 token to allocate.\n    uint256 allocatedAmount; // The original allocated amount of ERC6909 tokens.\n    Component[] portions; // claimants and amounts.\n}\n"}}, "settings": {"remappings": ["ds-test/=lib/permit2/lib/forge-std/lib/ds-test/src/", "forge-gas-snapshot/=lib/permit2/lib/forge-gas-snapshot/src/", "forge-std/=lib/forge-std/src/", "openzeppelin-contracts/=lib/permit2/lib/openzeppelin-contracts/", "permit2/=lib/permit2/", "solady/=lib/solady/src/", "soledge/=lib/soledge/src/", "solmate/=lib/permit2/lib/solmate/"], "optimizer": {"enabled": false, "runs": 200}, "metadata": {"appendCBOR": false}, "outputSelection": {"*": {"*": ["abi", "metadata", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers", "evm.legacyAssembly", "evm.bytecode.opcodes"]}}, "evmVersion": "prague", "viaIR": true}}